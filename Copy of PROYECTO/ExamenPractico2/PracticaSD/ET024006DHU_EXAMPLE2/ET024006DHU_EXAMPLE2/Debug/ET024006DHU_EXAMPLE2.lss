
ET024006DHU_EXAMPLE2.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00010da0  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  80012e00  80012e00  00013200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00003f40  80013000  80013000  00013400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         00000638  00000008  80016f40  00017408  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          000008c0  00000640  00000640  00000000  2**2
                  ALLOC
  8 .comment      00000030  00000000  00000000  00017a40  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00002188  00000000  00000000  00017a70  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 000047ad  00000000  00000000  00019bf8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0003ce4c  00000000  00000000  0001e3a5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00009246  00000000  00000000  0005b1f1  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00020253  00000000  00000000  00064437  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00005cb0  00000000  00000000  0008468c  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00009c15  00000000  00000000  0008a33c  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    00019f26  00000000  00000000  00093f51  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_macinfo 0223ffce  00000000  00000000  000ade77  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 19 .bss_sdram    00000004  d0000000  d0000000  022ee000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 20 .heap         01fffffc  d0000004  d0000004  00000000  2**0
                  ALLOC
 21 .debug_ranges 00002458  00000000  00000000  022ee008  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe ff 00 04 	ld.w	pc,pc[4]
80002004:	80 00       	ld.sh	r0,r0[0x0]
80002006:	b3 04       	ld.d	r4,r9

Disassembly of section .text:

80002008 <sdramc_ck_delay>:
 * \param ck Number of HSB clock cycles to wait.
 */
static void sdramc_ck_delay(unsigned long ck)
{
  // Use the CPU cycle counter (CPU and HSB clocks are the same).
  unsigned long delay_start_cycle = Get_system_register(AVR32_COUNT);
80002008:	e1 b8 00 42 	mfsr	r8,0x108
  unsigned long delay_end_cycle = delay_start_cycle + ck;
8000200c:	f0 0c 00 0c 	add	r12,r8,r12

  // To be safer, the end of wait is based on an inequality test, so CPU cycle
  // counter wrap around is checked.
  if (delay_start_cycle > delay_end_cycle)
80002010:	18 38       	cp.w	r8,r12
80002012:	e0 88 00 06 	brls	8000201e <sdramc_ck_delay+0x16>
  {
    while ((unsigned long)Get_system_register(AVR32_COUNT) > delay_end_cycle);
80002016:	e1 b8 00 42 	mfsr	r8,0x108
8000201a:	10 3c       	cp.w	r12,r8
8000201c:	cf d3       	brcs	80002016 <sdramc_ck_delay+0xe>
  }
  while ((unsigned long)Get_system_register(AVR32_COUNT) < delay_end_cycle);
8000201e:	e1 b8 00 42 	mfsr	r8,0x108
80002022:	10 3c       	cp.w	r12,r8
80002024:	fe 9b ff fd 	brhi	8000201e <sdramc_ck_delay+0x16>
}
80002028:	5e fc       	retal	r12
8000202a:	d7 03       	nop

8000202c <sdramc_init>:
{
}
#endif

void sdramc_init(unsigned long hsb_hz)
{
8000202c:	d4 31       	pushm	r0-r7,lr
8000202e:	20 2d       	sub	sp,8
80002030:	18 91       	mov	r1,r12
  unsigned long hsb_mhz_dn = hsb_hz / 1000000;
  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
80002032:	ee 7b 42 3f 	mov	r11,999999
80002036:	f8 0b 00 09 	add	r9,r12,r11
8000203a:	e0 60 de 83 	mov	r0,56963
8000203e:	ea 10 43 1b 	orh	r0,0x431b
80002042:	f2 00 06 48 	mulu.d	r8,r9,r0
80002046:	f2 06 16 12 	lsr	r6,r9,0x12
    // Enable clock-related pins.
    {AVR32_EBI_SDCK_0_PIN,            AVR32_EBI_SDCK_0_FUNCTION           },
    {AVR32_EBI_SDCKE_0_PIN,           AVR32_EBI_SDCKE_0_FUNCTION          }
  };

  gpio_enable_module(SDRAMC_EBI_GPIO_MAP, sizeof(SDRAMC_EBI_GPIO_MAP) / sizeof(SDRAMC_EBI_GPIO_MAP[0]));
8000204a:	32 7b       	mov	r11,39
8000204c:	4d 0c       	lddpc	r12,8000218c <sdramc_init+0x160>
8000204e:	f0 1f 00 51 	mcall	80002190 <sdramc_init+0x164>
  // Put the multiplexed MCU pins used for the SDRAM under control of the SDRAMC.
  sdramc_enable_muxed_pins();

  // Enable SDRAM mode for CS1.
#if (defined AVR32_HMATRIX)
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR] |= 1 << AVR32_EBI_SDRAM_CS;
80002052:	fe 68 10 00 	mov	r8,-126976
80002056:	f0 f9 01 24 	ld.w	r9,r8[292]
8000205a:	a1 b9       	sbr	r9,0x1
8000205c:	f1 49 01 24 	st.w	r8[292],r9
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR];
80002060:	f0 f8 01 24 	ld.w	r8,r8[292]
      ((( SDRAM_BANK_BITS                -    1) << AVR32_SDRAMC_CR_NB_OFFSET  ) & AVR32_SDRAMC_CR_NB_MASK  ) |
      ((  SDRAM_CAS                              << AVR32_SDRAMC_CR_CAS_OFFSET ) & AVR32_SDRAMC_CR_CAS_MASK ) |
      ((( SDRAM_DBW                      >>   4) << AVR32_SDRAMC_CR_DBW_OFFSET ) & AVR32_SDRAMC_CR_DBW_MASK ) |
      ((((SDRAM_TWR  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TWR_OFFSET ) & AVR32_SDRAMC_CR_TWR_MASK ) |
      ((((SDRAM_TRC  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRC_OFFSET ) & AVR32_SDRAMC_CR_TRC_MASK ) |
      ((((SDRAM_TRP  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRP_OFFSET ) & AVR32_SDRAMC_CR_TRP_MASK ) |
80002064:	ec 09 15 04 	lsl	r9,r6,0x4
80002068:	0c 19       	sub	r9,r6
8000206a:	f2 c3 fc 19 	sub	r3,r9,-999
8000206e:	e0 65 4d d3 	mov	r5,19923
80002072:	ea 15 10 62 	orh	r5,0x1062
80002076:	e6 05 06 42 	mulu.d	r2,r3,r5
8000207a:	a7 83       	lsr	r3,0x6
#endif

  // Configure the SDRAM Controller with SDRAM setup and timing information.
  // All timings below are rounded up because they are minimal values.
  AVR32_SDRAMC.cr =
      ((( SDRAM_COL_BITS                 -    8) << AVR32_SDRAMC_CR_NC_OFFSET  ) & AVR32_SDRAMC_CR_NC_MASK  ) |
8000207c:	ec 02 15 05 	lsl	r2,r6,0x5
80002080:	0c 02       	add	r2,r6
80002082:	a1 72       	lsl	r2,0x1
80002084:	e4 06 00 0b 	add	r11,r2,r6
80002088:	f6 cb fc 19 	sub	r11,r11,-999
8000208c:	f6 05 06 4a 	mulu.d	r10,r11,r5
80002090:	a7 8b       	lsr	r11,0x6
80002092:	bd 6b       	lsl	r11,0x1c
80002094:	16 9c       	mov	r12,r11
80002096:	e8 1c 00 d9 	orl	r12,0xd9
8000209a:	ec 08 15 03 	lsl	r8,r6,0x3
8000209e:	f0 06 01 0a 	sub	r10,r8,r6
800020a2:	a1 7a       	lsl	r10,0x1
800020a4:	f4 c7 fc 19 	sub	r7,r10,-999
800020a8:	ee 05 06 4a 	mulu.d	r10,r7,r5
800020ac:	fa eb 00 00 	st.d	sp[0],r10
800020b0:	40 0a       	lddsp	r10,sp[0x0]
800020b2:	a3 6a       	lsl	r10,0x2
800020b4:	e2 1a 0f 00 	andl	r10,0xf00,COH
800020b8:	14 4c       	or	r12,r10
800020ba:	a3 69       	lsl	r9,0x2
800020bc:	f2 c9 fc 19 	sub	r9,r9,-999
800020c0:	f2 05 06 4a 	mulu.d	r10,r9,r5
800020c4:	fa eb 00 00 	st.d	sp[0],r10
800020c8:	40 09       	lddsp	r9,sp[0x0]
800020ca:	a7 69       	lsl	r9,0x6
800020cc:	e2 19 f0 00 	andl	r9,0xf000,COH
800020d0:	f9 e9 10 0a 	or	r10,r12,r9
800020d4:	e6 09 15 10 	lsl	r9,r3,0x10
800020d8:	e6 19 00 0f 	andh	r9,0xf,COH
800020dc:	12 4a       	or	r10,r9
800020de:	e6 09 15 14 	lsl	r9,r3,0x14
800020e2:	e6 19 00 f0 	andh	r9,0xf0,COH
800020e6:	12 4a       	or	r10,r9
800020e8:	f0 06 00 09 	add	r9,r8,r6
800020ec:	ec 09 00 29 	add	r9,r6,r9<<0x2
800020f0:	f2 c9 fc 19 	sub	r9,r9,-999
800020f4:	f2 05 06 48 	mulu.d	r8,r9,r5
800020f8:	b3 69       	lsl	r9,0x12
800020fa:	e6 19 0f 00 	andh	r9,0xf00,COH
800020fe:	f5 e9 10 08 	or	r8,r10,r9
  AVR32_HMATRIXB.sfr[AVR32_EBI_HMATRIX_NR];
#endif

  // Configure the SDRAM Controller with SDRAM setup and timing information.
  // All timings below are rounded up because they are minimal values.
  AVR32_SDRAMC.cr =
80002102:	fe 67 20 00 	mov	r7,-122880
80002106:	8f 28       	st.w	r7[0x8],r8
      ((((SDRAM_TRC  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRC_OFFSET ) & AVR32_SDRAMC_CR_TRC_MASK ) |
      ((((SDRAM_TRP  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRP_OFFSET ) & AVR32_SDRAMC_CR_TRP_MASK ) |
      ((((SDRAM_TRCD * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRCD_OFFSET) & AVR32_SDRAMC_CR_TRCD_MASK) |
      ((((SDRAM_TRAS * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRAS_OFFSET) & AVR32_SDRAMC_CR_TRAS_MASK) |
      ((((SDRAM_TXSR * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TXSR_OFFSET) & AVR32_SDRAMC_CR_TXSR_MASK);
  AVR32_SDRAMC.cr;
80002108:	6e 28       	ld.w	r8,r7[0x8]

  // Issue a NOP command to the SDRAM in order to start the generation of SDRAMC signals.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_NOP;
8000210a:	30 18       	mov	r8,1
8000210c:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
8000210e:	6e 08       	ld.w	r8,r7[0x0]
  sdram[0];
80002110:	fc 14 d0 00 	movh	r4,0xd000
80002114:	88 08       	ld.sh	r8,r4[0x0]

  // Wait during the SDRAM stable-clock initialization delay.
  sdramc_us_delay(SDRAM_STABLE_CLOCK_INIT_DELAY, hsb_mhz_up);
80002116:	ec 0c 10 64 	mul	r12,r6,100
8000211a:	f0 1f 00 1f 	mcall	80002194 <sdramc_init+0x168>

  // Issue a PRECHARGE ALL command to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_BANKS_PRECHARGE;
8000211e:	30 28       	mov	r8,2
80002120:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
80002122:	6e 08       	ld.w	r8,r7[0x0]
  sdram[0];
80002124:	88 08       	ld.sh	r8,r4[0x0]
  sdramc_ns_delay(SDRAM_TRP, hsb_mhz_up);
80002126:	06 9c       	mov	r12,r3
80002128:	f0 1f 00 1b 	mcall	80002194 <sdramc_init+0x168>

  // Issue initialization AUTO REFRESH commands to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_AUTO_REFRESH;
8000212c:	30 48       	mov	r8,4
8000212e:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
80002130:	6e 08       	ld.w	r8,r7[0x0]
  for (i = 0; i < SDRAM_INIT_AUTO_REFRESH_COUNT; i++)
  {
    sdram[0];
    sdramc_ns_delay(SDRAM_TRFC, hsb_mhz_up);
80002132:	e4 c3 fc 19 	sub	r3,r2,-999
80002136:	e6 05 06 42 	mulu.d	r2,r3,r5
8000213a:	a7 83       	lsr	r3,0x6
  // Issue initialization AUTO REFRESH commands to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_AUTO_REFRESH;
  AVR32_SDRAMC.mr;
  for (i = 0; i < SDRAM_INIT_AUTO_REFRESH_COUNT; i++)
  {
    sdram[0];
8000213c:	88 08       	ld.sh	r8,r4[0x0]
    sdramc_ns_delay(SDRAM_TRFC, hsb_mhz_up);
8000213e:	06 9c       	mov	r12,r3
80002140:	f0 1f 00 15 	mcall	80002194 <sdramc_init+0x168>
  // Issue initialization AUTO REFRESH commands to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_AUTO_REFRESH;
  AVR32_SDRAMC.mr;
  for (i = 0; i < SDRAM_INIT_AUTO_REFRESH_COUNT; i++)
  {
    sdram[0];
80002144:	88 08       	ld.sh	r8,r4[0x0]
    sdramc_ns_delay(SDRAM_TRFC, hsb_mhz_up);
80002146:	06 9c       	mov	r12,r3
80002148:	f0 1f 00 13 	mcall	80002194 <sdramc_init+0x168>
  //  - bit 3: burst type: sequential (0b);
  //  - bits 4 to 6: CAS latency: AVR32_SDRAMC.CR.cas;
  //  - bits 7 to 8: operating mode: standard operation (00b);
  //  - bit 9: write burst mode: programmed burst length (0b);
  //  - all other bits: reserved: 0b.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_LOAD_MODE;
8000214c:	30 38       	mov	r8,3
8000214e:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
80002150:	6e 08       	ld.w	r8,r7[0x0]
  sdram[0];
80002152:	88 08       	ld.sh	r8,r4[0x0]
  sdramc_ns_delay(SDRAM_TMRD, hsb_mhz_up);
80002154:	ec 09 15 01 	lsl	r9,r6,0x1
80002158:	f2 c9 fc 19 	sub	r9,r9,-999
8000215c:	f2 05 06 48 	mulu.d	r8,r9,r5
80002160:	f2 0c 16 06 	lsr	r12,r9,0x6
80002164:	f0 1f 00 0c 	mcall	80002194 <sdramc_init+0x168>

  // Switch the SDRAM Controller to normal mode.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_NORMAL;
80002168:	30 08       	mov	r8,0
8000216a:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
8000216c:	6e 08       	ld.w	r8,r7[0x0]
  sdram[0];
8000216e:	88 08       	ld.sh	r8,r4[0x0]

  // Write the refresh period into the SDRAMC Refresh Timer Register.
  // tR is rounded down because it is a maximal value.
  AVR32_SDRAMC.tr = (SDRAM_TR * hsb_mhz_dn) / 1000;
80002170:	e2 00 06 40 	mulu.d	r0,r1,r0
80002174:	b3 81       	lsr	r1,0x12
80002176:	e0 68 1e 84 	mov	r8,7812
8000217a:	b1 31       	mul	r1,r8
8000217c:	e2 05 06 44 	mulu.d	r4,r1,r5
80002180:	a7 85       	lsr	r5,0x6
80002182:	8f 15       	st.w	r7[0x4],r5
  AVR32_SDRAMC.tr;
80002184:	6e 18       	ld.w	r8,r7[0x4]
}
80002186:	2f ed       	sub	sp,-8
80002188:	d8 32       	popm	r0-r7,pc
8000218a:	00 00       	add	r0,r0
8000218c:	80 01       	ld.sh	r1,r0[0x0]
8000218e:	30 00       	mov	r0,0
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	85 e4       	st.w	r2[0x38],r4
80002194:	80 00       	ld.sh	r0,r0[0x0]
80002196:	20 08       	sub	r8,0

80002198 <apu_step>:
}
void apu_destroy(APU apu) {
  assert(apu != NULL);
  free(apu);
}
void apu_step(NES nes) {
80002198:	d4 01       	pushm	lr
  assert(nes != NULL);
8000219a:	58 0c       	cp.w	r12,0
8000219c:	c0 71       	brne	800021aa <apu_step+0x12>
8000219e:	48 49       	lddpc	r9,800021ac <apu_step+0x14>
800021a0:	48 4a       	lddpc	r10,800021b0 <apu_step+0x18>
800021a2:	33 9b       	mov	r11,57
800021a4:	48 4c       	lddpc	r12,800021b4 <apu_step+0x1c>
800021a6:	f0 1f 00 05 	mcall	800021b8 <apu_step+0x20>
800021aa:	d8 02       	popm	pc
800021ac:	80 01       	ld.sh	r1,r0[0x0]
800021ae:	31 44       	mov	r4,20
800021b0:	80 01       	ld.sh	r1,r0[0x0]
800021b2:	31 70       	mov	r0,23
800021b4:	80 01       	ld.sh	r1,r0[0x0]
800021b6:	31 50       	mov	r0,21
800021b8:	80 00       	ld.sh	r0,r0[0x0]
800021ba:	c1 a0       	breq	800021ee <apu_init+0x32>

800021bc <apu_init>:
  Byte delta_control;
  Byte delta_da;
  Byte delta_address;
  Byte delta_dataLength;
};
APU apu_init(void) {
800021bc:	d4 01       	pushm	lr
  APU apu = (APU) malloc(sizeof(struct apu));
800021be:	31 3c       	mov	r12,19
800021c0:	f0 1f 00 15 	mcall	80002214 <apu_init+0x58>
  assert(apu != NULL);
800021c4:	c0 71       	brne	800021d2 <apu_init+0x16>
800021c6:	49 59       	lddpc	r9,80002218 <apu_init+0x5c>
800021c8:	49 5a       	lddpc	r10,8000221c <apu_init+0x60>
800021ca:	31 eb       	mov	r11,30
800021cc:	49 5c       	lddpc	r12,80002220 <apu_init+0x64>
800021ce:	f0 1f 00 16 	mcall	80002224 <apu_init+0x68>
  apu->pulse1_control = 0;
800021d2:	30 08       	mov	r8,0
800021d4:	b8 88       	st.b	r12[0x0],r8
  apu->pulse1_rampControl = 0;
800021d6:	b8 98       	st.b	r12[0x1],r8
  apu->pulse1_fineTune = 0;
800021d8:	b8 a8       	st.b	r12[0x2],r8
  apu->pulse1_courseTune = 0;
800021da:	b8 b8       	st.b	r12[0x3],r8
  apu->pulse2_control = 0;
800021dc:	b8 c8       	st.b	r12[0x4],r8
  apu->pulse2_rampControl = 0;
800021de:	b8 d8       	st.b	r12[0x5],r8
  apu->pulse2_fineTune = 0;
800021e0:	b8 e8       	st.b	r12[0x6],r8
  apu->pulse2_courseTune = 0;
800021e2:	b8 f8       	st.b	r12[0x7],r8
  apu->triangle_control1 = 0;
800021e4:	f9 68 00 08 	st.b	r12[8],r8
  apu->triangle_control2 = 0;
800021e8:	f9 68 00 09 	st.b	r12[9],r8
  apu->triangle_frequency1 = 0;
800021ec:	f9 68 00 0a 	st.b	r12[10],r8
  apu->triangle_frequency2 = 0;
800021f0:	f9 68 00 0b 	st.b	r12[11],r8
  apu->noise_control1 = 0;
800021f4:	f9 68 00 0c 	st.b	r12[12],r8
  apu->noise_frequency1 = 0;
800021f8:	f9 68 00 0d 	st.b	r12[13],r8
  apu->noise_frequency2 = 0;
800021fc:	f9 68 00 0e 	st.b	r12[14],r8
  apu->delta_control = 0;
80002200:	f9 68 00 0f 	st.b	r12[15],r8
  apu->delta_da = 0;
80002204:	f9 68 00 10 	st.b	r12[16],r8
  apu->delta_address = 0;
80002208:	f9 68 00 11 	st.b	r12[17],r8
  apu->delta_dataLength = 0;
8000220c:	f9 68 00 12 	st.b	r12[18],r8
  return apu;
}
80002210:	d8 02       	popm	pc
80002212:	00 00       	add	r0,r0
80002214:	80 00       	ld.sh	r0,r0[0x0]
80002216:	c1 fc       	rcall	80002254 <cartridge_getMirrorType+0x1c>
80002218:	80 01       	ld.sh	r1,r0[0x0]
8000221a:	31 64       	mov	r4,22
8000221c:	80 01       	ld.sh	r1,r0[0x0]
8000221e:	31 38       	mov	r8,19
80002220:	80 01       	ld.sh	r1,r0[0x0]
80002222:	31 50       	mov	r0,21
80002224:	80 00       	ld.sh	r0,r0[0x0]
80002226:	c1 a0       	breq	8000225a <cartridge_getMirrorType+0x22>

80002228 <cartridge_readProgramBank>:

Byte cartridge_getNumProgramBanks(Cartridge cartridge1) {
  assert(cartridge1 != NULL);
  return cartridge1->numProgramBanks;
}
Byte cartridge_readProgramBank(Cartridge cartridge1, Byte bank, Address address) {
80002228:	78 48       	ld.w	r8,r12[0x10]
8000222a:	f0 0b 03 28 	ld.w	r8,r8[r11<<0x2]
8000222e:	5c 7a       	castu.h	r10
 // assert(cartridge1 != NULL);
 // assert(bank < cartridge1->numProgramBanks);
//  assert(address < BYTES_PER_PROGRAM_BANK);
  return cartridge1->programBanks[bank]->bytes[address];
}
80002230:	f0 0a 07 0c 	ld.ub	r12,r8[r10]
80002234:	5e fc       	retal	r12
80002236:	d7 03       	nop

80002238 <cartridge_getMirrorType>:
Byte cartridge_getNumCharacterBanks(Cartridge cartridge1) {
  assert(cartridge1 != NULL);
  return cartridge1->numCharacterBanks;
}

MirrorType cartridge_getMirrorType(Cartridge cartridge1) {
80002238:	d4 01       	pushm	lr
  assert(cartridge1 != NULL);
8000223a:	58 0c       	cp.w	r12,0
8000223c:	c0 81       	brne	8000224c <cartridge_getMirrorType+0x14>
8000223e:	48 59       	lddpc	r9,80002250 <cartridge_getMirrorType+0x18>
80002240:	48 5a       	lddpc	r10,80002254 <cartridge_getMirrorType+0x1c>
80002242:	e0 6b 01 18 	mov	r11,280
80002246:	48 5c       	lddpc	r12,80002258 <cartridge_getMirrorType+0x20>
80002248:	f0 1f 00 05 	mcall	8000225c <cartridge_getMirrorType+0x24>
  return (cartridge1->mirrorType);
}
8000224c:	78 1c       	ld.w	r12,r12[0x4]
8000224e:	d8 02       	popm	pc
80002250:	80 01       	ld.sh	r1,r0[0x0]
80002252:	31 f0       	mov	r0,31
80002254:	80 01       	ld.sh	r1,r0[0x0]
80002256:	35 08       	mov	r8,80
80002258:	80 01       	ld.sh	r1,r0[0x0]
8000225a:	32 04       	mov	r4,32
8000225c:	80 00       	ld.sh	r0,r0[0x0]
8000225e:	c1 a0       	breq	80002292 <cartridge_getMMUNumber+0xa>

80002260 <cartridge_getNumCharacterBanks>:
}
Byte cartridge_getMMUNumber(Cartridge cartridge1) {
  assert(cartridge1 != NULL);
  return cartridge1->mmuNumber;
}
Byte cartridge_getNumCharacterBanks(Cartridge cartridge1) {
80002260:	d4 01       	pushm	lr
  assert(cartridge1 != NULL);
80002262:	58 0c       	cp.w	r12,0
80002264:	c0 81       	brne	80002274 <cartridge_getNumCharacterBanks+0x14>
80002266:	48 59       	lddpc	r9,80002278 <cartridge_getNumCharacterBanks+0x18>
80002268:	48 5a       	lddpc	r10,8000227c <cartridge_getNumCharacterBanks+0x1c>
8000226a:	e0 6b 01 13 	mov	r11,275
8000226e:	48 5c       	lddpc	r12,80002280 <cartridge_getNumCharacterBanks+0x20>
80002270:	f0 1f 00 05 	mcall	80002284 <cartridge_getNumCharacterBanks+0x24>
  return cartridge1->numCharacterBanks;
}
80002274:	19 9c       	ld.ub	r12,r12[0x1]
80002276:	d8 02       	popm	pc
80002278:	80 01       	ld.sh	r1,r0[0x0]
8000227a:	31 f0       	mov	r0,31
8000227c:	80 01       	ld.sh	r1,r0[0x0]
8000227e:	31 d0       	mov	r0,29
80002280:	80 01       	ld.sh	r1,r0[0x0]
80002282:	32 04       	mov	r4,32
80002284:	80 00       	ld.sh	r0,r0[0x0]
80002286:	c1 a0       	breq	800022ba <cartridge_readCharacterBank+0x6>

80002288 <cartridge_getMMUNumber>:
  for (i=0; i < cartridge1->numProgramBanks; i++) {
    free(cartridge1->programBanks[i]);
  }
  free(cartridge1);
}
Byte cartridge_getMMUNumber(Cartridge cartridge1) {
80002288:	d4 01       	pushm	lr
  assert(cartridge1 != NULL);
8000228a:	58 0c       	cp.w	r12,0
8000228c:	c0 81       	brne	8000229c <cartridge_getMMUNumber+0x14>
8000228e:	48 69       	lddpc	r9,800022a4 <cartridge_getMMUNumber+0x1c>
80002290:	48 6a       	lddpc	r10,800022a8 <cartridge_getMMUNumber+0x20>
80002292:	e0 6b 01 0f 	mov	r11,271
80002296:	48 6c       	lddpc	r12,800022ac <cartridge_getMMUNumber+0x24>
80002298:	f0 1f 00 06 	mcall	800022b0 <cartridge_getMMUNumber+0x28>
  return cartridge1->mmuNumber;
}
8000229c:	f9 3c 00 0a 	ld.ub	r12,r12[10]
800022a0:	d8 02       	popm	pc
800022a2:	00 00       	add	r0,r0
800022a4:	80 01       	ld.sh	r1,r0[0x0]
800022a6:	31 f0       	mov	r0,31
800022a8:	80 01       	ld.sh	r1,r0[0x0]
800022aa:	31 ac       	mov	r12,26
800022ac:	80 01       	ld.sh	r1,r0[0x0]
800022ae:	32 04       	mov	r4,32
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	c1 a0       	breq	800022e6 <cartridge_readCharacterBank+0x32>

800022b4 <cartridge_readCharacterBank>:
 // assert(cartridge1 != NULL);
 // assert(bank < cartridge1->numProgramBanks);
//  assert(address < BYTES_PER_PROGRAM_BANK);
  return cartridge1->programBanks[bank]->bytes[address];
}
Byte cartridge_readCharacterBank(Cartridge cartridge1, Byte bank, Address address) {
800022b4:	d4 01       	pushm	lr
  assert(cartridge1 != NULL);
800022b6:	58 0c       	cp.w	r12,0
800022b8:	c0 71       	brne	800022c6 <cartridge_readCharacterBank+0x12>
800022ba:	49 39       	lddpc	r9,80002304 <cartridge_readCharacterBank+0x50>
800022bc:	49 3a       	lddpc	r10,80002308 <cartridge_readCharacterBank+0x54>
800022be:	36 cb       	mov	r11,108
800022c0:	49 3c       	lddpc	r12,8000230c <cartridge_readCharacterBank+0x58>
800022c2:	f0 1f 00 14 	mcall	80002310 <cartridge_readCharacterBank+0x5c>
  assert(bank < cartridge1->numCharacterBanks);
800022c6:	19 98       	ld.ub	r8,r12[0x1]
800022c8:	f6 08 18 00 	cp.b	r8,r11
800022cc:	e0 8b 00 08 	brhi	800022dc <cartridge_readCharacterBank+0x28>
800022d0:	49 19       	lddpc	r9,80002314 <cartridge_readCharacterBank+0x60>
800022d2:	48 ea       	lddpc	r10,80002308 <cartridge_readCharacterBank+0x54>
800022d4:	36 db       	mov	r11,109
800022d6:	48 ec       	lddpc	r12,8000230c <cartridge_readCharacterBank+0x58>
800022d8:	f0 1f 00 0e 	mcall	80002310 <cartridge_readCharacterBank+0x5c>
  assert(address < BYTES_PER_CHARACTER_BANK);
800022dc:	e0 68 1f ff 	mov	r8,8191
800022e0:	f0 0a 19 00 	cp.h	r10,r8
800022e4:	e0 88 00 08 	brls	800022f4 <cartridge_readCharacterBank+0x40>
800022e8:	48 c9       	lddpc	r9,80002318 <cartridge_readCharacterBank+0x64>
800022ea:	48 8a       	lddpc	r10,80002308 <cartridge_readCharacterBank+0x54>
800022ec:	36 eb       	mov	r11,110
800022ee:	48 8c       	lddpc	r12,8000230c <cartridge_readCharacterBank+0x58>
800022f0:	f0 1f 00 08 	mcall	80002310 <cartridge_readCharacterBank+0x5c>
800022f4:	78 38       	ld.w	r8,r12[0xc]
800022f6:	f0 0b 03 28 	ld.w	r8,r8[r11<<0x2]
800022fa:	5c 7a       	castu.h	r10
  return cartridge1->characterBanks[bank]->bytes[address];
}
800022fc:	f0 0a 07 0c 	ld.ub	r12,r8[r10]
80002300:	d8 02       	popm	pc
80002302:	00 00       	add	r0,r0
80002304:	80 01       	ld.sh	r1,r0[0x0]
80002306:	31 f0       	mov	r0,31
80002308:	80 01       	ld.sh	r1,r0[0x0]
8000230a:	31 7c       	mov	r12,23
8000230c:	80 01       	ld.sh	r1,r0[0x0]
8000230e:	32 04       	mov	r4,32
80002310:	80 00       	ld.sh	r0,r0[0x0]
80002312:	c1 a0       	breq	80002346 <initHeader+0x2>
80002314:	80 01       	ld.sh	r1,r0[0x0]
80002316:	32 1c       	mov	r12,33
80002318:	80 01       	ld.sh	r1,r0[0x0]
8000231a:	32 44       	mov	r4,36

8000231c <cartridge_getNumProgramBanks>:
	};




Byte cartridge_getNumProgramBanks(Cartridge cartridge1) {
8000231c:	d4 01       	pushm	lr
  assert(cartridge1 != NULL);
8000231e:	58 0c       	cp.w	r12,0
80002320:	c0 71       	brne	8000232e <cartridge_getNumProgramBanks+0x12>
80002322:	48 59       	lddpc	r9,80002334 <cartridge_getNumProgramBanks+0x18>
80002324:	48 5a       	lddpc	r10,80002338 <cartridge_getNumProgramBanks+0x1c>
80002326:	36 2b       	mov	r11,98
80002328:	48 5c       	lddpc	r12,8000233c <cartridge_getNumProgramBanks+0x20>
8000232a:	f0 1f 00 06 	mcall	80002340 <cartridge_getNumProgramBanks+0x24>
  return cartridge1->numProgramBanks;
}
8000232e:	19 8c       	ld.ub	r12,r12[0x0]
80002330:	d8 02       	popm	pc
80002332:	00 00       	add	r0,r0
80002334:	80 01       	ld.sh	r1,r0[0x0]
80002336:	31 f0       	mov	r0,31
80002338:	80 01       	ld.sh	r1,r0[0x0]
8000233a:	35 20       	mov	r0,82
8000233c:	80 01       	ld.sh	r1,r0[0x0]
8000233e:	32 04       	mov	r4,32
80002340:	80 00       	ld.sh	r0,r0[0x0]
80002342:	c1 a0       	breq	80002376 <initHeader+0x32>

80002344 <initHeader>:
  Byte  controlByte2;
  Byte  numRamBanks;
  Byte  magicReservedValues[7];
};

void initHeader( Header header1){
80002344:	eb cd 40 e0 	pushm	r5-r7,lr
80002348:	20 1d       	sub	sp,4
8000234a:	18 97       	mov	r7,r12
	//file_read_buf(&(header1->magicLabel),sizeof(header1->magicLabel));
	
	header1->magicLabel[0]=(uint8_t)file_getc();
8000234c:	f0 1f 00 1e 	mcall	800023c4 <initHeader+0x80>
80002350:	ae 8c       	st.b	r7[0x0],r12
	header1->magicLabel[1]=(uint8_t)file_getc();
80002352:	f0 1f 00 1d 	mcall	800023c4 <initHeader+0x80>
80002356:	ae 9c       	st.b	r7[0x1],r12
	header1->magicLabel[2]=(uint8_t)file_getc();
80002358:	f0 1f 00 1b 	mcall	800023c4 <initHeader+0x80>
8000235c:	ae ac       	st.b	r7[0x2],r12
	char mensaje[]={""};
8000235e:	49 b8       	lddpc	r8,800023c8 <initHeader+0x84>
80002360:	11 88       	ld.ub	r8,r8[0x0]
80002362:	ba 88       	st.b	sp[0x0],r8
	char z;
	
	

sprintf(mensaje,"%c",header1->magicLabel[0]);
80002364:	49 a6       	lddpc	r6,800023cc <initHeader+0x88>
80002366:	1a 95       	mov	r5,sp
80002368:	0f 88       	ld.ub	r8,r7[0x0]
8000236a:	1a d8       	st.w	--sp,r8
8000236c:	0c 9b       	mov	r11,r6
8000236e:	0a 9c       	mov	r12,r5
80002370:	f0 1f 00 18 	mcall	800023d0 <initHeader+0x8c>
//et024006_PrintString(mensaje,(const unsigned char*)&FONT8x8,10,110+(l+=10),BLUE,-1);
//usart_write_line(&AVR32_USART0,mensaje);


sprintf(mensaje,"%c",header1->magicLabel[1]);
80002374:	0f 98       	ld.ub	r8,r7[0x1]
80002376:	1a d8       	st.w	--sp,r8
80002378:	0c 9b       	mov	r11,r6
8000237a:	0a 9c       	mov	r12,r5
8000237c:	f0 1f 00 15 	mcall	800023d0 <initHeader+0x8c>
//et024006_PrintString(mensaje,(const unsigned char*)&FONT8x8,10,110+(l+=10),BLUE,-1);
//usart_write_line(&AVR32_USART0,mensaje);


sprintf(mensaje,"%c",header1->magicLabel[2]);
80002380:	0f a8       	ld.ub	r8,r7[0x2]
80002382:	1a d8       	st.w	--sp,r8
80002384:	0c 9b       	mov	r11,r6
80002386:	0a 9c       	mov	r12,r5
80002388:	f0 1f 00 12 	mcall	800023d0 <initHeader+0x8c>
//et024006_PrintString(mensaje,(const unsigned char*)&FONT8x8,10,110+(l+=10),BLUE,-1);
//usart_write_line(&AVR32_USART0,mensaje);
	
	header1->magicValue= file_getc();
8000238c:	f0 1f 00 0e 	mcall	800023c4 <initHeader+0x80>
80002390:	ae bc       	st.b	r7[0x3],r12
	header1->numProgramBanks= file_getc();
80002392:	f0 1f 00 0d 	mcall	800023c4 <initHeader+0x80>
80002396:	ae cc       	st.b	r7[0x4],r12
	header1->numCharacterBanks= file_getc();
80002398:	f0 1f 00 0b 	mcall	800023c4 <initHeader+0x80>
8000239c:	ae dc       	st.b	r7[0x5],r12
	header1->controlByte1= file_getc();
8000239e:	f0 1f 00 0a 	mcall	800023c4 <initHeader+0x80>
800023a2:	ae ec       	st.b	r7[0x6],r12
	header1->controlByte2= file_getc();
800023a4:	f0 1f 00 08 	mcall	800023c4 <initHeader+0x80>
800023a8:	ae fc       	st.b	r7[0x7],r12
	header1->numRamBanks= file_getc();
800023aa:	f0 1f 00 07 	mcall	800023c4 <initHeader+0x80>
800023ae:	ef 6c 00 08 	st.b	r7[8],r12
	file_read_buf(header1->magicReservedValues,sizeof(header1->magicReservedValues));
800023b2:	30 7b       	mov	r11,7
800023b4:	ee cc ff f7 	sub	r12,r7,-9
800023b8:	f0 1f 00 07 	mcall	800023d4 <initHeader+0x90>
800023bc:	2f dd       	sub	sp,-12
	};
800023be:	2f fd       	sub	sp,-4
800023c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800023c4:	80 00       	ld.sh	r0,r0[0x0]
800023c6:	a7 bc       	sbr	r12,0x7
800023c8:	80 01       	ld.sh	r1,r0[0x0]
800023ca:	34 84       	mov	r4,72
800023cc:	80 01       	ld.sh	r1,r0[0x0]
800023ce:	32 68       	mov	r8,38
800023d0:	80 00       	ld.sh	r0,r0[0x0]
800023d2:	c7 e0       	breq	800024ce <cartridge_init+0xf6>
800023d4:	80 00       	ld.sh	r0,r0[0x0]
800023d6:	a8 28       	st.h	r4[0x4],r8

800023d8 <cartridge_init>:

static void parseTitle(Cartridge cartridge1) {
  assert(cartridge1 != NULL);
  //fread(cartridge->title, sizeof(Byte), 128, file);
}
Cartridge cartridge_init( int filename) {
800023d8:	d4 21       	pushm	r4-r7,lr
  Cartridge cartridge1 = malloc(sizeof(struct cartridge));
800023da:	e0 6c 00 94 	mov	r12,148
800023de:	f0 1f 00 98 	mcall	8000263c <cartridge_init+0x264>
800023e2:	18 97       	mov	r7,r12
  assert(cartridge1 != NULL);
800023e4:	c0 b1       	brne	800023fa <cartridge_init+0x22>
800023e6:	fe f9 02 5a 	ld.w	r9,pc[602]
800023ea:	fe fa 02 5a 	ld.w	r10,pc[602]
800023ee:	e0 6b 00 e8 	mov	r11,232
800023f2:	fe fc 02 56 	ld.w	r12,pc[598]
800023f6:	f0 1f 00 96 	mcall	8000264c <cartridge_init+0x274>
  //nav_filterlist_goto((uint16_t)filename); 
  
  //file_open(FOPEN_MODE_R);
  //assert(file != NULL);
  cartridge1->numProgramBanks = 0;
800023fa:	30 08       	mov	r8,0
800023fc:	b8 88       	st.b	r12[0x0],r8
  cartridge1->numCharacterBanks = 0;
800023fe:	b8 98       	st.b	r12[0x1],r8
  cartridge1->mirrorType = HORIZONTAL;
80002400:	30 09       	mov	r9,0
80002402:	99 19       	st.w	r12[0x4],r9
  cartridge1->hasBatteryPack = FALSE;
80002404:	f9 68 00 08 	st.b	r12[8],r8
  cartridge1->hasTrainer = FALSE;
80002408:	f9 68 00 09 	st.b	r12[9],r8
  cartridge1->mmuNumber = 0;
8000240c:	f9 68 00 0a 	st.b	r12[10],r8
  cartridge1->numRamBanks = 0;
80002410:	f9 68 00 0b 	st.b	r12[11],r8
  cartridge1->characterBanks = NULL;
80002414:	99 39       	st.w	r12[0xc],r9
  cartridge1->programBanks = NULL;
80002416:	99 49       	st.w	r12[0x10],r9
  cartridge1->title[0] = 0;
80002418:	f9 68 00 14 	st.b	r12[20],r8
//static void parseHeader(Cartridge cartridge, FILE *file) {
static void parseHeader(Cartridge cartridge1) {
  //assert(cartridge1 != NULL);
  //assert(file != NULL);
  //file_seek(0, FS_SEEK_SET);
  Header header1 = malloc(sizeof(struct header));
8000241c:	31 0c       	mov	r12,16
8000241e:	f0 1f 00 88 	mcall	8000263c <cartridge_init+0x264>
80002422:	18 96       	mov	r6,r12
  //assert(fread(header, sizeof(struct header), 1, file) == 1);
 // file_read_buf( header,sizeof(struct header));
  //memcpy(&rawData[0],&header,sizeof(struct header));
  
  initHeader(header1);
80002424:	f0 1f 00 8b 	mcall	80002650 <cartridge_init+0x278>
  //usart_write_line(&AVR32_USART0,"parsing Header");
  assert(header1->magicLabel[0] == 'N');
80002428:	0d 89       	ld.ub	r9,r6[0x0]
8000242a:	34 e8       	mov	r8,78
8000242c:	f0 09 18 00 	cp.b	r9,r8
80002430:	c0 a0       	breq	80002444 <cartridge_init+0x6c>
80002432:	fe f9 02 22 	ld.w	r9,pc[546]
80002436:	fe fa 02 22 	ld.w	r10,pc[546]
8000243a:	37 db       	mov	r11,125
8000243c:	fe fc 02 0c 	ld.w	r12,pc[524]
80002440:	f0 1f 00 83 	mcall	8000264c <cartridge_init+0x274>
  assert(header1->magicLabel[1] == 'E');
80002444:	0d 99       	ld.ub	r9,r6[0x1]
80002446:	34 58       	mov	r8,69
80002448:	f0 09 18 00 	cp.b	r9,r8
8000244c:	c0 90       	breq	8000245e <cartridge_init+0x86>
8000244e:	fe f9 02 0e 	ld.w	r9,pc[526]
80002452:	fe fa 02 06 	ld.w	r10,pc[518]
80002456:	37 eb       	mov	r11,126
80002458:	4f cc       	lddpc	r12,80002648 <cartridge_init+0x270>
8000245a:	f0 1f 00 7d 	mcall	8000264c <cartridge_init+0x274>
  assert(header1->magicLabel[2] == 'S');
8000245e:	0d a9       	ld.ub	r9,r6[0x2]
80002460:	35 38       	mov	r8,83
80002462:	f0 09 18 00 	cp.b	r9,r8
80002466:	c0 70       	breq	80002474 <cartridge_init+0x9c>
80002468:	4f e9       	lddpc	r9,80002660 <cartridge_init+0x288>
8000246a:	4f ca       	lddpc	r10,80002658 <cartridge_init+0x280>
8000246c:	37 fb       	mov	r11,127
8000246e:	4f 7c       	lddpc	r12,80002648 <cartridge_init+0x270>
80002470:	f0 1f 00 77 	mcall	8000264c <cartridge_init+0x274>
  //usart_write_line(&AVR32_USART0,"parsing Header2");
  assert(header1->magicValue == 0x1A);
80002474:	0d b9       	ld.ub	r9,r6[0x3]
80002476:	31 a8       	mov	r8,26
80002478:	f0 09 18 00 	cp.b	r9,r8
8000247c:	c0 80       	breq	8000248c <cartridge_init+0xb4>
8000247e:	4f a9       	lddpc	r9,80002664 <cartridge_init+0x28c>
80002480:	4f 6a       	lddpc	r10,80002658 <cartridge_init+0x280>
80002482:	e0 6b 00 81 	mov	r11,129
80002486:	4f 1c       	lddpc	r12,80002648 <cartridge_init+0x270>
80002488:	f0 1f 00 71 	mcall	8000264c <cartridge_init+0x274>
  //usart_write_line(&AVR32_USART0,"parsing Header3");
  cartridge1->numProgramBanks = header1->numProgramBanks;
8000248c:	0d c8       	ld.ub	r8,r6[0x4]
8000248e:	ae 88       	st.b	r7[0x0],r8
  assert(cartridge1->numProgramBanks > 0);
80002490:	58 08       	cp.w	r8,0
80002492:	c0 81       	brne	800024a2 <cartridge_init+0xca>
80002494:	4f 59       	lddpc	r9,80002668 <cartridge_init+0x290>
80002496:	4f 1a       	lddpc	r10,80002658 <cartridge_init+0x280>
80002498:	e0 6b 00 84 	mov	r11,132
8000249c:	4e bc       	lddpc	r12,80002648 <cartridge_init+0x270>
8000249e:	f0 1f 00 6c 	mcall	8000264c <cartridge_init+0x274>
  //usart_write_line(&AVR32_USART0,"parsing Header4");
  cartridge1->numCharacterBanks = header1->numCharacterBanks;
800024a2:	0d d8       	ld.ub	r8,r6[0x5]
800024a4:	ae 98       	st.b	r7[0x1],r8
  cartridge1->numRamBanks = header1->numRamBanks;
800024a6:	ed 38 00 08 	ld.ub	r8,r6[8]
800024aa:	ef 68 00 0b 	st.b	r7[11],r8
  if ((header1->controlByte1 & MASK_BIT3) == MASK_BIT3) {
800024ae:	0d e8       	ld.ub	r8,r6[0x6]
800024b0:	10 99       	mov	r9,r8
800024b2:	e2 19 00 08 	andl	r9,0x8,COH
800024b6:	c0 40       	breq	800024be <cartridge_init+0xe6>
    cartridge1->mirrorType = BOTH;
800024b8:	30 28       	mov	r8,2
800024ba:	8f 18       	st.w	r7[0x4],r8
800024bc:	c0 98       	rjmp	800024ce <cartridge_init+0xf6>
  } else if ((header1->controlByte1 & MASK_BIT0) == 0) {
800024be:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
    cartridge1->mirrorType = HORIZONTAL;
800024c2:	ef f8 0a 01 	st.weq	r7[0x4],r8
  } else if ((header1->controlByte1 & MASK_BIT0) == MASK_BIT0) {
    cartridge1->mirrorType = VERTICAL;
800024c6:	f9 b8 01 01 	movne	r8,1
800024ca:	ef f8 1a 01 	st.wne	r7[0x4],r8
  } else {
    assert(FALSE);
  }
  if ((header1->controlByte1 & MASK_BIT1) == MASK_BIT1) {
800024ce:	0d e8       	ld.ub	r8,r6[0x6]
800024d0:	e2 18 00 02 	andl	r8,0x2,COH
    cartridge1->hasBatteryPack = 1;
800024d4:	f9 b8 01 01 	movne	r8,1
800024d8:	ef f8 1e 08 	st.bne	r7[0x8],r8
  } else {
    cartridge1->hasBatteryPack = 0;
800024dc:	f9 b8 00 00 	moveq	r8,0
800024e0:	ef f8 0e 08 	st.beq	r7[0x8],r8
  }
  if ((header1->controlByte1 & MASK_BIT2) == MASK_BIT2) {
800024e4:	0d e8       	ld.ub	r8,r6[0x6]
800024e6:	e2 18 00 04 	andl	r8,0x4,COH
    cartridge1->hasTrainer = 1;
800024ea:	f9 b8 01 01 	movne	r8,1
800024ee:	ef f8 1e 09 	st.bne	r7[0x9],r8
  } else {
    cartridge1->hasTrainer = 0;
800024f2:	f9 b8 00 00 	moveq	r8,0
800024f6:	ef f8 0e 09 	st.beq	r7[0x9],r8
  }
  cartridge1->mmuNumber = (header1->controlByte1 & (MASK_BIT4 | MASK_BIT5 | MASK_BIT6 |MASK_BIT7)) >> 4;
800024fa:	0d e9       	ld.ub	r9,r6[0x6]
800024fc:	a5 89       	lsr	r9,0x4
  cartridge1->mmuNumber += header1->controlByte2 & (MASK_BIT4 | MASK_BIT5 | MASK_BIT6 |MASK_BIT7);
800024fe:	0d f8       	ld.ub	r8,r6[0x7]
80002500:	10 9a       	mov	r10,r8
80002502:	e2 1a 00 f0 	andl	r10,0xf0,COH
80002506:	f4 09 00 09 	add	r9,r10,r9
8000250a:	ef 69 00 0a 	st.b	r7[10],r9
  assert((header1->controlByte2 & MASK_BIT0) == 0);
8000250e:	f3 d8 c0 01 	bfextu	r9,r8,0x0,0x1
80002512:	c0 80       	breq	80002522 <cartridge_init+0x14a>
80002514:	4d 69       	lddpc	r9,8000266c <cartridge_init+0x294>
80002516:	4d 1a       	lddpc	r10,80002658 <cartridge_init+0x280>
80002518:	e0 6b 00 9d 	mov	r11,157
8000251c:	4c bc       	lddpc	r12,80002648 <cartridge_init+0x270>
8000251e:	f0 1f 00 4c 	mcall	8000264c <cartridge_init+0x274>
  assert((header1->controlByte2 & MASK_BIT1) == 0);
80002522:	10 99       	mov	r9,r8
80002524:	e2 19 00 02 	andl	r9,0x2,COH
80002528:	c0 80       	breq	80002538 <cartridge_init+0x160>
8000252a:	4d 29       	lddpc	r9,80002670 <cartridge_init+0x298>
8000252c:	4c ba       	lddpc	r10,80002658 <cartridge_init+0x280>
8000252e:	e0 6b 00 9e 	mov	r11,158
80002532:	4c 6c       	lddpc	r12,80002648 <cartridge_init+0x270>
80002534:	f0 1f 00 46 	mcall	8000264c <cartridge_init+0x274>
  assert((header1->controlByte2 & MASK_BIT2) == 0);
80002538:	10 99       	mov	r9,r8
8000253a:	e2 19 00 04 	andl	r9,0x4,COH
8000253e:	c0 80       	breq	8000254e <cartridge_init+0x176>
80002540:	4c d9       	lddpc	r9,80002674 <cartridge_init+0x29c>
80002542:	4c 6a       	lddpc	r10,80002658 <cartridge_init+0x280>
80002544:	e0 6b 00 9f 	mov	r11,159
80002548:	4c 0c       	lddpc	r12,80002648 <cartridge_init+0x270>
8000254a:	f0 1f 00 41 	mcall	8000264c <cartridge_init+0x274>
  assert((header1->controlByte2 & MASK_BIT3) == 0);
8000254e:	e2 18 00 08 	andl	r8,0x8,COH
80002552:	c0 80       	breq	80002562 <cartridge_init+0x18a>
80002554:	4c 99       	lddpc	r9,80002678 <cartridge_init+0x2a0>
80002556:	4c 1a       	lddpc	r10,80002658 <cartridge_init+0x280>
80002558:	e0 6b 00 a0 	mov	r11,160
8000255c:	4b bc       	lddpc	r12,80002648 <cartridge_init+0x270>
8000255e:	f0 1f 00 3c 	mcall	8000264c <cartridge_init+0x274>
    assert(header1->magicReservedValues[i] == 0);
  }
  */
  //usart_write_line(&AVR32_USART0,"parsing Header6");
  
  file_seek(sizeof(struct header), FS_SEEK_SET);
80002562:	30 0b       	mov	r11,0
80002564:	31 0c       	mov	r12,16
80002566:	f0 1f 00 46 	mcall	8000267c <cartridge_init+0x2a4>
  if (cartridge1->hasTrainer) {
8000256a:	ef 39 00 09 	ld.ub	r9,r7[9]
8000256e:	30 08       	mov	r8,0
80002570:	f0 09 18 00 	cp.b	r9,r8
80002574:	c0 60       	breq	80002580 <cartridge_init+0x1a8>
    file_seek(TRAINER_BYTES, FS_SEEK_CUR_FW);
80002576:	30 3b       	mov	r11,3
80002578:	e0 6c 02 00 	mov	r12,512
8000257c:	f0 1f 00 40 	mcall	8000267c <cartridge_init+0x2a4>
  }
  free(header1);
80002580:	0c 9c       	mov	r12,r6
80002582:	f0 1f 00 40 	mcall	80002680 <cartridge_init+0x2a8>
//static void parseProgramBanks(Cartridge cartridge, FILE *file) {
static void parseProgramBanks(Cartridge cartridge1) {
  assert(cartridge1 != NULL);
  //usart_write_line(&AVR32_USART0,"parse BANK1");
  //assert(file != NULL);
  cartridge1->programBanks = (ProgramBank*) malloc(sizeof(ProgramBank) * cartridge1->numProgramBanks);
80002586:	0f 8c       	ld.ub	r12,r7[0x0]
80002588:	a3 6c       	lsl	r12,0x2
8000258a:	f0 1f 00 2d 	mcall	8000263c <cartridge_init+0x264>
8000258e:	8f 4c       	st.w	r7[0x10],r12
  assert(cartridge1->programBanks != NULL);
80002590:	c0 60       	breq	8000259c <cartridge_init+0x1c4>
  //usart_write_line(&AVR32_USART0,"parsing Bak2");
  int i;
 // Byte bytes[BYTES_PER_PROGRAM_BANK];
  for (i=0; i < cartridge1->numProgramBanks; i++) {
80002592:	0f 88       	ld.ub	r8,r7[0x0]
80002594:	58 08       	cp.w	r8,0
80002596:	e0 89 00 0a 	brgt	800025aa <cartridge_init+0x1d2>
8000259a:	c2 18       	rjmp	800025dc <cartridge_init+0x204>
static void parseProgramBanks(Cartridge cartridge1) {
  assert(cartridge1 != NULL);
  //usart_write_line(&AVR32_USART0,"parse BANK1");
  //assert(file != NULL);
  cartridge1->programBanks = (ProgramBank*) malloc(sizeof(ProgramBank) * cartridge1->numProgramBanks);
  assert(cartridge1->programBanks != NULL);
8000259c:	4b a9       	lddpc	r9,80002684 <cartridge_init+0x2ac>
8000259e:	4b ba       	lddpc	r10,80002688 <cartridge_init+0x2b0>
800025a0:	e0 6b 00 b9 	mov	r11,185
800025a4:	4a 9c       	lddpc	r12,80002648 <cartridge_init+0x270>
800025a6:	f0 1f 00 2a 	mcall	8000264c <cartridge_init+0x274>
800025aa:	30 06       	mov	r6,0
  //usart_write_line(&AVR32_USART0,"parsing Bak2");
  int i;
 // Byte bytes[BYTES_PER_PROGRAM_BANK];
  for (i=0; i < cartridge1->numProgramBanks; i++) {
    ProgramBank programBank1 = malloc(sizeof(struct programBank));
800025ac:	e0 64 40 00 	mov	r4,16384
800025b0:	08 9c       	mov	r12,r4
800025b2:	f0 1f 00 23 	mcall	8000263c <cartridge_init+0x264>
800025b6:	18 95       	mov	r5,r12
    
	assert(programBank1 != NULL);
800025b8:	c0 81       	brne	800025c8 <cartridge_init+0x1f0>
800025ba:	4b 59       	lddpc	r9,8000268c <cartridge_init+0x2b4>
800025bc:	4b 3a       	lddpc	r10,80002688 <cartridge_init+0x2b0>
800025be:	e0 6b 00 c0 	mov	r11,192
800025c2:	4a 2c       	lddpc	r12,80002648 <cartridge_init+0x270>
800025c4:	f0 1f 00 22 	mcall	8000264c <cartridge_init+0x274>
	//usart_write_line(&AVR32_USART0,"parsing Bak3");
    //assert(fread(programBank, sizeof(struct programBank), 1, file) == 1);
    //memcpy(&rawData[sizeof(struct header)-1+i*sizeof(struct programBank)],programBank,sizeof(struct programBank));
    //file_read_buf(bytes,sizeof(bytes));
	file_read_buf(programBank1,sizeof(struct programBank));
800025c8:	08 9b       	mov	r11,r4
800025ca:	f0 1f 00 32 	mcall	80002690 <cartridge_init+0x2b8>
	cartridge1->programBanks[i]=programBank1;
800025ce:	6e 48       	ld.w	r8,r7[0x10]
800025d0:	f0 06 09 25 	st.w	r8[r6<<0x2],r5
  cartridge1->programBanks = (ProgramBank*) malloc(sizeof(ProgramBank) * cartridge1->numProgramBanks);
  assert(cartridge1->programBanks != NULL);
  //usart_write_line(&AVR32_USART0,"parsing Bak2");
  int i;
 // Byte bytes[BYTES_PER_PROGRAM_BANK];
  for (i=0; i < cartridge1->numProgramBanks; i++) {
800025d4:	2f f6       	sub	r6,-1
800025d6:	0f 88       	ld.ub	r8,r7[0x0]
800025d8:	10 36       	cp.w	r6,r8
800025da:	ce b5       	brlt	800025b0 <cartridge_init+0x1d8>
//static void parseCharacterBanks(Cartridge cartridge, FILE *file) {
static void parseCharacterBanks(Cartridge cartridge1) {
  assert(cartridge1 != NULL);
  //usart_write_line(&AVR32_USART0,"parsing Bak4");
 // assert(file != NULL);
  cartridge1->characterBanks = (CharacterBank*) malloc(sizeof(struct characterBank) * cartridge1->numCharacterBanks);
800025dc:	0f 9c       	ld.ub	r12,r7[0x1]
800025de:	ad 7c       	lsl	r12,0xd
800025e0:	f0 1f 00 17 	mcall	8000263c <cartridge_init+0x264>
800025e4:	8f 3c       	st.w	r7[0xc],r12
  assert(cartridge1->characterBanks != NULL);
800025e6:	c0 60       	breq	800025f2 <cartridge_init+0x21a>
  //usart_write_line(&AVR32_USART0,"parsing Bak5");
  int i;
//  Byte bytes[BYTES_PER_CHARACTER_BANK];
  for (i=0; i < cartridge1->numCharacterBanks; i++) {
800025e8:	0f 98       	ld.ub	r8,r7[0x1]
800025ea:	58 08       	cp.w	r8,0
800025ec:	e0 89 00 0a 	brgt	80002600 <cartridge_init+0x228>
800025f0:	c2 18       	rjmp	80002632 <cartridge_init+0x25a>
static void parseCharacterBanks(Cartridge cartridge1) {
  assert(cartridge1 != NULL);
  //usart_write_line(&AVR32_USART0,"parsing Bak4");
 // assert(file != NULL);
  cartridge1->characterBanks = (CharacterBank*) malloc(sizeof(struct characterBank) * cartridge1->numCharacterBanks);
  assert(cartridge1->characterBanks != NULL);
800025f2:	4a 99       	lddpc	r9,80002694 <cartridge_init+0x2bc>
800025f4:	4a 9a       	lddpc	r10,80002698 <cartridge_init+0x2c0>
800025f6:	e0 6b 00 d1 	mov	r11,209
800025fa:	49 4c       	lddpc	r12,80002648 <cartridge_init+0x270>
800025fc:	f0 1f 00 14 	mcall	8000264c <cartridge_init+0x274>
80002600:	30 06       	mov	r6,0
  //usart_write_line(&AVR32_USART0,"parsing Bak5");
  int i;
//  Byte bytes[BYTES_PER_CHARACTER_BANK];
  for (i=0; i < cartridge1->numCharacterBanks; i++) {
    CharacterBank characterBank1 = malloc(sizeof(struct characterBank));
80002602:	e0 64 20 00 	mov	r4,8192
80002606:	08 9c       	mov	r12,r4
80002608:	f0 1f 00 0d 	mcall	8000263c <cartridge_init+0x264>
8000260c:	18 95       	mov	r5,r12
    assert(characterBank1 != NULL);
8000260e:	c0 81       	brne	8000261e <cartridge_init+0x246>
80002610:	4a 39       	lddpc	r9,8000269c <cartridge_init+0x2c4>
80002612:	4a 2a       	lddpc	r10,80002698 <cartridge_init+0x2c0>
80002614:	e0 6b 00 d7 	mov	r11,215
80002618:	48 cc       	lddpc	r12,80002648 <cartridge_init+0x270>
8000261a:	f0 1f 00 0d 	mcall	8000264c <cartridge_init+0x274>
	//usart_write_line(&AVR32_USART0,"parsing Bak6");
	file_read_buf(characterBank1,sizeof(struct characterBank));
8000261e:	08 9b       	mov	r11,r4
80002620:	f0 1f 00 1c 	mcall	80002690 <cartridge_init+0x2b8>
    ///assert(fread(characterBank, sizeof(struct characterBank), 1, file) == 1);
   // memcpy(&rawData[sizeof(struct header)-1+(cartridge->numProgramBanks)*sizeof(struct programBank)+i*sizeof(struct characterBank)],characterBank,sizeof(struct characterBank));
    //file_read_buf(bytes,sizeof(bytes));
	//memcpy(cartridge1->characterBanks[i]->bytes,bytes,sizeof(bytes));
      cartridge1->characterBanks[i] = characterBank1;
80002624:	6e 38       	ld.w	r8,r7[0xc]
80002626:	f0 06 09 25 	st.w	r8[r6<<0x2],r5
  cartridge1->characterBanks = (CharacterBank*) malloc(sizeof(struct characterBank) * cartridge1->numCharacterBanks);
  assert(cartridge1->characterBanks != NULL);
  //usart_write_line(&AVR32_USART0,"parsing Bak5");
  int i;
//  Byte bytes[BYTES_PER_CHARACTER_BANK];
  for (i=0; i < cartridge1->numCharacterBanks; i++) {
8000262a:	2f f6       	sub	r6,-1
8000262c:	0f 98       	ld.ub	r8,r7[0x1]
8000262e:	10 36       	cp.w	r6,r8
80002630:	ce b5       	brlt	80002606 <cartridge_init+0x22e>
  parseProgramBanks(cartridge1);
  //usart_write_line(&AVR32_USART0,"Initiating program banks\n");
  parseCharacterBanks(cartridge1);
  //usart_write_line(&AVR32_USART0,"Initiating Cartridge\n");
  parseTitle(cartridge1);
  file_close();
80002632:	f0 1f 00 1c 	mcall	800026a0 <cartridge_init+0x2c8>
  //usart_write_line(&AVR32_USART0,"Cartridge1");
  return cartridge1;
}
80002636:	0e 9c       	mov	r12,r7
80002638:	d8 22       	popm	r4-r7,pc
8000263a:	00 00       	add	r0,r0
8000263c:	80 00       	ld.sh	r0,r0[0x0]
8000263e:	c1 fc       	rcall	8000267c <cartridge_init+0x2a4>
80002640:	80 01       	ld.sh	r1,r0[0x0]
80002642:	31 f0       	mov	r0,31
80002644:	80 01       	ld.sh	r1,r0[0x0]
80002646:	34 f8       	mov	r8,79
80002648:	80 01       	ld.sh	r1,r0[0x0]
8000264a:	32 04       	mov	r4,32
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	c1 a0       	breq	80002682 <cartridge_init+0x2aa>
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	23 44       	sub	r4,52
80002654:	80 01       	ld.sh	r1,r0[0x0]
80002656:	32 6c       	mov	r12,38
80002658:	80 01       	ld.sh	r1,r0[0x0]
8000265a:	31 c4       	mov	r4,28
8000265c:	80 01       	ld.sh	r1,r0[0x0]
8000265e:	32 8c       	mov	r12,40
80002660:	80 01       	ld.sh	r1,r0[0x0]
80002662:	32 ac       	mov	r12,42
80002664:	80 01       	ld.sh	r1,r0[0x0]
80002666:	32 cc       	mov	r12,44
80002668:	80 01       	ld.sh	r1,r0[0x0]
8000266a:	32 e8       	mov	r8,46
8000266c:	80 01       	ld.sh	r1,r0[0x0]
8000266e:	33 08       	mov	r8,48
80002670:	80 01       	ld.sh	r1,r0[0x0]
80002672:	33 34       	mov	r4,51
80002674:	80 01       	ld.sh	r1,r0[0x0]
80002676:	33 60       	mov	r0,54
80002678:	80 01       	ld.sh	r1,r0[0x0]
8000267a:	33 8c       	mov	r12,56
8000267c:	80 00       	ld.sh	r0,r0[0x0]
8000267e:	a6 cc       	st.b	r3[0x4],r12
80002680:	80 00       	ld.sh	r0,r0[0x0]
80002682:	c1 ec       	rcall	800026be <colour_setColour+0x1a>
80002684:	80 01       	ld.sh	r1,r0[0x0]
80002686:	33 b8       	mov	r8,59
80002688:	80 01       	ld.sh	r1,r0[0x0]
8000268a:	34 e4       	mov	r4,78
8000268c:	80 01       	ld.sh	r1,r0[0x0]
8000268e:	33 dc       	mov	r12,61
80002690:	80 00       	ld.sh	r0,r0[0x0]
80002692:	a8 28       	st.h	r4[0x4],r8
80002694:	80 01       	ld.sh	r1,r0[0x0]
80002696:	33 f4       	mov	r4,63
80002698:	80 01       	ld.sh	r1,r0[0x0]
8000269a:	31 98       	mov	r8,25
8000269c:	80 01       	ld.sh	r1,r0[0x0]
8000269e:	34 18       	mov	r8,65
800026a0:	80 00       	ld.sh	r0,r0[0x0]
800026a2:	a7 80       	lsr	r0,0x6

800026a4 <colour_setColour>:
}
Byte colour_getBlue(Colour colour) {
  assert(colour != NULL);
  return colour->blue;
}
void colour_setColour(Colour colour, Byte red, Byte green, Byte blue) {
800026a4:	d4 01       	pushm	lr
  assert(colour != NULL);
800026a6:	58 0c       	cp.w	r12,0
800026a8:	c0 71       	brne	800026b6 <colour_setColour+0x12>
800026aa:	48 69       	lddpc	r9,800026c0 <colour_setColour+0x1c>
800026ac:	48 6a       	lddpc	r10,800026c4 <colour_setColour+0x20>
800026ae:	32 9b       	mov	r11,41
800026b0:	48 6c       	lddpc	r12,800026c8 <colour_setColour+0x24>
800026b2:	f0 1f 00 07 	mcall	800026cc <colour_setColour+0x28>
  colour->red = red;
800026b6:	b8 8b       	st.b	r12[0x0],r11
  colour->green = green;
800026b8:	b8 9a       	st.b	r12[0x1],r10
  colour->blue = blue;
800026ba:	b8 a9       	st.b	r12[0x2],r9
800026bc:	d8 02       	popm	pc
800026be:	00 00       	add	r0,r0
800026c0:	80 01       	ld.sh	r1,r0[0x0]
800026c2:	35 64       	mov	r4,86
800026c4:	80 01       	ld.sh	r1,r0[0x0]
800026c6:	35 40       	mov	r0,84
800026c8:	80 01       	ld.sh	r1,r0[0x0]
800026ca:	35 74       	mov	r4,87
800026cc:	80 00       	ld.sh	r0,r0[0x0]
800026ce:	c1 a0       	breq	80002702 <colour_getGreen+0xa>

800026d0 <colour_getBlue>:
}
Byte colour_getGreen(Colour colour) {
  assert(colour != NULL);
  return colour->green;
}
Byte colour_getBlue(Colour colour) {
800026d0:	d4 01       	pushm	lr
  assert(colour != NULL);
800026d2:	58 0c       	cp.w	r12,0
800026d4:	c0 71       	brne	800026e2 <colour_getBlue+0x12>
800026d6:	48 59       	lddpc	r9,800026e8 <colour_getBlue+0x18>
800026d8:	48 5a       	lddpc	r10,800026ec <colour_getBlue+0x1c>
800026da:	32 5b       	mov	r11,37
800026dc:	48 5c       	lddpc	r12,800026f0 <colour_getBlue+0x20>
800026de:	f0 1f 00 06 	mcall	800026f4 <colour_getBlue+0x24>
  return colour->blue;
}
800026e2:	19 ac       	ld.ub	r12,r12[0x2]
800026e4:	d8 02       	popm	pc
800026e6:	00 00       	add	r0,r0
800026e8:	80 01       	ld.sh	r1,r0[0x0]
800026ea:	35 64       	mov	r4,86
800026ec:	80 01       	ld.sh	r1,r0[0x0]
800026ee:	35 a8       	mov	r8,90
800026f0:	80 01       	ld.sh	r1,r0[0x0]
800026f2:	35 74       	mov	r4,87
800026f4:	80 00       	ld.sh	r0,r0[0x0]
800026f6:	c1 a0       	breq	8000272a <colour_getRed+0xa>

800026f8 <colour_getGreen>:
}
Byte colour_getRed(Colour colour) {
  assert(colour != NULL);
  return colour->red;
}
Byte colour_getGreen(Colour colour) {
800026f8:	d4 01       	pushm	lr
  assert(colour != NULL);
800026fa:	58 0c       	cp.w	r12,0
800026fc:	c0 71       	brne	8000270a <colour_getGreen+0x12>
800026fe:	48 59       	lddpc	r9,80002710 <colour_getGreen+0x18>
80002700:	48 5a       	lddpc	r10,80002714 <colour_getGreen+0x1c>
80002702:	32 1b       	mov	r11,33
80002704:	48 5c       	lddpc	r12,80002718 <colour_getGreen+0x20>
80002706:	f0 1f 00 06 	mcall	8000271c <colour_getGreen+0x24>
  return colour->green;
}
8000270a:	19 9c       	ld.ub	r12,r12[0x1]
8000270c:	d8 02       	popm	pc
8000270e:	00 00       	add	r0,r0
80002710:	80 01       	ld.sh	r1,r0[0x0]
80002712:	35 64       	mov	r4,86
80002714:	80 01       	ld.sh	r1,r0[0x0]
80002716:	35 8c       	mov	r12,88
80002718:	80 01       	ld.sh	r1,r0[0x0]
8000271a:	35 74       	mov	r4,87
8000271c:	80 00       	ld.sh	r0,r0[0x0]
8000271e:	c1 a0       	breq	80002752 <colour_destroy+0xa>

80002720 <colour_getRed>:
}
void colour_setBlue(Colour colour, Byte blue) {
  assert(colour != NULL);
  colour->blue = blue;
}
Byte colour_getRed(Colour colour) {
80002720:	d4 01       	pushm	lr
  assert(colour != NULL);
80002722:	58 0c       	cp.w	r12,0
80002724:	c0 71       	brne	80002732 <colour_getRed+0x12>
80002726:	48 59       	lddpc	r9,80002738 <colour_getRed+0x18>
80002728:	48 5a       	lddpc	r10,8000273c <colour_getRed+0x1c>
8000272a:	31 db       	mov	r11,29
8000272c:	48 5c       	lddpc	r12,80002740 <colour_getRed+0x20>
8000272e:	f0 1f 00 06 	mcall	80002744 <colour_getRed+0x24>
  return colour->red;
}
80002732:	19 8c       	ld.ub	r12,r12[0x0]
80002734:	d8 02       	popm	pc
80002736:	00 00       	add	r0,r0
80002738:	80 01       	ld.sh	r1,r0[0x0]
8000273a:	35 64       	mov	r4,86
8000273c:	80 01       	ld.sh	r1,r0[0x0]
8000273e:	35 54       	mov	r4,85
80002740:	80 01       	ld.sh	r1,r0[0x0]
80002742:	35 74       	mov	r4,87
80002744:	80 00       	ld.sh	r0,r0[0x0]
80002746:	c1 a0       	breq	8000277a <colour_init+0x6>

80002748 <colour_destroy>:
  Colour colour = (Colour) malloc(sizeof(struct colour));
  assert(colour != NULL);
  colour_setColour(colour, red, green, blue);
  return colour;
}
void colour_destroy(Colour colour) {
80002748:	d4 01       	pushm	lr
  assert(colour != NULL);
8000274a:	58 0c       	cp.w	r12,0
8000274c:	c0 71       	brne	8000275a <colour_destroy+0x12>
8000274e:	48 59       	lddpc	r9,80002760 <colour_destroy+0x18>
80002750:	48 5a       	lddpc	r10,80002764 <colour_destroy+0x1c>
80002752:	30 db       	mov	r11,13
80002754:	48 5c       	lddpc	r12,80002768 <colour_destroy+0x20>
80002756:	f0 1f 00 06 	mcall	8000276c <colour_destroy+0x24>
  free(colour);
8000275a:	f0 1f 00 06 	mcall	80002770 <colour_destroy+0x28>
}
8000275e:	d8 02       	popm	pc
80002760:	80 01       	ld.sh	r1,r0[0x0]
80002762:	35 64       	mov	r4,86
80002764:	80 01       	ld.sh	r1,r0[0x0]
80002766:	35 b8       	mov	r8,91
80002768:	80 01       	ld.sh	r1,r0[0x0]
8000276a:	35 74       	mov	r4,87
8000276c:	80 00       	ld.sh	r0,r0[0x0]
8000276e:	c1 a0       	breq	800027a2 <colour_init+0x2e>
80002770:	80 00       	ld.sh	r0,r0[0x0]
80002772:	c1 ec       	rcall	800027ae <colour_init+0x3a>

80002774 <colour_init>:
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include "globals.h"
#include "colour.h"
Colour colour_init(Byte red, Byte green, Byte blue) {
80002774:	d4 21       	pushm	r4-r7,lr
80002776:	18 94       	mov	r4,r12
80002778:	16 95       	mov	r5,r11
8000277a:	14 96       	mov	r6,r10
  Colour colour = (Colour) malloc(sizeof(struct colour));
8000277c:	30 3c       	mov	r12,3
8000277e:	f0 1f 00 09 	mcall	800027a0 <colour_init+0x2c>
80002782:	18 97       	mov	r7,r12
  assert(colour != NULL);
80002784:	c0 71       	brne	80002792 <colour_init+0x1e>
80002786:	48 89       	lddpc	r9,800027a4 <colour_init+0x30>
80002788:	48 8a       	lddpc	r10,800027a8 <colour_init+0x34>
8000278a:	30 8b       	mov	r11,8
8000278c:	48 8c       	lddpc	r12,800027ac <colour_init+0x38>
8000278e:	f0 1f 00 09 	mcall	800027b0 <colour_init+0x3c>
  colour_setColour(colour, red, green, blue);
80002792:	0c 99       	mov	r9,r6
80002794:	0a 9a       	mov	r10,r5
80002796:	08 9b       	mov	r11,r4
80002798:	f0 1f 00 07 	mcall	800027b4 <colour_init+0x40>
  return colour;
}
8000279c:	0e 9c       	mov	r12,r7
8000279e:	d8 22       	popm	r4-r7,pc
800027a0:	80 00       	ld.sh	r0,r0[0x0]
800027a2:	c1 fc       	rcall	800027e0 <cpu_setZero+0xc>
800027a4:	80 01       	ld.sh	r1,r0[0x0]
800027a6:	35 64       	mov	r4,86
800027a8:	80 01       	ld.sh	r1,r0[0x0]
800027aa:	35 9c       	mov	r12,89
800027ac:	80 01       	ld.sh	r1,r0[0x0]
800027ae:	35 74       	mov	r4,87
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	c1 a0       	breq	800027e6 <cpu_setZero+0x12>
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	26 a4       	sub	r4,106

800027b8 <cpu_setIndexX>:
	status |= MASK_BIT5;
	cpu1->status = status;
}
void cpu_setIndexX(CPU cpu1, Byte indexX) {
	//assert(cpu1 != NULL);
	cpu1->indexX = indexX;
800027b8:	b8 cb       	st.b	r12[0x4],r11
}
800027ba:	5e fc       	retal	r12

800027bc <cpu_setIndexY>:
void cpu_setIndexY(CPU cpu1, Byte indexY) {
	//assert(cpu1 != NULL);
	cpu1->indexY = indexY;
800027bc:	b8 db       	st.b	r12[0x5],r11
}
800027be:	5e fc       	retal	r12

800027c0 <cpu_setAccumulator>:
void cpu_setAccumulator(CPU cpu1, Byte accumulator) {
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
800027c0:	b8 eb       	st.b	r12[0x6],r11
}
800027c2:	5e fc       	retal	r12

800027c4 <cpu_increaseProgramCounter>:
static void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
800027c4:	98 08       	ld.sh	r8,r12[0x0]
800027c6:	2f f8       	sub	r8,-1
800027c8:	b8 08       	st.h	r12[0x0],r8
}
800027ca:	5e fc       	retal	r12

800027cc <cpu_getZero>:
	CPU cpu1 = nes_getCPU(nes);
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"JMP\n");
	cpu1->programCounter = address;
}
static Bool cpu_getZero(CPU cpu1) {
800027cc:	19 bc       	ld.ub	r12,r12[0x3]
	if ((cpu1->status & MASK_STATUS_ZERO_ON) == MASK_STATUS_ZERO_ON) {
		return TRUE;
		} else {
		return FALSE;
	}
}
800027ce:	f9 dc c0 21 	bfextu	r12,r12,0x1,0x1
800027d2:	5e fc       	retal	r12

800027d4 <cpu_setZero>:
static void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
800027d4:	30 18       	mov	r8,1
800027d6:	f0 0b 18 00 	cp.b	r11,r8
800027da:	c0 51       	brne	800027e4 <cpu_setZero+0x10>
		cpu1->status |= MASK_STATUS_ZERO_ON;
800027dc:	19 b8       	ld.ub	r8,r12[0x3]
800027de:	a1 b8       	sbr	r8,0x1
800027e0:	b8 b8       	st.b	r12[0x3],r8
800027e2:	5e fc       	retal	r12
		} else if (state == FALSE) {
800027e4:	58 0b       	cp.w	r11,0
800027e6:	5e 1c       	retne	r12
		cpu1->status &= MASK_STATUS_ZERO_OFF;
800027e8:	19 b8       	ld.ub	r8,r12[0x3]
800027ea:	a1 d8       	cbr	r8,0x1
800027ec:	b8 b8       	st.b	r12[0x3],r8
800027ee:	5e fc       	retal	r12

800027f0 <cpu_updateZero>:
	}
}
//Z     Zero Flag      Set if A = 0
static void cpu_updateZero(CPU cpu1, Byte data) {
800027f0:	d4 01       	pushm	lr
	//assert(cpu1 != NULL);
	if (data == 0) {
800027f2:	58 0b       	cp.w	r11,0
800027f4:	c0 51       	brne	800027fe <cpu_updateZero+0xe>
		cpu_setZero(cpu1, TRUE);
800027f6:	30 1b       	mov	r11,1
800027f8:	f0 1f 00 04 	mcall	80002808 <cpu_updateZero+0x18>
800027fc:	d8 02       	popm	pc
		} else {
		cpu_setZero(cpu1, FALSE);
800027fe:	30 0b       	mov	r11,0
80002800:	f0 1f 00 02 	mcall	80002808 <cpu_updateZero+0x18>
80002804:	d8 02       	popm	pc
80002806:	00 00       	add	r0,r0
80002808:	80 00       	ld.sh	r0,r0[0x0]
8000280a:	27 d4       	sub	r4,125

8000280c <cpu_setDecimal>:
	}
}
static void cpu_setDecimal(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
8000280c:	30 18       	mov	r8,1
8000280e:	f0 0b 18 00 	cp.b	r11,r8
80002812:	c0 51       	brne	8000281c <cpu_setDecimal+0x10>
		cpu1->status |= MASK_STATUS_DECIMAL_ON;
80002814:	19 b8       	ld.ub	r8,r12[0x3]
80002816:	a3 b8       	sbr	r8,0x3
80002818:	b8 b8       	st.b	r12[0x3],r8
8000281a:	5e fc       	retal	r12
		} else if (state == FALSE) {
8000281c:	58 0b       	cp.w	r11,0
8000281e:	5e 1c       	retne	r12
		cpu1->status &= MASK_STATUS_DECIMAL_OFF;
80002820:	19 b8       	ld.ub	r8,r12[0x3]
80002822:	a3 d8       	cbr	r8,0x3
80002824:	b8 b8       	st.b	r12[0x3],r8
80002826:	5e fc       	retal	r12

80002828 <cpu_getNegative>:
// CLD - Clear Decimal Mode
static void cpu_CLD(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu_setDecimal(cpu1, FALSE);
}
static Bool cpu_getNegative(CPU cpu1) {
80002828:	19 bc       	ld.ub	r12,r12[0x3]
	if ((cpu1->status & MASK_STATUS_NEGATIVE_ON) == MASK_STATUS_NEGATIVE_ON) {
		return TRUE;
		} else {
		return FALSE;
	}
}
8000282a:	a7 9c       	lsr	r12,0x7
8000282c:	5e fc       	retal	r12

8000282e <cpu_setNegative>:
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
8000282e:	30 18       	mov	r8,1
80002830:	f0 0b 18 00 	cp.b	r11,r8
80002834:	c0 81       	brne	80002844 <cpu_setNegative+0x16>
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
80002836:	19 b8       	ld.ub	r8,r12[0x3]
80002838:	ea 18 ff ff 	orh	r8,0xffff
8000283c:	e8 18 ff 80 	orl	r8,0xff80
80002840:	b8 b8       	st.b	r12[0x3],r8
80002842:	5e fc       	retal	r12
		} else if (state == FALSE) {
80002844:	58 0b       	cp.w	r11,0
80002846:	5e 1c       	retne	r12
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
80002848:	19 b8       	ld.ub	r8,r12[0x3]
8000284a:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
8000284e:	b8 b8       	st.b	r12[0x3],r8
80002850:	5e fc       	retal	r12
80002852:	d7 03       	nop

80002854 <cpu_updateNegative>:
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
80002854:	d4 01       	pushm	lr
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
80002856:	30 08       	mov	r8,0
80002858:	f0 0b 18 00 	cp.b	r11,r8
8000285c:	c0 54       	brge	80002866 <cpu_updateNegative+0x12>
		cpu_setNegative(cpu1, TRUE);
8000285e:	30 1b       	mov	r11,1
80002860:	f0 1f 00 04 	mcall	80002870 <cpu_updateNegative+0x1c>
80002864:	d8 02       	popm	pc
		} else {
		cpu_setNegative(cpu1, FALSE);
80002866:	30 0b       	mov	r11,0
80002868:	f0 1f 00 02 	mcall	80002870 <cpu_updateNegative+0x1c>
8000286c:	d8 02       	popm	pc
8000286e:	00 00       	add	r0,r0
80002870:	80 00       	ld.sh	r0,r0[0x0]
80002872:	28 2e       	sub	lr,-126

80002874 <cpu_setOverflow>:
	cpu_updateZero(cpu1, cpu1->accumulator);
	cpu_updateNegative(cpu1, cpu1->accumulator);
}
static void cpu_setOverflow(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
80002874:	30 18       	mov	r8,1
80002876:	f0 0b 18 00 	cp.b	r11,r8
8000287a:	c0 51       	brne	80002884 <cpu_setOverflow+0x10>
		cpu1->status |= MASK_STATUS_OVERFLOW_ON;
8000287c:	19 b8       	ld.ub	r8,r12[0x3]
8000287e:	a7 a8       	sbr	r8,0x6
80002880:	b8 b8       	st.b	r12[0x3],r8
80002882:	5e fc       	retal	r12
		} else if (state == FALSE) {
80002884:	58 0b       	cp.w	r11,0
80002886:	5e 1c       	retne	r12
		cpu1->status &= MASK_STATUS_OVERFLOW_OFF;
80002888:	19 b8       	ld.ub	r8,r12[0x3]
8000288a:	a7 c8       	cbr	r8,0x6
8000288c:	b8 b8       	st.b	r12[0x3],r8
8000288e:	5e fc       	retal	r12

80002890 <cpu_getOverflow>:
	}
}
static Bool cpu_getOverflow(CPU cpu1) {
80002890:	19 bc       	ld.ub	r12,r12[0x3]
	if ((cpu1->status & MASK_STATUS_OVERFLOW_ON) == MASK_STATUS_OVERFLOW_ON) {
		return TRUE;
		} else {
		return FALSE;
	}
}
80002892:	f9 dc c0 c1 	bfextu	r12,r12,0x6,0x1
80002896:	5e fc       	retal	r12

80002898 <cpu_setCarry>:
		cpu_setOverflow(cpu1, FALSE);
	}
}
static void cpu_setCarry(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
80002898:	30 18       	mov	r8,1
8000289a:	f0 0b 18 00 	cp.b	r11,r8
8000289e:	c0 51       	brne	800028a8 <cpu_setCarry+0x10>
		cpu1->status |= MASK_STATUS_CARRY_ON;
800028a0:	19 b8       	ld.ub	r8,r12[0x3]
800028a2:	a1 a8       	sbr	r8,0x0
800028a4:	b8 b8       	st.b	r12[0x3],r8
800028a6:	5e fc       	retal	r12
		} else if (state == FALSE) {
800028a8:	58 0b       	cp.w	r11,0
800028aa:	5e 1c       	retne	r12
		cpu1->status &= MASK_STATUS_CARRY_OFF;
800028ac:	19 b8       	ld.ub	r8,r12[0x3]
800028ae:	a1 c8       	cbr	r8,0x0
800028b0:	b8 b8       	st.b	r12[0x3],r8
800028b2:	5e fc       	retal	r12

800028b4 <cpu_getCarry>:
	}
}
static Bool cpu_getCarry(CPU cpu1) {
800028b4:	19 bc       	ld.ub	r12,r12[0x3]
	if ((cpu1->status & MASK_STATUS_CARRY_ON) == MASK_STATUS_CARRY_ON) {
		return TRUE;
		} else {
		return FALSE;
	}
}
800028b6:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
800028ba:	5e fc       	retal	r12

800028bc <cpu_updateCarry_subtract>:
// set to 0 - if a borrow is required
// set to 1 - if no borrow is required.
static void cpu_updateCarry_subtract(CPU cpu1, Byte a, Byte b) {
800028bc:	d4 01       	pushm	lr
	// add a 'borrow' bit to borrow from
	Word aa = a;
	aa += MASK_BIT8;
	Word bb = b;
	Word result = aa-bb;
	if ((result & MASK_BIT8) == MASK_BIT8) {
800028be:	f6 cb ff 00 	sub	r11,r11,-256
800028c2:	14 1b       	sub	r11,r10
800028c4:	e2 1b 01 00 	andl	r11,0x100,COH
800028c8:	c0 50       	breq	800028d2 <cpu_updateCarry_subtract+0x16>
		// subtraction didn't need to borrow from the 8th bit
		cpu_setCarry(cpu1, TRUE);
800028ca:	30 1b       	mov	r11,1
800028cc:	f0 1f 00 04 	mcall	800028dc <cpu_updateCarry_subtract+0x20>
800028d0:	d8 02       	popm	pc
		} else {
		// needed to borrow from the 8th bit
		cpu_setCarry(cpu1, FALSE);
800028d2:	30 0b       	mov	r11,0
800028d4:	f0 1f 00 02 	mcall	800028dc <cpu_updateCarry_subtract+0x20>
800028d8:	d8 02       	popm	pc
800028da:	00 00       	add	r0,r0
800028dc:	80 00       	ld.sh	r0,r0[0x0]
800028de:	28 98       	sub	r8,-119

800028e0 <cpu_setInterruptDisable>:
	// N Negative Flag   Set if bit 7 of the result is set
	cpu_updateNegative(cpu1, cpu1->accumulator);
}
static void cpu_setInterruptDisable(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
800028e0:	30 18       	mov	r8,1
800028e2:	f0 0b 18 00 	cp.b	r11,r8
800028e6:	c0 51       	brne	800028f0 <cpu_setInterruptDisable+0x10>
		cpu1->status |= MASK_STATUS_INTERRUPT_ON;
800028e8:	19 b8       	ld.ub	r8,r12[0x3]
800028ea:	a3 a8       	sbr	r8,0x2
800028ec:	b8 b8       	st.b	r12[0x3],r8
800028ee:	5e fc       	retal	r12
		} else if (state == FALSE) {
800028f0:	58 0b       	cp.w	r11,0
800028f2:	5e 1c       	retne	r12
		cpu1->status &= MASK_STATUS_INTERRUPT_OFF;
800028f4:	19 b8       	ld.ub	r8,r12[0x3]
800028f6:	a3 c8       	cbr	r8,0x2
800028f8:	b8 b8       	st.b	r12[0x3],r8
800028fa:	5e fc       	retal	r12

800028fc <cpu_getInterruptDisable>:
	}
}
Bool cpu_getInterruptDisable(CPU cpu1) {
800028fc:	19 bc       	ld.ub	r12,r12[0x3]
	if ((cpu1->status & MASK_STATUS_INTERRUPT_ON) == MASK_STATUS_INTERRUPT_ON) {
		return TRUE;
		} else {
		return FALSE;
	}
}
800028fe:	f9 dc c0 41 	bfextu	r12,r12,0x2,0x1
80002902:	5e fc       	retal	r12

80002904 <cpu_setBreak>:
static void cpu_setBreak(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
80002904:	30 18       	mov	r8,1
80002906:	f0 0b 18 00 	cp.b	r11,r8
8000290a:	c0 51       	brne	80002914 <cpu_setBreak+0x10>
		cpu1->status |= MASK_STATUS_BREAK_ON;
8000290c:	19 b8       	ld.ub	r8,r12[0x3]
8000290e:	a5 a8       	sbr	r8,0x4
80002910:	b8 b8       	st.b	r12[0x3],r8
80002912:	5e fc       	retal	r12
		} else if (state == FALSE) {
80002914:	58 0b       	cp.w	r11,0
80002916:	5e 1c       	retne	r12
		cpu1->status &= MASK_STATUS_BREAK_OFF;
80002918:	19 b8       	ld.ub	r8,r12[0x3]
8000291a:	a5 c8       	cbr	r8,0x4
8000291c:	b8 b8       	st.b	r12[0x3],r8
8000291e:	5e fc       	retal	r12

80002920 <cpu_JMP>:
}
static void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
}
static void cpu_JMP(NES nes, Address address) {
80002920:	eb cd 40 80 	pushm	r7,lr
80002924:	16 97       	mov	r7,r11
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80002926:	f0 1f 00 03 	mcall	80002930 <cpu_JMP+0x10>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"JMP\n");
	cpu1->programCounter = address;
8000292a:	b8 07       	st.h	r12[0x0],r7
}
8000292c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002930:	80 00       	ld.sh	r0,r0[0x0]
80002932:	50 70       	stdsp	sp[0x1c],r0

80002934 <cpu_ROR_memory>:
	nes_writeCPUMemory(nes, address, result);
}
// ROR - Rotate Right
// Move each of the bits in either A or M one place to the right.
// Bit 7 is filled with the current value of the carry flag whilst the old bit 0 becomes the new carry flag value.
static void cpu_ROR_memory(NES nes, Address address) {
80002934:	eb cd 40 f8 	pushm	r3-r7,lr
80002938:	18 94       	mov	r4,r12
8000293a:	16 95       	mov	r5,r11
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
8000293c:	f0 1f 00 1a 	mcall	800029a4 <cpu_ROR_memory+0x70>
80002940:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"ROR_memory\n");
	Byte data = nes_readCPUMemory(nes, address);
80002942:	5c 75       	castu.h	r5
80002944:	0a 9b       	mov	r11,r5
80002946:	08 9c       	mov	r12,r4
80002948:	f0 1f 00 18 	mcall	800029a8 <cpu_ROR_memory+0x74>
	// dummy write, cycle wasted here
	nes_writeCPUMemory(nes, address, data);
8000294c:	18 96       	mov	r6,r12
8000294e:	18 9a       	mov	r10,r12
80002950:	0a 9b       	mov	r11,r5
80002952:	08 9c       	mov	r12,r4
80002954:	f0 1f 00 16 	mcall	800029ac <cpu_ROR_memory+0x78>
	Word result = data >> 1;
80002958:	e7 d6 c0 28 	bfextu	r3,r6,0x1,0x8
	if (cpu_getCarry(cpu1) == TRUE) {
8000295c:	0e 9c       	mov	r12,r7
8000295e:	f0 1f 00 15 	mcall	800029b0 <cpu_ROR_memory+0x7c>
80002962:	30 18       	mov	r8,1
80002964:	f0 0c 18 00 	cp.b	r12,r8
80002968:	c0 21       	brne	8000296c <cpu_ROR_memory+0x38>
		result |= MASK_BIT7;
8000296a:	a7 b3       	sbr	r3,0x7
	}
	// C         Carry Flag      Set to contents of old bit 0
	if ((data & MASK_BIT0) == MASK_BIT0) {
8000296c:	ed d6 c0 01 	bfextu	r6,r6,0x0,0x1
80002970:	c0 60       	breq	8000297c <cpu_ROR_memory+0x48>
		cpu_setCarry(cpu1, TRUE);
80002972:	30 1b       	mov	r11,1
80002974:	0e 9c       	mov	r12,r7
80002976:	f0 1f 00 10 	mcall	800029b4 <cpu_ROR_memory+0x80>
8000297a:	c0 58       	rjmp	80002984 <cpu_ROR_memory+0x50>
		} else {
		cpu_setCarry(cpu1, FALSE);
8000297c:	30 0b       	mov	r11,0
8000297e:	0e 9c       	mov	r12,r7
80002980:	f0 1f 00 0d 	mcall	800029b4 <cpu_ROR_memory+0x80>
	}
	// Z Zero Flag       Set if A = 0
	cpu_updateZero(cpu1, result);
80002984:	06 96       	mov	r6,r3
80002986:	06 9b       	mov	r11,r3
80002988:	0e 9c       	mov	r12,r7
8000298a:	f0 1f 00 0c 	mcall	800029b8 <cpu_ROR_memory+0x84>
	// N Negative Flag   Set if bit 7 of the result is set
	cpu_updateZero(cpu1, result);
8000298e:	06 9b       	mov	r11,r3
80002990:	0e 9c       	mov	r12,r7
80002992:	f0 1f 00 0a 	mcall	800029b8 <cpu_ROR_memory+0x84>
	nes_writeCPUMemory(nes, address, result);
80002996:	06 9a       	mov	r10,r3
80002998:	0a 9b       	mov	r11,r5
8000299a:	08 9c       	mov	r12,r4
8000299c:	f0 1f 00 04 	mcall	800029ac <cpu_ROR_memory+0x78>
}
800029a0:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800029a4:	80 00       	ld.sh	r0,r0[0x0]
800029a6:	50 70       	stdsp	sp[0x1c],r0
800029a8:	80 00       	ld.sh	r0,r0[0x0]
800029aa:	53 6c       	stdsp	sp[0xd8],r12
800029ac:	80 00       	ld.sh	r0,r0[0x0]
800029ae:	52 68       	stdsp	sp[0x98],r8
800029b0:	80 00       	ld.sh	r0,r0[0x0]
800029b2:	28 b4       	sub	r4,-117
800029b4:	80 00       	ld.sh	r0,r0[0x0]
800029b6:	28 98       	sub	r8,-119
800029b8:	80 00       	ld.sh	r0,r0[0x0]
800029ba:	27 f0       	sub	r0,127

800029bc <cpu_INC>:
// INC - Increment Memory
// Adds one to the value held at a specified memory location setting the zero and negative flags as appropriate.
static void cpu_INC(NES nes, Address address) {
800029bc:	d4 21       	pushm	r4-r7,lr
800029be:	18 95       	mov	r5,r12
800029c0:	16 97       	mov	r7,r11
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
800029c2:	f0 1f 00 10 	mcall	80002a00 <cpu_INC+0x44>
800029c6:	18 94       	mov	r4,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"INC\n");
	Byte data = nes_readCPUMemory(nes, address);
800029c8:	5c 77       	castu.h	r7
800029ca:	0e 9b       	mov	r11,r7
800029cc:	0a 9c       	mov	r12,r5
800029ce:	f0 1f 00 0e 	mcall	80002a04 <cpu_INC+0x48>
800029d2:	18 96       	mov	r6,r12
	// dummy write, cycle wasted here
	nes_writeCPUMemory(nes, address, data);
800029d4:	18 9a       	mov	r10,r12
800029d6:	0e 9b       	mov	r11,r7
800029d8:	0a 9c       	mov	r12,r5
800029da:	f0 1f 00 0c 	mcall	80002a08 <cpu_INC+0x4c>
	data++;
	// Z Zero Flag       Set if result is zero
	cpu_updateZero(cpu1, data);
800029de:	2f f6       	sub	r6,-1
800029e0:	5c 56       	castu.b	r6
800029e2:	0c 9b       	mov	r11,r6
800029e4:	08 9c       	mov	r12,r4
800029e6:	f0 1f 00 0a 	mcall	80002a0c <cpu_INC+0x50>
	// N Negative Flag   Set if bit 7 of the result is set
	cpu_updateNegative(cpu1, data);
800029ea:	0c 9b       	mov	r11,r6
800029ec:	08 9c       	mov	r12,r4
800029ee:	f0 1f 00 09 	mcall	80002a10 <cpu_INC+0x54>
	nes_writeCPUMemory(nes, address, data);
800029f2:	0c 9a       	mov	r10,r6
800029f4:	0e 9b       	mov	r11,r7
800029f6:	0a 9c       	mov	r12,r5
800029f8:	f0 1f 00 04 	mcall	80002a08 <cpu_INC+0x4c>
}
800029fc:	d8 22       	popm	r4-r7,pc
800029fe:	00 00       	add	r0,r0
80002a00:	80 00       	ld.sh	r0,r0[0x0]
80002a02:	50 70       	stdsp	sp[0x1c],r0
80002a04:	80 00       	ld.sh	r0,r0[0x0]
80002a06:	53 6c       	stdsp	sp[0xd8],r12
80002a08:	80 00       	ld.sh	r0,r0[0x0]
80002a0a:	52 68       	stdsp	sp[0x98],r8
80002a0c:	80 00       	ld.sh	r0,r0[0x0]
80002a0e:	27 f0       	sub	r0,127
80002a10:	80 00       	ld.sh	r0,r0[0x0]
80002a12:	28 54       	sub	r4,-123

80002a14 <cpu_DEC>:
// DEC - Decrement Memory
// Subtracts one from the value held at a specified memory location setting the zero and negative flags as appropriate.
static void cpu_DEC(NES nes, Address address) {
80002a14:	d4 21       	pushm	r4-r7,lr
80002a16:	18 95       	mov	r5,r12
80002a18:	16 97       	mov	r7,r11
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80002a1a:	f0 1f 00 10 	mcall	80002a58 <cpu_DEC+0x44>
80002a1e:	18 94       	mov	r4,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"DEC\n");
	Byte data = nes_readCPUMemory(nes, address);
80002a20:	5c 77       	castu.h	r7
80002a22:	0e 9b       	mov	r11,r7
80002a24:	0a 9c       	mov	r12,r5
80002a26:	f0 1f 00 0e 	mcall	80002a5c <cpu_DEC+0x48>
80002a2a:	18 96       	mov	r6,r12
	// dummy write, cycle wasted here
	nes_writeCPUMemory(nes, address, data);
80002a2c:	18 9a       	mov	r10,r12
80002a2e:	0e 9b       	mov	r11,r7
80002a30:	0a 9c       	mov	r12,r5
80002a32:	f0 1f 00 0c 	mcall	80002a60 <cpu_DEC+0x4c>
	data--;
	// Z Zero Flag       Set if result is zero
	cpu_updateZero(cpu1, data);
80002a36:	20 16       	sub	r6,1
80002a38:	5c 56       	castu.b	r6
80002a3a:	0c 9b       	mov	r11,r6
80002a3c:	08 9c       	mov	r12,r4
80002a3e:	f0 1f 00 0a 	mcall	80002a64 <cpu_DEC+0x50>
	// N Negative Flag   Set if bit 7 of the result is set
	cpu_updateNegative(cpu1, data);
80002a42:	0c 9b       	mov	r11,r6
80002a44:	08 9c       	mov	r12,r4
80002a46:	f0 1f 00 09 	mcall	80002a68 <cpu_DEC+0x54>
	nes_writeCPUMemory(nes, address, data);
80002a4a:	0c 9a       	mov	r10,r6
80002a4c:	0e 9b       	mov	r11,r7
80002a4e:	0a 9c       	mov	r12,r5
80002a50:	f0 1f 00 04 	mcall	80002a60 <cpu_DEC+0x4c>
}
80002a54:	d8 22       	popm	r4-r7,pc
80002a56:	00 00       	add	r0,r0
80002a58:	80 00       	ld.sh	r0,r0[0x0]
80002a5a:	50 70       	stdsp	sp[0x1c],r0
80002a5c:	80 00       	ld.sh	r0,r0[0x0]
80002a5e:	53 6c       	stdsp	sp[0xd8],r12
80002a60:	80 00       	ld.sh	r0,r0[0x0]
80002a62:	52 68       	stdsp	sp[0x98],r8
80002a64:	80 00       	ld.sh	r0,r0[0x0]
80002a66:	27 f0       	sub	r0,127
80002a68:	80 00       	ld.sh	r0,r0[0x0]
80002a6a:	28 54       	sub	r4,-123

80002a6c <cpu_pushStack>:
// The stack is located at memory locations $0100-$01FF.
// The stack pointer is an 8-bit register which serves as an offset from $0100.
// The stack pointer is an 8 bit register and holds the low 8 bits of the next freelocation on the stack.
// Pushing bytes to the stack causes the stack pointer to be decremented. Conversely pulling bytes causes it to be incremented.
// There is no detection of stack overflow and the stack pointer will just wrap around from $00 to $FF.
static void cpu_pushStack(NES nes, Byte data) {
80002a6c:	eb cd 40 e0 	pushm	r5-r7,lr
80002a70:	18 95       	mov	r5,r12
80002a72:	16 96       	mov	r6,r11
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80002a74:	f0 1f 00 21 	mcall	80002af8 <cpu_pushStack+0x8c>
80002a78:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	Address stackAddress = GET_STACK_ADDRESS(cpu1->stackPointer);
80002a7a:	19 ab       	ld.ub	r11,r12[0x2]
80002a7c:	f6 cb ff 00 	sub	r11,r11,-256
	VALIDATE_STACK_ADDRESS(stackAddress);
80002a80:	e0 68 01 ff 	mov	r8,511
80002a84:	f0 0b 19 00 	cp.h	r11,r8
80002a88:	e0 88 00 09 	brls	80002a9a <cpu_pushStack+0x2e>
80002a8c:	49 c9       	lddpc	r9,80002afc <cpu_pushStack+0x90>
80002a8e:	49 da       	lddpc	r10,80002b00 <cpu_pushStack+0x94>
80002a90:	e0 6b 02 6a 	mov	r11,618
80002a94:	49 cc       	lddpc	r12,80002b04 <cpu_pushStack+0x98>
80002a96:	f0 1f 00 1d 	mcall	80002b08 <cpu_pushStack+0x9c>
80002a9a:	e0 68 00 ff 	mov	r8,255
80002a9e:	f0 0b 19 00 	cp.h	r11,r8
80002aa2:	e0 8b 00 09 	brhi	80002ab4 <cpu_pushStack+0x48>
80002aa6:	49 a9       	lddpc	r9,80002b0c <cpu_pushStack+0xa0>
80002aa8:	49 6a       	lddpc	r10,80002b00 <cpu_pushStack+0x94>
80002aaa:	e0 6b 02 6a 	mov	r11,618
80002aae:	49 6c       	lddpc	r12,80002b04 <cpu_pushStack+0x98>
80002ab0:	f0 1f 00 16 	mcall	80002b08 <cpu_pushStack+0x9c>
	nes_writeCPUMemory(nes, stackAddress, data);
80002ab4:	0c 9a       	mov	r10,r6
80002ab6:	0a 9c       	mov	r12,r5
80002ab8:	f0 1f 00 16 	mcall	80002b10 <cpu_pushStack+0xa4>
	cpu1->stackPointer--;
80002abc:	0f a8       	ld.ub	r8,r7[0x2]
80002abe:	20 18       	sub	r8,1
80002ac0:	5c 58       	castu.b	r8
80002ac2:	ae a8       	st.b	r7[0x2],r8
	VALIDATE_STACK_POINTER(cpu1->stackPointer);
80002ac4:	f0 c8 ff 00 	sub	r8,r8,-256
80002ac8:	e0 48 01 ff 	cp.w	r8,511
80002acc:	e0 8a 00 09 	brle	80002ade <cpu_pushStack+0x72>
80002ad0:	49 19       	lddpc	r9,80002b14 <cpu_pushStack+0xa8>
80002ad2:	48 ca       	lddpc	r10,80002b00 <cpu_pushStack+0x94>
80002ad4:	e0 6b 02 6d 	mov	r11,621
80002ad8:	48 bc       	lddpc	r12,80002b04 <cpu_pushStack+0x98>
80002ada:	f0 1f 00 0c 	mcall	80002b08 <cpu_pushStack+0x9c>
80002ade:	e0 48 00 ff 	cp.w	r8,255
80002ae2:	e0 89 00 09 	brgt	80002af4 <cpu_pushStack+0x88>
80002ae6:	48 d9       	lddpc	r9,80002b18 <cpu_pushStack+0xac>
80002ae8:	48 6a       	lddpc	r10,80002b00 <cpu_pushStack+0x94>
80002aea:	e0 6b 02 6d 	mov	r11,621
80002aee:	48 6c       	lddpc	r12,80002b04 <cpu_pushStack+0x98>
80002af0:	f0 1f 00 06 	mcall	80002b08 <cpu_pushStack+0x9c>
80002af4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002af8:	80 00       	ld.sh	r0,r0[0x0]
80002afa:	50 70       	stdsp	sp[0x1c],r0
80002afc:	80 01       	ld.sh	r1,r0[0x0]
80002afe:	3d fc       	mov	r12,-33
80002b00:	80 01       	ld.sh	r1,r0[0x0]
80002b02:	3d ec       	mov	r12,-34
80002b04:	80 01       	ld.sh	r1,r0[0x0]
80002b06:	3e 20       	mov	r0,-30
80002b08:	80 00       	ld.sh	r0,r0[0x0]
80002b0a:	c1 a0       	breq	80002b3e <cpu_JSR+0x22>
80002b0c:	80 01       	ld.sh	r1,r0[0x0]
80002b0e:	3e 34       	mov	r4,-29
80002b10:	80 00       	ld.sh	r0,r0[0x0]
80002b12:	52 68       	stdsp	sp[0x98],r8
80002b14:	80 01       	ld.sh	r1,r0[0x0]
80002b16:	3e 58       	mov	r8,-27
80002b18:	80 01       	ld.sh	r1,r0[0x0]
80002b1a:	3e 98       	mov	r8,-23

80002b1c <cpu_JSR>:
	Byte data = nes_readCPUMemory(nes, stackAddress);
	return data;
}
// JSR - Jump to Subroutine
// The JSR instruction pushes the address (minus one) of the return point on to the stack and then sets the program counter to the target memory address.
static void cpu_JSR(NES nes, Address address) {
80002b1c:	d4 21       	pushm	r4-r7,lr
80002b1e:	18 97       	mov	r7,r12
80002b20:	16 94       	mov	r4,r11
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80002b22:	f0 1f 00 0b 	mcall	80002b4c <cpu_JSR+0x30>
80002b26:	18 95       	mov	r5,r12
	// During a JSR, the address pushed onto the stack is that of the 3rd byte of th	instruction - that is, 1 byte BEFORE the next instruction.
	// This is because it pushes the program counter onto the stack BEFORE it fetches the final byte of the opcode
	// (and, as such, before it can increment the PC past this point).
	// To compensate for this, the RTS opcode increments the program counter during its 6th instruction cycle.
	// JSR takes 6 cycles, waste a cycle here
	nes_cpuCycled(nes);
80002b28:	0e 9c       	mov	r12,r7
80002b2a:	f0 1f 00 0a 	mcall	80002b50 <cpu_JSR+0x34>
	Address returnAddress = cpu1->programCounter - 1;
80002b2e:	8a 06       	ld.sh	r6,r5[0x0]
80002b30:	20 16       	sub	r6,1
80002b32:	5c 86       	casts.h	r6
	cpu_pushStack(nes, GET_ADDRESS_HIGH_BYTE(returnAddress));
80002b34:	f7 d6 c1 08 	bfextu	r11,r6,0x8,0x8
80002b38:	0e 9c       	mov	r12,r7
80002b3a:	f0 1f 00 07 	mcall	80002b54 <cpu_JSR+0x38>
	cpu_pushStack(nes, GET_ADDRESS_LOW_BYTE(returnAddress));
80002b3e:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80002b42:	0e 9c       	mov	r12,r7
80002b44:	f0 1f 00 04 	mcall	80002b54 <cpu_JSR+0x38>
	cpu1->programCounter = address;
80002b48:	aa 04       	st.h	r5[0x0],r4
}
80002b4a:	d8 22       	popm	r4-r7,pc
80002b4c:	80 00       	ld.sh	r0,r0[0x0]
80002b4e:	50 70       	stdsp	sp[0x1c],r0
80002b50:	80 00       	ld.sh	r0,r0[0x0]
80002b52:	51 64       	stdsp	sp[0x58],r4
80002b54:	80 00       	ld.sh	r0,r0[0x0]
80002b56:	2a 6c       	sub	r12,-90

80002b58 <cpu_popStack>:
	VALIDATE_STACK_ADDRESS(stackAddress);
	nes_writeCPUMemory(nes, stackAddress, data);
	cpu1->stackPointer--;
	VALIDATE_STACK_POINTER(cpu1->stackPointer);
}
static Byte cpu_popStack(NES nes) {
80002b58:	eb cd 40 80 	pushm	r7,lr
80002b5c:	18 97       	mov	r7,r12
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80002b5e:	f0 1f 00 2c 	mcall	80002c0c <cpu_popStack+0xb4>
	//assert(cpu1 != NULL);
	VALIDATE_STACK_POINTER(cpu1->stackPointer);
80002b62:	19 ab       	ld.ub	r11,r12[0x2]
80002b64:	f6 c8 ff 00 	sub	r8,r11,-256
80002b68:	e0 48 01 ff 	cp.w	r8,511
80002b6c:	e0 8a 00 09 	brle	80002b7e <cpu_popStack+0x26>
80002b70:	4a 89       	lddpc	r9,80002c10 <cpu_popStack+0xb8>
80002b72:	4a 9a       	lddpc	r10,80002c14 <cpu_popStack+0xbc>
80002b74:	e0 6b 02 73 	mov	r11,627
80002b78:	4a 8c       	lddpc	r12,80002c18 <cpu_popStack+0xc0>
80002b7a:	f0 1f 00 29 	mcall	80002c1c <cpu_popStack+0xc4>
80002b7e:	e0 48 00 ff 	cp.w	r8,255
80002b82:	e0 89 00 09 	brgt	80002b94 <cpu_popStack+0x3c>
80002b86:	4a 79       	lddpc	r9,80002c20 <cpu_popStack+0xc8>
80002b88:	4a 3a       	lddpc	r10,80002c14 <cpu_popStack+0xbc>
80002b8a:	e0 6b 02 73 	mov	r11,627
80002b8e:	4a 3c       	lddpc	r12,80002c18 <cpu_popStack+0xc0>
80002b90:	f0 1f 00 23 	mcall	80002c1c <cpu_popStack+0xc4>
	cpu1->stackPointer++;
80002b94:	2f fb       	sub	r11,-1
80002b96:	5c 5b       	castu.b	r11
80002b98:	b8 ab       	st.b	r12[0x2],r11
	VALIDATE_STACK_POINTER(cpu1->stackPointer);
80002b9a:	f6 c8 ff 00 	sub	r8,r11,-256
80002b9e:	e0 48 01 ff 	cp.w	r8,511
80002ba2:	e0 8a 00 09 	brle	80002bb4 <cpu_popStack+0x5c>
80002ba6:	49 b9       	lddpc	r9,80002c10 <cpu_popStack+0xb8>
80002ba8:	49 ba       	lddpc	r10,80002c14 <cpu_popStack+0xbc>
80002baa:	e0 6b 02 75 	mov	r11,629
80002bae:	49 bc       	lddpc	r12,80002c18 <cpu_popStack+0xc0>
80002bb0:	f0 1f 00 1b 	mcall	80002c1c <cpu_popStack+0xc4>
80002bb4:	e0 48 00 ff 	cp.w	r8,255
80002bb8:	e0 89 00 09 	brgt	80002bca <cpu_popStack+0x72>
80002bbc:	49 99       	lddpc	r9,80002c20 <cpu_popStack+0xc8>
80002bbe:	49 6a       	lddpc	r10,80002c14 <cpu_popStack+0xbc>
80002bc0:	e0 6b 02 75 	mov	r11,629
80002bc4:	49 5c       	lddpc	r12,80002c18 <cpu_popStack+0xc0>
80002bc6:	f0 1f 00 16 	mcall	80002c1c <cpu_popStack+0xc4>
	Address stackAddress = GET_STACK_ADDRESS(cpu1->stackPointer);
80002bca:	f6 cb ff 00 	sub	r11,r11,-256
	VALIDATE_STACK_ADDRESS(stackAddress);
80002bce:	e0 68 01 ff 	mov	r8,511
80002bd2:	f0 0b 19 00 	cp.h	r11,r8
80002bd6:	e0 88 00 09 	brls	80002be8 <cpu_popStack+0x90>
80002bda:	49 39       	lddpc	r9,80002c24 <cpu_popStack+0xcc>
80002bdc:	48 ea       	lddpc	r10,80002c14 <cpu_popStack+0xbc>
80002bde:	e0 6b 02 77 	mov	r11,631
80002be2:	48 ec       	lddpc	r12,80002c18 <cpu_popStack+0xc0>
80002be4:	f0 1f 00 0e 	mcall	80002c1c <cpu_popStack+0xc4>
80002be8:	e0 68 00 ff 	mov	r8,255
80002bec:	f0 0b 19 00 	cp.h	r11,r8
80002bf0:	e0 8b 00 09 	brhi	80002c02 <cpu_popStack+0xaa>
80002bf4:	48 d9       	lddpc	r9,80002c28 <cpu_popStack+0xd0>
80002bf6:	48 8a       	lddpc	r10,80002c14 <cpu_popStack+0xbc>
80002bf8:	e0 6b 02 77 	mov	r11,631
80002bfc:	48 7c       	lddpc	r12,80002c18 <cpu_popStack+0xc0>
80002bfe:	f0 1f 00 08 	mcall	80002c1c <cpu_popStack+0xc4>
	Byte data = nes_readCPUMemory(nes, stackAddress);
80002c02:	0e 9c       	mov	r12,r7
80002c04:	f0 1f 00 0a 	mcall	80002c2c <cpu_popStack+0xd4>
	return data;
}
80002c08:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c0c:	80 00       	ld.sh	r0,r0[0x0]
80002c0e:	50 70       	stdsp	sp[0x1c],r0
80002c10:	80 01       	ld.sh	r1,r0[0x0]
80002c12:	3e 58       	mov	r8,-27
80002c14:	80 01       	ld.sh	r1,r0[0x0]
80002c16:	3d dc       	mov	r12,-35
80002c18:	80 01       	ld.sh	r1,r0[0x0]
80002c1a:	3e 20       	mov	r0,-30
80002c1c:	80 00       	ld.sh	r0,r0[0x0]
80002c1e:	c1 a0       	breq	80002c52 <cpu_RTS+0x22>
80002c20:	80 01       	ld.sh	r1,r0[0x0]
80002c22:	3e 98       	mov	r8,-23
80002c24:	80 01       	ld.sh	r1,r0[0x0]
80002c26:	3d fc       	mov	r12,-33
80002c28:	80 01       	ld.sh	r1,r0[0x0]
80002c2a:	3e 34       	mov	r4,-29
80002c2c:	80 00       	ld.sh	r0,r0[0x0]
80002c2e:	53 6c       	stdsp	sp[0xd8],r12

80002c30 <cpu_RTS>:
	cpu_handleInterrupt(nes, CPU_IRQ_VECTOR_LOWER_ADDRESS, TRUE);
}
// RTS - Return from Subroutine
// The RTS instruction is used at the end of a subroutine to return to the calling routine.
// It pulls the program counter (minus one) from the stack.
static void cpu_RTS(NES nes) {
80002c30:	d4 21       	pushm	r4-r7,lr
80002c32:	18 97       	mov	r7,r12
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80002c34:	f0 1f 00 0b 	mcall	80002c60 <cpu_RTS+0x30>
80002c38:	18 94       	mov	r4,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"RTS\n");
	// waste a cycle for the stack pointer increment that is about to happen in popStack
	nes_cpuCycled(nes);
80002c3a:	0e 9c       	mov	r12,r7
80002c3c:	f0 1f 00 0a 	mcall	80002c64 <cpu_RTS+0x34>
	Address address = cpu_popStack(nes);
80002c40:	0e 9c       	mov	r12,r7
80002c42:	f0 1f 00 0a 	mcall	80002c68 <cpu_RTS+0x38>
80002c46:	18 96       	mov	r6,r12
	address += cpu_popStack(nes) << BITS_PER_BYTE;
80002c48:	0e 9c       	mov	r12,r7
80002c4a:	f0 1f 00 08 	mcall	80002c68 <cpu_RTS+0x38>
80002c4e:	18 95       	mov	r5,r12
	// waste a cycle to increment the program counter
	nes_cpuCycled(nes);
80002c50:	0e 9c       	mov	r12,r7
80002c52:	f0 1f 00 05 	mcall	80002c64 <cpu_RTS+0x34>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"RTS\n");
	// waste a cycle for the stack pointer increment that is about to happen in popStack
	nes_cpuCycled(nes);
	Address address = cpu_popStack(nes);
	address += cpu_popStack(nes) << BITS_PER_BYTE;
80002c56:	2f f6       	sub	r6,-1
	// waste a cycle to increment the program counter
	nes_cpuCycled(nes);
	address++;
	cpu1->programCounter = address;
80002c58:	a9 65       	lsl	r5,0x8
80002c5a:	0a 06       	add	r6,r5
80002c5c:	a8 06       	st.h	r4[0x0],r6
}
80002c5e:	d8 22       	popm	r4-r7,pc
80002c60:	80 00       	ld.sh	r0,r0[0x0]
80002c62:	50 70       	stdsp	sp[0x1c],r0
80002c64:	80 00       	ld.sh	r0,r0[0x0]
80002c66:	51 64       	stdsp	sp[0x58],r4
80002c68:	80 00       	ld.sh	r0,r0[0x0]
80002c6a:	2b 58       	sub	r8,-75

80002c6c <cpu_RTI>:
// RTI - Return from Interrupt
// The RTI instruction is used at the end of an interrupt processing routine.
// It pulls the processor flags from the stack followed by the program counter.
static void cpu_RTI(NES nes) {
80002c6c:	eb cd 40 e0 	pushm	r5-r7,lr
80002c70:	18 97       	mov	r7,r12
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80002c72:	f0 1f 00 0d 	mcall	80002ca4 <cpu_RTI+0x38>
80002c76:	18 96       	mov	r6,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"RTI\n");
	// waste a cycle for the initial stack pointer increment that is about to happen in popStack
	nes_cpuCycled(nes);
80002c78:	0e 9c       	mov	r12,r7
80002c7a:	f0 1f 00 0c 	mcall	80002ca8 <cpu_RTI+0x3c>
	cpu1->status = cpu_popStack(nes);
80002c7e:	0e 9c       	mov	r12,r7
80002c80:	f0 1f 00 0b 	mcall	80002cac <cpu_RTI+0x40>
	// 1 at all times
	cpu1->status |= MASK_BIT5;
80002c84:	a5 bc       	sbr	r12,0x5
80002c86:	ac bc       	st.b	r6[0x3],r12
	Address address = cpu_popStack(nes);
80002c88:	0e 9c       	mov	r12,r7
80002c8a:	f0 1f 00 09 	mcall	80002cac <cpu_RTI+0x40>
80002c8e:	18 95       	mov	r5,r12
	address += cpu_popStack(nes) << BITS_PER_BYTE;
80002c90:	0e 9c       	mov	r12,r7
80002c92:	f0 1f 00 07 	mcall	80002cac <cpu_RTI+0x40>
	cpu1->programCounter = address;
80002c96:	a9 6c       	lsl	r12,0x8
80002c98:	f8 05 00 05 	add	r5,r12,r5
80002c9c:	ac 05       	st.h	r6[0x0],r5
}
80002c9e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002ca2:	00 00       	add	r0,r0
80002ca4:	80 00       	ld.sh	r0,r0[0x0]
80002ca6:	50 70       	stdsp	sp[0x1c],r0
80002ca8:	80 00       	ld.sh	r0,r0[0x0]
80002caa:	51 64       	stdsp	sp[0x58],r4
80002cac:	80 00       	ld.sh	r0,r0[0x0]
80002cae:	2b 58       	sub	r8,-75

80002cb0 <cpu_PLP>:
	cpu_pushStack(nes, data);
}
// PLP - Pull Processor Status
// Pulls an 8 bit value from the stack and into the processor flags.
// The flags will take on new states as determined by the value pulled.
static void cpu_PLP(NES nes) {
80002cb0:	eb cd 40 c0 	pushm	r6-r7,lr
80002cb4:	18 97       	mov	r7,r12
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80002cb6:	f0 1f 00 07 	mcall	80002cd0 <cpu_PLP+0x20>
80002cba:	18 96       	mov	r6,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"PLP\n");
	// waste a cycle for the stack pointer increment that is about to happen in popStack
	nes_cpuCycled(nes);
80002cbc:	0e 9c       	mov	r12,r7
80002cbe:	f0 1f 00 06 	mcall	80002cd4 <cpu_PLP+0x24>
	Byte data = cpu_popStack(nes);
80002cc2:	0e 9c       	mov	r12,r7
80002cc4:	f0 1f 00 05 	mcall	80002cd8 <cpu_PLP+0x28>
	//printf("PLP 0x%x 0x%x\n", cpu1->status, data);
	cpu1->status = data;
	// 1 at all times
	cpu1->status |= MASK_BIT5;
80002cc8:	a5 bc       	sbr	r12,0x5
80002cca:	ac bc       	st.b	r6[0x3],r12
}
80002ccc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002cd0:	80 00       	ld.sh	r0,r0[0x0]
80002cd2:	50 70       	stdsp	sp[0x1c],r0
80002cd4:	80 00       	ld.sh	r0,r0[0x0]
80002cd6:	51 64       	stdsp	sp[0x58],r4
80002cd8:	80 00       	ld.sh	r0,r0[0x0]
80002cda:	2b 58       	sub	r8,-75

80002cdc <cpu_PLA>:
	cpu_pushStack(nes, cpu1->accumulator);
}
// PLA - Pull Accumulator
// Pulls an 8 bit value from the stack and into the accumulator.
// The zero and negative flags are set as appropriate.
static void cpu_PLA(NES nes) {
80002cdc:	eb cd 40 c0 	pushm	r6-r7,lr
80002ce0:	18 96       	mov	r6,r12
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80002ce2:	f0 1f 00 0b 	mcall	80002d0c <cpu_PLA+0x30>
80002ce6:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"PLA\n");
	// waste a cycle for the stack pointer increment that is about to happen in popStack
	nes_cpuCycled(nes);
80002ce8:	0c 9c       	mov	r12,r6
80002cea:	f0 1f 00 0a 	mcall	80002d10 <cpu_PLA+0x34>
	cpu1->accumulator = cpu_popStack(nes);
80002cee:	0c 9c       	mov	r12,r6
80002cf0:	f0 1f 00 09 	mcall	80002d14 <cpu_PLA+0x38>
80002cf4:	18 9b       	mov	r11,r12
80002cf6:	ae ec       	st.b	r7[0x6],r12
	// Z Zero Flag       Set if A = 0
	cpu_updateZero(cpu1, cpu1->accumulator);
80002cf8:	0e 9c       	mov	r12,r7
80002cfa:	f0 1f 00 08 	mcall	80002d18 <cpu_PLA+0x3c>
	// N Negative Flag Set if bit 7 of A is set
	cpu_updateNegative(cpu1, cpu1->accumulator);
80002cfe:	0f eb       	ld.ub	r11,r7[0x6]
80002d00:	0e 9c       	mov	r12,r7
80002d02:	f0 1f 00 07 	mcall	80002d1c <cpu_PLA+0x40>
}
80002d06:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002d0a:	00 00       	add	r0,r0
80002d0c:	80 00       	ld.sh	r0,r0[0x0]
80002d0e:	50 70       	stdsp	sp[0x1c],r0
80002d10:	80 00       	ld.sh	r0,r0[0x0]
80002d12:	51 64       	stdsp	sp[0x58],r4
80002d14:	80 00       	ld.sh	r0,r0[0x0]
80002d16:	2b 58       	sub	r8,-75
80002d18:	80 00       	ld.sh	r0,r0[0x0]
80002d1a:	27 f0       	sub	r0,127
80002d1c:	80 00       	ld.sh	r0,r0[0x0]
80002d1e:	28 54       	sub	r4,-123

80002d20 <cpu_handleInterrupt>:
		return TRUE;
		} else {
		return FALSE;
	}
}
void cpu_handleInterrupt(NES nes, Address handlerLowByte, Bool fromBRK) {
80002d20:	d4 21       	pushm	r4-r7,lr
80002d22:	18 96       	mov	r6,r12
80002d24:	16 95       	mov	r5,r11
80002d26:	14 94       	mov	r4,r10
	assert(nes != NULL);
80002d28:	58 0c       	cp.w	r12,0
80002d2a:	c0 81       	brne	80002d3a <cpu_handleInterrupt+0x1a>
80002d2c:	4a 49       	lddpc	r9,80002dbc <cpu_handleInterrupt+0x9c>
80002d2e:	4a 5a       	lddpc	r10,80002dc0 <cpu_handleInterrupt+0xa0>
80002d30:	e0 6b 03 01 	mov	r11,769
80002d34:	4a 4c       	lddpc	r12,80002dc4 <cpu_handleInterrupt+0xa4>
80002d36:	f0 1f 00 25 	mcall	80002dc8 <cpu_handleInterrupt+0xa8>
	CPU cpu1 = nes_getCPU(nes);
80002d3a:	f0 1f 00 25 	mcall	80002dcc <cpu_handleInterrupt+0xac>
80002d3e:	18 97       	mov	r7,r12
	assert(cpu1 != NULL);
80002d40:	c0 81       	brne	80002d50 <cpu_handleInterrupt+0x30>
80002d42:	4a 49       	lddpc	r9,80002dd0 <cpu_handleInterrupt+0xb0>
80002d44:	49 fa       	lddpc	r10,80002dc0 <cpu_handleInterrupt+0xa0>
80002d46:	e0 6b 03 03 	mov	r11,771
80002d4a:	49 fc       	lddpc	r12,80002dc4 <cpu_handleInterrupt+0xa4>
80002d4c:	f0 1f 00 1f 	mcall	80002dc8 <cpu_handleInterrupt+0xa8>
	usart_write_line(&AVR32_USART0,"handleInterrupt\n");
80002d50:	4a 1b       	lddpc	r11,80002dd4 <cpu_handleInterrupt+0xb4>
80002d52:	fe 7c 14 00 	mov	r12,-60416
80002d56:	f0 1f 00 21 	mcall	80002dd8 <cpu_handleInterrupt+0xb8>
	cpu_setInterruptDisable(cpu1, TRUE);
80002d5a:	30 1b       	mov	r11,1
80002d5c:	0e 9c       	mov	r12,r7
80002d5e:	f0 1f 00 20 	mcall	80002ddc <cpu_handleInterrupt+0xbc>
	if (fromBRK == TRUE) {
80002d62:	30 18       	mov	r8,1
80002d64:	f0 04 18 00 	cp.b	r4,r8
80002d68:	c0 61       	brne	80002d74 <cpu_handleInterrupt+0x54>
		cpu_setBreak(cpu1, TRUE);
80002d6a:	30 1b       	mov	r11,1
80002d6c:	0e 9c       	mov	r12,r7
80002d6e:	f0 1f 00 1d 	mcall	80002de0 <cpu_handleInterrupt+0xc0>
80002d72:	c0 58       	rjmp	80002d7c <cpu_handleInterrupt+0x5c>
		} else {
		cpu_setBreak(cpu1, FALSE);
80002d74:	30 0b       	mov	r11,0
80002d76:	0e 9c       	mov	r12,r7
80002d78:	f0 1f 00 1a 	mcall	80002de0 <cpu_handleInterrupt+0xc0>
	}
	cpu_pushStack(nes, GET_ADDRESS_HIGH_BYTE(cpu1->programCounter));
80002d7c:	0f 8b       	ld.ub	r11,r7[0x0]
80002d7e:	0c 9c       	mov	r12,r6
80002d80:	f0 1f 00 19 	mcall	80002de4 <cpu_handleInterrupt+0xc4>
	cpu_pushStack(nes, GET_ADDRESS_LOW_BYTE(cpu1->programCounter));
80002d84:	0f 9b       	ld.ub	r11,r7[0x1]
80002d86:	0c 9c       	mov	r12,r6
80002d88:	f0 1f 00 17 	mcall	80002de4 <cpu_handleInterrupt+0xc4>
	// 1 at all times
	cpu1->status |= MASK_BIT5;
80002d8c:	0f bb       	ld.ub	r11,r7[0x3]
80002d8e:	a5 bb       	sbr	r11,0x5
80002d90:	5c 5b       	castu.b	r11
80002d92:	ae bb       	st.b	r7[0x3],r11
	cpu_pushStack(nes, cpu1->status);
80002d94:	0c 9c       	mov	r12,r6
80002d96:	f0 1f 00 14 	mcall	80002de4 <cpu_handleInterrupt+0xc4>
	//0xFFFC para el reset
	Address address = nes_readCPUMemory(nes, handlerLowByte);
80002d9a:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
80002d9e:	0c 9c       	mov	r12,r6
80002da0:	f0 1f 00 12 	mcall	80002de8 <cpu_handleInterrupt+0xc8>
80002da4:	18 94       	mov	r4,r12
	address += nes_readCPUMemory(nes, handlerLowByte+1) << BITS_PER_BYTE;
80002da6:	ea cb ff ff 	sub	r11,r5,-1
80002daa:	5c 7b       	castu.h	r11
80002dac:	0c 9c       	mov	r12,r6
80002dae:	f0 1f 00 0f 	mcall	80002de8 <cpu_handleInterrupt+0xc8>
	
    //usart_write_line(&AVR32_USART0,address);
	cpu1->programCounter = address;
80002db2:	a9 6c       	lsl	r12,0x8
80002db4:	f8 04 00 04 	add	r4,r12,r4
80002db8:	ae 04       	st.h	r7[0x0],r4
}
80002dba:	d8 22       	popm	r4-r7,pc
80002dbc:	80 01       	ld.sh	r1,r0[0x0]
80002dbe:	31 44       	mov	r4,20
80002dc0:	80 01       	ld.sh	r1,r0[0x0]
80002dc2:	3d c8       	mov	r8,-36
80002dc4:	80 01       	ld.sh	r1,r0[0x0]
80002dc6:	3e 20       	mov	r0,-30
80002dc8:	80 00       	ld.sh	r0,r0[0x0]
80002dca:	c1 a0       	breq	80002dfe <cpu_BRK+0x12>
80002dcc:	80 00       	ld.sh	r0,r0[0x0]
80002dce:	50 70       	stdsp	sp[0x1c],r0
80002dd0:	80 01       	ld.sh	r1,r0[0x0]
80002dd2:	3e d8       	mov	r8,-19
80002dd4:	80 01       	ld.sh	r1,r0[0x0]
80002dd6:	3e e8       	mov	r8,-18
80002dd8:	80 00       	ld.sh	r0,r0[0x0]
80002dda:	8e 5c       	ld.sh	r12,r7[0xa]
80002ddc:	80 00       	ld.sh	r0,r0[0x0]
80002dde:	28 e0       	sub	r0,-114
80002de0:	80 00       	ld.sh	r0,r0[0x0]
80002de2:	29 04       	sub	r4,-112
80002de4:	80 00       	ld.sh	r0,r0[0x0]
80002de6:	2a 6c       	sub	r12,-90
80002de8:	80 00       	ld.sh	r0,r0[0x0]
80002dea:	53 6c       	stdsp	sp[0xd8],r12

80002dec <cpu_BRK>:
// BRK - Force Interrupt
// The BRK instruction forces the generation of an interrupt request.
// The program counter and processor status are pushed on the stack
// then the IRQ interrupt vector at $FFFE/F is loaded into the PC
// and the break flag in the status set to one.
static void cpu_BRK(NES nes) {
80002dec:	eb cd 40 80 	pushm	r7,lr
80002df0:	18 97       	mov	r7,r12
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80002df2:	f0 1f 00 07 	mcall	80002e0c <cpu_BRK+0x20>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BRK\n");
	// the instruction has a "useless" second byte we need to skip
	// (added for debugging purposes apparently)
	cpu1->programCounter++;
80002df6:	98 08       	ld.sh	r8,r12[0x0]
80002df8:	2f f8       	sub	r8,-1
80002dfa:	b8 08       	st.h	r12[0x0],r8
	// B         Break Command          Set to 1
	cpu_handleInterrupt(nes, CPU_IRQ_VECTOR_LOWER_ADDRESS, TRUE);
80002dfc:	30 1a       	mov	r10,1
80002dfe:	e0 6b ff fe 	mov	r11,65534
80002e02:	0e 9c       	mov	r12,r7
80002e04:	f0 1f 00 03 	mcall	80002e10 <cpu_BRK+0x24>
}
80002e08:	e3 cd 80 80 	ldm	sp++,r7,pc
80002e0c:	80 00       	ld.sh	r0,r0[0x0]
80002e0e:	50 70       	stdsp	sp[0x1c],r0
80002e10:	80 00       	ld.sh	r0,r0[0x0]
80002e12:	2d 20       	sub	r0,-46

80002e14 <cpu_step>:
		// +1 cycle if the branch succeeds
		nes_cpuCycled(nes);
		cpu1->programCounter += data;
	}
}
void cpu_step(NES nes) {
80002e14:	eb cd 40 fc 	pushm	r2-r7,lr
80002e18:	18 94       	mov	r4,r12
	//assert(nes != NULL);
	//usart_write_line(&AVR32_USART0,"cpu_step\n");
	CPU cpu1 = nes_getCPU(nes);
80002e1a:	f0 1f 02 b9 	mcall	800038fc <cpu_step+0xae8>
80002e1e:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	Byte instruction = nes_readCPUMemory(nes, cpu1->programCounter);
80002e20:	98 8b       	ld.uh	r11,r12[0x0]
80002e22:	08 9c       	mov	r12,r4
80002e24:	f0 1f 02 b7 	mcall	80003900 <cpu_step+0xaec>
80002e28:	18 95       	mov	r5,r12
	usart_write_char(&AVR32_USART0,instruction);
80002e2a:	18 9b       	mov	r11,r12
80002e2c:	fe 7c 14 00 	mov	r12,-60416
80002e30:	f0 1f 02 b5 	mcall	80003904 <cpu_step+0xaf0>
	cpu_increaseProgramCounter(cpu1);
80002e34:	0e 9c       	mov	r12,r7
80002e36:	f0 1f 02 b5 	mcall	80003908 <cpu_step+0xaf4>
//	//usart_write_line(&AVR32_USART0,"Instruction: 0x%x\n", instruction);
	Address address = 0;
	switch(instruction) {
80002e3a:	e0 45 00 ff 	cp.w	r5,255
80002e3e:	e0 8b 00 06 	brhi	80002e4a <cpu_step+0x36>
80002e42:	fe f8 0a ca 	ld.w	r8,pc[2762]
80002e46:	f0 05 03 2f 	ld.w	pc,r8[r5<<0x2]
80002e4a:	30 06       	mov	r6,0
80002e4c:	cd 78       	rjmp	80002ffa <cpu_step+0x1e6>
		case CMP_IMM:
		case CPX_IMM:
		case CPY_IMM:
		case ADC_IMM:
		case SBC_IMM:
		address = cpu1->programCounter;
80002e4e:	8e 06       	ld.sh	r6,r7[0x0]
		cpu_increaseProgramCounter(cpu1);
80002e50:	0e 9c       	mov	r12,r7
80002e52:	f0 1f 02 ae 	mcall	80003908 <cpu_step+0xaf4>
		break;
80002e56:	cd 28       	rjmp	80002ffa <cpu_step+0x1e6>
		case LSR_ZPAGE:
		case ROL_ZPAGE:
		case ROR_ZPAGE:
		case INC_ZPAGE:
		case DEC_ZPAGE:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
80002e58:	8e 8b       	ld.uh	r11,r7[0x0]
80002e5a:	08 9c       	mov	r12,r4
80002e5c:	f0 1f 02 a9 	mcall	80003900 <cpu_step+0xaec>
80002e60:	18 96       	mov	r6,r12
		cpu_increaseProgramCounter(cpu1);
80002e62:	0e 9c       	mov	r12,r7
80002e64:	f0 1f 02 a9 	mcall	80003908 <cpu_step+0xaf4>
		break;
80002e68:	cc 98       	rjmp	80002ffa <cpu_step+0x1e6>
		case ROL_ZPAGEX:
		case ROR_ZPAGEX:
		case INC_ZPAGEX:
		case DEC_ZPAGEX:
		{
			Byte data = nes_readCPUMemory(nes, cpu1->programCounter);
80002e6a:	8e 8b       	ld.uh	r11,r7[0x0]
80002e6c:	08 9c       	mov	r12,r4
80002e6e:	f0 1f 02 a5 	mcall	80003900 <cpu_step+0xaec>
80002e72:	18 96       	mov	r6,r12
			cpu_increaseProgramCounter(cpu1);
80002e74:	0e 9c       	mov	r12,r7
80002e76:	f0 1f 02 a5 	mcall	80003908 <cpu_step+0xaf4>
			data += cpu1->indexX;
			address = data;
80002e7a:	0f c8       	ld.ub	r8,r7[0x4]
80002e7c:	f0 06 00 06 	add	r6,r8,r6
80002e80:	5c 56       	castu.b	r6
		}
		break;
80002e82:	cb c8       	rjmp	80002ffa <cpu_step+0x1e6>
		case ROR_ABS:
		case INC_ABS:
		case DEC_ABS:
		case JSR_ABS:
		case JMP_ABS:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
80002e84:	8e 8b       	ld.uh	r11,r7[0x0]
80002e86:	08 9c       	mov	r12,r4
80002e88:	f0 1f 02 9e 	mcall	80003900 <cpu_step+0xaec>
80002e8c:	18 96       	mov	r6,r12
		cpu_increaseProgramCounter(cpu1);
80002e8e:	0e 9c       	mov	r12,r7
80002e90:	f0 1f 02 9e 	mcall	80003908 <cpu_step+0xaf4>
		address += nes_readCPUMemory(nes, cpu1->programCounter) << BITS_PER_BYTE;
80002e94:	8e 8b       	ld.uh	r11,r7[0x0]
80002e96:	08 9c       	mov	r12,r4
80002e98:	f0 1f 02 9a 	mcall	80003900 <cpu_step+0xaec>
80002e9c:	a9 6c       	lsl	r12,0x8
80002e9e:	f8 06 00 06 	add	r6,r12,r6
80002ea2:	5c 86       	casts.h	r6
		cpu_increaseProgramCounter(cpu1);
80002ea4:	0e 9c       	mov	r12,r7
80002ea6:	f0 1f 02 99 	mcall	80003908 <cpu_step+0xaf4>
		break;
80002eaa:	ca 88       	rjmp	80002ffa <cpu_step+0x1e6>
		case LSR_ABSX:
		case ROL_ABSX:
		case ROR_ABSX:
		case INC_ABSX:
		case DEC_ABSX:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
80002eac:	8e 8b       	ld.uh	r11,r7[0x0]
80002eae:	08 9c       	mov	r12,r4
80002eb0:	f0 1f 02 94 	mcall	80003900 <cpu_step+0xaec>
80002eb4:	18 96       	mov	r6,r12
		cpu_increaseProgramCounter(cpu1);
80002eb6:	0e 9c       	mov	r12,r7
80002eb8:	f0 1f 02 94 	mcall	80003908 <cpu_step+0xaf4>
		address += nes_readCPUMemory(nes, cpu1->programCounter) << BITS_PER_BYTE;
80002ebc:	8e 8b       	ld.uh	r11,r7[0x0]
80002ebe:	08 9c       	mov	r12,r4
80002ec0:	f0 1f 02 90 	mcall	80003900 <cpu_step+0xaec>
80002ec4:	18 93       	mov	r3,r12
		cpu_increaseProgramCounter(cpu1);
80002ec6:	0e 9c       	mov	r12,r7
80002ec8:	f0 1f 02 90 	mcall	80003908 <cpu_step+0xaf4>
		case ROR_ABSX:
		case INC_ABSX:
		case DEC_ABSX:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
		cpu_increaseProgramCounter(cpu1);
		address += nes_readCPUMemory(nes, cpu1->programCounter) << BITS_PER_BYTE;
80002ecc:	0f c8       	ld.ub	r8,r7[0x4]
80002ece:	f0 06 00 06 	add	r6,r8,r6
		cpu_increaseProgramCounter(cpu1);
		address += cpu1->indexX;
80002ed2:	a9 63       	lsl	r3,0x8
80002ed4:	06 06       	add	r6,r3
80002ed6:	5c 86       	casts.h	r6
		break;
80002ed8:	c9 18       	rjmp	80002ffa <cpu_step+0x1e6>
		case ORA_ABSY:
		case EOR_ABSY:
		case CMP_ABSY:
		case ADC_ABSY:
		case SBC_ABSY:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
80002eda:	8e 8b       	ld.uh	r11,r7[0x0]
80002edc:	08 9c       	mov	r12,r4
80002ede:	f0 1f 02 89 	mcall	80003900 <cpu_step+0xaec>
80002ee2:	18 96       	mov	r6,r12
		cpu_increaseProgramCounter(cpu1);
80002ee4:	0e 9c       	mov	r12,r7
80002ee6:	f0 1f 02 89 	mcall	80003908 <cpu_step+0xaf4>
		address += nes_readCPUMemory(nes, cpu1->programCounter) << BITS_PER_BYTE;
80002eea:	8e 8b       	ld.uh	r11,r7[0x0]
80002eec:	08 9c       	mov	r12,r4
80002eee:	f0 1f 02 85 	mcall	80003900 <cpu_step+0xaec>
80002ef2:	18 93       	mov	r3,r12
		cpu_increaseProgramCounter(cpu1);
80002ef4:	0e 9c       	mov	r12,r7
80002ef6:	f0 1f 02 85 	mcall	80003908 <cpu_step+0xaf4>
		case CMP_ABSY:
		case ADC_ABSY:
		case SBC_ABSY:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
		cpu_increaseProgramCounter(cpu1);
		address += nes_readCPUMemory(nes, cpu1->programCounter) << BITS_PER_BYTE;
80002efa:	0f d8       	ld.ub	r8,r7[0x5]
80002efc:	f0 06 00 06 	add	r6,r8,r6
		cpu_increaseProgramCounter(cpu1);
		address += cpu1->indexY;
80002f00:	a9 63       	lsl	r3,0x8
80002f02:	06 06       	add	r6,r3
80002f04:	5c 86       	casts.h	r6
		break;
80002f06:	c7 a8       	rjmp	80002ffa <cpu_step+0x1e6>
		case EOR_INDX:
		case CMP_INDX:
		case ADC_INDX:
		case SBC_INDX:
		{
			Byte data = nes_readCPUMemory(nes, cpu1->programCounter);
80002f08:	8e 8b       	ld.uh	r11,r7[0x0]
80002f0a:	08 9c       	mov	r12,r4
80002f0c:	f0 1f 02 7d 	mcall	80003900 <cpu_step+0xaec>
80002f10:	18 96       	mov	r6,r12
			cpu_increaseProgramCounter(cpu1);
80002f12:	0e 9c       	mov	r12,r7
80002f14:	f0 1f 02 7d 	mcall	80003908 <cpu_step+0xaf4>
			data += cpu1->indexX;
80002f18:	0f c8       	ld.ub	r8,r7[0x4]
80002f1a:	f0 06 00 06 	add	r6,r8,r6
80002f1e:	5c 56       	castu.b	r6
			Byte lowAddress = data;
			Byte highAddress = data + 1;
			address = nes_readCPUMemory(nes, lowAddress);
80002f20:	0c 9b       	mov	r11,r6
80002f22:	08 9c       	mov	r12,r4
80002f24:	f0 1f 02 77 	mcall	80003900 <cpu_step+0xaec>
80002f28:	18 93       	mov	r3,r12
			address += nes_readCPUMemory(nes, highAddress) << BITS_PER_BYTE;
80002f2a:	ec cb ff ff 	sub	r11,r6,-1
80002f2e:	5c 5b       	castu.b	r11
80002f30:	08 9c       	mov	r12,r4
80002f32:	f0 1f 02 74 	mcall	80003900 <cpu_step+0xaec>
80002f36:	f8 06 15 08 	lsl	r6,r12,0x8
80002f3a:	06 06       	add	r6,r3
80002f3c:	5c 86       	casts.h	r6
		}
		break;
80002f3e:	c5 e8       	rjmp	80002ffa <cpu_step+0x1e6>
		case EOR_INDY:
		case CMP_INDY:
		case ADC_INDY:
		case SBC_INDY:
		{
			Byte data = nes_readCPUMemory(nes, cpu1->programCounter);
80002f40:	8e 8b       	ld.uh	r11,r7[0x0]
80002f42:	08 9c       	mov	r12,r4
80002f44:	f0 1f 02 6f 	mcall	80003900 <cpu_step+0xaec>
80002f48:	18 96       	mov	r6,r12
			cpu_increaseProgramCounter(cpu1);
80002f4a:	0e 9c       	mov	r12,r7
80002f4c:	f0 1f 02 6f 	mcall	80003908 <cpu_step+0xaf4>
			Byte lowAddress = data;
			Byte highAddress = data+1;
			address = nes_readCPUMemory(nes, lowAddress);
80002f50:	0c 9b       	mov	r11,r6
80002f52:	08 9c       	mov	r12,r4
80002f54:	f0 1f 02 6b 	mcall	80003900 <cpu_step+0xaec>
80002f58:	18 93       	mov	r3,r12
			address += nes_readCPUMemory(nes, highAddress) << BITS_PER_BYTE;    // is the +1 meant to wraparound to zero page as well?
80002f5a:	ec cb ff ff 	sub	r11,r6,-1
80002f5e:	5c 5b       	castu.b	r11
80002f60:	08 9c       	mov	r12,r4
80002f62:	f0 1f 02 68 	mcall	80003900 <cpu_step+0xaec>
80002f66:	0f d6       	ld.ub	r6,r7[0x5]
80002f68:	ec 03 00 03 	add	r3,r6,r3
			address += cpu1->indexY;
80002f6c:	a9 6c       	lsl	r12,0x8
80002f6e:	18 03       	add	r3,r12
80002f70:	ed d3 b0 10 	bfexts	r6,r3,0x0,0x10
		}
		break;
80002f74:	c4 38       	rjmp	80002ffa <cpu_step+0x1e6>
		case LDX_ZPAGEY:
		case STX_ZPAGEY:
		{
			Byte data = nes_readCPUMemory(nes, cpu1->programCounter);
80002f76:	8e 8b       	ld.uh	r11,r7[0x0]
80002f78:	08 9c       	mov	r12,r4
80002f7a:	f0 1f 02 62 	mcall	80003900 <cpu_step+0xaec>
80002f7e:	18 96       	mov	r6,r12
			cpu_increaseProgramCounter(cpu1);
80002f80:	0e 9c       	mov	r12,r7
80002f82:	f0 1f 02 62 	mcall	80003908 <cpu_step+0xaf4>
			data += cpu1->indexY;
			address = data;
80002f86:	0f d8       	ld.ub	r8,r7[0x5]
80002f88:	f0 06 00 06 	add	r6,r8,r6
80002f8c:	5c 56       	castu.b	r6
		}
		break;
80002f8e:	c3 68       	rjmp	80002ffa <cpu_step+0x1e6>
		case ASL_ACCUM:
		case LSR_ACCUM:
		case ROL_ACCUM:
		case ROR_ACCUM:
		// these take 2 cycles. do a dummy read so that the ppu/apu get to advance
		nes_cpuCycled(nes);
80002f90:	08 9c       	mov	r12,r4
80002f92:	f0 1f 02 60 	mcall	80003910 <cpu_step+0xafc>
80002f96:	30 06       	mov	r6,0
		break;
80002f98:	c3 18       	rjmp	80002ffa <cpu_step+0x1e6>
		case JMP_INDIRECT_CODE1:
		case JMP_INDIRECT_CODE2:
		{
			Byte directAddressLow = nes_readCPUMemory(nes, cpu1->programCounter);
80002f9a:	8e 8b       	ld.uh	r11,r7[0x0]
80002f9c:	08 9c       	mov	r12,r4
80002f9e:	f0 1f 02 59 	mcall	80003900 <cpu_step+0xaec>
80002fa2:	18 93       	mov	r3,r12
			cpu_increaseProgramCounter(cpu1);
80002fa4:	0e 9c       	mov	r12,r7
80002fa6:	f0 1f 02 59 	mcall	80003908 <cpu_step+0xaf4>
			Byte directAddressHigh = nes_readCPUMemory(nes, cpu1->programCounter);
80002faa:	8e 8b       	ld.uh	r11,r7[0x0]
80002fac:	08 9c       	mov	r12,r4
80002fae:	f0 1f 02 55 	mcall	80003900 <cpu_step+0xaec>
80002fb2:	18 96       	mov	r6,r12
			cpu_increaseProgramCounter(cpu1);
80002fb4:	0e 9c       	mov	r12,r7
80002fb6:	f0 1f 02 55 	mcall	80003908 <cpu_step+0xaf4>
			Address lowAddress = directAddressLow;
			lowAddress += directAddressHigh << BITS_PER_BYTE;
80002fba:	a9 66       	lsl	r6,0x8
			directAddressLow++;
			Address highAddress = directAddressLow;
80002fbc:	e6 c2 ff ff 	sub	r2,r3,-1
80002fc0:	5c 52       	castu.b	r2
			highAddress += directAddressHigh << BITS_PER_BYTE;
			address = nes_readCPUMemory(nes, lowAddress);
80002fc2:	ec 03 00 0b 	add	r11,r6,r3
80002fc6:	5c 7b       	castu.h	r11
80002fc8:	08 9c       	mov	r12,r4
80002fca:	f0 1f 02 4e 	mcall	80003900 <cpu_step+0xaec>
80002fce:	18 93       	mov	r3,r12
			address += nes_readCPUMemory(nes, highAddress) << BITS_PER_BYTE;
80002fd0:	e4 06 00 06 	add	r6,r2,r6
80002fd4:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80002fd8:	08 9c       	mov	r12,r4
80002fda:	f0 1f 02 4a 	mcall	80003900 <cpu_step+0xaec>
80002fde:	f8 06 15 08 	lsl	r6,r12,0x8
80002fe2:	06 06       	add	r6,r3
80002fe4:	5c 86       	casts.h	r6
		}
		break;
80002fe6:	c0 a8       	rjmp	80002ffa <cpu_step+0x1e6>
		case SEC:
		case CLC:
		case CLV:
		case NOP:
		// these take 2+ cycles. do a dummy read so that the ppu/apu get to advance
		nes_cpuCycled(nes);
80002fe8:	08 9c       	mov	r12,r4
80002fea:	f0 1f 02 4a 	mcall	80003910 <cpu_step+0xafc>
80002fee:	30 06       	mov	r6,0
		break;
80002ff0:	c0 58       	rjmp	80002ffa <cpu_step+0x1e6>
		case BPL:
		case BCC:
		case BCS:
		case BVC:
		case BVS:
		address = cpu1->programCounter;
80002ff2:	8e 06       	ld.sh	r6,r7[0x0]
		cpu_increaseProgramCounter(cpu1);
80002ff4:	0e 9c       	mov	r12,r7
80002ff6:	f0 1f 02 45 	mcall	80003908 <cpu_step+0xaf4>
		break;
		//printf("Instruction not implemented: 0x%x\n", instruction);
		////usart_write_line(&AVR32_USART0,"Instruction not implemented: 0x%x\n", instruction);
		//assert(FALSE);
	}
	switch(instruction) {
80002ffa:	e0 45 00 ff 	cp.w	r5,255
80002ffe:	e0 8b 04 7d 	brhi	800038f8 <cpu_step+0xae4>
80003002:	fe f8 09 12 	ld.w	r8,pc[2322]
80003006:	f0 05 03 2f 	ld.w	pc,r8[r5<<0x2]
}
// LDA - Load Accumulator
// Loads a byte of memory into the accumulator setting the zero and negative flags as appropriate.
static void cpu_LDA(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
8000300a:	08 9c       	mov	r12,r4
8000300c:	f0 1f 02 3c 	mcall	800038fc <cpu_step+0xae8>
80003010:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"LDA\n");
	Byte data = nes_readCPUMemory(nes, address);
80003012:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80003016:	08 9c       	mov	r12,r4
80003018:	f0 1f 02 3a 	mcall	80003900 <cpu_step+0xaec>
8000301c:	18 96       	mov	r6,r12
	cpu_updateZero(cpu1, data);
8000301e:	18 9b       	mov	r11,r12
80003020:	0e 9c       	mov	r12,r7
80003022:	f0 1f 02 3e 	mcall	80003918 <cpu_step+0xb04>
	cpu_updateNegative(cpu1, data);
80003026:	0c 9b       	mov	r11,r6
80003028:	0e 9c       	mov	r12,r7
8000302a:	f0 1f 02 3d 	mcall	8000391c <cpu_step+0xb08>
	cpu_setAccumulator(cpu1, data);
8000302e:	0c 9b       	mov	r11,r6
80003030:	0e 9c       	mov	r12,r7
80003032:	f0 1f 02 3c 	mcall	80003920 <cpu_step+0xb0c>
80003036:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// STA - Store Accumulator
// Stores the contents of the accumulator into memory.
static void cpu_STA(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
8000303a:	08 9c       	mov	r12,r4
8000303c:	f0 1f 02 30 	mcall	800038fc <cpu_step+0xae8>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"STA\n");
	nes_writeCPUMemory(nes, address, cpu1->accumulator);
80003040:	19 ea       	ld.ub	r10,r12[0x6]
80003042:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80003046:	08 9c       	mov	r12,r4
80003048:	f0 1f 02 37 	mcall	80003924 <cpu_step+0xb10>
8000304c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// LDX - Load X Register
// Loads a byte of memory into the X register setting the zero and negative flags as appropriate.
static void cpu_LDX(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80003050:	08 9c       	mov	r12,r4
80003052:	f0 1f 02 2b 	mcall	800038fc <cpu_step+0xae8>
80003056:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"LDX\n");
	Byte data = nes_readCPUMemory(nes, address);
80003058:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
8000305c:	08 9c       	mov	r12,r4
8000305e:	f0 1f 02 29 	mcall	80003900 <cpu_step+0xaec>
80003062:	18 96       	mov	r6,r12
	cpu_updateZero(cpu1, data);
80003064:	18 9b       	mov	r11,r12
80003066:	0e 9c       	mov	r12,r7
80003068:	f0 1f 02 2c 	mcall	80003918 <cpu_step+0xb04>
	cpu_updateNegative(cpu1, data);
8000306c:	0c 9b       	mov	r11,r6
8000306e:	0e 9c       	mov	r12,r7
80003070:	f0 1f 02 2b 	mcall	8000391c <cpu_step+0xb08>
	cpu_setIndexX(cpu1, data);
80003074:	0c 9b       	mov	r11,r6
80003076:	0e 9c       	mov	r12,r7
80003078:	f0 1f 02 2c 	mcall	80003928 <cpu_step+0xb14>
8000307c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// STX - Store X Register
// Stores the contents of the X register into memory.
static void cpu_STX(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80003080:	08 9c       	mov	r12,r4
80003082:	f0 1f 02 1f 	mcall	800038fc <cpu_step+0xae8>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"STX\n");
	nes_writeCPUMemory(nes, address, cpu1->indexX);
80003086:	19 ca       	ld.ub	r10,r12[0x4]
80003088:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
8000308c:	08 9c       	mov	r12,r4
8000308e:	f0 1f 02 26 	mcall	80003924 <cpu_step+0xb10>
80003092:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// LDY - Load Y Register
// Loads a byte of memory into the Y register setting the zero and negative flags as appropriate.
static void cpu_LDY(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80003096:	08 9c       	mov	r12,r4
80003098:	f0 1f 02 19 	mcall	800038fc <cpu_step+0xae8>
8000309c:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"LDY\n");
	Byte data = nes_readCPUMemory(nes, address);
8000309e:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800030a2:	08 9c       	mov	r12,r4
800030a4:	f0 1f 02 17 	mcall	80003900 <cpu_step+0xaec>
800030a8:	18 96       	mov	r6,r12
	cpu_updateZero(cpu1, data);
800030aa:	18 9b       	mov	r11,r12
800030ac:	0e 9c       	mov	r12,r7
800030ae:	f0 1f 02 1b 	mcall	80003918 <cpu_step+0xb04>
	cpu_updateNegative(cpu1, data);
800030b2:	0c 9b       	mov	r11,r6
800030b4:	0e 9c       	mov	r12,r7
800030b6:	f0 1f 02 1a 	mcall	8000391c <cpu_step+0xb08>
	cpu_setIndexY(cpu1, data);
800030ba:	0c 9b       	mov	r11,r6
800030bc:	0e 9c       	mov	r12,r7
800030be:	f0 1f 02 1c 	mcall	8000392c <cpu_step+0xb18>
800030c2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// STY - Store Y Register
// Stores the contents of the Y register into memory.
static void cpu_STY(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
800030c6:	08 9c       	mov	r12,r4
800030c8:	f0 1f 02 0d 	mcall	800038fc <cpu_step+0xae8>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"STY\n");
	nes_writeCPUMemory(nes, address, cpu1->indexY);
800030cc:	19 da       	ld.ub	r10,r12[0x5]
800030ce:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800030d2:	08 9c       	mov	r12,r4
800030d4:	f0 1f 02 14 	mcall	80003924 <cpu_step+0xb10>
800030d8:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// AND - Logical AND
// A logical AND is performed, bit by bit, on the accumulator contents using the contents of a byte of memory.
static void cpu_AND(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
800030dc:	08 9c       	mov	r12,r4
800030de:	f0 1f 02 08 	mcall	800038fc <cpu_step+0xae8>
800030e2:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"AND\n");
	Byte data = nes_readCPUMemory(nes, address);
800030e4:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800030e8:	08 9c       	mov	r12,r4
800030ea:	f0 1f 02 06 	mcall	80003900 <cpu_step+0xaec>
	cpu1->accumulator &= data;
800030ee:	0f e8       	ld.ub	r8,r7[0x6]
800030f0:	f9 e8 00 0b 	and	r11,r12,r8
800030f4:	ae eb       	st.b	r7[0x6],r11
	cpu_updateZero(cpu1, cpu1->accumulator);
800030f6:	0e 9c       	mov	r12,r7
800030f8:	f0 1f 02 08 	mcall	80003918 <cpu_step+0xb04>
	cpu_updateNegative(cpu1, cpu1->accumulator);
800030fc:	0f eb       	ld.ub	r11,r7[0x6]
800030fe:	0e 9c       	mov	r12,r7
80003100:	f0 1f 02 07 	mcall	8000391c <cpu_step+0xb08>
80003104:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// ORA - Logical Inclusive OR
// An inclusive OR is performed, bit by bit, on the accumulator contents using the contents of a byte of memory.
static void cpu_ORA(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80003108:	08 9c       	mov	r12,r4
8000310a:	f0 1f 01 fd 	mcall	800038fc <cpu_step+0xae8>
8000310e:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"ORA\n");
	Byte data = nes_readCPUMemory(nes, address);
80003110:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80003114:	08 9c       	mov	r12,r4
80003116:	f0 1f 01 fb 	mcall	80003900 <cpu_step+0xaec>
	cpu1->accumulator |= data;
8000311a:	0f e8       	ld.ub	r8,r7[0x6]
8000311c:	f9 e8 10 08 	or	r8,r12,r8
80003120:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
80003124:	ae eb       	st.b	r7[0x6],r11
	cpu_updateZero(cpu1, cpu1->accumulator);
80003126:	0e 9c       	mov	r12,r7
80003128:	f0 1f 01 fc 	mcall	80003918 <cpu_step+0xb04>
	cpu_updateNegative(cpu1, cpu1->accumulator);
8000312c:	0f eb       	ld.ub	r11,r7[0x6]
8000312e:	0e 9c       	mov	r12,r7
80003130:	f0 1f 01 fb 	mcall	8000391c <cpu_step+0xb08>
80003134:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// EOR - Exclusive OR
// An exclusive OR is performed, bit by bit, on the accumulator contents using the ontents of a byte of memory.
static void cpu_EOR(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80003138:	08 9c       	mov	r12,r4
8000313a:	f0 1f 01 f1 	mcall	800038fc <cpu_step+0xae8>
8000313e:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"EOR\n");
	Byte data = nes_readCPUMemory(nes, address);
80003140:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80003144:	08 9c       	mov	r12,r4
80003146:	f0 1f 01 ef 	mcall	80003900 <cpu_step+0xaec>
	cpu1->accumulator ^= data;
8000314a:	0f e8       	ld.ub	r8,r7[0x6]
8000314c:	f9 e8 20 08 	eor	r8,r12,r8
80003150:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
80003154:	ae eb       	st.b	r7[0x6],r11
	cpu_updateZero(cpu1, cpu1->accumulator);
80003156:	0e 9c       	mov	r12,r7
80003158:	f0 1f 01 f0 	mcall	80003918 <cpu_step+0xb04>
	cpu_updateNegative(cpu1, cpu1->accumulator);
8000315c:	0f eb       	ld.ub	r11,r7[0x6]
8000315e:	0e 9c       	mov	r12,r7
80003160:	f0 1f 01 ef 	mcall	8000391c <cpu_step+0xb08>
80003164:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// This instructions is used to test if one or more bits are set in a target memory location.
// The mask pattern in A is ANDed with the value in memory to set or clear the zero flag, but the result is not kept.
// Bits 7 and 6 of the value from memory are copied into the N and V flags.
static void cpu_BIT(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80003168:	08 9c       	mov	r12,r4
8000316a:	f0 1f 01 e5 	mcall	800038fc <cpu_step+0xae8>
8000316e:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BIT\n");
	Byte data = nes_readCPUMemory(nes, address);
80003170:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80003174:	08 9c       	mov	r12,r4
80003176:	f0 1f 01 e3 	mcall	80003900 <cpu_step+0xaec>
8000317a:	18 96       	mov	r6,r12
	cpu_updateZero(cpu1, cpu1->accumulator & data);
8000317c:	0f eb       	ld.ub	r11,r7[0x6]
8000317e:	f9 eb 00 0b 	and	r11,r12,r11
80003182:	0e 9c       	mov	r12,r7
80003184:	f0 1f 01 e5 	mcall	80003918 <cpu_step+0xb04>
	cpu_updateNegative(cpu1, data);
80003188:	0c 9b       	mov	r11,r6
8000318a:	0e 9c       	mov	r12,r7
8000318c:	f0 1f 01 e4 	mcall	8000391c <cpu_step+0xb08>
	if ((data & MASK_BIT6) == MASK_BIT6) {
80003190:	e2 16 00 40 	andl	r6,0x40,COH
80003194:	c0 70       	breq	800031a2 <cpu_step+0x38e>
		cpu_setOverflow(cpu1, TRUE);
80003196:	30 1b       	mov	r11,1
80003198:	0e 9c       	mov	r12,r7
8000319a:	f0 1f 01 e6 	mcall	80003930 <cpu_step+0xb1c>
8000319e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		} else {
		cpu_setOverflow(cpu1, FALSE);
800031a2:	30 0b       	mov	r11,0
800031a4:	0e 9c       	mov	r12,r7
800031a6:	f0 1f 01 e3 	mcall	80003930 <cpu_step+0xb1c>
800031aa:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// CMP - Compare
// This instruction compares the contents of the accumulator with another memory held value and sets the zero and carry flags as appropriate.
static void cpu_CMP(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
800031ae:	08 9c       	mov	r12,r4
800031b0:	f0 1f 01 d3 	mcall	800038fc <cpu_step+0xae8>
800031b4:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"CMP\n");
	Byte data = nes_readCPUMemory(nes, address);
800031b6:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800031ba:	08 9c       	mov	r12,r4
800031bc:	f0 1f 01 d1 	mcall	80003900 <cpu_step+0xaec>
800031c0:	18 96       	mov	r6,r12
	// C         Carry Flag     Set if A >= M
	cpu_updateCarry_subtract(cpu1, cpu1->accumulator, data);
800031c2:	18 9a       	mov	r10,r12
800031c4:	0f eb       	ld.ub	r11,r7[0x6]
800031c6:	0e 9c       	mov	r12,r7
800031c8:	f0 1f 01 db 	mcall	80003934 <cpu_step+0xb20>
	// Z Zero Flag       Set if A = M
	cpu_updateZero(cpu1, cpu1->accumulator - data);
800031cc:	0f eb       	ld.ub	r11,r7[0x6]
800031ce:	0c 1b       	sub	r11,r6
800031d0:	5c 5b       	castu.b	r11
800031d2:	0e 9c       	mov	r12,r7
800031d4:	f0 1f 01 d1 	mcall	80003918 <cpu_step+0xb04>
	// N Negative Flag   Set if bit 7 of the result is set
	cpu_updateNegative(cpu1, cpu1->accumulator - data);
800031d8:	0f eb       	ld.ub	r11,r7[0x6]
800031da:	0c 1b       	sub	r11,r6
800031dc:	5c 5b       	castu.b	r11
800031de:	0e 9c       	mov	r12,r7
800031e0:	f0 1f 01 cf 	mcall	8000391c <cpu_step+0xb08>
800031e4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// CPX - Compare X Register
// This instruction compares the contents of the X register with another memory held value and sets the zero and carry flags as appropriate.
static void cpu_CPX(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
800031e8:	08 9c       	mov	r12,r4
800031ea:	f0 1f 01 c5 	mcall	800038fc <cpu_step+0xae8>
800031ee:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"CPX\n");
	Byte data = nes_readCPUMemory(nes, address);
800031f0:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800031f4:	08 9c       	mov	r12,r4
800031f6:	f0 1f 01 c3 	mcall	80003900 <cpu_step+0xaec>
800031fa:	18 96       	mov	r6,r12
	// C         Carry Flag     Set if X >= M
	cpu_updateCarry_subtract(cpu1, cpu1->indexX, data);
800031fc:	18 9a       	mov	r10,r12
800031fe:	0f cb       	ld.ub	r11,r7[0x4]
80003200:	0e 9c       	mov	r12,r7
80003202:	f0 1f 01 cd 	mcall	80003934 <cpu_step+0xb20>
	// Z Zero Flag       Set if X = M
	cpu_updateZero(cpu1, cpu1->indexX - data);
80003206:	0f cb       	ld.ub	r11,r7[0x4]
80003208:	0c 1b       	sub	r11,r6
8000320a:	5c 5b       	castu.b	r11
8000320c:	0e 9c       	mov	r12,r7
8000320e:	f0 1f 01 c3 	mcall	80003918 <cpu_step+0xb04>
	// N Negative Flag   Set if bit 7 of the result is set
	cpu_updateNegative(cpu1, cpu1->indexX - data);
80003212:	0f cb       	ld.ub	r11,r7[0x4]
80003214:	0c 1b       	sub	r11,r6
80003216:	5c 5b       	castu.b	r11
80003218:	0e 9c       	mov	r12,r7
8000321a:	f0 1f 01 c1 	mcall	8000391c <cpu_step+0xb08>
8000321e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// CPY - Compare Y Register
// This instruction compares the contents of the Y register with another memory held value and sets the zero and carry flags as appropriate.
static void cpu_CPY(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80003222:	08 9c       	mov	r12,r4
80003224:	f0 1f 01 b6 	mcall	800038fc <cpu_step+0xae8>
80003228:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"CPY\n");
	Byte data = nes_readCPUMemory(nes, address);
8000322a:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
8000322e:	08 9c       	mov	r12,r4
80003230:	f0 1f 01 b4 	mcall	80003900 <cpu_step+0xaec>
80003234:	18 96       	mov	r6,r12
	// C         Carry Flag     Set if Y >= M
	cpu_updateCarry_subtract(cpu1, cpu1->indexY, data);
80003236:	18 9a       	mov	r10,r12
80003238:	0f db       	ld.ub	r11,r7[0x5]
8000323a:	0e 9c       	mov	r12,r7
8000323c:	f0 1f 01 be 	mcall	80003934 <cpu_step+0xb20>
	// Z Zero Flag       Set if Y = M
	cpu_updateZero(cpu1, cpu1->indexY - data);
80003240:	0f db       	ld.ub	r11,r7[0x5]
80003242:	0c 1b       	sub	r11,r6
80003244:	5c 5b       	castu.b	r11
80003246:	0e 9c       	mov	r12,r7
80003248:	f0 1f 01 b4 	mcall	80003918 <cpu_step+0xb04>
	// N Negative Flag   Set if bit 7 of the result is set
	cpu_updateNegative(cpu1, cpu1->indexY - data);
8000324c:	0f db       	ld.ub	r11,r7[0x5]
8000324e:	0c 1b       	sub	r11,r6
80003250:	5c 5b       	castu.b	r11
80003252:	0e 9c       	mov	r12,r7
80003254:	f0 1f 01 b2 	mcall	8000391c <cpu_step+0xb08>
80003258:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// ADC - Add with Carry
// This instruction adds the contents of a memory location to the accumulator together with the carry bit.
// If overflow occurs the carry bit is set, this enables multiple byte addition to be performed.
static void cpu_ADC(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
8000325c:	08 9c       	mov	r12,r4
8000325e:	f0 1f 01 a8 	mcall	800038fc <cpu_step+0xae8>
80003262:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"ADC\n");
	// A + M + C
	Byte data = nes_readCPUMemory(nes, address);
80003264:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80003268:	08 9c       	mov	r12,r4
8000326a:	f0 1f 01 a6 	mcall	80003900 <cpu_step+0xaec>
8000326e:	18 95       	mov	r5,r12
	Word result = cpu1->accumulator + data;
80003270:	0f e6       	ld.ub	r6,r7[0x6]
80003272:	18 06       	add	r6,r12
80003274:	5c 86       	casts.h	r6
	if (cpu_getCarry(cpu1) == TRUE) {
80003276:	0e 9c       	mov	r12,r7
80003278:	f0 1f 01 b0 	mcall	80003938 <cpu_step+0xb24>
8000327c:	30 18       	mov	r8,1
8000327e:	f0 0c 18 00 	cp.b	r12,r8
80003282:	c0 31       	brne	80003288 <cpu_step+0x474>
		result++;
80003284:	2f f6       	sub	r6,-1
80003286:	5c 86       	casts.h	r6
	}
	// C  Carry Flag     Set if overflow in bit 7
	if ((result & MASK_BIT8) == MASK_BIT8) {
80003288:	e9 d6 c0 10 	bfextu	r4,r6,0x0,0x10
8000328c:	08 98       	mov	r8,r4
8000328e:	e2 18 01 00 	andl	r8,0x100,COH
80003292:	c0 60       	breq	8000329e <cpu_step+0x48a>
		cpu_setCarry(cpu1, TRUE);
80003294:	30 1b       	mov	r11,1
80003296:	0e 9c       	mov	r12,r7
80003298:	f0 1f 01 a9 	mcall	8000393c <cpu_step+0xb28>
8000329c:	c0 58       	rjmp	800032a6 <cpu_step+0x492>
		} else {
		cpu_setCarry(cpu1, FALSE);
8000329e:	30 0b       	mov	r11,0
800032a0:	0e 9c       	mov	r12,r7
800032a2:	f0 1f 01 a7 	mcall	8000393c <cpu_step+0xb28>
	}
	// V Overflow Flag   Set if sign bit is incorrect
	// based on http://nesdev.parodius.com/6502.txt
	if (((cpu1->accumulator ^ result) & 0x80) && !((cpu1->accumulator ^ data) & 0x80)) {
800032a6:	0f e8       	ld.ub	r8,r7[0x6]
800032a8:	10 54       	eor	r4,r8
800032aa:	e2 14 00 80 	andl	r4,0x80,COH
800032ae:	c0 c0       	breq	800032c6 <cpu_step+0x4b2>
800032b0:	eb e8 20 08 	eor	r8,r5,r8
800032b4:	30 09       	mov	r9,0
800032b6:	f2 08 18 00 	cp.b	r8,r9
800032ba:	c0 65       	brlt	800032c6 <cpu_step+0x4b2>
		cpu_setOverflow(cpu1, TRUE);
800032bc:	30 1b       	mov	r11,1
800032be:	0e 9c       	mov	r12,r7
800032c0:	f0 1f 01 9c 	mcall	80003930 <cpu_step+0xb1c>
800032c4:	c0 58       	rjmp	800032ce <cpu_step+0x4ba>
		} else {
		cpu_setOverflow(cpu1, FALSE);
800032c6:	30 0b       	mov	r11,0
800032c8:	0e 9c       	mov	r12,r7
800032ca:	f0 1f 01 9a 	mcall	80003930 <cpu_step+0xb1c>
	}
	cpu1->accumulator = result;
800032ce:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
800032d2:	ae eb       	st.b	r7[0x6],r11
	// Z Zero Flag       Set if A = 0
	cpu_updateZero(cpu1, cpu1->accumulator);
800032d4:	0e 9c       	mov	r12,r7
800032d6:	f0 1f 01 91 	mcall	80003918 <cpu_step+0xb04>
	// N Negative Flag   Set if bit 7 set
	cpu_updateNegative(cpu1, cpu1->accumulator);
800032da:	0f eb       	ld.ub	r11,r7[0x6]
800032dc:	0e 9c       	mov	r12,r7
800032de:	f0 1f 01 90 	mcall	8000391c <cpu_step+0xb08>
		case ADC_ABS:
		case ADC_ABSX:
		case ADC_ABSY:
		case ADC_INDX:
		cpu_ADC(nes, address);
		break;
800032e2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// SBC - Subtract with Carry
// This instruction subtracts the contents of a memory location to the accumulator together with the not of the carry bit.
// If overflow occurs the carry bit is clear, this enables multiple byte subtraction to be performed.
static void cpu_SBC(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
800032e6:	08 9c       	mov	r12,r4
800032e8:	f0 1f 01 85 	mcall	800038fc <cpu_step+0xae8>
800032ec:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"SBC\n");
	// A,Z,C,N = A-M-(1-C)
	Byte data = nes_readCPUMemory(nes, address);
800032ee:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800032f2:	08 9c       	mov	r12,r4
800032f4:	f0 1f 01 83 	mcall	80003900 <cpu_step+0xaec>
800032f8:	18 95       	mov	r5,r12
	Word result = cpu1->accumulator - data;
800032fa:	0f e6       	ld.ub	r6,r7[0x6]
800032fc:	18 16       	sub	r6,r12
800032fe:	5c 86       	casts.h	r6
	if (cpu_getCarry(cpu1) == FALSE) {
80003300:	0e 9c       	mov	r12,r7
80003302:	f0 1f 01 8e 	mcall	80003938 <cpu_step+0xb24>
80003306:	c0 31       	brne	8000330c <cpu_step+0x4f8>
		result--;
80003308:	20 16       	sub	r6,1
8000330a:	5c 86       	casts.h	r6
	}
	// C         Carry Flag     Clear if overflow in bit 7
	if ((result & MASK_BIT8) == MASK_BIT8) {
8000330c:	e9 d6 c0 10 	bfextu	r4,r6,0x0,0x10
80003310:	08 98       	mov	r8,r4
80003312:	e2 18 01 00 	andl	r8,0x100,COH
80003316:	c0 60       	breq	80003322 <cpu_step+0x50e>
		cpu_setCarry(cpu1, FALSE);
80003318:	30 0b       	mov	r11,0
8000331a:	0e 9c       	mov	r12,r7
8000331c:	f0 1f 01 88 	mcall	8000393c <cpu_step+0xb28>
80003320:	c0 58       	rjmp	8000332a <cpu_step+0x516>
		} else {
		cpu_setCarry(cpu1, TRUE);
80003322:	30 1b       	mov	r11,1
80003324:	0e 9c       	mov	r12,r7
80003326:	f0 1f 01 86 	mcall	8000393c <cpu_step+0xb28>
	}
	// V Overflow Flag   Set if sign bit is incorrect
	// based on http://nesdev.parodius.com/6502.txt
	if (((cpu1->accumulator ^ result) & 0x80) && ((cpu1->accumulator ^ data) & 0x80)) {
8000332a:	0f e8       	ld.ub	r8,r7[0x6]
8000332c:	10 54       	eor	r4,r8
8000332e:	e2 14 00 80 	andl	r4,0x80,COH
80003332:	c0 c0       	breq	8000334a <cpu_step+0x536>
80003334:	eb e8 20 08 	eor	r8,r5,r8
80003338:	30 09       	mov	r9,0
8000333a:	f2 08 18 00 	cp.b	r8,r9
8000333e:	c0 64       	brge	8000334a <cpu_step+0x536>
		cpu_setOverflow(cpu1, TRUE);
80003340:	30 1b       	mov	r11,1
80003342:	0e 9c       	mov	r12,r7
80003344:	f0 1f 01 7b 	mcall	80003930 <cpu_step+0xb1c>
80003348:	c0 58       	rjmp	80003352 <cpu_step+0x53e>
		} else {
		cpu_setOverflow(cpu1, FALSE);
8000334a:	30 0b       	mov	r11,0
8000334c:	0e 9c       	mov	r12,r7
8000334e:	f0 1f 01 79 	mcall	80003930 <cpu_step+0xb1c>
	}
	cpu1->accumulator = result;
80003352:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80003356:	ae eb       	st.b	r7[0x6],r11
	// Z Zero Flag       Set if A = 0
	cpu_updateZero(cpu1, cpu1->accumulator);
80003358:	0e 9c       	mov	r12,r7
8000335a:	f0 1f 01 70 	mcall	80003918 <cpu_step+0xb04>
	// N Negative Flag   Set if bit 7 set
	cpu_updateNegative(cpu1, cpu1->accumulator);
8000335e:	0f eb       	ld.ub	r11,r7[0x6]
80003360:	0e 9c       	mov	r12,r7
80003362:	f0 1f 01 6f 	mcall	8000391c <cpu_step+0xb08>
		case SBC_ABS:
		case SBC_ABSX:
		case SBC_ABSY:
		case SBC_INDX:
		cpu_SBC(nes, address);
		break;
80003366:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case ASL_ZPAGE:
		case ASL_ZPAGEX:
		case ASL_ABS:
		case ASL_ABSX:
		cpu_ASL_memory(nes, address);
8000336a:	eb d6 c0 10 	bfextu	r5,r6,0x0,0x10
// Bit 0 is set to 0 and bit 7 is placed in the carry flag.
// The effect of this operation is to multiply the memory contents by 2 (ignoring 2's complement considerations),
// setting the carry if the result will not fit in 8 bits.
static void cpu_ASL_memory(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
8000336e:	08 9c       	mov	r12,r4
80003370:	f0 1f 01 63 	mcall	800038fc <cpu_step+0xae8>
80003374:	18 96       	mov	r6,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"ASL_memory\n");
	// A,Z,C,N = M*2 or M,Z,C,N = M*2
	Byte data = nes_readCPUMemory(nes, address);
80003376:	0a 9b       	mov	r11,r5
80003378:	08 9c       	mov	r12,r4
8000337a:	f0 1f 01 62 	mcall	80003900 <cpu_step+0xaec>
8000337e:	18 97       	mov	r7,r12
	// dummy write, cycle wasted here
	nes_writeCPUMemory(nes, address, data);
80003380:	18 9a       	mov	r10,r12
80003382:	0a 9b       	mov	r11,r5
80003384:	08 9c       	mov	r12,r4
80003386:	f0 1f 01 68 	mcall	80003924 <cpu_step+0xb10>
	Word result = data << 1;
	// C Carry Flag      Set to contents of old bit 7
	if ( (data & MASK_BIT7) == MASK_BIT7) {
8000338a:	30 08       	mov	r8,0
8000338c:	f0 07 18 00 	cp.b	r7,r8
80003390:	c0 64       	brge	8000339c <cpu_step+0x588>
		cpu_setCarry(cpu1, TRUE);
80003392:	30 1b       	mov	r11,1
80003394:	0c 9c       	mov	r12,r6
80003396:	f0 1f 01 6a 	mcall	8000393c <cpu_step+0xb28>
8000339a:	c0 58       	rjmp	800033a4 <cpu_step+0x590>
		} else {
		cpu_setCarry(cpu1, FALSE);
8000339c:	30 0b       	mov	r11,0
8000339e:	0c 9c       	mov	r12,r6
800033a0:	f0 1f 01 67 	mcall	8000393c <cpu_step+0xb28>
	}
	// Z Zero Flag       Set if A = 0
	cpu_updateZero(cpu1, result);
800033a4:	ee 08 15 01 	lsl	r8,r7,0x1
800033a8:	10 97       	mov	r7,r8
800033aa:	5c 57       	castu.b	r7
800033ac:	0e 9b       	mov	r11,r7
800033ae:	0c 9c       	mov	r12,r6
800033b0:	f0 1f 01 5a 	mcall	80003918 <cpu_step+0xb04>
	// N Negative Flag   Set if bit 7 of the result is set
	cpu_updateNegative(cpu1, result);
800033b4:	0e 9b       	mov	r11,r7
800033b6:	0c 9c       	mov	r12,r6
800033b8:	f0 1f 01 59 	mcall	8000391c <cpu_step+0xb08>
	nes_writeCPUMemory(nes, address, result);
800033bc:	0e 9a       	mov	r10,r7
800033be:	0a 9b       	mov	r11,r5
800033c0:	08 9c       	mov	r12,r4
800033c2:	f0 1f 01 59 	mcall	80003924 <cpu_step+0xb10>
		case ASL_ZPAGE:
		case ASL_ZPAGEX:
		case ASL_ABS:
		case ASL_ABSX:
		cpu_ASL_memory(nes, address);
		break;
800033c6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case LSR_ZPAGE:
		case LSR_ZPAGEX:
		case LSR_ABS:
		case LSR_ABSX:
		cpu_LSR_memory(nes, address);
800033ca:	eb d6 c0 10 	bfextu	r5,r6,0x0,0x10
// Each of the bits in A or M is shift one place to the right.
// The bit that was in bit 0 is shifted into the carry flag.
// Bit 7 is set to zero.
static void cpu_LSR_memory(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
800033ce:	08 9c       	mov	r12,r4
800033d0:	f0 1f 01 4b 	mcall	800038fc <cpu_step+0xae8>
800033d4:	18 96       	mov	r6,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"LSR_memory\n");
	// A,C,Z,N = A/2 or M,C,Z,N = M/2
	Byte data = nes_readCPUMemory(nes, address);
800033d6:	0a 9b       	mov	r11,r5
800033d8:	08 9c       	mov	r12,r4
800033da:	f0 1f 01 4a 	mcall	80003900 <cpu_step+0xaec>
800033de:	18 97       	mov	r7,r12
	// dummy write, cycle wasted here
	nes_writeCPUMemory(nes, address, data);
800033e0:	18 9a       	mov	r10,r12
800033e2:	0a 9b       	mov	r11,r5
800033e4:	08 9c       	mov	r12,r4
800033e6:	f0 1f 01 50 	mcall	80003924 <cpu_step+0xb10>
	Word result = data >> 1;
	// C         Carry Flag     Set to contents of old bit 0
	if ( (data & MASK_BIT0) == MASK_BIT0) {
800033ea:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
800033ee:	c0 60       	breq	800033fa <cpu_step+0x5e6>
		cpu_setCarry(cpu1, TRUE);
800033f0:	30 1b       	mov	r11,1
800033f2:	0c 9c       	mov	r12,r6
800033f4:	f0 1f 01 52 	mcall	8000393c <cpu_step+0xb28>
800033f8:	c0 58       	rjmp	80003402 <cpu_step+0x5ee>
		} else {
		cpu_setCarry(cpu1, FALSE);
800033fa:	30 0b       	mov	r11,0
800033fc:	0c 9c       	mov	r12,r6
800033fe:	f0 1f 01 50 	mcall	8000393c <cpu_step+0xb28>
	}
	// Z Zero Flag       Set if result = 0
	cpu_updateZero(cpu1, result);
80003402:	ef d7 c0 28 	bfextu	r7,r7,0x1,0x8
80003406:	0e 9b       	mov	r11,r7
80003408:	0c 9c       	mov	r12,r6
8000340a:	f0 1f 01 44 	mcall	80003918 <cpu_step+0xb04>
	// N Negative Flag   Set if bit 7 of the result is set
	cpu_updateNegative(cpu1, result);
8000340e:	0e 9b       	mov	r11,r7
80003410:	0c 9c       	mov	r12,r6
80003412:	f0 1f 01 43 	mcall	8000391c <cpu_step+0xb08>
	nes_writeCPUMemory(nes, address, result);
80003416:	0e 9a       	mov	r10,r7
80003418:	0a 9b       	mov	r11,r5
8000341a:	08 9c       	mov	r12,r4
8000341c:	f0 1f 01 42 	mcall	80003924 <cpu_step+0xb10>
		case LSR_ZPAGE:
		case LSR_ZPAGEX:
		case LSR_ABS:
		case LSR_ABSX:
		cpu_LSR_memory(nes, address);
		break;
80003420:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case ROL_ZPAGE:
		case ROL_ZPAGEX:
		case ROL_ABS:
		case ROL_ABSX:
		cpu_ROL_memory(nes, address);
80003424:	e7 d6 c0 10 	bfextu	r3,r6,0x0,0x10
// ROL - Rotate Left
// Move each of the bits in either A or M one place to the left.
// Bit 0 is filled with the current value of the carry flag whilst the old bit 7 becomes the new carry flag value.
static void cpu_ROL_memory(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80003428:	08 9c       	mov	r12,r4
8000342a:	f0 1f 01 35 	mcall	800038fc <cpu_step+0xae8>
8000342e:	18 96       	mov	r6,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"ROL_memory\n");
	Byte data = nes_readCPUMemory(nes, address);
80003430:	06 9b       	mov	r11,r3
80003432:	08 9c       	mov	r12,r4
80003434:	f0 1f 01 33 	mcall	80003900 <cpu_step+0xaec>
80003438:	18 95       	mov	r5,r12
	// dummy write, cycle wasted here
	nes_writeCPUMemory(nes, address, data);
8000343a:	18 9a       	mov	r10,r12
8000343c:	06 9b       	mov	r11,r3
8000343e:	08 9c       	mov	r12,r4
80003440:	f0 1f 01 39 	mcall	80003924 <cpu_step+0xb10>
	Word result  = data << 1;
80003444:	ea 07 15 01 	lsl	r7,r5,0x1
80003448:	5c 87       	casts.h	r7
	if (cpu_getCarry(cpu1) == TRUE) {
8000344a:	0c 9c       	mov	r12,r6
8000344c:	f0 1f 01 3b 	mcall	80003938 <cpu_step+0xb24>
80003450:	30 18       	mov	r8,1
80003452:	f0 0c 18 00 	cp.b	r12,r8
80003456:	c0 21       	brne	8000345a <cpu_step+0x646>
		result |= MASK_BIT0;
80003458:	a1 a7       	sbr	r7,0x0
	}
	// C         Carry Flag     Set to contents of old bit 7
	if ((data & MASK_BIT7) == MASK_BIT7) {
8000345a:	30 08       	mov	r8,0
8000345c:	f0 05 18 00 	cp.b	r5,r8
80003460:	c0 64       	brge	8000346c <cpu_step+0x658>
		cpu_setCarry(cpu1, TRUE);
80003462:	30 1b       	mov	r11,1
80003464:	0c 9c       	mov	r12,r6
80003466:	f0 1f 01 36 	mcall	8000393c <cpu_step+0xb28>
8000346a:	c0 58       	rjmp	80003474 <cpu_step+0x660>
		} else {
		cpu_setCarry(cpu1, FALSE);
8000346c:	30 0b       	mov	r11,0
8000346e:	0c 9c       	mov	r12,r6
80003470:	f0 1f 01 33 	mcall	8000393c <cpu_step+0xb28>
	}
	// Z Zero Flag       Set if A = 0
	cpu_updateZero(cpu1, result);
80003474:	5c 57       	castu.b	r7
80003476:	0e 9b       	mov	r11,r7
80003478:	0c 9c       	mov	r12,r6
8000347a:	f0 1f 01 28 	mcall	80003918 <cpu_step+0xb04>
	// N Negative Flag   Set if bit 7 of the result is set
	cpu_updateNegative(cpu1, result);
8000347e:	0e 9b       	mov	r11,r7
80003480:	0c 9c       	mov	r12,r6
80003482:	f0 1f 01 27 	mcall	8000391c <cpu_step+0xb08>
	nes_writeCPUMemory(nes, address, result);
80003486:	0e 9a       	mov	r10,r7
80003488:	06 9b       	mov	r11,r3
8000348a:	08 9c       	mov	r12,r4
8000348c:	f0 1f 01 26 	mcall	80003924 <cpu_step+0xb10>
		case ROL_ZPAGE:
		case ROL_ZPAGEX:
		case ROL_ABS:
		case ROL_ABSX:
		cpu_ROL_memory(nes, address);
		break;
80003490:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case ROR_ZPAGE:
		case ROR_ZPAGEX:
		case ROR_ABS:
		case ROR_ABSX:
		cpu_ROR_memory(nes, address);
80003494:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80003498:	08 9c       	mov	r12,r4
8000349a:	f0 1f 01 2a 	mcall	80003940 <cpu_step+0xb2c>
		break;
8000349e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case INC_ZPAGE:
		case INC_ZPAGEX:
		case INC_ABS:
		case INC_ABSX:
		cpu_INC(nes, address);
800034a2:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800034a6:	08 9c       	mov	r12,r4
800034a8:	f0 1f 01 27 	mcall	80003944 <cpu_step+0xb30>
		break;
800034ac:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case DEC_ZPAGE:
		case DEC_ZPAGEX:
		case DEC_ABS:
		case DEC_ABSX:
		cpu_DEC(nes, address);
800034b0:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800034b4:	08 9c       	mov	r12,r4
800034b6:	f0 1f 01 25 	mcall	80003948 <cpu_step+0xb34>
		break;
800034ba:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case JSR_ABS:
		cpu_JSR(nes, address);
800034be:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800034c2:	08 9c       	mov	r12,r4
800034c4:	f0 1f 01 22 	mcall	8000394c <cpu_step+0xb38>
		break;
800034c8:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case JMP_ABS:
		cpu_JMP(nes, address);
800034cc:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800034d0:	08 9c       	mov	r12,r4
800034d2:	f0 1f 01 20 	mcall	80003950 <cpu_step+0xb3c>
		break;
800034d6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// The effect of this operation is to multiply the memory contents by 2
// (ignoring 2's complement considerations), setting the carry if the result will not fit in 8 bits.
static void cpu_ASL(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"ASL\n");
	Word result = cpu1->accumulator << 1;
800034da:	0f e6       	ld.ub	r6,r7[0x6]
	// C         Carry Flag      Set to contents of old bit 7
	if ((cpu1->accumulator & MASK_BIT7) == MASK_BIT7) {
800034dc:	30 08       	mov	r8,0
800034de:	f0 06 18 00 	cp.b	r6,r8
800034e2:	c0 64       	brge	800034ee <cpu_step+0x6da>
		cpu_setCarry(cpu1, TRUE);
800034e4:	30 1b       	mov	r11,1
800034e6:	0e 9c       	mov	r12,r7
800034e8:	f0 1f 01 15 	mcall	8000393c <cpu_step+0xb28>
800034ec:	c0 58       	rjmp	800034f6 <cpu_step+0x6e2>
		} else {
		cpu_setCarry(cpu1, FALSE);
800034ee:	30 0b       	mov	r11,0
800034f0:	0e 9c       	mov	r12,r7
800034f2:	f0 1f 01 13 	mcall	8000393c <cpu_step+0xb28>
	}
	cpu1->accumulator = result;
800034f6:	ec 0b 15 01 	lsl	r11,r6,0x1
800034fa:	5c 5b       	castu.b	r11
800034fc:	ae eb       	st.b	r7[0x6],r11
	// Z Zero Flag       Set if A = 0
	cpu_updateZero(cpu1, cpu1->accumulator);
800034fe:	0e 9c       	mov	r12,r7
80003500:	f0 1f 01 06 	mcall	80003918 <cpu_step+0xb04>
	// N Negative Flag   Set if bit 7 of the result is set
	cpu_updateNegative(cpu1, cpu1->accumulator);
80003504:	0f eb       	ld.ub	r11,r7[0x6]
80003506:	0e 9c       	mov	r12,r7
80003508:	f0 1f 01 05 	mcall	8000391c <cpu_step+0xb08>
		case JMP_ABS:
		cpu_JMP(nes, address);
		break;
		case ASL_ACCUM:
		cpu_ASL(cpu1);
		break;
8000350c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// Each of the bits in A is shift one place to the right.
// The bit that was in bit 0 is shifted into the carry flag. Bit 7 is set to zero.
static void cpu_LSR(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"LSR\n");
	Word result = cpu1->accumulator >> 1;
80003510:	0f e8       	ld.ub	r8,r7[0x6]
80003512:	f0 06 16 01 	lsr	r6,r8,0x1
	// C         Carry Flag      Set to contents of old bit 0
	if ( (cpu1->accumulator & MASK_BIT0) == MASK_BIT0 ) {
80003516:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000351a:	c0 60       	breq	80003526 <cpu_step+0x712>
		cpu_setCarry(cpu1, TRUE);
8000351c:	30 1b       	mov	r11,1
8000351e:	0e 9c       	mov	r12,r7
80003520:	f0 1f 01 07 	mcall	8000393c <cpu_step+0xb28>
80003524:	c0 58       	rjmp	8000352e <cpu_step+0x71a>
		} else {
		cpu_setCarry(cpu1, FALSE);
80003526:	30 0b       	mov	r11,0
80003528:	0e 9c       	mov	r12,r7
8000352a:	f0 1f 01 05 	mcall	8000393c <cpu_step+0xb28>
	}
	cpu1->accumulator = result;
8000352e:	ae e6       	st.b	r7[0x6],r6
	// Z Zero Flag       Set if result = 0
	cpu_updateZero(cpu1, cpu1->accumulator);
80003530:	0c 9b       	mov	r11,r6
80003532:	0e 9c       	mov	r12,r7
80003534:	f0 1f 00 f9 	mcall	80003918 <cpu_step+0xb04>
	// N Negative Flag   Set if bit 7 of the result is set
	cpu_updateNegative(cpu1, cpu1->accumulator);
80003538:	0f eb       	ld.ub	r11,r7[0x6]
8000353a:	0e 9c       	mov	r12,r7
8000353c:	f0 1f 00 f8 	mcall	8000391c <cpu_step+0xb08>
		case ASL_ACCUM:
		cpu_ASL(cpu1);
		break;
		case LSR_ACCUM:
		cpu_LSR(cpu1);
		break;
80003540:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// Move each of the bits in either A or M one place to the left.
// Bit 0 is filled with the current value of the carry flag whilst the old bit 7 becomes the new carry flag value.
static void cpu_ROL(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"ROL\n");
	Word result = cpu1->accumulator << 1;
80003544:	0f e6       	ld.ub	r6,r7[0x6]
80003546:	ec 05 15 01 	lsl	r5,r6,0x1
	if (cpu_getCarry(cpu1) == TRUE) {
8000354a:	0e 9c       	mov	r12,r7
8000354c:	f0 1f 00 fb 	mcall	80003938 <cpu_step+0xb24>
80003550:	30 18       	mov	r8,1
80003552:	f0 0c 18 00 	cp.b	r12,r8
80003556:	c0 21       	brne	8000355a <cpu_step+0x746>
		result |= MASK_BIT0;
80003558:	a1 a5       	sbr	r5,0x0
	}
	if ( (cpu1->accumulator & MASK_BIT7) == MASK_BIT7) {
8000355a:	30 08       	mov	r8,0
8000355c:	f0 06 18 00 	cp.b	r6,r8
80003560:	c0 64       	brge	8000356c <cpu_step+0x758>
		cpu_setCarry(cpu1, TRUE);
80003562:	30 1b       	mov	r11,1
80003564:	0e 9c       	mov	r12,r7
80003566:	f0 1f 00 f6 	mcall	8000393c <cpu_step+0xb28>
8000356a:	c0 58       	rjmp	80003574 <cpu_step+0x760>
		} else {
		cpu_setCarry(cpu1, FALSE);
8000356c:	30 0b       	mov	r11,0
8000356e:	0e 9c       	mov	r12,r7
80003570:	f0 1f 00 f3 	mcall	8000393c <cpu_step+0xb28>
	}
	// Z Zero Flag       Set if A = 0
	cpu1->accumulator = result;
80003574:	f7 d5 c0 08 	bfextu	r11,r5,0x0,0x8
80003578:	ae eb       	st.b	r7[0x6],r11
	cpu_updateZero(cpu1, cpu1->accumulator);
8000357a:	0e 9c       	mov	r12,r7
8000357c:	f0 1f 00 e7 	mcall	80003918 <cpu_step+0xb04>
	// N Negative Flag   Set if bit 7 of the result is set
	cpu_updateNegative(cpu1, cpu1->accumulator);
80003580:	0f eb       	ld.ub	r11,r7[0x6]
80003582:	0e 9c       	mov	r12,r7
80003584:	f0 1f 00 e6 	mcall	8000391c <cpu_step+0xb08>
		case LSR_ACCUM:
		cpu_LSR(cpu1);
		break;
		case ROL_ACCUM:
		cpu_ROL(cpu1);
		break;
80003588:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// Move each of the bits in either A or M one place to the right.
// Bit 7 is filled with the current value of the carry flag whilst the old bit 0 becomes the new carry flag value.
static void cpu_ROR(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"ROR\n");
	Word result = cpu1->accumulator >> 1;
8000358c:	0f e6       	ld.ub	r6,r7[0x6]
8000358e:	ec 05 16 01 	lsr	r5,r6,0x1
	if (cpu_getCarry(cpu1) == TRUE) {
80003592:	0e 9c       	mov	r12,r7
80003594:	f0 1f 00 e9 	mcall	80003938 <cpu_step+0xb24>
80003598:	30 18       	mov	r8,1
8000359a:	f0 0c 18 00 	cp.b	r12,r8
8000359e:	c0 21       	brne	800035a2 <cpu_step+0x78e>
		result |= MASK_BIT7;
800035a0:	a7 b5       	sbr	r5,0x7
	}
	// C         Carry Flag     Set to contents of old bit 0
	if ( (cpu1->accumulator & MASK_BIT0) == MASK_BIT0) {
800035a2:	ed d6 c0 01 	bfextu	r6,r6,0x0,0x1
800035a6:	c0 60       	breq	800035b2 <cpu_step+0x79e>
		cpu_setCarry(cpu1, TRUE);
800035a8:	30 1b       	mov	r11,1
800035aa:	0e 9c       	mov	r12,r7
800035ac:	f0 1f 00 e4 	mcall	8000393c <cpu_step+0xb28>
800035b0:	c0 58       	rjmp	800035ba <cpu_step+0x7a6>
		} else {
		cpu_setCarry(cpu1, FALSE);
800035b2:	30 0b       	mov	r11,0
800035b4:	0e 9c       	mov	r12,r7
800035b6:	f0 1f 00 e2 	mcall	8000393c <cpu_step+0xb28>
	}
	cpu1->accumulator = result;
800035ba:	0a 9b       	mov	r11,r5
800035bc:	ae e5       	st.b	r7[0x6],r5
	// Z Zero Flag       Set if A = 0
	cpu_updateZero(cpu1, cpu1->accumulator);
800035be:	0e 9c       	mov	r12,r7
800035c0:	f0 1f 00 d6 	mcall	80003918 <cpu_step+0xb04>
	// N Negative Flag   Set if bit 7 of the result is set
	cpu_updateNegative(cpu1, cpu1->accumulator);
800035c4:	0f eb       	ld.ub	r11,r7[0x6]
800035c6:	0e 9c       	mov	r12,r7
800035c8:	f0 1f 00 d5 	mcall	8000391c <cpu_step+0xb08>
		case ROL_ACCUM:
		cpu_ROL(cpu1);
		break;
		case ROR_ACCUM:
		cpu_ROR(cpu1);
		break;
800035cc:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case JMP_INDIRECT_CODE1:
		case JMP_INDIRECT_CODE2:
		cpu_JMP(nes, address);
800035d0:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800035d4:	08 9c       	mov	r12,r4
800035d6:	f0 1f 00 df 	mcall	80003950 <cpu_step+0xb3c>
		break;
800035da:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case BRK:
		cpu_BRK(nes);
800035de:	08 9c       	mov	r12,r4
800035e0:	f0 1f 00 dd 	mcall	80003954 <cpu_step+0xb40>
		break;
800035e4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case RTS:
		cpu_RTS(nes);
800035e8:	08 9c       	mov	r12,r4
800035ea:	f0 1f 00 dc 	mcall	80003958 <cpu_step+0xb44>
		break;
800035ee:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case RTI:
		cpu_RTI(nes);
800035f2:	08 9c       	mov	r12,r4
800035f4:	f0 1f 00 da 	mcall	8000395c <cpu_step+0xb48>
		break;
800035f8:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// PHP - Push Processor Status
// Pushes a copy of the status flags on to the stack.
static void cpu_PHP(NES nes) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
800035fc:	08 9c       	mov	r12,r4
800035fe:	f0 1f 00 c0 	mcall	800038fc <cpu_step+0xae8>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"PHP\n");
	// The status bits pushed on the stack by PHP have the breakpoint bit set.
	// 1 at all times
	cpu1->status |= MASK_BIT5;
80003602:	19 bb       	ld.ub	r11,r12[0x3]
80003604:	a5 bb       	sbr	r11,0x5
80003606:	5c 5b       	castu.b	r11
80003608:	b8 bb       	st.b	r12[0x3],r11
	Byte data = cpu1->status;
	data |= MASK_STATUS_BREAK_ON;
	//printf("PHP 0x%x 0x%x\n", cpu1->status, data);
	cpu_pushStack(nes, data);
8000360a:	a5 ab       	sbr	r11,0x4
8000360c:	08 9c       	mov	r12,r4
8000360e:	f0 1f 00 d5 	mcall	80003960 <cpu_step+0xb4c>
		case RTI:
		cpu_RTI(nes);
		break;
		case PHP:
		cpu_PHP(nes);
		break;
80003612:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case PLP:
		cpu_PLP(nes);
80003616:	08 9c       	mov	r12,r4
80003618:	f0 1f 00 d3 	mcall	80003964 <cpu_step+0xb50>
		break;
8000361c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// PHA - Push Accumulator
// Pushes a copy of the accumulator on to the stack.
static void cpu_PHA(NES nes) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80003620:	08 9c       	mov	r12,r4
80003622:	f0 1f 00 b7 	mcall	800038fc <cpu_step+0xae8>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"PHA\n");
	cpu_pushStack(nes, cpu1->accumulator);
80003626:	19 eb       	ld.ub	r11,r12[0x6]
80003628:	08 9c       	mov	r12,r4
8000362a:	f0 1f 00 ce 	mcall	80003960 <cpu_step+0xb4c>
		case PLP:
		cpu_PLP(nes);
		break;
		case PHA:
		cpu_PHA(nes);
		break;
8000362e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case PLA:
		cpu_PLA(nes);
80003632:	08 9c       	mov	r12,r4
80003634:	f0 1f 00 cd 	mcall	80003968 <cpu_step+0xb54>
		break;
80003638:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// INX - Increment X Register
// Adds one to the X register setting the zero and negative flags as appropriate.
static void cpu_INX(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"INX\n");
	cpu1->indexX++;
8000363c:	0f cb       	ld.ub	r11,r7[0x4]
8000363e:	2f fb       	sub	r11,-1
80003640:	5c 5b       	castu.b	r11
80003642:	ae cb       	st.b	r7[0x4],r11
	// Z Zero Flag       Set if X is zero
	cpu_updateZero(cpu1, cpu1->indexX);
80003644:	0e 9c       	mov	r12,r7
80003646:	f0 1f 00 b5 	mcall	80003918 <cpu_step+0xb04>
	// N Negative Flag   Set if bit 7 of X is set
	cpu_updateNegative(cpu1, cpu1->indexX);
8000364a:	0f cb       	ld.ub	r11,r7[0x4]
8000364c:	0e 9c       	mov	r12,r7
8000364e:	f0 1f 00 b4 	mcall	8000391c <cpu_step+0xb08>
		case PLA:
		cpu_PLA(nes);
		break;
		case INX:
		cpu_INX(cpu1);
		break;
80003652:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// DEX - Decrement X Register
// Subtracts one from the X register setting the zero and negative flags as appropriate.
static void cpu_DEX(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"DEX\n");
	cpu1->indexX--;
80003656:	0f cb       	ld.ub	r11,r7[0x4]
80003658:	20 1b       	sub	r11,1
8000365a:	5c 5b       	castu.b	r11
8000365c:	ae cb       	st.b	r7[0x4],r11
	// Z Zero Flag       Set if X is zero
	cpu_updateZero(cpu1, cpu1->indexX);
8000365e:	0e 9c       	mov	r12,r7
80003660:	f0 1f 00 ae 	mcall	80003918 <cpu_step+0xb04>
	// N Negative Flag   Set if bit 7 of X is set
	cpu_updateNegative(cpu1, cpu1->indexX);
80003664:	0f cb       	ld.ub	r11,r7[0x4]
80003666:	0e 9c       	mov	r12,r7
80003668:	f0 1f 00 ad 	mcall	8000391c <cpu_step+0xb08>
		case INX:
		cpu_INX(cpu1);
		break;
		case DEX:
		cpu_DEX(cpu1);
		break;
8000366c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// INY - Increment Y Register
// Adds one to the Y register setting the zero and negative flags as appropriate.
static void cpu_INY(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"INY\n");
	cpu1->indexY++;
80003670:	0f db       	ld.ub	r11,r7[0x5]
80003672:	2f fb       	sub	r11,-1
80003674:	5c 5b       	castu.b	r11
80003676:	ae db       	st.b	r7[0x5],r11
	// Z Zero Flag       Set if Y is zero
	cpu_updateZero(cpu1, cpu1->indexY);
80003678:	0e 9c       	mov	r12,r7
8000367a:	f0 1f 00 a8 	mcall	80003918 <cpu_step+0xb04>
	// N Negative Flag   Set if bit 7 of Y is set
	cpu_updateNegative(cpu1, cpu1->indexY);
8000367e:	0f db       	ld.ub	r11,r7[0x5]
80003680:	0e 9c       	mov	r12,r7
80003682:	f0 1f 00 a7 	mcall	8000391c <cpu_step+0xb08>
		case DEX:
		cpu_DEX(cpu1);
		break;
		case INY:
		cpu_INY(cpu1);
		break;
80003686:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// DEY - Decrement Y Register
// Subtracts one from the Y register setting the zero and negative flags as appropriate.
static void cpu_DEY(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"DEY\n");
	cpu1->indexY--;
8000368a:	0f db       	ld.ub	r11,r7[0x5]
8000368c:	20 1b       	sub	r11,1
8000368e:	5c 5b       	castu.b	r11
80003690:	ae db       	st.b	r7[0x5],r11
	// Z Zero Flag       Set if Y is zero
	cpu_updateZero(cpu1, cpu1->indexY);
80003692:	0e 9c       	mov	r12,r7
80003694:	f0 1f 00 a1 	mcall	80003918 <cpu_step+0xb04>
	// N Negative Flag Set if bit 7 of Y is set
	cpu_updateNegative(cpu1, cpu1->indexY);
80003698:	0f db       	ld.ub	r11,r7[0x5]
8000369a:	0e 9c       	mov	r12,r7
8000369c:	f0 1f 00 a0 	mcall	8000391c <cpu_step+0xb08>
		case INY:
		cpu_INY(cpu1);
		break;
		case DEY:
		cpu_DEY(cpu1);
		break;
800036a0:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// TAX - Transfer Accumulator to X
// Copies the current contents of the accumulator into the X register and sets the zero and negative flags as appropriate.
static void cpu_TAX(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"TAX\n");
	cpu1->indexX = cpu1->accumulator;
800036a4:	0f eb       	ld.ub	r11,r7[0x6]
800036a6:	ae cb       	st.b	r7[0x4],r11
	// Z Zero Flag       Set if X = 0
	cpu_updateZero(cpu1, cpu1->indexX);
800036a8:	0e 9c       	mov	r12,r7
800036aa:	f0 1f 00 9c 	mcall	80003918 <cpu_step+0xb04>
	// N Negative Flag   Set if bit 7 of X is set
	cpu_updateNegative(cpu1, cpu1->indexX);
800036ae:	0f cb       	ld.ub	r11,r7[0x4]
800036b0:	0e 9c       	mov	r12,r7
800036b2:	f0 1f 00 9b 	mcall	8000391c <cpu_step+0xb08>
		case DEY:
		cpu_DEY(cpu1);
		break;
		case TAX:
		cpu_TAX(cpu1);
		break;
800036b6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// TXA - Transfer X to Accumulator
// Copies the current contents of the X register into the accumulator and sets the zero and negative flags as appropriate.
static void cpu_TXA(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"TXA\n");
	cpu1->accumulator = cpu1->indexX;
800036ba:	0f cb       	ld.ub	r11,r7[0x4]
800036bc:	ae eb       	st.b	r7[0x6],r11
	// Z Zero Flag       Set if A = 0
	cpu_updateZero(cpu1, cpu1->accumulator);
800036be:	0e 9c       	mov	r12,r7
800036c0:	f0 1f 00 96 	mcall	80003918 <cpu_step+0xb04>
	// N Negative Flag Set if bit 7 of A is set
	cpu_updateNegative(cpu1, cpu1->accumulator);
800036c4:	0f eb       	ld.ub	r11,r7[0x6]
800036c6:	0e 9c       	mov	r12,r7
800036c8:	f0 1f 00 95 	mcall	8000391c <cpu_step+0xb08>
		case TAX:
		cpu_TAX(cpu1);
		break;
		case TXA:
		cpu_TXA(cpu1);
		break;
800036cc:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// TAY - Transfer Accumulator to Y
// Copies the current contents of the accumulator into the Y register and sets the zero and negative flags as appropriate.
static void cpu_TAY(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"TAY\n");
	cpu1->indexY = cpu1->accumulator;
800036d0:	0f eb       	ld.ub	r11,r7[0x6]
800036d2:	ae db       	st.b	r7[0x5],r11
	// Z Zero Flag       Set if Y = 0
	cpu_updateZero(cpu1, cpu1->indexY);
800036d4:	0e 9c       	mov	r12,r7
800036d6:	f0 1f 00 91 	mcall	80003918 <cpu_step+0xb04>
	// N Negative Flag Set if bit 7 of Y is set
	cpu_updateNegative(cpu1, cpu1->indexY);
800036da:	0f db       	ld.ub	r11,r7[0x5]
800036dc:	0e 9c       	mov	r12,r7
800036de:	f0 1f 00 90 	mcall	8000391c <cpu_step+0xb08>
		case TXA:
		cpu_TXA(cpu1);
		break;
		case TAY:
		cpu_TAY(cpu1);
		break;
800036e2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// TYA - Transfer Y to Accumulator
// Copies the current contents of the Y register into the accumulator and sets the zero and negative flags as appropriate.
static void cpu_TYA(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"TYA\n");
	cpu1->accumulator = cpu1->indexY;
800036e6:	0f db       	ld.ub	r11,r7[0x5]
800036e8:	ae eb       	st.b	r7[0x6],r11
	// Z Zero Flag       Set if A = 0
	cpu_updateZero(cpu1, cpu1->accumulator);
800036ea:	0e 9c       	mov	r12,r7
800036ec:	f0 1f 00 8b 	mcall	80003918 <cpu_step+0xb04>
	// N Negative Flag Set if bit 7 of A is set
	cpu_updateNegative(cpu1, cpu1->accumulator);
800036f0:	0f eb       	ld.ub	r11,r7[0x6]
800036f2:	0e 9c       	mov	r12,r7
800036f4:	f0 1f 00 8a 	mcall	8000391c <cpu_step+0xb08>
		case TAY:
		cpu_TAY(cpu1);
		break;
		case TYA:
		cpu_TYA(cpu1);
		break;
800036f8:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// TSX - Transfer Stack Pointer to X
// Copies the current contents of the stack register into the X register and sets the zero and negative flags as appropriate.
static void cpu_TSX(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"TSX\n");
	cpu1->indexX = cpu1->stackPointer;
800036fc:	0f ab       	ld.ub	r11,r7[0x2]
800036fe:	ae cb       	st.b	r7[0x4],r11
	// Z Zero Flag       Set if X = 0
	cpu_updateZero(cpu1, cpu1->indexX);
80003700:	0e 9c       	mov	r12,r7
80003702:	f0 1f 00 86 	mcall	80003918 <cpu_step+0xb04>
	// N Negative Flag   Set if bit 7 of X is set
	cpu_updateNegative(cpu1, cpu1->indexX);
80003706:	0f cb       	ld.ub	r11,r7[0x4]
80003708:	0e 9c       	mov	r12,r7
8000370a:	f0 1f 00 85 	mcall	8000391c <cpu_step+0xb08>
		case TYA:
		cpu_TYA(cpu1);
		break;
		case TSX:
		cpu_TSX(cpu1);
		break;
8000370e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// TXS - Transfer X to Stack Pointer
// Copies the current contents of the X register into the stack register.
static void cpu_TXS(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"TXS\n");
	cpu1->stackPointer = cpu1->indexX;
80003712:	0f c8       	ld.ub	r8,r7[0x4]
80003714:	ae a8       	st.b	r7[0x2],r8
		case TSX:
		cpu_TSX(cpu1);
		break;
		case TXS:
		cpu_TXS(cpu1);
		break;
80003716:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
	}
}
// SED - Set Decimal Flag
static void cpu_SED(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu_setDecimal(cpu1, TRUE);
8000371a:	30 1b       	mov	r11,1
8000371c:	0e 9c       	mov	r12,r7
8000371e:	f0 1f 00 94 	mcall	8000396c <cpu_step+0xb58>
		case TXS:
		cpu_TXS(cpu1);
		break;
		case SED:
		cpu_SED(cpu1);
		break;
80003722:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
	cpu_setDecimal(cpu1, TRUE);
}
// CLD - Clear Decimal Mode
static void cpu_CLD(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu_setDecimal(cpu1, FALSE);
80003726:	30 0b       	mov	r11,0
80003728:	0e 9c       	mov	r12,r7
8000372a:	f0 1f 00 91 	mcall	8000396c <cpu_step+0xb58>
		case SED:
		cpu_SED(cpu1);
		break;
		case CLD:
		cpu_CLD(cpu1);
		break;
8000372e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// SEI - Set Interrupt Disable
static void cpu_SEI(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"SEI\n");
	// I         Interrupt Disable      Set to 1
	cpu_setInterruptDisable(cpu1, TRUE);
80003732:	30 1b       	mov	r11,1
80003734:	0e 9c       	mov	r12,r7
80003736:	f0 1f 00 8f 	mcall	80003970 <cpu_step+0xb5c>
		case CLD:
		cpu_CLD(cpu1);
		break;
		case SEI:
		cpu_SEI(cpu1);
		break;
8000373a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// CLI - Clear Interrupt Disable
static void cpu_CLI(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"CLI\n");
	// I         Interrupt Disable      Set to 0
	cpu_setInterruptDisable(cpu1, FALSE);
8000373e:	30 0b       	mov	r11,0
80003740:	0e 9c       	mov	r12,r7
80003742:	f0 1f 00 8c 	mcall	80003970 <cpu_step+0xb5c>
		case SEI:
		cpu_SEI(cpu1);
		break;
		case CLI:
		cpu_CLI(cpu1);
		break;
80003746:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// SEC - Set Carry Flag
static void cpu_SEC(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"SEC\n");
	cpu_setCarry(cpu1, TRUE);
8000374a:	30 1b       	mov	r11,1
8000374c:	0e 9c       	mov	r12,r7
8000374e:	f0 1f 00 7c 	mcall	8000393c <cpu_step+0xb28>
		case CLI:
		cpu_CLI(cpu1);
		break;
		case SEC:
		cpu_SEC(cpu1);
		break;
80003752:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// CLC - Clear Carry Flag
static void cpu_CLC(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"CLC\n");
	// C         Carry Flag     Set to 0
	cpu_setCarry(cpu1, FALSE);
80003756:	30 0b       	mov	r11,0
80003758:	0e 9c       	mov	r12,r7
8000375a:	f0 1f 00 79 	mcall	8000393c <cpu_step+0xb28>
		case SEC:
		cpu_SEC(cpu1);
		break;
		case CLC:
		cpu_CLC(cpu1);
		break;
8000375e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// CLV - Clear Overflow Flag
static void cpu_CLV(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"CLV\n");
	// V         Overflow Flag          Set to 0
	cpu_setOverflow(cpu1, FALSE);
80003762:	30 0b       	mov	r11,0
80003764:	0e 9c       	mov	r12,r7
80003766:	f0 1f 00 73 	mcall	80003930 <cpu_step+0xb1c>
		case CLC:
		cpu_CLC(cpu1);
		break;
		case CLV:
		cpu_CLV(cpu1);
		break;
8000376a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// BEQ - Branch if Equal
// If the zero flag is set then add the relative displacement to the program counter to ause a branch to a new location.
static void cpu_BEQ(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
8000376e:	08 9c       	mov	r12,r4
80003770:	f0 1f 00 63 	mcall	800038fc <cpu_step+0xae8>
80003774:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BEQ\n");
	SignedByte data = nes_readCPUMemory(nes, address);
80003776:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
8000377a:	08 9c       	mov	r12,r4
8000377c:	f0 1f 00 61 	mcall	80003900 <cpu_step+0xaec>
80003780:	18 96       	mov	r6,r12
	if (cpu_getZero(cpu1) == TRUE) {
80003782:	0e 9c       	mov	r12,r7
80003784:	f0 1f 00 7c 	mcall	80003974 <cpu_step+0xb60>
80003788:	30 18       	mov	r8,1
8000378a:	f0 0c 18 00 	cp.b	r12,r8
8000378e:	e0 81 00 b5 	brne	800038f8 <cpu_step+0xae4>
		// +1 cycle if the branch succeeds
		nes_cpuCycled(nes);
80003792:	08 9c       	mov	r12,r4
80003794:	f0 1f 00 5f 	mcall	80003910 <cpu_step+0xafc>
		cpu1->programCounter += data;
80003798:	5c 66       	casts.b	r6
8000379a:	8e 08       	ld.sh	r8,r7[0x0]
8000379c:	0c 08       	add	r8,r6
8000379e:	ae 08       	st.h	r7[0x0],r8
800037a0:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// BNE - Branch if Not Equal
// If the zero flag is clear then add the relative displacement to the program counter o cause a branch to a new location.
static void cpu_BNE(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
800037a4:	08 9c       	mov	r12,r4
800037a6:	f0 1f 00 56 	mcall	800038fc <cpu_step+0xae8>
800037aa:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BNE\n");
	SignedByte data = nes_readCPUMemory(nes, address);
800037ac:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800037b0:	08 9c       	mov	r12,r4
800037b2:	f0 1f 00 54 	mcall	80003900 <cpu_step+0xaec>
800037b6:	18 96       	mov	r6,r12
	if (cpu_getZero(cpu1) == FALSE) {
800037b8:	0e 9c       	mov	r12,r7
800037ba:	f0 1f 00 6f 	mcall	80003974 <cpu_step+0xb60>
800037be:	e0 81 00 9d 	brne	800038f8 <cpu_step+0xae4>
		// +1 cycle if the branch succeeds
		nes_cpuCycled(nes);
800037c2:	08 9c       	mov	r12,r4
800037c4:	f0 1f 00 53 	mcall	80003910 <cpu_step+0xafc>
		cpu1->programCounter += data;
800037c8:	5c 66       	casts.b	r6
800037ca:	8e 08       	ld.sh	r8,r7[0x0]
800037cc:	0c 08       	add	r8,r6
800037ce:	ae 08       	st.h	r7[0x0],r8
800037d0:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// BMI - Branch if Minus
// If the negative flag is set then add the relative displacement to the program counter to cause a branch to a new location.
static void cpu_BMI(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
800037d4:	08 9c       	mov	r12,r4
800037d6:	f0 1f 00 4a 	mcall	800038fc <cpu_step+0xae8>
800037da:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BMI\n");
	SignedByte data = nes_readCPUMemory(nes, address);
800037dc:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800037e0:	08 9c       	mov	r12,r4
800037e2:	f0 1f 00 48 	mcall	80003900 <cpu_step+0xaec>
800037e6:	18 96       	mov	r6,r12
	if (cpu_getNegative(cpu1) == TRUE) {
800037e8:	0e 9c       	mov	r12,r7
800037ea:	f0 1f 00 64 	mcall	80003978 <cpu_step+0xb64>
800037ee:	30 18       	mov	r8,1
800037f0:	f0 0c 18 00 	cp.b	r12,r8
800037f4:	e0 81 00 82 	brne	800038f8 <cpu_step+0xae4>
		// +1 cycle if the branch succeeds
		nes_cpuCycled(nes);
800037f8:	08 9c       	mov	r12,r4
800037fa:	f0 1f 00 46 	mcall	80003910 <cpu_step+0xafc>
		cpu1->programCounter += data;
800037fe:	5c 66       	casts.b	r6
80003800:	8e 08       	ld.sh	r8,r7[0x0]
80003802:	0c 08       	add	r8,r6
80003804:	ae 08       	st.h	r7[0x0],r8
80003806:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// BPL - Branch if Positive
// If the negative flag is clear then add the relative displacement to the program counter to cause a branch to a new location.
static void cpu_BPL(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
8000380a:	08 9c       	mov	r12,r4
8000380c:	f0 1f 00 3c 	mcall	800038fc <cpu_step+0xae8>
80003810:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BPL\n");
	SignedByte data = nes_readCPUMemory(nes, address);
80003812:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80003816:	08 9c       	mov	r12,r4
80003818:	f0 1f 00 3a 	mcall	80003900 <cpu_step+0xaec>
8000381c:	18 96       	mov	r6,r12
	if (cpu_getNegative(cpu1) == FALSE) {
8000381e:	0e 9c       	mov	r12,r7
80003820:	f0 1f 00 56 	mcall	80003978 <cpu_step+0xb64>
80003824:	c6 a1       	brne	800038f8 <cpu_step+0xae4>
		// +1 cycle if the branch succeeds
		nes_cpuCycled(nes);
80003826:	08 9c       	mov	r12,r4
80003828:	f0 1f 00 3a 	mcall	80003910 <cpu_step+0xafc>
		cpu1->programCounter += data;
8000382c:	5c 66       	casts.b	r6
8000382e:	8e 08       	ld.sh	r8,r7[0x0]
80003830:	0c 08       	add	r8,r6
80003832:	ae 08       	st.h	r7[0x0],r8
80003834:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// BCC - Branch if Carry Clear
// If the carry flag is clear then add the relative displacement to the program counter to cause a branch to a new location.
static void cpu_BCC(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80003838:	08 9c       	mov	r12,r4
8000383a:	f0 1f 00 31 	mcall	800038fc <cpu_step+0xae8>
8000383e:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BCC\n");
	SignedByte data = nes_readCPUMemory(nes, address);
80003840:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80003844:	08 9c       	mov	r12,r4
80003846:	f0 1f 00 2f 	mcall	80003900 <cpu_step+0xaec>
8000384a:	18 96       	mov	r6,r12
	if (cpu_getCarry(cpu1) == FALSE) {
8000384c:	0e 9c       	mov	r12,r7
8000384e:	f0 1f 00 3b 	mcall	80003938 <cpu_step+0xb24>
80003852:	c5 31       	brne	800038f8 <cpu_step+0xae4>
		// +1 cycle if the branch succeeds
		nes_cpuCycled(nes);
80003854:	08 9c       	mov	r12,r4
80003856:	f0 1f 00 2f 	mcall	80003910 <cpu_step+0xafc>
		cpu1->programCounter += data;
8000385a:	5c 66       	casts.b	r6
8000385c:	8e 08       	ld.sh	r8,r7[0x0]
8000385e:	0c 08       	add	r8,r6
80003860:	ae 08       	st.h	r7[0x0],r8
80003862:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// BCS - Branch if Carry Set
// If the carry flag is set then add the relative displacement to the program counter to cause a branch to a new location.
static void cpu_BCS(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80003866:	08 9c       	mov	r12,r4
80003868:	f0 1f 00 25 	mcall	800038fc <cpu_step+0xae8>
8000386c:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BCS\n");
	SignedByte data = nes_readCPUMemory(nes, address);
8000386e:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80003872:	08 9c       	mov	r12,r4
80003874:	f0 1f 00 23 	mcall	80003900 <cpu_step+0xaec>
80003878:	18 96       	mov	r6,r12
	if (cpu_getCarry(cpu1) == TRUE) {
8000387a:	0e 9c       	mov	r12,r7
8000387c:	f0 1f 00 2f 	mcall	80003938 <cpu_step+0xb24>
80003880:	30 18       	mov	r8,1
80003882:	f0 0c 18 00 	cp.b	r12,r8
80003886:	c3 91       	brne	800038f8 <cpu_step+0xae4>
		// +1 cycle if the branch succeeds
		nes_cpuCycled(nes);
80003888:	08 9c       	mov	r12,r4
8000388a:	f0 1f 00 22 	mcall	80003910 <cpu_step+0xafc>
		cpu1->programCounter += data;
8000388e:	5c 66       	casts.b	r6
80003890:	8e 08       	ld.sh	r8,r7[0x0]
80003892:	0c 08       	add	r8,r6
80003894:	ae 08       	st.h	r7[0x0],r8
80003896:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// BVC - Branch if Overflow Clear
// If the overflow flag is clear then add the relative displacement to the program counter to cause a branch to a new location.
static void cpu_BVC(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
8000389a:	08 9c       	mov	r12,r4
8000389c:	f0 1f 00 18 	mcall	800038fc <cpu_step+0xae8>
800038a0:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BVC\n");
	SignedByte data = nes_readCPUMemory(nes, address);
800038a2:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800038a6:	08 9c       	mov	r12,r4
800038a8:	f0 1f 00 16 	mcall	80003900 <cpu_step+0xaec>
800038ac:	18 96       	mov	r6,r12
	if (cpu_getOverflow(cpu1) == FALSE) {
800038ae:	0e 9c       	mov	r12,r7
800038b0:	f0 1f 00 33 	mcall	8000397c <cpu_step+0xb68>
800038b4:	c2 21       	brne	800038f8 <cpu_step+0xae4>
		// +1 cycle if the branch succeeds
		nes_cpuCycled(nes);
800038b6:	08 9c       	mov	r12,r4
800038b8:	f0 1f 00 16 	mcall	80003910 <cpu_step+0xafc>
		cpu1->programCounter += data;
800038bc:	5c 66       	casts.b	r6
800038be:	8e 08       	ld.sh	r8,r7[0x0]
800038c0:	0c 08       	add	r8,r6
800038c2:	ae 08       	st.h	r7[0x0],r8
800038c4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// BVS - Branch if Overflow Set
// If the overflow flag is set then add the relative displacement to the program counter to cause a branch to a new location.
static void cpu_BVS(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
800038c8:	08 9c       	mov	r12,r4
800038ca:	f0 1f 00 0d 	mcall	800038fc <cpu_step+0xae8>
800038ce:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BVS\n");
	SignedByte data = nes_readCPUMemory(nes, address);
800038d0:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800038d4:	08 9c       	mov	r12,r4
800038d6:	f0 1f 00 0b 	mcall	80003900 <cpu_step+0xaec>
800038da:	18 96       	mov	r6,r12
	if (cpu_getOverflow(cpu1) == TRUE) {
800038dc:	0e 9c       	mov	r12,r7
800038de:	f0 1f 00 28 	mcall	8000397c <cpu_step+0xb68>
800038e2:	30 18       	mov	r8,1
800038e4:	f0 0c 18 00 	cp.b	r12,r8
800038e8:	c0 81       	brne	800038f8 <cpu_step+0xae4>
		// +1 cycle if the branch succeeds
		nes_cpuCycled(nes);
800038ea:	08 9c       	mov	r12,r4
800038ec:	f0 1f 00 09 	mcall	80003910 <cpu_step+0xafc>
		cpu1->programCounter += data;
800038f0:	5c 66       	casts.b	r6
800038f2:	8e 08       	ld.sh	r8,r7[0x0]
800038f4:	0c 08       	add	r8,r6
800038f6:	ae 08       	st.h	r7[0x0],r8
800038f8:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800038fc:	80 00       	ld.sh	r0,r0[0x0]
800038fe:	50 70       	stdsp	sp[0x1c],r0
80003900:	80 00       	ld.sh	r0,r0[0x0]
80003902:	53 6c       	stdsp	sp[0xd8],r12
80003904:	80 00       	ld.sh	r0,r0[0x0]
80003906:	8e 1c       	ld.sh	r12,r7[0x2]
80003908:	80 00       	ld.sh	r0,r0[0x0]
8000390a:	27 c4       	sub	r4,124
8000390c:	80 01       	ld.sh	r1,r0[0x0]
8000390e:	35 c8       	mov	r8,92
80003910:	80 00       	ld.sh	r0,r0[0x0]
80003912:	51 64       	stdsp	sp[0x58],r4
80003914:	80 01       	ld.sh	r1,r0[0x0]
80003916:	39 c8       	mov	r8,-100
80003918:	80 00       	ld.sh	r0,r0[0x0]
8000391a:	27 f0       	sub	r0,127
8000391c:	80 00       	ld.sh	r0,r0[0x0]
8000391e:	28 54       	sub	r4,-123
80003920:	80 00       	ld.sh	r0,r0[0x0]
80003922:	27 c0       	sub	r0,124
80003924:	80 00       	ld.sh	r0,r0[0x0]
80003926:	52 68       	stdsp	sp[0x98],r8
80003928:	80 00       	ld.sh	r0,r0[0x0]
8000392a:	27 b8       	sub	r8,123
8000392c:	80 00       	ld.sh	r0,r0[0x0]
8000392e:	27 bc       	sub	r12,123
80003930:	80 00       	ld.sh	r0,r0[0x0]
80003932:	28 74       	sub	r4,-121
80003934:	80 00       	ld.sh	r0,r0[0x0]
80003936:	28 bc       	sub	r12,-117
80003938:	80 00       	ld.sh	r0,r0[0x0]
8000393a:	28 b4       	sub	r4,-117
8000393c:	80 00       	ld.sh	r0,r0[0x0]
8000393e:	28 98       	sub	r8,-119
80003940:	80 00       	ld.sh	r0,r0[0x0]
80003942:	29 34       	sub	r4,-109
80003944:	80 00       	ld.sh	r0,r0[0x0]
80003946:	29 bc       	sub	r12,-101
80003948:	80 00       	ld.sh	r0,r0[0x0]
8000394a:	2a 14       	sub	r4,-95
8000394c:	80 00       	ld.sh	r0,r0[0x0]
8000394e:	2b 1c       	sub	r12,-79
80003950:	80 00       	ld.sh	r0,r0[0x0]
80003952:	29 20       	sub	r0,-110
80003954:	80 00       	ld.sh	r0,r0[0x0]
80003956:	2d ec       	sub	r12,-34
80003958:	80 00       	ld.sh	r0,r0[0x0]
8000395a:	2c 30       	sub	r0,-61
8000395c:	80 00       	ld.sh	r0,r0[0x0]
8000395e:	2c 6c       	sub	r12,-58
80003960:	80 00       	ld.sh	r0,r0[0x0]
80003962:	2a 6c       	sub	r12,-90
80003964:	80 00       	ld.sh	r0,r0[0x0]
80003966:	2c b0       	sub	r0,-53
80003968:	80 00       	ld.sh	r0,r0[0x0]
8000396a:	2c dc       	sub	r12,-51
8000396c:	80 00       	ld.sh	r0,r0[0x0]
8000396e:	28 0c       	sub	r12,-128
80003970:	80 00       	ld.sh	r0,r0[0x0]
80003972:	28 e0       	sub	r0,-114
80003974:	80 00       	ld.sh	r0,r0[0x0]
80003976:	27 cc       	sub	r12,124
80003978:	80 00       	ld.sh	r0,r0[0x0]
8000397a:	28 28       	sub	r8,-126
8000397c:	80 00       	ld.sh	r0,r0[0x0]
8000397e:	28 90       	sub	r0,-119

80003980 <cpu_init>:
	Byte status;
	Byte indexX;
	Byte indexY;
	Byte accumulator;
};
CPU cpu_init(void) {
80003980:	d4 01       	pushm	lr
	CPU cpu1 = (CPU) malloc(sizeof(struct cpu));
80003982:	30 8c       	mov	r12,8
80003984:	f0 1f 00 06 	mcall	8000399c <cpu_init+0x1c>
	//assert(cpu1 != NULL);
	cpu1->programCounter = 0;
80003988:	30 09       	mov	r9,0
8000398a:	b8 09       	st.h	r12[0x0],r9
	cpu1->status = CPU_STATUS_REGISTER_INITIAL_VALUE;
8000398c:	32 0a       	mov	r10,32
8000398e:	b8 ba       	st.b	r12[0x3],r10
	cpu1->indexX = 0;
80003990:	b8 c9       	st.b	r12[0x4],r9
	cpu1->indexY = 0;
80003992:	b8 d9       	st.b	r12[0x5],r9
	cpu1->accumulator = 0;
80003994:	b8 e9       	st.b	r12[0x6],r9
	cpu1->stackPointer = CPU_STACK_POINTER_INITIAL_VALUE;
80003996:	3f f9       	mov	r9,-1
80003998:	b8 a9       	st.b	r12[0x2],r9
	return cpu1;
}
8000399a:	d8 02       	popm	pc
8000399c:	80 00       	ld.sh	r0,r0[0x0]
8000399e:	c1 fc       	rcall	800039dc <cpuMemory_ppuMirror_getLowestAddress+0x14>

800039a0 <cpuMemory_spriteDMARegister_reader>:
}
////////////////////////////////////////////////////////////////////////////////////////
///
// #define CPU_SPRITE_DMA_REGISTER_ADDRESS                 0x4014 // write
#define CPU_DMA_ADDRESS_MULTIPLIER 0x0100
static Byte cpuMemory_spriteDMARegister_reader(NES nes, Address address) {
800039a0:	d4 01       	pushm	lr
  assert(nes != NULL);
800039a2:	58 0c       	cp.w	r12,0
800039a4:	c0 81       	brne	800039b4 <cpuMemory_spriteDMARegister_reader+0x14>
800039a6:	48 59       	lddpc	r9,800039b8 <cpuMemory_spriteDMARegister_reader+0x18>
800039a8:	48 5a       	lddpc	r10,800039bc <cpuMemory_spriteDMARegister_reader+0x1c>
800039aa:	e0 6b 00 c0 	mov	r11,192
800039ae:	48 5c       	lddpc	r12,800039c0 <cpuMemory_spriteDMARegister_reader+0x20>
800039b0:	f0 1f 00 05 	mcall	800039c4 <cpuMemory_spriteDMARegister_reader+0x24>
  return 0;
}
800039b4:	d8 0a       	popm	pc,r12=0
800039b6:	00 00       	add	r0,r0
800039b8:	80 01       	ld.sh	r1,r0[0x0]
800039ba:	31 44       	mov	r4,20
800039bc:	80 01       	ld.sh	r1,r0[0x0]
800039be:	3f b8       	mov	r8,-5
800039c0:	80 01       	ld.sh	r1,r0[0x0]
800039c2:	40 d0       	lddsp	r0,sp[0x34]
800039c4:	80 00       	ld.sh	r0,r0[0x0]
800039c6:	c1 a0       	breq	800039fa <cpuMemory_ppuStatusRegister_writer+0xe>

800039c8 <cpuMemory_ppuMirror_getLowestAddress>:
  return data;
}
////////////////////////////////////////////////////////////////////////////////////////
//
static Address cpuMemory_ppuMirror_getLowestAddress(Address address) {
  while(address > CPU_GENUINE_PPU_LAST_ADDRESS) {
800039c8:	e0 68 20 07 	mov	r8,8199
800039cc:	f0 0c 19 00 	cp.h	r12,r8
800039d0:	5e 8c       	retls	r12
    address -= CPU_PPU_MIRRORED_SIZE;
800039d2:	f8 c8 00 08 	sub	r8,r12,8
  Byte data = memory_read_callback(nes, cpuMemory, address);
  return data;
}
////////////////////////////////////////////////////////////////////////////////////////
//
static Address cpuMemory_ppuMirror_getLowestAddress(Address address) {
800039d6:	fe 3c 20 08 	sub	r12,-57336
800039da:	f9 dc c0 6d 	bfextu	r12,r12,0x3,0xd
800039de:	f8 0c 10 f8 	mul	r12,r12,-8
800039e2:	f0 0c 00 0c 	add	r12,r8,r12
800039e6:	5c 8c       	casts.h	r12
  while(address > CPU_GENUINE_PPU_LAST_ADDRESS) {
    address -= CPU_PPU_MIRRORED_SIZE;
  }
  assert(address <= CPU_GENUINE_PPU_LAST_ADDRESS);
  return address;
}
800039e8:	5e fc       	retal	r12
800039ea:	d7 03       	nop

800039ec <cpuMemory_ppuStatusRegister_writer>:
  assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
  assert(ppu != NULL);
  return ppu_getStatusRegister(ppu);
}
static void cpuMemory_ppuStatusRegister_writer(NES nes, Address address, Byte data) {
800039ec:	d4 01       	pushm	lr
  assert(nes != NULL);
800039ee:	58 0c       	cp.w	r12,0
800039f0:	c0 71       	brne	800039fe <cpuMemory_ppuStatusRegister_writer+0x12>
800039f2:	48 79       	lddpc	r9,80003a0c <cpuMemory_ppuStatusRegister_writer+0x20>
800039f4:	48 7a       	lddpc	r10,80003a10 <cpuMemory_ppuStatusRegister_writer+0x24>
800039f6:	36 8b       	mov	r11,104
800039f8:	48 7c       	lddpc	r12,80003a14 <cpuMemory_ppuStatusRegister_writer+0x28>
800039fa:	f0 1f 00 08 	mcall	80003a18 <cpuMemory_ppuStatusRegister_writer+0x2c>
  // not allowed to write this
  assert(FALSE);
800039fe:	48 89       	lddpc	r9,80003a1c <cpuMemory_ppuStatusRegister_writer+0x30>
80003a00:	48 4a       	lddpc	r10,80003a10 <cpuMemory_ppuStatusRegister_writer+0x24>
80003a02:	36 ab       	mov	r11,106
80003a04:	48 4c       	lddpc	r12,80003a14 <cpuMemory_ppuStatusRegister_writer+0x28>
80003a06:	f0 1f 00 05 	mcall	80003a18 <cpuMemory_ppuStatusRegister_writer+0x2c>
80003a0a:	00 00       	add	r0,r0
80003a0c:	80 01       	ld.sh	r1,r0[0x0]
80003a0e:	31 44       	mov	r4,20
80003a10:	80 01       	ld.sh	r1,r0[0x0]
80003a12:	40 20       	lddsp	r0,sp[0x8]
80003a14:	80 01       	ld.sh	r1,r0[0x0]
80003a16:	40 d0       	lddsp	r0,sp[0x34]
80003a18:	80 00       	ld.sh	r0,r0[0x0]
80003a1a:	c1 a0       	breq	80003a4e <cpuMemory_init+0x1e>
80003a1c:	80 01       	ld.sh	r1,r0[0x0]
80003a1e:	56 cc       	stdsp	sp[0x1b0],r12

80003a20 <cpuMemory_ramMirror_getLowestAddress>:
#include "objectAttributeMemory.h"
#include "usart.h"
////////////////////////////////////////////////////////////////////////////////////////
//
static Address cpuMemory_ramMirror_getLowestAddress(Address address) {
  while(address > CPU_GENUINE_RAM_LAST_ADDRESS) {
80003a20:	e0 68 07 ff 	mov	r8,2047
80003a24:	f0 0c 19 00 	cp.h	r12,r8
80003a28:	5e 8c       	retls	r12
    address -= CPU_RAM_MIRRORED_SIZE;
80003a2a:	f9 dc c0 0b 	bfextu	r12,r12,0x0,0xb
  }
  assert(address <= CPU_GENUINE_RAM_LAST_ADDRESS);
  return address;
}
80003a2e:	5e fc       	retal	r12

80003a30 <cpuMemory_init>:
  assert(currentJoypad >= 0);
  assert(currentJoypad <= 3);
  nes_writeJoypad(nes, currentJoypad, data);
}

Memory cpuMemory_init(void) {
80003a30:	d4 21       	pushm	r4-r7,lr
	usart_write_line(&AVR32_USART0,"CPU22");
80003a32:	4e 7b       	lddpc	r11,80003bcc <cpuMemory_init+0x19c>
80003a34:	fe 7c 14 00 	mov	r12,-60416
80003a38:	f0 1f 00 66 	mcall	80003bd0 <cpuMemory_init+0x1a0>
  Memory memory1 = memory_init(CPU_TOTAL_MEMORY_ADDRESSES);
80003a3c:	e0 7c 00 00 	mov	r12,65536
80003a40:	f0 1f 00 65 	mcall	80003bd4 <cpuMemory_init+0x1a4>
80003a44:	18 96       	mov	r6,r12
  //Memory memory1 = memory_init(0xFFFF);
  assert(memory1 != NULL);
80003a46:	c0 81       	brne	80003a56 <cpuMemory_init+0x26>
80003a48:	4e 49       	lddpc	r9,80003bd8 <cpuMemory_init+0x1a8>
80003a4a:	4e 5a       	lddpc	r10,80003bdc <cpuMemory_init+0x1ac>
80003a4c:	e0 6b 00 e9 	mov	r11,233
80003a50:	4e 4c       	lddpc	r12,80003be0 <cpuMemory_init+0x1b0>
80003a52:	f0 1f 00 65 	mcall	80003be4 <cpuMemory_init+0x1b4>
  usart_write_line(&AVR32_USART0,"CPU221");
80003a56:	4e 5b       	lddpc	r11,80003be8 <cpuMemory_init+0x1b8>
80003a58:	fe 7c 14 00 	mov	r12,-60416
80003a5c:	f0 1f 00 5d 	mcall	80003bd0 <cpuMemory_init+0x1a0>
80003a60:	e0 67 08 00 	mov	r7,2048
  int address;
  //for (address=CPU_FIRST_RAM_MIRRORED_ADDRESS; address <=CPU_LAST_RAM_MIRRORED_ADDRESS; address++) {
	  
  for (address=CPU_RAM_MIRROR_FIRST_ADDRESS; address <= CPU_RAM_MIRROR_LAST_ADDRESS; address++) {
    memory_setWriteCallback(memory1, address, &cpuMemory_ramMirror_writer);
80003a64:	4e 25       	lddpc	r5,80003bec <cpuMemory_init+0x1bc>
    memory_setReadCallback(memory1, address, &cpuMemory_ramMirror_reader);
80003a66:	4e 34       	lddpc	r4,80003bf0 <cpuMemory_init+0x1c0>
  usart_write_line(&AVR32_USART0,"CPU221");
  int address;
  //for (address=CPU_FIRST_RAM_MIRRORED_ADDRESS; address <=CPU_LAST_RAM_MIRRORED_ADDRESS; address++) {
	  
  for (address=CPU_RAM_MIRROR_FIRST_ADDRESS; address <= CPU_RAM_MIRROR_LAST_ADDRESS; address++) {
    memory_setWriteCallback(memory1, address, &cpuMemory_ramMirror_writer);
80003a68:	0a 9a       	mov	r10,r5
80003a6a:	0e 9b       	mov	r11,r7
80003a6c:	0c 9c       	mov	r12,r6
80003a6e:	f0 1f 00 62 	mcall	80003bf4 <cpuMemory_init+0x1c4>
    memory_setReadCallback(memory1, address, &cpuMemory_ramMirror_reader);
80003a72:	08 9a       	mov	r10,r4
80003a74:	0e 9b       	mov	r11,r7
80003a76:	0c 9c       	mov	r12,r6
80003a78:	f0 1f 00 60 	mcall	80003bf8 <cpuMemory_init+0x1c8>
  assert(memory1 != NULL);
  usart_write_line(&AVR32_USART0,"CPU221");
  int address;
  //for (address=CPU_FIRST_RAM_MIRRORED_ADDRESS; address <=CPU_LAST_RAM_MIRRORED_ADDRESS; address++) {
	  
  for (address=CPU_RAM_MIRROR_FIRST_ADDRESS; address <= CPU_RAM_MIRROR_LAST_ADDRESS; address++) {
80003a7c:	2f f7       	sub	r7,-1
80003a7e:	e0 47 20 00 	cp.w	r7,8192
80003a82:	cf 31       	brne	80003a68 <cpuMemory_init+0x38>
    memory_setWriteCallback(memory1, address, &cpuMemory_ramMirror_writer);
    memory_setReadCallback(memory1, address, &cpuMemory_ramMirror_reader);
  }
  usart_write_line(&AVR32_USART0,"CPU2");
80003a84:	4d eb       	lddpc	r11,80003bfc <cpuMemory_init+0x1cc>
80003a86:	fe 7c 14 00 	mov	r12,-60416
80003a8a:	f0 1f 00 52 	mcall	80003bd0 <cpuMemory_init+0x1a0>
  // setup the ppu register redirectors
  
  memory_setReadCallback(memory1, CPU_PPU_CONTROL_REGISTER_ADDRESS, &cpuMemory_ppuControlRegister_reader);
80003a8e:	4d da       	lddpc	r10,80003c00 <cpuMemory_init+0x1d0>
80003a90:	e0 6b 20 00 	mov	r11,8192
80003a94:	0c 9c       	mov	r12,r6
80003a96:	f0 1f 00 59 	mcall	80003bf8 <cpuMemory_init+0x1c8>
  memory_setWriteCallback(memory1, CPU_PPU_CONTROL_REGISTER_ADDRESS, &cpuMemory_ppuControlRegister_writer);
80003a9a:	4d ba       	lddpc	r10,80003c04 <cpuMemory_init+0x1d4>
80003a9c:	e0 6b 20 00 	mov	r11,8192
80003aa0:	0c 9c       	mov	r12,r6
80003aa2:	f0 1f 00 55 	mcall	80003bf4 <cpuMemory_init+0x1c4>
  memory_setReadCallback(memory1, CPU_PPU_MASK_REGISTER_ADDRESS, &cpuMemory_ppuMaskRegister_reader);
80003aa6:	4d 9a       	lddpc	r10,80003c08 <cpuMemory_init+0x1d8>
80003aa8:	e0 6b 20 01 	mov	r11,8193
80003aac:	0c 9c       	mov	r12,r6
80003aae:	f0 1f 00 53 	mcall	80003bf8 <cpuMemory_init+0x1c8>
  memory_setWriteCallback(memory1, CPU_PPU_MASK_REGISTER_ADDRESS,&cpuMemory_ppuMaskRegister_writer);
80003ab2:	4d 7a       	lddpc	r10,80003c0c <cpuMemory_init+0x1dc>
80003ab4:	e0 6b 20 01 	mov	r11,8193
80003ab8:	0c 9c       	mov	r12,r6
80003aba:	f0 1f 00 4f 	mcall	80003bf4 <cpuMemory_init+0x1c4>
  memory_setReadCallback(memory1, CPU_PPU_STATUS_REGISTER_ADDRESS,&cpuMemory_ppuStatusRegister_reader);
80003abe:	4d 5a       	lddpc	r10,80003c10 <cpuMemory_init+0x1e0>
80003ac0:	e0 6b 20 02 	mov	r11,8194
80003ac4:	0c 9c       	mov	r12,r6
80003ac6:	f0 1f 00 4d 	mcall	80003bf8 <cpuMemory_init+0x1c8>
  memory_setWriteCallback(memory1, CPU_PPU_STATUS_REGISTER_ADDRESS,&cpuMemory_ppuStatusRegister_writer);
80003aca:	4d 3a       	lddpc	r10,80003c14 <cpuMemory_init+0x1e4>
80003acc:	e0 6b 20 02 	mov	r11,8194
80003ad0:	0c 9c       	mov	r12,r6
80003ad2:	f0 1f 00 49 	mcall	80003bf4 <cpuMemory_init+0x1c4>
  memory_setReadCallback(memory1, CPU_PPU_SPRITE_ADDRESS_REGISTER_ADDRESS,&cpuMemory_ppuSpriteAddressRegister_reader);
80003ad6:	4d 1a       	lddpc	r10,80003c18 <cpuMemory_init+0x1e8>
80003ad8:	e0 6b 20 03 	mov	r11,8195
80003adc:	0c 9c       	mov	r12,r6
80003ade:	f0 1f 00 47 	mcall	80003bf8 <cpuMemory_init+0x1c8>
  memory_setWriteCallback(memory1, CPU_PPU_SPRITE_ADDRESS_REGISTER_ADDRESS,&cpuMemory_ppuSpriteAddressRegister_writer);
80003ae2:	4c fa       	lddpc	r10,80003c1c <cpuMemory_init+0x1ec>
80003ae4:	e0 6b 20 03 	mov	r11,8195
80003ae8:	0c 9c       	mov	r12,r6
80003aea:	f0 1f 00 43 	mcall	80003bf4 <cpuMemory_init+0x1c4>
  memory_setReadCallback(memory1, CPU_PPU_SPRITE_DATA_REGISTER_ADDRESS,&cpuMemory_ppuSpriteDataRegister_reader);
80003aee:	4c da       	lddpc	r10,80003c20 <cpuMemory_init+0x1f0>
80003af0:	e0 6b 20 04 	mov	r11,8196
80003af4:	0c 9c       	mov	r12,r6
80003af6:	f0 1f 00 41 	mcall	80003bf8 <cpuMemory_init+0x1c8>
  memory_setWriteCallback(memory1, CPU_PPU_SPRITE_DATA_REGISTER_ADDRESS,&cpuMemory_ppuSpriteDataRegister_writer);
80003afa:	4c ba       	lddpc	r10,80003c24 <cpuMemory_init+0x1f4>
80003afc:	e0 6b 20 04 	mov	r11,8196
80003b00:	0c 9c       	mov	r12,r6
80003b02:	f0 1f 00 3d 	mcall	80003bf4 <cpuMemory_init+0x1c4>
  memory_setReadCallback(memory1, CPU_PPU_SCROLL_REGISTER_ADDRESS,&cpuMemory_ppuScrollRegister_reader);
80003b06:	4c 9a       	lddpc	r10,80003c28 <cpuMemory_init+0x1f8>
80003b08:	e0 6b 20 05 	mov	r11,8197
80003b0c:	0c 9c       	mov	r12,r6
80003b0e:	f0 1f 00 3b 	mcall	80003bf8 <cpuMemory_init+0x1c8>
  memory_setWriteCallback(memory1, CPU_PPU_SCROLL_REGISTER_ADDRESS,&cpuMemory_ppuScrollRegister_writer);
80003b12:	4c 7a       	lddpc	r10,80003c2c <cpuMemory_init+0x1fc>
80003b14:	e0 6b 20 05 	mov	r11,8197
80003b18:	0c 9c       	mov	r12,r6
80003b1a:	f0 1f 00 37 	mcall	80003bf4 <cpuMemory_init+0x1c4>
  memory_setReadCallback(memory1, CPU_PPUMEMORY_ADDRESS_REGISTER_ADDRESS,&cpuMemory_ppuMemoryAddressRegister_reader);
80003b1e:	4c 5a       	lddpc	r10,80003c30 <cpuMemory_init+0x200>
80003b20:	e0 6b 20 06 	mov	r11,8198
80003b24:	0c 9c       	mov	r12,r6
80003b26:	f0 1f 00 35 	mcall	80003bf8 <cpuMemory_init+0x1c8>
  memory_setWriteCallback(memory1, CPU_PPUMEMORY_ADDRESS_REGISTER_ADDRESS,&cpuMemory_ppuMemoryAddressRegister_writer);
80003b2a:	4c 3a       	lddpc	r10,80003c34 <cpuMemory_init+0x204>
80003b2c:	e0 6b 20 06 	mov	r11,8198
80003b30:	0c 9c       	mov	r12,r6
80003b32:	f0 1f 00 31 	mcall	80003bf4 <cpuMemory_init+0x1c4>
  memory_setReadCallback(memory1, CPU_PPUMEMORY_DATA_REGISTER_ADDRESS,&cpuMemory_ppuMemoryDataRegister_reader);
80003b36:	4c 1a       	lddpc	r10,80003c38 <cpuMemory_init+0x208>
80003b38:	e0 6b 20 07 	mov	r11,8199
80003b3c:	0c 9c       	mov	r12,r6
80003b3e:	f0 1f 00 2f 	mcall	80003bf8 <cpuMemory_init+0x1c8>
  memory_setWriteCallback(memory1, CPU_PPUMEMORY_DATA_REGISTER_ADDRESS,&cpuMemory_ppuMemoryDataRegister_writer);
80003b42:	4b fa       	lddpc	r10,80003c3c <cpuMemory_init+0x20c>
80003b44:	e0 6b 20 07 	mov	r11,8199
80003b48:	0c 9c       	mov	r12,r6
80003b4a:	f0 1f 00 2b 	mcall	80003bf4 <cpuMemory_init+0x1c4>
80003b4e:	e0 67 20 08 	mov	r7,8200
  // now setup their mirrors
  for (address=CPU_PPU_MIRROR_FIRST_ADDRESS; address <= CPU_PPU_MIRROR_LAST_ADDRESS; address++) {
    memory_setWriteCallback(memory1, address, &cpuMemory_ppuMirror_writer);
80003b52:	4b c5       	lddpc	r5,80003c40 <cpuMemory_init+0x210>
    memory_setReadCallback(memory1, address, &cpuMemory_ppuMirror_reader);
80003b54:	4b c4       	lddpc	r4,80003c44 <cpuMemory_init+0x214>
  memory_setWriteCallback(memory1, CPU_PPUMEMORY_ADDRESS_REGISTER_ADDRESS,&cpuMemory_ppuMemoryAddressRegister_writer);
  memory_setReadCallback(memory1, CPU_PPUMEMORY_DATA_REGISTER_ADDRESS,&cpuMemory_ppuMemoryDataRegister_reader);
  memory_setWriteCallback(memory1, CPU_PPUMEMORY_DATA_REGISTER_ADDRESS,&cpuMemory_ppuMemoryDataRegister_writer);
  // now setup their mirrors
  for (address=CPU_PPU_MIRROR_FIRST_ADDRESS; address <= CPU_PPU_MIRROR_LAST_ADDRESS; address++) {
    memory_setWriteCallback(memory1, address, &cpuMemory_ppuMirror_writer);
80003b56:	0a 9a       	mov	r10,r5
80003b58:	0e 9b       	mov	r11,r7
80003b5a:	0c 9c       	mov	r12,r6
80003b5c:	f0 1f 00 26 	mcall	80003bf4 <cpuMemory_init+0x1c4>
    memory_setReadCallback(memory1, address, &cpuMemory_ppuMirror_reader);
80003b60:	08 9a       	mov	r10,r4
80003b62:	0e 9b       	mov	r11,r7
80003b64:	0c 9c       	mov	r12,r6
80003b66:	f0 1f 00 25 	mcall	80003bf8 <cpuMemory_init+0x1c8>
  memory_setReadCallback(memory1, CPU_PPUMEMORY_ADDRESS_REGISTER_ADDRESS,&cpuMemory_ppuMemoryAddressRegister_reader);
  memory_setWriteCallback(memory1, CPU_PPUMEMORY_ADDRESS_REGISTER_ADDRESS,&cpuMemory_ppuMemoryAddressRegister_writer);
  memory_setReadCallback(memory1, CPU_PPUMEMORY_DATA_REGISTER_ADDRESS,&cpuMemory_ppuMemoryDataRegister_reader);
  memory_setWriteCallback(memory1, CPU_PPUMEMORY_DATA_REGISTER_ADDRESS,&cpuMemory_ppuMemoryDataRegister_writer);
  // now setup their mirrors
  for (address=CPU_PPU_MIRROR_FIRST_ADDRESS; address <= CPU_PPU_MIRROR_LAST_ADDRESS; address++) {
80003b6a:	2f f7       	sub	r7,-1
80003b6c:	e0 47 40 00 	cp.w	r7,16384
80003b70:	cf 31       	brne	80003b56 <cpuMemory_init+0x126>
    memory_setWriteCallback(memory1, address, &cpuMemory_ppuMirror_writer);
    memory_setReadCallback(memory1, address, &cpuMemory_ppuMirror_reader);
  }
  memory_setReadCallback(memory1, CPU_SPRITE_DMA_REGISTER_ADDRESS,&cpuMemory_spriteDMARegister_reader);
80003b72:	4b 6a       	lddpc	r10,80003c48 <cpuMemory_init+0x218>
80003b74:	e0 6b 40 14 	mov	r11,16404
80003b78:	0c 9c       	mov	r12,r6
80003b7a:	f0 1f 00 20 	mcall	80003bf8 <cpuMemory_init+0x1c8>
  memory_setWriteCallback(memory1, CPU_SPRITE_DMA_REGISTER_ADDRESS,&cpuMemory_spriteDMARegister_writer);
80003b7e:	4b 4a       	lddpc	r10,80003c4c <cpuMemory_init+0x21c>
80003b80:	e0 6b 40 14 	mov	r11,16404
80003b84:	0c 9c       	mov	r12,r6
80003b86:	f0 1f 00 1c 	mcall	80003bf4 <cpuMemory_init+0x1c4>
  memory_setReadCallback(memory1, CPU_JOYPAD_0_ADDRESS, &cpuMemory_joypad_reader);
80003b8a:	4b 27       	lddpc	r7,80003c50 <cpuMemory_init+0x220>
80003b8c:	0e 9a       	mov	r10,r7
80003b8e:	e0 6b 40 16 	mov	r11,16406
80003b92:	0c 9c       	mov	r12,r6
80003b94:	f0 1f 00 19 	mcall	80003bf8 <cpuMemory_init+0x1c8>
  memory_setWriteCallback(memory1, CPU_JOYPAD_0_ADDRESS, &cpuMemory_joypad_writer);
80003b98:	4a f5       	lddpc	r5,80003c54 <cpuMemory_init+0x224>
80003b9a:	0a 9a       	mov	r10,r5
80003b9c:	e0 6b 40 16 	mov	r11,16406
80003ba0:	0c 9c       	mov	r12,r6
80003ba2:	f0 1f 00 15 	mcall	80003bf4 <cpuMemory_init+0x1c4>
  memory_setReadCallback(memory1, CPU_JOYPAD_1_ADDRESS, &cpuMemory_joypad_reader);
80003ba6:	0e 9a       	mov	r10,r7
80003ba8:	e0 6b 40 17 	mov	r11,16407
80003bac:	0c 9c       	mov	r12,r6
80003bae:	f0 1f 00 13 	mcall	80003bf8 <cpuMemory_init+0x1c8>
  memory_setWriteCallback(memory1, CPU_JOYPAD_1_ADDRESS, &cpuMemory_joypad_writer);
80003bb2:	0a 9a       	mov	r10,r5
80003bb4:	e0 6b 40 17 	mov	r11,16407
80003bb8:	0c 9c       	mov	r12,r6
80003bba:	f0 1f 00 0f 	mcall	80003bf4 <cpuMemory_init+0x1c4>
  
  usart_write_line(&AVR32_USART0,"CPU21");
80003bbe:	4a 7b       	lddpc	r11,80003c58 <cpuMemory_init+0x228>
80003bc0:	fe 7c 14 00 	mov	r12,-60416
80003bc4:	f0 1f 00 03 	mcall	80003bd0 <cpuMemory_init+0x1a0>
  return memory1;
}
80003bc8:	0c 9c       	mov	r12,r6
80003bca:	d8 22       	popm	r4-r7,pc
80003bcc:	80 01       	ld.sh	r1,r0[0x0]
80003bce:	40 e8       	lddsp	r8,sp[0x38]
80003bd0:	80 00       	ld.sh	r0,r0[0x0]
80003bd2:	8e 5c       	ld.sh	r12,r7[0xa]
80003bd4:	80 00       	ld.sh	r0,r0[0x0]
80003bd6:	49 1c       	lddpc	r12,80003c18 <cpuMemory_init+0x1e8>
80003bd8:	80 01       	ld.sh	r1,r0[0x0]
80003bda:	40 f0       	lddsp	r0,sp[0x3c]
80003bdc:	80 01       	ld.sh	r1,r0[0x0]
80003bde:	3f 84       	mov	r4,-8
80003be0:	80 01       	ld.sh	r1,r0[0x0]
80003be2:	40 d0       	lddsp	r0,sp[0x34]
80003be4:	80 00       	ld.sh	r0,r0[0x0]
80003be6:	c1 a0       	breq	80003c1a <cpuMemory_init+0x1ea>
80003be8:	80 01       	ld.sh	r1,r0[0x0]
80003bea:	41 00       	lddsp	r0,sp[0x40]
80003bec:	80 00       	ld.sh	r0,r0[0x0]
80003bee:	3e cc       	mov	r12,-20
80003bf0:	80 00       	ld.sh	r0,r0[0x0]
80003bf2:	3d 70       	mov	r0,-41
80003bf4:	80 00       	ld.sh	r0,r0[0x0]
80003bf6:	47 cc       	lddsp	r12,sp[0x1f0]
80003bf8:	80 00       	ld.sh	r0,r0[0x0]
80003bfa:	47 a0       	lddsp	r0,sp[0x1e8]
80003bfc:	80 01       	ld.sh	r1,r0[0x0]
80003bfe:	41 08       	lddsp	r8,sp[0x40]
80003c00:	80 00       	ld.sh	r0,r0[0x0]
80003c02:	43 84       	lddsp	r4,sp[0xe0]
80003c04:	80 00       	ld.sh	r0,r0[0x0]
80003c06:	43 34       	lddsp	r4,sp[0xcc]
80003c08:	80 00       	ld.sh	r0,r0[0x0]
80003c0a:	42 ec       	lddsp	r12,sp[0xb8]
80003c0c:	80 00       	ld.sh	r0,r0[0x0]
80003c0e:	42 9c       	lddsp	r12,sp[0xa4]
80003c10:	80 00       	ld.sh	r0,r0[0x0]
80003c12:	42 54       	lddsp	r4,sp[0x94]
80003c14:	80 00       	ld.sh	r0,r0[0x0]
80003c16:	39 ec       	mov	r12,-98
80003c18:	80 00       	ld.sh	r0,r0[0x0]
80003c1a:	42 0c       	lddsp	r12,sp[0x80]
80003c1c:	80 00       	ld.sh	r0,r0[0x0]
80003c1e:	41 bc       	lddsp	r12,sp[0x6c]
80003c20:	80 00       	ld.sh	r0,r0[0x0]
80003c22:	41 68       	lddsp	r8,sp[0x58]
80003c24:	80 00       	ld.sh	r0,r0[0x0]
80003c26:	41 10       	lddsp	r0,sp[0x44]
80003c28:	80 00       	ld.sh	r0,r0[0x0]
80003c2a:	40 c4       	lddsp	r4,sp[0x30]
80003c2c:	80 00       	ld.sh	r0,r0[0x0]
80003c2e:	40 70       	lddsp	r0,sp[0x1c]
80003c30:	80 00       	ld.sh	r0,r0[0x0]
80003c32:	40 24       	lddsp	r4,sp[0x8]
80003c34:	80 00       	ld.sh	r0,r0[0x0]
80003c36:	3f d0       	mov	r0,-3
80003c38:	80 00       	ld.sh	r0,r0[0x0]
80003c3a:	3f 7c       	mov	r12,-9
80003c3c:	80 00       	ld.sh	r0,r0[0x0]
80003c3e:	3f 24       	mov	r4,-14
80003c40:	80 00       	ld.sh	r0,r0[0x0]
80003c42:	3e 74       	mov	r4,-25
80003c44:	80 00       	ld.sh	r0,r0[0x0]
80003c46:	3d 1c       	mov	r12,-47
80003c48:	80 00       	ld.sh	r0,r0[0x0]
80003c4a:	39 a0       	mov	r0,-102
80003c4c:	80 00       	ld.sh	r0,r0[0x0]
80003c4e:	3d c4       	mov	r4,-36
80003c50:	80 00       	ld.sh	r0,r0[0x0]
80003c52:	3c bc       	mov	r12,-53
80003c54:	80 00       	ld.sh	r0,r0[0x0]
80003c56:	3c 5c       	mov	r12,-59
80003c58:	80 01       	ld.sh	r1,r0[0x0]
80003c5a:	41 10       	lddsp	r0,sp[0x44]

80003c5c <cpuMemory_joypad_writer>:
  int currentJoypad = address - CPU_JOYPAD_0_ADDRESS;
  assert(currentJoypad >= 0);
  assert(currentJoypad <= 3);
  return nes_readJoypad(nes, currentJoypad);
}
static void cpuMemory_joypad_writer(NES nes, Address address, Byte data) {
80003c5c:	d4 01       	pushm	lr
  assert(nes != NULL);
80003c5e:	58 0c       	cp.w	r12,0
80003c60:	c0 81       	brne	80003c70 <cpuMemory_joypad_writer+0x14>
80003c62:	49 09       	lddpc	r9,80003ca0 <cpuMemory_joypad_writer+0x44>
80003c64:	49 0a       	lddpc	r10,80003ca4 <cpuMemory_joypad_writer+0x48>
80003c66:	e0 6b 00 de 	mov	r11,222
80003c6a:	49 0c       	lddpc	r12,80003ca8 <cpuMemory_joypad_writer+0x4c>
80003c6c:	f0 1f 00 10 	mcall	80003cac <cpuMemory_joypad_writer+0x50>
  int currentJoypad = address - CPU_JOYPAD_0_ADDRESS;
80003c70:	5c 7b       	castu.h	r11
80003c72:	f6 cb 40 16 	sub	r11,r11,16406
  assert(currentJoypad >= 0);
80003c76:	c0 87       	brpl	80003c86 <cpuMemory_joypad_writer+0x2a>
80003c78:	48 e9       	lddpc	r9,80003cb0 <cpuMemory_joypad_writer+0x54>
80003c7a:	48 ba       	lddpc	r10,80003ca4 <cpuMemory_joypad_writer+0x48>
80003c7c:	e0 6b 00 e0 	mov	r11,224
80003c80:	48 ac       	lddpc	r12,80003ca8 <cpuMemory_joypad_writer+0x4c>
80003c82:	f0 1f 00 0b 	mcall	80003cac <cpuMemory_joypad_writer+0x50>
  assert(currentJoypad <= 3);
80003c86:	58 3b       	cp.w	r11,3
80003c88:	e0 8a 00 09 	brle	80003c9a <cpuMemory_joypad_writer+0x3e>
80003c8c:	48 a9       	lddpc	r9,80003cb4 <cpuMemory_joypad_writer+0x58>
80003c8e:	48 6a       	lddpc	r10,80003ca4 <cpuMemory_joypad_writer+0x48>
80003c90:	e0 6b 00 e1 	mov	r11,225
80003c94:	48 5c       	lddpc	r12,80003ca8 <cpuMemory_joypad_writer+0x4c>
80003c96:	f0 1f 00 06 	mcall	80003cac <cpuMemory_joypad_writer+0x50>
  nes_writeJoypad(nes, currentJoypad, data);
80003c9a:	f0 1f 00 08 	mcall	80003cb8 <cpuMemory_joypad_writer+0x5c>
}
80003c9e:	d8 02       	popm	pc
80003ca0:	80 01       	ld.sh	r1,r0[0x0]
80003ca2:	31 44       	mov	r4,20
80003ca4:	80 01       	ld.sh	r1,r0[0x0]
80003ca6:	3f 50       	mov	r0,-11
80003ca8:	80 01       	ld.sh	r1,r0[0x0]
80003caa:	40 d0       	lddsp	r0,sp[0x34]
80003cac:	80 00       	ld.sh	r0,r0[0x0]
80003cae:	c1 a0       	breq	80003ce2 <cpuMemory_joypad_reader+0x26>
80003cb0:	80 01       	ld.sh	r1,r0[0x0]
80003cb2:	41 18       	lddsp	r8,sp[0x44]
80003cb4:	80 01       	ld.sh	r1,r0[0x0]
80003cb6:	41 2c       	lddsp	r12,sp[0x48]
80003cb8:	80 00       	ld.sh	r0,r0[0x0]
80003cba:	54 c8       	stdsp	sp[0x130],r8

80003cbc <cpuMemory_joypad_reader>:
}
////////////////////////////////////////////////////////////////////////////////////////
///
// CPU_JOYPAD_0_ADDRESS
// CPU_JOYPAD_1_ADDRESS
static Byte cpuMemory_joypad_reader(NES nes, Address address) {
80003cbc:	d4 01       	pushm	lr
  assert(nes != NULL);
80003cbe:	58 0c       	cp.w	r12,0
80003cc0:	c0 81       	brne	80003cd0 <cpuMemory_joypad_reader+0x14>
80003cc2:	49 09       	lddpc	r9,80003d00 <cpuMemory_joypad_reader+0x44>
80003cc4:	49 0a       	lddpc	r10,80003d04 <cpuMemory_joypad_reader+0x48>
80003cc6:	e0 6b 00 d7 	mov	r11,215
80003cca:	49 0c       	lddpc	r12,80003d08 <cpuMemory_joypad_reader+0x4c>
80003ccc:	f0 1f 00 10 	mcall	80003d0c <cpuMemory_joypad_reader+0x50>
  int currentJoypad = address - CPU_JOYPAD_0_ADDRESS;
80003cd0:	5c 7b       	castu.h	r11
80003cd2:	f6 cb 40 16 	sub	r11,r11,16406
  assert(currentJoypad >= 0);
80003cd6:	c0 87       	brpl	80003ce6 <cpuMemory_joypad_reader+0x2a>
80003cd8:	48 e9       	lddpc	r9,80003d10 <cpuMemory_joypad_reader+0x54>
80003cda:	48 ba       	lddpc	r10,80003d04 <cpuMemory_joypad_reader+0x48>
80003cdc:	e0 6b 00 d9 	mov	r11,217
80003ce0:	48 ac       	lddpc	r12,80003d08 <cpuMemory_joypad_reader+0x4c>
80003ce2:	f0 1f 00 0b 	mcall	80003d0c <cpuMemory_joypad_reader+0x50>
  assert(currentJoypad <= 3);
80003ce6:	58 3b       	cp.w	r11,3
80003ce8:	e0 8a 00 09 	brle	80003cfa <cpuMemory_joypad_reader+0x3e>
80003cec:	48 a9       	lddpc	r9,80003d14 <cpuMemory_joypad_reader+0x58>
80003cee:	48 6a       	lddpc	r10,80003d04 <cpuMemory_joypad_reader+0x48>
80003cf0:	e0 6b 00 da 	mov	r11,218
80003cf4:	48 5c       	lddpc	r12,80003d08 <cpuMemory_joypad_reader+0x4c>
80003cf6:	f0 1f 00 06 	mcall	80003d0c <cpuMemory_joypad_reader+0x50>
  return nes_readJoypad(nes, currentJoypad);
80003cfa:	f0 1f 00 08 	mcall	80003d18 <cpuMemory_joypad_reader+0x5c>
}
80003cfe:	d8 02       	popm	pc
80003d00:	80 01       	ld.sh	r1,r0[0x0]
80003d02:	31 44       	mov	r4,20
80003d04:	80 01       	ld.sh	r1,r0[0x0]
80003d06:	42 d4       	lddsp	r4,sp[0xb4]
80003d08:	80 01       	ld.sh	r1,r0[0x0]
80003d0a:	40 d0       	lddsp	r0,sp[0x34]
80003d0c:	80 00       	ld.sh	r0,r0[0x0]
80003d0e:	c1 a0       	breq	80003d42 <cpuMemory_ppuMirror_reader+0x26>
80003d10:	80 01       	ld.sh	r1,r0[0x0]
80003d12:	41 18       	lddsp	r8,sp[0x44]
80003d14:	80 01       	ld.sh	r1,r0[0x0]
80003d16:	41 2c       	lddsp	r12,sp[0x48]
80003d18:	80 00       	ld.sh	r0,r0[0x0]
80003d1a:	55 34       	stdsp	sp[0x14c],r4

80003d1c <cpuMemory_ppuMirror_reader>:
  address = cpuMemory_ppuMirror_getLowestAddress(address);
  Memory cpuMemory = nes_getCPUMemory(nes);
  assert(cpuMemory != NULL);
  memory_write_callback(nes, cpuMemory, address, data);
}
static Byte cpuMemory_ppuMirror_reader(NES nes, Address address) {
80003d1c:	eb cd 40 c0 	pushm	r6-r7,lr
80003d20:	18 97       	mov	r7,r12
  address = cpuMemory_ppuMirror_getLowestAddress(address);
80003d22:	f9 db c0 10 	bfextu	r12,r11,0x0,0x10
80003d26:	f0 1f 00 0c 	mcall	80003d54 <cpuMemory_ppuMirror_reader+0x38>
80003d2a:	ed dc b0 10 	bfexts	r6,r12,0x0,0x10
  Memory cpuMemory = nes_getCPUMemory(nes);
80003d2e:	0e 9c       	mov	r12,r7
80003d30:	f0 1f 00 0a 	mcall	80003d58 <cpuMemory_ppuMirror_reader+0x3c>
  assert(cpuMemory != NULL);
80003d34:	c0 71       	brne	80003d42 <cpuMemory_ppuMirror_reader+0x26>
80003d36:	48 a9       	lddpc	r9,80003d5c <cpuMemory_ppuMirror_reader+0x40>
80003d38:	48 aa       	lddpc	r10,80003d60 <cpuMemory_ppuMirror_reader+0x44>
80003d3a:	33 8b       	mov	r11,56
80003d3c:	48 ac       	lddpc	r12,80003d64 <cpuMemory_ppuMirror_reader+0x48>
80003d3e:	f0 1f 00 0b 	mcall	80003d68 <cpuMemory_ppuMirror_reader+0x4c>
  Byte data = memory_read_callback(nes, cpuMemory, address);
80003d42:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80003d46:	18 9b       	mov	r11,r12
80003d48:	0e 9c       	mov	r12,r7
80003d4a:	f0 1f 00 09 	mcall	80003d6c <cpuMemory_ppuMirror_reader+0x50>
  return data;
}
80003d4e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003d52:	00 00       	add	r0,r0
80003d54:	80 00       	ld.sh	r0,r0[0x0]
80003d56:	39 c8       	mov	r8,-100
80003d58:	80 00       	ld.sh	r0,r0[0x0]
80003d5a:	50 c0       	stdsp	sp[0x30],r0
80003d5c:	80 01       	ld.sh	r1,r0[0x0]
80003d5e:	41 40       	lddsp	r0,sp[0x50]
80003d60:	80 01       	ld.sh	r1,r0[0x0]
80003d62:	40 b4       	lddsp	r4,sp[0x2c]
80003d64:	80 01       	ld.sh	r1,r0[0x0]
80003d66:	40 d0       	lddsp	r0,sp[0x34]
80003d68:	80 00       	ld.sh	r0,r0[0x0]
80003d6a:	c1 a0       	breq	80003d9e <cpuMemory_ramMirror_reader+0x2e>
80003d6c:	80 00       	ld.sh	r0,r0[0x0]
80003d6e:	48 40       	lddpc	r0,80003d7c <cpuMemory_ramMirror_reader+0xc>

80003d70 <cpuMemory_ramMirror_reader>:
  address = cpuMemory_ramMirror_getLowestAddress(address);
  Memory cpuMemory = nes_getCPUMemory(nes);
  assert(cpuMemory != NULL);
  memory_write_callback(nes, cpuMemory, address, data);
}
static Byte cpuMemory_ramMirror_reader(NES nes, Address address) {
80003d70:	eb cd 40 c0 	pushm	r6-r7,lr
80003d74:	18 97       	mov	r7,r12
  // Memory locations $0000-$07FF are mirrored three times at $0800-$1FFF.
  // This means that, for example, any data written to $0000 will also be written to$0800, $1000 and $1800.
  address = cpuMemory_ramMirror_getLowestAddress(address);
80003d76:	f9 db c0 10 	bfextu	r12,r11,0x0,0x10
80003d7a:	f0 1f 00 0c 	mcall	80003da8 <cpuMemory_ramMirror_reader+0x38>
80003d7e:	ed dc b0 10 	bfexts	r6,r12,0x0,0x10
  Memory cpuMemory = nes_getCPUMemory(nes);
80003d82:	0e 9c       	mov	r12,r7
80003d84:	f0 1f 00 0a 	mcall	80003dac <cpuMemory_ramMirror_reader+0x3c>
  assert(cpuMemory != NULL);
80003d88:	c0 71       	brne	80003d96 <cpuMemory_ramMirror_reader+0x26>
80003d8a:	48 a9       	lddpc	r9,80003db0 <cpuMemory_ramMirror_reader+0x40>
80003d8c:	48 aa       	lddpc	r10,80003db4 <cpuMemory_ramMirror_reader+0x44>
80003d8e:	32 2b       	mov	r11,34
80003d90:	48 ac       	lddpc	r12,80003db8 <cpuMemory_ramMirror_reader+0x48>
80003d92:	f0 1f 00 0b 	mcall	80003dbc <cpuMemory_ramMirror_reader+0x4c>
  Byte data = memory_read_callback(nes, cpuMemory, address);
80003d96:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80003d9a:	18 9b       	mov	r11,r12
80003d9c:	0e 9c       	mov	r12,r7
80003d9e:	f0 1f 00 09 	mcall	80003dc0 <cpuMemory_ramMirror_reader+0x50>
  return data;
}
80003da2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003da6:	00 00       	add	r0,r0
80003da8:	80 00       	ld.sh	r0,r0[0x0]
80003daa:	3a 20       	mov	r0,-94
80003dac:	80 00       	ld.sh	r0,r0[0x0]
80003dae:	50 c0       	stdsp	sp[0x30],r0
80003db0:	80 01       	ld.sh	r1,r0[0x0]
80003db2:	41 40       	lddsp	r0,sp[0x50]
80003db4:	80 01       	ld.sh	r1,r0[0x0]
80003db6:	3f dc       	mov	r12,-3
80003db8:	80 01       	ld.sh	r1,r0[0x0]
80003dba:	40 d0       	lddsp	r0,sp[0x34]
80003dbc:	80 00       	ld.sh	r0,r0[0x0]
80003dbe:	c1 a0       	breq	80003df2 <cpuMemory_spriteDMARegister_writer+0x2e>
80003dc0:	80 00       	ld.sh	r0,r0[0x0]
80003dc2:	48 40       	lddpc	r0,80003dd0 <cpuMemory_spriteDMARegister_writer+0xc>

80003dc4 <cpuMemory_spriteDMARegister_writer>:
#define CPU_DMA_ADDRESS_MULTIPLIER 0x0100
static Byte cpuMemory_spriteDMARegister_reader(NES nes, Address address) {
  assert(nes != NULL);
  return 0;
}
static void cpuMemory_spriteDMARegister_writer(NES nes, Address address, Byte data) {
80003dc4:	eb cd 40 fc 	pushm	r2-r7,lr
80003dc8:	18 96       	mov	r6,r12
  assert(nes != NULL);
80003dca:	58 0c       	cp.w	r12,0
80003dcc:	c0 81       	brne	80003ddc <cpuMemory_spriteDMARegister_writer+0x18>
80003dce:	49 f9       	lddpc	r9,80003e48 <cpuMemory_spriteDMARegister_writer+0x84>
80003dd0:	49 fa       	lddpc	r10,80003e4c <cpuMemory_spriteDMARegister_writer+0x88>
80003dd2:	e0 6b 00 c4 	mov	r11,196
80003dd6:	49 fc       	lddpc	r12,80003e50 <cpuMemory_spriteDMARegister_writer+0x8c>
80003dd8:	f0 1f 00 1f 	mcall	80003e54 <cpuMemory_spriteDMARegister_writer+0x90>
  Address readAddress = data * CPU_DMA_ADDRESS_MULTIPLIER;
80003ddc:	f4 04 15 08 	lsl	r4,r10,0x8
80003de0:	5c 84       	casts.h	r4
  Address offset;
  Memory cpuMemory = nes_getCPUMemory(nes);
80003de2:	f0 1f 00 1e 	mcall	80003e58 <cpuMemory_spriteDMARegister_writer+0x94>
80003de6:	18 93       	mov	r3,r12
  assert(cpuMemory != NULL);
80003de8:	c0 81       	brne	80003df8 <cpuMemory_spriteDMARegister_writer+0x34>
80003dea:	49 d9       	lddpc	r9,80003e5c <cpuMemory_spriteDMARegister_writer+0x98>
80003dec:	49 8a       	lddpc	r10,80003e4c <cpuMemory_spriteDMARegister_writer+0x88>
80003dee:	e0 6b 00 c8 	mov	r11,200
80003df2:	49 8c       	lddpc	r12,80003e50 <cpuMemory_spriteDMARegister_writer+0x8c>
80003df4:	f0 1f 00 18 	mcall	80003e54 <cpuMemory_spriteDMARegister_writer+0x90>
  Memory objectAttributeMemory = nes_getObjectAttributeMemory(nes);
80003df8:	0c 9c       	mov	r12,r6
80003dfa:	f0 1f 00 1a 	mcall	80003e60 <cpuMemory_spriteDMARegister_writer+0x9c>
80003dfe:	18 92       	mov	r2,r12
  assert(objectAttributeMemory != NULL);
80003e00:	c0 81       	brne	80003e10 <cpuMemory_spriteDMARegister_writer+0x4c>
80003e02:	49 99       	lddpc	r9,80003e64 <cpuMemory_spriteDMARegister_writer+0xa0>
80003e04:	49 2a       	lddpc	r10,80003e4c <cpuMemory_spriteDMARegister_writer+0x88>
80003e06:	e0 6b 00 ca 	mov	r11,202
80003e0a:	49 2c       	lddpc	r12,80003e50 <cpuMemory_spriteDMARegister_writer+0x8c>
80003e0c:	f0 1f 00 12 	mcall	80003e54 <cpuMemory_spriteDMARegister_writer+0x90>
80003e10:	30 07       	mov	r7,0
  for (offset=0; offset < OAM_NUM_ADDRESSES; offset++) {
    Byte data = memory_read_callback(nes, cpuMemory, readAddress + offset);
80003e12:	0e 9a       	mov	r10,r7
80003e14:	08 0a       	add	r10,r4
80003e16:	5c 7a       	castu.h	r10
80003e18:	06 9b       	mov	r11,r3
80003e1a:	0c 9c       	mov	r12,r6
80003e1c:	f0 1f 00 13 	mcall	80003e68 <cpuMemory_spriteDMARegister_writer+0xa4>
80003e20:	18 95       	mov	r5,r12
    nes_cpuCycled(nes);
80003e22:	0c 9c       	mov	r12,r6
80003e24:	f0 1f 00 12 	mcall	80003e6c <cpuMemory_spriteDMARegister_writer+0xa8>
    memory_write_callback(nes, objectAttributeMemory, offset, data);
80003e28:	0a 99       	mov	r9,r5
80003e2a:	0e 9a       	mov	r10,r7
80003e2c:	04 9b       	mov	r11,r2
80003e2e:	0c 9c       	mov	r12,r6
80003e30:	f0 1f 00 10 	mcall	80003e70 <cpuMemory_spriteDMARegister_writer+0xac>
    nes_cpuCycled(nes);
80003e34:	0c 9c       	mov	r12,r6
80003e36:	f0 1f 00 0e 	mcall	80003e6c <cpuMemory_spriteDMARegister_writer+0xa8>
80003e3a:	2f f7       	sub	r7,-1
  Address offset;
  Memory cpuMemory = nes_getCPUMemory(nes);
  assert(cpuMemory != NULL);
  Memory objectAttributeMemory = nes_getObjectAttributeMemory(nes);
  assert(objectAttributeMemory != NULL);
  for (offset=0; offset < OAM_NUM_ADDRESSES; offset++) {
80003e3c:	e0 47 01 00 	cp.w	r7,256
80003e40:	ce 91       	brne	80003e12 <cpuMemory_spriteDMARegister_writer+0x4e>
    Byte data = memory_read_callback(nes, cpuMemory, readAddress + offset);
    nes_cpuCycled(nes);
    memory_write_callback(nes, objectAttributeMemory, offset, data);
    nes_cpuCycled(nes);
  }
}
80003e42:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80003e46:	00 00       	add	r0,r0
80003e48:	80 01       	ld.sh	r1,r0[0x0]
80003e4a:	31 44       	mov	r4,20
80003e4c:	80 01       	ld.sh	r1,r0[0x0]
80003e4e:	42 10       	lddsp	r0,sp[0x84]
80003e50:	80 01       	ld.sh	r1,r0[0x0]
80003e52:	40 d0       	lddsp	r0,sp[0x34]
80003e54:	80 00       	ld.sh	r0,r0[0x0]
80003e56:	c1 a0       	breq	80003e8a <cpuMemory_ppuMirror_writer+0x16>
80003e58:	80 00       	ld.sh	r0,r0[0x0]
80003e5a:	50 c0       	stdsp	sp[0x30],r0
80003e5c:	80 01       	ld.sh	r1,r0[0x0]
80003e5e:	41 40       	lddsp	r0,sp[0x50]
80003e60:	80 00       	ld.sh	r0,r0[0x0]
80003e62:	51 28       	stdsp	sp[0x48],r8
80003e64:	80 01       	ld.sh	r1,r0[0x0]
80003e66:	41 54       	lddsp	r4,sp[0x54]
80003e68:	80 00       	ld.sh	r0,r0[0x0]
80003e6a:	48 40       	lddpc	r0,80003e78 <cpuMemory_ppuMirror_writer+0x4>
80003e6c:	80 00       	ld.sh	r0,r0[0x0]
80003e6e:	51 64       	stdsp	sp[0x58],r4
80003e70:	80 00       	ld.sh	r0,r0[0x0]
80003e72:	48 d0       	lddpc	r0,80003ea4 <cpuMemory_ppuMirror_writer+0x30>

80003e74 <cpuMemory_ppuMirror_writer>:
    address -= CPU_PPU_MIRRORED_SIZE;
  }
  assert(address <= CPU_GENUINE_PPU_LAST_ADDRESS);
  return address;
}
static void cpuMemory_ppuMirror_writer(NES nes, Address address, Byte data) {
80003e74:	eb cd 40 e0 	pushm	r5-r7,lr
80003e78:	18 97       	mov	r7,r12
80003e7a:	14 95       	mov	r5,r10
  address = cpuMemory_ppuMirror_getLowestAddress(address);
80003e7c:	f9 db c0 10 	bfextu	r12,r11,0x0,0x10
80003e80:	f0 1f 00 0c 	mcall	80003eb0 <cpuMemory_ppuMirror_writer+0x3c>
80003e84:	ed dc b0 10 	bfexts	r6,r12,0x0,0x10
  Memory cpuMemory = nes_getCPUMemory(nes);
80003e88:	0e 9c       	mov	r12,r7
80003e8a:	f0 1f 00 0b 	mcall	80003eb4 <cpuMemory_ppuMirror_writer+0x40>
  assert(cpuMemory != NULL);
80003e8e:	c0 71       	brne	80003e9c <cpuMemory_ppuMirror_writer+0x28>
80003e90:	48 a9       	lddpc	r9,80003eb8 <cpuMemory_ppuMirror_writer+0x44>
80003e92:	48 ba       	lddpc	r10,80003ebc <cpuMemory_ppuMirror_writer+0x48>
80003e94:	33 2b       	mov	r11,50
80003e96:	48 bc       	lddpc	r12,80003ec0 <cpuMemory_ppuMirror_writer+0x4c>
80003e98:	f0 1f 00 0b 	mcall	80003ec4 <cpuMemory_ppuMirror_writer+0x50>
  memory_write_callback(nes, cpuMemory, address, data);
80003e9c:	0a 99       	mov	r9,r5
80003e9e:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80003ea2:	18 9b       	mov	r11,r12
80003ea4:	0e 9c       	mov	r12,r7
80003ea6:	f0 1f 00 09 	mcall	80003ec8 <cpuMemory_ppuMirror_writer+0x54>
}
80003eaa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003eae:	00 00       	add	r0,r0
80003eb0:	80 00       	ld.sh	r0,r0[0x0]
80003eb2:	39 c8       	mov	r8,-100
80003eb4:	80 00       	ld.sh	r0,r0[0x0]
80003eb6:	50 c0       	stdsp	sp[0x30],r0
80003eb8:	80 01       	ld.sh	r1,r0[0x0]
80003eba:	41 40       	lddsp	r0,sp[0x50]
80003ebc:	80 01       	ld.sh	r1,r0[0x0]
80003ebe:	41 a4       	lddsp	r4,sp[0x68]
80003ec0:	80 01       	ld.sh	r1,r0[0x0]
80003ec2:	40 d0       	lddsp	r0,sp[0x34]
80003ec4:	80 00       	ld.sh	r0,r0[0x0]
80003ec6:	c1 a0       	breq	80003efa <cpuMemory_ramMirror_writer+0x2e>
80003ec8:	80 00       	ld.sh	r0,r0[0x0]
80003eca:	48 d0       	lddpc	r0,80003efc <cpuMemory_ramMirror_writer+0x30>

80003ecc <cpuMemory_ramMirror_writer>:
    address -= CPU_RAM_MIRRORED_SIZE;
  }
  assert(address <= CPU_GENUINE_RAM_LAST_ADDRESS);
  return address;
}
static void cpuMemory_ramMirror_writer(NES nes, Address address, Byte data) {
80003ecc:	eb cd 40 e0 	pushm	r5-r7,lr
80003ed0:	18 97       	mov	r7,r12
80003ed2:	14 95       	mov	r5,r10
  // Memory locations $0000-$07FF are mirrored three times at $0800-$1FFF.
  // This means that, for example, any data written to $0000 will also be written to$0800, $1000 and $1800.
  address = cpuMemory_ramMirror_getLowestAddress(address);
80003ed4:	f9 db c0 10 	bfextu	r12,r11,0x0,0x10
80003ed8:	f0 1f 00 0c 	mcall	80003f08 <cpuMemory_ramMirror_writer+0x3c>
80003edc:	ed dc b0 10 	bfexts	r6,r12,0x0,0x10
  Memory cpuMemory = nes_getCPUMemory(nes);
80003ee0:	0e 9c       	mov	r12,r7
80003ee2:	f0 1f 00 0b 	mcall	80003f0c <cpuMemory_ramMirror_writer+0x40>
  assert(cpuMemory != NULL);
80003ee6:	c0 71       	brne	80003ef4 <cpuMemory_ramMirror_writer+0x28>
80003ee8:	48 a9       	lddpc	r9,80003f10 <cpuMemory_ramMirror_writer+0x44>
80003eea:	48 ba       	lddpc	r10,80003f14 <cpuMemory_ramMirror_writer+0x48>
80003eec:	31 ab       	mov	r11,26
80003eee:	48 bc       	lddpc	r12,80003f18 <cpuMemory_ramMirror_writer+0x4c>
80003ef0:	f0 1f 00 0b 	mcall	80003f1c <cpuMemory_ramMirror_writer+0x50>
  memory_write_callback(nes, cpuMemory, address, data);
80003ef4:	0a 99       	mov	r9,r5
80003ef6:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80003efa:	18 9b       	mov	r11,r12
80003efc:	0e 9c       	mov	r12,r7
80003efe:	f0 1f 00 09 	mcall	80003f20 <cpuMemory_ramMirror_writer+0x54>
}
80003f02:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003f06:	00 00       	add	r0,r0
80003f08:	80 00       	ld.sh	r0,r0[0x0]
80003f0a:	3a 20       	mov	r0,-94
80003f0c:	80 00       	ld.sh	r0,r0[0x0]
80003f0e:	50 c0       	stdsp	sp[0x30],r0
80003f10:	80 01       	ld.sh	r1,r0[0x0]
80003f12:	41 40       	lddsp	r0,sp[0x50]
80003f14:	80 01       	ld.sh	r1,r0[0x0]
80003f16:	3f 68       	mov	r8,-10
80003f18:	80 01       	ld.sh	r1,r0[0x0]
80003f1a:	40 d0       	lddsp	r0,sp[0x34]
80003f1c:	80 00       	ld.sh	r0,r0[0x0]
80003f1e:	c1 a0       	breq	80003f52 <cpuMemory_ppuMemoryDataRegister_writer+0x2e>
80003f20:	80 00       	ld.sh	r0,r0[0x0]
80003f22:	48 d0       	lddpc	r0,80003f54 <cpuMemory_ppuMemoryDataRegister_writer+0x30>

80003f24 <cpuMemory_ppuMemoryDataRegister_writer>:
  PPU ppu = nes_getPPU(nes);
  assert(ppu != NULL);
  return ppu_getPPUMemoryDataRegister(nes);
}
static void cpuMemory_ppuMemoryDataRegister_writer(NES nes, Address address, Byte data)
{
80003f24:	eb cd 40 c0 	pushm	r6-r7,lr
80003f28:	18 97       	mov	r7,r12
80003f2a:	14 96       	mov	r6,r10
  assert(nes != NULL);
80003f2c:	58 0c       	cp.w	r12,0
80003f2e:	c0 81       	brne	80003f3e <cpuMemory_ppuMemoryDataRegister_writer+0x1a>
80003f30:	48 c9       	lddpc	r9,80003f60 <cpuMemory_ppuMemoryDataRegister_writer+0x3c>
80003f32:	48 da       	lddpc	r10,80003f64 <cpuMemory_ppuMemoryDataRegister_writer+0x40>
80003f34:	e0 6b 00 b6 	mov	r11,182
80003f38:	48 cc       	lddpc	r12,80003f68 <cpuMemory_ppuMemoryDataRegister_writer+0x44>
80003f3a:	f0 1f 00 0d 	mcall	80003f6c <cpuMemory_ppuMemoryDataRegister_writer+0x48>
  PPU ppu = nes_getPPU(nes);
80003f3e:	f0 1f 00 0d 	mcall	80003f70 <cpuMemory_ppuMemoryDataRegister_writer+0x4c>
  assert(ppu != NULL);
80003f42:	c0 81       	brne	80003f52 <cpuMemory_ppuMemoryDataRegister_writer+0x2e>
80003f44:	48 c9       	lddpc	r9,80003f74 <cpuMemory_ppuMemoryDataRegister_writer+0x50>
80003f46:	48 8a       	lddpc	r10,80003f64 <cpuMemory_ppuMemoryDataRegister_writer+0x40>
80003f48:	e0 6b 00 b8 	mov	r11,184
80003f4c:	48 7c       	lddpc	r12,80003f68 <cpuMemory_ppuMemoryDataRegister_writer+0x44>
80003f4e:	f0 1f 00 08 	mcall	80003f6c <cpuMemory_ppuMemoryDataRegister_writer+0x48>
  ppu_setPPUMemoryDataRegister(nes, data);
80003f52:	0c 9b       	mov	r11,r6
80003f54:	0e 9c       	mov	r12,r7
80003f56:	f0 1f 00 09 	mcall	80003f78 <cpuMemory_ppuMemoryDataRegister_writer+0x54>
}
80003f5a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003f5e:	00 00       	add	r0,r0
80003f60:	80 01       	ld.sh	r1,r0[0x0]
80003f62:	31 44       	mov	r4,20
80003f64:	80 01       	ld.sh	r1,r0[0x0]
80003f66:	40 8c       	lddsp	r12,sp[0x20]
80003f68:	80 01       	ld.sh	r1,r0[0x0]
80003f6a:	40 d0       	lddsp	r0,sp[0x34]
80003f6c:	80 00       	ld.sh	r0,r0[0x0]
80003f6e:	c1 a0       	breq	80003fa2 <cpuMemory_ppuMemoryDataRegister_reader+0x26>
80003f70:	80 00       	ld.sh	r0,r0[0x0]
80003f72:	50 48       	stdsp	sp[0x10],r8
80003f74:	80 01       	ld.sh	r1,r0[0x0]
80003f76:	41 74       	lddsp	r4,sp[0x5c]
80003f78:	80 00       	ld.sh	r0,r0[0x0]
80003f7a:	61 78       	ld.w	r8,r0[0x5c]

80003f7c <cpuMemory_ppuMemoryDataRegister_reader>:
  ppu_setPPUMemoryAddressRegister(ppu, data);
}
////////////////////////////////////////////////////////////////////////////////////////
///
// #define CPU_PPUMEMORY_DATA_REGISTER_ADDRESS             0x2007 // read/write
static Byte cpuMemory_ppuMemoryDataRegister_reader(NES nes, Address address) {
80003f7c:	eb cd 40 80 	pushm	r7,lr
80003f80:	18 97       	mov	r7,r12
  assert(nes != NULL);
80003f82:	58 0c       	cp.w	r12,0
80003f84:	c0 81       	brne	80003f94 <cpuMemory_ppuMemoryDataRegister_reader+0x18>
80003f86:	48 c9       	lddpc	r9,80003fb4 <cpuMemory_ppuMemoryDataRegister_reader+0x38>
80003f88:	48 ca       	lddpc	r10,80003fb8 <cpuMemory_ppuMemoryDataRegister_reader+0x3c>
80003f8a:	e0 6b 00 af 	mov	r11,175
80003f8e:	48 cc       	lddpc	r12,80003fbc <cpuMemory_ppuMemoryDataRegister_reader+0x40>
80003f90:	f0 1f 00 0c 	mcall	80003fc0 <cpuMemory_ppuMemoryDataRegister_reader+0x44>
  PPU ppu = nes_getPPU(nes);
80003f94:	f0 1f 00 0c 	mcall	80003fc4 <cpuMemory_ppuMemoryDataRegister_reader+0x48>
  assert(ppu != NULL);
80003f98:	c0 81       	brne	80003fa8 <cpuMemory_ppuMemoryDataRegister_reader+0x2c>
80003f9a:	48 c9       	lddpc	r9,80003fc8 <cpuMemory_ppuMemoryDataRegister_reader+0x4c>
80003f9c:	48 7a       	lddpc	r10,80003fb8 <cpuMemory_ppuMemoryDataRegister_reader+0x3c>
80003f9e:	e0 6b 00 b1 	mov	r11,177
80003fa2:	48 7c       	lddpc	r12,80003fbc <cpuMemory_ppuMemoryDataRegister_reader+0x40>
80003fa4:	f0 1f 00 07 	mcall	80003fc0 <cpuMemory_ppuMemoryDataRegister_reader+0x44>
  return ppu_getPPUMemoryDataRegister(nes);
80003fa8:	0e 9c       	mov	r12,r7
80003faa:	f0 1f 00 09 	mcall	80003fcc <cpuMemory_ppuMemoryDataRegister_reader+0x50>
}
80003fae:	e3 cd 80 80 	ldm	sp++,r7,pc
80003fb2:	00 00       	add	r0,r0
80003fb4:	80 01       	ld.sh	r1,r0[0x0]
80003fb6:	31 44       	mov	r4,20
80003fb8:	80 01       	ld.sh	r1,r0[0x0]
80003fba:	3f f8       	mov	r8,-1
80003fbc:	80 01       	ld.sh	r1,r0[0x0]
80003fbe:	40 d0       	lddsp	r0,sp[0x34]
80003fc0:	80 00       	ld.sh	r0,r0[0x0]
80003fc2:	c1 a0       	breq	80003ff6 <cpuMemory_ppuMemoryAddressRegister_writer+0x26>
80003fc4:	80 00       	ld.sh	r0,r0[0x0]
80003fc6:	50 48       	stdsp	sp[0x10],r8
80003fc8:	80 01       	ld.sh	r1,r0[0x0]
80003fca:	41 74       	lddsp	r4,sp[0x5c]
80003fcc:	80 00       	ld.sh	r0,r0[0x0]
80003fce:	60 00       	ld.w	r0,r0[0x0]

80003fd0 <cpuMemory_ppuMemoryAddressRegister_writer>:
  PPU ppu = nes_getPPU(nes);
  assert(ppu != NULL);
  return ppu_getPPUMemoryAddressRegister(ppu);
}
static void cpuMemory_ppuMemoryAddressRegister_writer(NES nes, Address address, Byte
data) {
80003fd0:	eb cd 40 80 	pushm	r7,lr
80003fd4:	14 97       	mov	r7,r10
  assert(nes != NULL);
80003fd6:	58 0c       	cp.w	r12,0
80003fd8:	c0 81       	brne	80003fe8 <cpuMemory_ppuMemoryAddressRegister_writer+0x18>
80003fda:	48 c9       	lddpc	r9,80004008 <cpuMemory_ppuMemoryAddressRegister_writer+0x38>
80003fdc:	48 ca       	lddpc	r10,8000400c <cpuMemory_ppuMemoryAddressRegister_writer+0x3c>
80003fde:	e0 6b 00 a6 	mov	r11,166
80003fe2:	48 cc       	lddpc	r12,80004010 <cpuMemory_ppuMemoryAddressRegister_writer+0x40>
80003fe4:	f0 1f 00 0c 	mcall	80004014 <cpuMemory_ppuMemoryAddressRegister_writer+0x44>
  PPU ppu = nes_getPPU(nes);
80003fe8:	f0 1f 00 0c 	mcall	80004018 <cpuMemory_ppuMemoryAddressRegister_writer+0x48>
  assert(ppu != NULL);
80003fec:	c0 81       	brne	80003ffc <cpuMemory_ppuMemoryAddressRegister_writer+0x2c>
80003fee:	48 c9       	lddpc	r9,8000401c <cpuMemory_ppuMemoryAddressRegister_writer+0x4c>
80003ff0:	48 7a       	lddpc	r10,8000400c <cpuMemory_ppuMemoryAddressRegister_writer+0x3c>
80003ff2:	e0 6b 00 a8 	mov	r11,168
80003ff6:	48 7c       	lddpc	r12,80004010 <cpuMemory_ppuMemoryAddressRegister_writer+0x40>
80003ff8:	f0 1f 00 07 	mcall	80004014 <cpuMemory_ppuMemoryAddressRegister_writer+0x44>
  ppu_setPPUMemoryAddressRegister(ppu, data);
80003ffc:	0e 9b       	mov	r11,r7
80003ffe:	f0 1f 00 09 	mcall	80004020 <cpuMemory_ppuMemoryAddressRegister_writer+0x50>
}
80004002:	e3 cd 80 80 	ldm	sp++,r7,pc
80004006:	00 00       	add	r0,r0
80004008:	80 01       	ld.sh	r1,r0[0x0]
8000400a:	31 44       	mov	r4,20
8000400c:	80 01       	ld.sh	r1,r0[0x0]
8000400e:	41 e4       	lddsp	r4,sp[0x78]
80004010:	80 01       	ld.sh	r1,r0[0x0]
80004012:	40 d0       	lddsp	r0,sp[0x34]
80004014:	80 00       	ld.sh	r0,r0[0x0]
80004016:	c1 a0       	breq	8000404a <cpuMemory_ppuMemoryAddressRegister_reader+0x26>
80004018:	80 00       	ld.sh	r0,r0[0x0]
8000401a:	50 48       	stdsp	sp[0x10],r8
8000401c:	80 01       	ld.sh	r1,r0[0x0]
8000401e:	41 74       	lddsp	r4,sp[0x5c]
80004020:	80 00       	ld.sh	r0,r0[0x0]
80004022:	5c f0       	rol	r0

80004024 <cpuMemory_ppuMemoryAddressRegister_reader>:
  ppu_setScrollRegister(ppu, data);
}
////////////////////////////////////////////////////////////////////////////////////////
///
// #define CPU_PPUMEMORY_ADDRESS_REGISTER_ADDRESS          0x2006 // write
static Byte cpuMemory_ppuMemoryAddressRegister_reader(NES nes, Address address) {
80004024:	d4 01       	pushm	lr
  assert(nes != NULL);
80004026:	58 0c       	cp.w	r12,0
80004028:	c0 81       	brne	80004038 <cpuMemory_ppuMemoryAddressRegister_reader+0x14>
8000402a:	48 b9       	lddpc	r9,80004054 <cpuMemory_ppuMemoryAddressRegister_reader+0x30>
8000402c:	48 ba       	lddpc	r10,80004058 <cpuMemory_ppuMemoryAddressRegister_reader+0x34>
8000402e:	e0 6b 00 9f 	mov	r11,159
80004032:	48 bc       	lddpc	r12,8000405c <cpuMemory_ppuMemoryAddressRegister_reader+0x38>
80004034:	f0 1f 00 0b 	mcall	80004060 <cpuMemory_ppuMemoryAddressRegister_reader+0x3c>
  PPU ppu = nes_getPPU(nes);
80004038:	f0 1f 00 0b 	mcall	80004064 <cpuMemory_ppuMemoryAddressRegister_reader+0x40>
  assert(ppu != NULL);
8000403c:	c0 81       	brne	8000404c <cpuMemory_ppuMemoryAddressRegister_reader+0x28>
8000403e:	48 b9       	lddpc	r9,80004068 <cpuMemory_ppuMemoryAddressRegister_reader+0x44>
80004040:	48 6a       	lddpc	r10,80004058 <cpuMemory_ppuMemoryAddressRegister_reader+0x34>
80004042:	e0 6b 00 a1 	mov	r11,161
80004046:	48 6c       	lddpc	r12,8000405c <cpuMemory_ppuMemoryAddressRegister_reader+0x38>
80004048:	f0 1f 00 06 	mcall	80004060 <cpuMemory_ppuMemoryAddressRegister_reader+0x3c>
  return ppu_getPPUMemoryAddressRegister(ppu);
8000404c:	f0 1f 00 08 	mcall	8000406c <cpuMemory_ppuMemoryAddressRegister_reader+0x48>
}
80004050:	d8 02       	popm	pc
80004052:	00 00       	add	r0,r0
80004054:	80 01       	ld.sh	r1,r0[0x0]
80004056:	31 44       	mov	r4,20
80004058:	80 01       	ld.sh	r1,r0[0x0]
8000405a:	42 34       	lddsp	r4,sp[0x8c]
8000405c:	80 01       	ld.sh	r1,r0[0x0]
8000405e:	40 d0       	lddsp	r0,sp[0x34]
80004060:	80 00       	ld.sh	r0,r0[0x0]
80004062:	c1 a0       	breq	80004096 <cpuMemory_ppuScrollRegister_writer+0x26>
80004064:	80 00       	ld.sh	r0,r0[0x0]
80004066:	50 48       	stdsp	sp[0x10],r8
80004068:	80 01       	ld.sh	r1,r0[0x0]
8000406a:	41 74       	lddsp	r4,sp[0x5c]
8000406c:	80 00       	ld.sh	r0,r0[0x0]
8000406e:	5e 00       	reteq	r0

80004070 <cpuMemory_ppuScrollRegister_writer>:
  assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
  assert(ppu != NULL);
  return ppu_getScrollRegister(ppu);
}
static void cpuMemory_ppuScrollRegister_writer(NES nes, Address address, Byte data) {
80004070:	eb cd 40 80 	pushm	r7,lr
80004074:	14 97       	mov	r7,r10
  assert(nes != NULL);
80004076:	58 0c       	cp.w	r12,0
80004078:	c0 81       	brne	80004088 <cpuMemory_ppuScrollRegister_writer+0x18>
8000407a:	48 c9       	lddpc	r9,800040a8 <cpuMemory_ppuScrollRegister_writer+0x38>
8000407c:	48 ca       	lddpc	r10,800040ac <cpuMemory_ppuScrollRegister_writer+0x3c>
8000407e:	e0 6b 00 96 	mov	r11,150
80004082:	48 cc       	lddpc	r12,800040b0 <cpuMemory_ppuScrollRegister_writer+0x40>
80004084:	f0 1f 00 0c 	mcall	800040b4 <cpuMemory_ppuScrollRegister_writer+0x44>
  PPU ppu = nes_getPPU(nes);
80004088:	f0 1f 00 0c 	mcall	800040b8 <cpuMemory_ppuScrollRegister_writer+0x48>
  assert(ppu != NULL);
8000408c:	c0 81       	brne	8000409c <cpuMemory_ppuScrollRegister_writer+0x2c>
8000408e:	48 c9       	lddpc	r9,800040bc <cpuMemory_ppuScrollRegister_writer+0x4c>
80004090:	48 7a       	lddpc	r10,800040ac <cpuMemory_ppuScrollRegister_writer+0x3c>
80004092:	e0 6b 00 98 	mov	r11,152
80004096:	48 7c       	lddpc	r12,800040b0 <cpuMemory_ppuScrollRegister_writer+0x40>
80004098:	f0 1f 00 07 	mcall	800040b4 <cpuMemory_ppuScrollRegister_writer+0x44>
  ppu_setScrollRegister(ppu, data);
8000409c:	0e 9b       	mov	r11,r7
8000409e:	f0 1f 00 09 	mcall	800040c0 <cpuMemory_ppuScrollRegister_writer+0x50>
}
800040a2:	e3 cd 80 80 	ldm	sp++,r7,pc
800040a6:	00 00       	add	r0,r0
800040a8:	80 01       	ld.sh	r1,r0[0x0]
800040aa:	31 44       	mov	r4,20
800040ac:	80 01       	ld.sh	r1,r0[0x0]
800040ae:	40 44       	lddsp	r4,sp[0x10]
800040b0:	80 01       	ld.sh	r1,r0[0x0]
800040b2:	40 d0       	lddsp	r0,sp[0x34]
800040b4:	80 00       	ld.sh	r0,r0[0x0]
800040b6:	c1 a0       	breq	800040ea <cpuMemory_ppuScrollRegister_reader+0x26>
800040b8:	80 00       	ld.sh	r0,r0[0x0]
800040ba:	50 48       	stdsp	sp[0x10],r8
800040bc:	80 01       	ld.sh	r1,r0[0x0]
800040be:	41 74       	lddsp	r4,sp[0x5c]
800040c0:	80 00       	ld.sh	r0,r0[0x0]
800040c2:	5d 3c       	musfr	r12

800040c4 <cpuMemory_ppuScrollRegister_reader>:
  ppu_setSpriteDataRegister(nes, data);
}
////////////////////////////////////////////////////////////////////////////////////////
///
// #define CPU_PPU_SCROLL_REGISTER_ADDRESS                 0x2005 // write
static Byte cpuMemory_ppuScrollRegister_reader(NES nes, Address address) {
800040c4:	d4 01       	pushm	lr
  assert(nes != NULL);
800040c6:	58 0c       	cp.w	r12,0
800040c8:	c0 81       	brne	800040d8 <cpuMemory_ppuScrollRegister_reader+0x14>
800040ca:	48 b9       	lddpc	r9,800040f4 <cpuMemory_ppuScrollRegister_reader+0x30>
800040cc:	48 ba       	lddpc	r10,800040f8 <cpuMemory_ppuScrollRegister_reader+0x34>
800040ce:	e0 6b 00 90 	mov	r11,144
800040d2:	48 bc       	lddpc	r12,800040fc <cpuMemory_ppuScrollRegister_reader+0x38>
800040d4:	f0 1f 00 0b 	mcall	80004100 <cpuMemory_ppuScrollRegister_reader+0x3c>
  PPU ppu = nes_getPPU(nes);
800040d8:	f0 1f 00 0b 	mcall	80004104 <cpuMemory_ppuScrollRegister_reader+0x40>
  assert(ppu != NULL);
800040dc:	c0 81       	brne	800040ec <cpuMemory_ppuScrollRegister_reader+0x28>
800040de:	48 b9       	lddpc	r9,80004108 <cpuMemory_ppuScrollRegister_reader+0x44>
800040e0:	48 6a       	lddpc	r10,800040f8 <cpuMemory_ppuScrollRegister_reader+0x34>
800040e2:	e0 6b 00 92 	mov	r11,146
800040e6:	48 6c       	lddpc	r12,800040fc <cpuMemory_ppuScrollRegister_reader+0x38>
800040e8:	f0 1f 00 06 	mcall	80004100 <cpuMemory_ppuScrollRegister_reader+0x3c>
  return ppu_getScrollRegister(ppu);
800040ec:	f0 1f 00 08 	mcall	8000410c <cpuMemory_ppuScrollRegister_reader+0x48>
}
800040f0:	d8 02       	popm	pc
800040f2:	00 00       	add	r0,r0
800040f4:	80 01       	ld.sh	r1,r0[0x0]
800040f6:	31 44       	mov	r4,20
800040f8:	80 01       	ld.sh	r1,r0[0x0]
800040fa:	3f 94       	mov	r4,-7
800040fc:	80 01       	ld.sh	r1,r0[0x0]
800040fe:	40 d0       	lddsp	r0,sp[0x34]
80004100:	80 00       	ld.sh	r0,r0[0x0]
80004102:	c1 a0       	breq	80004136 <cpuMemory_ppuSpriteDataRegister_writer+0x26>
80004104:	80 00       	ld.sh	r0,r0[0x0]
80004106:	50 48       	stdsp	sp[0x10],r8
80004108:	80 01       	ld.sh	r1,r0[0x0]
8000410a:	41 74       	lddsp	r4,sp[0x5c]
8000410c:	80 00       	ld.sh	r0,r0[0x0]
8000410e:	5e 28       	reths	r8

80004110 <cpuMemory_ppuSpriteDataRegister_writer>:
  PPU ppu = nes_getPPU(nes);
  assert(ppu != NULL);
  return ppu_getSpriteDataRegister(nes);
}
static void cpuMemory_ppuSpriteDataRegister_writer(NES nes, Address address, Byte data)
{
80004110:	eb cd 40 c0 	pushm	r6-r7,lr
80004114:	18 97       	mov	r7,r12
80004116:	14 96       	mov	r6,r10
  assert(nes != NULL);
80004118:	58 0c       	cp.w	r12,0
8000411a:	c0 81       	brne	8000412a <cpuMemory_ppuSpriteDataRegister_writer+0x1a>
8000411c:	48 c9       	lddpc	r9,8000414c <cpuMemory_ppuSpriteDataRegister_writer+0x3c>
8000411e:	48 da       	lddpc	r10,80004150 <cpuMemory_ppuSpriteDataRegister_writer+0x40>
80004120:	e0 6b 00 87 	mov	r11,135
80004124:	48 cc       	lddpc	r12,80004154 <cpuMemory_ppuSpriteDataRegister_writer+0x44>
80004126:	f0 1f 00 0d 	mcall	80004158 <cpuMemory_ppuSpriteDataRegister_writer+0x48>
  PPU ppu = nes_getPPU(nes);
8000412a:	f0 1f 00 0d 	mcall	8000415c <cpuMemory_ppuSpriteDataRegister_writer+0x4c>
  assert(ppu != NULL);
8000412e:	c0 81       	brne	8000413e <cpuMemory_ppuSpriteDataRegister_writer+0x2e>
80004130:	48 c9       	lddpc	r9,80004160 <cpuMemory_ppuSpriteDataRegister_writer+0x50>
80004132:	48 8a       	lddpc	r10,80004150 <cpuMemory_ppuSpriteDataRegister_writer+0x40>
80004134:	e0 6b 00 89 	mov	r11,137
80004138:	48 7c       	lddpc	r12,80004154 <cpuMemory_ppuSpriteDataRegister_writer+0x44>
8000413a:	f0 1f 00 08 	mcall	80004158 <cpuMemory_ppuSpriteDataRegister_writer+0x48>
  ppu_setSpriteDataRegister(nes, data);
8000413e:	0c 9b       	mov	r11,r6
80004140:	0e 9c       	mov	r12,r7
80004142:	f0 1f 00 09 	mcall	80004164 <cpuMemory_ppuSpriteDataRegister_writer+0x54>
}
80004146:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000414a:	00 00       	add	r0,r0
8000414c:	80 01       	ld.sh	r1,r0[0x0]
8000414e:	31 44       	mov	r4,20
80004150:	80 01       	ld.sh	r1,r0[0x0]
80004152:	3f 28       	mov	r8,-14
80004154:	80 01       	ld.sh	r1,r0[0x0]
80004156:	40 d0       	lddsp	r0,sp[0x34]
80004158:	80 00       	ld.sh	r0,r0[0x0]
8000415a:	c1 a0       	breq	8000418e <cpuMemory_ppuSpriteDataRegister_reader+0x26>
8000415c:	80 00       	ld.sh	r0,r0[0x0]
8000415e:	50 48       	stdsp	sp[0x10],r8
80004160:	80 01       	ld.sh	r1,r0[0x0]
80004162:	41 74       	lddsp	r4,sp[0x5c]
80004164:	80 00       	ld.sh	r0,r0[0x0]
80004166:	61 e8       	ld.w	r8,r0[0x78]

80004168 <cpuMemory_ppuSpriteDataRegister_reader>:
  ppu_setSpriteAddressRegister(ppu, data);
}
////////////////////////////////////////////////////////////////////////////////////////
///
// #define CPU_PPU_SPRITE_DATA_REGISTER_ADDRESS            0x2004 // write
static Byte cpuMemory_ppuSpriteDataRegister_reader(NES nes, Address address) {
80004168:	eb cd 40 80 	pushm	r7,lr
8000416c:	18 97       	mov	r7,r12
  assert(nes != NULL);
8000416e:	58 0c       	cp.w	r12,0
80004170:	c0 81       	brne	80004180 <cpuMemory_ppuSpriteDataRegister_reader+0x18>
80004172:	48 c9       	lddpc	r9,800041a0 <cpuMemory_ppuSpriteDataRegister_reader+0x38>
80004174:	48 ca       	lddpc	r10,800041a4 <cpuMemory_ppuSpriteDataRegister_reader+0x3c>
80004176:	e0 6b 00 80 	mov	r11,128
8000417a:	48 cc       	lddpc	r12,800041a8 <cpuMemory_ppuSpriteDataRegister_reader+0x40>
8000417c:	f0 1f 00 0c 	mcall	800041ac <cpuMemory_ppuSpriteDataRegister_reader+0x44>
  PPU ppu = nes_getPPU(nes);
80004180:	f0 1f 00 0c 	mcall	800041b0 <cpuMemory_ppuSpriteDataRegister_reader+0x48>
  assert(ppu != NULL);
80004184:	c0 81       	brne	80004194 <cpuMemory_ppuSpriteDataRegister_reader+0x2c>
80004186:	48 c9       	lddpc	r9,800041b4 <cpuMemory_ppuSpriteDataRegister_reader+0x4c>
80004188:	48 7a       	lddpc	r10,800041a4 <cpuMemory_ppuSpriteDataRegister_reader+0x3c>
8000418a:	e0 6b 00 82 	mov	r11,130
8000418e:	48 7c       	lddpc	r12,800041a8 <cpuMemory_ppuSpriteDataRegister_reader+0x40>
80004190:	f0 1f 00 07 	mcall	800041ac <cpuMemory_ppuSpriteDataRegister_reader+0x44>
  return ppu_getSpriteDataRegister(nes);
80004194:	0e 9c       	mov	r12,r7
80004196:	f0 1f 00 09 	mcall	800041b8 <cpuMemory_ppuSpriteDataRegister_reader+0x50>
}
8000419a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000419e:	00 00       	add	r0,r0
800041a0:	80 01       	ld.sh	r1,r0[0x0]
800041a2:	31 44       	mov	r4,20
800041a4:	80 01       	ld.sh	r1,r0[0x0]
800041a6:	42 ec       	lddsp	r12,sp[0xb8]
800041a8:	80 01       	ld.sh	r1,r0[0x0]
800041aa:	40 d0       	lddsp	r0,sp[0x34]
800041ac:	80 00       	ld.sh	r0,r0[0x0]
800041ae:	c1 a0       	breq	800041e2 <cpuMemory_ppuSpriteAddressRegister_writer+0x26>
800041b0:	80 00       	ld.sh	r0,r0[0x0]
800041b2:	50 48       	stdsp	sp[0x10],r8
800041b4:	80 01       	ld.sh	r1,r0[0x0]
800041b6:	41 74       	lddsp	r4,sp[0x5c]
800041b8:	80 00       	ld.sh	r0,r0[0x0]
800041ba:	62 48       	ld.w	r8,r1[0x10]

800041bc <cpuMemory_ppuSpriteAddressRegister_writer>:
  PPU ppu = nes_getPPU(nes);
  assert(ppu != NULL);
  return ppu_getSpriteAddressRegister(ppu);
}
static void cpuMemory_ppuSpriteAddressRegister_writer(NES nes, Address address, Byte
data) {
800041bc:	eb cd 40 80 	pushm	r7,lr
800041c0:	14 97       	mov	r7,r10
  assert(nes != NULL);
800041c2:	58 0c       	cp.w	r12,0
800041c4:	c0 71       	brne	800041d2 <cpuMemory_ppuSpriteAddressRegister_writer+0x16>
800041c6:	48 b9       	lddpc	r9,800041f0 <cpuMemory_ppuSpriteAddressRegister_writer+0x34>
800041c8:	48 ba       	lddpc	r10,800041f4 <cpuMemory_ppuSpriteAddressRegister_writer+0x38>
800041ca:	37 7b       	mov	r11,119
800041cc:	48 bc       	lddpc	r12,800041f8 <cpuMemory_ppuSpriteAddressRegister_writer+0x3c>
800041ce:	f0 1f 00 0c 	mcall	800041fc <cpuMemory_ppuSpriteAddressRegister_writer+0x40>
  PPU ppu = nes_getPPU(nes);
800041d2:	f0 1f 00 0c 	mcall	80004200 <cpuMemory_ppuSpriteAddressRegister_writer+0x44>
  assert(ppu != NULL);
800041d6:	c0 71       	brne	800041e4 <cpuMemory_ppuSpriteAddressRegister_writer+0x28>
800041d8:	48 b9       	lddpc	r9,80004204 <cpuMemory_ppuSpriteAddressRegister_writer+0x48>
800041da:	48 7a       	lddpc	r10,800041f4 <cpuMemory_ppuSpriteAddressRegister_writer+0x38>
800041dc:	37 9b       	mov	r11,121
800041de:	48 7c       	lddpc	r12,800041f8 <cpuMemory_ppuSpriteAddressRegister_writer+0x3c>
800041e0:	f0 1f 00 07 	mcall	800041fc <cpuMemory_ppuSpriteAddressRegister_writer+0x40>
  ppu_setSpriteAddressRegister(ppu, data);
800041e4:	0e 9b       	mov	r11,r7
800041e6:	f0 1f 00 09 	mcall	80004208 <cpuMemory_ppuSpriteAddressRegister_writer+0x4c>
}
800041ea:	e3 cd 80 80 	ldm	sp++,r7,pc
800041ee:	00 00       	add	r0,r0
800041f0:	80 01       	ld.sh	r1,r0[0x0]
800041f2:	31 44       	mov	r4,20
800041f4:	80 01       	ld.sh	r1,r0[0x0]
800041f6:	42 84       	lddsp	r4,sp[0xa0]
800041f8:	80 01       	ld.sh	r1,r0[0x0]
800041fa:	40 d0       	lddsp	r0,sp[0x34]
800041fc:	80 00       	ld.sh	r0,r0[0x0]
800041fe:	c1 a0       	breq	80004232 <cpuMemory_ppuSpriteAddressRegister_reader+0x26>
80004200:	80 00       	ld.sh	r0,r0[0x0]
80004202:	50 48       	stdsp	sp[0x10],r8
80004204:	80 01       	ld.sh	r1,r0[0x0]
80004206:	41 74       	lddsp	r4,sp[0x5c]
80004208:	80 00       	ld.sh	r0,r0[0x0]
8000420a:	5d 88       	*unknown*

8000420c <cpuMemory_ppuSpriteAddressRegister_reader>:
  assert(FALSE);
}
////////////////////////////////////////////////////////////////////////////////////////
///
// #define CPU_PPU_SPRITE_ADDRESS_REGISTER_ADDRESS         0x2003 // write
static Byte cpuMemory_ppuSpriteAddressRegister_reader(NES nes, Address address) {
8000420c:	d4 01       	pushm	lr
  assert(nes != NULL);
8000420e:	58 0c       	cp.w	r12,0
80004210:	c0 71       	brne	8000421e <cpuMemory_ppuSpriteAddressRegister_reader+0x12>
80004212:	48 a9       	lddpc	r9,80004238 <cpuMemory_ppuSpriteAddressRegister_reader+0x2c>
80004214:	48 aa       	lddpc	r10,8000423c <cpuMemory_ppuSpriteAddressRegister_reader+0x30>
80004216:	37 0b       	mov	r11,112
80004218:	48 ac       	lddpc	r12,80004240 <cpuMemory_ppuSpriteAddressRegister_reader+0x34>
8000421a:	f0 1f 00 0b 	mcall	80004244 <cpuMemory_ppuSpriteAddressRegister_reader+0x38>
  PPU ppu = nes_getPPU(nes);
8000421e:	f0 1f 00 0b 	mcall	80004248 <cpuMemory_ppuSpriteAddressRegister_reader+0x3c>
  assert(ppu != NULL);
80004222:	c0 71       	brne	80004230 <cpuMemory_ppuSpriteAddressRegister_reader+0x24>
80004224:	48 a9       	lddpc	r9,8000424c <cpuMemory_ppuSpriteAddressRegister_reader+0x40>
80004226:	48 6a       	lddpc	r10,8000423c <cpuMemory_ppuSpriteAddressRegister_reader+0x30>
80004228:	37 2b       	mov	r11,114
8000422a:	48 6c       	lddpc	r12,80004240 <cpuMemory_ppuSpriteAddressRegister_reader+0x34>
8000422c:	f0 1f 00 06 	mcall	80004244 <cpuMemory_ppuSpriteAddressRegister_reader+0x38>
  return ppu_getSpriteAddressRegister(ppu);
80004230:	f0 1f 00 08 	mcall	80004250 <cpuMemory_ppuSpriteAddressRegister_reader+0x44>
}
80004234:	d8 02       	popm	pc
80004236:	00 00       	add	r0,r0
80004238:	80 01       	ld.sh	r1,r0[0x0]
8000423a:	31 44       	mov	r4,20
8000423c:	80 01       	ld.sh	r1,r0[0x0]
8000423e:	3e fc       	mov	r12,-17
80004240:	80 01       	ld.sh	r1,r0[0x0]
80004242:	40 d0       	lddsp	r0,sp[0x34]
80004244:	80 00       	ld.sh	r0,r0[0x0]
80004246:	c1 a0       	breq	8000427a <cpuMemory_ppuStatusRegister_reader+0x26>
80004248:	80 00       	ld.sh	r0,r0[0x0]
8000424a:	50 48       	stdsp	sp[0x10],r8
8000424c:	80 01       	ld.sh	r1,r0[0x0]
8000424e:	41 74       	lddsp	r4,sp[0x5c]
80004250:	80 00       	ld.sh	r0,r0[0x0]
80004252:	5e 50       	retlt	r0

80004254 <cpuMemory_ppuStatusRegister_reader>:
  ppu_setMaskRegister(ppu, data);
}
////////////////////////////////////////////////////////////////////////////////////////
///
// #define CPU_PPU_STATUS_REGISTER_ADDRESS                 0x2002 // read
static Byte cpuMemory_ppuStatusRegister_reader(NES nes, Address address) {
80004254:	d4 01       	pushm	lr
  assert(nes != NULL);
80004256:	58 0c       	cp.w	r12,0
80004258:	c0 71       	brne	80004266 <cpuMemory_ppuStatusRegister_reader+0x12>
8000425a:	48 a9       	lddpc	r9,80004280 <cpuMemory_ppuStatusRegister_reader+0x2c>
8000425c:	48 aa       	lddpc	r10,80004284 <cpuMemory_ppuStatusRegister_reader+0x30>
8000425e:	36 2b       	mov	r11,98
80004260:	48 ac       	lddpc	r12,80004288 <cpuMemory_ppuStatusRegister_reader+0x34>
80004262:	f0 1f 00 0b 	mcall	8000428c <cpuMemory_ppuStatusRegister_reader+0x38>
  PPU ppu = nes_getPPU(nes);
80004266:	f0 1f 00 0b 	mcall	80004290 <cpuMemory_ppuStatusRegister_reader+0x3c>
  assert(ppu != NULL);
8000426a:	c0 71       	brne	80004278 <cpuMemory_ppuStatusRegister_reader+0x24>
8000426c:	48 a9       	lddpc	r9,80004294 <cpuMemory_ppuStatusRegister_reader+0x40>
8000426e:	48 6a       	lddpc	r10,80004284 <cpuMemory_ppuStatusRegister_reader+0x30>
80004270:	36 4b       	mov	r11,100
80004272:	48 6c       	lddpc	r12,80004288 <cpuMemory_ppuStatusRegister_reader+0x34>
80004274:	f0 1f 00 06 	mcall	8000428c <cpuMemory_ppuStatusRegister_reader+0x38>
  return ppu_getStatusRegister(ppu);
80004278:	f0 1f 00 08 	mcall	80004298 <cpuMemory_ppuStatusRegister_reader+0x44>
}
8000427c:	d8 02       	popm	pc
8000427e:	00 00       	add	r0,r0
80004280:	80 01       	ld.sh	r1,r0[0x0]
80004282:	31 44       	mov	r4,20
80004284:	80 01       	ld.sh	r1,r0[0x0]
80004286:	42 b0       	lddsp	r0,sp[0xac]
80004288:	80 01       	ld.sh	r1,r0[0x0]
8000428a:	40 d0       	lddsp	r0,sp[0x34]
8000428c:	80 00       	ld.sh	r0,r0[0x0]
8000428e:	c1 a0       	breq	800042c2 <cpuMemory_ppuMaskRegister_writer+0x26>
80004290:	80 00       	ld.sh	r0,r0[0x0]
80004292:	50 48       	stdsp	sp[0x10],r8
80004294:	80 01       	ld.sh	r1,r0[0x0]
80004296:	41 74       	lddsp	r4,sp[0x5c]
80004298:	80 00       	ld.sh	r0,r0[0x0]
8000429a:	5e 78       	retpl	r8

8000429c <cpuMemory_ppuMaskRegister_writer>:
  // assert(FALSE);
  PPU ppu = nes_getPPU(nes);
  assert(ppu != NULL);
  return ppu_getMaskRegister(ppu);
}
static void cpuMemory_ppuMaskRegister_writer(NES nes, Address address, Byte data) {
8000429c:	eb cd 40 80 	pushm	r7,lr
800042a0:	14 97       	mov	r7,r10
  assert(nes != NULL);
800042a2:	58 0c       	cp.w	r12,0
800042a4:	c0 71       	brne	800042b2 <cpuMemory_ppuMaskRegister_writer+0x16>
800042a6:	48 b9       	lddpc	r9,800042d0 <cpuMemory_ppuMaskRegister_writer+0x34>
800042a8:	48 ba       	lddpc	r10,800042d4 <cpuMemory_ppuMaskRegister_writer+0x38>
800042aa:	35 9b       	mov	r11,89
800042ac:	48 bc       	lddpc	r12,800042d8 <cpuMemory_ppuMaskRegister_writer+0x3c>
800042ae:	f0 1f 00 0c 	mcall	800042dc <cpuMemory_ppuMaskRegister_writer+0x40>
  PPU ppu = nes_getPPU(nes);
800042b2:	f0 1f 00 0c 	mcall	800042e0 <cpuMemory_ppuMaskRegister_writer+0x44>
  assert(ppu != NULL);
800042b6:	c0 71       	brne	800042c4 <cpuMemory_ppuMaskRegister_writer+0x28>
800042b8:	48 b9       	lddpc	r9,800042e4 <cpuMemory_ppuMaskRegister_writer+0x48>
800042ba:	48 7a       	lddpc	r10,800042d4 <cpuMemory_ppuMaskRegister_writer+0x38>
800042bc:	35 bb       	mov	r11,91
800042be:	48 7c       	lddpc	r12,800042d8 <cpuMemory_ppuMaskRegister_writer+0x3c>
800042c0:	f0 1f 00 07 	mcall	800042dc <cpuMemory_ppuMaskRegister_writer+0x40>
  ppu_setMaskRegister(ppu, data);
800042c4:	0e 9b       	mov	r11,r7
800042c6:	f0 1f 00 09 	mcall	800042e8 <cpuMemory_ppuMaskRegister_writer+0x4c>
}
800042ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800042ce:	00 00       	add	r0,r0
800042d0:	80 01       	ld.sh	r1,r0[0x0]
800042d2:	31 44       	mov	r4,20
800042d4:	80 01       	ld.sh	r1,r0[0x0]
800042d6:	42 60       	lddsp	r0,sp[0x98]
800042d8:	80 01       	ld.sh	r1,r0[0x0]
800042da:	40 d0       	lddsp	r0,sp[0x34]
800042dc:	80 00       	ld.sh	r0,r0[0x0]
800042de:	c1 a0       	breq	80004312 <cpuMemory_ppuMaskRegister_reader+0x26>
800042e0:	80 00       	ld.sh	r0,r0[0x0]
800042e2:	50 48       	stdsp	sp[0x10],r8
800042e4:	80 01       	ld.sh	r1,r0[0x0]
800042e6:	41 74       	lddsp	r4,sp[0x5c]
800042e8:	80 00       	ld.sh	r0,r0[0x0]
800042ea:	5d b0       	*unknown*

800042ec <cpuMemory_ppuMaskRegister_reader>:
  ppu_setControlRegister(ppu, data);
}
////////////////////////////////////////////////////////////////////////////////////////
///
// #define CPU_PPU_MASK_REGISTER_ADDRESS                   0x2001 // write
static Byte cpuMemory_ppuMaskRegister_reader(NES nes, Address address) {
800042ec:	d4 01       	pushm	lr
  assert(nes != NULL);
800042ee:	58 0c       	cp.w	r12,0
800042f0:	c0 71       	brne	800042fe <cpuMemory_ppuMaskRegister_reader+0x12>
800042f2:	48 a9       	lddpc	r9,80004318 <cpuMemory_ppuMaskRegister_reader+0x2c>
800042f4:	48 aa       	lddpc	r10,8000431c <cpuMemory_ppuMaskRegister_reader+0x30>
800042f6:	35 1b       	mov	r11,81
800042f8:	48 ac       	lddpc	r12,80004320 <cpuMemory_ppuMaskRegister_reader+0x34>
800042fa:	f0 1f 00 0b 	mcall	80004324 <cpuMemory_ppuMaskRegister_reader+0x38>
  // not allowed to read this
  // assert(FALSE);
  PPU ppu = nes_getPPU(nes);
800042fe:	f0 1f 00 0b 	mcall	80004328 <cpuMemory_ppuMaskRegister_reader+0x3c>
  assert(ppu != NULL);
80004302:	c0 71       	brne	80004310 <cpuMemory_ppuMaskRegister_reader+0x24>
80004304:	48 a9       	lddpc	r9,8000432c <cpuMemory_ppuMaskRegister_reader+0x40>
80004306:	48 6a       	lddpc	r10,8000431c <cpuMemory_ppuMaskRegister_reader+0x30>
80004308:	35 5b       	mov	r11,85
8000430a:	48 6c       	lddpc	r12,80004320 <cpuMemory_ppuMaskRegister_reader+0x34>
8000430c:	f0 1f 00 06 	mcall	80004324 <cpuMemory_ppuMaskRegister_reader+0x38>
  return ppu_getMaskRegister(ppu);
80004310:	f0 1f 00 08 	mcall	80004330 <cpuMemory_ppuMaskRegister_reader+0x44>
}
80004314:	d8 02       	popm	pc
80004316:	00 00       	add	r0,r0
80004318:	80 01       	ld.sh	r1,r0[0x0]
8000431a:	31 44       	mov	r4,20
8000431c:	80 01       	ld.sh	r1,r0[0x0]
8000431e:	41 c0       	lddsp	r0,sp[0x70]
80004320:	80 01       	ld.sh	r1,r0[0x0]
80004322:	40 d0       	lddsp	r0,sp[0x34]
80004324:	80 00       	ld.sh	r0,r0[0x0]
80004326:	c1 a0       	breq	8000435a <cpuMemory_ppuControlRegister_writer+0x26>
80004328:	80 00       	ld.sh	r0,r0[0x0]
8000432a:	50 48       	stdsp	sp[0x10],r8
8000432c:	80 01       	ld.sh	r1,r0[0x0]
8000432e:	41 74       	lddsp	r4,sp[0x5c]
80004330:	80 00       	ld.sh	r0,r0[0x0]
80004332:	5e b8       	rethi	r8

80004334 <cpuMemory_ppuControlRegister_writer>:
  // assert(FALSE);
  PPU ppu = nes_getPPU(nes);
  assert(ppu != NULL);
  return ppu_getControlRegister(ppu);
}
static void cpuMemory_ppuControlRegister_writer(NES nes, Address address, Byte data) {
80004334:	eb cd 40 80 	pushm	r7,lr
80004338:	14 97       	mov	r7,r10
  assert(nes != NULL);
8000433a:	58 0c       	cp.w	r12,0
8000433c:	c0 71       	brne	8000434a <cpuMemory_ppuControlRegister_writer+0x16>
8000433e:	48 b9       	lddpc	r9,80004368 <cpuMemory_ppuControlRegister_writer+0x34>
80004340:	48 ba       	lddpc	r10,8000436c <cpuMemory_ppuControlRegister_writer+0x38>
80004342:	34 8b       	mov	r11,72
80004344:	48 bc       	lddpc	r12,80004370 <cpuMemory_ppuControlRegister_writer+0x3c>
80004346:	f0 1f 00 0c 	mcall	80004374 <cpuMemory_ppuControlRegister_writer+0x40>
  PPU ppu = nes_getPPU(nes);
8000434a:	f0 1f 00 0c 	mcall	80004378 <cpuMemory_ppuControlRegister_writer+0x44>
  assert(ppu != NULL);
8000434e:	c0 71       	brne	8000435c <cpuMemory_ppuControlRegister_writer+0x28>
80004350:	48 b9       	lddpc	r9,8000437c <cpuMemory_ppuControlRegister_writer+0x48>
80004352:	48 7a       	lddpc	r10,8000436c <cpuMemory_ppuControlRegister_writer+0x38>
80004354:	34 ab       	mov	r11,74
80004356:	48 7c       	lddpc	r12,80004370 <cpuMemory_ppuControlRegister_writer+0x3c>
80004358:	f0 1f 00 07 	mcall	80004374 <cpuMemory_ppuControlRegister_writer+0x40>
  ppu_setControlRegister(ppu, data);
8000435c:	0e 9b       	mov	r11,r7
8000435e:	f0 1f 00 09 	mcall	80004380 <cpuMemory_ppuControlRegister_writer+0x4c>
}
80004362:	e3 cd 80 80 	ldm	sp++,r7,pc
80004366:	00 00       	add	r0,r0
80004368:	80 01       	ld.sh	r1,r0[0x0]
8000436a:	31 44       	mov	r4,20
8000436c:	80 01       	ld.sh	r1,r0[0x0]
8000436e:	41 80       	lddsp	r0,sp[0x60]
80004370:	80 01       	ld.sh	r1,r0[0x0]
80004372:	40 d0       	lddsp	r0,sp[0x34]
80004374:	80 00       	ld.sh	r0,r0[0x0]
80004376:	c1 a0       	breq	800043aa <cpuMemory_ppuControlRegister_reader+0x26>
80004378:	80 00       	ld.sh	r0,r0[0x0]
8000437a:	50 48       	stdsp	sp[0x10],r8
8000437c:	80 01       	ld.sh	r1,r0[0x0]
8000437e:	41 74       	lddsp	r4,sp[0x5c]
80004380:	80 00       	ld.sh	r0,r0[0x0]
80004382:	5d d8       	*unknown*

80004384 <cpuMemory_ppuControlRegister_reader>:
  return data;
}
////////////////////////////////////////////////////////////////////////////////////////
///
// #define CPU_PPU_CONTROL_REGISTER_ADDRESS                0x2000 // write
static Byte cpuMemory_ppuControlRegister_reader(NES nes, Address address) {
80004384:	d4 01       	pushm	lr
  assert(nes != NULL);
80004386:	58 0c       	cp.w	r12,0
80004388:	c0 71       	brne	80004396 <cpuMemory_ppuControlRegister_reader+0x12>
8000438a:	48 a9       	lddpc	r9,800043b0 <cpuMemory_ppuControlRegister_reader+0x2c>
8000438c:	48 aa       	lddpc	r10,800043b4 <cpuMemory_ppuControlRegister_reader+0x30>
8000438e:	34 0b       	mov	r11,64
80004390:	48 ac       	lddpc	r12,800043b8 <cpuMemory_ppuControlRegister_reader+0x34>
80004392:	f0 1f 00 0b 	mcall	800043bc <cpuMemory_ppuControlRegister_reader+0x38>
  // not allowed to read this
  // assert(FALSE);
  PPU ppu = nes_getPPU(nes);
80004396:	f0 1f 00 0b 	mcall	800043c0 <cpuMemory_ppuControlRegister_reader+0x3c>
  assert(ppu != NULL);
8000439a:	c0 71       	brne	800043a8 <cpuMemory_ppuControlRegister_reader+0x24>
8000439c:	48 a9       	lddpc	r9,800043c4 <cpuMemory_ppuControlRegister_reader+0x40>
8000439e:	48 6a       	lddpc	r10,800043b4 <cpuMemory_ppuControlRegister_reader+0x30>
800043a0:	34 4b       	mov	r11,68
800043a2:	48 6c       	lddpc	r12,800043b8 <cpuMemory_ppuControlRegister_reader+0x34>
800043a4:	f0 1f 00 06 	mcall	800043bc <cpuMemory_ppuControlRegister_reader+0x38>
  return ppu_getControlRegister(ppu);
800043a8:	f0 1f 00 08 	mcall	800043c8 <cpuMemory_ppuControlRegister_reader+0x44>
}
800043ac:	d8 02       	popm	pc
800043ae:	00 00       	add	r0,r0
800043b0:	80 01       	ld.sh	r1,r0[0x0]
800043b2:	31 44       	mov	r4,20
800043b4:	80 01       	ld.sh	r1,r0[0x0]
800043b6:	40 68       	lddsp	r8,sp[0x18]
800043b8:	80 01       	ld.sh	r1,r0[0x0]
800043ba:	40 d0       	lddsp	r0,sp[0x34]
800043bc:	80 00       	ld.sh	r0,r0[0x0]
800043be:	c1 a0       	breq	800043f2 <gui_isButtonPressed+0x22>
800043c0:	80 00       	ld.sh	r0,r0[0x0]
800043c2:	50 48       	stdsp	sp[0x10],r8
800043c4:	80 01       	ld.sh	r1,r0[0x0]
800043c6:	41 74       	lddsp	r4,sp[0x5c]
800043c8:	80 00       	ld.sh	r0,r0[0x0]
800043ca:	5e e0       	retqs	r0

800043cc <debug_printf>:
  char logBuffer[LOG_LINE_LENGTH];
  vsnprintf(logBuffer,LOG_LINE_LENGTH-1,format,arg);
  fprintf(stderr,logBuffer,LOG_LINE_LENGTH);
  va_end (arg);
#endif
800043cc:	5e fc       	retal	r12
800043ce:	d7 03       	nop

800043d0 <gui_isButtonPressed>:
      }
    }
  }
  */
}
Bool gui_isButtonPressed(GUI gui, int joypad, Button button) {
800043d0:	d4 01       	pushm	lr
  assert(gui != NULL);
800043d2:	58 0c       	cp.w	r12,0
800043d4:	c0 81       	brne	800043e4 <gui_isButtonPressed+0x14>
800043d6:	49 69       	lddpc	r9,8000442c <gui_isButtonPressed+0x5c>
800043d8:	49 6a       	lddpc	r10,80004430 <gui_isButtonPressed+0x60>
800043da:	e0 6b 00 ae 	mov	r11,174
800043de:	49 6c       	lddpc	r12,80004434 <gui_isButtonPressed+0x64>
800043e0:	f0 1f 00 16 	mcall	80004438 <gui_isButtonPressed+0x68>
  assert(joypad >= 0);
800043e4:	58 0b       	cp.w	r11,0
800043e6:	c0 84       	brge	800043f6 <gui_isButtonPressed+0x26>
800043e8:	49 59       	lddpc	r9,8000443c <gui_isButtonPressed+0x6c>
800043ea:	49 2a       	lddpc	r10,80004430 <gui_isButtonPressed+0x60>
800043ec:	e0 6b 00 af 	mov	r11,175
800043f0:	49 1c       	lddpc	r12,80004434 <gui_isButtonPressed+0x64>
800043f2:	f0 1f 00 12 	mcall	80004438 <gui_isButtonPressed+0x68>
  assert(joypad <= GUI_MAX_JOYPADS);
800043f6:	58 4b       	cp.w	r11,4
800043f8:	e0 8a 00 09 	brle	8000440a <gui_isButtonPressed+0x3a>
800043fc:	49 19       	lddpc	r9,80004440 <gui_isButtonPressed+0x70>
800043fe:	48 da       	lddpc	r10,80004430 <gui_isButtonPressed+0x60>
80004400:	e0 6b 00 b0 	mov	r11,176
80004404:	48 cc       	lddpc	r12,80004434 <gui_isButtonPressed+0x64>
80004406:	f0 1f 00 0d 	mcall	80004438 <gui_isButtonPressed+0x68>
  assert(button >= 0);
  assert(button <= JOYPAD_NUM_BUTTONS);
8000440a:	58 8a       	cp.w	r10,8
8000440c:	e0 88 00 09 	brls	8000441e <gui_isButtonPressed+0x4e>
80004410:	48 d9       	lddpc	r9,80004444 <gui_isButtonPressed+0x74>
80004412:	48 8a       	lddpc	r10,80004430 <gui_isButtonPressed+0x60>
80004414:	e0 6b 00 b2 	mov	r11,178
80004418:	48 7c       	lddpc	r12,80004434 <gui_isButtonPressed+0x64>
8000441a:	f0 1f 00 08 	mcall	80004438 <gui_isButtonPressed+0x68>
8000441e:	f8 0b 00 3c 	add	r12,r12,r11<<0x3
80004422:	f8 0a 00 0a 	add	r10,r12,r10
  return gui->buttonState[joypad][button];
80004426:	f5 3c 00 0c 	ld.ub	r12,r10[12]
8000442a:	d8 02       	popm	pc
8000442c:	80 01       	ld.sh	r1,r0[0x0]
8000442e:	43 44       	lddsp	r4,sp[0xd0]
80004430:	80 01       	ld.sh	r1,r0[0x0]
80004432:	43 24       	lddsp	r4,sp[0xc8]
80004434:	80 01       	ld.sh	r1,r0[0x0]
80004436:	43 50       	lddsp	r0,sp[0xd4]
80004438:	80 00       	ld.sh	r0,r0[0x0]
8000443a:	c1 a0       	breq	8000446e <gui_receivedTerminationRequest+0x2>
8000443c:	80 01       	ld.sh	r1,r0[0x0]
8000443e:	43 64       	lddsp	r4,sp[0xd8]
80004440:	80 01       	ld.sh	r1,r0[0x0]
80004442:	43 70       	lddsp	r0,sp[0xdc]
80004444:	80 01       	ld.sh	r1,r0[0x0]
80004446:	43 8c       	lddsp	r12,sp[0xe0]

80004448 <gui_queryInput>:
}
void gui_destroy(GUI gui) {
  assert(gui != NULL);
  free(gui);
}
void gui_queryInput(GUI gui) {
80004448:	d4 01       	pushm	lr
  assert(gui != NULL);
8000444a:	58 0c       	cp.w	r12,0
8000444c:	c0 71       	brne	8000445a <gui_queryInput+0x12>
8000444e:	48 49       	lddpc	r9,8000445c <gui_queryInput+0x14>
80004450:	48 4a       	lddpc	r10,80004460 <gui_queryInput+0x18>
80004452:	36 ab       	mov	r11,106
80004454:	48 4c       	lddpc	r12,80004464 <gui_queryInput+0x1c>
80004456:	f0 1f 00 05 	mcall	80004468 <gui_queryInput+0x20>
8000445a:	d8 02       	popm	pc
8000445c:	80 01       	ld.sh	r1,r0[0x0]
8000445e:	43 44       	lddsp	r4,sp[0xd0]
80004460:	80 01       	ld.sh	r1,r0[0x0]
80004462:	43 14       	lddsp	r4,sp[0xc4]
80004464:	80 01       	ld.sh	r1,r0[0x0]
80004466:	43 50       	lddsp	r0,sp[0xd4]
80004468:	80 00       	ld.sh	r0,r0[0x0]
8000446a:	c1 a0       	breq	8000449e <gui_refresh+0xa>

8000446c <gui_receivedTerminationRequest>:
  gui->currentFrame = 0;
  gui->receivedTerminationRequest = FALSE;
  gui_resetButtonState(gui);
  return gui;
}
Bool gui_receivedTerminationRequest(GUI gui) {
8000446c:	d4 01       	pushm	lr
  assert(gui != NULL);
8000446e:	58 0c       	cp.w	r12,0
80004470:	c0 71       	brne	8000447e <gui_receivedTerminationRequest+0x12>
80004472:	48 59       	lddpc	r9,80004484 <gui_receivedTerminationRequest+0x18>
80004474:	48 5a       	lddpc	r10,80004488 <gui_receivedTerminationRequest+0x1c>
80004476:	36 2b       	mov	r11,98
80004478:	48 5c       	lddpc	r12,8000448c <gui_receivedTerminationRequest+0x20>
8000447a:	f0 1f 00 06 	mcall	80004490 <gui_receivedTerminationRequest+0x24>
  return gui->receivedTerminationRequest;
}
8000447e:	f9 3c 00 2c 	ld.ub	r12,r12[44]
80004482:	d8 02       	popm	pc
80004484:	80 01       	ld.sh	r1,r0[0x0]
80004486:	43 44       	lddsp	r4,sp[0xd0]
80004488:	80 01       	ld.sh	r1,r0[0x0]
8000448a:	43 e8       	lddsp	r8,sp[0xf8]
8000448c:	80 01       	ld.sh	r1,r0[0x0]
8000448e:	43 50       	lddsp	r0,sp[0xd4]
80004490:	80 00       	ld.sh	r0,r0[0x0]
80004492:	c1 a0       	breq	800044c6 <gui_init+0x6>

80004494 <gui_refresh>:
  *bufp = color;
  bufp = (Uint32 *)gui->screen->pixels + (((actualY)+1)*gui->screen->pitch/4) +
(actualX) + 1;
  *bufp = color;*/
}
void gui_refresh(GUI gui) {
80004494:	d4 01       	pushm	lr
  assert(gui != NULL);
80004496:	58 0c       	cp.w	r12,0
80004498:	c0 71       	brne	800044a6 <gui_refresh+0x12>
8000449a:	48 69       	lddpc	r9,800044b0 <gui_refresh+0x1c>
8000449c:	48 6a       	lddpc	r10,800044b4 <gui_refresh+0x20>
8000449e:	33 8b       	mov	r11,56
800044a0:	48 6c       	lddpc	r12,800044b8 <gui_refresh+0x24>
800044a2:	f0 1f 00 07 	mcall	800044bc <gui_refresh+0x28>
    char filename[100];
    sprintf(filename, "capture%03d.bmp", gui->currentFrame);
    SDL_SaveBMP(gui->screen,filename);
  }
  */
  gui->currentFrame++;
800044a6:	78 28       	ld.w	r8,r12[0x8]
800044a8:	2f f8       	sub	r8,-1
800044aa:	99 28       	st.w	r12[0x8],r8
  //SDL_Flip(gui->screen);
        //SDL_Delay(1000/60);
}
800044ac:	d8 02       	popm	pc
800044ae:	00 00       	add	r0,r0
800044b0:	80 01       	ld.sh	r1,r0[0x0]
800044b2:	43 44       	lddsp	r4,sp[0xd0]
800044b4:	80 01       	ld.sh	r1,r0[0x0]
800044b6:	43 38       	lddsp	r8,sp[0xcc]
800044b8:	80 01       	ld.sh	r1,r0[0x0]
800044ba:	43 50       	lddsp	r0,sp[0xd4]
800044bc:	80 00       	ld.sh	r0,r0[0x0]
800044be:	c1 a0       	breq	800044f2 <gui_init+0x32>

800044c0 <gui_init>:
    for (button=0; button < JOYPAD_NUM_BUTTONS; button++) {
      gui->buttonState[joypad][button] = 0;
    }
  }
}
GUI gui_init(int width, int height) {
800044c0:	eb cd 40 c0 	pushm	r6-r7,lr
800044c4:	18 96       	mov	r6,r12
800044c6:	16 97       	mov	r7,r11
  GUI gui = (GUI) malloc(sizeof(struct gui));
800044c8:	33 0c       	mov	r12,48
800044ca:	f0 1f 00 12 	mcall	80004510 <gui_init+0x50>
  assert(gui != NULL);
800044ce:	c0 71       	brne	800044dc <gui_init+0x1c>
800044d0:	49 19       	lddpc	r9,80004514 <gui_init+0x54>
800044d2:	49 2a       	lddpc	r10,80004518 <gui_init+0x58>
800044d4:	35 1b       	mov	r11,81
800044d6:	49 2c       	lddpc	r12,8000451c <gui_init+0x5c>
800044d8:	f0 1f 00 12 	mcall	80004520 <gui_init+0x60>
  //atexit(SDL_Quit);
  /*gui->screen=SDL_SetVideoMode(width * GUI_IMAGE_SCALE,height *
GUI_IMAGE_SCALE,32,SDL_HWSURFACE|SDL_DOUBLEBUF); //|SDL_FULLSCREEN);
  assert(gui->screen != NULL);
  */
  gui->width = width;
800044dc:	99 06       	st.w	r12[0x0],r6
  gui->height = height;
800044de:	99 17       	st.w	r12[0x4],r7
  gui->currentFrame = 0;
800044e0:	30 0b       	mov	r11,0
800044e2:	99 2b       	st.w	r12[0x8],r11
  gui->receivedTerminationRequest = FALSE;
800044e4:	f9 6b 00 2c 	st.b	r12[44],r11
        //SDL_Delay(1000/60);
}
static void gui_resetButtonState(GUI gui) {
  assert(gui != NULL);
  int joypad;
  for (joypad=0; joypad < GUI_MAX_JOYPADS; joypad++) {
800044e8:	16 97       	mov	r7,r11
    int button;
    for (button=0; button < JOYPAD_NUM_BUTTONS; button++) {
      gui->buttonState[joypad][button] = 0;
800044ea:	30 0a       	mov	r10,0
800044ec:	c0 88       	rjmp	800044fc <gui_init+0x3c>
800044ee:	12 ca       	st.b	r9++,r10
static void gui_resetButtonState(GUI gui) {
  assert(gui != NULL);
  int joypad;
  for (joypad=0; joypad < GUI_MAX_JOYPADS; joypad++) {
    int button;
    for (button=0; button < JOYPAD_NUM_BUTTONS; button++) {
800044f0:	2f f8       	sub	r8,-1
800044f2:	58 88       	cp.w	r8,8
800044f4:	cf d1       	brne	800044ee <gui_init+0x2e>
        //SDL_Delay(1000/60);
}
static void gui_resetButtonState(GUI gui) {
  assert(gui != NULL);
  int joypad;
  for (joypad=0; joypad < GUI_MAX_JOYPADS; joypad++) {
800044f6:	2f fb       	sub	r11,-1
800044f8:	58 4b       	cp.w	r11,4
800044fa:	c0 80       	breq	8000450a <gui_init+0x4a>
800044fc:	f6 09 15 03 	lsl	r9,r11,0x3
80004500:	2f 49       	sub	r9,-12
80004502:	f8 09 00 09 	add	r9,r12,r9
80004506:	0e 98       	mov	r8,r7
80004508:	cf 3b       	rjmp	800044ee <gui_init+0x2e>
  gui->height = height;
  gui->currentFrame = 0;
  gui->receivedTerminationRequest = FALSE;
  gui_resetButtonState(gui);
  return gui;
}
8000450a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000450e:	00 00       	add	r0,r0
80004510:	80 00       	ld.sh	r0,r0[0x0]
80004512:	c1 fc       	rcall	80004550 <gui_drawPixel+0x2c>
80004514:	80 01       	ld.sh	r1,r0[0x0]
80004516:	43 44       	lddsp	r4,sp[0xd0]
80004518:	80 01       	ld.sh	r1,r0[0x0]
8000451a:	43 cc       	lddsp	r12,sp[0xf0]
8000451c:	80 01       	ld.sh	r1,r0[0x0]
8000451e:	43 50       	lddsp	r0,sp[0xd4]
80004520:	80 00       	ld.sh	r0,r0[0x0]
80004522:	c1 a0       	breq	80004556 <gui_drawPixel+0x32>

80004524 <gui_drawPixel>:
}
int gui_getHeight(GUI gui) {
  assert(gui != NULL);
  return gui->height;
}
void gui_drawPixel(GUI gui, Byte x, Byte y, Byte red, Byte green, Byte blue) {
80004524:	eb cd 40 80 	pushm	r7,lr
80004528:	18 9e       	mov	lr,r12
8000452a:	40 27       	lddsp	r7,sp[0x8]
  assert(gui != NULL);
8000452c:	58 0c       	cp.w	r12,0
8000452e:	c0 71       	brne	8000453c <gui_drawPixel+0x18>
80004530:	49 29       	lddpc	r9,80004578 <gui_drawPixel+0x54>
80004532:	49 3a       	lddpc	r10,8000457c <gui_drawPixel+0x58>
80004534:	32 0b       	mov	r11,32
80004536:	49 3c       	lddpc	r12,80004580 <gui_drawPixel+0x5c>
80004538:	f0 1f 00 13 	mcall	80004584 <gui_drawPixel+0x60>
  //assert(gui->screen != NULL);
  assert(x < gui->width);    // Byte type is unsigned
8000453c:	16 9c       	mov	r12,r11
8000453e:	7c 0b       	ld.w	r11,lr[0x0]
80004540:	16 3c       	cp.w	r12,r11
80004542:	c0 75       	brlt	80004550 <gui_drawPixel+0x2c>
80004544:	49 19       	lddpc	r9,80004588 <gui_drawPixel+0x64>
80004546:	48 ea       	lddpc	r10,8000457c <gui_drawPixel+0x58>
80004548:	32 2b       	mov	r11,34
8000454a:	48 ec       	lddpc	r12,80004580 <gui_drawPixel+0x5c>
8000454c:	f0 1f 00 0e 	mcall	80004584 <gui_drawPixel+0x60>
  assert(y < gui->height);   // Byte type is unsigned
80004550:	14 9b       	mov	r11,r10
80004552:	7c 1a       	ld.w	r10,lr[0x4]
80004554:	14 3b       	cp.w	r11,r10
80004556:	c0 75       	brlt	80004564 <gui_drawPixel+0x40>
80004558:	48 d9       	lddpc	r9,8000458c <gui_drawPixel+0x68>
8000455a:	48 9a       	lddpc	r10,8000457c <gui_drawPixel+0x58>
8000455c:	32 3b       	mov	r11,35
8000455e:	48 9c       	lddpc	r12,80004580 <gui_drawPixel+0x5c>
80004560:	f0 1f 00 09 	mcall	80004584 <gui_drawPixel+0x60>
  et024006_DrawQuickPixel(x,y,RGB(red,green,blue));
80004564:	ef e9 10 b9 	or	r9,r7,r9<<0xb
80004568:	f3 e8 10 58 	or	r8,r9,r8<<0x5
8000456c:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80004570:	f0 1f 00 08 	mcall	80004590 <gui_drawPixel+0x6c>
(actualX);
  *bufp = color;
  bufp = (Uint32 *)gui->screen->pixels + (((actualY)+1)*gui->screen->pitch/4) +
(actualX) + 1;
  *bufp = color;*/
}
80004574:	e3 cd 80 80 	ldm	sp++,r7,pc
80004578:	80 01       	ld.sh	r1,r0[0x0]
8000457a:	43 44       	lddsp	r4,sp[0xd0]
8000457c:	80 01       	ld.sh	r1,r0[0x0]
8000457e:	43 d8       	lddsp	r8,sp[0xf4]
80004580:	80 01       	ld.sh	r1,r0[0x0]
80004582:	43 50       	lddsp	r0,sp[0xd4]
80004584:	80 00       	ld.sh	r0,r0[0x0]
80004586:	c1 a0       	breq	800045ba <interrupts_setRESET+0x26>
80004588:	80 01       	ld.sh	r1,r0[0x0]
8000458a:	43 ac       	lddsp	r12,sp[0xe8]
8000458c:	80 01       	ld.sh	r1,r0[0x0]
8000458e:	43 bc       	lddsp	r12,sp[0xec]
80004590:	80 00       	ld.sh	r0,r0[0x0]
80004592:	6f 6c       	ld.w	r12,r7[0x58]

80004594 <interrupts_setRESET>:
}
void interrupts_setNMI(Interrupts interrupts, Bool NMI) {
  assert(interrupts != NULL);
  interrupts->NMI = NMI;
}
void interrupts_setRESET(Interrupts interrupts, Bool RESET) {
80004594:	d4 01       	pushm	lr
  assert(interrupts != NULL);
80004596:	58 0c       	cp.w	r12,0
80004598:	c0 71       	brne	800045a6 <interrupts_setRESET+0x12>
8000459a:	48 59       	lddpc	r9,800045ac <interrupts_setRESET+0x18>
8000459c:	48 5a       	lddpc	r10,800045b0 <interrupts_setRESET+0x1c>
8000459e:	32 cb       	mov	r11,44
800045a0:	48 5c       	lddpc	r12,800045b4 <interrupts_setRESET+0x20>
800045a2:	f0 1f 00 06 	mcall	800045b8 <interrupts_setRESET+0x24>
  interrupts->RESET = RESET;
800045a6:	b8 ab       	st.b	r12[0x2],r11
800045a8:	d8 02       	popm	pc
800045aa:	00 00       	add	r0,r0
800045ac:	80 01       	ld.sh	r1,r0[0x0]
800045ae:	44 68       	lddsp	r8,sp[0x118]
800045b0:	80 01       	ld.sh	r1,r0[0x0]
800045b2:	44 98       	lddsp	r8,sp[0x124]
800045b4:	80 01       	ld.sh	r1,r0[0x0]
800045b6:	44 7c       	lddsp	r12,sp[0x11c]
800045b8:	80 00       	ld.sh	r0,r0[0x0]
800045ba:	c1 a0       	breq	800045ee <interrupts_setIRQ+0xa>

800045bc <interrupts_setNMI>:
}
void interrupts_setIRQ(Interrupts interrupts, Bool IRQ) {
  assert(interrupts != NULL);
  interrupts->IRQ = IRQ;
}
void interrupts_setNMI(Interrupts interrupts, Bool NMI) {
800045bc:	d4 01       	pushm	lr
  assert(interrupts != NULL);
800045be:	58 0c       	cp.w	r12,0
800045c0:	c0 71       	brne	800045ce <interrupts_setNMI+0x12>
800045c2:	48 59       	lddpc	r9,800045d4 <interrupts_setNMI+0x18>
800045c4:	48 5a       	lddpc	r10,800045d8 <interrupts_setNMI+0x1c>
800045c6:	32 8b       	mov	r11,40
800045c8:	48 5c       	lddpc	r12,800045dc <interrupts_setNMI+0x20>
800045ca:	f0 1f 00 06 	mcall	800045e0 <interrupts_setNMI+0x24>
  interrupts->NMI = NMI;
800045ce:	b8 9b       	st.b	r12[0x1],r11
}
800045d0:	d8 02       	popm	pc
800045d2:	00 00       	add	r0,r0
800045d4:	80 01       	ld.sh	r1,r0[0x0]
800045d6:	44 68       	lddsp	r8,sp[0x118]
800045d8:	80 01       	ld.sh	r1,r0[0x0]
800045da:	44 54       	lddsp	r4,sp[0x114]
800045dc:	80 01       	ld.sh	r1,r0[0x0]
800045de:	44 7c       	lddsp	r12,sp[0x11c]
800045e0:	80 00       	ld.sh	r0,r0[0x0]
800045e2:	c1 a0       	breq	80004616 <interrupts_getRESET+0xa>

800045e4 <interrupts_setIRQ>:
}
Bool interrupts_getRESET(Interrupts interrupts) {
  assert(interrupts != NULL);
  return interrupts->RESET;
}
void interrupts_setIRQ(Interrupts interrupts, Bool IRQ) {
800045e4:	d4 01       	pushm	lr
  assert(interrupts != NULL);
800045e6:	58 0c       	cp.w	r12,0
800045e8:	c0 71       	brne	800045f6 <interrupts_setIRQ+0x12>
800045ea:	48 59       	lddpc	r9,800045fc <interrupts_setIRQ+0x18>
800045ec:	48 5a       	lddpc	r10,80004600 <interrupts_setIRQ+0x1c>
800045ee:	32 4b       	mov	r11,36
800045f0:	48 5c       	lddpc	r12,80004604 <interrupts_setIRQ+0x20>
800045f2:	f0 1f 00 06 	mcall	80004608 <interrupts_setIRQ+0x24>
  interrupts->IRQ = IRQ;
800045f6:	b8 8b       	st.b	r12[0x0],r11
}
800045f8:	d8 02       	popm	pc
800045fa:	00 00       	add	r0,r0
800045fc:	80 01       	ld.sh	r1,r0[0x0]
800045fe:	44 68       	lddsp	r8,sp[0x118]
80004600:	80 01       	ld.sh	r1,r0[0x0]
80004602:	44 40       	lddsp	r0,sp[0x110]
80004604:	80 01       	ld.sh	r1,r0[0x0]
80004606:	44 7c       	lddsp	r12,sp[0x11c]
80004608:	80 00       	ld.sh	r0,r0[0x0]
8000460a:	c1 a0       	breq	8000463e <interrupts_getNMI+0xa>

8000460c <interrupts_getRESET>:
}
Bool interrupts_getNMI(Interrupts interrupts) {
  assert(interrupts != NULL);
  return interrupts->NMI;
}
Bool interrupts_getRESET(Interrupts interrupts) {
8000460c:	d4 01       	pushm	lr
  assert(interrupts != NULL);
8000460e:	58 0c       	cp.w	r12,0
80004610:	c0 71       	brne	8000461e <interrupts_getRESET+0x12>
80004612:	48 59       	lddpc	r9,80004624 <interrupts_getRESET+0x18>
80004614:	48 5a       	lddpc	r10,80004628 <interrupts_getRESET+0x1c>
80004616:	32 0b       	mov	r11,32
80004618:	48 5c       	lddpc	r12,8000462c <interrupts_getRESET+0x20>
8000461a:	f0 1f 00 06 	mcall	80004630 <interrupts_getRESET+0x24>
  return interrupts->RESET;
}
8000461e:	19 ac       	ld.ub	r12,r12[0x2]
80004620:	d8 02       	popm	pc
80004622:	00 00       	add	r0,r0
80004624:	80 01       	ld.sh	r1,r0[0x0]
80004626:	44 68       	lddsp	r8,sp[0x118]
80004628:	80 01       	ld.sh	r1,r0[0x0]
8000462a:	44 1c       	lddsp	r12,sp[0x104]
8000462c:	80 01       	ld.sh	r1,r0[0x0]
8000462e:	44 7c       	lddsp	r12,sp[0x11c]
80004630:	80 00       	ld.sh	r0,r0[0x0]
80004632:	c1 a0       	breq	80004666 <interrupts_getIRQ+0xa>

80004634 <interrupts_getNMI>:
}
Bool interrupts_getIRQ(Interrupts interrupts) {
  assert(interrupts != NULL);
  return interrupts->IRQ;
}
Bool interrupts_getNMI(Interrupts interrupts) {
80004634:	d4 01       	pushm	lr
  assert(interrupts != NULL);
80004636:	58 0c       	cp.w	r12,0
80004638:	c0 71       	brne	80004646 <interrupts_getNMI+0x12>
8000463a:	48 59       	lddpc	r9,8000464c <interrupts_getNMI+0x18>
8000463c:	48 5a       	lddpc	r10,80004650 <interrupts_getNMI+0x1c>
8000463e:	31 cb       	mov	r11,28
80004640:	48 5c       	lddpc	r12,80004654 <interrupts_getNMI+0x20>
80004642:	f0 1f 00 06 	mcall	80004658 <interrupts_getNMI+0x24>
  return interrupts->NMI;
}
80004646:	19 9c       	ld.ub	r12,r12[0x1]
80004648:	d8 02       	popm	pc
8000464a:	00 00       	add	r0,r0
8000464c:	80 01       	ld.sh	r1,r0[0x0]
8000464e:	44 68       	lddsp	r8,sp[0x118]
80004650:	80 01       	ld.sh	r1,r0[0x0]
80004652:	44 08       	lddsp	r8,sp[0x100]
80004654:	80 01       	ld.sh	r1,r0[0x0]
80004656:	44 7c       	lddsp	r12,sp[0x11c]
80004658:	80 00       	ld.sh	r0,r0[0x0]
8000465a:	c1 a0       	breq	8000468e <interrupts_init+0xa>

8000465c <interrupts_getIRQ>:
}
void interrupts_destroy(Interrupts interrupts) {
  assert(interrupts != NULL);
  free(interrupts);
}
Bool interrupts_getIRQ(Interrupts interrupts) {
8000465c:	d4 01       	pushm	lr
  assert(interrupts != NULL);
8000465e:	58 0c       	cp.w	r12,0
80004660:	c0 71       	brne	8000466e <interrupts_getIRQ+0x12>
80004662:	48 59       	lddpc	r9,80004674 <interrupts_getIRQ+0x18>
80004664:	48 5a       	lddpc	r10,80004678 <interrupts_getIRQ+0x1c>
80004666:	31 8b       	mov	r11,24
80004668:	48 5c       	lddpc	r12,8000467c <interrupts_getIRQ+0x20>
8000466a:	f0 1f 00 06 	mcall	80004680 <interrupts_getIRQ+0x24>
  return interrupts->IRQ;
}
8000466e:	19 8c       	ld.ub	r12,r12[0x0]
80004670:	d8 02       	popm	pc
80004672:	00 00       	add	r0,r0
80004674:	80 01       	ld.sh	r1,r0[0x0]
80004676:	44 68       	lddsp	r8,sp[0x118]
80004678:	80 01       	ld.sh	r1,r0[0x0]
8000467a:	44 ac       	lddsp	r12,sp[0x128]
8000467c:	80 01       	ld.sh	r1,r0[0x0]
8000467e:	44 7c       	lddsp	r12,sp[0x11c]
80004680:	80 00       	ld.sh	r0,r0[0x0]
80004682:	c1 a0       	breq	800046b6 <interrupts_init+0x32>

80004684 <interrupts_init>:
struct interrupts {
  Bool IRQ;
  Bool NMI;
  Bool RESET;
};
Interrupts interrupts_init(void) {
80004684:	d4 01       	pushm	lr
  Interrupts interrupts = (Interrupts) malloc(sizeof(struct interrupts));
80004686:	30 3c       	mov	r12,3
80004688:	f0 1f 00 07 	mcall	800046a4 <interrupts_init+0x20>
  assert(interrupts != NULL);
8000468c:	c0 71       	brne	8000469a <interrupts_init+0x16>
8000468e:	48 79       	lddpc	r9,800046a8 <interrupts_init+0x24>
80004690:	48 7a       	lddpc	r10,800046ac <interrupts_init+0x28>
80004692:	30 db       	mov	r11,13
80004694:	48 7c       	lddpc	r12,800046b0 <interrupts_init+0x2c>
80004696:	f0 1f 00 08 	mcall	800046b4 <interrupts_init+0x30>
  interrupts->IRQ = FALSE;
8000469a:	30 08       	mov	r8,0
8000469c:	b8 88       	st.b	r12[0x0],r8
  interrupts->NMI = FALSE;
8000469e:	b8 98       	st.b	r12[0x1],r8
  interrupts->RESET = FALSE;
800046a0:	b8 a8       	st.b	r12[0x2],r8
  return interrupts;
}
800046a2:	d8 02       	popm	pc
800046a4:	80 00       	ld.sh	r0,r0[0x0]
800046a6:	c1 fc       	rcall	800046e4 <joypad_readByte+0x4>
800046a8:	80 01       	ld.sh	r1,r0[0x0]
800046aa:	44 68       	lddsp	r8,sp[0x118]
800046ac:	80 01       	ld.sh	r1,r0[0x0]
800046ae:	44 30       	lddsp	r0,sp[0x10c]
800046b0:	80 01       	ld.sh	r1,r0[0x0]
800046b2:	44 7c       	lddsp	r12,sp[0x11c]
800046b4:	80 00       	ld.sh	r0,r0[0x0]
800046b6:	c1 a0       	breq	800046ea <joypad_readByte+0xa>

800046b8 <joypad_resetCurrentButton>:
  assert(joypad != NULL);
  joypad->joypadNumber = joypadNumber;
  joypad->currentButton = 0;
  return joypad;
}
void joypad_resetCurrentButton(Joypad joypad) {
800046b8:	d4 01       	pushm	lr
  assert(joypad != NULL);
800046ba:	58 0c       	cp.w	r12,0
800046bc:	c0 71       	brne	800046ca <joypad_resetCurrentButton+0x12>
800046be:	48 59       	lddpc	r9,800046d0 <joypad_resetCurrentButton+0x18>
800046c0:	48 5a       	lddpc	r10,800046d4 <joypad_resetCurrentButton+0x1c>
800046c2:	31 3b       	mov	r11,19
800046c4:	48 5c       	lddpc	r12,800046d8 <joypad_resetCurrentButton+0x20>
800046c6:	f0 1f 00 06 	mcall	800046dc <joypad_resetCurrentButton+0x24>
  joypad->currentButton = 0;
800046ca:	30 08       	mov	r8,0
800046cc:	99 18       	st.w	r12[0x4],r8
}
800046ce:	d8 02       	popm	pc
800046d0:	80 01       	ld.sh	r1,r0[0x0]
800046d2:	44 ec       	lddsp	r12,sp[0x138]
800046d4:	80 01       	ld.sh	r1,r0[0x0]
800046d6:	44 c0       	lddsp	r0,sp[0x130]
800046d8:	80 01       	ld.sh	r1,r0[0x0]
800046da:	44 fc       	lddsp	r12,sp[0x13c]
800046dc:	80 00       	ld.sh	r0,r0[0x0]
800046de:	c1 a0       	breq	80004712 <joypad_readByte+0x32>

800046e0 <joypad_readByte>:
Byte joypad_readByte(NES nes, Joypad joypad) {
800046e0:	eb cd 40 80 	pushm	r7,lr
800046e4:	16 97       	mov	r7,r11
  assert(nes != NULL);
800046e6:	58 0c       	cp.w	r12,0
800046e8:	c0 71       	brne	800046f6 <joypad_readByte+0x16>
800046ea:	49 89       	lddpc	r9,80004748 <joypad_readByte+0x68>
800046ec:	49 8a       	lddpc	r10,8000474c <joypad_readByte+0x6c>
800046ee:	31 7b       	mov	r11,23
800046f0:	49 8c       	lddpc	r12,80004750 <joypad_readByte+0x70>
800046f2:	f0 1f 00 19 	mcall	80004754 <joypad_readByte+0x74>
  assert(joypad != NULL);
800046f6:	58 0b       	cp.w	r11,0
800046f8:	c0 71       	brne	80004706 <joypad_readByte+0x26>
800046fa:	49 89       	lddpc	r9,80004758 <joypad_readByte+0x78>
800046fc:	49 4a       	lddpc	r10,8000474c <joypad_readByte+0x6c>
800046fe:	31 8b       	mov	r11,24
80004700:	49 4c       	lddpc	r12,80004750 <joypad_readByte+0x70>
80004702:	f0 1f 00 15 	mcall	80004754 <joypad_readByte+0x74>
  GUI gui = nes_getGUI(nes);
80004706:	f0 1f 00 16 	mcall	8000475c <joypad_readByte+0x7c>
  assert(gui != NULL);
8000470a:	c0 71       	brne	80004718 <joypad_readByte+0x38>
8000470c:	49 59       	lddpc	r9,80004760 <joypad_readByte+0x80>
8000470e:	49 0a       	lddpc	r10,8000474c <joypad_readByte+0x6c>
80004710:	31 ab       	mov	r11,26
80004712:	49 0c       	lddpc	r12,80004750 <joypad_readByte+0x70>
80004714:	f0 1f 00 10 	mcall	80004754 <joypad_readByte+0x74>
  Byte data = 0;
  if (joypad->currentButton < JOYPAD_NUM_BUTTONS) {
80004718:	6e 1a       	ld.w	r10,r7[0x4]
8000471a:	58 7a       	cp.w	r10,7
8000471c:	e0 8b 00 0a 	brhi	80004730 <joypad_readByte+0x50>
    if (gui_isButtonPressed(gui, joypad->joypadNumber, joypad->currentButton) == TRUE) {
80004720:	6e 0b       	ld.w	r11,r7[0x0]
80004722:	f0 1f 00 11 	mcall	80004764 <joypad_readByte+0x84>
80004726:	30 18       	mov	r8,1
80004728:	f0 0c 18 00 	cp.b	r12,r8
8000472c:	c0 71       	brne	8000473a <joypad_readByte+0x5a>
8000472e:	c0 48       	rjmp	80004736 <joypad_readByte+0x56>
      data = 1;
    }
  } else if (joypad->currentButton < (JOYPAD_NUM_BUTTONS * 2)) {
80004730:	58 fa       	cp.w	r10,15
80004732:	e0 88 00 04 	brls	8000473a <joypad_readByte+0x5a>
80004736:	30 1c       	mov	r12,1
80004738:	c0 28       	rjmp	8000473c <joypad_readByte+0x5c>
8000473a:	30 0c       	mov	r12,0
    data = 0; // player 0/2 1/3
  } else {
    data = 1;
  }
  joypad->currentButton++;
8000473c:	6e 18       	ld.w	r8,r7[0x4]
8000473e:	2f f8       	sub	r8,-1
80004740:	8f 18       	st.w	r7[0x4],r8
  return data;
}
80004742:	e3 cd 80 80 	ldm	sp++,r7,pc
80004746:	00 00       	add	r0,r0
80004748:	80 01       	ld.sh	r1,r0[0x0]
8000474a:	31 44       	mov	r4,20
8000474c:	80 01       	ld.sh	r1,r0[0x0]
8000474e:	44 dc       	lddsp	r12,sp[0x134]
80004750:	80 01       	ld.sh	r1,r0[0x0]
80004752:	44 fc       	lddsp	r12,sp[0x13c]
80004754:	80 00       	ld.sh	r0,r0[0x0]
80004756:	c1 a0       	breq	8000478a <joypad_init+0x22>
80004758:	80 01       	ld.sh	r1,r0[0x0]
8000475a:	44 ec       	lddsp	r12,sp[0x138]
8000475c:	80 00       	ld.sh	r0,r0[0x0]
8000475e:	50 e8       	stdsp	sp[0x38],r8
80004760:	80 01       	ld.sh	r1,r0[0x0]
80004762:	43 44       	lddsp	r4,sp[0xd0]
80004764:	80 00       	ld.sh	r0,r0[0x0]
80004766:	43 d0       	lddsp	r0,sp[0xf4]

80004768 <joypad_init>:
#include "nes.h"
struct joypad {
  int joypadNumber;
  Button currentButton;
};
Joypad joypad_init(int joypadNumber) {
80004768:	eb cd 40 80 	pushm	r7,lr
8000476c:	18 97       	mov	r7,r12
  Joypad joypad = (Joypad) malloc(sizeof(struct joypad));
8000476e:	30 8c       	mov	r12,8
80004770:	f0 1f 00 07 	mcall	8000478c <joypad_init+0x24>
  assert(joypad != NULL);
80004774:	c0 71       	brne	80004782 <joypad_init+0x1a>
80004776:	48 79       	lddpc	r9,80004790 <joypad_init+0x28>
80004778:	48 7a       	lddpc	r10,80004794 <joypad_init+0x2c>
8000477a:	30 db       	mov	r11,13
8000477c:	48 7c       	lddpc	r12,80004798 <joypad_init+0x30>
8000477e:	f0 1f 00 08 	mcall	8000479c <joypad_init+0x34>
  joypad->joypadNumber = joypadNumber;
80004782:	99 07       	st.w	r12[0x0],r7
  joypad->currentButton = 0;
80004784:	30 08       	mov	r8,0
80004786:	99 18       	st.w	r12[0x4],r8
  return joypad;
}
80004788:	e3 cd 80 80 	ldm	sp++,r7,pc
8000478c:	80 00       	ld.sh	r0,r0[0x0]
8000478e:	c1 fc       	rcall	800047cc <memory_setWriteCallback>
80004790:	80 01       	ld.sh	r1,r0[0x0]
80004792:	44 ec       	lddsp	r12,sp[0x138]
80004794:	80 01       	ld.sh	r1,r0[0x0]
80004796:	45 14       	lddsp	r4,sp[0x144]
80004798:	80 01       	ld.sh	r1,r0[0x0]
8000479a:	44 fc       	lddsp	r12,sp[0x13c]
8000479c:	80 00       	ld.sh	r0,r0[0x0]
8000479e:	c1 a0       	breq	800047d2 <memory_setWriteCallback+0x6>

800047a0 <memory_setReadCallback>:
}
void memory_setWriteCallback(Memory memory, Address address, NES_WriteCallback writeCallback) {
  assert(memory != NULL);
  memory->writeCallbacks[address] = writeCallback;
}
void memory_setReadCallback(Memory memory, Address address, NES_ReadCallback readCallback) {
800047a0:	d4 01       	pushm	lr
  assert(memory != NULL);
800047a2:	58 0c       	cp.w	r12,0
800047a4:	c0 71       	brne	800047b2 <memory_setReadCallback+0x12>
800047a6:	48 69       	lddpc	r9,800047bc <memory_setReadCallback+0x1c>
800047a8:	48 6a       	lddpc	r10,800047c0 <memory_setReadCallback+0x20>
800047aa:	35 2b       	mov	r11,82
800047ac:	48 6c       	lddpc	r12,800047c4 <memory_setReadCallback+0x24>
800047ae:	f0 1f 00 07 	mcall	800047c8 <memory_setReadCallback+0x28>
  memory->readCallbacks[address] = readCallback;
800047b2:	5c 7b       	castu.h	r11
800047b4:	78 38       	ld.w	r8,r12[0xc]
800047b6:	f0 0b 09 2a 	st.w	r8[r11<<0x2],r10
}
800047ba:	d8 02       	popm	pc
800047bc:	80 01       	ld.sh	r1,r0[0x0]
800047be:	45 64       	lddsp	r4,sp[0x158]
800047c0:	80 01       	ld.sh	r1,r0[0x0]
800047c2:	46 2c       	lddsp	r12,sp[0x188]
800047c4:	80 01       	ld.sh	r1,r0[0x0]
800047c6:	45 74       	lddsp	r4,sp[0x15c]
800047c8:	80 00       	ld.sh	r0,r0[0x0]
800047ca:	c1 a0       	breq	800047fe <memory_read_direct+0x6>

800047cc <memory_setWriteCallback>:
}
int memory_getNumAddresses(Memory memory) {
  assert(memory != NULL);
  return memory->numAddresses;
}
void memory_setWriteCallback(Memory memory, Address address, NES_WriteCallback writeCallback) {
800047cc:	d4 01       	pushm	lr
  assert(memory != NULL);
800047ce:	58 0c       	cp.w	r12,0
800047d0:	c0 71       	brne	800047de <memory_setWriteCallback+0x12>
800047d2:	48 69       	lddpc	r9,800047e8 <memory_setWriteCallback+0x1c>
800047d4:	48 6a       	lddpc	r10,800047ec <memory_setWriteCallback+0x20>
800047d6:	34 eb       	mov	r11,78
800047d8:	48 6c       	lddpc	r12,800047f0 <memory_setWriteCallback+0x24>
800047da:	f0 1f 00 07 	mcall	800047f4 <memory_setWriteCallback+0x28>
  memory->writeCallbacks[address] = writeCallback;
800047de:	5c 7b       	castu.h	r11
800047e0:	78 28       	ld.w	r8,r12[0x8]
800047e2:	f0 0b 09 2a 	st.w	r8[r11<<0x2],r10
}
800047e6:	d8 02       	popm	pc
800047e8:	80 01       	ld.sh	r1,r0[0x0]
800047ea:	45 64       	lddsp	r4,sp[0x158]
800047ec:	80 01       	ld.sh	r1,r0[0x0]
800047ee:	45 4c       	lddsp	r12,sp[0x150]
800047f0:	80 01       	ld.sh	r1,r0[0x0]
800047f2:	45 74       	lddsp	r4,sp[0x15c]
800047f4:	80 00       	ld.sh	r0,r0[0x0]
800047f6:	c1 a0       	breq	8000482a <memory_read_direct+0x32>

800047f8 <memory_read_direct>:
void memory_write_direct(Memory memory, Address address, Byte data) {
  assert(memory != NULL);
  assert(address < memory->numAddresses);
  memory->memoryU[address] = data;
}
Byte memory_read_direct(Memory memory, Address address) {
800047f8:	d4 01       	pushm	lr
  assert(memory != NULL);
800047fa:	58 0c       	cp.w	r12,0
800047fc:	c0 71       	brne	8000480a <memory_read_direct+0x12>
800047fe:	48 c9       	lddpc	r9,8000482c <memory_read_direct+0x34>
80004800:	48 ca       	lddpc	r10,80004830 <memory_read_direct+0x38>
80004802:	33 7b       	mov	r11,55
80004804:	48 cc       	lddpc	r12,80004834 <memory_read_direct+0x3c>
80004806:	f0 1f 00 0d 	mcall	80004838 <memory_read_direct+0x40>
  assert(address < memory->numAddresses);
8000480a:	f3 db c0 10 	bfextu	r9,r11,0x0,0x10
8000480e:	78 08       	ld.w	r8,r12[0x0]
80004810:	10 39       	cp.w	r9,r8
80004812:	c0 75       	brlt	80004820 <memory_read_direct+0x28>
80004814:	48 a9       	lddpc	r9,8000483c <memory_read_direct+0x44>
80004816:	48 7a       	lddpc	r10,80004830 <memory_read_direct+0x38>
80004818:	33 8b       	mov	r11,56
8000481a:	48 7c       	lddpc	r12,80004834 <memory_read_direct+0x3c>
8000481c:	f0 1f 00 07 	mcall	80004838 <memory_read_direct+0x40>
80004820:	5c 7b       	castu.h	r11
80004822:	78 18       	ld.w	r8,r12[0x4]
  return memory->memoryU[address];
}
80004824:	f0 0b 07 0c 	ld.ub	r12,r8[r11]
80004828:	d8 02       	popm	pc
8000482a:	00 00       	add	r0,r0
8000482c:	80 01       	ld.sh	r1,r0[0x0]
8000482e:	45 64       	lddsp	r4,sp[0x158]
80004830:	80 01       	ld.sh	r1,r0[0x0]
80004832:	46 18       	lddsp	r8,sp[0x184]
80004834:	80 01       	ld.sh	r1,r0[0x0]
80004836:	45 74       	lddsp	r4,sp[0x15c]
80004838:	80 00       	ld.sh	r0,r0[0x0]
8000483a:	c1 a0       	breq	8000486e <memory_read_callback+0x2e>
8000483c:	80 01       	ld.sh	r1,r0[0x0]
8000483e:	45 8c       	lddsp	r12,sp[0x160]

80004840 <memory_read_callback>:
    memory_write_direct(memory, address, data);
  } else {
    memory->writeCallbacks[address](nes, address, data);
  }
}
Byte memory_read_callback(NES nes, Memory memory1, Address address) {
80004840:	d4 01       	pushm	lr
80004842:	16 99       	mov	r9,r11
  assert(memory1 != NULL);
80004844:	58 0b       	cp.w	r11,0
80004846:	c0 71       	brne	80004854 <memory_read_callback+0x14>
80004848:	48 b9       	lddpc	r9,80004874 <memory_read_callback+0x34>
8000484a:	48 ca       	lddpc	r10,80004878 <memory_read_callback+0x38>
8000484c:	35 eb       	mov	r11,94
8000484e:	48 cc       	lddpc	r12,8000487c <memory_read_callback+0x3c>
80004850:	f0 1f 00 0c 	mcall	80004880 <memory_read_callback+0x40>
  //usart_write_line(&AVR32_USART0,"readCallback\n");
  if (memory1->readCallbacks[address] == NULL) {
80004854:	f7 da c0 10 	bfextu	r11,r10,0x0,0x10
80004858:	72 38       	ld.w	r8,r9[0xc]
8000485a:	f0 0b 03 28 	ld.w	r8,r8[r11<<0x2]
8000485e:	58 08       	cp.w	r8,0
80004860:	c0 51       	brne	8000486a <memory_read_callback+0x2a>
	  //usart_write_line(&AVR32_USART0,"readCallback1_1\n");
    return memory_read_direct(memory1, address);
80004862:	12 9c       	mov	r12,r9
80004864:	f0 1f 00 08 	mcall	80004884 <memory_read_callback+0x44>
80004868:	d8 02       	popm	pc
  } else {
	  //usart_write_line(&AVR32_USART0,"readCallback1_2\n");
    return memory1->readCallbacks[address](nes,address);
8000486a:	f7 da c0 10 	bfextu	r11,r10,0x0,0x10
8000486e:	5d 18       	icall	r8
	//return memory_read_direct(memory1, address);
  }
  
80004870:	d8 02       	popm	pc
80004872:	00 00       	add	r0,r0
80004874:	80 01       	ld.sh	r1,r0[0x0]
80004876:	40 f0       	lddsp	r0,sp[0x3c]
80004878:	80 01       	ld.sh	r1,r0[0x0]
8000487a:	45 34       	lddsp	r4,sp[0x14c]
8000487c:	80 01       	ld.sh	r1,r0[0x0]
8000487e:	45 74       	lddsp	r4,sp[0x15c]
80004880:	80 00       	ld.sh	r0,r0[0x0]
80004882:	c1 a0       	breq	800048b6 <memory_write_direct+0x2e>
80004884:	80 00       	ld.sh	r0,r0[0x0]
80004886:	47 f8       	lddsp	r8,sp[0x1fc]

80004888 <memory_write_direct>:
}
void memory_destroy(Memory memory) {
  assert(memory != NULL);
  free(memory);
}
void memory_write_direct(Memory memory, Address address, Byte data) {
80004888:	d4 01       	pushm	lr
  assert(memory != NULL);
8000488a:	58 0c       	cp.w	r12,0
8000488c:	c0 71       	brne	8000489a <memory_write_direct+0x12>
8000488e:	48 c9       	lddpc	r9,800048bc <memory_write_direct+0x34>
80004890:	48 ca       	lddpc	r10,800048c0 <memory_write_direct+0x38>
80004892:	33 2b       	mov	r11,50
80004894:	48 cc       	lddpc	r12,800048c4 <memory_write_direct+0x3c>
80004896:	f0 1f 00 0d 	mcall	800048c8 <memory_write_direct+0x40>
  assert(address < memory->numAddresses);
8000489a:	f3 db c0 10 	bfextu	r9,r11,0x0,0x10
8000489e:	78 08       	ld.w	r8,r12[0x0]
800048a0:	10 39       	cp.w	r9,r8
800048a2:	c0 75       	brlt	800048b0 <memory_write_direct+0x28>
800048a4:	48 a9       	lddpc	r9,800048cc <memory_write_direct+0x44>
800048a6:	48 7a       	lddpc	r10,800048c0 <memory_write_direct+0x38>
800048a8:	33 3b       	mov	r11,51
800048aa:	48 7c       	lddpc	r12,800048c4 <memory_write_direct+0x3c>
800048ac:	f0 1f 00 07 	mcall	800048c8 <memory_write_direct+0x40>
  memory->memoryU[address] = data;
800048b0:	5c 7b       	castu.h	r11
800048b2:	78 18       	ld.w	r8,r12[0x4]
800048b4:	f0 0b 0b 0a 	st.b	r8[r11],r10
}
800048b8:	d8 02       	popm	pc
800048ba:	00 00       	add	r0,r0
800048bc:	80 01       	ld.sh	r1,r0[0x0]
800048be:	45 64       	lddsp	r4,sp[0x158]
800048c0:	80 01       	ld.sh	r1,r0[0x0]
800048c2:	45 20       	lddsp	r0,sp[0x148]
800048c4:	80 01       	ld.sh	r1,r0[0x0]
800048c6:	45 74       	lddsp	r4,sp[0x15c]
800048c8:	80 00       	ld.sh	r0,r0[0x0]
800048ca:	c1 a0       	breq	800048fe <memory_write_callback+0x2e>
800048cc:	80 01       	ld.sh	r1,r0[0x0]
800048ce:	45 8c       	lddsp	r12,sp[0x160]

800048d0 <memory_write_callback>:
}
void memory_setReadCallback(Memory memory, Address address, NES_ReadCallback readCallback) {
  assert(memory != NULL);
  memory->readCallbacks[address] = readCallback;
}
void memory_write_callback(NES nes, Memory memory, Address address, Byte data) {
800048d0:	d4 01       	pushm	lr
800048d2:	16 9e       	mov	lr,r11
800048d4:	14 9b       	mov	r11,r10
  assert(memory != NULL);
800048d6:	58 0e       	cp.w	lr,0
800048d8:	c0 71       	brne	800048e6 <memory_write_callback+0x16>
800048da:	48 c9       	lddpc	r9,80004908 <memory_write_callback+0x38>
800048dc:	48 ca       	lddpc	r10,8000490c <memory_write_callback+0x3c>
800048de:	35 6b       	mov	r11,86
800048e0:	48 cc       	lddpc	r12,80004910 <memory_write_callback+0x40>
800048e2:	f0 1f 00 0d 	mcall	80004914 <memory_write_callback+0x44>
  if (memory->writeCallbacks[address] == NULL) {
800048e6:	5c 7a       	castu.h	r10
800048e8:	7c 28       	ld.w	r8,lr[0x8]
800048ea:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
800048ee:	58 08       	cp.w	r8,0
800048f0:	c0 71       	brne	800048fe <memory_write_callback+0x2e>
    memory_write_direct(memory, address, data);
800048f2:	12 9a       	mov	r10,r9
800048f4:	5c 7b       	castu.h	r11
800048f6:	1c 9c       	mov	r12,lr
800048f8:	f0 1f 00 08 	mcall	80004918 <memory_write_callback+0x48>
800048fc:	d8 02       	popm	pc
  } else {
    memory->writeCallbacks[address](nes, address, data);
800048fe:	12 9a       	mov	r10,r9
80004900:	5c 7b       	castu.h	r11
80004902:	5d 18       	icall	r8
80004904:	d8 02       	popm	pc
80004906:	00 00       	add	r0,r0
80004908:	80 01       	ld.sh	r1,r0[0x0]
8000490a:	45 64       	lddsp	r4,sp[0x158]
8000490c:	80 01       	ld.sh	r1,r0[0x0]
8000490e:	46 50       	lddsp	r0,sp[0x194]
80004910:	80 01       	ld.sh	r1,r0[0x0]
80004912:	45 74       	lddsp	r4,sp[0x15c]
80004914:	80 00       	ld.sh	r0,r0[0x0]
80004916:	c1 a0       	breq	8000494a <memory_init+0x2e>
80004918:	80 00       	ld.sh	r0,r0[0x0]
8000491a:	48 88       	lddpc	r8,80004938 <memory_init+0x1c>

8000491c <memory_init>:
  int numAddresses;
  Byte *memoryU;
  NES_WriteCallback *writeCallbacks;
  NES_ReadCallback *readCallbacks;
};
Memory memory_init(uint32_t numAddresses) {
8000491c:	eb cd 40 e0 	pushm	r5-r7,lr
80004920:	18 96       	mov	r6,r12
  Memory memory1 = malloc(sizeof(struct memory));
80004922:	31 0c       	mov	r12,16
80004924:	f0 1f 00 32 	mcall	800049ec <memory_init+0xd0>
80004928:	18 97       	mov	r7,r12
  assert(memory1 != NULL);
8000492a:	c0 71       	brne	80004938 <memory_init+0x1c>
8000492c:	4b 19       	lddpc	r9,800049f0 <memory_init+0xd4>
8000492e:	4b 2a       	lddpc	r10,800049f4 <memory_init+0xd8>
80004930:	31 4b       	mov	r11,20
80004932:	4b 2c       	lddpc	r12,800049f8 <memory_init+0xdc>
80004934:	f0 1f 00 32 	mcall	800049fc <memory_init+0xe0>
  memory1->memoryU = (Byte*) malloc(sizeof(Byte) * numAddresses);
80004938:	0c 9c       	mov	r12,r6
8000493a:	f0 1f 00 2d 	mcall	800049ec <memory_init+0xd0>
8000493e:	8f 1c       	st.w	r7[0x4],r12
 assert(memory1->memoryU != NULL);
80004940:	c0 71       	brne	8000494e <memory_init+0x32>
80004942:	4b 09       	lddpc	r9,80004a00 <memory_init+0xe4>
80004944:	4a ca       	lddpc	r10,800049f4 <memory_init+0xd8>
80004946:	31 6b       	mov	r11,22
80004948:	4a cc       	lddpc	r12,800049f8 <memory_init+0xdc>
8000494a:	f0 1f 00 2d 	mcall	800049fc <memory_init+0xe0>
 usart_write_line(&AVR32_USART0,"CPU33");
8000494e:	4a eb       	lddpc	r11,80004a04 <memory_init+0xe8>
80004950:	fe 7c 14 00 	mov	r12,-60416
80004954:	f0 1f 00 2d 	mcall	80004a08 <memory_init+0xec>
 
  int i;
  
  for (i=0; i < numAddresses; i++) {
80004958:	58 06       	cp.w	r6,0
8000495a:	c0 c0       	breq	80004972 <memory_init+0x56>
8000495c:	30 09       	mov	r9,0
8000495e:	12 98       	mov	r8,r9
    memory1->memoryU[i] = 0;
80004960:	30 0b       	mov	r11,0
80004962:	6e 1a       	ld.w	r10,r7[0x4]
80004964:	f4 09 0b 0b 	st.b	r10[r9],r11
 assert(memory1->memoryU != NULL);
 usart_write_line(&AVR32_USART0,"CPU33");
 
  int i;
  
  for (i=0; i < numAddresses; i++) {
80004968:	2f f8       	sub	r8,-1
8000496a:	10 99       	mov	r9,r8
8000496c:	10 36       	cp.w	r6,r8
8000496e:	fe 9b ff fa 	brhi	80004962 <memory_init+0x46>
    memory1->memoryU[i] = 0;
  }
  
  memory1->writeCallbacks = (NES_WriteCallback*) malloc(sizeof(NES_WriteCallback) * numAddresses);
80004972:	ec 05 15 02 	lsl	r5,r6,0x2
80004976:	0a 9c       	mov	r12,r5
80004978:	f0 1f 00 1d 	mcall	800049ec <memory_init+0xd0>
8000497c:	8f 2c       	st.w	r7[0x8],r12
  assert(memory1->writeCallbacks != NULL);
8000497e:	c0 40       	breq	80004986 <memory_init+0x6a>
  for (i=0; i < numAddresses; i++) {
80004980:	58 06       	cp.w	r6,0
80004982:	c0 81       	brne	80004992 <memory_init+0x76>
80004984:	c1 28       	rjmp	800049a8 <memory_init+0x8c>
  for (i=0; i < numAddresses; i++) {
    memory1->memoryU[i] = 0;
  }
  
  memory1->writeCallbacks = (NES_WriteCallback*) malloc(sizeof(NES_WriteCallback) * numAddresses);
  assert(memory1->writeCallbacks != NULL);
80004986:	4a 29       	lddpc	r9,80004a0c <memory_init+0xf0>
80004988:	49 ba       	lddpc	r10,800049f4 <memory_init+0xd8>
8000498a:	32 0b       	mov	r11,32
8000498c:	49 bc       	lddpc	r12,800049f8 <memory_init+0xdc>
8000498e:	f0 1f 00 1c 	mcall	800049fc <memory_init+0xe0>
80004992:	30 09       	mov	r9,0
80004994:	12 98       	mov	r8,r9
  for (i=0; i < numAddresses; i++) {
    memory1->writeCallbacks[i] = NULL;
80004996:	12 9b       	mov	r11,r9
80004998:	6e 2a       	ld.w	r10,r7[0x8]
8000499a:	f4 09 09 2b 	st.w	r10[r9<<0x2],r11
    memory1->memoryU[i] = 0;
  }
  
  memory1->writeCallbacks = (NES_WriteCallback*) malloc(sizeof(NES_WriteCallback) * numAddresses);
  assert(memory1->writeCallbacks != NULL);
  for (i=0; i < numAddresses; i++) {
8000499e:	2f f8       	sub	r8,-1
800049a0:	10 99       	mov	r9,r8
800049a2:	10 36       	cp.w	r6,r8
800049a4:	fe 9b ff fa 	brhi	80004998 <memory_init+0x7c>
    memory1->writeCallbacks[i] = NULL;
  }
  memory1->readCallbacks = (NES_ReadCallback*) malloc(sizeof(NES_ReadCallback) * numAddresses);
800049a8:	0a 9c       	mov	r12,r5
800049aa:	f0 1f 00 11 	mcall	800049ec <memory_init+0xd0>
800049ae:	8f 3c       	st.w	r7[0xc],r12
  assert(memory1->readCallbacks != NULL);
800049b0:	c0 40       	breq	800049b8 <memory_init+0x9c>
  for (i=0; i < numAddresses; i++) {
800049b2:	58 06       	cp.w	r6,0
800049b4:	c0 81       	brne	800049c4 <memory_init+0xa8>
800049b6:	c1 28       	rjmp	800049da <memory_init+0xbe>
  assert(memory1->writeCallbacks != NULL);
  for (i=0; i < numAddresses; i++) {
    memory1->writeCallbacks[i] = NULL;
  }
  memory1->readCallbacks = (NES_ReadCallback*) malloc(sizeof(NES_ReadCallback) * numAddresses);
  assert(memory1->readCallbacks != NULL);
800049b8:	49 69       	lddpc	r9,80004a10 <memory_init+0xf4>
800049ba:	48 fa       	lddpc	r10,800049f4 <memory_init+0xd8>
800049bc:	32 5b       	mov	r11,37
800049be:	48 fc       	lddpc	r12,800049f8 <memory_init+0xdc>
800049c0:	f0 1f 00 0f 	mcall	800049fc <memory_init+0xe0>
800049c4:	30 09       	mov	r9,0
800049c6:	12 98       	mov	r8,r9
  for (i=0; i < numAddresses; i++) {
    memory1->readCallbacks[i] = NULL;
800049c8:	12 9b       	mov	r11,r9
800049ca:	6e 3a       	ld.w	r10,r7[0xc]
800049cc:	f4 09 09 2b 	st.w	r10[r9<<0x2],r11
  for (i=0; i < numAddresses; i++) {
    memory1->writeCallbacks[i] = NULL;
  }
  memory1->readCallbacks = (NES_ReadCallback*) malloc(sizeof(NES_ReadCallback) * numAddresses);
  assert(memory1->readCallbacks != NULL);
  for (i=0; i < numAddresses; i++) {
800049d0:	2f f8       	sub	r8,-1
800049d2:	10 99       	mov	r9,r8
800049d4:	10 36       	cp.w	r6,r8
800049d6:	fe 9b ff fa 	brhi	800049ca <memory_init+0xae>
    memory1->readCallbacks[i] = NULL;
  }
  usart_write_line(&AVR32_USART0,"CPU43");
800049da:	48 fb       	lddpc	r11,80004a14 <memory_init+0xf8>
800049dc:	fe 7c 14 00 	mov	r12,-60416
800049e0:	f0 1f 00 0a 	mcall	80004a08 <memory_init+0xec>
  memory1->numAddresses = numAddresses;
800049e4:	8f 06       	st.w	r7[0x0],r6
  return memory1;
}
800049e6:	0e 9c       	mov	r12,r7
800049e8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800049ec:	80 00       	ld.sh	r0,r0[0x0]
800049ee:	c1 fc       	rcall	80004a2c <mmu_ppuMemory_writeVerticalMirror+0x14>
800049f0:	80 01       	ld.sh	r1,r0[0x0]
800049f2:	40 f0       	lddsp	r0,sp[0x3c]
800049f4:	80 01       	ld.sh	r1,r0[0x0]
800049f6:	46 44       	lddsp	r4,sp[0x190]
800049f8:	80 01       	ld.sh	r1,r0[0x0]
800049fa:	45 74       	lddsp	r4,sp[0x15c]
800049fc:	80 00       	ld.sh	r0,r0[0x0]
800049fe:	c1 a0       	breq	80004a32 <mmu_ppuMemory_writeVerticalMirror+0x1a>
80004a00:	80 01       	ld.sh	r1,r0[0x0]
80004a02:	45 ac       	lddsp	r12,sp[0x168]
80004a04:	80 01       	ld.sh	r1,r0[0x0]
80004a06:	45 c8       	lddsp	r8,sp[0x170]
80004a08:	80 00       	ld.sh	r0,r0[0x0]
80004a0a:	8e 5c       	ld.sh	r12,r7[0xa]
80004a0c:	80 01       	ld.sh	r1,r0[0x0]
80004a0e:	45 d0       	lddsp	r0,sp[0x174]
80004a10:	80 01       	ld.sh	r1,r0[0x0]
80004a12:	45 f0       	lddsp	r0,sp[0x17c]
80004a14:	80 01       	ld.sh	r1,r0[0x0]
80004a16:	46 10       	lddsp	r0,sp[0x184]

80004a18 <mmu_ppuMemory_writeVerticalMirror>:
  assert(ppuMemory != NULL);
  address -= PPU_NAME_TABLE_SIZE;
  address -= PPU_NAME_TABLE_SIZE;
  return memory_read_callback(nes, ppuMemory, address);
}
void mmu_ppuMemory_writeVerticalMirror(NES nes, Address address, Byte byte) {
80004a18:	eb cd 40 e0 	pushm	r5-r7,lr
80004a1c:	18 97       	mov	r7,r12
80004a1e:	16 96       	mov	r6,r11
80004a20:	14 95       	mov	r5,r10
  assert(nes != NULL);
80004a22:	58 0c       	cp.w	r12,0
80004a24:	c0 71       	brne	80004a32 <mmu_ppuMemory_writeVerticalMirror+0x1a>
80004a26:	48 d9       	lddpc	r9,80004a58 <mmu_ppuMemory_writeVerticalMirror+0x40>
80004a28:	48 da       	lddpc	r10,80004a5c <mmu_ppuMemory_writeVerticalMirror+0x44>
80004a2a:	35 cb       	mov	r11,92
80004a2c:	48 dc       	lddpc	r12,80004a60 <mmu_ppuMemory_writeVerticalMirror+0x48>
80004a2e:	f0 1f 00 0e 	mcall	80004a64 <mmu_ppuMemory_writeVerticalMirror+0x4c>
  Memory ppuMemory = nes_getPPUMemory(nes);
80004a32:	f0 1f 00 0e 	mcall	80004a68 <mmu_ppuMemory_writeVerticalMirror+0x50>
80004a36:	18 9b       	mov	r11,r12
  assert(ppuMemory != NULL);
80004a38:	c0 71       	brne	80004a46 <mmu_ppuMemory_writeVerticalMirror+0x2e>
80004a3a:	48 d9       	lddpc	r9,80004a6c <mmu_ppuMemory_writeVerticalMirror+0x54>
80004a3c:	48 8a       	lddpc	r10,80004a5c <mmu_ppuMemory_writeVerticalMirror+0x44>
80004a3e:	35 eb       	mov	r11,94
80004a40:	48 8c       	lddpc	r12,80004a60 <mmu_ppuMemory_writeVerticalMirror+0x48>
80004a42:	f0 1f 00 09 	mcall	80004a64 <mmu_ppuMemory_writeVerticalMirror+0x4c>
  address -= PPU_NAME_TABLE_SIZE;
  address -= PPU_NAME_TABLE_SIZE;
  memory_write_callback(nes, ppuMemory, address, byte);
80004a46:	ec ca 08 00 	sub	r10,r6,2048
80004a4a:	0a 99       	mov	r9,r5
80004a4c:	5c 7a       	castu.h	r10
80004a4e:	0e 9c       	mov	r12,r7
80004a50:	f0 1f 00 08 	mcall	80004a70 <mmu_ppuMemory_writeVerticalMirror+0x58>
}
80004a54:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004a58:	80 01       	ld.sh	r1,r0[0x0]
80004a5a:	31 44       	mov	r4,20
80004a5c:	80 01       	ld.sh	r1,r0[0x0]
80004a5e:	46 8c       	lddsp	r12,sp[0x1a0]
80004a60:	80 01       	ld.sh	r1,r0[0x0]
80004a62:	46 bc       	lddsp	r12,sp[0x1ac]
80004a64:	80 00       	ld.sh	r0,r0[0x0]
80004a66:	c1 a0       	breq	80004a9a <mmu_ppuMemory_writeHorizontalMirror+0x26>
80004a68:	80 00       	ld.sh	r0,r0[0x0]
80004a6a:	50 98       	stdsp	sp[0x24],r8
80004a6c:	80 01       	ld.sh	r1,r0[0x0]
80004a6e:	46 d0       	lddsp	r0,sp[0x1b4]
80004a70:	80 00       	ld.sh	r0,r0[0x0]
80004a72:	48 d0       	lddpc	r0,80004aa4 <mmu_ppuMemory_writeHorizontalMirror+0x30>

80004a74 <mmu_ppuMemory_writeHorizontalMirror>:
  Memory ppuMemory = nes_getPPUMemory(nes);
  assert(ppuMemory != NULL);
  address -= PPU_NAME_TABLE_SIZE;
  return memory_read_callback(nes, ppuMemory, address);
}
void mmu_ppuMemory_writeHorizontalMirror(NES nes, Address address, Byte byte) {
80004a74:	eb cd 40 e0 	pushm	r5-r7,lr
80004a78:	18 97       	mov	r7,r12
80004a7a:	16 96       	mov	r6,r11
80004a7c:	14 95       	mov	r5,r10
  assert(nes != NULL);
80004a7e:	58 0c       	cp.w	r12,0
80004a80:	c0 71       	brne	80004a8e <mmu_ppuMemory_writeHorizontalMirror+0x1a>
80004a82:	48 d9       	lddpc	r9,80004ab4 <mmu_ppuMemory_writeHorizontalMirror+0x40>
80004a84:	48 da       	lddpc	r10,80004ab8 <mmu_ppuMemory_writeHorizontalMirror+0x44>
80004a86:	34 bb       	mov	r11,75
80004a88:	48 dc       	lddpc	r12,80004abc <mmu_ppuMemory_writeHorizontalMirror+0x48>
80004a8a:	f0 1f 00 0e 	mcall	80004ac0 <mmu_ppuMemory_writeHorizontalMirror+0x4c>
  Memory ppuMemory = nes_getPPUMemory(nes);
80004a8e:	f0 1f 00 0e 	mcall	80004ac4 <mmu_ppuMemory_writeHorizontalMirror+0x50>
80004a92:	18 9b       	mov	r11,r12
  assert(ppuMemory != NULL);
80004a94:	c0 71       	brne	80004aa2 <mmu_ppuMemory_writeHorizontalMirror+0x2e>
80004a96:	48 d9       	lddpc	r9,80004ac8 <mmu_ppuMemory_writeHorizontalMirror+0x54>
80004a98:	48 8a       	lddpc	r10,80004ab8 <mmu_ppuMemory_writeHorizontalMirror+0x44>
80004a9a:	34 db       	mov	r11,77
80004a9c:	48 8c       	lddpc	r12,80004abc <mmu_ppuMemory_writeHorizontalMirror+0x48>
80004a9e:	f0 1f 00 09 	mcall	80004ac0 <mmu_ppuMemory_writeHorizontalMirror+0x4c>
  address -= PPU_NAME_TABLE_SIZE;
  memory_write_callback(nes, ppuMemory, address, byte);
80004aa2:	ec ca 04 00 	sub	r10,r6,1024
80004aa6:	0a 99       	mov	r9,r5
80004aa8:	5c 7a       	castu.h	r10
80004aaa:	0e 9c       	mov	r12,r7
80004aac:	f0 1f 00 08 	mcall	80004acc <mmu_ppuMemory_writeHorizontalMirror+0x58>
}
80004ab0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004ab4:	80 01       	ld.sh	r1,r0[0x0]
80004ab6:	31 44       	mov	r4,20
80004ab8:	80 01       	ld.sh	r1,r0[0x0]
80004aba:	47 6c       	lddsp	r12,sp[0x1d8]
80004abc:	80 01       	ld.sh	r1,r0[0x0]
80004abe:	46 bc       	lddsp	r12,sp[0x1ac]
80004ac0:	80 00       	ld.sh	r0,r0[0x0]
80004ac2:	c1 a0       	breq	80004af6 <mmu_ppuMemory_readVerticalMirror+0x26>
80004ac4:	80 00       	ld.sh	r0,r0[0x0]
80004ac6:	50 98       	stdsp	sp[0x24],r8
80004ac8:	80 01       	ld.sh	r1,r0[0x0]
80004aca:	46 d0       	lddsp	r0,sp[0x1b4]
80004acc:	80 00       	ld.sh	r0,r0[0x0]
80004ace:	48 d0       	lddpc	r0,80004b00 <mmu_ppuMemory_readVerticalMirror+0x30>

80004ad0 <mmu_ppuMemory_readVerticalMirror>:
////////////////////////////////////////////////////////////////////////////////////////
////////////
Byte mmu_ppuMemory_readVerticalMirror(NES nes, Address address) {
80004ad0:	eb cd 40 c0 	pushm	r6-r7,lr
80004ad4:	18 97       	mov	r7,r12
80004ad6:	16 96       	mov	r6,r11
  assert(nes != NULL);
80004ad8:	58 0c       	cp.w	r12,0
80004ada:	c0 71       	brne	80004ae8 <mmu_ppuMemory_readVerticalMirror+0x18>
80004adc:	48 c9       	lddpc	r9,80004b0c <mmu_ppuMemory_readVerticalMirror+0x3c>
80004ade:	48 da       	lddpc	r10,80004b10 <mmu_ppuMemory_readVerticalMirror+0x40>
80004ae0:	35 4b       	mov	r11,84
80004ae2:	48 dc       	lddpc	r12,80004b14 <mmu_ppuMemory_readVerticalMirror+0x44>
80004ae4:	f0 1f 00 0d 	mcall	80004b18 <mmu_ppuMemory_readVerticalMirror+0x48>
  Memory ppuMemory = nes_getPPUMemory(nes);
80004ae8:	f0 1f 00 0d 	mcall	80004b1c <mmu_ppuMemory_readVerticalMirror+0x4c>
80004aec:	18 9b       	mov	r11,r12
  assert(ppuMemory != NULL);
80004aee:	c0 71       	brne	80004afc <mmu_ppuMemory_readVerticalMirror+0x2c>
80004af0:	48 c9       	lddpc	r9,80004b20 <mmu_ppuMemory_readVerticalMirror+0x50>
80004af2:	48 8a       	lddpc	r10,80004b10 <mmu_ppuMemory_readVerticalMirror+0x40>
80004af4:	35 6b       	mov	r11,86
80004af6:	48 8c       	lddpc	r12,80004b14 <mmu_ppuMemory_readVerticalMirror+0x44>
80004af8:	f0 1f 00 08 	mcall	80004b18 <mmu_ppuMemory_readVerticalMirror+0x48>
  address -= PPU_NAME_TABLE_SIZE;
  address -= PPU_NAME_TABLE_SIZE;
  return memory_read_callback(nes, ppuMemory, address);
80004afc:	ec ca 08 00 	sub	r10,r6,2048
80004b00:	5c 7a       	castu.h	r10
80004b02:	0e 9c       	mov	r12,r7
80004b04:	f0 1f 00 08 	mcall	80004b24 <mmu_ppuMemory_readVerticalMirror+0x54>
}
80004b08:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004b0c:	80 01       	ld.sh	r1,r0[0x0]
80004b0e:	31 44       	mov	r4,20
80004b10:	80 01       	ld.sh	r1,r0[0x0]
80004b12:	46 68       	lddsp	r8,sp[0x198]
80004b14:	80 01       	ld.sh	r1,r0[0x0]
80004b16:	46 bc       	lddsp	r12,sp[0x1ac]
80004b18:	80 00       	ld.sh	r0,r0[0x0]
80004b1a:	c1 a0       	breq	80004b4e <mmu_ppuMemory_readHorizontalMirror+0x26>
80004b1c:	80 00       	ld.sh	r0,r0[0x0]
80004b1e:	50 98       	stdsp	sp[0x24],r8
80004b20:	80 01       	ld.sh	r1,r0[0x0]
80004b22:	46 d0       	lddsp	r0,sp[0x1b4]
80004b24:	80 00       	ld.sh	r0,r0[0x0]
80004b26:	48 40       	lddpc	r0,80004b34 <mmu_ppuMemory_readHorizontalMirror+0xc>

80004b28 <mmu_ppuMemory_readHorizontalMirror>:
  assert(mmu != NULL);
  free(mmu);
}
////////////////////////////////////////////////////////////////////////////////////////
////////////
Byte mmu_ppuMemory_readHorizontalMirror(NES nes, Address address) {
80004b28:	eb cd 40 c0 	pushm	r6-r7,lr
80004b2c:	18 97       	mov	r7,r12
80004b2e:	16 96       	mov	r6,r11
  assert(nes != NULL);
80004b30:	58 0c       	cp.w	r12,0
80004b32:	c0 71       	brne	80004b40 <mmu_ppuMemory_readHorizontalMirror+0x18>
80004b34:	48 c9       	lddpc	r9,80004b64 <mmu_ppuMemory_readHorizontalMirror+0x3c>
80004b36:	48 da       	lddpc	r10,80004b68 <mmu_ppuMemory_readHorizontalMirror+0x40>
80004b38:	34 4b       	mov	r11,68
80004b3a:	48 dc       	lddpc	r12,80004b6c <mmu_ppuMemory_readHorizontalMirror+0x44>
80004b3c:	f0 1f 00 0d 	mcall	80004b70 <mmu_ppuMemory_readHorizontalMirror+0x48>
  Memory ppuMemory = nes_getPPUMemory(nes);
80004b40:	f0 1f 00 0d 	mcall	80004b74 <mmu_ppuMemory_readHorizontalMirror+0x4c>
80004b44:	18 9b       	mov	r11,r12
  assert(ppuMemory != NULL);
80004b46:	c0 71       	brne	80004b54 <mmu_ppuMemory_readHorizontalMirror+0x2c>
80004b48:	48 c9       	lddpc	r9,80004b78 <mmu_ppuMemory_readHorizontalMirror+0x50>
80004b4a:	48 8a       	lddpc	r10,80004b68 <mmu_ppuMemory_readHorizontalMirror+0x40>
80004b4c:	34 6b       	mov	r11,70
80004b4e:	48 8c       	lddpc	r12,80004b6c <mmu_ppuMemory_readHorizontalMirror+0x44>
80004b50:	f0 1f 00 08 	mcall	80004b70 <mmu_ppuMemory_readHorizontalMirror+0x48>
  address -= PPU_NAME_TABLE_SIZE;
  return memory_read_callback(nes, ppuMemory, address);
80004b54:	ec ca 04 00 	sub	r10,r6,1024
80004b58:	5c 7a       	castu.h	r10
80004b5a:	0e 9c       	mov	r12,r7
80004b5c:	f0 1f 00 08 	mcall	80004b7c <mmu_ppuMemory_readHorizontalMirror+0x54>
}
80004b60:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004b64:	80 01       	ld.sh	r1,r0[0x0]
80004b66:	31 44       	mov	r4,20
80004b68:	80 01       	ld.sh	r1,r0[0x0]
80004b6a:	47 3c       	lddsp	r12,sp[0x1cc]
80004b6c:	80 01       	ld.sh	r1,r0[0x0]
80004b6e:	46 bc       	lddsp	r12,sp[0x1ac]
80004b70:	80 00       	ld.sh	r0,r0[0x0]
80004b72:	c1 a0       	breq	80004ba6 <mmu_init+0x26>
80004b74:	80 00       	ld.sh	r0,r0[0x0]
80004b76:	50 98       	stdsp	sp[0x24],r8
80004b78:	80 01       	ld.sh	r1,r0[0x0]
80004b7a:	46 d0       	lddsp	r0,sp[0x1b4]
80004b7c:	80 00       	ld.sh	r0,r0[0x0]
80004b7e:	48 40       	lddpc	r0,80004b8c <mmu_init+0xc>

80004b80 <mmu_init>:
struct mmu {
  Byte activeProgramBank_lower;
  Byte activeProgramBank_upper;
  Byte activeCharacterBank;
};
MMU mmu_init(NES nes) {
80004b80:	eb cd 40 c0 	pushm	r6-r7,lr
80004b84:	18 96       	mov	r6,r12
  assert(nes != NULL);
80004b86:	58 0c       	cp.w	r12,0
80004b88:	c0 71       	brne	80004b96 <mmu_init+0x16>
80004b8a:	49 f9       	lddpc	r9,80004c04 <mmu_init+0x84>
80004b8c:	49 fa       	lddpc	r10,80004c08 <mmu_init+0x88>
80004b8e:	31 5b       	mov	r11,21
80004b90:	49 fc       	lddpc	r12,80004c0c <mmu_init+0x8c>
80004b92:	f0 1f 00 20 	mcall	80004c10 <mmu_init+0x90>
  MMU mmu = (MMU) malloc(sizeof(struct mmu));
80004b96:	30 3c       	mov	r12,3
80004b98:	f0 1f 00 1f 	mcall	80004c14 <mmu_init+0x94>
80004b9c:	18 97       	mov	r7,r12
  assert(mmu != NULL);
80004b9e:	c0 71       	brne	80004bac <mmu_init+0x2c>
80004ba0:	49 e9       	lddpc	r9,80004c18 <mmu_init+0x98>
80004ba2:	49 aa       	lddpc	r10,80004c08 <mmu_init+0x88>
80004ba4:	31 7b       	mov	r11,23
80004ba6:	49 ac       	lddpc	r12,80004c0c <mmu_init+0x8c>
80004ba8:	f0 1f 00 1a 	mcall	80004c10 <mmu_init+0x90>
  mmu->activeProgramBank_lower = 0;
80004bac:	30 08       	mov	r8,0
80004bae:	b8 88       	st.b	r12[0x0],r8
  mmu->activeProgramBank_upper = 0;
80004bb0:	b8 98       	st.b	r12[0x1],r8
  mmu->activeCharacterBank = 0;
80004bb2:	b8 a8       	st.b	r12[0x2],r8
  Cartridge cartridge = nes_getCartridge(nes);
80004bb4:	0c 9c       	mov	r12,r6
80004bb6:	f0 1f 00 1a 	mcall	80004c1c <mmu_init+0x9c>
  assert(cartridge != NULL);
80004bba:	c0 71       	brne	80004bc8 <mmu_init+0x48>
80004bbc:	49 99       	lddpc	r9,80004c20 <mmu_init+0xa0>
80004bbe:	49 3a       	lddpc	r10,80004c08 <mmu_init+0x88>
80004bc0:	31 cb       	mov	r11,28
80004bc2:	49 3c       	lddpc	r12,80004c0c <mmu_init+0x8c>
80004bc4:	f0 1f 00 13 	mcall	80004c10 <mmu_init+0x90>
  Byte mmuNumber = cartridge_getMMUNumber(cartridge);
80004bc8:	f0 1f 00 17 	mcall	80004c24 <mmu_init+0xa4>
  assert(mmuNumber < num_mmu_callbackCreators);
80004bcc:	49 78       	lddpc	r8,80004c28 <mmu_init+0xa8>
80004bce:	70 08       	ld.w	r8,r8[0x0]
80004bd0:	10 3c       	cp.w	r12,r8
80004bd2:	c0 75       	brlt	80004be0 <mmu_init+0x60>
80004bd4:	49 69       	lddpc	r9,80004c2c <mmu_init+0xac>
80004bd6:	48 da       	lddpc	r10,80004c08 <mmu_init+0x88>
80004bd8:	31 eb       	mov	r11,30
80004bda:	48 dc       	lddpc	r12,80004c0c <mmu_init+0x8c>
80004bdc:	f0 1f 00 0d 	mcall	80004c10 <mmu_init+0x90>
  MMU_CallbackCreator mmu_callbackCreator = mmu_callbackCreators[mmuNumber];
80004be0:	49 48       	lddpc	r8,80004c30 <mmu_init+0xb0>
80004be2:	f0 0c 03 28 	ld.w	r8,r8[r12<<0x2]
 // MMU_CallbackCreator mmu_callbackCreator = mmu_callbackCreators[0];
  assert(mmu_callbackCreator != NULL);
80004be6:	58 08       	cp.w	r8,0
80004be8:	c0 71       	brne	80004bf6 <mmu_init+0x76>
80004bea:	49 39       	lddpc	r9,80004c34 <mmu_init+0xb4>
80004bec:	48 7a       	lddpc	r10,80004c08 <mmu_init+0x88>
80004bee:	32 1b       	mov	r11,33
80004bf0:	48 7c       	lddpc	r12,80004c0c <mmu_init+0x8c>
80004bf2:	f0 1f 00 08 	mcall	80004c10 <mmu_init+0x90>
  mmu_callbackCreator(nes, mmu);
80004bf6:	0e 9b       	mov	r11,r7
80004bf8:	0c 9c       	mov	r12,r6
80004bfa:	5d 18       	icall	r8
  return mmu;
}
80004bfc:	0e 9c       	mov	r12,r7
80004bfe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c02:	00 00       	add	r0,r0
80004c04:	80 01       	ld.sh	r1,r0[0x0]
80004c06:	31 44       	mov	r4,20
80004c08:	80 01       	ld.sh	r1,r0[0x0]
80004c0a:	47 60       	lddsp	r0,sp[0x1d8]
80004c0c:	80 01       	ld.sh	r1,r0[0x0]
80004c0e:	46 bc       	lddsp	r12,sp[0x1ac]
80004c10:	80 00       	ld.sh	r0,r0[0x0]
80004c12:	c1 a0       	breq	80004c46 <mmu0_ppuMemory_writePattern+0xe>
80004c14:	80 00       	ld.sh	r0,r0[0x0]
80004c16:	c1 fc       	rcall	80004c54 <mmu0_ppuMemory_writePattern+0x1c>
80004c18:	80 01       	ld.sh	r1,r0[0x0]
80004c1a:	46 b0       	lddsp	r0,sp[0x1ac]
80004c1c:	80 00       	ld.sh	r0,r0[0x0]
80004c1e:	50 34       	stdsp	sp[0xc],r4
80004c20:	80 01       	ld.sh	r1,r0[0x0]
80004c22:	46 e4       	lddsp	r4,sp[0x1b8]
80004c24:	80 00       	ld.sh	r0,r0[0x0]
80004c26:	22 88       	sub	r8,40
80004c28:	00 00       	add	r0,r0
80004c2a:	00 08       	add	r8,r0
80004c2c:	80 01       	ld.sh	r1,r0[0x0]
80004c2e:	46 f8       	lddsp	r8,sp[0x1bc]
80004c30:	00 00       	add	r0,r0
80004c32:	00 0c       	add	r12,r0
80004c34:	80 01       	ld.sh	r1,r0[0x0]
80004c36:	47 20       	lddsp	r0,sp[0x1c8]

80004c38 <mmu0_ppuMemory_writePattern>:
  assert(nes != NULL);
  Cartridge cartridge = nes_getCartridge(nes);
  assert(cartridge != NULL);
  return cartridge_readCharacterBank(cartridge, 0, address);
}
static void mmu0_ppuMemory_writePattern(NES nes, Address address, Byte byte) {
80004c38:	d4 01       	pushm	lr
  assert(nes != NULL);
80004c3a:	58 0c       	cp.w	r12,0
80004c3c:	c0 71       	brne	80004c4a <mmu0_ppuMemory_writePattern+0x12>
80004c3e:	48 49       	lddpc	r9,80004c4c <mmu0_ppuMemory_writePattern+0x14>
80004c40:	48 4a       	lddpc	r10,80004c50 <mmu0_ppuMemory_writePattern+0x18>
80004c42:	34 7b       	mov	r11,71
80004c44:	48 4c       	lddpc	r12,80004c54 <mmu0_ppuMemory_writePattern+0x1c>
80004c46:	f0 1f 00 05 	mcall	80004c58 <mmu0_ppuMemory_writePattern+0x20>
80004c4a:	d8 02       	popm	pc
80004c4c:	80 01       	ld.sh	r1,r0[0x0]
80004c4e:	31 44       	mov	r4,20
80004c50:	80 01       	ld.sh	r1,r0[0x0]
80004c52:	47 b0       	lddsp	r0,sp[0x1ec]
80004c54:	80 01       	ld.sh	r1,r0[0x0]
80004c56:	47 e4       	lddsp	r4,sp[0x1f8]
80004c58:	80 00       	ld.sh	r0,r0[0x0]
80004c5a:	c1 a0       	breq	80004c8e <mmu0_cpuMemory_writeProgramBank0+0x32>

80004c5c <mmu0_cpuMemory_writeProgramBank0>:
  Cartridge cartridge = nes_getCartridge(nes);
  assert(nes != NULL);
  assert(0 < cartridge_getNumProgramBanks(cartridge));
  return cartridge_readProgramBank(cartridge, 0, address);
}
static void mmu0_cpuMemory_writeProgramBank0(NES nes, Address address, Byte byte) {
80004c5c:	d4 01       	pushm	lr
  assert(nes != NULL);
80004c5e:	58 0c       	cp.w	r12,0
80004c60:	c0 71       	brne	80004c6e <mmu0_cpuMemory_writeProgramBank0+0x12>
80004c62:	48 b9       	lddpc	r9,80004c8c <mmu0_cpuMemory_writeProgramBank0+0x30>
80004c64:	48 ba       	lddpc	r10,80004c90 <mmu0_cpuMemory_writeProgramBank0+0x34>
80004c66:	32 5b       	mov	r11,37
80004c68:	48 bc       	lddpc	r12,80004c94 <mmu0_cpuMemory_writeProgramBank0+0x38>
80004c6a:	f0 1f 00 0c 	mcall	80004c98 <mmu0_cpuMemory_writeProgramBank0+0x3c>
  Memory memory = nes_getCPUMemory(nes);
80004c6e:	f0 1f 00 0c 	mcall	80004c9c <mmu0_cpuMemory_writeProgramBank0+0x40>
  assert(memory != NULL);
80004c72:	c0 71       	brne	80004c80 <mmu0_cpuMemory_writeProgramBank0+0x24>
80004c74:	48 b9       	lddpc	r9,80004ca0 <mmu0_cpuMemory_writeProgramBank0+0x44>
80004c76:	48 7a       	lddpc	r10,80004c90 <mmu0_cpuMemory_writeProgramBank0+0x34>
80004c78:	32 7b       	mov	r11,39
80004c7a:	48 7c       	lddpc	r12,80004c94 <mmu0_cpuMemory_writeProgramBank0+0x38>
80004c7c:	f0 1f 00 07 	mcall	80004c98 <mmu0_cpuMemory_writeProgramBank0+0x3c>
  // not allowed to write to ROM
  assert(FALSE);
80004c80:	48 99       	lddpc	r9,80004ca4 <mmu0_cpuMemory_writeProgramBank0+0x48>
80004c82:	48 4a       	lddpc	r10,80004c90 <mmu0_cpuMemory_writeProgramBank0+0x34>
80004c84:	32 9b       	mov	r11,41
80004c86:	48 4c       	lddpc	r12,80004c94 <mmu0_cpuMemory_writeProgramBank0+0x38>
80004c88:	f0 1f 00 04 	mcall	80004c98 <mmu0_cpuMemory_writeProgramBank0+0x3c>
80004c8c:	80 01       	ld.sh	r1,r0[0x0]
80004c8e:	31 44       	mov	r4,20
80004c90:	80 01       	ld.sh	r1,r0[0x0]
80004c92:	48 90       	lddpc	r0,80004cb4 <mmu0_callbackCreator+0xc>
80004c94:	80 01       	ld.sh	r1,r0[0x0]
80004c96:	47 e4       	lddsp	r4,sp[0x1f8]
80004c98:	80 00       	ld.sh	r0,r0[0x0]
80004c9a:	c1 a0       	breq	80004cce <mmu0_callbackCreator+0x26>
80004c9c:	80 00       	ld.sh	r0,r0[0x0]
80004c9e:	50 c0       	stdsp	sp[0x30],r0
80004ca0:	80 01       	ld.sh	r1,r0[0x0]
80004ca2:	45 64       	lddsp	r4,sp[0x158]
80004ca4:	80 01       	ld.sh	r1,r0[0x0]
80004ca6:	56 cc       	stdsp	sp[0x1b0],r12

80004ca8 <mmu0_callbackCreator>:
  assert(nes != NULL);
  //assert(FALSE); // can't write to ROM
}
////////////////////////////////////////////////////////////////////////////////////////
////////////
void mmu0_callbackCreator(NES nes, MMU mmu) {
80004ca8:	eb cd 40 fe 	pushm	r1-r7,lr
80004cac:	18 92       	mov	r2,r12
  assert(nes != NULL);
80004cae:	58 0c       	cp.w	r12,0
80004cb0:	c0 a1       	brne	80004cc4 <mmu0_callbackCreator+0x1c>
80004cb2:	fe f9 02 0e 	ld.w	r9,pc[526]
80004cb6:	fe fa 02 0e 	ld.w	r10,pc[526]
80004cba:	34 db       	mov	r11,77
80004cbc:	fe fc 02 0c 	ld.w	r12,pc[524]
80004cc0:	f0 1f 00 83 	mcall	80004ecc <mmu0_callbackCreator+0x224>
  assert(mmu != NULL);
80004cc4:	58 0b       	cp.w	r11,0
80004cc6:	c0 81       	brne	80004cd6 <mmu0_callbackCreator+0x2e>
80004cc8:	fe f9 02 08 	ld.w	r9,pc[520]
80004ccc:	4f ea       	lddpc	r10,80004ec4 <mmu0_callbackCreator+0x21c>
80004cce:	34 eb       	mov	r11,78
80004cd0:	4f ec       	lddpc	r12,80004ec8 <mmu0_callbackCreator+0x220>
80004cd2:	f0 1f 00 7f 	mcall	80004ecc <mmu0_callbackCreator+0x224>
  usart_write_line(&AVR32_USART0,"mmu0_callbackCreator\n");
80004cd6:	fe fb 01 fe 	ld.w	r11,pc[510]
80004cda:	fe 7c 14 00 	mov	r12,-60416
80004cde:	f0 1f 00 7f 	mcall	80004ed8 <mmu0_callbackCreator+0x230>
  Memory cpuMemory = nes_getCPUMemory(nes);
80004ce2:	04 9c       	mov	r12,r2
80004ce4:	f0 1f 00 7e 	mcall	80004edc <mmu0_callbackCreator+0x234>
80004ce8:	18 95       	mov	r5,r12
  assert(cpuMemory != NULL);
80004cea:	c0 71       	brne	80004cf8 <mmu0_callbackCreator+0x50>
80004cec:	4f d9       	lddpc	r9,80004ee0 <mmu0_callbackCreator+0x238>
80004cee:	4f 6a       	lddpc	r10,80004ec4 <mmu0_callbackCreator+0x21c>
80004cf0:	35 1b       	mov	r11,81
80004cf2:	4f 6c       	lddpc	r12,80004ec8 <mmu0_callbackCreator+0x220>
80004cf4:	f0 1f 00 76 	mcall	80004ecc <mmu0_callbackCreator+0x224>
80004cf8:	e0 67 80 00 	mov	r7,32768
  int i;
  for (i = MMU_PROGRAM_BANK_LOWER_FIRST_ADDRESS; i <=MMU_PROGRAM_BANK_LOWER_LAST_ADDRESS; i++) {
    //memory_setWriteCallback(cpuMemory, i, &mmu0_cpuMemory_writeProgramBank0);
    memory_setReadCallback(cpuMemory, i, &mmu0_cpuMemory_readProgramBank0);
80004cfc:	4f a6       	lddpc	r6,80004ee4 <mmu0_callbackCreator+0x23c>
80004cfe:	0c 9a       	mov	r10,r6
80004d00:	0e 9b       	mov	r11,r7
80004d02:	0a 9c       	mov	r12,r5
80004d04:	f0 1f 00 79 	mcall	80004ee8 <mmu0_callbackCreator+0x240>
  assert(mmu != NULL);
  usart_write_line(&AVR32_USART0,"mmu0_callbackCreator\n");
  Memory cpuMemory = nes_getCPUMemory(nes);
  assert(cpuMemory != NULL);
  int i;
  for (i = MMU_PROGRAM_BANK_LOWER_FIRST_ADDRESS; i <=MMU_PROGRAM_BANK_LOWER_LAST_ADDRESS; i++) {
80004d08:	2f f7       	sub	r7,-1
80004d0a:	e0 47 c0 00 	cp.w	r7,49152
80004d0e:	cf 81       	brne	80004cfe <mmu0_callbackCreator+0x56>
    //memory_setWriteCallback(cpuMemory, i, &mmu0_cpuMemory_writeProgramBank0);
    memory_setReadCallback(cpuMemory, i, &mmu0_cpuMemory_readProgramBank0);
  }
  Cartridge cartridge = nes_getCartridge(nes);
80004d10:	04 9c       	mov	r12,r2
80004d12:	f0 1f 00 77 	mcall	80004eec <mmu0_callbackCreator+0x244>
80004d16:	18 91       	mov	r1,r12
  assert(cartridge != NULL);
80004d18:	c0 71       	brne	80004d26 <mmu0_callbackCreator+0x7e>
80004d1a:	4f 69       	lddpc	r9,80004ef0 <mmu0_callbackCreator+0x248>
80004d1c:	4e aa       	lddpc	r10,80004ec4 <mmu0_callbackCreator+0x21c>
80004d1e:	35 8b       	mov	r11,88
80004d20:	4e ac       	lddpc	r12,80004ec8 <mmu0_callbackCreator+0x220>
80004d22:	f0 1f 00 6b 	mcall	80004ecc <mmu0_callbackCreator+0x224>
  Byte numProgramBanks = cartridge_getNumProgramBanks(cartridge);
80004d26:	f0 1f 00 74 	mcall	80004ef4 <mmu0_callbackCreator+0x24c>
80004d2a:	18 96       	mov	r6,r12
  usart_write_char(&AVR32_USART0,numProgramBanks+0x30);
80004d2c:	f8 cb ff d0 	sub	r11,r12,-48
80004d30:	fe 7c 14 00 	mov	r12,-60416
80004d34:	f0 1f 00 71 	mcall	80004ef8 <mmu0_callbackCreator+0x250>
  // mmu0 only supports 1 or 2 program banks on the cartridge
  assert(numProgramBanks >= 1);
80004d38:	58 06       	cp.w	r6,0
80004d3a:	c0 71       	brne	80004d48 <mmu0_callbackCreator+0xa0>
80004d3c:	4f 09       	lddpc	r9,80004efc <mmu0_callbackCreator+0x254>
80004d3e:	4e 2a       	lddpc	r10,80004ec4 <mmu0_callbackCreator+0x21c>
80004d40:	35 cb       	mov	r11,92
80004d42:	4e 2c       	lddpc	r12,80004ec8 <mmu0_callbackCreator+0x220>
80004d44:	f0 1f 00 62 	mcall	80004ecc <mmu0_callbackCreator+0x224>
  assert(numProgramBanks <= 2);
80004d48:	30 28       	mov	r8,2
80004d4a:	f0 06 18 00 	cp.b	r6,r8
80004d4e:	e0 88 00 08 	brls	80004d5e <mmu0_callbackCreator+0xb6>
80004d52:	4e c9       	lddpc	r9,80004f00 <mmu0_callbackCreator+0x258>
80004d54:	4d ca       	lddpc	r10,80004ec4 <mmu0_callbackCreator+0x21c>
80004d56:	35 db       	mov	r11,93
80004d58:	4d cc       	lddpc	r12,80004ec8 <mmu0_callbackCreator+0x220>
80004d5a:	f0 1f 00 5d 	mcall	80004ecc <mmu0_callbackCreator+0x224>
  if (numProgramBanks == 1) {
80004d5e:	30 18       	mov	r8,1
80004d60:	f0 06 18 00 	cp.b	r6,r8
80004d64:	c1 41       	brne	80004d8c <mmu0_callbackCreator+0xe4>
    // mirror the first bank if there is only one
    for (i = MMU_PROGRAM_BANK_UPPER_FIRST_ADDRESS; i <=
MMU_PROGRAM_BANK_UPPER_LAST_ADDRESS; i++) {
      memory_setWriteCallback(cpuMemory, i, &mmu0_cpuMemory_writeProgramBank0);
80004d66:	4e 84       	lddpc	r4,80004f04 <mmu0_callbackCreator+0x25c>
      memory_setReadCallback(cpuMemory, i, &mmu0_cpuMemory_readProgramBank0);
80004d68:	4d f3       	lddpc	r3,80004ee4 <mmu0_callbackCreator+0x23c>
  assert(numProgramBanks <= 2);
  if (numProgramBanks == 1) {
    // mirror the first bank if there is only one
    for (i = MMU_PROGRAM_BANK_UPPER_FIRST_ADDRESS; i <=
MMU_PROGRAM_BANK_UPPER_LAST_ADDRESS; i++) {
      memory_setWriteCallback(cpuMemory, i, &mmu0_cpuMemory_writeProgramBank0);
80004d6a:	0e 96       	mov	r6,r7
80004d6c:	5c 76       	castu.h	r6
80004d6e:	08 9a       	mov	r10,r4
80004d70:	0c 9b       	mov	r11,r6
80004d72:	0a 9c       	mov	r12,r5
80004d74:	f0 1f 00 65 	mcall	80004f08 <mmu0_callbackCreator+0x260>
      memory_setReadCallback(cpuMemory, i, &mmu0_cpuMemory_readProgramBank0);
80004d78:	06 9a       	mov	r10,r3
80004d7a:	0c 9b       	mov	r11,r6
80004d7c:	0a 9c       	mov	r12,r5
80004d7e:	f0 1f 00 5b 	mcall	80004ee8 <mmu0_callbackCreator+0x240>
  assert(numProgramBanks >= 1);
  assert(numProgramBanks <= 2);
  if (numProgramBanks == 1) {
    // mirror the first bank if there is only one
    for (i = MMU_PROGRAM_BANK_UPPER_FIRST_ADDRESS; i <=
MMU_PROGRAM_BANK_UPPER_LAST_ADDRESS; i++) {
80004d82:	2f f7       	sub	r7,-1
  // mmu0 only supports 1 or 2 program banks on the cartridge
  assert(numProgramBanks >= 1);
  assert(numProgramBanks <= 2);
  if (numProgramBanks == 1) {
    // mirror the first bank if there is only one
    for (i = MMU_PROGRAM_BANK_UPPER_FIRST_ADDRESS; i <=
80004d84:	e0 57 00 00 	cp.w	r7,65536
80004d88:	cf 11       	brne	80004d6a <mmu0_callbackCreator+0xc2>
80004d8a:	c1 08       	rjmp	80004daa <mmu0_callbackCreator+0x102>
MMU_PROGRAM_BANK_UPPER_LAST_ADDRESS; i++) {
      memory_setWriteCallback(cpuMemory, i, &mmu0_cpuMemory_writeProgramBank0);
      memory_setReadCallback(cpuMemory, i, &mmu0_cpuMemory_readProgramBank0);
    }
  } else if (numProgramBanks == 2) {
80004d8c:	30 28       	mov	r8,2
80004d8e:	f0 06 18 00 	cp.b	r6,r8
80004d92:	c0 c1       	brne	80004daa <mmu0_callbackCreator+0x102>
    for (i = MMU_PROGRAM_BANK_UPPER_FIRST_ADDRESS; i <=MMU_PROGRAM_BANK_UPPER_LAST_ADDRESS; i++) {
      //memory_setWriteCallback(cpuMemory, i, &mmu0_cpuMemory_writeProgramBank1);
      memory_setReadCallback(cpuMemory, i, &mmu0_cpuMemory_readProgramBank1);
80004d94:	4d e6       	lddpc	r6,80004f0c <mmu0_callbackCreator+0x264>
80004d96:	0c 9a       	mov	r10,r6
80004d98:	0e 9b       	mov	r11,r7
80004d9a:	5c 7b       	castu.h	r11
80004d9c:	0a 9c       	mov	r12,r5
80004d9e:	f0 1f 00 53 	mcall	80004ee8 <mmu0_callbackCreator+0x240>
MMU_PROGRAM_BANK_UPPER_LAST_ADDRESS; i++) {
      memory_setWriteCallback(cpuMemory, i, &mmu0_cpuMemory_writeProgramBank0);
      memory_setReadCallback(cpuMemory, i, &mmu0_cpuMemory_readProgramBank0);
    }
  } else if (numProgramBanks == 2) {
    for (i = MMU_PROGRAM_BANK_UPPER_FIRST_ADDRESS; i <=MMU_PROGRAM_BANK_UPPER_LAST_ADDRESS; i++) {
80004da2:	2f f7       	sub	r7,-1
80004da4:	e0 57 00 00 	cp.w	r7,65536
80004da8:	cf 71       	brne	80004d96 <mmu0_callbackCreator+0xee>
      //memory_setWriteCallback(cpuMemory, i, &mmu0_cpuMemory_writeProgramBank1);
      memory_setReadCallback(cpuMemory, i, &mmu0_cpuMemory_readProgramBank1);
    }
  }
  Byte numCharacterBanks = cartridge_getNumCharacterBanks(cartridge);
80004daa:	02 9c       	mov	r12,r1
80004dac:	f0 1f 00 59 	mcall	80004f10 <mmu0_callbackCreator+0x268>
80004db0:	18 96       	mov	r6,r12
  assert(numCharacterBanks <= 1);
80004db2:	30 18       	mov	r8,1
80004db4:	f0 0c 18 00 	cp.b	r12,r8
80004db8:	e0 88 00 08 	brls	80004dc8 <mmu0_callbackCreator+0x120>
80004dbc:	4d 69       	lddpc	r9,80004f14 <mmu0_callbackCreator+0x26c>
80004dbe:	4c 2a       	lddpc	r10,80004ec4 <mmu0_callbackCreator+0x21c>
80004dc0:	36 cb       	mov	r11,108
80004dc2:	4c 2c       	lddpc	r12,80004ec8 <mmu0_callbackCreator+0x220>
80004dc4:	f0 1f 00 42 	mcall	80004ecc <mmu0_callbackCreator+0x224>
  Memory ppuMemory = nes_getPPUMemory(nes);
80004dc8:	04 9c       	mov	r12,r2
80004dca:	f0 1f 00 54 	mcall	80004f18 <mmu0_callbackCreator+0x270>
80004dce:	18 97       	mov	r7,r12
  assert(ppuMemory != NULL);
80004dd0:	c0 71       	brne	80004dde <mmu0_callbackCreator+0x136>
80004dd2:	4d 39       	lddpc	r9,80004f1c <mmu0_callbackCreator+0x274>
80004dd4:	4b ca       	lddpc	r10,80004ec4 <mmu0_callbackCreator+0x21c>
80004dd6:	36 eb       	mov	r11,110
80004dd8:	4b cc       	lddpc	r12,80004ec8 <mmu0_callbackCreator+0x220>
80004dda:	f0 1f 00 3d 	mcall	80004ecc <mmu0_callbackCreator+0x224>
  if (numCharacterBanks == 1) {
80004dde:	30 18       	mov	r8,1
80004de0:	f0 06 18 00 	cp.b	r6,r8
80004de4:	c1 21       	brne	80004e08 <mmu0_callbackCreator+0x160>
80004de6:	30 06       	mov	r6,0
    // dump it in the lower space of ppu memory
    for (i = PPU_PATTERN_TABLE_0_FIRST_ADDRESS; i <= PPU_PATTERN_TABLE_1_LAST_ADDRESS;
i++) {
      memory_setWriteCallback(ppuMemory, i, &mmu0_ppuMemory_writePattern);
80004de8:	4c e5       	lddpc	r5,80004f20 <mmu0_callbackCreator+0x278>
      memory_setReadCallback(ppuMemory, i, &mmu0_ppuMemory_readPattern);
80004dea:	4c f4       	lddpc	r4,80004f24 <mmu0_callbackCreator+0x27c>
  assert(ppuMemory != NULL);
  if (numCharacterBanks == 1) {
    // dump it in the lower space of ppu memory
    for (i = PPU_PATTERN_TABLE_0_FIRST_ADDRESS; i <= PPU_PATTERN_TABLE_1_LAST_ADDRESS;
i++) {
      memory_setWriteCallback(ppuMemory, i, &mmu0_ppuMemory_writePattern);
80004dec:	0a 9a       	mov	r10,r5
80004dee:	0c 9b       	mov	r11,r6
80004df0:	0e 9c       	mov	r12,r7
80004df2:	f0 1f 00 46 	mcall	80004f08 <mmu0_callbackCreator+0x260>
      memory_setReadCallback(ppuMemory, i, &mmu0_ppuMemory_readPattern);
80004df6:	08 9a       	mov	r10,r4
80004df8:	0c 9b       	mov	r11,r6
80004dfa:	0e 9c       	mov	r12,r7
80004dfc:	f0 1f 00 3b 	mcall	80004ee8 <mmu0_callbackCreator+0x240>
  Memory ppuMemory = nes_getPPUMemory(nes);
  assert(ppuMemory != NULL);
  if (numCharacterBanks == 1) {
    // dump it in the lower space of ppu memory
    for (i = PPU_PATTERN_TABLE_0_FIRST_ADDRESS; i <= PPU_PATTERN_TABLE_1_LAST_ADDRESS;
i++) {
80004e00:	2f f6       	sub	r6,-1
  assert(numCharacterBanks <= 1);
  Memory ppuMemory = nes_getPPUMemory(nes);
  assert(ppuMemory != NULL);
  if (numCharacterBanks == 1) {
    // dump it in the lower space of ppu memory
    for (i = PPU_PATTERN_TABLE_0_FIRST_ADDRESS; i <= PPU_PATTERN_TABLE_1_LAST_ADDRESS;
80004e02:	e0 46 20 00 	cp.w	r6,8192
80004e06:	cf 31       	brne	80004dec <mmu0_callbackCreator+0x144>
i++) {
      memory_setWriteCallback(ppuMemory, i, &mmu0_ppuMemory_writePattern);
      memory_setReadCallback(ppuMemory, i, &mmu0_ppuMemory_readPattern);
    }
  }
  MirrorType mirrorType = cartridge_getMirrorType(cartridge);
80004e08:	02 9c       	mov	r12,r1
80004e0a:	f0 1f 00 48 	mcall	80004f28 <mmu0_callbackCreator+0x280>
  if (mirrorType == HORIZONTAL) {
80004e0e:	c2 71       	brne	80004e5c <mmu0_callbackCreator+0x1b4>
80004e10:	e0 66 24 00 	mov	r6,9216
    for (i = PPU_NAME_TABLE_1_FIRST_ADDRESS; i <= PPU_NAME_TABLE_1_LAST_ADDRESS; i++) {
      // map it back to table 0
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeHorizontalMirror);
80004e14:	4c 65       	lddpc	r5,80004f2c <mmu0_callbackCreator+0x284>
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readHorizontalMirror);
80004e16:	4c 74       	lddpc	r4,80004f30 <mmu0_callbackCreator+0x288>
  }
  MirrorType mirrorType = cartridge_getMirrorType(cartridge);
  if (mirrorType == HORIZONTAL) {
    for (i = PPU_NAME_TABLE_1_FIRST_ADDRESS; i <= PPU_NAME_TABLE_1_LAST_ADDRESS; i++) {
      // map it back to table 0
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeHorizontalMirror);
80004e18:	0a 9a       	mov	r10,r5
80004e1a:	0c 9b       	mov	r11,r6
80004e1c:	0e 9c       	mov	r12,r7
80004e1e:	f0 1f 00 3b 	mcall	80004f08 <mmu0_callbackCreator+0x260>
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readHorizontalMirror);
80004e22:	08 9a       	mov	r10,r4
80004e24:	0c 9b       	mov	r11,r6
80004e26:	0e 9c       	mov	r12,r7
80004e28:	f0 1f 00 30 	mcall	80004ee8 <mmu0_callbackCreator+0x240>
      memory_setReadCallback(ppuMemory, i, &mmu0_ppuMemory_readPattern);
    }
  }
  MirrorType mirrorType = cartridge_getMirrorType(cartridge);
  if (mirrorType == HORIZONTAL) {
    for (i = PPU_NAME_TABLE_1_FIRST_ADDRESS; i <= PPU_NAME_TABLE_1_LAST_ADDRESS; i++) {
80004e2c:	2f f6       	sub	r6,-1
80004e2e:	e0 46 28 00 	cp.w	r6,10240
80004e32:	cf 31       	brne	80004e18 <mmu0_callbackCreator+0x170>
80004e34:	e0 66 2c 00 	mov	r6,11264
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeHorizontalMirror);
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readHorizontalMirror);
    }
    for (i = PPU_NAME_TABLE_3_FIRST_ADDRESS; i <= PPU_NAME_TABLE_3_LAST_ADDRESS; i++) {
      // map it back to table 2
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeHorizontalMirror);
80004e38:	4b d5       	lddpc	r5,80004f2c <mmu0_callbackCreator+0x284>
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readHorizontalMirror);
80004e3a:	4b e4       	lddpc	r4,80004f30 <mmu0_callbackCreator+0x288>
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeHorizontalMirror);
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readHorizontalMirror);
    }
    for (i = PPU_NAME_TABLE_3_FIRST_ADDRESS; i <= PPU_NAME_TABLE_3_LAST_ADDRESS; i++) {
      // map it back to table 2
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeHorizontalMirror);
80004e3c:	0a 9a       	mov	r10,r5
80004e3e:	0c 9b       	mov	r11,r6
80004e40:	0e 9c       	mov	r12,r7
80004e42:	f0 1f 00 32 	mcall	80004f08 <mmu0_callbackCreator+0x260>
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readHorizontalMirror);
80004e46:	08 9a       	mov	r10,r4
80004e48:	0c 9b       	mov	r11,r6
80004e4a:	0e 9c       	mov	r12,r7
80004e4c:	f0 1f 00 27 	mcall	80004ee8 <mmu0_callbackCreator+0x240>
    for (i = PPU_NAME_TABLE_1_FIRST_ADDRESS; i <= PPU_NAME_TABLE_1_LAST_ADDRESS; i++) {
      // map it back to table 0
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeHorizontalMirror);
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readHorizontalMirror);
    }
    for (i = PPU_NAME_TABLE_3_FIRST_ADDRESS; i <= PPU_NAME_TABLE_3_LAST_ADDRESS; i++) {
80004e50:	2f f6       	sub	r6,-1
80004e52:	e0 46 30 00 	cp.w	r6,12288
80004e56:	cf 31       	brne	80004e3c <mmu0_callbackCreator+0x194>
80004e58:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
      // map it back to table 2
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeHorizontalMirror);
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readHorizontalMirror);
    }
  } else if (mirrorType == VERTICAL) {
80004e5c:	58 1c       	cp.w	r12,1
80004e5e:	c2 51       	brne	80004ea8 <mmu0_callbackCreator+0x200>
80004e60:	e0 66 28 00 	mov	r6,10240
    // Vertical mirroring: $2000 equals $2800 and $2400 equals $2C00 (e.g. Super MarioBros.)
    for (i = PPU_NAME_TABLE_2_FIRST_ADDRESS; i <= PPU_NAME_TABLE_2_LAST_ADDRESS; i++) {
      // map it back to table 0
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeVerticalMirror);
80004e64:	4b 45       	lddpc	r5,80004f34 <mmu0_callbackCreator+0x28c>
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readVerticalMirror);
80004e66:	4b 54       	lddpc	r4,80004f38 <mmu0_callbackCreator+0x290>
    }
  } else if (mirrorType == VERTICAL) {
    // Vertical mirroring: $2000 equals $2800 and $2400 equals $2C00 (e.g. Super MarioBros.)
    for (i = PPU_NAME_TABLE_2_FIRST_ADDRESS; i <= PPU_NAME_TABLE_2_LAST_ADDRESS; i++) {
      // map it back to table 0
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeVerticalMirror);
80004e68:	0a 9a       	mov	r10,r5
80004e6a:	0c 9b       	mov	r11,r6
80004e6c:	0e 9c       	mov	r12,r7
80004e6e:	f0 1f 00 27 	mcall	80004f08 <mmu0_callbackCreator+0x260>
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readVerticalMirror);
80004e72:	08 9a       	mov	r10,r4
80004e74:	0c 9b       	mov	r11,r6
80004e76:	0e 9c       	mov	r12,r7
80004e78:	f0 1f 00 1c 	mcall	80004ee8 <mmu0_callbackCreator+0x240>
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeHorizontalMirror);
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readHorizontalMirror);
    }
  } else if (mirrorType == VERTICAL) {
    // Vertical mirroring: $2000 equals $2800 and $2400 equals $2C00 (e.g. Super MarioBros.)
    for (i = PPU_NAME_TABLE_2_FIRST_ADDRESS; i <= PPU_NAME_TABLE_2_LAST_ADDRESS; i++) {
80004e7c:	2f f6       	sub	r6,-1
80004e7e:	e0 46 2c 00 	cp.w	r6,11264
80004e82:	cf 31       	brne	80004e68 <mmu0_callbackCreator+0x1c0>
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeVerticalMirror);
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readVerticalMirror);
    }
    for (i = PPU_NAME_TABLE_3_FIRST_ADDRESS; i <= PPU_NAME_TABLE_3_LAST_ADDRESS; i++) {
      // map it back to table 1
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeVerticalMirror);
80004e84:	4a c5       	lddpc	r5,80004f34 <mmu0_callbackCreator+0x28c>
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readVerticalMirror);
80004e86:	4a d4       	lddpc	r4,80004f38 <mmu0_callbackCreator+0x290>
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeVerticalMirror);
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readVerticalMirror);
    }
    for (i = PPU_NAME_TABLE_3_FIRST_ADDRESS; i <= PPU_NAME_TABLE_3_LAST_ADDRESS; i++) {
      // map it back to table 1
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeVerticalMirror);
80004e88:	0a 9a       	mov	r10,r5
80004e8a:	0c 9b       	mov	r11,r6
80004e8c:	0e 9c       	mov	r12,r7
80004e8e:	f0 1f 00 1f 	mcall	80004f08 <mmu0_callbackCreator+0x260>
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readVerticalMirror);
80004e92:	08 9a       	mov	r10,r4
80004e94:	0c 9b       	mov	r11,r6
80004e96:	0e 9c       	mov	r12,r7
80004e98:	f0 1f 00 14 	mcall	80004ee8 <mmu0_callbackCreator+0x240>
    for (i = PPU_NAME_TABLE_2_FIRST_ADDRESS; i <= PPU_NAME_TABLE_2_LAST_ADDRESS; i++) {
      // map it back to table 0
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeVerticalMirror);
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readVerticalMirror);
    }
    for (i = PPU_NAME_TABLE_3_FIRST_ADDRESS; i <= PPU_NAME_TABLE_3_LAST_ADDRESS; i++) {
80004e9c:	2f f6       	sub	r6,-1
80004e9e:	e0 46 30 00 	cp.w	r6,12288
80004ea2:	cf 31       	brne	80004e88 <mmu0_callbackCreator+0x1e0>
80004ea4:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
      // map it back to table 1
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeVerticalMirror);
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readVerticalMirror);
    }
  } else if (mirrorType == BOTH) {
80004ea8:	58 2c       	cp.w	r12,2
80004eaa:	c0 81       	brne	80004eba <mmu0_callbackCreator+0x212>
    assert(FALSE);
80004eac:	4a 49       	lddpc	r9,80004f3c <mmu0_callbackCreator+0x294>
80004eae:	48 6a       	lddpc	r10,80004ec4 <mmu0_callbackCreator+0x21c>
80004eb0:	e0 6b 00 90 	mov	r11,144
80004eb4:	48 5c       	lddpc	r12,80004ec8 <mmu0_callbackCreator+0x220>
80004eb6:	f0 1f 00 06 	mcall	80004ecc <mmu0_callbackCreator+0x224>
80004eba:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80004ebe:	00 00       	add	r0,r0
80004ec0:	80 01       	ld.sh	r1,r0[0x0]
80004ec2:	31 44       	mov	r4,20
80004ec4:	80 01       	ld.sh	r1,r0[0x0]
80004ec6:	47 cc       	lddsp	r12,sp[0x1f0]
80004ec8:	80 01       	ld.sh	r1,r0[0x0]
80004eca:	47 e4       	lddsp	r4,sp[0x1f8]
80004ecc:	80 00       	ld.sh	r0,r0[0x0]
80004ece:	c1 a0       	breq	80004f02 <mmu0_callbackCreator+0x25a>
80004ed0:	80 01       	ld.sh	r1,r0[0x0]
80004ed2:	46 b0       	lddsp	r0,sp[0x1ac]
80004ed4:	80 01       	ld.sh	r1,r0[0x0]
80004ed6:	47 f8       	lddsp	r8,sp[0x1fc]
80004ed8:	80 00       	ld.sh	r0,r0[0x0]
80004eda:	8e 5c       	ld.sh	r12,r7[0xa]
80004edc:	80 00       	ld.sh	r0,r0[0x0]
80004ede:	50 c0       	stdsp	sp[0x30],r0
80004ee0:	80 01       	ld.sh	r1,r0[0x0]
80004ee2:	41 40       	lddsp	r0,sp[0x50]
80004ee4:	80 00       	ld.sh	r0,r0[0x0]
80004ee6:	4f cc       	lddpc	r12,800050d4 <nes_getCPUMemory+0x14>
80004ee8:	80 00       	ld.sh	r0,r0[0x0]
80004eea:	47 a0       	lddsp	r0,sp[0x1e8]
80004eec:	80 00       	ld.sh	r0,r0[0x0]
80004eee:	50 34       	stdsp	sp[0xc],r4
80004ef0:	80 01       	ld.sh	r1,r0[0x0]
80004ef2:	46 e4       	lddsp	r4,sp[0x1b8]
80004ef4:	80 00       	ld.sh	r0,r0[0x0]
80004ef6:	23 1c       	sub	r12,49
80004ef8:	80 00       	ld.sh	r0,r0[0x0]
80004efa:	8e 1c       	ld.sh	r12,r7[0x2]
80004efc:	80 01       	ld.sh	r1,r0[0x0]
80004efe:	48 10       	lddpc	r0,80004f00 <mmu0_callbackCreator+0x258>
80004f00:	80 01       	ld.sh	r1,r0[0x0]
80004f02:	48 28       	lddpc	r8,80004f08 <mmu0_callbackCreator+0x260>
80004f04:	80 00       	ld.sh	r0,r0[0x0]
80004f06:	4c 5c       	lddpc	r12,80005018 <mmu0_cpuMemory_readProgramBank0+0x4c>
80004f08:	80 00       	ld.sh	r0,r0[0x0]
80004f0a:	47 cc       	lddsp	r12,sp[0x1f0]
80004f0c:	80 00       	ld.sh	r0,r0[0x0]
80004f0e:	4f 94       	lddpc	r4,800050f0 <nes_getGUI+0x8>
80004f10:	80 00       	ld.sh	r0,r0[0x0]
80004f12:	22 60       	sub	r0,38
80004f14:	80 01       	ld.sh	r1,r0[0x0]
80004f16:	48 40       	lddpc	r0,80004f24 <mmu0_callbackCreator+0x27c>
80004f18:	80 00       	ld.sh	r0,r0[0x0]
80004f1a:	50 98       	stdsp	sp[0x24],r8
80004f1c:	80 01       	ld.sh	r1,r0[0x0]
80004f1e:	46 d0       	lddsp	r0,sp[0x1b4]
80004f20:	80 00       	ld.sh	r0,r0[0x0]
80004f22:	4c 38       	lddpc	r8,8000502c <mmu0_cpuMemory_readProgramBank0+0x60>
80004f24:	80 00       	ld.sh	r0,r0[0x0]
80004f26:	4f 40       	lddpc	r0,800050f4 <nes_getGUI+0xc>
80004f28:	80 00       	ld.sh	r0,r0[0x0]
80004f2a:	22 38       	sub	r8,35
80004f2c:	80 00       	ld.sh	r0,r0[0x0]
80004f2e:	4a 74       	lddpc	r4,80004fc8 <mmu0_cpuMemory_readProgramBank1+0x34>
80004f30:	80 00       	ld.sh	r0,r0[0x0]
80004f32:	4b 28       	lddpc	r8,80004ff8 <mmu0_cpuMemory_readProgramBank0+0x2c>
80004f34:	80 00       	ld.sh	r0,r0[0x0]
80004f36:	4a 18       	lddpc	r8,80004fb8 <mmu0_cpuMemory_readProgramBank1+0x24>
80004f38:	80 00       	ld.sh	r0,r0[0x0]
80004f3a:	4a d0       	lddpc	r0,80004fec <mmu0_cpuMemory_readProgramBank0+0x20>
80004f3c:	80 01       	ld.sh	r1,r0[0x0]
80004f3e:	56 cc       	stdsp	sp[0x1b0],r12

80004f40 <mmu0_ppuMemory_readPattern>:
  // not allowed to write to ROM
  assert(FALSE);
}
////////////////////////////////////////////////////////////////////////////////////////
////////////
static Byte mmu0_ppuMemory_readPattern(NES nes, Address address) {
80004f40:	eb cd 40 80 	pushm	r7,lr
80004f44:	16 97       	mov	r7,r11
  assert(nes != NULL);
80004f46:	58 0c       	cp.w	r12,0
80004f48:	c0 71       	brne	80004f56 <mmu0_ppuMemory_readPattern+0x16>
80004f4a:	48 c9       	lddpc	r9,80004f78 <mmu0_ppuMemory_readPattern+0x38>
80004f4c:	48 ca       	lddpc	r10,80004f7c <mmu0_ppuMemory_readPattern+0x3c>
80004f4e:	34 1b       	mov	r11,65
80004f50:	48 cc       	lddpc	r12,80004f80 <mmu0_ppuMemory_readPattern+0x40>
80004f52:	f0 1f 00 0d 	mcall	80004f84 <mmu0_ppuMemory_readPattern+0x44>
  Cartridge cartridge = nes_getCartridge(nes);
80004f56:	f0 1f 00 0d 	mcall	80004f88 <mmu0_ppuMemory_readPattern+0x48>
  assert(cartridge != NULL);
80004f5a:	c0 71       	brne	80004f68 <mmu0_ppuMemory_readPattern+0x28>
80004f5c:	48 c9       	lddpc	r9,80004f8c <mmu0_ppuMemory_readPattern+0x4c>
80004f5e:	48 8a       	lddpc	r10,80004f7c <mmu0_ppuMemory_readPattern+0x3c>
80004f60:	34 3b       	mov	r11,67
80004f62:	48 8c       	lddpc	r12,80004f80 <mmu0_ppuMemory_readPattern+0x40>
80004f64:	f0 1f 00 08 	mcall	80004f84 <mmu0_ppuMemory_readPattern+0x44>
  return cartridge_readCharacterBank(cartridge, 0, address);
80004f68:	0e 9a       	mov	r10,r7
80004f6a:	5c 7a       	castu.h	r10
80004f6c:	30 0b       	mov	r11,0
80004f6e:	f0 1f 00 09 	mcall	80004f90 <mmu0_ppuMemory_readPattern+0x50>
}
80004f72:	e3 cd 80 80 	ldm	sp++,r7,pc
80004f76:	00 00       	add	r0,r0
80004f78:	80 01       	ld.sh	r1,r0[0x0]
80004f7a:	31 44       	mov	r4,20
80004f7c:	80 01       	ld.sh	r1,r0[0x0]
80004f7e:	48 b4       	lddpc	r4,80004fa8 <mmu0_cpuMemory_readProgramBank1+0x14>
80004f80:	80 01       	ld.sh	r1,r0[0x0]
80004f82:	47 e4       	lddsp	r4,sp[0x1f8]
80004f84:	80 00       	ld.sh	r0,r0[0x0]
80004f86:	c1 a0       	breq	80004fba <mmu0_cpuMemory_readProgramBank1+0x26>
80004f88:	80 00       	ld.sh	r0,r0[0x0]
80004f8a:	50 34       	stdsp	sp[0xc],r4
80004f8c:	80 01       	ld.sh	r1,r0[0x0]
80004f8e:	46 e4       	lddsp	r4,sp[0x1b8]
80004f90:	80 00       	ld.sh	r0,r0[0x0]
80004f92:	22 b4       	sub	r4,43

80004f94 <mmu0_cpuMemory_readProgramBank1>:
  // not allowed to write to ROM
  assert(FALSE);
}
////////////////////////////////////////////////////////////////////////////////////////
////////////
static Byte mmu0_cpuMemory_readProgramBank1(NES nes, Address address) {
80004f94:	eb cd 40 c0 	pushm	r6-r7,lr
80004f98:	16 96       	mov	r6,r11
  //assert(nes != NULL);
  //address = mmu0_cpuMemory_getLocalAddress(address);
  address = address-0xC000; //segundo banko
  Cartridge cartridge = nes_getCartridge(nes);
80004f9a:	f0 1f 00 09 	mcall	80004fbc <mmu0_cpuMemory_readProgramBank1+0x28>
80004f9e:	18 97       	mov	r7,r12
  usart_write_line(&AVR32_USART0,"Cartridge\n");
80004fa0:	48 8b       	lddpc	r11,80004fc0 <mmu0_cpuMemory_readProgramBank1+0x2c>
80004fa2:	fe 7c 14 00 	mov	r12,-60416
80004fa6:	f0 1f 00 08 	mcall	80004fc4 <mmu0_cpuMemory_readProgramBank1+0x30>
  //assert(nes != NULL);
  //assert(1 < cartridge_getNumProgramBanks(cartridge));
  return cartridge_readProgramBank(cartridge, 1, address);
80004faa:	ec ca c0 00 	sub	r10,r6,-16384
80004fae:	5c 7a       	castu.h	r10
80004fb0:	30 1b       	mov	r11,1
80004fb2:	0e 9c       	mov	r12,r7
80004fb4:	f0 1f 00 05 	mcall	80004fc8 <mmu0_cpuMemory_readProgramBank1+0x34>
}
80004fb8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004fbc:	80 00       	ld.sh	r0,r0[0x0]
80004fbe:	50 34       	stdsp	sp[0xc],r4
80004fc0:	80 01       	ld.sh	r1,r0[0x0]
80004fc2:	48 58       	lddpc	r8,80004fd4 <mmu0_cpuMemory_readProgramBank0+0x8>
80004fc4:	80 00       	ld.sh	r0,r0[0x0]
80004fc6:	8e 5c       	ld.sh	r12,r7[0xa]
80004fc8:	80 00       	ld.sh	r0,r0[0x0]
80004fca:	22 28       	sub	r8,34

80004fcc <mmu0_cpuMemory_readProgramBank0>:
  usart_write_line(&AVR32_USART0,"mmu0");
  return address;
}
////////////////////////////////////////////////////////////////////////////////////////
////////////
static Byte mmu0_cpuMemory_readProgramBank0(NES nes, Address address) {
80004fcc:	eb cd 40 e0 	pushm	r5-r7,lr
80004fd0:	18 95       	mov	r5,r12
80004fd2:	16 96       	mov	r6,r11
  //assert(nes != NULL);
  //Memory memory = nes_getCPUMemory(nes);
  //assert(memory != NULL);
  //address = mmu0_cpuMemory_getLocalAddress(address);
  address = address -0x8000; //primer banko
  Cartridge cartridge = nes_getCartridge(nes);
80004fd4:	f0 1f 00 10 	mcall	80005014 <mmu0_cpuMemory_readProgramBank0+0x48>
80004fd8:	18 97       	mov	r7,r12
  assert(nes != NULL);
80004fda:	58 05       	cp.w	r5,0
80004fdc:	c0 71       	brne	80004fea <mmu0_cpuMemory_readProgramBank0+0x1e>
80004fde:	48 f9       	lddpc	r9,80005018 <mmu0_cpuMemory_readProgramBank0+0x4c>
80004fe0:	48 fa       	lddpc	r10,8000501c <mmu0_cpuMemory_readProgramBank0+0x50>
80004fe2:	32 0b       	mov	r11,32
80004fe4:	48 fc       	lddpc	r12,80005020 <mmu0_cpuMemory_readProgramBank0+0x54>
80004fe6:	f0 1f 00 10 	mcall	80005024 <mmu0_cpuMemory_readProgramBank0+0x58>
  assert(0 < cartridge_getNumProgramBanks(cartridge));
80004fea:	f0 1f 00 10 	mcall	80005028 <mmu0_cpuMemory_readProgramBank0+0x5c>
80004fee:	c0 71       	brne	80004ffc <mmu0_cpuMemory_readProgramBank0+0x30>
80004ff0:	48 f9       	lddpc	r9,8000502c <mmu0_cpuMemory_readProgramBank0+0x60>
80004ff2:	48 ba       	lddpc	r10,8000501c <mmu0_cpuMemory_readProgramBank0+0x50>
80004ff4:	32 1b       	mov	r11,33
80004ff6:	48 bc       	lddpc	r12,80005020 <mmu0_cpuMemory_readProgramBank0+0x54>
80004ff8:	f0 1f 00 0b 	mcall	80005024 <mmu0_cpuMemory_readProgramBank0+0x58>
  return cartridge_readProgramBank(cartridge, 0, address);
80004ffc:	fe 78 80 00 	mov	r8,-32768
80005000:	ec 08 00 0a 	add	r10,r6,r8
80005004:	5c 7a       	castu.h	r10
80005006:	30 0b       	mov	r11,0
80005008:	0e 9c       	mov	r12,r7
8000500a:	f0 1f 00 0a 	mcall	80005030 <mmu0_cpuMemory_readProgramBank0+0x64>
}
8000500e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005012:	00 00       	add	r0,r0
80005014:	80 00       	ld.sh	r0,r0[0x0]
80005016:	50 34       	stdsp	sp[0xc],r4
80005018:	80 01       	ld.sh	r1,r0[0x0]
8000501a:	31 44       	mov	r4,20
8000501c:	80 01       	ld.sh	r1,r0[0x0]
8000501e:	47 90       	lddsp	r0,sp[0x1e4]
80005020:	80 01       	ld.sh	r1,r0[0x0]
80005022:	47 e4       	lddsp	r4,sp[0x1f8]
80005024:	80 00       	ld.sh	r0,r0[0x0]
80005026:	c1 a0       	breq	8000505a <nes_getPPU+0x12>
80005028:	80 00       	ld.sh	r0,r0[0x0]
8000502a:	23 1c       	sub	r12,49
8000502c:	80 01       	ld.sh	r1,r0[0x0]
8000502e:	48 64       	lddpc	r4,80005044 <nes_getLowPPUAddress+0xc>
80005030:	80 00       	ld.sh	r0,r0[0x0]
80005032:	22 28       	sub	r8,34

80005034 <nes_getCartridge>:
  return nes->ppu;
}
Cartridge nes_getCartridge(NES nes) {
 // assert(nes != NULL);
  return nes->cartridge;
}
80005034:	78 6c       	ld.w	r12,r12[0x18]
80005036:	5e fc       	retal	r12

80005038 <nes_getLowPPUAddress>:
}
// the PPU has 64kb of address space but can only access 16kb of it
// we handle the "big picture" ppu mirrors here (the four 16kb mirrors)
// and we handle the smaller mirrors (mirrors within mirrors) with callbacks
static Address nes_getLowPPUAddress(Address address) {
  while(address > PPU_LAST_REAL_ADDRESS) {
80005038:	e0 68 3f ff 	mov	r8,16383
8000503c:	f0 0c 19 00 	cp.h	r12,r8
80005040:	5e 8c       	retls	r12
    address -= PPU_NUM_REAL_ADDRESSES;
80005042:	f9 dc c0 0e 	bfextu	r12,r12,0x0,0xe
  }
  assert(address <= PPU_LAST_REAL_ADDRESS);
  return address;
}
80005046:	5e fc       	retal	r12

80005048 <nes_getPPU>:
}
CPU nes_getCPU(NES nes) {
  assert(nes != NULL);
  return nes->cpu1;
}
PPU nes_getPPU(NES nes) {
80005048:	d4 01       	pushm	lr
  assert(nes != NULL);
8000504a:	58 0c       	cp.w	r12,0
8000504c:	c0 81       	brne	8000505c <nes_getPPU+0x14>
8000504e:	48 59       	lddpc	r9,80005060 <nes_getPPU+0x18>
80005050:	48 5a       	lddpc	r10,80005064 <nes_getPPU+0x1c>
80005052:	e0 6b 00 ed 	mov	r11,237
80005056:	48 5c       	lddpc	r12,80005068 <nes_getPPU+0x20>
80005058:	f0 1f 00 05 	mcall	8000506c <nes_getPPU+0x24>
  return nes->ppu;
}
8000505c:	78 4c       	ld.w	r12,r12[0x10]
8000505e:	d8 02       	popm	pc
80005060:	80 01       	ld.sh	r1,r0[0x0]
80005062:	31 44       	mov	r4,20
80005064:	80 01       	ld.sh	r1,r0[0x0]
80005066:	4d 08       	lddpc	r8,800051a4 <nes_cpuCycled+0x40>
80005068:	80 01       	ld.sh	r1,r0[0x0]
8000506a:	49 dc       	lddpc	r12,800050dc <nes_getCPUMemory+0x1c>
8000506c:	80 00       	ld.sh	r0,r0[0x0]
8000506e:	c1 a0       	breq	800050a2 <nes_getPPUMemory+0xa>

80005070 <nes_getCPU>:
}
Memory nes_getPPUMemory(NES nes) {
  assert(nes != NULL);
  return nes->ppuMemory;
}
CPU nes_getCPU(NES nes) {
80005070:	d4 01       	pushm	lr
  assert(nes != NULL);
80005072:	58 0c       	cp.w	r12,0
80005074:	c0 81       	brne	80005084 <nes_getCPU+0x14>
80005076:	48 59       	lddpc	r9,80005088 <nes_getCPU+0x18>
80005078:	48 5a       	lddpc	r10,8000508c <nes_getCPU+0x1c>
8000507a:	e0 6b 00 e9 	mov	r11,233
8000507e:	48 5c       	lddpc	r12,80005090 <nes_getCPU+0x20>
80005080:	f0 1f 00 05 	mcall	80005094 <nes_getCPU+0x24>
  return nes->cpu1;
}
80005084:	78 3c       	ld.w	r12,r12[0xc]
80005086:	d8 02       	popm	pc
80005088:	80 01       	ld.sh	r1,r0[0x0]
8000508a:	31 44       	mov	r4,20
8000508c:	80 01       	ld.sh	r1,r0[0x0]
8000508e:	4c b8       	lddpc	r8,800051b8 <nes_cpuCycled+0x54>
80005090:	80 01       	ld.sh	r1,r0[0x0]
80005092:	49 dc       	lddpc	r12,80005104 <nes_getGUI+0x1c>
80005094:	80 00       	ld.sh	r0,r0[0x0]
80005096:	c1 a0       	breq	800050ca <nes_getCPUMemory+0xa>

80005098 <nes_getPPUMemory>:
}
Memory nes_getCPUMemory(NES nes) {
  assert(nes != NULL);
  return nes->cpuMemory;
}
Memory nes_getPPUMemory(NES nes) {
80005098:	d4 01       	pushm	lr
  assert(nes != NULL);
8000509a:	58 0c       	cp.w	r12,0
8000509c:	c0 81       	brne	800050ac <nes_getPPUMemory+0x14>
8000509e:	48 59       	lddpc	r9,800050b0 <nes_getPPUMemory+0x18>
800050a0:	48 5a       	lddpc	r10,800050b4 <nes_getPPUMemory+0x1c>
800050a2:	e0 6b 00 e5 	mov	r11,229
800050a6:	48 5c       	lddpc	r12,800050b8 <nes_getPPUMemory+0x20>
800050a8:	f0 1f 00 05 	mcall	800050bc <nes_getPPUMemory+0x24>
  return nes->ppuMemory;
}
800050ac:	78 1c       	ld.w	r12,r12[0x4]
800050ae:	d8 02       	popm	pc
800050b0:	80 01       	ld.sh	r1,r0[0x0]
800050b2:	31 44       	mov	r4,20
800050b4:	80 01       	ld.sh	r1,r0[0x0]
800050b6:	4c 98       	lddpc	r8,800051d8 <nes_writePPUMemory+0x1c>
800050b8:	80 01       	ld.sh	r1,r0[0x0]
800050ba:	49 dc       	lddpc	r12,8000512c <nes_getObjectAttributeMemory+0x4>
800050bc:	80 00       	ld.sh	r0,r0[0x0]
800050be:	c1 a0       	breq	800050f2 <nes_getGUI+0xa>

800050c0 <nes_getCPUMemory>:
GUI nes_getGUI(NES nes) {
  assert(nes != NULL);
  assert(nes->gui != NULL);
  return nes->gui;
}
Memory nes_getCPUMemory(NES nes) {
800050c0:	d4 01       	pushm	lr
  assert(nes != NULL);
800050c2:	58 0c       	cp.w	r12,0
800050c4:	c0 81       	brne	800050d4 <nes_getCPUMemory+0x14>
800050c6:	48 59       	lddpc	r9,800050d8 <nes_getCPUMemory+0x18>
800050c8:	48 5a       	lddpc	r10,800050dc <nes_getCPUMemory+0x1c>
800050ca:	e0 6b 00 e1 	mov	r11,225
800050ce:	48 5c       	lddpc	r12,800050e0 <nes_getCPUMemory+0x20>
800050d0:	f0 1f 00 05 	mcall	800050e4 <nes_getCPUMemory+0x24>
  return nes->cpuMemory;
}
800050d4:	78 0c       	ld.w	r12,r12[0x0]
800050d6:	d8 02       	popm	pc
800050d8:	80 01       	ld.sh	r1,r0[0x0]
800050da:	31 44       	mov	r4,20
800050dc:	80 01       	ld.sh	r1,r0[0x0]
800050de:	49 0c       	lddpc	r12,8000511c <nes_getGUI+0x34>
800050e0:	80 01       	ld.sh	r1,r0[0x0]
800050e2:	49 dc       	lddpc	r12,80005154 <nes_getObjectAttributeMemory+0x2c>
800050e4:	80 00       	ld.sh	r0,r0[0x0]
800050e6:	c1 a0       	breq	8000511a <nes_getGUI+0x32>

800050e8 <nes_getGUI>:
	//usart_write_line(&AVR32_USART0,"step");
    cpu_step(nes);
    nes_checkKeyboard(nes);
  }
}
GUI nes_getGUI(NES nes) {
800050e8:	d4 01       	pushm	lr
  assert(nes != NULL);
800050ea:	58 0c       	cp.w	r12,0
800050ec:	c0 81       	brne	800050fc <nes_getGUI+0x14>
800050ee:	48 a9       	lddpc	r9,80005114 <nes_getGUI+0x2c>
800050f0:	48 aa       	lddpc	r10,80005118 <nes_getGUI+0x30>
800050f2:	e0 6b 00 dc 	mov	r11,220
800050f6:	48 ac       	lddpc	r12,8000511c <nes_getGUI+0x34>
800050f8:	f0 1f 00 0a 	mcall	80005120 <nes_getGUI+0x38>
  assert(nes->gui != NULL);
800050fc:	78 ac       	ld.w	r12,r12[0x28]
800050fe:	58 0c       	cp.w	r12,0
80005100:	c0 81       	brne	80005110 <nes_getGUI+0x28>
80005102:	48 99       	lddpc	r9,80005124 <nes_getGUI+0x3c>
80005104:	48 5a       	lddpc	r10,80005118 <nes_getGUI+0x30>
80005106:	e0 6b 00 dd 	mov	r11,221
8000510a:	48 5c       	lddpc	r12,8000511c <nes_getGUI+0x34>
8000510c:	f0 1f 00 05 	mcall	80005120 <nes_getGUI+0x38>
  return nes->gui;
}
80005110:	d8 02       	popm	pc
80005112:	00 00       	add	r0,r0
80005114:	80 01       	ld.sh	r1,r0[0x0]
80005116:	31 44       	mov	r4,20
80005118:	80 01       	ld.sh	r1,r0[0x0]
8000511a:	48 d0       	lddpc	r0,8000514c <nes_getObjectAttributeMemory+0x24>
8000511c:	80 01       	ld.sh	r1,r0[0x0]
8000511e:	49 dc       	lddpc	r12,80005190 <nes_cpuCycled+0x2c>
80005120:	80 00       	ld.sh	r0,r0[0x0]
80005122:	c1 a0       	breq	80005156 <nes_getObjectAttributeMemory+0x2e>
80005124:	80 01       	ld.sh	r1,r0[0x0]
80005126:	49 f0       	lddpc	r0,800051a0 <nes_cpuCycled+0x3c>

80005128 <nes_getObjectAttributeMemory>:
  assert(nes != NULL);
  assert(nes->objectAttributeMemory == NULL);
  nes->objectAttributeMemory = objectAttributeMemory_init();
  assert(nes->objectAttributeMemory != NULL);
}
Memory nes_getObjectAttributeMemory(NES nes) {
80005128:	d4 01       	pushm	lr
  assert(nes != NULL);
8000512a:	58 0c       	cp.w	r12,0
8000512c:	c0 71       	brne	8000513a <nes_getObjectAttributeMemory+0x12>
8000512e:	48 99       	lddpc	r9,80005150 <nes_getObjectAttributeMemory+0x28>
80005130:	48 9a       	lddpc	r10,80005154 <nes_getObjectAttributeMemory+0x2c>
80005132:	35 cb       	mov	r11,92
80005134:	48 9c       	lddpc	r12,80005158 <nes_getObjectAttributeMemory+0x30>
80005136:	f0 1f 00 0a 	mcall	8000515c <nes_getObjectAttributeMemory+0x34>
  assert(nes->objectAttributeMemory != NULL);
8000513a:	78 2c       	ld.w	r12,r12[0x8]
8000513c:	58 0c       	cp.w	r12,0
8000513e:	c0 71       	brne	8000514c <nes_getObjectAttributeMemory+0x24>
80005140:	48 89       	lddpc	r9,80005160 <nes_getObjectAttributeMemory+0x38>
80005142:	48 5a       	lddpc	r10,80005154 <nes_getObjectAttributeMemory+0x2c>
80005144:	35 db       	mov	r11,93
80005146:	48 5c       	lddpc	r12,80005158 <nes_getObjectAttributeMemory+0x30>
80005148:	f0 1f 00 05 	mcall	8000515c <nes_getObjectAttributeMemory+0x34>
  return nes->objectAttributeMemory;
}
8000514c:	d8 02       	popm	pc
8000514e:	00 00       	add	r0,r0
80005150:	80 01       	ld.sh	r1,r0[0x0]
80005152:	31 44       	mov	r4,20
80005154:	80 01       	ld.sh	r1,r0[0x0]
80005156:	49 48       	lddpc	r8,800051a4 <nes_cpuCycled+0x40>
80005158:	80 01       	ld.sh	r1,r0[0x0]
8000515a:	49 dc       	lddpc	r12,800051cc <nes_writePPUMemory+0x10>
8000515c:	80 00       	ld.sh	r0,r0[0x0]
8000515e:	c1 a0       	breq	80005192 <nes_cpuCycled+0x2e>
80005160:	80 01       	ld.sh	r1,r0[0x0]
80005162:	4a 04       	lddpc	r4,800051e0 <nes_writePPUMemory+0x24>

80005164 <nes_cpuCycled>:
}
APU getAPU(NES nes) {
  assert(nes != NULL);
  return nes->apu;
}
void nes_cpuCycled(NES nes) {
80005164:	eb cd 40 80 	pushm	r7,lr
80005168:	18 97       	mov	r7,r12
  assert(nes != NULL);
8000516a:	58 0c       	cp.w	r12,0
8000516c:	c0 81       	brne	8000517c <nes_cpuCycled+0x18>
8000516e:	48 e9       	lddpc	r9,800051a4 <nes_cpuCycled+0x40>
80005170:	48 ea       	lddpc	r10,800051a8 <nes_cpuCycled+0x44>
80005172:	e0 6b 01 2b 	mov	r11,299
80005176:	48 ec       	lddpc	r12,800051ac <nes_cpuCycled+0x48>
80005178:	f0 1f 00 0e 	mcall	800051b0 <nes_cpuCycled+0x4c>
  ppu_step(nes);
8000517c:	f0 1f 00 0e 	mcall	800051b4 <nes_cpuCycled+0x50>
  apu_step(nes);
80005180:	0e 9c       	mov	r12,r7
80005182:	f0 1f 00 0e 	mcall	800051b8 <nes_cpuCycled+0x54>
  ppu_step(nes);
80005186:	0e 9c       	mov	r12,r7
80005188:	f0 1f 00 0b 	mcall	800051b4 <nes_cpuCycled+0x50>
  apu_step(nes);
8000518c:	0e 9c       	mov	r12,r7
8000518e:	f0 1f 00 0b 	mcall	800051b8 <nes_cpuCycled+0x54>
  ppu_step(nes);
80005192:	0e 9c       	mov	r12,r7
80005194:	f0 1f 00 08 	mcall	800051b4 <nes_cpuCycled+0x50>
  apu_step(nes);
80005198:	0e 9c       	mov	r12,r7
8000519a:	f0 1f 00 08 	mcall	800051b8 <nes_cpuCycled+0x54>
  // adjust for pal frequency here
  // if (PAL) {
  // }
8000519e:	e3 cd 80 80 	ldm	sp++,r7,pc
800051a2:	00 00       	add	r0,r0
800051a4:	80 01       	ld.sh	r1,r0[0x0]
800051a6:	31 44       	mov	r4,20
800051a8:	80 01       	ld.sh	r1,r0[0x0]
800051aa:	4c 2c       	lddpc	r12,800052b0 <nes_writeCPUMemory+0x48>
800051ac:	80 01       	ld.sh	r1,r0[0x0]
800051ae:	49 dc       	lddpc	r12,80005220 <nes_writeObjectAttributeMemory+0x8>
800051b0:	80 00       	ld.sh	r0,r0[0x0]
800051b2:	c1 a0       	breq	800051e6 <nes_writePPUMemory+0x2a>
800051b4:	80 00       	ld.sh	r0,r0[0x0]
800051b6:	64 24       	ld.w	r4,r2[0x8]
800051b8:	80 00       	ld.sh	r0,r0[0x0]
800051ba:	21 98       	sub	r8,25

800051bc <nes_writePPUMemory>:
Byte nes_readPPUMemory(NES nes, Address address) {
  assert(nes != NULL);
  address = nes_getLowPPUAddress(address);
  return memory_read_callback(nes, nes_getPPUMemory(nes), address);
}
void nes_writePPUMemory(NES nes, Address address, Byte data) {
800051bc:	eb cd 40 e0 	pushm	r5-r7,lr
800051c0:	18 97       	mov	r7,r12
800051c2:	14 95       	mov	r5,r10
  assert(nes != NULL);
800051c4:	58 0c       	cp.w	r12,0
800051c6:	c0 81       	brne	800051d6 <nes_writePPUMemory+0x1a>
800051c8:	48 d9       	lddpc	r9,800051fc <nes_writePPUMemory+0x40>
800051ca:	48 ea       	lddpc	r10,80005200 <nes_writePPUMemory+0x44>
800051cc:	e0 6b 01 22 	mov	r11,290
800051d0:	48 dc       	lddpc	r12,80005204 <nes_writePPUMemory+0x48>
800051d2:	f0 1f 00 0e 	mcall	80005208 <nes_writePPUMemory+0x4c>
  address = nes_getLowPPUAddress(address);
800051d6:	f9 db c0 10 	bfextu	r12,r11,0x0,0x10
800051da:	f0 1f 00 0d 	mcall	8000520c <nes_writePPUMemory+0x50>
800051de:	ed dc b0 10 	bfexts	r6,r12,0x0,0x10
  memory_write_callback(nes, nes_getPPUMemory(nes), address, data);
800051e2:	0e 9c       	mov	r12,r7
800051e4:	f0 1f 00 0b 	mcall	80005210 <nes_writePPUMemory+0x54>
800051e8:	0a 99       	mov	r9,r5
800051ea:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
800051ee:	18 9b       	mov	r11,r12
800051f0:	0e 9c       	mov	r12,r7
800051f2:	f0 1f 00 09 	mcall	80005214 <nes_writePPUMemory+0x58>
}
800051f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800051fa:	00 00       	add	r0,r0
800051fc:	80 01       	ld.sh	r1,r0[0x0]
800051fe:	31 44       	mov	r4,20
80005200:	80 01       	ld.sh	r1,r0[0x0]
80005202:	49 98       	lddpc	r8,80005264 <nes_writeObjectAttributeMemory+0x4c>
80005204:	80 01       	ld.sh	r1,r0[0x0]
80005206:	49 dc       	lddpc	r12,80005278 <nes_writeCPUMemory+0x10>
80005208:	80 00       	ld.sh	r0,r0[0x0]
8000520a:	c1 a0       	breq	8000523e <nes_writeObjectAttributeMemory+0x26>
8000520c:	80 00       	ld.sh	r0,r0[0x0]
8000520e:	50 38       	stdsp	sp[0xc],r8
80005210:	80 00       	ld.sh	r0,r0[0x0]
80005212:	50 98       	stdsp	sp[0x24],r8
80005214:	80 00       	ld.sh	r0,r0[0x0]
80005216:	48 d0       	lddpc	r0,80005248 <nes_writeObjectAttributeMemory+0x30>

80005218 <nes_writeObjectAttributeMemory>:
Byte nes_readObjectAttributeMemory(NES nes, Address address) {
  assert(nes != NULL);
  assert(nes->objectAttributeMemory != NULL);
  return memory_read_callback(nes, nes->objectAttributeMemory, address);
}
void nes_writeObjectAttributeMemory(NES nes, Address address, Byte data) {
80005218:	d4 01       	pushm	lr
  assert(nes != NULL);
8000521a:	58 0c       	cp.w	r12,0
8000521c:	c0 81       	brne	8000522c <nes_writeObjectAttributeMemory+0x14>
8000521e:	48 d9       	lddpc	r9,80005250 <nes_writeObjectAttributeMemory+0x38>
80005220:	48 da       	lddpc	r10,80005254 <nes_writeObjectAttributeMemory+0x3c>
80005222:	e0 6b 01 0e 	mov	r11,270
80005226:	48 dc       	lddpc	r12,80005258 <nes_writeObjectAttributeMemory+0x40>
80005228:	f0 1f 00 0d 	mcall	8000525c <nes_writeObjectAttributeMemory+0x44>
  assert(nes->objectAttributeMemory != NULL);
8000522c:	78 28       	ld.w	r8,r12[0x8]
8000522e:	58 08       	cp.w	r8,0
80005230:	c0 81       	brne	80005240 <nes_writeObjectAttributeMemory+0x28>
80005232:	48 c9       	lddpc	r9,80005260 <nes_writeObjectAttributeMemory+0x48>
80005234:	48 8a       	lddpc	r10,80005254 <nes_writeObjectAttributeMemory+0x3c>
80005236:	e0 6b 01 0f 	mov	r11,271
8000523a:	48 8c       	lddpc	r12,80005258 <nes_writeObjectAttributeMemory+0x40>
8000523c:	f0 1f 00 08 	mcall	8000525c <nes_writeObjectAttributeMemory+0x44>
  memory_write_callback(nes, nes->objectAttributeMemory, address, data);
80005240:	14 99       	mov	r9,r10
80005242:	f5 db c0 10 	bfextu	r10,r11,0x0,0x10
80005246:	10 9b       	mov	r11,r8
80005248:	f0 1f 00 07 	mcall	80005264 <nes_writeObjectAttributeMemory+0x4c>
}
8000524c:	d8 02       	popm	pc
8000524e:	00 00       	add	r0,r0
80005250:	80 01       	ld.sh	r1,r0[0x0]
80005252:	31 44       	mov	r4,20
80005254:	80 01       	ld.sh	r1,r0[0x0]
80005256:	49 ac       	lddpc	r12,800052bc <nes_writeCPUMemory+0x54>
80005258:	80 01       	ld.sh	r1,r0[0x0]
8000525a:	49 dc       	lddpc	r12,800052cc <nes_readPPUMemory+0x4>
8000525c:	80 00       	ld.sh	r0,r0[0x0]
8000525e:	c1 a0       	breq	80005292 <nes_writeCPUMemory+0x2a>
80005260:	80 01       	ld.sh	r1,r0[0x0]
80005262:	4a 04       	lddpc	r4,800052e0 <nes_readPPUMemory+0x18>
80005264:	80 00       	ld.sh	r0,r0[0x0]
80005266:	48 d0       	lddpc	r0,80005298 <nes_writeCPUMemory+0x30>

80005268 <nes_writeCPUMemory>:
  //usart_write_line(&AVR32_USART0,"readCPUmem1\n");
  nes_cpuCycled(nes1);
   
  return data;
}
void nes_writeCPUMemory(NES nes, Address address, Byte data) {
80005268:	eb cd 40 80 	pushm	r7,lr
8000526c:	18 97       	mov	r7,r12
  assert(nes != NULL);
8000526e:	58 0c       	cp.w	r12,0
80005270:	c0 81       	brne	80005280 <nes_writeCPUMemory+0x18>
80005272:	48 f9       	lddpc	r9,800052ac <nes_writeCPUMemory+0x44>
80005274:	48 fa       	lddpc	r10,800052b0 <nes_writeCPUMemory+0x48>
80005276:	e0 6b 01 03 	mov	r11,259
8000527a:	48 fc       	lddpc	r12,800052b4 <nes_writeCPUMemory+0x4c>
8000527c:	f0 1f 00 0f 	mcall	800052b8 <nes_writeCPUMemory+0x50>
  assert(nes->cpuMemory != NULL);
80005280:	78 08       	ld.w	r8,r12[0x0]
80005282:	58 08       	cp.w	r8,0
80005284:	c0 81       	brne	80005294 <nes_writeCPUMemory+0x2c>
80005286:	48 e9       	lddpc	r9,800052bc <nes_writeCPUMemory+0x54>
80005288:	48 aa       	lddpc	r10,800052b0 <nes_writeCPUMemory+0x48>
8000528a:	e0 6b 01 04 	mov	r11,260
8000528e:	48 ac       	lddpc	r12,800052b4 <nes_writeCPUMemory+0x4c>
80005290:	f0 1f 00 0a 	mcall	800052b8 <nes_writeCPUMemory+0x50>
  memory_write_callback(nes, nes->cpuMemory, address, data);
80005294:	14 99       	mov	r9,r10
80005296:	f5 db c0 10 	bfextu	r10,r11,0x0,0x10
8000529a:	10 9b       	mov	r11,r8
8000529c:	f0 1f 00 09 	mcall	800052c0 <nes_writeCPUMemory+0x58>
  nes_cpuCycled(nes);
800052a0:	0e 9c       	mov	r12,r7
800052a2:	f0 1f 00 09 	mcall	800052c4 <nes_writeCPUMemory+0x5c>
}
800052a6:	e3 cd 80 80 	ldm	sp++,r7,pc
800052aa:	00 00       	add	r0,r0
800052ac:	80 01       	ld.sh	r1,r0[0x0]
800052ae:	31 44       	mov	r4,20
800052b0:	80 01       	ld.sh	r1,r0[0x0]
800052b2:	49 34       	lddpc	r4,800052fc <nes_readPPUMemory+0x34>
800052b4:	80 01       	ld.sh	r1,r0[0x0]
800052b6:	49 dc       	lddpc	r12,80005328 <nes_readObjectAttributeMemory+0x8>
800052b8:	80 00       	ld.sh	r0,r0[0x0]
800052ba:	c1 a0       	breq	800052ee <nes_readPPUMemory+0x26>
800052bc:	80 01       	ld.sh	r1,r0[0x0]
800052be:	4a 28       	lddpc	r8,80005344 <nes_readObjectAttributeMemory+0x24>
800052c0:	80 00       	ld.sh	r0,r0[0x0]
800052c2:	48 d0       	lddpc	r0,800052f4 <nes_readPPUMemory+0x2c>
800052c4:	80 00       	ld.sh	r0,r0[0x0]
800052c6:	51 64       	stdsp	sp[0x58],r4

800052c8 <nes_readPPUMemory>:
    address -= PPU_NUM_REAL_ADDRESSES;
  }
  assert(address <= PPU_LAST_REAL_ADDRESS);
  return address;
}
Byte nes_readPPUMemory(NES nes, Address address) {
800052c8:	eb cd 40 c0 	pushm	r6-r7,lr
800052cc:	18 97       	mov	r7,r12
  assert(nes != NULL);
800052ce:	58 0c       	cp.w	r12,0
800052d0:	c0 81       	brne	800052e0 <nes_readPPUMemory+0x18>
800052d2:	48 d9       	lddpc	r9,80005304 <nes_readPPUMemory+0x3c>
800052d4:	48 da       	lddpc	r10,80005308 <nes_readPPUMemory+0x40>
800052d6:	e0 6b 01 1d 	mov	r11,285
800052da:	48 dc       	lddpc	r12,8000530c <nes_readPPUMemory+0x44>
800052dc:	f0 1f 00 0d 	mcall	80005310 <nes_readPPUMemory+0x48>
  address = nes_getLowPPUAddress(address);
800052e0:	f9 db c0 10 	bfextu	r12,r11,0x0,0x10
800052e4:	f0 1f 00 0c 	mcall	80005314 <nes_readPPUMemory+0x4c>
800052e8:	ed dc b0 10 	bfexts	r6,r12,0x0,0x10
  return memory_read_callback(nes, nes_getPPUMemory(nes), address);
800052ec:	0e 9c       	mov	r12,r7
800052ee:	f0 1f 00 0b 	mcall	80005318 <nes_readPPUMemory+0x50>
800052f2:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
800052f6:	18 9b       	mov	r11,r12
800052f8:	0e 9c       	mov	r12,r7
800052fa:	f0 1f 00 09 	mcall	8000531c <nes_readPPUMemory+0x54>
}
800052fe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005302:	00 00       	add	r0,r0
80005304:	80 01       	ld.sh	r1,r0[0x0]
80005306:	31 44       	mov	r4,20
80005308:	80 01       	ld.sh	r1,r0[0x0]
8000530a:	4c 5c       	lddpc	r12,8000541c <nes_run+0x58>
8000530c:	80 01       	ld.sh	r1,r0[0x0]
8000530e:	49 dc       	lddpc	r12,80005380 <nes_readCPUMemory+0x14>
80005310:	80 00       	ld.sh	r0,r0[0x0]
80005312:	c1 a0       	breq	80005346 <nes_readObjectAttributeMemory+0x26>
80005314:	80 00       	ld.sh	r0,r0[0x0]
80005316:	50 38       	stdsp	sp[0xc],r8
80005318:	80 00       	ld.sh	r0,r0[0x0]
8000531a:	50 98       	stdsp	sp[0x24],r8
8000531c:	80 00       	ld.sh	r0,r0[0x0]
8000531e:	48 40       	lddpc	r0,8000532c <nes_readObjectAttributeMemory+0xc>

80005320 <nes_readObjectAttributeMemory>:
  assert(nes != NULL);
  assert(nes->cpuMemory != NULL);
  memory_write_callback(nes, nes->cpuMemory, address, data);
  nes_cpuCycled(nes);
}
Byte nes_readObjectAttributeMemory(NES nes, Address address) {
80005320:	d4 01       	pushm	lr
  assert(nes != NULL);
80005322:	58 0c       	cp.w	r12,0
80005324:	c0 81       	brne	80005334 <nes_readObjectAttributeMemory+0x14>
80005326:	48 c9       	lddpc	r9,80005354 <nes_readObjectAttributeMemory+0x34>
80005328:	48 ca       	lddpc	r10,80005358 <nes_readObjectAttributeMemory+0x38>
8000532a:	e0 6b 01 09 	mov	r11,265
8000532e:	48 cc       	lddpc	r12,8000535c <nes_readObjectAttributeMemory+0x3c>
80005330:	f0 1f 00 0c 	mcall	80005360 <nes_readObjectAttributeMemory+0x40>
  assert(nes->objectAttributeMemory != NULL);
80005334:	78 28       	ld.w	r8,r12[0x8]
80005336:	58 08       	cp.w	r8,0
80005338:	c0 81       	brne	80005348 <nes_readObjectAttributeMemory+0x28>
8000533a:	48 b9       	lddpc	r9,80005364 <nes_readObjectAttributeMemory+0x44>
8000533c:	48 7a       	lddpc	r10,80005358 <nes_readObjectAttributeMemory+0x38>
8000533e:	e0 6b 01 0a 	mov	r11,266
80005342:	48 7c       	lddpc	r12,8000535c <nes_readObjectAttributeMemory+0x3c>
80005344:	f0 1f 00 07 	mcall	80005360 <nes_readObjectAttributeMemory+0x40>
  return memory_read_callback(nes, nes->objectAttributeMemory, address);
80005348:	f5 db c0 10 	bfextu	r10,r11,0x0,0x10
8000534c:	10 9b       	mov	r11,r8
8000534e:	f0 1f 00 07 	mcall	80005368 <nes_readObjectAttributeMemory+0x48>
}
80005352:	d8 02       	popm	pc
80005354:	80 01       	ld.sh	r1,r0[0x0]
80005356:	31 44       	mov	r4,20
80005358:	80 01       	ld.sh	r1,r0[0x0]
8000535a:	49 68       	lddpc	r8,800053b0 <nes_generateNMI+0x1c>
8000535c:	80 01       	ld.sh	r1,r0[0x0]
8000535e:	49 dc       	lddpc	r12,800053d0 <nes_run+0xc>
80005360:	80 00       	ld.sh	r0,r0[0x0]
80005362:	c1 a0       	breq	80005396 <nes_generateNMI+0x2>
80005364:	80 01       	ld.sh	r1,r0[0x0]
80005366:	4a 04       	lddpc	r4,800053e4 <nes_run+0x20>
80005368:	80 00       	ld.sh	r0,r0[0x0]
8000536a:	48 40       	lddpc	r0,80005378 <nes_readCPUMemory+0xc>

8000536c <nes_readCPUMemory>:
}
Interrupts nes_getInterrupts(NES nes) {
  assert(nes != NULL);
  return nes->interrupts;
}
Byte nes_readCPUMemory(NES nes1, Address address) {
8000536c:	eb cd 40 c0 	pushm	r6-r7,lr
80005370:	18 97       	mov	r7,r12
  //assert(nes1 != NULL);
  //assert(nes1->cpuMemory != NULL);
   //usart_write_line(&AVR32_USART0,"readCPUmem\n");
  Byte data = memory_read_callback(nes1, nes1->cpuMemory, address);
80005372:	f5 db c0 10 	bfextu	r10,r11,0x0,0x10
80005376:	78 0b       	ld.w	r11,r12[0x0]
80005378:	f0 1f 00 05 	mcall	8000538c <nes_readCPUMemory+0x20>
8000537c:	18 96       	mov	r6,r12
  //usart_write_line(&AVR32_USART0,"readCPUmem1\n");
  nes_cpuCycled(nes1);
8000537e:	0e 9c       	mov	r12,r7
80005380:	f0 1f 00 04 	mcall	80005390 <nes_readCPUMemory+0x24>
   
  return data;
}
80005384:	0c 9c       	mov	r12,r6
80005386:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000538a:	00 00       	add	r0,r0
8000538c:	80 00       	ld.sh	r0,r0[0x0]
8000538e:	48 40       	lddpc	r0,8000539c <nes_generateNMI+0x8>
80005390:	80 00       	ld.sh	r0,r0[0x0]
80005392:	51 64       	stdsp	sp[0x58],r4

80005394 <nes_generateNMI>:
Memory nes_getObjectAttributeMemory(NES nes) {
  assert(nes != NULL);
  assert(nes->objectAttributeMemory != NULL);
  return nes->objectAttributeMemory;
}
void nes_generateNMI(NES nes) {
80005394:	d4 01       	pushm	lr
  assert(nes != NULL);
80005396:	58 0c       	cp.w	r12,0
80005398:	c0 71       	brne	800053a6 <nes_generateNMI+0x12>
8000539a:	48 69       	lddpc	r9,800053b0 <nes_generateNMI+0x1c>
8000539c:	48 6a       	lddpc	r10,800053b4 <nes_generateNMI+0x20>
8000539e:	36 1b       	mov	r11,97
800053a0:	48 6c       	lddpc	r12,800053b8 <nes_generateNMI+0x24>
800053a2:	f0 1f 00 07 	mcall	800053bc <nes_generateNMI+0x28>
  //usart_write_line(&AVR32_USART0,"generateNMI\n");
  interrupts_setNMI(nes->interrupts, TRUE);
800053a6:	30 1b       	mov	r11,1
800053a8:	78 7c       	ld.w	r12,r12[0x1c]
800053aa:	f0 1f 00 06 	mcall	800053c0 <nes_generateNMI+0x2c>
}
800053ae:	d8 02       	popm	pc
800053b0:	80 01       	ld.sh	r1,r0[0x0]
800053b2:	31 44       	mov	r4,20
800053b4:	80 01       	ld.sh	r1,r0[0x0]
800053b6:	49 88       	lddpc	r8,80005414 <nes_run+0x50>
800053b8:	80 01       	ld.sh	r1,r0[0x0]
800053ba:	49 dc       	lddpc	r12,8000542c <nes_run+0x68>
800053bc:	80 00       	ld.sh	r0,r0[0x0]
800053be:	c1 a0       	breq	800053f2 <nes_run+0x2e>
800053c0:	80 00       	ld.sh	r0,r0[0x0]
800053c2:	45 bc       	lddsp	r12,sp[0x16c]

800053c4 <nes_run>:
}
static void nes_checkKeyboard(NES nes) {
  assert(nes != NULL);
  nes->isRunning = !gui_receivedTerminationRequest(nes->gui);
}
void nes_run(NES nes) {
800053c4:	d4 31       	pushm	r0-r7,lr
800053c6:	18 97       	mov	r7,r12
  //assert(nes != NULL);
  while(nes->isRunning == TRUE) {
800053c8:	f9 39 00 24 	ld.ub	r9,r12[36]
800053cc:	30 18       	mov	r8,1
800053ce:	f0 09 18 00 	cp.b	r9,r8
800053d2:	c5 a1       	brne	80005486 <nes_run+0xc2>
   // usart_write_line(&AVR32_USART0,"nes_run\n");
    if (interrupts_getRESET(nes->interrupts) == TRUE) {
800053d4:	10 96       	mov	r6,r8
      usart_write_line(&AVR32_USART0,"RESET\n");
800053d6:	4a d3       	lddpc	r3,80005488 <nes_run+0xc4>
800053d8:	fe 72 14 00 	mov	r2,-60416
      interrupts_setRESET(nes->interrupts, FALSE);
800053dc:	30 04       	mov	r4,0
      cpu_handleInterrupt(nes, CPU_RESET_VECTOR_LOWER_ADDRESS, FALSE);
800053de:	e0 61 ff fc 	mov	r1,65532
    } else if (interrupts_getNMI(nes->interrupts) == TRUE) {
      //usart_write_line(&AVR32_USART0,"NMI\n");
      interrupts_setNMI(nes->interrupts, FALSE);
      cpu_handleInterrupt(nes, CPU_NMI_VECTOR_LOWER_ADDRESS, FALSE);
800053e2:	e0 60 ff fa 	mov	r0,65530
  }
  free(nes);
}
static void nes_checkKeyboard(NES nes) {
  assert(nes != NULL);
  nes->isRunning = !gui_receivedTerminationRequest(nes->gui);
800053e6:	30 05       	mov	r5,0
}
void nes_run(NES nes) {
  //assert(nes != NULL);
  while(nes->isRunning == TRUE) {
   // usart_write_line(&AVR32_USART0,"nes_run\n");
    if (interrupts_getRESET(nes->interrupts) == TRUE) {
800053e8:	6e 7c       	ld.w	r12,r7[0x1c]
800053ea:	f0 1f 00 29 	mcall	8000548c <nes_run+0xc8>
800053ee:	ec 0c 18 00 	cp.b	r12,r6
800053f2:	c0 f1       	brne	80005410 <nes_run+0x4c>
      usart_write_line(&AVR32_USART0,"RESET\n");
800053f4:	06 9b       	mov	r11,r3
800053f6:	04 9c       	mov	r12,r2
800053f8:	f0 1f 00 26 	mcall	80005490 <nes_run+0xcc>
      interrupts_setRESET(nes->interrupts, FALSE);
800053fc:	08 9b       	mov	r11,r4
800053fe:	6e 7c       	ld.w	r12,r7[0x1c]
80005400:	f0 1f 00 25 	mcall	80005494 <nes_run+0xd0>
      cpu_handleInterrupt(nes, CPU_RESET_VECTOR_LOWER_ADDRESS, FALSE);
80005404:	08 9a       	mov	r10,r4
80005406:	02 9b       	mov	r11,r1
80005408:	0e 9c       	mov	r12,r7
8000540a:	f0 1f 00 24 	mcall	80005498 <nes_run+0xd4>
8000540e:	c2 58       	rjmp	80005458 <nes_run+0x94>
    } else if (interrupts_getNMI(nes->interrupts) == TRUE) {
80005410:	6e 7c       	ld.w	r12,r7[0x1c]
80005412:	f0 1f 00 23 	mcall	8000549c <nes_run+0xd8>
80005416:	ec 0c 18 00 	cp.b	r12,r6
8000541a:	c0 b1       	brne	80005430 <nes_run+0x6c>
      //usart_write_line(&AVR32_USART0,"NMI\n");
      interrupts_setNMI(nes->interrupts, FALSE);
8000541c:	08 9b       	mov	r11,r4
8000541e:	6e 7c       	ld.w	r12,r7[0x1c]
80005420:	f0 1f 00 20 	mcall	800054a0 <nes_run+0xdc>
      cpu_handleInterrupt(nes, CPU_NMI_VECTOR_LOWER_ADDRESS, FALSE);
80005424:	08 9a       	mov	r10,r4
80005426:	00 9b       	mov	r11,r0
80005428:	0e 9c       	mov	r12,r7
8000542a:	f0 1f 00 1c 	mcall	80005498 <nes_run+0xd4>
8000542e:	c1 58       	rjmp	80005458 <nes_run+0x94>
    } else if ((cpu_getInterruptDisable(nes->cpu1) == FALSE) && (interrupts_getIRQ(nes->interrupts) == TRUE)) {
80005430:	6e 3c       	ld.w	r12,r7[0xc]
80005432:	f0 1f 00 1d 	mcall	800054a4 <nes_run+0xe0>
80005436:	c1 11       	brne	80005458 <nes_run+0x94>
80005438:	6e 7c       	ld.w	r12,r7[0x1c]
8000543a:	f0 1f 00 1c 	mcall	800054a8 <nes_run+0xe4>
8000543e:	ec 0c 18 00 	cp.b	r12,r6
80005442:	c0 b1       	brne	80005458 <nes_run+0x94>
      //usart_write_line(&AVR32_USART0,"IRQ\n");
      interrupts_setIRQ(nes->interrupts, FALSE);
80005444:	08 9b       	mov	r11,r4
80005446:	6e 7c       	ld.w	r12,r7[0x1c]
80005448:	f0 1f 00 19 	mcall	800054ac <nes_run+0xe8>
      cpu_handleInterrupt(nes, CPU_IRQ_VECTOR_LOWER_ADDRESS, FALSE);
8000544c:	08 9a       	mov	r10,r4
8000544e:	e0 6b ff fe 	mov	r11,65534
80005452:	0e 9c       	mov	r12,r7
80005454:	f0 1f 00 11 	mcall	80005498 <nes_run+0xd4>
    }
	//usart_write_line(&AVR32_USART0,"step");
    cpu_step(nes);
80005458:	0e 9c       	mov	r12,r7
8000545a:	f0 1f 00 16 	mcall	800054b0 <nes_run+0xec>
    joypad_destroy(nes->joypads[i]);
  }
  free(nes);
}
static void nes_checkKeyboard(NES nes) {
  assert(nes != NULL);
8000545e:	58 07       	cp.w	r7,0
80005460:	c0 81       	brne	80005470 <nes_run+0xac>
80005462:	49 59       	lddpc	r9,800054b4 <nes_run+0xf0>
80005464:	49 5a       	lddpc	r10,800054b8 <nes_run+0xf4>
80005466:	e0 6b 00 c2 	mov	r11,194
8000546a:	49 5c       	lddpc	r12,800054bc <nes_run+0xf8>
8000546c:	f0 1f 00 15 	mcall	800054c0 <nes_run+0xfc>
  nes->isRunning = !gui_receivedTerminationRequest(nes->gui);
80005470:	6e ac       	ld.w	r12,r7[0x28]
80005472:	f0 1f 00 15 	mcall	800054c4 <nes_run+0x100>
80005476:	ea 0c 18 00 	cp.b	r12,r5
8000547a:	5f 08       	sreq	r8
8000547c:	ef 68 00 24 	st.b	r7[36],r8
}
void nes_run(NES nes) {
  //assert(nes != NULL);
  while(nes->isRunning == TRUE) {
80005480:	ec 08 18 00 	cp.b	r8,r6
80005484:	cb 20       	breq	800053e8 <nes_run+0x24>
80005486:	d8 32       	popm	r0-r7,pc
80005488:	80 01       	ld.sh	r1,r0[0x0]
8000548a:	4a 40       	lddpc	r0,80005518 <nes_writeJoypad+0x50>
8000548c:	80 00       	ld.sh	r0,r0[0x0]
8000548e:	46 0c       	lddsp	r12,sp[0x180]
80005490:	80 00       	ld.sh	r0,r0[0x0]
80005492:	8e 5c       	ld.sh	r12,r7[0xa]
80005494:	80 00       	ld.sh	r0,r0[0x0]
80005496:	45 94       	lddsp	r4,sp[0x164]
80005498:	80 00       	ld.sh	r0,r0[0x0]
8000549a:	2d 20       	sub	r0,-46
8000549c:	80 00       	ld.sh	r0,r0[0x0]
8000549e:	46 34       	lddsp	r4,sp[0x18c]
800054a0:	80 00       	ld.sh	r0,r0[0x0]
800054a2:	45 bc       	lddsp	r12,sp[0x16c]
800054a4:	80 00       	ld.sh	r0,r0[0x0]
800054a6:	28 fc       	sub	r12,-113
800054a8:	80 00       	ld.sh	r0,r0[0x0]
800054aa:	46 5c       	lddsp	r12,sp[0x194]
800054ac:	80 00       	ld.sh	r0,r0[0x0]
800054ae:	45 e4       	lddsp	r4,sp[0x178]
800054b0:	80 00       	ld.sh	r0,r0[0x0]
800054b2:	2e 14       	sub	r4,-31
800054b4:	80 01       	ld.sh	r1,r0[0x0]
800054b6:	31 44       	mov	r4,20
800054b8:	80 01       	ld.sh	r1,r0[0x0]
800054ba:	4c 70       	lddpc	r0,800055d4 <nes_init+0x54>
800054bc:	80 01       	ld.sh	r1,r0[0x0]
800054be:	49 dc       	lddpc	r12,80005530 <nes_writeJoypad+0x68>
800054c0:	80 00       	ld.sh	r0,r0[0x0]
800054c2:	c1 a0       	breq	800054f6 <nes_writeJoypad+0x2e>
800054c4:	80 00       	ld.sh	r0,r0[0x0]
800054c6:	44 6c       	lddsp	r12,sp[0x118]

800054c8 <nes_writeJoypad>:
Byte nes_readJoypad(NES nes, int joypadNumber) {
  assert(nes != NULL);
  assert(joypadNumber < NES_NUM_JOYPADS);
  return joypad_readByte(nes, nes->joypads[joypadNumber]);
}
void nes_writeJoypad(NES nes, int joypadNumber, Byte data) {
800054c8:	eb cd 40 80 	pushm	r7,lr
800054cc:	18 97       	mov	r7,r12
  assert(nes != NULL);
800054ce:	58 0c       	cp.w	r12,0
800054d0:	c0 81       	brne	800054e0 <nes_writeJoypad+0x18>
800054d2:	49 29       	lddpc	r9,80005518 <nes_writeJoypad+0x50>
800054d4:	49 2a       	lddpc	r10,8000551c <nes_writeJoypad+0x54>
800054d6:	e0 6b 00 a2 	mov	r11,162
800054da:	49 2c       	lddpc	r12,80005520 <nes_writeJoypad+0x58>
800054dc:	f0 1f 00 12 	mcall	80005524 <nes_writeJoypad+0x5c>
  assert(joypadNumber < NES_NUM_JOYPADS);
800054e0:	58 1b       	cp.w	r11,1
800054e2:	e0 8a 00 09 	brle	800054f4 <nes_writeJoypad+0x2c>
800054e6:	49 19       	lddpc	r9,80005528 <nes_writeJoypad+0x60>
800054e8:	48 da       	lddpc	r10,8000551c <nes_writeJoypad+0x54>
800054ea:	e0 6b 00 a3 	mov	r11,163
800054ee:	48 dc       	lddpc	r12,80005520 <nes_writeJoypad+0x58>
800054f0:	f0 1f 00 0d 	mcall	80005524 <nes_writeJoypad+0x5c>
  if (joypadNumber == 0) {
800054f4:	58 0b       	cp.w	r11,0
800054f6:	c0 f1       	brne	80005514 <nes_writeJoypad+0x4c>
    if ((data & MASK_BIT0) == MASK_BIT0) {
800054f8:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
800054fc:	c0 60       	breq	80005508 <nes_writeJoypad+0x40>
      gui_queryInput(nes->gui);
800054fe:	78 ac       	ld.w	r12,r12[0x28]
80005500:	f0 1f 00 0b 	mcall	8000552c <nes_writeJoypad+0x64>
80005504:	e3 cd 80 80 	ldm	sp++,r7,pc
    } else {
      int i;
      for (i=0; i < NES_NUM_JOYPADS; i++) {
        joypad_resetCurrentButton(nes->joypads[i]);
80005508:	78 bc       	ld.w	r12,r12[0x2c]
8000550a:	f0 1f 00 0a 	mcall	80005530 <nes_writeJoypad+0x68>
8000550e:	6e cc       	ld.w	r12,r7[0x30]
80005510:	f0 1f 00 08 	mcall	80005530 <nes_writeJoypad+0x68>
80005514:	e3 cd 80 80 	ldm	sp++,r7,pc
80005518:	80 01       	ld.sh	r1,r0[0x0]
8000551a:	31 44       	mov	r4,20
8000551c:	80 01       	ld.sh	r1,r0[0x0]
8000551e:	4c 4c       	lddpc	r12,8000562c <nes_init+0xac>
80005520:	80 01       	ld.sh	r1,r0[0x0]
80005522:	49 dc       	lddpc	r12,80005594 <nes_init+0x14>
80005524:	80 00       	ld.sh	r0,r0[0x0]
80005526:	c1 a0       	breq	8000555a <nes_readJoypad+0x26>
80005528:	80 01       	ld.sh	r1,r0[0x0]
8000552a:	4a 48       	lddpc	r8,800055b8 <nes_init+0x38>
8000552c:	80 00       	ld.sh	r0,r0[0x0]
8000552e:	44 48       	lddsp	r8,sp[0x110]
80005530:	80 00       	ld.sh	r0,r0[0x0]
80005532:	46 b8       	lddsp	r8,sp[0x1ac]

80005534 <nes_readJoypad>:
  usart_write_line(&AVR32_USART0,"Initial objectAttributeMemory\n");
  //memory_print(nes, nes->objectAttributeMemory);
  nes->isRunning = TRUE;
  return nes;
}
Byte nes_readJoypad(NES nes, int joypadNumber) {
80005534:	d4 01       	pushm	lr
  assert(nes != NULL);
80005536:	58 0c       	cp.w	r12,0
80005538:	c0 81       	brne	80005548 <nes_readJoypad+0x14>
8000553a:	48 c9       	lddpc	r9,80005568 <nes_readJoypad+0x34>
8000553c:	48 ca       	lddpc	r10,8000556c <nes_readJoypad+0x38>
8000553e:	e0 6b 00 9d 	mov	r11,157
80005542:	48 cc       	lddpc	r12,80005570 <nes_readJoypad+0x3c>
80005544:	f0 1f 00 0c 	mcall	80005574 <nes_readJoypad+0x40>
  assert(joypadNumber < NES_NUM_JOYPADS);
80005548:	58 1b       	cp.w	r11,1
8000554a:	e0 8a 00 09 	brle	8000555c <nes_readJoypad+0x28>
8000554e:	48 b9       	lddpc	r9,80005578 <nes_readJoypad+0x44>
80005550:	48 7a       	lddpc	r10,8000556c <nes_readJoypad+0x38>
80005552:	e0 6b 00 9e 	mov	r11,158
80005556:	48 7c       	lddpc	r12,80005570 <nes_readJoypad+0x3c>
80005558:	f0 1f 00 07 	mcall	80005574 <nes_readJoypad+0x40>
  return joypad_readByte(nes, nes->joypads[joypadNumber]);
8000555c:	2f 5b       	sub	r11,-11
8000555e:	f8 0b 03 2b 	ld.w	r11,r12[r11<<0x2]
80005562:	f0 1f 00 07 	mcall	8000557c <nes_readJoypad+0x48>
}
80005566:	d8 02       	popm	pc
80005568:	80 01       	ld.sh	r1,r0[0x0]
8000556a:	31 44       	mov	r4,20
8000556c:	80 01       	ld.sh	r1,r0[0x0]
8000556e:	4c d4       	lddpc	r4,800056a0 <nes_init+0x120>
80005570:	80 01       	ld.sh	r1,r0[0x0]
80005572:	49 dc       	lddpc	r12,800055e4 <nes_init+0x64>
80005574:	80 00       	ld.sh	r0,r0[0x0]
80005576:	c1 a0       	breq	800055aa <nes_init+0x2a>
80005578:	80 01       	ld.sh	r1,r0[0x0]
8000557a:	4a 48       	lddpc	r8,80005608 <nes_init+0x88>
8000557c:	80 00       	ld.sh	r0,r0[0x0]
8000557e:	46 e0       	lddsp	r0,sp[0x1b8]

80005580 <nes_init>:
  for (i=0; i < NES_NUM_JOYPADS; i++) {
    nes->joypads[i] = joypad_init(i);
    assert(nes->joypads[i] != NULL);
  }
}
NES nes_init(int filename, int width, int height) {
80005580:	d4 21       	pushm	r4-r7,lr
80005582:	18 96       	mov	r6,r12
80005584:	16 94       	mov	r4,r11
80005586:	14 95       	mov	r5,r10
  NES nes = (NES) malloc(sizeof(struct nes));
80005588:	33 4c       	mov	r12,52
8000558a:	f0 1f 00 7a 	mcall	80005770 <nes_init+0x1f0>
8000558e:	18 97       	mov	r7,r12
  assert(nes != NULL);
80005590:	c0 71       	brne	8000559e <nes_init+0x1e>
80005592:	4f 99       	lddpc	r9,80005774 <nes_init+0x1f4>
80005594:	4f 9a       	lddpc	r10,80005778 <nes_init+0x1f8>
80005596:	37 5b       	mov	r11,117
80005598:	4f 9c       	lddpc	r12,8000577c <nes_init+0x1fc>
8000559a:	f0 1f 00 7a 	mcall	80005780 <nes_init+0x200>
  nes->cartridge = NULL;
8000559e:	30 08       	mov	r8,0
800055a0:	99 68       	st.w	r12[0x18],r8
  nes->ppuMemory = NULL;
800055a2:	99 18       	st.w	r12[0x4],r8
  nes->cpuMemory = NULL;
800055a4:	99 08       	st.w	r12[0x0],r8
  nes->ppu = NULL;
800055a6:	99 48       	st.w	r12[0x10],r8
  nes->cpu1 = NULL;
800055a8:	99 38       	st.w	r12[0xc],r8
  nes->apu = NULL;
800055aa:	99 58       	st.w	r12[0x14],r8
  nes->interrupts = NULL;
800055ac:	99 78       	st.w	r12[0x1c],r8
  nes->mmu = NULL;
800055ae:	99 88       	st.w	r12[0x20],r8
  nes->objectAttributeMemory = NULL;
800055b0:	99 28       	st.w	r12[0x8],r8
  nes->gui = NULL;
800055b2:	99 a8       	st.w	r12[0x28],r8
  usart_write_line(&AVR32_USART0,"Initial cpuMemory1\n");
800055b4:	4f 4b       	lddpc	r11,80005784 <nes_init+0x204>
800055b6:	fe 7c 14 00 	mov	r12,-60416
800055ba:	f0 1f 00 74 	mcall	80005788 <nes_init+0x208>
  nes->ppuMemory = ppuMemory_init();
  //assert(nes->ppuMemory != NULL);
}
static void nes_init_cpuMemory(NES nes) {
 assert(nes != NULL);
 assert(nes->cpuMemory == NULL);
800055be:	6e 08       	ld.w	r8,r7[0x0]
800055c0:	58 08       	cp.w	r8,0
800055c2:	c0 70       	breq	800055d0 <nes_init+0x50>
800055c4:	4f 29       	lddpc	r9,8000578c <nes_init+0x20c>
800055c6:	4f 3a       	lddpc	r10,80005790 <nes_init+0x210>
800055c8:	34 bb       	mov	r11,75
800055ca:	4e dc       	lddpc	r12,8000577c <nes_init+0x1fc>
800055cc:	f0 1f 00 6d 	mcall	80005780 <nes_init+0x200>
  nes->cpuMemory = cpuMemory_init();
800055d0:	f0 1f 00 71 	mcall	80005794 <nes_init+0x214>
800055d4:	8f 0c       	st.w	r7[0x0],r12
 assert(nes->cpuMemory != NULL);
800055d6:	c0 71       	brne	800055e4 <nes_init+0x64>
800055d8:	4f 09       	lddpc	r9,80005798 <nes_init+0x218>
800055da:	4e ea       	lddpc	r10,80005790 <nes_init+0x210>
800055dc:	34 db       	mov	r11,77
800055de:	4e 8c       	lddpc	r12,8000577c <nes_init+0x1fc>
800055e0:	f0 1f 00 68 	mcall	80005780 <nes_init+0x200>
  nes->mmu = NULL;
  nes->objectAttributeMemory = NULL;
  nes->gui = NULL;
  usart_write_line(&AVR32_USART0,"Initial cpuMemory1\n");
  nes_init_cpuMemory(nes);
   usart_write_line(&AVR32_USART0,"Initial cpuMemory2\n");
800055e4:	4e eb       	lddpc	r11,8000579c <nes_init+0x21c>
800055e6:	fe 7c 14 00 	mov	r12,-60416
800055ea:	f0 1f 00 68 	mcall	80005788 <nes_init+0x208>
  assert(nes->cartridge != NULL);
}
static void nes_init_ppuMemory(NES nes) {
  //assert(nes != NULL);
  //assert(nes->ppuMemory == NULL);
  nes->ppuMemory = ppuMemory_init();
800055ee:	f0 1f 00 6d 	mcall	800057a0 <nes_init+0x220>
800055f2:	8f 1c       	st.w	r7[0x4],r12
  nes->gui = NULL;
  usart_write_line(&AVR32_USART0,"Initial cpuMemory1\n");
  nes_init_cpuMemory(nes);
   usart_write_line(&AVR32_USART0,"Initial cpuMemory2\n");
  nes_init_ppuMemory(nes);
   usart_write_line(&AVR32_USART0,"Initial cpuMemory3\n");
800055f4:	4e cb       	lddpc	r11,800057a4 <nes_init+0x224>
800055f6:	fe 7c 14 00 	mov	r12,-60416
800055fa:	f0 1f 00 64 	mcall	80005788 <nes_init+0x208>
  nes->apu = apu_init();
  assert(nes->apu != NULL);
}
static void nes_init_cartridge(NES nes, int filename) {
  assert(nes != NULL);
  assert(nes->cartridge == NULL);
800055fe:	6e 68       	ld.w	r8,r7[0x18]
80005600:	58 08       	cp.w	r8,0
80005602:	c0 70       	breq	80005610 <nes_init+0x90>
80005604:	4e 99       	lddpc	r9,800057a8 <nes_init+0x228>
80005606:	4e aa       	lddpc	r10,800057ac <nes_init+0x22c>
80005608:	33 fb       	mov	r11,63
8000560a:	4d dc       	lddpc	r12,8000577c <nes_init+0x1fc>
8000560c:	f0 1f 00 5d 	mcall	80005780 <nes_init+0x200>
  nes->cartridge = cartridge_init(filename);
80005610:	0c 9c       	mov	r12,r6
80005612:	f0 1f 00 68 	mcall	800057b0 <nes_init+0x230>
80005616:	8f 6c       	st.w	r7[0x18],r12
  assert(nes->cartridge != NULL);
80005618:	c0 71       	brne	80005626 <nes_init+0xa6>
8000561a:	4e 79       	lddpc	r9,800057b4 <nes_init+0x234>
8000561c:	4e 4a       	lddpc	r10,800057ac <nes_init+0x22c>
8000561e:	34 1b       	mov	r11,65
80005620:	4d 7c       	lddpc	r12,8000577c <nes_init+0x1fc>
80005622:	f0 1f 00 58 	mcall	80005780 <nes_init+0x200>
  nes->ppu = ppu_init();
  assert(nes->ppu != NULL);
}
static void nes_init_apu(NES nes) {
  assert(nes != NULL);
  assert(nes->apu == NULL);
80005626:	6e 58       	ld.w	r8,r7[0x14]
80005628:	58 08       	cp.w	r8,0
8000562a:	c0 70       	breq	80005638 <nes_init+0xb8>
8000562c:	4e 39       	lddpc	r9,800057b8 <nes_init+0x238>
8000562e:	4e 4a       	lddpc	r10,800057bc <nes_init+0x23c>
80005630:	33 9b       	mov	r11,57
80005632:	4d 3c       	lddpc	r12,8000577c <nes_init+0x1fc>
80005634:	f0 1f 00 53 	mcall	80005780 <nes_init+0x200>
  nes->apu = apu_init();
80005638:	f0 1f 00 62 	mcall	800057c0 <nes_init+0x240>
8000563c:	8f 5c       	st.w	r7[0x14],r12
  assert(nes->apu != NULL);
8000563e:	c0 71       	brne	8000564c <nes_init+0xcc>
80005640:	4e 19       	lddpc	r9,800057c4 <nes_init+0x244>
80005642:	4d fa       	lddpc	r10,800057bc <nes_init+0x23c>
80005644:	33 bb       	mov	r11,59
80005646:	4c ec       	lddpc	r12,8000577c <nes_init+0x1fc>
80005648:	f0 1f 00 4e 	mcall	80005780 <nes_init+0x200>
  interrupts_setRESET(nes->interrupts, TRUE);
}

static void nes_init_cpu(NES nes) {
  assert(nes != NULL);
  assert(nes->cpu1 == NULL);
8000564c:	6e 38       	ld.w	r8,r7[0xc]
8000564e:	58 08       	cp.w	r8,0
80005650:	c0 70       	breq	8000565e <nes_init+0xde>
80005652:	4d e9       	lddpc	r9,800057c8 <nes_init+0x248>
80005654:	4d ea       	lddpc	r10,800057cc <nes_init+0x24c>
80005656:	32 db       	mov	r11,45
80005658:	4c 9c       	lddpc	r12,8000577c <nes_init+0x1fc>
8000565a:	f0 1f 00 4a 	mcall	80005780 <nes_init+0x200>
  nes->cpu1 = cpu_init();
8000565e:	f0 1f 00 5d 	mcall	800057d0 <nes_init+0x250>
80005662:	8f 3c       	st.w	r7[0xc],r12
  assert(nes->cpu1 != NULL);
80005664:	c0 71       	brne	80005672 <nes_init+0xf2>
80005666:	4d c9       	lddpc	r9,800057d4 <nes_init+0x254>
80005668:	4d 9a       	lddpc	r10,800057cc <nes_init+0x24c>
8000566a:	32 fb       	mov	r11,47
8000566c:	4c 4c       	lddpc	r12,8000577c <nes_init+0x1fc>
8000566e:	f0 1f 00 45 	mcall	80005780 <nes_init+0x200>
}
static void nes_init_ppu(NES nes) {
  assert(nes != NULL);
  assert(nes->ppu == NULL);
80005672:	6e 48       	ld.w	r8,r7[0x10]
80005674:	58 08       	cp.w	r8,0
80005676:	c0 70       	breq	80005684 <nes_init+0x104>
80005678:	4d 89       	lddpc	r9,800057d8 <nes_init+0x258>
8000567a:	4d 9a       	lddpc	r10,800057dc <nes_init+0x25c>
8000567c:	33 3b       	mov	r11,51
8000567e:	4c 0c       	lddpc	r12,8000577c <nes_init+0x1fc>
80005680:	f0 1f 00 40 	mcall	80005780 <nes_init+0x200>
  nes->ppu = ppu_init();
80005684:	f0 1f 00 57 	mcall	800057e0 <nes_init+0x260>
80005688:	8f 4c       	st.w	r7[0x10],r12
  assert(nes->ppu != NULL);
8000568a:	c0 71       	brne	80005698 <nes_init+0x118>
8000568c:	4d 69       	lddpc	r9,800057e4 <nes_init+0x264>
8000568e:	4d 4a       	lddpc	r10,800057dc <nes_init+0x25c>
80005690:	33 5b       	mov	r11,53
80005692:	4b bc       	lddpc	r12,8000577c <nes_init+0x1fc>
80005694:	f0 1f 00 3b 	mcall	80005780 <nes_init+0x200>
  GUI gui;
  Joypad joypads[NES_NUM_JOYPADS];
};
static void nes_init_interrupts(NES nes) {
  assert(nes != NULL);
  assert(nes->interrupts == NULL);
80005698:	6e 78       	ld.w	r8,r7[0x1c]
8000569a:	58 08       	cp.w	r8,0
8000569c:	c0 70       	breq	800056aa <nes_init+0x12a>
8000569e:	4d 39       	lddpc	r9,800057e8 <nes_init+0x268>
800056a0:	4d 3a       	lddpc	r10,800057ec <nes_init+0x26c>
800056a2:	32 5b       	mov	r11,37
800056a4:	4b 6c       	lddpc	r12,8000577c <nes_init+0x1fc>
800056a6:	f0 1f 00 37 	mcall	80005780 <nes_init+0x200>
  nes->interrupts = interrupts_init();
800056aa:	f0 1f 00 52 	mcall	800057f0 <nes_init+0x270>
800056ae:	8f 7c       	st.w	r7[0x1c],r12
  assert(nes->interrupts != NULL);
800056b0:	c0 71       	brne	800056be <nes_init+0x13e>
800056b2:	4d 19       	lddpc	r9,800057f4 <nes_init+0x274>
800056b4:	4c ea       	lddpc	r10,800057ec <nes_init+0x26c>
800056b6:	32 7b       	mov	r11,39
800056b8:	4b 1c       	lddpc	r12,8000577c <nes_init+0x1fc>
800056ba:	f0 1f 00 32 	mcall	80005780 <nes_init+0x200>
  interrupts_setRESET(nes->interrupts, TRUE);
800056be:	30 1b       	mov	r11,1
800056c0:	f0 1f 00 4e 	mcall	800057f8 <nes_init+0x278>
  nes->mmu = mmu_init(nes);
  assert(nes->mmu != NULL);
}
static void nes_init_objectAttributeMemory(NES nes) {
  assert(nes != NULL);
  assert(nes->objectAttributeMemory == NULL);
800056c4:	6e 28       	ld.w	r8,r7[0x8]
800056c6:	58 08       	cp.w	r8,0
800056c8:	c0 70       	breq	800056d6 <nes_init+0x156>
800056ca:	4c d9       	lddpc	r9,800057fc <nes_init+0x27c>
800056cc:	4c da       	lddpc	r10,80005800 <nes_init+0x280>
800056ce:	35 7b       	mov	r11,87
800056d0:	4a bc       	lddpc	r12,8000577c <nes_init+0x1fc>
800056d2:	f0 1f 00 2c 	mcall	80005780 <nes_init+0x200>
  nes->objectAttributeMemory = objectAttributeMemory_init();
800056d6:	f0 1f 00 4c 	mcall	80005804 <nes_init+0x284>
800056da:	8f 2c       	st.w	r7[0x8],r12
  assert(nes->objectAttributeMemory != NULL);
800056dc:	c0 71       	brne	800056ea <nes_init+0x16a>
800056de:	4c b9       	lddpc	r9,80005808 <nes_init+0x288>
800056e0:	4c 8a       	lddpc	r10,80005800 <nes_init+0x280>
800056e2:	35 9b       	mov	r11,89
800056e4:	4a 6c       	lddpc	r12,8000577c <nes_init+0x1fc>
800056e6:	f0 1f 00 27 	mcall	80005780 <nes_init+0x200>
  //usart_write_line(&AVR32_USART0,"generateNMI\n");
  interrupts_setNMI(nes->interrupts, TRUE);
}
static void nes_init_gui(NES nes, int width, int height) {
  assert(nes != NULL);
  assert(nes->gui == NULL);
800056ea:	6e a8       	ld.w	r8,r7[0x28]
800056ec:	58 08       	cp.w	r8,0
800056ee:	c0 70       	breq	800056fc <nes_init+0x17c>
800056f0:	4c 79       	lddpc	r9,8000580c <nes_init+0x28c>
800056f2:	4c 8a       	lddpc	r10,80005810 <nes_init+0x290>
800056f4:	36 7b       	mov	r11,103
800056f6:	4a 2c       	lddpc	r12,8000577c <nes_init+0x1fc>
800056f8:	f0 1f 00 22 	mcall	80005780 <nes_init+0x200>
  nes->gui = gui_init(width, height);
800056fc:	0a 9b       	mov	r11,r5
800056fe:	08 9c       	mov	r12,r4
80005700:	f0 1f 00 45 	mcall	80005814 <nes_init+0x294>
80005704:	8f ac       	st.w	r7[0x28],r12
  assert(nes->gui != NULL);
80005706:	c0 71       	brne	80005714 <nes_init+0x194>
80005708:	4c 49       	lddpc	r9,80005818 <nes_init+0x298>
8000570a:	4c 2a       	lddpc	r10,80005810 <nes_init+0x290>
8000570c:	36 9b       	mov	r11,105
8000570e:	49 cc       	lddpc	r12,8000577c <nes_init+0x1fc>
80005710:	f0 1f 00 1c 	mcall	80005780 <nes_init+0x200>
}
static void nes_init_joypads(NES nes) {
  assert(nes != NULL);
  int i;
  for (i=0; i < NES_NUM_JOYPADS; i++) {
    nes->joypads[i] = joypad_init(i);
80005714:	30 0c       	mov	r12,0
80005716:	f0 1f 00 42 	mcall	8000581c <nes_init+0x29c>
8000571a:	8f bc       	st.w	r7[0x2c],r12
    assert(nes->joypads[i] != NULL);
8000571c:	c0 60       	breq	80005728 <nes_init+0x1a8>
}
static void nes_init_joypads(NES nes) {
  assert(nes != NULL);
  int i;
  for (i=0; i < NES_NUM_JOYPADS; i++) {
    nes->joypads[i] = joypad_init(i);
8000571e:	30 1c       	mov	r12,1
80005720:	f0 1f 00 3f 	mcall	8000581c <nes_init+0x29c>
80005724:	8f cc       	st.w	r7[0x30],r12
    assert(nes->joypads[i] != NULL);
80005726:	c0 71       	brne	80005734 <nes_init+0x1b4>
80005728:	4b e9       	lddpc	r9,80005820 <nes_init+0x2a0>
8000572a:	4b fa       	lddpc	r10,80005824 <nes_init+0x2a4>
8000572c:	37 0b       	mov	r11,112
8000572e:	49 4c       	lddpc	r12,8000577c <nes_init+0x1fc>
80005730:	f0 1f 00 14 	mcall	80005780 <nes_init+0x200>
  nes->cpuMemory = cpuMemory_init();
 assert(nes->cpuMemory != NULL);
}
static void nes_init_mmu(NES nes) {
  assert(nes != NULL);
  assert(nes->mmu == NULL);
80005734:	6e 88       	ld.w	r8,r7[0x20]
80005736:	58 08       	cp.w	r8,0
80005738:	c0 70       	breq	80005746 <nes_init+0x1c6>
8000573a:	4b c9       	lddpc	r9,80005828 <nes_init+0x2a8>
8000573c:	4b ca       	lddpc	r10,8000582c <nes_init+0x2ac>
8000573e:	35 1b       	mov	r11,81
80005740:	48 fc       	lddpc	r12,8000577c <nes_init+0x1fc>
80005742:	f0 1f 00 10 	mcall	80005780 <nes_init+0x200>
  nes->mmu = mmu_init(nes);
80005746:	0e 9c       	mov	r12,r7
80005748:	f0 1f 00 3a 	mcall	80005830 <nes_init+0x2b0>
8000574c:	8f 8c       	st.w	r7[0x20],r12
  assert(nes->mmu != NULL);
8000574e:	c0 71       	brne	8000575c <nes_init+0x1dc>
80005750:	4b 99       	lddpc	r9,80005834 <nes_init+0x2b4>
80005752:	4b 7a       	lddpc	r10,8000582c <nes_init+0x2ac>
80005754:	35 3b       	mov	r11,83
80005756:	48 ac       	lddpc	r12,8000577c <nes_init+0x1fc>
80005758:	f0 1f 00 0a 	mcall	80005780 <nes_init+0x200>
 // memory_print(nes, nes->cpuMemory);
  //usart_write_line(&AVR32_USART0,"\n");
  //usart_write_line(&AVR32_USART0,"Initial ppuMemory\n");
 // memory_print(nes, nes->ppuMemory);
  //usart_write_line(&AVR32_USART0,"\n");
  usart_write_line(&AVR32_USART0,"Initial objectAttributeMemory\n");
8000575c:	4b 7b       	lddpc	r11,80005838 <nes_init+0x2b8>
8000575e:	fe 7c 14 00 	mov	r12,-60416
80005762:	f0 1f 00 0a 	mcall	80005788 <nes_init+0x208>
  //memory_print(nes, nes->objectAttributeMemory);
  nes->isRunning = TRUE;
80005766:	30 18       	mov	r8,1
80005768:	ef 68 00 24 	st.b	r7[36],r8
  return nes;
}
8000576c:	0e 9c       	mov	r12,r7
8000576e:	d8 22       	popm	r4-r7,pc
80005770:	80 00       	ld.sh	r0,r0[0x0]
80005772:	c1 fc       	rcall	800057b0 <nes_init+0x230>
80005774:	80 01       	ld.sh	r1,r0[0x0]
80005776:	31 44       	mov	r4,20
80005778:	80 01       	ld.sh	r1,r0[0x0]
8000577a:	4c ac       	lddpc	r12,800058a0 <objectAttributeMemory_getAttributes+0x30>
8000577c:	80 01       	ld.sh	r1,r0[0x0]
8000577e:	49 dc       	lddpc	r12,800057f0 <nes_init+0x270>
80005780:	80 00       	ld.sh	r0,r0[0x0]
80005782:	c1 a0       	breq	800057b6 <nes_init+0x236>
80005784:	80 01       	ld.sh	r1,r0[0x0]
80005786:	4a 68       	lddpc	r8,8000581c <nes_init+0x29c>
80005788:	80 00       	ld.sh	r0,r0[0x0]
8000578a:	8e 5c       	ld.sh	r12,r7[0xa]
8000578c:	80 01       	ld.sh	r1,r0[0x0]
8000578e:	4a 7c       	lddpc	r12,80005828 <nes_init+0x2a8>
80005790:	80 01       	ld.sh	r1,r0[0x0]
80005792:	4c f4       	lddpc	r4,800058cc <objectAttributeMemory_isFlippedVertical+0x24>
80005794:	80 00       	ld.sh	r0,r0[0x0]
80005796:	3a 30       	mov	r0,-93
80005798:	80 01       	ld.sh	r1,r0[0x0]
8000579a:	4a 28       	lddpc	r8,80005820 <nes_init+0x2a0>
8000579c:	80 01       	ld.sh	r1,r0[0x0]
8000579e:	4a 94       	lddpc	r4,80005840 <objectAttributeMemory_getX+0x4>
800057a0:	80 00       	ld.sh	r0,r0[0x0]
800057a2:	6b 4c       	ld.w	r12,r5[0x50]
800057a4:	80 01       	ld.sh	r1,r0[0x0]
800057a6:	4a a8       	lddpc	r8,8000584c <objectAttributeMemory_getX+0x10>
800057a8:	80 01       	ld.sh	r1,r0[0x0]
800057aa:	4a bc       	lddpc	r12,80005854 <objectAttributeMemory_getX+0x18>
800057ac:	80 01       	ld.sh	r1,r0[0x0]
800057ae:	49 20       	lddpc	r0,800057f4 <nes_init+0x274>
800057b0:	80 00       	ld.sh	r0,r0[0x0]
800057b2:	23 d8       	sub	r8,61
800057b4:	80 01       	ld.sh	r1,r0[0x0]
800057b6:	4a d4       	lddpc	r4,80005868 <objectAttributeMemory_getX+0x2c>
800057b8:	80 01       	ld.sh	r1,r0[0x0]
800057ba:	4a ec       	lddpc	r12,80005870 <objectAttributeMemory_getAttributes>
800057bc:	80 01       	ld.sh	r1,r0[0x0]
800057be:	48 dc       	lddpc	r12,800057f0 <nes_init+0x270>
800057c0:	80 00       	ld.sh	r0,r0[0x0]
800057c2:	21 bc       	sub	r12,27
800057c4:	80 01       	ld.sh	r1,r0[0x0]
800057c6:	4b 00       	lddpc	r0,80005884 <objectAttributeMemory_getAttributes+0x14>
800057c8:	80 01       	ld.sh	r1,r0[0x0]
800057ca:	4b 14       	lddpc	r4,8000588c <objectAttributeMemory_getAttributes+0x1c>
800057cc:	80 01       	ld.sh	r1,r0[0x0]
800057ce:	4c c4       	lddpc	r4,800058fc <objectAttributeMemory_isFlippedHorizontal+0x24>
800057d0:	80 00       	ld.sh	r0,r0[0x0]
800057d2:	39 80       	mov	r0,-104
800057d4:	80 01       	ld.sh	r1,r0[0x0]
800057d6:	4b 28       	lddpc	r8,8000589c <objectAttributeMemory_getAttributes+0x2c>
800057d8:	80 01       	ld.sh	r1,r0[0x0]
800057da:	4b 3c       	lddpc	r12,800058a4 <objectAttributeMemory_getAttributes+0x34>
800057dc:	80 01       	ld.sh	r1,r0[0x0]
800057de:	4c e4       	lddpc	r4,80005914 <objectAttributeMemory_isBehindBackground+0xc>
800057e0:	80 00       	ld.sh	r0,r0[0x0]
800057e2:	6a d8       	ld.w	r8,r5[0x34]
800057e4:	80 01       	ld.sh	r1,r0[0x0]
800057e6:	4b 50       	lddpc	r0,800058b8 <objectAttributeMemory_isFlippedVertical+0x10>
800057e8:	80 01       	ld.sh	r1,r0[0x0]
800057ea:	4b 64       	lddpc	r4,800058c0 <objectAttributeMemory_isFlippedVertical+0x18>
800057ec:	80 01       	ld.sh	r1,r0[0x0]
800057ee:	4c 84       	lddpc	r4,8000590c <objectAttributeMemory_isBehindBackground+0x4>
800057f0:	80 00       	ld.sh	r0,r0[0x0]
800057f2:	46 84       	lddsp	r4,sp[0x1a0]
800057f4:	80 01       	ld.sh	r1,r0[0x0]
800057f6:	4b 7c       	lddpc	r12,800058d0 <objectAttributeMemory_isFlippedVertical+0x28>
800057f8:	80 00       	ld.sh	r0,r0[0x0]
800057fa:	45 94       	lddsp	r4,sp[0x164]
800057fc:	80 01       	ld.sh	r1,r0[0x0]
800057fe:	4b 94       	lddpc	r4,800058e0 <objectAttributeMemory_isFlippedHorizontal+0x8>
80005800:	80 01       	ld.sh	r1,r0[0x0]
80005802:	48 ec       	lddpc	r12,80005838 <nes_init+0x2b8>
80005804:	80 00       	ld.sh	r0,r0[0x0]
80005806:	5a 18       	cp.w	r8,-31
80005808:	80 01       	ld.sh	r1,r0[0x0]
8000580a:	4a 04       	lddpc	r4,80005888 <objectAttributeMemory_getAttributes+0x18>
8000580c:	80 01       	ld.sh	r1,r0[0x0]
8000580e:	4b b8       	lddpc	r8,800058f8 <objectAttributeMemory_isFlippedHorizontal+0x20>
80005810:	80 01       	ld.sh	r1,r0[0x0]
80005812:	49 cc       	lddpc	r12,80005880 <objectAttributeMemory_getAttributes+0x10>
80005814:	80 00       	ld.sh	r0,r0[0x0]
80005816:	44 c0       	lddsp	r0,sp[0x130]
80005818:	80 01       	ld.sh	r1,r0[0x0]
8000581a:	49 f0       	lddpc	r0,80005894 <objectAttributeMemory_getAttributes+0x24>
8000581c:	80 00       	ld.sh	r0,r0[0x0]
8000581e:	47 68       	lddsp	r8,sp[0x1d8]
80005820:	80 01       	ld.sh	r1,r0[0x0]
80005822:	4b cc       	lddpc	r12,80005910 <objectAttributeMemory_isBehindBackground+0x8>
80005824:	80 01       	ld.sh	r1,r0[0x0]
80005826:	4d 14       	lddpc	r4,80005968 <objectAttributeMemory_getPalette+0x30>
80005828:	80 01       	ld.sh	r1,r0[0x0]
8000582a:	4b e4       	lddpc	r4,80005920 <objectAttributeMemory_isBehindBackground+0x18>
8000582c:	80 01       	ld.sh	r1,r0[0x0]
8000582e:	4c 3c       	lddpc	r12,80005938 <objectAttributeMemory_getPalette>
80005830:	80 00       	ld.sh	r0,r0[0x0]
80005832:	4b 80       	lddpc	r0,80005910 <objectAttributeMemory_isBehindBackground+0x8>
80005834:	80 01       	ld.sh	r1,r0[0x0]
80005836:	4b f8       	lddpc	r8,80005930 <objectAttributeMemory_isBehindBackground+0x28>
80005838:	80 01       	ld.sh	r1,r0[0x0]
8000583a:	4c 0c       	lddpc	r12,80005938 <objectAttributeMemory_getPalette>

8000583c <objectAttributeMemory_getX>:
    return FALSE;
  }
}
// byte 3
// 3    -      scanline pixel coordite of most left-hand side of object.
Byte objectAttributeMemory_getX(Memory memory, int spriteIndex) {
8000583c:	d4 01       	pushm	lr
  assert(memory != NULL);
8000583e:	58 0c       	cp.w	r12,0
80005840:	c0 71       	brne	8000584e <objectAttributeMemory_getX+0x12>
80005842:	48 79       	lddpc	r9,8000585c <objectAttributeMemory_getX+0x20>
80005844:	48 7a       	lddpc	r10,80005860 <objectAttributeMemory_getX+0x24>
80005846:	36 2b       	mov	r11,98
80005848:	48 7c       	lddpc	r12,80005864 <objectAttributeMemory_getX+0x28>
8000584a:	f0 1f 00 08 	mcall	80005868 <objectAttributeMemory_getX+0x2c>
  Byte address = (OAM_BYTES_PER_SPRITE * spriteIndex) + OAM_X_BYTE_OFFSET;
  return memory_read_direct(memory, address);
8000584e:	a3 6b       	lsl	r11,0x2
80005850:	2f db       	sub	r11,-3
80005852:	5c 5b       	castu.b	r11
80005854:	f0 1f 00 06 	mcall	8000586c <objectAttributeMemory_getX+0x30>
80005858:	d8 02       	popm	pc
8000585a:	00 00       	add	r0,r0
8000585c:	80 01       	ld.sh	r1,r0[0x0]
8000585e:	45 64       	lddsp	r4,sp[0x158]
80005860:	80 01       	ld.sh	r1,r0[0x0]
80005862:	4e 54       	lddpc	r4,800059f4 <objectAttributeMemory_getY+0x10>
80005864:	80 01       	ld.sh	r1,r0[0x0]
80005866:	4d ec       	lddpc	r12,800059dc <objectAttributeMemory_getBankNumber+0x30>
80005868:	80 00       	ld.sh	r0,r0[0x0]
8000586a:	c1 a0       	breq	8000589e <objectAttributeMemory_getAttributes+0x2e>
8000586c:	80 00       	ld.sh	r0,r0[0x0]
8000586e:	47 f8       	lddsp	r8,sp[0x1fc]

80005870 <objectAttributeMemory_getAttributes>:
    // lose the 0th bit
    return (data >> 1) << 1;
  }
}
// byte 2
Byte objectAttributeMemory_getAttributes(Memory memory, int spriteIndex) {
80005870:	d4 01       	pushm	lr
  assert(memory != NULL);
80005872:	58 0c       	cp.w	r12,0
80005874:	c0 71       	brne	80005882 <objectAttributeMemory_getAttributes+0x12>
80005876:	48 89       	lddpc	r9,80005894 <objectAttributeMemory_getAttributes+0x24>
80005878:	48 8a       	lddpc	r10,80005898 <objectAttributeMemory_getAttributes+0x28>
8000587a:	33 8b       	mov	r11,56
8000587c:	48 8c       	lddpc	r12,8000589c <objectAttributeMemory_getAttributes+0x2c>
8000587e:	f0 1f 00 09 	mcall	800058a0 <objectAttributeMemory_getAttributes+0x30>
  Byte address = (OAM_BYTES_PER_SPRITE * spriteIndex) + OAM_ATTRIBUTES_BYTE_OFFSET;
  return memory_read_direct(memory, address);
80005882:	a1 7b       	lsl	r11,0x1
80005884:	2f fb       	sub	r11,-1
80005886:	a1 7b       	lsl	r11,0x1
80005888:	e2 1b 00 fe 	andl	r11,0xfe,COH
8000588c:	f0 1f 00 06 	mcall	800058a4 <objectAttributeMemory_getAttributes+0x34>
}
80005890:	d8 02       	popm	pc
80005892:	00 00       	add	r0,r0
80005894:	80 01       	ld.sh	r1,r0[0x0]
80005896:	45 64       	lddsp	r4,sp[0x158]
80005898:	80 01       	ld.sh	r1,r0[0x0]
8000589a:	4d c8       	lddpc	r8,80005a08 <objectAttributeMemory_getY+0x24>
8000589c:	80 01       	ld.sh	r1,r0[0x0]
8000589e:	4d ec       	lddpc	r12,80005a14 <objectAttributeMemory_getY+0x30>
800058a0:	80 00       	ld.sh	r0,r0[0x0]
800058a2:	c1 a0       	breq	800058d6 <objectAttributeMemory_isFlippedVertical+0x2e>
800058a4:	80 00       	ld.sh	r0,r0[0x0]
800058a6:	47 f8       	lddsp	r8,sp[0x1fc]

800058a8 <objectAttributeMemory_isFlippedVertical>:
    return TRUE;
  } else {
    return FALSE;
  }
}
Bool objectAttributeMemory_isFlippedVertical(Memory memory, int spriteIndex) {
800058a8:	d4 01       	pushm	lr
  assert(memory != NULL);
800058aa:	58 0c       	cp.w	r12,0
800058ac:	c0 71       	brne	800058ba <objectAttributeMemory_isFlippedVertical+0x12>
800058ae:	48 69       	lddpc	r9,800058c4 <objectAttributeMemory_isFlippedVertical+0x1c>
800058b0:	48 6a       	lddpc	r10,800058c8 <objectAttributeMemory_isFlippedVertical+0x20>
800058b2:	35 7b       	mov	r11,87
800058b4:	48 6c       	lddpc	r12,800058cc <objectAttributeMemory_isFlippedVertical+0x24>
800058b6:	f0 1f 00 07 	mcall	800058d0 <objectAttributeMemory_isFlippedVertical+0x28>
  Byte attributes = objectAttributeMemory_getAttributes(memory, spriteIndex);
800058ba:	f0 1f 00 07 	mcall	800058d4 <objectAttributeMemory_isFlippedVertical+0x2c>
  if ( (attributes & MASK_OAM_FLIP_VERTICAL_ON) == MASK_OAM_FLIP_VERTICAL_ON) {
    return TRUE;
  } else {
    return FALSE;
  }
}
800058be:	f9 dc c0 e8 	bfextu	r12,r12,0x7,0x8
800058c2:	d8 02       	popm	pc
800058c4:	80 01       	ld.sh	r1,r0[0x0]
800058c6:	45 64       	lddsp	r4,sp[0x158]
800058c8:	80 01       	ld.sh	r1,r0[0x0]
800058ca:	4e 2c       	lddpc	r12,80005a50 <ppu_getBackgroundTileNumber+0x8>
800058cc:	80 01       	ld.sh	r1,r0[0x0]
800058ce:	4d ec       	lddpc	r12,80005a44 <objectAttributeMemory_init+0x2c>
800058d0:	80 00       	ld.sh	r0,r0[0x0]
800058d2:	c1 a0       	breq	80005906 <objectAttributeMemory_isFlippedHorizontal+0x2e>
800058d4:	80 00       	ld.sh	r0,r0[0x0]
800058d6:	58 70       	cp.w	r0,7

800058d8 <objectAttributeMemory_isFlippedHorizontal>:
    return TRUE;
  } else {
    return FALSE;
  }
}
Bool objectAttributeMemory_isFlippedHorizontal(Memory memory, int spriteIndex) {
800058d8:	d4 01       	pushm	lr
  assert(memory != NULL);
800058da:	58 0c       	cp.w	r12,0
800058dc:	c0 71       	brne	800058ea <objectAttributeMemory_isFlippedHorizontal+0x12>
800058de:	48 69       	lddpc	r9,800058f4 <objectAttributeMemory_isFlippedHorizontal+0x1c>
800058e0:	48 6a       	lddpc	r10,800058f8 <objectAttributeMemory_isFlippedHorizontal+0x20>
800058e2:	34 eb       	mov	r11,78
800058e4:	48 6c       	lddpc	r12,800058fc <objectAttributeMemory_isFlippedHorizontal+0x24>
800058e6:	f0 1f 00 07 	mcall	80005900 <objectAttributeMemory_isFlippedHorizontal+0x28>
  Byte attributes = objectAttributeMemory_getAttributes(memory, spriteIndex);
800058ea:	f0 1f 00 07 	mcall	80005904 <objectAttributeMemory_isFlippedHorizontal+0x2c>
  if ( (attributes & MASK_OAM_FLIP_HORIZONTAL_ON) == MASK_OAM_FLIP_HORIZONTAL_ON) {
    return TRUE;
  } else {
    return FALSE;
  }
}
800058ee:	f9 dc c0 c1 	bfextu	r12,r12,0x6,0x1
800058f2:	d8 02       	popm	pc
800058f4:	80 01       	ld.sh	r1,r0[0x0]
800058f6:	45 64       	lddsp	r4,sp[0x158]
800058f8:	80 01       	ld.sh	r1,r0[0x0]
800058fa:	4d 9c       	lddpc	r12,80005a5c <ppu_setStatusVerticalBlank>
800058fc:	80 01       	ld.sh	r1,r0[0x0]
800058fe:	4d ec       	lddpc	r12,80005a74 <ppu_setStatusVerticalBlank+0x18>
80005900:	80 00       	ld.sh	r0,r0[0x0]
80005902:	c1 a0       	breq	80005936 <objectAttributeMemory_isBehindBackground+0x2e>
80005904:	80 00       	ld.sh	r0,r0[0x0]
80005906:	58 70       	cp.w	r0,7

80005908 <objectAttributeMemory_isBehindBackground>:
  Byte attributes = objectAttributeMemory_getAttributes(memory, spriteIndex);
  // lose the 765432 bits
  attributes = (attributes << 6) >> 4;
  return attributes; // + 4;
}
Bool objectAttributeMemory_isBehindBackground(Memory memory, int spriteIndex) {
80005908:	d4 01       	pushm	lr
  assert(memory != NULL);
8000590a:	58 0c       	cp.w	r12,0
8000590c:	c0 71       	brne	8000591a <objectAttributeMemory_isBehindBackground+0x12>
8000590e:	48 69       	lddpc	r9,80005924 <objectAttributeMemory_isBehindBackground+0x1c>
80005910:	48 6a       	lddpc	r10,80005928 <objectAttributeMemory_isBehindBackground+0x20>
80005912:	34 5b       	mov	r11,69
80005914:	48 6c       	lddpc	r12,8000592c <objectAttributeMemory_isBehindBackground+0x24>
80005916:	f0 1f 00 07 	mcall	80005930 <objectAttributeMemory_isBehindBackground+0x28>
  Byte attributes = objectAttributeMemory_getAttributes(memory, spriteIndex);
8000591a:	f0 1f 00 07 	mcall	80005934 <objectAttributeMemory_isBehindBackground+0x2c>
  if ( (attributes & MASK_OAM_BEHIND_BACKGROUND_ON) == MASK_OAM_BEHIND_BACKGROUND_ON) {
    return TRUE;
  } else {
    return FALSE;
  }
}
8000591e:	f9 dc c0 a1 	bfextu	r12,r12,0x5,0x1
80005922:	d8 02       	popm	pc
80005924:	80 01       	ld.sh	r1,r0[0x0]
80005926:	45 64       	lddsp	r4,sp[0x158]
80005928:	80 01       	ld.sh	r1,r0[0x0]
8000592a:	4d 4c       	lddpc	r12,80005a78 <ppu_setStatusVerticalBlank+0x1c>
8000592c:	80 01       	ld.sh	r1,r0[0x0]
8000592e:	4d ec       	lddpc	r12,80005aa4 <ppu_setStatusSpriteOverflow>
80005930:	80 00       	ld.sh	r0,r0[0x0]
80005932:	c1 a0       	breq	80005966 <objectAttributeMemory_getPalette+0x2e>
80005934:	80 00       	ld.sh	r0,r0[0x0]
80005936:	58 70       	cp.w	r0,7

80005938 <objectAttributeMemory_getPalette>:
  assert(memory != NULL);
  Byte address = (OAM_BYTES_PER_SPRITE * spriteIndex) + OAM_ATTRIBUTES_BYTE_OFFSET;
  return memory_read_direct(memory, address);
}
// Palette (4 to 7) of sprite
Byte objectAttributeMemory_getPalette(Memory memory, int spriteIndex) {
80005938:	d4 01       	pushm	lr
  assert(memory != NULL);
8000593a:	58 0c       	cp.w	r12,0
8000593c:	c0 71       	brne	8000594a <objectAttributeMemory_getPalette+0x12>
8000593e:	48 79       	lddpc	r9,80005958 <objectAttributeMemory_getPalette+0x20>
80005940:	48 7a       	lddpc	r10,8000595c <objectAttributeMemory_getPalette+0x24>
80005942:	33 eb       	mov	r11,62
80005944:	48 7c       	lddpc	r12,80005960 <objectAttributeMemory_getPalette+0x28>
80005946:	f0 1f 00 08 	mcall	80005964 <objectAttributeMemory_getPalette+0x2c>
  Byte attributes = objectAttributeMemory_getAttributes(memory, spriteIndex);
8000594a:	f0 1f 00 08 	mcall	80005968 <objectAttributeMemory_getPalette+0x30>
  // lose the 765432 bits
  attributes = (attributes << 6) >> 4;
8000594e:	a3 6c       	lsl	r12,0x2
  return attributes; // + 4;
}
80005950:	e2 1c 00 fc 	andl	r12,0xfc,COH
80005954:	d8 02       	popm	pc
80005956:	00 00       	add	r0,r0
80005958:	80 01       	ld.sh	r1,r0[0x0]
8000595a:	45 64       	lddsp	r4,sp[0x158]
8000595c:	80 01       	ld.sh	r1,r0[0x0]
8000595e:	4e 70       	lddpc	r0,80005af8 <ppu_setStatusSpriteCollisionHit+0x14>
80005960:	80 01       	ld.sh	r1,r0[0x0]
80005962:	4d ec       	lddpc	r12,80005ad8 <ppu_setStatusSpriteOverflow+0x34>
80005964:	80 00       	ld.sh	r0,r0[0x0]
80005966:	c1 a0       	breq	8000599a <objectAttributeMemory_getTileNumber+0x2e>
80005968:	80 00       	ld.sh	r0,r0[0x0]
8000596a:	58 70       	cp.w	r0,7

8000596c <objectAttributeMemory_getTileNumber>:
  } else {
    return 0;
  }
}
Byte objectAttributeMemory_getTileNumber(Memory memory, int spriteIndex, Bool
using8x16) {
8000596c:	eb cd 40 80 	pushm	r7,lr
80005970:	14 97       	mov	r7,r10
  assert(memory != NULL);
80005972:	58 0c       	cp.w	r12,0
80005974:	c0 71       	brne	80005982 <objectAttributeMemory_getTileNumber+0x16>
80005976:	48 99       	lddpc	r9,80005998 <objectAttributeMemory_getTileNumber+0x2c>
80005978:	48 9a       	lddpc	r10,8000599c <objectAttributeMemory_getTileNumber+0x30>
8000597a:	32 cb       	mov	r11,44
8000597c:	48 9c       	lddpc	r12,800059a0 <objectAttributeMemory_getTileNumber+0x34>
8000597e:	f0 1f 00 0a 	mcall	800059a4 <objectAttributeMemory_getTileNumber+0x38>
  Byte address = (OAM_BYTES_PER_SPRITE * spriteIndex) + OAM_TILE_BYTE_OFFSET;
  Byte data = memory_read_direct(memory, address);
80005982:	a3 6b       	lsl	r11,0x2
80005984:	2f fb       	sub	r11,-1
80005986:	5c 5b       	castu.b	r11
80005988:	f0 1f 00 08 	mcall	800059a8 <objectAttributeMemory_getTileNumber+0x3c>
  if (using8x16 == FALSE) {
8000598c:	58 07       	cp.w	r7,0
8000598e:	c0 30       	breq	80005994 <objectAttributeMemory_getTileNumber+0x28>
    return data;
  } else {
    // lose the 0th bit
    return (data >> 1) << 1;
80005990:	e2 1c 00 fe 	andl	r12,0xfe,COH
  }
}
80005994:	e3 cd 80 80 	ldm	sp++,r7,pc
80005998:	80 01       	ld.sh	r1,r0[0x0]
8000599a:	45 64       	lddsp	r4,sp[0x158]
8000599c:	80 01       	ld.sh	r1,r0[0x0]
8000599e:	4d 78       	lddpc	r8,80005af8 <ppu_setStatusSpriteCollisionHit+0x14>
800059a0:	80 01       	ld.sh	r1,r0[0x0]
800059a2:	4d ec       	lddpc	r12,80005b18 <ppu_setStatusSpriteCollisionHit+0x34>
800059a4:	80 00       	ld.sh	r0,r0[0x0]
800059a6:	c1 a0       	breq	800059da <objectAttributeMemory_getBankNumber+0x2e>
800059a8:	80 00       	ld.sh	r0,r0[0x0]
800059aa:	47 f8       	lddsp	r8,sp[0x1fc]

800059ac <objectAttributeMemory_getBankNumber>:
  Byte address = (OAM_BYTES_PER_SPRITE * spriteIndex) + OAM_Y_BYTE_OFFSET;
  return memory_read_direct(memory, address);
}
// byte 1
// only valid for 8x16 sprites
Byte objectAttributeMemory_getBankNumber(Memory memory, int spriteIndex) {
800059ac:	d4 01       	pushm	lr
  assert(memory != NULL);
800059ae:	58 0c       	cp.w	r12,0
800059b0:	c0 71       	brne	800059be <objectAttributeMemory_getBankNumber+0x12>
800059b2:	48 89       	lddpc	r9,800059d0 <objectAttributeMemory_getBankNumber+0x24>
800059b4:	48 8a       	lddpc	r10,800059d4 <objectAttributeMemory_getBankNumber+0x28>
800059b6:	32 1b       	mov	r11,33
800059b8:	48 8c       	lddpc	r12,800059d8 <objectAttributeMemory_getBankNumber+0x2c>
800059ba:	f0 1f 00 09 	mcall	800059dc <objectAttributeMemory_getBankNumber+0x30>
  Byte address = (OAM_BYTES_PER_SPRITE * spriteIndex) + OAM_TILE_BYTE_OFFSET;
  Byte data = memory_read_direct(memory, address);
800059be:	a3 6b       	lsl	r11,0x2
800059c0:	2f fb       	sub	r11,-1
800059c2:	5c 5b       	castu.b	r11
800059c4:	f0 1f 00 07 	mcall	800059e0 <objectAttributeMemory_getBankNumber+0x34>
  if ( (data & MASK_OAM_BANK_NUMBER_ON) == MASK_OAM_BANK_NUMBER_ON) {
    return 1;
  } else {
    return 0;
  }
}
800059c8:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
800059cc:	d8 02       	popm	pc
800059ce:	00 00       	add	r0,r0
800059d0:	80 01       	ld.sh	r1,r0[0x0]
800059d2:	45 64       	lddsp	r4,sp[0x158]
800059d4:	80 01       	ld.sh	r1,r0[0x0]
800059d6:	4d 28       	lddpc	r8,80005b1c <ppu_setStatusSpriteCollisionHit+0x38>
800059d8:	80 01       	ld.sh	r1,r0[0x0]
800059da:	4d ec       	lddpc	r12,80005b50 <ppu_getControlVerticalScrollNametable>
800059dc:	80 00       	ld.sh	r0,r0[0x0]
800059de:	c1 a0       	breq	80005a12 <objectAttributeMemory_getY+0x2e>
800059e0:	80 00       	ld.sh	r0,r0[0x0]
800059e2:	47 f8       	lddsp	r8,sp[0x1fc]

800059e4 <objectAttributeMemory_getY>:
  assert(memory != NULL);
  return memory;
}
// byte 0
// 0    -       scanline coordinate minus one of object's top pixel row.
Byte objectAttributeMemory_getY(Memory memory, int spriteIndex) {
800059e4:	d4 01       	pushm	lr
  assert(memory != NULL);
800059e6:	58 0c       	cp.w	r12,0
800059e8:	c0 71       	brne	800059f6 <objectAttributeMemory_getY+0x12>
800059ea:	48 79       	lddpc	r9,80005a04 <objectAttributeMemory_getY+0x20>
800059ec:	48 7a       	lddpc	r10,80005a08 <objectAttributeMemory_getY+0x24>
800059ee:	31 ab       	mov	r11,26
800059f0:	48 7c       	lddpc	r12,80005a0c <objectAttributeMemory_getY+0x28>
800059f2:	f0 1f 00 08 	mcall	80005a10 <objectAttributeMemory_getY+0x2c>
  Byte address = (OAM_BYTES_PER_SPRITE * spriteIndex) + OAM_Y_BYTE_OFFSET;
  return memory_read_direct(memory, address);
800059f6:	a3 6b       	lsl	r11,0x2
800059f8:	e2 1b 00 fc 	andl	r11,0xfc,COH
800059fc:	f0 1f 00 06 	mcall	80005a14 <objectAttributeMemory_getY+0x30>
}
80005a00:	d8 02       	popm	pc
80005a02:	00 00       	add	r0,r0
80005a04:	80 01       	ld.sh	r1,r0[0x0]
80005a06:	45 64       	lddsp	r4,sp[0x158]
80005a08:	80 01       	ld.sh	r1,r0[0x0]
80005a0a:	4e 94       	lddpc	r4,80005bac <ppu_increasePPUMemoryAddress+0x4>
80005a0c:	80 01       	ld.sh	r1,r0[0x0]
80005a0e:	4d ec       	lddpc	r12,80005b84 <ppu_getControlPPUAddressIncrement+0x8>
80005a10:	80 00       	ld.sh	r0,r0[0x0]
80005a12:	c1 a0       	breq	80005a46 <objectAttributeMemory_init+0x2e>
80005a14:	80 00       	ld.sh	r0,r0[0x0]
80005a16:	47 f8       	lddsp	r8,sp[0x1fc]

80005a18 <objectAttributeMemory_init>:
(behind/on top of background). Sprite ram can be accessed byte-by-byte through
the NES registers, or also can be loaded via DMA transfer through another
register.
*/
// assumption: not using callbacks within sprite memory?
Memory objectAttributeMemory_init(void) {
80005a18:	d4 01       	pushm	lr
  Memory memory = memory_init(OAM_NUM_ADDRESSES);
80005a1a:	e0 6c 01 00 	mov	r12,256
80005a1e:	f0 1f 00 06 	mcall	80005a34 <objectAttributeMemory_init+0x1c>
  assert(memory != NULL);
80005a22:	c0 71       	brne	80005a30 <objectAttributeMemory_init+0x18>
80005a24:	48 59       	lddpc	r9,80005a38 <objectAttributeMemory_init+0x20>
80005a26:	48 6a       	lddpc	r10,80005a3c <objectAttributeMemory_init+0x24>
80005a28:	31 4b       	mov	r11,20
80005a2a:	48 6c       	lddpc	r12,80005a40 <objectAttributeMemory_init+0x28>
80005a2c:	f0 1f 00 06 	mcall	80005a44 <objectAttributeMemory_init+0x2c>
  return memory;
}
80005a30:	d8 02       	popm	pc
80005a32:	00 00       	add	r0,r0
80005a34:	80 00       	ld.sh	r0,r0[0x0]
80005a36:	49 1c       	lddpc	r12,80005a78 <ppu_setStatusVerticalBlank+0x1c>
80005a38:	80 01       	ld.sh	r1,r0[0x0]
80005a3a:	45 64       	lddsp	r4,sp[0x158]
80005a3c:	80 01       	ld.sh	r1,r0[0x0]
80005a3e:	4e 10       	lddpc	r0,80005bc0 <ppu_increasePPUMemoryAddress+0x18>
80005a40:	80 01       	ld.sh	r1,r0[0x0]
80005a42:	4d ec       	lddpc	r12,80005bb8 <ppu_increasePPUMemoryAddress+0x10>
80005a44:	80 00       	ld.sh	r0,r0[0x0]
80005a46:	c1 a0       	breq	80005a7a <ppu_setStatusVerticalBlank+0x1e>

80005a48 <ppu_getBackgroundTileNumber>:
static Byte ppu_getCurrentY(PPU ppu) {
  assert(ppu != NULL);
  return ppu->currentScanline - PPU_WASTED_VBLANK_SCANLINES -
PPU_WASTED_PREFETCH_SCANLINES;
}
static Word ppu_getBackgroundTileNumber(Word x, Word y) {
80005a48:	f7 db c0 6d 	bfextu	r11,r11,0x3,0xd
80005a4c:	a5 7b       	lsl	r11,0x5
80005a4e:	f9 dc c0 6d 	bfextu	r12,r12,0x3,0xd
80005a52:	18 0b       	add	r11,r12
  Word horizontalOffset = (x / PPU_HORIZONTAL_PIXELS_PER_TILE);
  Word verticalOffset = (y / PPU_VERTICAL_PIXELS_PER_TILE) *
PPU_BACKGROUND_TILES_PER_ROW;
  Word tileNumber = horizontalOffset + verticalOffset;
  return tileNumber;
}
80005a54:	f9 db b0 10 	bfexts	r12,r11,0x0,0x10
80005a58:	5e fc       	retal	r12
80005a5a:	d7 03       	nop

80005a5c <ppu_setStatusVerticalBlank>:
    return TRUE;
  } else {
    return FALSE;
  }
}
static void ppu_setStatusVerticalBlank(PPU ppu, Bool state) {
80005a5c:	d4 01       	pushm	lr
  assert(ppu != NULL);
80005a5e:	58 0c       	cp.w	r12,0
80005a60:	c0 81       	brne	80005a70 <ppu_setStatusVerticalBlank+0x14>
80005a62:	48 d9       	lddpc	r9,80005a94 <ppu_setStatusVerticalBlank+0x38>
80005a64:	48 da       	lddpc	r10,80005a98 <ppu_setStatusVerticalBlank+0x3c>
80005a66:	e0 6b 01 be 	mov	r11,446
80005a6a:	48 dc       	lddpc	r12,80005a9c <ppu_setStatusVerticalBlank+0x40>
80005a6c:	f0 1f 00 0d 	mcall	80005aa0 <ppu_setStatusVerticalBlank+0x44>
  if (state == TRUE) {
80005a70:	30 18       	mov	r8,1
80005a72:	f0 0b 18 00 	cp.b	r11,r8
80005a76:	c0 81       	brne	80005a86 <ppu_setStatusVerticalBlank+0x2a>
    ppu->statusRegister |= MASK_STATUS_VBLANK_ON;
80005a78:	19 a8       	ld.ub	r8,r12[0x2]
80005a7a:	ea 18 ff ff 	orh	r8,0xffff
80005a7e:	e8 18 ff 80 	orl	r8,0xff80
80005a82:	b8 a8       	st.b	r12[0x2],r8
80005a84:	d8 02       	popm	pc
  } else if (state == FALSE) {
80005a86:	58 0b       	cp.w	r11,0
80005a88:	c0 51       	brne	80005a92 <ppu_setStatusVerticalBlank+0x36>
    ppu->statusRegister &= MASK_STATUS_VBLANK_OFF;
80005a8a:	19 a8       	ld.ub	r8,r12[0x2]
80005a8c:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
80005a90:	b8 a8       	st.b	r12[0x2],r8
80005a92:	d8 02       	popm	pc
80005a94:	80 01       	ld.sh	r1,r0[0x0]
80005a96:	41 74       	lddsp	r4,sp[0x5c]
80005a98:	80 01       	ld.sh	r1,r0[0x0]
80005a9a:	58 78       	cp.w	r8,7
80005a9c:	80 01       	ld.sh	r1,r0[0x0]
80005a9e:	4f 94       	lddpc	r4,80005c80 <ppu_getControlNMI+0x14>
80005aa0:	80 00       	ld.sh	r0,r0[0x0]
80005aa2:	c1 a0       	breq	80005ad6 <ppu_setStatusSpriteOverflow+0x32>

80005aa4 <ppu_setStatusSpriteOverflow>:
    return TRUE;
  } else {
    return FALSE;
  }
}
static void ppu_setStatusSpriteOverflow(PPU ppu, Bool state) {
80005aa4:	d4 01       	pushm	lr
  assert(ppu != NULL);
80005aa6:	58 0c       	cp.w	r12,0
80005aa8:	c0 81       	brne	80005ab8 <ppu_setStatusSpriteOverflow+0x14>
80005aaa:	48 b9       	lddpc	r9,80005ad4 <ppu_setStatusSpriteOverflow+0x30>
80005aac:	48 ba       	lddpc	r10,80005ad8 <ppu_setStatusSpriteOverflow+0x34>
80005aae:	e0 6b 01 9c 	mov	r11,412
80005ab2:	48 bc       	lddpc	r12,80005adc <ppu_setStatusSpriteOverflow+0x38>
80005ab4:	f0 1f 00 0b 	mcall	80005ae0 <ppu_setStatusSpriteOverflow+0x3c>
  if (state == TRUE) {
80005ab8:	30 18       	mov	r8,1
80005aba:	f0 0b 18 00 	cp.b	r11,r8
80005abe:	c0 51       	brne	80005ac8 <ppu_setStatusSpriteOverflow+0x24>
    ppu->statusRegister |= MASK_STATUS_SPRITE_OVERFLOW_ON;
80005ac0:	19 a8       	ld.ub	r8,r12[0x2]
80005ac2:	a5 b8       	sbr	r8,0x5
80005ac4:	b8 a8       	st.b	r12[0x2],r8
80005ac6:	d8 02       	popm	pc
  } else if (state == FALSE) {
80005ac8:	58 0b       	cp.w	r11,0
80005aca:	c0 41       	brne	80005ad2 <ppu_setStatusSpriteOverflow+0x2e>
    ppu->statusRegister &= MASK_STATUS_SPRITE_OVERFLOW_OFF;
80005acc:	19 a8       	ld.ub	r8,r12[0x2]
80005ace:	a5 d8       	cbr	r8,0x5
80005ad0:	b8 a8       	st.b	r12[0x2],r8
80005ad2:	d8 02       	popm	pc
80005ad4:	80 01       	ld.sh	r1,r0[0x0]
80005ad6:	41 74       	lddsp	r4,sp[0x5c]
80005ad8:	80 01       	ld.sh	r1,r0[0x0]
80005ada:	5c 5c       	castu.b	r12
80005adc:	80 01       	ld.sh	r1,r0[0x0]
80005ade:	4f 94       	lddpc	r4,80005cc0 <ppu_getMaskBackgroundVisibility+0x28>
80005ae0:	80 00       	ld.sh	r0,r0[0x0]
80005ae2:	c1 a0       	breq	80005b16 <ppu_setStatusSpriteCollisionHit+0x32>

80005ae4 <ppu_setStatusSpriteCollisionHit>:
    return TRUE;
  } else {
    return FALSE;
  }
}
static void ppu_setStatusSpriteCollisionHit(PPU ppu, Bool state) {
80005ae4:	d4 01       	pushm	lr
  assert(ppu != NULL);
80005ae6:	58 0c       	cp.w	r12,0
80005ae8:	c0 81       	brne	80005af8 <ppu_setStatusSpriteCollisionHit+0x14>
80005aea:	48 b9       	lddpc	r9,80005b14 <ppu_setStatusSpriteCollisionHit+0x30>
80005aec:	48 ba       	lddpc	r10,80005b18 <ppu_setStatusSpriteCollisionHit+0x34>
80005aee:	e0 6b 01 ad 	mov	r11,429
80005af2:	48 bc       	lddpc	r12,80005b1c <ppu_setStatusSpriteCollisionHit+0x38>
80005af4:	f0 1f 00 0b 	mcall	80005b20 <ppu_setStatusSpriteCollisionHit+0x3c>
  if (state == TRUE) {
80005af8:	30 18       	mov	r8,1
80005afa:	f0 0b 18 00 	cp.b	r11,r8
80005afe:	c0 51       	brne	80005b08 <ppu_setStatusSpriteCollisionHit+0x24>
    ppu->statusRegister |= MASK_STATUS_SPRITE_COLLISION_HIT_ON;
80005b00:	19 a8       	ld.ub	r8,r12[0x2]
80005b02:	a7 a8       	sbr	r8,0x6
80005b04:	b8 a8       	st.b	r12[0x2],r8
80005b06:	d8 02       	popm	pc
  } else if (state == FALSE) {
80005b08:	58 0b       	cp.w	r11,0
80005b0a:	c0 41       	brne	80005b12 <ppu_setStatusSpriteCollisionHit+0x2e>
    ppu->statusRegister &= MASK_STATUS_SPRITE_COLLISION_HIT_OFF;
80005b0c:	19 a8       	ld.ub	r8,r12[0x2]
80005b0e:	a7 c8       	cbr	r8,0x6
80005b10:	b8 a8       	st.b	r12[0x2],r8
80005b12:	d8 02       	popm	pc
80005b14:	80 01       	ld.sh	r1,r0[0x0]
80005b16:	41 74       	lddsp	r4,sp[0x5c]
80005b18:	80 01       	ld.sh	r1,r0[0x0]
80005b1a:	57 fc       	stdsp	sp[0x1fc],r12
80005b1c:	80 01       	ld.sh	r1,r0[0x0]
80005b1e:	4f 94       	lddpc	r4,80005d00 <ppu_setPPUMemoryAddressRegister+0x10>
80005b20:	80 00       	ld.sh	r0,r0[0x0]
80005b22:	c1 a0       	breq	80005b56 <ppu_getControlVerticalScrollNametable+0x6>

80005b24 <ppu_getControlHorizontalScrollNametable>:
}
void ppu_destroy(PPU ppu) {
  assert(ppu != NULL);
  free(ppu);
}
static Bool ppu_getControlHorizontalScrollNametable(PPU ppu) {
80005b24:	d4 01       	pushm	lr
  assert(ppu != NULL);
80005b26:	58 0c       	cp.w	r12,0
80005b28:	c0 81       	brne	80005b38 <ppu_getControlHorizontalScrollNametable+0x14>
80005b2a:	48 69       	lddpc	r9,80005b40 <ppu_getControlHorizontalScrollNametable+0x1c>
80005b2c:	48 6a       	lddpc	r10,80005b44 <ppu_getControlHorizontalScrollNametable+0x20>
80005b2e:	e0 6b 00 94 	mov	r11,148
80005b32:	48 6c       	lddpc	r12,80005b48 <ppu_getControlHorizontalScrollNametable+0x24>
80005b34:	f0 1f 00 06 	mcall	80005b4c <ppu_getControlHorizontalScrollNametable+0x28>
80005b38:	19 8c       	ld.ub	r12,r12[0x0]
MASK_CONTROL_HORIZONTAL_SCROLL_NAME_TABLE_ON) {
    return TRUE;
  } else {
    return FALSE;
  }
}
80005b3a:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80005b3e:	d8 02       	popm	pc
80005b40:	80 01       	ld.sh	r1,r0[0x0]
80005b42:	41 74       	lddsp	r4,sp[0x5c]
80005b44:	80 01       	ld.sh	r1,r0[0x0]
80005b46:	5c 34       	neg	r4
80005b48:	80 01       	ld.sh	r1,r0[0x0]
80005b4a:	4f 94       	lddpc	r4,80005d2c <ppu_setPPUMemoryAddressRegister+0x3c>
80005b4c:	80 00       	ld.sh	r0,r0[0x0]
80005b4e:	c1 a0       	breq	80005b82 <ppu_getControlPPUAddressIncrement+0x6>

80005b50 <ppu_getControlVerticalScrollNametable>:
    ppu->controlRegister |= MASK_CONTROL_HORIZONTAL_SCROLL_NAME_TABLE_ON;
  } else if (state == FALSE) {
    ppu->controlRegister &= MASK_CONTROL_HORIZONTAL_SCROLL_NAME_TABLE_OFF;
  }
}
static Bool ppu_getControlVerticalScrollNametable(PPU ppu) {
80005b50:	d4 01       	pushm	lr
  assert(ppu != NULL);
80005b52:	58 0c       	cp.w	r12,0
80005b54:	c0 81       	brne	80005b64 <ppu_getControlVerticalScrollNametable+0x14>
80005b56:	48 69       	lddpc	r9,80005b6c <ppu_getControlVerticalScrollNametable+0x1c>
80005b58:	48 6a       	lddpc	r10,80005b70 <ppu_getControlVerticalScrollNametable+0x20>
80005b5a:	e0 6b 00 a5 	mov	r11,165
80005b5e:	48 6c       	lddpc	r12,80005b74 <ppu_getControlVerticalScrollNametable+0x24>
80005b60:	f0 1f 00 06 	mcall	80005b78 <ppu_getControlVerticalScrollNametable+0x28>
80005b64:	19 8c       	ld.ub	r12,r12[0x0]
MASK_CONTROL_VERTICAL_SCROLL_NAME_TABLE_ON) {
    return TRUE;
  } else {
    return FALSE;
  }
}
80005b66:	f9 dc c0 21 	bfextu	r12,r12,0x1,0x1
80005b6a:	d8 02       	popm	pc
80005b6c:	80 01       	ld.sh	r1,r0[0x0]
80005b6e:	41 74       	lddsp	r4,sp[0x5c]
80005b70:	80 01       	ld.sh	r1,r0[0x0]
80005b72:	4f 14       	lddpc	r4,80005d34 <ppu_setPPUMemoryAddressRegister+0x44>
80005b74:	80 01       	ld.sh	r1,r0[0x0]
80005b76:	4f 94       	lddpc	r4,80005d58 <ppu_setScrollRegister+0x1c>
80005b78:	80 00       	ld.sh	r0,r0[0x0]
80005b7a:	c1 a0       	breq	80005bae <ppu_increasePPUMemoryAddress+0x6>

80005b7c <ppu_getControlPPUAddressIncrement>:
    ppu->controlRegister |= MASK_CONTROL_PPU_ADDRESS_INCREMENT_ON;
  } else if (state == FALSE) {
    ppu->controlRegister &= MASK_CONTROL_PPU_ADDRESS_INCREMENT_OFF;
  }
}
static Bool ppu_getControlPPUAddressIncrement(PPU ppu) {
80005b7c:	d4 01       	pushm	lr
  assert(ppu != NULL);
80005b7e:	58 0c       	cp.w	r12,0
80005b80:	c0 81       	brne	80005b90 <ppu_getControlPPUAddressIncrement+0x14>
80005b82:	48 69       	lddpc	r9,80005b98 <ppu_getControlPPUAddressIncrement+0x1c>
80005b84:	48 6a       	lddpc	r10,80005b9c <ppu_getControlPPUAddressIncrement+0x20>
80005b86:	e0 6b 00 fc 	mov	r11,252
80005b8a:	48 6c       	lddpc	r12,80005ba0 <ppu_getControlPPUAddressIncrement+0x24>
80005b8c:	f0 1f 00 06 	mcall	80005ba4 <ppu_getControlPPUAddressIncrement+0x28>
80005b90:	19 8c       	ld.ub	r12,r12[0x0]
MASK_CONTROL_PPU_ADDRESS_INCREMENT_ON) {
    return TRUE;
  } else {
    return FALSE;
  }
}
80005b92:	f9 dc c0 41 	bfextu	r12,r12,0x2,0x1
80005b96:	d8 02       	popm	pc
80005b98:	80 01       	ld.sh	r1,r0[0x0]
80005b9a:	41 74       	lddsp	r4,sp[0x5c]
80005b9c:	80 01       	ld.sh	r1,r0[0x0]
80005b9e:	4e f0       	lddpc	r0,80005d58 <ppu_setScrollRegister+0x1c>
80005ba0:	80 01       	ld.sh	r1,r0[0x0]
80005ba2:	4f 94       	lddpc	r4,80005d84 <ppu_setScrollRegister+0x48>
80005ba4:	80 00       	ld.sh	r0,r0[0x0]
80005ba6:	c1 a0       	breq	80005bda <ppu_increasePPUMemoryAddress+0x32>

80005ba8 <ppu_increasePPUMemoryAddress>:
    ppu->ppuAddressLow = ppuMemoryAddressRegister;
    ppu->hasPartial = FALSE;
  }
  ppu->ppuMemoryAddressRegister = ppuMemoryAddressRegister;
}
static void ppu_increasePPUMemoryAddress(PPU ppu) {
80005ba8:	eb cd 40 c0 	pushm	r6-r7,lr
80005bac:	18 97       	mov	r7,r12
  //assert(ppu->hasPartial == FALSE);
  Address address = ppu->ppuAddressLow;
80005bae:	f9 38 00 0c 	ld.ub	r8,r12[12]
  address += ppu->ppuAddressHigh << BITS_PER_BYTE;
80005bb2:	f9 36 00 0d 	ld.ub	r6,r12[13]
80005bb6:	a9 66       	lsl	r6,0x8
80005bb8:	10 06       	add	r6,r8
80005bba:	5c 86       	casts.h	r6
  if (ppu_getControlPPUAddressIncrement(ppu) == TRUE) {
80005bbc:	f0 1f 00 0a 	mcall	80005be4 <ppu_increasePPUMemoryAddress+0x3c>
80005bc0:	30 18       	mov	r8,1
80005bc2:	f0 0c 18 00 	cp.b	r12,r8
80005bc6:	c0 41       	brne	80005bce <ppu_increasePPUMemoryAddress+0x26>
    address += PPU_CONTROL_ADDRESS_VERTICAL_INCREMENT;
80005bc8:	2e 06       	sub	r6,-32
80005bca:	5c 86       	casts.h	r6
80005bcc:	c0 38       	rjmp	80005bd2 <ppu_increasePPUMemoryAddress+0x2a>
  } else {
    address += PPU_CONTROL_ADDRESS_HORIZONTAL_INCREMENT;
80005bce:	2f f6       	sub	r6,-1
80005bd0:	5c 86       	casts.h	r6
  }
  ppu->ppuAddressLow = GET_ADDRESS_LOW_BYTE(address);
80005bd2:	ef 66 00 0c 	st.b	r7[12],r6
  ppu->ppuAddressHigh = GET_ADDRESS_HIGH_BYTE(address);
80005bd6:	ed d6 c1 08 	bfextu	r6,r6,0x8,0x8
80005bda:	ef 66 00 0d 	st.b	r7[13],r6
}
80005bde:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005be2:	00 00       	add	r0,r0
80005be4:	80 00       	ld.sh	r0,r0[0x0]
80005be6:	5b 7c       	cp.w	r12,-9

80005be8 <ppu_getControlSpriteTileTable>:
    ppu->controlRegister |= MASK_CONTROL_SPRITE_TILE_TABLE_ON;
  } else if (state == FALSE) {
    ppu->controlRegister &= MASK_CONTROL_SPRITE_TILE_TABLE_OFF;
  }
}
static Bool ppu_getControlSpriteTileTable(PPU ppu) {
80005be8:	d4 01       	pushm	lr
  assert(ppu != NULL);
80005bea:	58 0c       	cp.w	r12,0
80005bec:	c0 81       	brne	80005bfc <ppu_getControlSpriteTileTable+0x14>
80005bee:	48 69       	lddpc	r9,80005c04 <ppu_getControlSpriteTileTable+0x1c>
80005bf0:	48 6a       	lddpc	r10,80005c08 <ppu_getControlSpriteTileTable+0x20>
80005bf2:	e0 6b 01 0d 	mov	r11,269
80005bf6:	48 6c       	lddpc	r12,80005c0c <ppu_getControlSpriteTileTable+0x24>
80005bf8:	f0 1f 00 06 	mcall	80005c10 <ppu_getControlSpriteTileTable+0x28>
80005bfc:	19 8c       	ld.ub	r12,r12[0x0]
MASK_CONTROL_SPRITE_TILE_TABLE_ON) {
    return TRUE;
  } else {
    return FALSE;
  }
}
80005bfe:	f9 dc c0 61 	bfextu	r12,r12,0x3,0x1
80005c02:	d8 02       	popm	pc
80005c04:	80 01       	ld.sh	r1,r0[0x0]
80005c06:	41 74       	lddsp	r4,sp[0x5c]
80005c08:	80 01       	ld.sh	r1,r0[0x0]
80005c0a:	5a 70       	cp.w	r0,-25
80005c0c:	80 01       	ld.sh	r1,r0[0x0]
80005c0e:	4f 94       	lddpc	r4,80005df0 <ppu_setControlRegister+0x18>
80005c10:	80 00       	ld.sh	r0,r0[0x0]
80005c12:	c1 a0       	breq	80005c46 <ppu_getControlSpriteSize+0x6>

80005c14 <ppu_getControlBackgroundTileTable>:
    ppu->controlRegister |= MASK_CONTROL_BACKGROUND_TILE_TABLE_ON;
  } else if (state == FALSE) {
    ppu->controlRegister &= MASK_CONTROL_BACKGROUND_TILE_TABLE_OFF;
  }
}
static Bool ppu_getControlBackgroundTileTable(PPU ppu) {
80005c14:	d4 01       	pushm	lr
  assert(ppu != NULL);
80005c16:	58 0c       	cp.w	r12,0
80005c18:	c0 81       	brne	80005c28 <ppu_getControlBackgroundTileTable+0x14>
80005c1a:	48 69       	lddpc	r9,80005c30 <ppu_getControlBackgroundTileTable+0x1c>
80005c1c:	48 6a       	lddpc	r10,80005c34 <ppu_getControlBackgroundTileTable+0x20>
80005c1e:	e0 6b 01 1e 	mov	r11,286
80005c22:	48 6c       	lddpc	r12,80005c38 <ppu_getControlBackgroundTileTable+0x24>
80005c24:	f0 1f 00 06 	mcall	80005c3c <ppu_getControlBackgroundTileTable+0x28>
80005c28:	19 8c       	ld.ub	r12,r12[0x0]
MASK_CONTROL_BACKGROUND_TILE_TABLE_ON) {
    return TRUE;
  } else {
    return FALSE;
  }
}
80005c2a:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
80005c2e:	d8 02       	popm	pc
80005c30:	80 01       	ld.sh	r1,r0[0x0]
80005c32:	41 74       	lddsp	r4,sp[0x5c]
80005c34:	80 01       	ld.sh	r1,r0[0x0]
80005c36:	5b 98       	cp.w	r8,-7
80005c38:	80 01       	ld.sh	r1,r0[0x0]
80005c3a:	4f 94       	lddpc	r4,80005e1c <ppu_getPPUMemoryAddressRegister+0x1c>
80005c3c:	80 00       	ld.sh	r0,r0[0x0]
80005c3e:	c1 a0       	breq	80005c72 <ppu_getControlNMI+0x6>

80005c40 <ppu_getControlSpriteSize>:
    ppu->controlRegister |= MASK_CONTROL_SPRITE_SIZE_ON;
  } else if (state == FALSE) {
    ppu->controlRegister &= MASK_CONTROL_SPRITE_SIZE_OFF;
  }
}
static Bool ppu_getControlSpriteSize(PPU ppu) {
80005c40:	d4 01       	pushm	lr
  assert(ppu != NULL);
80005c42:	58 0c       	cp.w	r12,0
80005c44:	c0 81       	brne	80005c54 <ppu_getControlSpriteSize+0x14>
80005c46:	48 69       	lddpc	r9,80005c5c <ppu_getControlSpriteSize+0x1c>
80005c48:	48 6a       	lddpc	r10,80005c60 <ppu_getControlSpriteSize+0x20>
80005c4a:	e0 6b 01 2f 	mov	r11,303
80005c4e:	48 6c       	lddpc	r12,80005c64 <ppu_getControlSpriteSize+0x24>
80005c50:	f0 1f 00 06 	mcall	80005c68 <ppu_getControlSpriteSize+0x28>
80005c54:	19 8c       	ld.ub	r12,r12[0x0]
MASK_CONTROL_SPRITE_SIZE_ON) {
    return TRUE;
  } else {
    return FALSE;
  }
}
80005c56:	f9 dc c0 a1 	bfextu	r12,r12,0x5,0x1
80005c5a:	d8 02       	popm	pc
80005c5c:	80 01       	ld.sh	r1,r0[0x0]
80005c5e:	41 74       	lddsp	r4,sp[0x5c]
80005c60:	80 01       	ld.sh	r1,r0[0x0]
80005c62:	58 b4       	cp.w	r4,11
80005c64:	80 01       	ld.sh	r1,r0[0x0]
80005c66:	4f 94       	lddpc	r4,80005e48 <ppu_getScrollRegister+0x20>
80005c68:	80 00       	ld.sh	r0,r0[0x0]
80005c6a:	c1 a0       	breq	80005c9e <ppu_getMaskBackgroundVisibility+0x6>

80005c6c <ppu_getControlNMI>:
    ppu->controlRegister |= MASK_CONTROL_NMI_ON;
  } else if (state == FALSE) {
    ppu->controlRegister &= MASK_CONTROL_NMI_OFF;
  }
}
static Bool ppu_getControlNMI(PPU ppu) {
80005c6c:	d4 01       	pushm	lr
  assert(ppu != NULL);
80005c6e:	58 0c       	cp.w	r12,0
80005c70:	c0 81       	brne	80005c80 <ppu_getControlNMI+0x14>
80005c72:	48 69       	lddpc	r9,80005c88 <ppu_getControlNMI+0x1c>
80005c74:	48 6a       	lddpc	r10,80005c8c <ppu_getControlNMI+0x20>
80005c76:	e0 6b 01 40 	mov	r11,320
80005c7a:	48 6c       	lddpc	r12,80005c90 <ppu_getControlNMI+0x24>
80005c7c:	f0 1f 00 06 	mcall	80005c94 <ppu_getControlNMI+0x28>
80005c80:	19 8c       	ld.ub	r12,r12[0x0]
  if ((ppu->controlRegister & MASK_CONTROL_NMI_ON) == MASK_CONTROL_NMI_ON) {
    return TRUE;
  } else {
    return FALSE;
  }
}
80005c82:	a7 9c       	lsr	r12,0x7
80005c84:	d8 02       	popm	pc
80005c86:	00 00       	add	r0,r0
80005c88:	80 01       	ld.sh	r1,r0[0x0]
80005c8a:	41 74       	lddsp	r4,sp[0x5c]
80005c8c:	80 01       	ld.sh	r1,r0[0x0]
80005c8e:	5c 20       	cpc	r0
80005c90:	80 01       	ld.sh	r1,r0[0x0]
80005c92:	4f 94       	lddpc	r4,80005e74 <ppu_getSpriteAddressRegister+0x24>
80005c94:	80 00       	ld.sh	r0,r0[0x0]
80005c96:	c1 a0       	breq	80005cca <ppu_getMaskSpriteVisibility+0x6>

80005c98 <ppu_getMaskBackgroundVisibility>:
    ppu->maskRegister |= MASK_MASK_BACKGROUND_VISIBILITY_ON;
  } else if (state == FALSE) {
    ppu->maskRegister &= MASK_MASK_BACKGROUND_VISIBILITY_OFF;
  }
}
static Bool ppu_getMaskBackgroundVisibility (PPU ppu) {
80005c98:	d4 01       	pushm	lr
  assert(ppu != NULL);
80005c9a:	58 0c       	cp.w	r12,0
80005c9c:	c0 81       	brne	80005cac <ppu_getMaskBackgroundVisibility+0x14>
80005c9e:	48 69       	lddpc	r9,80005cb4 <ppu_getMaskBackgroundVisibility+0x1c>
80005ca0:	48 6a       	lddpc	r10,80005cb8 <ppu_getMaskBackgroundVisibility+0x20>
80005ca2:	e0 6b 01 82 	mov	r11,386
80005ca6:	48 6c       	lddpc	r12,80005cbc <ppu_getMaskBackgroundVisibility+0x24>
80005ca8:	f0 1f 00 06 	mcall	80005cc0 <ppu_getMaskBackgroundVisibility+0x28>
80005cac:	19 9c       	ld.ub	r12,r12[0x1]
MASK_MASK_BACKGROUND_VISIBILITY_ON) {
    return TRUE;
  } else {
    return FALSE;
  }
}
80005cae:	f9 dc c0 61 	bfextu	r12,r12,0x3,0x1
80005cb2:	d8 02       	popm	pc
80005cb4:	80 01       	ld.sh	r1,r0[0x0]
80005cb6:	41 74       	lddsp	r4,sp[0x5c]
80005cb8:	80 01       	ld.sh	r1,r0[0x0]
80005cba:	5b 20       	cp.w	r0,-14
80005cbc:	80 01       	ld.sh	r1,r0[0x0]
80005cbe:	4f 94       	lddpc	r4,80005ea0 <ppu_getStatusRegister+0x28>
80005cc0:	80 00       	ld.sh	r0,r0[0x0]
80005cc2:	c1 a0       	breq	80005cf6 <ppu_setPPUMemoryAddressRegister+0x6>

80005cc4 <ppu_getMaskSpriteVisibility>:
    ppu->maskRegister |= MASK_MASK_SPRITE_VISIBILITY_ON;
  } else if (state == FALSE) {
    ppu->maskRegister &= MASK_MASK_SPRITE_VISIBILITY_OFF;
  }
}
static Bool ppu_getMaskSpriteVisibility(PPU ppu) {
80005cc4:	d4 01       	pushm	lr
  assert(ppu != NULL);
80005cc6:	58 0c       	cp.w	r12,0
80005cc8:	c0 81       	brne	80005cd8 <ppu_getMaskSpriteVisibility+0x14>
80005cca:	48 69       	lddpc	r9,80005ce0 <ppu_getMaskSpriteVisibility+0x1c>
80005ccc:	48 6a       	lddpc	r10,80005ce4 <ppu_getMaskSpriteVisibility+0x20>
80005cce:	e0 6b 01 93 	mov	r11,403
80005cd2:	48 6c       	lddpc	r12,80005ce8 <ppu_getMaskSpriteVisibility+0x24>
80005cd4:	f0 1f 00 06 	mcall	80005cec <ppu_getMaskSpriteVisibility+0x28>
80005cd8:	19 9c       	ld.ub	r12,r12[0x1]
MASK_MASK_SPRITE_VISIBILITY_ON) {
    return TRUE;
  } else {
    return FALSE;
  }
}
80005cda:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
80005cde:	d8 02       	popm	pc
80005ce0:	80 01       	ld.sh	r1,r0[0x0]
80005ce2:	41 74       	lddsp	r4,sp[0x5c]
80005ce4:	80 01       	ld.sh	r1,r0[0x0]
80005ce6:	58 d0       	cp.w	r0,13
80005ce8:	80 01       	ld.sh	r1,r0[0x0]
80005cea:	4f 94       	lddpc	r4,80005ecc <ppu_getMaskRegister+0x14>
80005cec:	80 00       	ld.sh	r0,r0[0x0]
80005cee:	c1 a0       	breq	80005d22 <ppu_setPPUMemoryAddressRegister+0x32>

80005cf0 <ppu_setPPUMemoryAddressRegister>:
    ppu->verticalScroll = scrollRegister;
    ppu->hasPartial = FALSE;
  }
  ppu->scrollRegister = scrollRegister;
}
void ppu_setPPUMemoryAddressRegister(PPU ppu, Byte ppuMemoryAddressRegister) {
80005cf0:	d4 01       	pushm	lr
  assert(ppu != NULL);
80005cf2:	58 0c       	cp.w	r12,0
80005cf4:	c0 81       	brne	80005d04 <ppu_setPPUMemoryAddressRegister+0x14>
80005cf6:	48 e9       	lddpc	r9,80005d2c <ppu_setPPUMemoryAddressRegister+0x3c>
80005cf8:	48 ea       	lddpc	r10,80005d30 <ppu_setPPUMemoryAddressRegister+0x40>
80005cfa:	e0 6b 03 81 	mov	r11,897
80005cfe:	48 ec       	lddpc	r12,80005d34 <ppu_setPPUMemoryAddressRegister+0x44>
80005d00:	f0 1f 00 0e 	mcall	80005d38 <ppu_setPPUMemoryAddressRegister+0x48>
  if (ppu->hasPartial == FALSE) {
80005d04:	f9 39 00 0b 	ld.ub	r9,r12[11]
80005d08:	30 08       	mov	r8,0
    ppu->ppuAddressHigh = ppuMemoryAddressRegister;
80005d0a:	f0 09 18 00 	cp.b	r9,r8
80005d0e:	f9 fb 0e 0d 	st.beq	r12[0xd],r11
    ppu->hasPartial = TRUE;
80005d12:	f9 b8 00 01 	moveq	r8,1
80005d16:	f9 f8 0e 0b 	st.beq	r12[0xb],r8
  } else {
    // we have a partial address
    ppu->ppuAddressLow = ppuMemoryAddressRegister;
80005d1a:	f9 fb 1e 0c 	st.bne	r12[0xc],r11
    ppu->hasPartial = FALSE;
80005d1e:	f9 b8 01 00 	movne	r8,0
80005d22:	f9 f8 1e 0b 	st.bne	r12[0xb],r8
  }
  ppu->ppuMemoryAddressRegister = ppuMemoryAddressRegister;
80005d26:	b8 eb       	st.b	r12[0x6],r11
}
80005d28:	d8 02       	popm	pc
80005d2a:	00 00       	add	r0,r0
80005d2c:	80 01       	ld.sh	r1,r0[0x0]
80005d2e:	41 74       	lddsp	r4,sp[0x5c]
80005d30:	80 01       	ld.sh	r1,r0[0x0]
80005d32:	5a 2c       	cp.w	r12,-30
80005d34:	80 01       	ld.sh	r1,r0[0x0]
80005d36:	4f 94       	lddpc	r4,80005f18 <ppu_resetSpriteColoursForScanline+0x10>
80005d38:	80 00       	ld.sh	r0,r0[0x0]
80005d3a:	c1 a0       	breq	80005d6e <ppu_setScrollRegister+0x32>

80005d3c <ppu_setScrollRegister>:
}
void ppu_setSpriteAddressRegister(PPU ppu, Byte spriteAddressRegister) {
  assert(ppu != NULL);
  ppu->spriteAddressRegister = spriteAddressRegister;
}
void ppu_setScrollRegister(PPU ppu, Byte scrollRegister) {
80005d3c:	d4 01       	pushm	lr
  assert(ppu != NULL);
80005d3e:	58 0c       	cp.w	r12,0
80005d40:	c0 81       	brne	80005d50 <ppu_setScrollRegister+0x14>
80005d42:	48 e9       	lddpc	r9,80005d78 <ppu_setScrollRegister+0x3c>
80005d44:	48 ea       	lddpc	r10,80005d7c <ppu_setScrollRegister+0x40>
80005d46:	e0 6b 03 75 	mov	r11,885
80005d4a:	48 ec       	lddpc	r12,80005d80 <ppu_setScrollRegister+0x44>
80005d4c:	f0 1f 00 0e 	mcall	80005d84 <ppu_setScrollRegister+0x48>
  if (ppu->hasPartial == FALSE) {
80005d50:	f9 39 00 0b 	ld.ub	r9,r12[11]
80005d54:	30 08       	mov	r8,0
    ppu->horizontalScroll = scrollRegister;
80005d56:	f0 09 18 00 	cp.b	r9,r8
80005d5a:	f9 fb 0e 0a 	st.beq	r12[0xa],r11
    ppu->hasPartial = TRUE;
80005d5e:	f9 b8 00 01 	moveq	r8,1
80005d62:	f9 f8 0e 0b 	st.beq	r12[0xb],r8
  } else {
    // we have a partial scroll
    ppu->verticalScroll = scrollRegister;
80005d66:	f9 fb 1e 09 	st.bne	r12[0x9],r11
    ppu->hasPartial = FALSE;
80005d6a:	f9 b8 01 00 	movne	r8,0
80005d6e:	f9 f8 1e 0b 	st.bne	r12[0xb],r8
  }
  ppu->scrollRegister = scrollRegister;
80005d72:	b8 db       	st.b	r12[0x5],r11
}
80005d74:	d8 02       	popm	pc
80005d76:	00 00       	add	r0,r0
80005d78:	80 01       	ld.sh	r1,r0[0x0]
80005d7a:	41 74       	lddsp	r4,sp[0x5c]
80005d7c:	80 01       	ld.sh	r1,r0[0x0]
80005d7e:	5a 4c       	cp.w	r12,-28
80005d80:	80 01       	ld.sh	r1,r0[0x0]
80005d82:	4f 94       	lddpc	r4,80005f64 <ppu_getCurrentBaseNametableAddress+0x1c>
80005d84:	80 00       	ld.sh	r0,r0[0x0]
80005d86:	c1 a0       	breq	80005dba <ppu_setMaskRegister+0xa>

80005d88 <ppu_setSpriteAddressRegister>:
}
void ppu_setStatusRegister(PPU ppu, Byte statusRegister) {
  assert(ppu != NULL);
  ppu->statusRegister = statusRegister;
}
void ppu_setSpriteAddressRegister(PPU ppu, Byte spriteAddressRegister) {
80005d88:	d4 01       	pushm	lr
  assert(ppu != NULL);
80005d8a:	58 0c       	cp.w	r12,0
80005d8c:	c0 81       	brne	80005d9c <ppu_setSpriteAddressRegister+0x14>
80005d8e:	48 59       	lddpc	r9,80005da0 <ppu_setSpriteAddressRegister+0x18>
80005d90:	48 5a       	lddpc	r10,80005da4 <ppu_setSpriteAddressRegister+0x1c>
80005d92:	e0 6b 03 71 	mov	r11,881
80005d96:	48 5c       	lddpc	r12,80005da8 <ppu_setSpriteAddressRegister+0x20>
80005d98:	f0 1f 00 05 	mcall	80005dac <ppu_setSpriteAddressRegister+0x24>
  ppu->spriteAddressRegister = spriteAddressRegister;
80005d9c:	b8 bb       	st.b	r12[0x3],r11
}
80005d9e:	d8 02       	popm	pc
80005da0:	80 01       	ld.sh	r1,r0[0x0]
80005da2:	41 74       	lddsp	r4,sp[0x5c]
80005da4:	80 01       	ld.sh	r1,r0[0x0]
80005da6:	59 f0       	cp.w	r0,31
80005da8:	80 01       	ld.sh	r1,r0[0x0]
80005daa:	4f 94       	lddpc	r4,80005f8c <ppu_getCurrentBaseNametableAddress+0x44>
80005dac:	80 00       	ld.sh	r0,r0[0x0]
80005dae:	c1 a0       	breq	80005de2 <ppu_setControlRegister+0xa>

80005db0 <ppu_setMaskRegister>:
}
void ppu_setControlRegister(PPU ppu, Byte controlRegister) {
  assert(ppu != NULL);
  ppu->controlRegister = controlRegister;
}
void ppu_setMaskRegister(PPU ppu, Byte maskRegister) {
80005db0:	d4 01       	pushm	lr
  assert(ppu != NULL);
80005db2:	58 0c       	cp.w	r12,0
80005db4:	c0 81       	brne	80005dc4 <ppu_setMaskRegister+0x14>
80005db6:	48 59       	lddpc	r9,80005dc8 <ppu_setMaskRegister+0x18>
80005db8:	48 5a       	lddpc	r10,80005dcc <ppu_setMaskRegister+0x1c>
80005dba:	e0 6b 03 69 	mov	r11,873
80005dbe:	48 5c       	lddpc	r12,80005dd0 <ppu_setMaskRegister+0x20>
80005dc0:	f0 1f 00 05 	mcall	80005dd4 <ppu_setMaskRegister+0x24>
  ppu->maskRegister = maskRegister;
80005dc4:	b8 9b       	st.b	r12[0x1],r11
}
80005dc6:	d8 02       	popm	pc
80005dc8:	80 01       	ld.sh	r1,r0[0x0]
80005dca:	41 74       	lddsp	r4,sp[0x5c]
80005dcc:	80 01       	ld.sh	r1,r0[0x0]
80005dce:	59 dc       	cp.w	r12,29
80005dd0:	80 01       	ld.sh	r1,r0[0x0]
80005dd2:	4f 94       	lddpc	r4,80005fb4 <ppu_getCurrentY+0xc>
80005dd4:	80 00       	ld.sh	r0,r0[0x0]
80005dd6:	c1 a0       	breq	80005e0a <ppu_getPPUMemoryAddressRegister+0xa>

80005dd8 <ppu_setControlRegister>:
}
Byte ppu_getPPUMemoryAddressRegister(PPU ppu) {
  assert(ppu != NULL);
  return ppu->ppuMemoryAddressRegister;
}
void ppu_setControlRegister(PPU ppu, Byte controlRegister) {
80005dd8:	d4 01       	pushm	lr
  assert(ppu != NULL);
80005dda:	58 0c       	cp.w	r12,0
80005ddc:	c0 81       	brne	80005dec <ppu_setControlRegister+0x14>
80005dde:	48 59       	lddpc	r9,80005df0 <ppu_setControlRegister+0x18>
80005de0:	48 5a       	lddpc	r10,80005df4 <ppu_setControlRegister+0x1c>
80005de2:	e0 6b 03 65 	mov	r11,869
80005de6:	48 5c       	lddpc	r12,80005df8 <ppu_setControlRegister+0x20>
80005de8:	f0 1f 00 05 	mcall	80005dfc <ppu_setControlRegister+0x24>
  ppu->controlRegister = controlRegister;
80005dec:	b8 8b       	st.b	r12[0x0],r11
}
80005dee:	d8 02       	popm	pc
80005df0:	80 01       	ld.sh	r1,r0[0x0]
80005df2:	41 74       	lddsp	r4,sp[0x5c]
80005df4:	80 01       	ld.sh	r1,r0[0x0]
80005df6:	59 58       	cp.w	r8,21
80005df8:	80 01       	ld.sh	r1,r0[0x0]
80005dfa:	4f 94       	lddpc	r4,80005fdc <ppu_getCurrentX+0x8>
80005dfc:	80 00       	ld.sh	r0,r0[0x0]
80005dfe:	c1 a0       	breq	80005e32 <ppu_getScrollRegister+0xa>

80005e00 <ppu_getPPUMemoryAddressRegister>:
}
Byte ppu_getScrollRegister(PPU ppu) {
  assert(ppu != NULL);
  return ppu->scrollRegister;
}
Byte ppu_getPPUMemoryAddressRegister(PPU ppu) {
80005e00:	d4 01       	pushm	lr
  assert(ppu != NULL);
80005e02:	58 0c       	cp.w	r12,0
80005e04:	c0 81       	brne	80005e14 <ppu_getPPUMemoryAddressRegister+0x14>
80005e06:	48 59       	lddpc	r9,80005e18 <ppu_getPPUMemoryAddressRegister+0x18>
80005e08:	48 5a       	lddpc	r10,80005e1c <ppu_getPPUMemoryAddressRegister+0x1c>
80005e0a:	e0 6b 03 61 	mov	r11,865
80005e0e:	48 5c       	lddpc	r12,80005e20 <ppu_getPPUMemoryAddressRegister+0x20>
80005e10:	f0 1f 00 05 	mcall	80005e24 <ppu_getPPUMemoryAddressRegister+0x24>
  return ppu->ppuMemoryAddressRegister;
}
80005e14:	19 ec       	ld.ub	r12,r12[0x6]
80005e16:	d8 02       	popm	pc
80005e18:	80 01       	ld.sh	r1,r0[0x0]
80005e1a:	41 74       	lddsp	r4,sp[0x5c]
80005e1c:	80 01       	ld.sh	r1,r0[0x0]
80005e1e:	59 9c       	cp.w	r12,25
80005e20:	80 01       	ld.sh	r1,r0[0x0]
80005e22:	4f 94       	lddpc	r4,80006004 <ppu_getPPUMemoryDataRegister+0x4>
80005e24:	80 00       	ld.sh	r0,r0[0x0]
80005e26:	c1 a0       	breq	80005e5a <ppu_getSpriteAddressRegister+0xa>

80005e28 <ppu_getScrollRegister>:
  PPU ppu = nes_getPPU(nes);
  assert(ppu != NULL);
  nes_writeObjectAttributeMemory(nes, ppu->spriteAddressRegister, spriteDataRegister);
  ppu->spriteAddressRegister++;
}
Byte ppu_getScrollRegister(PPU ppu) {
80005e28:	d4 01       	pushm	lr
  assert(ppu != NULL);
80005e2a:	58 0c       	cp.w	r12,0
80005e2c:	c0 81       	brne	80005e3c <ppu_getScrollRegister+0x14>
80005e2e:	48 59       	lddpc	r9,80005e40 <ppu_getScrollRegister+0x18>
80005e30:	48 5a       	lddpc	r10,80005e44 <ppu_getScrollRegister+0x1c>
80005e32:	e0 6b 03 5d 	mov	r11,861
80005e36:	48 5c       	lddpc	r12,80005e48 <ppu_getScrollRegister+0x20>
80005e38:	f0 1f 00 05 	mcall	80005e4c <ppu_getScrollRegister+0x24>
  return ppu->scrollRegister;
}
80005e3c:	19 dc       	ld.ub	r12,r12[0x5]
80005e3e:	d8 02       	popm	pc
80005e40:	80 01       	ld.sh	r1,r0[0x0]
80005e42:	41 74       	lddsp	r4,sp[0x5c]
80005e44:	80 01       	ld.sh	r1,r0[0x0]
80005e46:	59 04       	cp.w	r4,16
80005e48:	80 01       	ld.sh	r1,r0[0x0]
80005e4a:	4f 94       	lddpc	r4,8000602c <ppu_getPPUMemoryDataRegister+0x2c>
80005e4c:	80 00       	ld.sh	r0,r0[0x0]
80005e4e:	c1 a0       	breq	80005e82 <ppu_getStatusRegister+0xa>

80005e50 <ppu_getSpriteAddressRegister>:
  // cleared on read
  ppu_setStatusVerticalBlank(ppu, FALSE);
  ppu->hasPartial = FALSE;
  return status;
}
Byte ppu_getSpriteAddressRegister(PPU ppu) {
80005e50:	d4 01       	pushm	lr
  assert(ppu != NULL);
80005e52:	58 0c       	cp.w	r12,0
80005e54:	c0 81       	brne	80005e64 <ppu_getSpriteAddressRegister+0x14>
80005e56:	48 59       	lddpc	r9,80005e68 <ppu_getSpriteAddressRegister+0x18>
80005e58:	48 5a       	lddpc	r10,80005e6c <ppu_getSpriteAddressRegister+0x1c>
80005e5a:	e0 6b 03 49 	mov	r11,841
80005e5e:	48 5c       	lddpc	r12,80005e70 <ppu_getSpriteAddressRegister+0x20>
80005e60:	f0 1f 00 05 	mcall	80005e74 <ppu_getSpriteAddressRegister+0x24>
  return ppu->spriteAddressRegister;
}
80005e64:	19 bc       	ld.ub	r12,r12[0x3]
80005e66:	d8 02       	popm	pc
80005e68:	80 01       	ld.sh	r1,r0[0x0]
80005e6a:	41 74       	lddsp	r4,sp[0x5c]
80005e6c:	80 01       	ld.sh	r1,r0[0x0]
80005e6e:	58 94       	cp.w	r4,9
80005e70:	80 01       	ld.sh	r1,r0[0x0]
80005e72:	4f 94       	lddpc	r4,80006054 <ppu_getPPUMemoryDataRegister+0x54>
80005e74:	80 00       	ld.sh	r0,r0[0x0]
80005e76:	c1 a0       	breq	80005eaa <ppu_getStatusRegister+0x32>

80005e78 <ppu_getStatusRegister>:
}
Byte ppu_getMaskRegister(PPU ppu) {
  assert(ppu != NULL);
  return ppu->maskRegister;
}
Byte ppu_getStatusRegister(PPU ppu) {
80005e78:	eb cd 40 c0 	pushm	r6-r7,lr
80005e7c:	18 97       	mov	r7,r12
  assert(ppu != NULL);
80005e7e:	58 0c       	cp.w	r12,0
80005e80:	c0 81       	brne	80005e90 <ppu_getStatusRegister+0x18>
80005e82:	48 99       	lddpc	r9,80005ea4 <ppu_getStatusRegister+0x2c>
80005e84:	48 9a       	lddpc	r10,80005ea8 <ppu_getStatusRegister+0x30>
80005e86:	e0 6b 03 41 	mov	r11,833
80005e8a:	48 9c       	lddpc	r12,80005eac <ppu_getStatusRegister+0x34>
80005e8c:	f0 1f 00 09 	mcall	80005eb0 <ppu_getStatusRegister+0x38>
  Byte status = ppu->statusRegister;
80005e90:	19 a6       	ld.ub	r6,r12[0x2]
  // cleared on read
  ppu_setStatusVerticalBlank(ppu, FALSE);
80005e92:	30 0b       	mov	r11,0
80005e94:	f0 1f 00 08 	mcall	80005eb4 <ppu_getStatusRegister+0x3c>
  ppu->hasPartial = FALSE;
80005e98:	30 08       	mov	r8,0
80005e9a:	ef 68 00 0b 	st.b	r7[11],r8
  return status;
}
80005e9e:	0c 9c       	mov	r12,r6
80005ea0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005ea4:	80 01       	ld.sh	r1,r0[0x0]
80005ea6:	41 74       	lddsp	r4,sp[0x5c]
80005ea8:	80 01       	ld.sh	r1,r0[0x0]
80005eaa:	58 44       	cp.w	r4,4
80005eac:	80 01       	ld.sh	r1,r0[0x0]
80005eae:	4f 94       	lddpc	r4,80006090 <ppu_getPPUMemoryDataRegister+0x90>
80005eb0:	80 00       	ld.sh	r0,r0[0x0]
80005eb2:	c1 a0       	breq	80005ee6 <ppu_getControlRegister+0x6>
80005eb4:	80 00       	ld.sh	r0,r0[0x0]
80005eb6:	5a 5c       	cp.w	r12,-27

80005eb8 <ppu_getMaskRegister>:
}
Byte ppu_getControlRegister(PPU ppu) {
  assert(ppu != NULL);
  return ppu->controlRegister;
}
Byte ppu_getMaskRegister(PPU ppu) {
80005eb8:	d4 01       	pushm	lr
  assert(ppu != NULL);
80005eba:	58 0c       	cp.w	r12,0
80005ebc:	c0 81       	brne	80005ecc <ppu_getMaskRegister+0x14>
80005ebe:	48 59       	lddpc	r9,80005ed0 <ppu_getMaskRegister+0x18>
80005ec0:	48 5a       	lddpc	r10,80005ed4 <ppu_getMaskRegister+0x1c>
80005ec2:	e0 6b 03 3d 	mov	r11,829
80005ec6:	48 5c       	lddpc	r12,80005ed8 <ppu_getMaskRegister+0x20>
80005ec8:	f0 1f 00 05 	mcall	80005edc <ppu_getMaskRegister+0x24>
  return ppu->maskRegister;
}
80005ecc:	19 9c       	ld.ub	r12,r12[0x1]
80005ece:	d8 02       	popm	pc
80005ed0:	80 01       	ld.sh	r1,r0[0x0]
80005ed2:	41 74       	lddsp	r4,sp[0x5c]
80005ed4:	80 01       	ld.sh	r1,r0[0x0]
80005ed6:	5b 40       	cp.w	r0,-12
80005ed8:	80 01       	ld.sh	r1,r0[0x0]
80005eda:	4f 94       	lddpc	r4,800060bc <ppu_getPatternColourIndex+0x28>
80005edc:	80 00       	ld.sh	r0,r0[0x0]
80005ede:	c1 a0       	breq	80005f12 <ppu_resetSpriteColoursForScanline+0xa>

80005ee0 <ppu_getControlRegister>:
        nes_generateNMI(nes);
      }
    }
  }
}
Byte ppu_getControlRegister(PPU ppu) {
80005ee0:	d4 01       	pushm	lr
  assert(ppu != NULL);
80005ee2:	58 0c       	cp.w	r12,0
80005ee4:	c0 81       	brne	80005ef4 <ppu_getControlRegister+0x14>
80005ee6:	48 59       	lddpc	r9,80005ef8 <ppu_getControlRegister+0x18>
80005ee8:	48 5a       	lddpc	r10,80005efc <ppu_getControlRegister+0x1c>
80005eea:	e0 6b 03 39 	mov	r11,825
80005eee:	48 5c       	lddpc	r12,80005f00 <ppu_getControlRegister+0x20>
80005ef0:	f0 1f 00 05 	mcall	80005f04 <ppu_getControlRegister+0x24>
  return ppu->controlRegister;
}
80005ef4:	19 8c       	ld.ub	r12,r12[0x0]
80005ef6:	d8 02       	popm	pc
80005ef8:	80 01       	ld.sh	r1,r0[0x0]
80005efa:	41 74       	lddsp	r4,sp[0x5c]
80005efc:	80 01       	ld.sh	r1,r0[0x0]
80005efe:	58 2c       	cp.w	r12,2
80005f00:	80 01       	ld.sh	r1,r0[0x0]
80005f02:	4f 94       	lddpc	r4,800060e4 <ppu_getPatternColourIndex+0x50>
80005f04:	80 00       	ld.sh	r0,r0[0x0]
80005f06:	c1 a0       	breq	80005f3a <ppu_resetSpriteColoursForScanline+0x32>

80005f08 <ppu_resetSpriteColoursForScanline>:
  int currentFrame;
  Byte spriteColoursForScanline[PPU_SCREEN_WIDTH_IN_PIXELS];
  Bool spriteColoursForScanlineSet[PPU_SCREEN_WIDTH_IN_PIXELS];
  Bool spriteColoursForScanlineIsBehindBackground[PPU_SCREEN_WIDTH_IN_PIXELS];
};
static void ppu_resetSpriteColoursForScanline(PPU ppu) {
80005f08:	d4 01       	pushm	lr
  assert(ppu != NULL);
80005f0a:	58 0c       	cp.w	r12,0
80005f0c:	c0 71       	brne	80005f1a <ppu_resetSpriteColoursForScanline+0x12>
80005f0e:	48 b9       	lddpc	r9,80005f38 <ppu_resetSpriteColoursForScanline+0x30>
80005f10:	48 ba       	lddpc	r10,80005f3c <ppu_resetSpriteColoursForScanline+0x34>
80005f12:	36 fb       	mov	r11,111
80005f14:	48 bc       	lddpc	r12,80005f40 <ppu_resetSpriteColoursForScanline+0x38>
80005f16:	f0 1f 00 0c 	mcall	80005f44 <ppu_resetSpriteColoursForScanline+0x3c>
80005f1a:	f8 c8 ff e0 	sub	r8,r12,-32
80005f1e:	30 0a       	mov	r10,0
  int i;
  for (i=0; i < PPU_SCREEN_WIDTH_IN_PIXELS; i++) {
    ppu->spriteColoursForScanline[i] = 0;
80005f20:	30 09       	mov	r9,0
80005f22:	b0 89       	st.b	r8[0x0],r9
    ppu->spriteColoursForScanlineSet[i] = FALSE;
80005f24:	f1 69 01 00 	st.b	r8[256],r9
    ppu->spriteColoursForScanlineIsBehindBackground[i] = FALSE;
80005f28:	f1 69 02 00 	st.b	r8[512],r9
  Bool spriteColoursForScanlineIsBehindBackground[PPU_SCREEN_WIDTH_IN_PIXELS];
};
static void ppu_resetSpriteColoursForScanline(PPU ppu) {
  assert(ppu != NULL);
  int i;
  for (i=0; i < PPU_SCREEN_WIDTH_IN_PIXELS; i++) {
80005f2c:	2f fa       	sub	r10,-1
80005f2e:	2f f8       	sub	r8,-1
80005f30:	e0 4a 01 00 	cp.w	r10,256
80005f34:	cf 71       	brne	80005f22 <ppu_resetSpriteColoursForScanline+0x1a>
    ppu->spriteColoursForScanline[i] = 0;
    ppu->spriteColoursForScanlineSet[i] = FALSE;
    ppu->spriteColoursForScanlineIsBehindBackground[i] = FALSE;
  }
}
80005f36:	d8 02       	popm	pc
80005f38:	80 01       	ld.sh	r1,r0[0x0]
80005f3a:	41 74       	lddsp	r4,sp[0x5c]
80005f3c:	80 01       	ld.sh	r1,r0[0x0]
80005f3e:	5b e4       	cp.w	r4,-2
80005f40:	80 01       	ld.sh	r1,r0[0x0]
80005f42:	4f 94       	lddpc	r4,80006124 <ppu_getPatternColourIndex+0x90>
80005f44:	80 00       	ld.sh	r0,r0[0x0]
80005f46:	c1 a0       	breq	80005f7a <ppu_getCurrentBaseNametableAddress+0x32>

80005f48 <ppu_getCurrentBaseNametableAddress>:
    ppu->controlRegister |= MASK_CONTROL_VERTICAL_SCROLL_NAME_TABLE_ON;
  } else if (state == FALSE) {
    ppu->controlRegister &= MASK_CONTROL_VERTICAL_SCROLL_NAME_TABLE_OFF;
  }
}
static Address ppu_getCurrentBaseNametableAddress(PPU ppu) {
80005f48:	eb cd 40 c0 	pushm	r6-r7,lr
80005f4c:	18 97       	mov	r7,r12
  assert(ppu != NULL);
80005f4e:	58 0c       	cp.w	r12,0
80005f50:	c0 81       	brne	80005f60 <ppu_getCurrentBaseNametableAddress+0x18>
80005f52:	49 09       	lddpc	r9,80005f90 <ppu_getCurrentBaseNametableAddress+0x48>
80005f54:	49 0a       	lddpc	r10,80005f94 <ppu_getCurrentBaseNametableAddress+0x4c>
80005f56:	e0 6b 00 b6 	mov	r11,182
80005f5a:	49 0c       	lddpc	r12,80005f98 <ppu_getCurrentBaseNametableAddress+0x50>
80005f5c:	f0 1f 00 10 	mcall	80005f9c <ppu_getCurrentBaseNametableAddress+0x54>
  Address address = PPU_NAME_TABLE_0_FIRST_ADDRESS;
  if (ppu_getControlHorizontalScrollNametable(ppu) == TRUE) {
80005f60:	f0 1f 00 10 	mcall	80005fa0 <ppu_getCurrentBaseNametableAddress+0x58>
80005f64:	30 18       	mov	r8,1
80005f66:	e0 69 24 00 	mov	r9,9216
80005f6a:	e0 66 20 00 	mov	r6,8192
80005f6e:	f8 08 18 00 	cp.b	r8,r12
80005f72:	f2 06 17 00 	moveq	r6,r9
    address += PPU_NAME_TABLE_SIZE;
  }
  if (ppu_getControlVerticalScrollNametable(ppu) == TRUE) {
80005f76:	0e 9c       	mov	r12,r7
80005f78:	f0 1f 00 0b 	mcall	80005fa4 <ppu_getCurrentBaseNametableAddress+0x5c>
80005f7c:	30 18       	mov	r8,1
80005f7e:	f0 0c 18 00 	cp.b	r12,r8
80005f82:	c0 31       	brne	80005f88 <ppu_getCurrentBaseNametableAddress+0x40>
    address += PPU_NAME_TABLE_SIZE;
    address += PPU_NAME_TABLE_SIZE;
80005f84:	ec c6 f8 00 	sub	r6,r6,-2048
  }
  return address;
}
80005f88:	0c 9c       	mov	r12,r6
80005f8a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005f8e:	00 00       	add	r0,r0
80005f90:	80 01       	ld.sh	r1,r0[0x0]
80005f92:	41 74       	lddsp	r4,sp[0x5c]
80005f94:	80 01       	ld.sh	r1,r0[0x0]
80005f96:	4f 70       	lddpc	r0,80006170 <ppu_getSystemIndexFromBackgroundIndex+0x2c>
80005f98:	80 01       	ld.sh	r1,r0[0x0]
80005f9a:	4f 94       	lddpc	r4,8000617c <ppu_setPPUMemoryDataRegister+0x4>
80005f9c:	80 00       	ld.sh	r0,r0[0x0]
80005f9e:	c1 a0       	breq	80005fd2 <ppu_getCurrentY+0x2a>
80005fa0:	80 00       	ld.sh	r0,r0[0x0]
80005fa2:	5b 24       	cp.w	r4,-14
80005fa4:	80 00       	ld.sh	r0,r0[0x0]
80005fa6:	5b 50       	cp.w	r0,-11

80005fa8 <ppu_getCurrentY>:
}
static Byte ppu_getCurrentX(PPU ppu) {
  assert(ppu != NULL);
  return ppu->currentScanlineCycle;
}
static Byte ppu_getCurrentY(PPU ppu) {
80005fa8:	d4 01       	pushm	lr
  assert(ppu != NULL);
80005faa:	58 0c       	cp.w	r12,0
80005fac:	c0 81       	brne	80005fbc <ppu_getCurrentY+0x14>
80005fae:	48 69       	lddpc	r9,80005fc4 <ppu_getCurrentY+0x1c>
80005fb0:	48 6a       	lddpc	r10,80005fc8 <ppu_getCurrentY+0x20>
80005fb2:	e0 6b 01 d2 	mov	r11,466
80005fb6:	48 6c       	lddpc	r12,80005fcc <ppu_getCurrentY+0x24>
80005fb8:	f0 1f 00 06 	mcall	80005fd0 <ppu_getCurrentY+0x28>
80005fbc:	78 5c       	ld.w	r12,r12[0x14]
80005fbe:	21 5c       	sub	r12,21
  return ppu->currentScanline - PPU_WASTED_VBLANK_SCANLINES -
PPU_WASTED_PREFETCH_SCANLINES;
}
80005fc0:	5c 5c       	castu.b	r12
80005fc2:	d8 02       	popm	pc
80005fc4:	80 01       	ld.sh	r1,r0[0x0]
80005fc6:	41 74       	lddsp	r4,sp[0x5c]
80005fc8:	80 01       	ld.sh	r1,r0[0x0]
80005fca:	58 1c       	cp.w	r12,1
80005fcc:	80 01       	ld.sh	r1,r0[0x0]
80005fce:	4f 94       	lddpc	r4,800061b0 <ppu_setPPUMemoryDataRegister+0x38>
80005fd0:	80 00       	ld.sh	r0,r0[0x0]
80005fd2:	c1 a0       	breq	80006006 <ppu_getPPUMemoryDataRegister+0x6>

80005fd4 <ppu_getCurrentX>:
    return TRUE;
  } else {
    return FALSE;
  }
}
static Byte ppu_getCurrentX(PPU ppu) {
80005fd4:	d4 01       	pushm	lr
  assert(ppu != NULL);
80005fd6:	58 0c       	cp.w	r12,0
80005fd8:	c0 81       	brne	80005fe8 <ppu_getCurrentX+0x14>
80005fda:	48 69       	lddpc	r9,80005ff0 <ppu_getCurrentX+0x1c>
80005fdc:	48 6a       	lddpc	r10,80005ff4 <ppu_getCurrentX+0x20>
80005fde:	e0 6b 01 ce 	mov	r11,462
80005fe2:	48 6c       	lddpc	r12,80005ff8 <ppu_getCurrentX+0x24>
80005fe4:	f0 1f 00 06 	mcall	80005ffc <ppu_getCurrentX+0x28>
  return ppu->currentScanlineCycle;
}
80005fe8:	f9 3c 00 1b 	ld.ub	r12,r12[27]
80005fec:	d8 02       	popm	pc
80005fee:	00 00       	add	r0,r0
80005ff0:	80 01       	ld.sh	r1,r0[0x0]
80005ff2:	41 74       	lddsp	r4,sp[0x5c]
80005ff4:	80 01       	ld.sh	r1,r0[0x0]
80005ff6:	4f 60       	lddpc	r0,800061cc <ppu_setPPUMemoryDataRegister+0x54>
80005ff8:	80 01       	ld.sh	r1,r0[0x0]
80005ffa:	4f 94       	lddpc	r4,800061dc <ppu_setPPUMemoryDataRegister+0x64>
80005ffc:	80 00       	ld.sh	r0,r0[0x0]
80005ffe:	c1 a0       	breq	80006032 <ppu_getPPUMemoryDataRegister+0x32>

80006000 <ppu_getPPUMemoryDataRegister>:
  nes_writePPUMemory(nes, address, ppuMemoryDataRegister);
  //ppu->ppuMemoryDataRegister = ppuMemoryDataRegister;
  ppu_increasePPUMemoryAddress(ppu);
}
// one buffer pipeline
Byte ppu_getPPUMemoryDataRegister(NES nes) {
80006000:	d4 21       	pushm	r4-r7,lr
80006002:	18 95       	mov	r5,r12
  assert(nes != NULL);
80006004:	58 0c       	cp.w	r12,0
80006006:	c0 81       	brne	80006016 <ppu_getPPUMemoryDataRegister+0x16>
80006008:	49 b9       	lddpc	r9,80006074 <ppu_getPPUMemoryDataRegister+0x74>
8000600a:	49 ca       	lddpc	r10,80006078 <ppu_getPPUMemoryDataRegister+0x78>
8000600c:	e0 6b 03 a4 	mov	r11,932
80006010:	49 bc       	lddpc	r12,8000607c <ppu_getPPUMemoryDataRegister+0x7c>
80006012:	f0 1f 00 1c 	mcall	80006080 <ppu_getPPUMemoryDataRegister+0x80>
  PPU ppu = nes_getPPU(nes);
80006016:	f0 1f 00 1c 	mcall	80006084 <ppu_getPPUMemoryDataRegister+0x84>
8000601a:	18 97       	mov	r7,r12
  assert(ppu != NULL);
8000601c:	c0 81       	brne	8000602c <ppu_getPPUMemoryDataRegister+0x2c>
8000601e:	49 b9       	lddpc	r9,80006088 <ppu_getPPUMemoryDataRegister+0x88>
80006020:	49 6a       	lddpc	r10,80006078 <ppu_getPPUMemoryDataRegister+0x78>
80006022:	e0 6b 03 a6 	mov	r11,934
80006026:	49 6c       	lddpc	r12,8000607c <ppu_getPPUMemoryDataRegister+0x7c>
80006028:	f0 1f 00 16 	mcall	80006080 <ppu_getPPUMemoryDataRegister+0x80>
  Byte data = ppu->ppuMemoryReadBuffer;
8000602c:	f9 34 00 08 	ld.ub	r4,r12[8]
  Address address = ppu->ppuAddressLow;
80006030:	f9 38 00 0c 	ld.ub	r8,r12[12]
  address += ppu->ppuAddressHigh << BITS_PER_BYTE;
80006034:	f9 36 00 0d 	ld.ub	r6,r12[13]
80006038:	a9 66       	lsl	r6,0x8
8000603a:	10 06       	add	r6,r8
8000603c:	5c 86       	casts.h	r6
  ppu->ppuMemoryReadBuffer = nes_readPPUMemory(nes, address);
8000603e:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006042:	0a 9c       	mov	r12,r5
80006044:	f0 1f 00 12 	mcall	8000608c <ppu_getPPUMemoryDataRegister+0x8c>
80006048:	ef 6c 00 08 	st.b	r7[8],r12
  while (address > PPU_LAST_REAL_ADDRESS) {
8000604c:	e0 68 3f ff 	mov	r8,16383
80006050:	f0 06 19 00 	cp.h	r6,r8
80006054:	e0 88 00 04 	brls	8000605c <ppu_getPPUMemoryDataRegister+0x5c>
    address -= PPU_NUM_REAL_ADDRESSES;
80006058:	ed d6 c0 0e 	bfextu	r6,r6,0x0,0xe
  }
  assert(address <= PPU_LAST_REAL_ADDRESS);
  // palette reads are not buffered
  if (address >= PPU_BACKGROUND_PALETTE_FIRST_ADDRESS) {
8000605c:	e0 68 3e ff 	mov	r8,16127
80006060:	ec 08 19 00 	cp.h	r8,r6
80006064:	f8 04 17 30 	movlo	r4,r12
    data = ppu->ppuMemoryReadBuffer;
  }
  ppu_increasePPUMemoryAddress(ppu);
80006068:	0e 9c       	mov	r12,r7
8000606a:	f0 1f 00 0a 	mcall	80006090 <ppu_getPPUMemoryDataRegister+0x90>
  return data;
}
8000606e:	08 9c       	mov	r12,r4
80006070:	d8 22       	popm	r4-r7,pc
80006072:	00 00       	add	r0,r0
80006074:	80 01       	ld.sh	r1,r0[0x0]
80006076:	31 44       	mov	r4,20
80006078:	80 01       	ld.sh	r1,r0[0x0]
8000607a:	5b 00       	cp.w	r0,-16
8000607c:	80 01       	ld.sh	r1,r0[0x0]
8000607e:	4f 94       	lddpc	r4,80006260 <ppu_getSpriteDataRegister+0x18>
80006080:	80 00       	ld.sh	r0,r0[0x0]
80006082:	c1 a0       	breq	800060b6 <ppu_getPatternColourIndex+0x22>
80006084:	80 00       	ld.sh	r0,r0[0x0]
80006086:	50 48       	stdsp	sp[0x10],r8
80006088:	80 01       	ld.sh	r1,r0[0x0]
8000608a:	41 74       	lddsp	r4,sp[0x5c]
8000608c:	80 00       	ld.sh	r0,r0[0x0]
8000608e:	52 c8       	stdsp	sp[0xb0],r8
80006090:	80 00       	ld.sh	r0,r0[0x0]
80006092:	5b a8       	cp.w	r8,-6

80006094 <ppu_getPatternColourIndex>:
  Byte patternIndex = pattern1 + pattern2;
  assert(patternIndex <= 3);
  return patternIndex;
}
static Byte ppu_getPatternColourIndex(NES nes, Address basePatternAddress, Byte
patternTileNumber, Byte x, Byte y) {
80006094:	eb cd 40 f8 	pushm	r3-r7,lr
80006098:	18 97       	mov	r7,r12
8000609a:	16 96       	mov	r6,r11
8000609c:	14 95       	mov	r5,r10
8000609e:	12 93       	mov	r3,r9
800060a0:	10 94       	mov	r4,r8
  assert(nes != NULL);
800060a2:	58 0c       	cp.w	r12,0
800060a4:	c0 81       	brne	800060b4 <ppu_getPatternColourIndex+0x20>
800060a6:	49 f9       	lddpc	r9,80006120 <ppu_getPatternColourIndex+0x8c>
800060a8:	49 fa       	lddpc	r10,80006124 <ppu_getPatternColourIndex+0x90>
800060aa:	e0 6b 01 fb 	mov	r11,507
800060ae:	49 fc       	lddpc	r12,80006128 <ppu_getPatternColourIndex+0x94>
800060b0:	f0 1f 00 1f 	mcall	8000612c <ppu_getPatternColourIndex+0x98>
  PPU ppu = nes_getPPU(nes);
800060b4:	f0 1f 00 1f 	mcall	80006130 <ppu_getPatternColourIndex+0x9c>
  assert(ppu != NULL);
800060b8:	c0 81       	brne	800060c8 <ppu_getPatternColourIndex+0x34>
800060ba:	49 f9       	lddpc	r9,80006134 <ppu_getPatternColourIndex+0xa0>
800060bc:	49 aa       	lddpc	r10,80006124 <ppu_getPatternColourIndex+0x90>
800060be:	e0 6b 01 fd 	mov	r11,509
800060c2:	49 ac       	lddpc	r12,80006128 <ppu_getPatternColourIndex+0x94>
800060c4:	f0 1f 00 1a 	mcall	8000612c <ppu_getPatternColourIndex+0x98>
  Word horizontalOffset = patternTileNumber * PPU_PATTERN_BYTES_PER_TILE;
  Word verticalOffset = (y % PPU_VERTICAL_PIXELS_PER_TILE);
  Address pattern1Address = basePatternAddress + horizontalOffset + verticalOffset;
800060c8:	a5 65       	lsl	r5,0x4
800060ca:	ea 06 00 06 	add	r6,r5,r6
800060ce:	e9 d4 c0 03 	bfextu	r4,r4,0x0,0x3
800060d2:	08 06       	add	r6,r4
  Address pattern2Address = pattern1Address + 8;
  Byte pattern1 = nes_readPPUMemory(nes, pattern1Address);
800060d4:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800060d8:	0e 9c       	mov	r12,r7
800060da:	f0 1f 00 18 	mcall	80006138 <ppu_getPatternColourIndex+0xa4>
800060de:	18 95       	mov	r5,r12
  Byte pattern2 = nes_readPPUMemory(nes, pattern2Address);
800060e0:	2f 86       	sub	r6,-8
800060e2:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800060e6:	0e 9c       	mov	r12,r7
800060e8:	f0 1f 00 14 	mcall	80006138 <ppu_getPatternColourIndex+0xa4>
  return nes_readPPUMemory(nes,nametableByteAddress);
}
static Byte ppu_combinePatternBytes(PPU ppu, Byte pattern1, Byte pattern2, Byte x) {
  assert(ppu != NULL);
  x %= PPU_HORIZONTAL_PIXELS_PER_TILE;
  pattern1 = pattern1 << x;
800060ec:	e7 d3 c0 03 	bfextu	r3,r3,0x0,0x3
800060f0:	ea 03 09 45 	lsl	r5,r5,r3
  pattern1 = pattern1 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
  pattern2 = pattern2 << x;
800060f4:	f8 03 09 4c 	lsl	r12,r12,r3
  pattern2 = pattern2 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
800060f8:	f9 dc c0 e1 	bfextu	r12,r12,0x7,0x1
  pattern2 = pattern2 << 1;
  Byte patternIndex = pattern1 + pattern2;
800060fc:	eb d5 c0 e1 	bfextu	r5,r5,0x7,0x1
80006100:	ea 0c 00 1c 	add	r12,r5,r12<<0x1
  assert(patternIndex <= 3);
80006104:	30 38       	mov	r8,3
80006106:	f0 0c 18 00 	cp.b	r12,r8
8000610a:	e0 88 00 09 	brls	8000611c <ppu_getPatternColourIndex+0x88>
8000610e:	48 c9       	lddpc	r9,8000613c <ppu_getPatternColourIndex+0xa8>
80006110:	48 ca       	lddpc	r10,80006140 <ppu_getPatternColourIndex+0xac>
80006112:	e0 6b 01 f6 	mov	r11,502
80006116:	48 5c       	lddpc	r12,80006128 <ppu_getPatternColourIndex+0x94>
80006118:	f0 1f 00 05 	mcall	8000612c <ppu_getPatternColourIndex+0x98>
  Address pattern2Address = pattern1Address + 8;
  Byte pattern1 = nes_readPPUMemory(nes, pattern1Address);
  Byte pattern2 = nes_readPPUMemory(nes, pattern2Address);
  Address patternIndex = ppu_combinePatternBytes(ppu, pattern1, pattern2, x);
  return patternIndex;
}
8000611c:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80006120:	80 01       	ld.sh	r1,r0[0x0]
80006122:	31 44       	mov	r4,20
80006124:	80 01       	ld.sh	r1,r0[0x0]
80006126:	59 3c       	cp.w	r12,19
80006128:	80 01       	ld.sh	r1,r0[0x0]
8000612a:	4f 94       	lddpc	r4,8000630c <ppu_updateScanlineSpriteColour8+0x70>
8000612c:	80 00       	ld.sh	r0,r0[0x0]
8000612e:	c1 a0       	breq	80006162 <ppu_getSystemIndexFromBackgroundIndex+0x1e>
80006130:	80 00       	ld.sh	r0,r0[0x0]
80006132:	50 48       	stdsp	sp[0x10],r8
80006134:	80 01       	ld.sh	r1,r0[0x0]
80006136:	41 74       	lddsp	r4,sp[0x5c]
80006138:	80 00       	ld.sh	r0,r0[0x0]
8000613a:	52 c8       	stdsp	sp[0xb0],r8
8000613c:	80 01       	ld.sh	r1,r0[0x0]
8000613e:	4f a8       	lddpc	r8,80006324 <ppu_updateScanlineSpriteColour8+0x88>
80006140:	80 01       	ld.sh	r1,r0[0x0]
80006142:	5c 08       	acr	r8

80006144 <ppu_getSystemIndexFromBackgroundIndex>:
  }
  attributeColourIndex = attributeColourIndex >> 6;
  attributeColourIndex = attributeColourIndex << 2;
  return attributeColourIndex;
}
static Byte ppu_getSystemIndexFromBackgroundIndex(NES nes, Byte backgroundColourIndex) {
80006144:	d4 01       	pushm	lr
  assert(nes != NULL);
80006146:	58 0c       	cp.w	r12,0
80006148:	c0 81       	brne	80006158 <ppu_getSystemIndexFromBackgroundIndex+0x14>
8000614a:	48 79       	lddpc	r9,80006164 <ppu_getSystemIndexFromBackgroundIndex+0x20>
8000614c:	48 7a       	lddpc	r10,80006168 <ppu_getSystemIndexFromBackgroundIndex+0x24>
8000614e:	e0 6b 02 4d 	mov	r11,589
80006152:	48 7c       	lddpc	r12,8000616c <ppu_getSystemIndexFromBackgroundIndex+0x28>
80006154:	f0 1f 00 07 	mcall	80006170 <ppu_getSystemIndexFromBackgroundIndex+0x2c>
  Address address = PPU_BACKGROUND_PALETTE_FIRST_ADDRESS;
  address += backgroundColourIndex;
  Byte systemIndex = nes_readPPUMemory(nes, address);
80006158:	f6 cb c1 00 	sub	r11,r11,-16128
8000615c:	5c 7b       	castu.h	r11
8000615e:	f0 1f 00 06 	mcall	80006174 <ppu_getSystemIndexFromBackgroundIndex+0x30>
  return systemIndex;
}
80006162:	d8 02       	popm	pc
80006164:	80 01       	ld.sh	r1,r0[0x0]
80006166:	31 44       	mov	r4,20
80006168:	80 01       	ld.sh	r1,r0[0x0]
8000616a:	5b 54       	cp.w	r4,-11
8000616c:	80 01       	ld.sh	r1,r0[0x0]
8000616e:	4f 94       	lddpc	r4,80006350 <ppu_updateScanlineSpriteColour8+0xb4>
80006170:	80 00       	ld.sh	r0,r0[0x0]
80006172:	c1 a0       	breq	800061a6 <ppu_setPPUMemoryDataRegister+0x2e>
80006174:	80 00       	ld.sh	r0,r0[0x0]
80006176:	52 c8       	stdsp	sp[0xb0],r8

80006178 <ppu_setPPUMemoryDataRegister>:
    address += PPU_CONTROL_ADDRESS_HORIZONTAL_INCREMENT;
  }
  ppu->ppuAddressLow = GET_ADDRESS_LOW_BYTE(address);
  ppu->ppuAddressHigh = GET_ADDRESS_HIGH_BYTE(address);
}
void ppu_setPPUMemoryDataRegister(NES nes, Byte ppuMemoryDataRegister) {
80006178:	eb cd 40 e0 	pushm	r5-r7,lr
8000617c:	18 96       	mov	r6,r12
8000617e:	16 95       	mov	r5,r11
  assert(nes != NULL);
80006180:	58 0c       	cp.w	r12,0
80006182:	c0 81       	brne	80006192 <ppu_setPPUMemoryDataRegister+0x1a>
80006184:	49 19       	lddpc	r9,800061c8 <ppu_setPPUMemoryDataRegister+0x50>
80006186:	49 2a       	lddpc	r10,800061cc <ppu_setPPUMemoryDataRegister+0x54>
80006188:	e0 6b 03 99 	mov	r11,921
8000618c:	49 1c       	lddpc	r12,800061d0 <ppu_setPPUMemoryDataRegister+0x58>
8000618e:	f0 1f 00 12 	mcall	800061d4 <ppu_setPPUMemoryDataRegister+0x5c>
  PPU ppu = nes_getPPU(nes);
80006192:	f0 1f 00 12 	mcall	800061d8 <ppu_setPPUMemoryDataRegister+0x60>
80006196:	18 97       	mov	r7,r12
  assert(ppu != NULL);
80006198:	c0 81       	brne	800061a8 <ppu_setPPUMemoryDataRegister+0x30>
8000619a:	49 19       	lddpc	r9,800061dc <ppu_setPPUMemoryDataRegister+0x64>
8000619c:	48 ca       	lddpc	r10,800061cc <ppu_setPPUMemoryDataRegister+0x54>
8000619e:	e0 6b 03 9b 	mov	r11,923
800061a2:	48 cc       	lddpc	r12,800061d0 <ppu_setPPUMemoryDataRegister+0x58>
800061a4:	f0 1f 00 0c 	mcall	800061d4 <ppu_setPPUMemoryDataRegister+0x5c>
  Address address = ppu->ppuAddressLow;
800061a8:	f9 38 00 0c 	ld.ub	r8,r12[12]
  address += ppu->ppuAddressHigh << BITS_PER_BYTE;
  nes_writePPUMemory(nes, address, ppuMemoryDataRegister);
800061ac:	f9 3b 00 0d 	ld.ub	r11,r12[13]
800061b0:	a9 6b       	lsl	r11,0x8
800061b2:	10 0b       	add	r11,r8
800061b4:	0a 9a       	mov	r10,r5
800061b6:	5c 7b       	castu.h	r11
800061b8:	0c 9c       	mov	r12,r6
800061ba:	f0 1f 00 0a 	mcall	800061e0 <ppu_setPPUMemoryDataRegister+0x68>
  //ppu->ppuMemoryDataRegister = ppuMemoryDataRegister;
  ppu_increasePPUMemoryAddress(ppu);
800061be:	0e 9c       	mov	r12,r7
800061c0:	f0 1f 00 09 	mcall	800061e4 <ppu_setPPUMemoryDataRegister+0x6c>
}
800061c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800061c8:	80 01       	ld.sh	r1,r0[0x0]
800061ca:	31 44       	mov	r4,20
800061cc:	80 01       	ld.sh	r1,r0[0x0]
800061ce:	5a c0       	cp.w	r0,-20
800061d0:	80 01       	ld.sh	r1,r0[0x0]
800061d2:	4f 94       	lddpc	r4,800063b4 <ppu_updateScanlineSpriteColour8+0x118>
800061d4:	80 00       	ld.sh	r0,r0[0x0]
800061d6:	c1 a0       	breq	8000620a <ppu_setSpriteDataRegister+0x22>
800061d8:	80 00       	ld.sh	r0,r0[0x0]
800061da:	50 48       	stdsp	sp[0x10],r8
800061dc:	80 01       	ld.sh	r1,r0[0x0]
800061de:	41 74       	lddsp	r4,sp[0x5c]
800061e0:	80 00       	ld.sh	r0,r0[0x0]
800061e2:	51 bc       	stdsp	sp[0x6c],r12
800061e4:	80 00       	ld.sh	r0,r0[0x0]
800061e6:	5b a8       	cp.w	r8,-6

800061e8 <ppu_setSpriteDataRegister>:
  Byte data = nes_readObjectAttributeMemory(nes, ppu->spriteAddressRegister);
  //reads don't increase this?
  //ppu->spriteAddressRegister++;
  return data;
}
void ppu_setSpriteDataRegister(NES nes, Byte spriteDataRegister) {
800061e8:	eb cd 40 e0 	pushm	r5-r7,lr
800061ec:	18 96       	mov	r6,r12
800061ee:	16 95       	mov	r5,r11
  assert(nes != NULL);
800061f0:	58 0c       	cp.w	r12,0
800061f2:	c0 81       	brne	80006202 <ppu_setSpriteDataRegister+0x1a>
800061f4:	48 e9       	lddpc	r9,8000622c <ppu_setSpriteDataRegister+0x44>
800061f6:	48 fa       	lddpc	r10,80006230 <ppu_setSpriteDataRegister+0x48>
800061f8:	e0 6b 03 56 	mov	r11,854
800061fc:	48 ec       	lddpc	r12,80006234 <ppu_setSpriteDataRegister+0x4c>
800061fe:	f0 1f 00 0f 	mcall	80006238 <ppu_setSpriteDataRegister+0x50>
  PPU ppu = nes_getPPU(nes);
80006202:	f0 1f 00 0f 	mcall	8000623c <ppu_setSpriteDataRegister+0x54>
80006206:	18 97       	mov	r7,r12
  assert(ppu != NULL);
80006208:	c0 81       	brne	80006218 <ppu_setSpriteDataRegister+0x30>
8000620a:	48 e9       	lddpc	r9,80006240 <ppu_setSpriteDataRegister+0x58>
8000620c:	48 9a       	lddpc	r10,80006230 <ppu_setSpriteDataRegister+0x48>
8000620e:	e0 6b 03 58 	mov	r11,856
80006212:	48 9c       	lddpc	r12,80006234 <ppu_setSpriteDataRegister+0x4c>
80006214:	f0 1f 00 09 	mcall	80006238 <ppu_setSpriteDataRegister+0x50>
  nes_writeObjectAttributeMemory(nes, ppu->spriteAddressRegister, spriteDataRegister);
80006218:	0a 9a       	mov	r10,r5
8000621a:	19 bb       	ld.ub	r11,r12[0x3]
8000621c:	0c 9c       	mov	r12,r6
8000621e:	f0 1f 00 0a 	mcall	80006244 <ppu_setSpriteDataRegister+0x5c>
  ppu->spriteAddressRegister++;
80006222:	0f b8       	ld.ub	r8,r7[0x3]
80006224:	2f f8       	sub	r8,-1
80006226:	ae b8       	st.b	r7[0x3],r8
}
80006228:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000622c:	80 01       	ld.sh	r1,r0[0x0]
8000622e:	31 44       	mov	r4,20
80006230:	80 01       	ld.sh	r1,r0[0x0]
80006232:	5a 10       	cp.w	r0,-31
80006234:	80 01       	ld.sh	r1,r0[0x0]
80006236:	4f 94       	lddpc	r4,80006418 <ppu_updateScanlineSpriteColour8+0x17c>
80006238:	80 00       	ld.sh	r0,r0[0x0]
8000623a:	c1 a0       	breq	8000626e <ppu_getSpriteDataRegister+0x26>
8000623c:	80 00       	ld.sh	r0,r0[0x0]
8000623e:	50 48       	stdsp	sp[0x10],r8
80006240:	80 01       	ld.sh	r1,r0[0x0]
80006242:	41 74       	lddsp	r4,sp[0x5c]
80006244:	80 00       	ld.sh	r0,r0[0x0]
80006246:	52 18       	stdsp	sp[0x84],r8

80006248 <ppu_getSpriteDataRegister>:
}
Byte ppu_getSpriteAddressRegister(PPU ppu) {
  assert(ppu != NULL);
  return ppu->spriteAddressRegister;
}
Byte ppu_getSpriteDataRegister(NES nes) {
80006248:	eb cd 40 80 	pushm	r7,lr
8000624c:	18 97       	mov	r7,r12
  assert(nes != NULL);
8000624e:	58 0c       	cp.w	r12,0
80006250:	c0 81       	brne	80006260 <ppu_getSpriteDataRegister+0x18>
80006252:	48 c9       	lddpc	r9,80006280 <ppu_getSpriteDataRegister+0x38>
80006254:	48 ca       	lddpc	r10,80006284 <ppu_getSpriteDataRegister+0x3c>
80006256:	e0 6b 03 4d 	mov	r11,845
8000625a:	48 cc       	lddpc	r12,80006288 <ppu_getSpriteDataRegister+0x40>
8000625c:	f0 1f 00 0c 	mcall	8000628c <ppu_getSpriteDataRegister+0x44>
  PPU ppu = nes_getPPU(nes);
80006260:	f0 1f 00 0c 	mcall	80006290 <ppu_getSpriteDataRegister+0x48>
  assert(ppu != NULL);
80006264:	c0 81       	brne	80006274 <ppu_getSpriteDataRegister+0x2c>
80006266:	48 c9       	lddpc	r9,80006294 <ppu_getSpriteDataRegister+0x4c>
80006268:	48 7a       	lddpc	r10,80006284 <ppu_getSpriteDataRegister+0x3c>
8000626a:	e0 6b 03 4f 	mov	r11,847
8000626e:	48 7c       	lddpc	r12,80006288 <ppu_getSpriteDataRegister+0x40>
80006270:	f0 1f 00 07 	mcall	8000628c <ppu_getSpriteDataRegister+0x44>
  Byte data = nes_readObjectAttributeMemory(nes, ppu->spriteAddressRegister);
80006274:	19 bb       	ld.ub	r11,r12[0x3]
80006276:	0e 9c       	mov	r12,r7
80006278:	f0 1f 00 08 	mcall	80006298 <ppu_getSpriteDataRegister+0x50>
  //reads don't increase this?
  //ppu->spriteAddressRegister++;
  return data;
}
8000627c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006280:	80 01       	ld.sh	r1,r0[0x0]
80006282:	31 44       	mov	r4,20
80006284:	80 01       	ld.sh	r1,r0[0x0]
80006286:	5b 7c       	cp.w	r12,-9
80006288:	80 01       	ld.sh	r1,r0[0x0]
8000628a:	4f 94       	lddpc	r4,8000646c <ppu_step+0x48>
8000628c:	80 00       	ld.sh	r0,r0[0x0]
8000628e:	c1 a0       	breq	800062c2 <ppu_updateScanlineSpriteColour8+0x26>
80006290:	80 00       	ld.sh	r0,r0[0x0]
80006292:	50 48       	stdsp	sp[0x10],r8
80006294:	80 01       	ld.sh	r1,r0[0x0]
80006296:	41 74       	lddsp	r4,sp[0x5c]
80006298:	80 00       	ld.sh	r0,r0[0x0]
8000629a:	53 20       	stdsp	sp[0xc8],r0

8000629c <ppu_updateScanlineSpriteColour8>:
  address += spriteColourIndex;
  Byte systemIndex = nes_readPPUMemory(nes, address);
  return systemIndex;
}
static void ppu_updateScanlineSpriteColour8(NES nes, Byte spriteIndex, Address
basePatternAddress, Byte multiplier) {
8000629c:	d4 31       	pushm	r0-r7,lr
8000629e:	20 3d       	sub	sp,12
800062a0:	18 93       	mov	r3,r12
800062a2:	16 94       	mov	r4,r11
800062a4:	50 0a       	stdsp	sp[0x0],r10
800062a6:	12 91       	mov	r1,r9
  assert(nes != NULL);
800062a8:	58 0c       	cp.w	r12,0
800062aa:	c0 81       	brne	800062ba <ppu_updateScanlineSpriteColour8+0x1e>
800062ac:	4c d9       	lddpc	r9,800063e0 <ppu_updateScanlineSpriteColour8+0x144>
800062ae:	4c ea       	lddpc	r10,800063e4 <ppu_updateScanlineSpriteColour8+0x148>
800062b0:	e0 6b 02 78 	mov	r11,632
800062b4:	4c dc       	lddpc	r12,800063e8 <ppu_updateScanlineSpriteColour8+0x14c>
800062b6:	f0 1f 00 4e 	mcall	800063ec <ppu_updateScanlineSpriteColour8+0x150>
  PPU ppu = nes_getPPU(nes);
800062ba:	f0 1f 00 4e 	mcall	800063f0 <ppu_updateScanlineSpriteColour8+0x154>
800062be:	18 97       	mov	r7,r12
  assert(ppu != NULL);
800062c0:	c0 81       	brne	800062d0 <ppu_updateScanlineSpriteColour8+0x34>
800062c2:	4c d9       	lddpc	r9,800063f4 <ppu_updateScanlineSpriteColour8+0x158>
800062c4:	4c 8a       	lddpc	r10,800063e4 <ppu_updateScanlineSpriteColour8+0x148>
800062c6:	e0 6b 02 7a 	mov	r11,634
800062ca:	4c 8c       	lddpc	r12,800063e8 <ppu_updateScanlineSpriteColour8+0x14c>
800062cc:	f0 1f 00 48 	mcall	800063ec <ppu_updateScanlineSpriteColour8+0x150>
  Memory objectAttributeMemory = nes_getObjectAttributeMemory(nes);
800062d0:	06 9c       	mov	r12,r3
800062d2:	f0 1f 00 4a 	mcall	800063f8 <ppu_updateScanlineSpriteColour8+0x15c>
800062d6:	18 95       	mov	r5,r12
  assert(objectAttributeMemory != NULL);
800062d8:	c0 81       	brne	800062e8 <ppu_updateScanlineSpriteColour8+0x4c>
800062da:	4c 99       	lddpc	r9,800063fc <ppu_updateScanlineSpriteColour8+0x160>
800062dc:	4c 2a       	lddpc	r10,800063e4 <ppu_updateScanlineSpriteColour8+0x148>
800062de:	e0 6b 02 7c 	mov	r11,636
800062e2:	4c 2c       	lddpc	r12,800063e8 <ppu_updateScanlineSpriteColour8+0x14c>
800062e4:	f0 1f 00 42 	mcall	800063ec <ppu_updateScanlineSpriteColour8+0x150>
  Byte screenY = ppu_getCurrentY(ppu);
800062e8:	0e 9c       	mov	r12,r7
800062ea:	f0 1f 00 46 	mcall	80006400 <ppu_updateScanlineSpriteColour8+0x164>
800062ee:	18 96       	mov	r6,r12
  Byte spriteLeftX = objectAttributeMemory_getX(objectAttributeMemory, spriteIndex);
800062f0:	08 9b       	mov	r11,r4
800062f2:	0a 9c       	mov	r12,r5
800062f4:	f0 1f 00 44 	mcall	80006404 <ppu_updateScanlineSpriteColour8+0x168>
800062f8:	50 1c       	stdsp	sp[0x4],r12
  Byte spriteTopY = objectAttributeMemory_getY(objectAttributeMemory, spriteIndex) - 1;
800062fa:	08 9b       	mov	r11,r4
800062fc:	0a 9c       	mov	r12,r5
800062fe:	f0 1f 00 43 	mcall	80006408 <ppu_updateScanlineSpriteColour8+0x16c>
80006302:	f8 c2 00 01 	sub	r2,r12,1
80006306:	5c 52       	castu.b	r2
  int yOffset = 0;
  Bool inRange = FALSE;
  if (screenY >= spriteTopY) {
80006308:	e4 06 18 00 	cp.b	r6,r2
8000630c:	c5 f3       	brcs	800063ca <ppu_updateScanlineSpriteColour8+0x12e>
    yOffset = screenY - spriteTopY;
8000630e:	ec 02 01 02 	sub	r2,r6,r2
80006312:	a3 71       	lsl	r1,0x3
80006314:	04 31       	cp.w	r1,r2
80006316:	5f 96       	srgt	r6
    if (yOffset < (PPU_VERTICAL_PIXELS_PER_TILE*multiplier)) {
      inRange = TRUE;
    }
  }
  Byte y = yOffset;
80006318:	e3 d2 c0 08 	bfextu	r1,r2,0x0,0x8
  Byte patternTileNumber = objectAttributeMemory_getTileNumber(objectAttributeMemory,
8000631c:	30 0a       	mov	r10,0
8000631e:	08 9b       	mov	r11,r4
80006320:	0a 9c       	mov	r12,r5
80006322:	f0 1f 00 3b 	mcall	8000640c <ppu_updateScanlineSpriteColour8+0x170>
80006326:	18 90       	mov	r0,r12
spriteIndex, FALSE);
  if (yOffset >= 8) {
80006328:	58 72       	cp.w	r2,7
8000632a:	e0 8a 00 06 	brle	80006336 <ppu_updateScanlineSpriteColour8+0x9a>
    y = yOffset - 8;
8000632e:	20 81       	sub	r1,8
80006330:	5c 51       	castu.b	r1
    patternTileNumber++;
80006332:	2f f0       	sub	r0,-1
80006334:	5c 50       	castu.b	r0
  }
  if (objectAttributeMemory_isFlippedVertical(objectAttributeMemory, spriteIndex) ==
80006336:	08 9b       	mov	r11,r4
80006338:	0a 9c       	mov	r12,r5
8000633a:	f0 1f 00 36 	mcall	80006410 <ppu_updateScanlineSpriteColour8+0x174>
8000633e:	30 18       	mov	r8,1
80006340:	f0 0c 18 00 	cp.b	r12,r8
80006344:	c0 41       	brne	8000634c <ppu_updateScanlineSpriteColour8+0xb0>
TRUE) {
    y = PPU_VERTICAL_PIXELS_PER_TILE - y - 1;
80006346:	e2 01 11 07 	rsub	r1,r1,7
8000634a:	5c 51       	castu.b	r1
  }
  Byte attributeIndex = objectAttributeMemory_getPalette(objectAttributeMemory,
8000634c:	08 9b       	mov	r11,r4
8000634e:	0a 9c       	mov	r12,r5
80006350:	f0 1f 00 31 	mcall	80006414 <ppu_updateScanlineSpriteColour8+0x178>
80006354:	50 2c       	stdsp	sp[0x8],r12
spriteIndex);
  if (inRange == TRUE) {
80006356:	58 06       	cp.w	r6,0
80006358:	c4 20       	breq	800063dc <ppu_updateScanlineSpriteColour8+0x140>
8000635a:	40 18       	lddsp	r8,sp[0x4]
8000635c:	f0 c6 fe e0 	sub	r6,r8,-288
80006360:	ee 06 00 06 	add	r6,r7,r6
80006364:	30 07       	mov	r7,0
    int i;
    for (i=0; i < PPU_HORIZONTAL_PIXELS_PER_TILE; i++) {
      if (ppu->spriteColoursForScanlineSet[spriteLeftX+i] == FALSE) {
80006366:	30 02       	mov	r2,0
        Byte x = i;
        if (objectAttributeMemory_isFlippedHorizontal(objectAttributeMemory,
spriteIndex) == TRUE) {
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
80006368:	40 08       	lddsp	r8,sp[0x0]
8000636a:	5c 78       	castu.h	r8
8000636c:	50 08       	stdsp	sp[0x0],r8
8000636e:	50 10       	stdsp	sp[0x4],r0
80006370:	02 90       	mov	r0,r1
80006372:	06 91       	mov	r1,r3
80006374:	0a 93       	mov	r3,r5
  Byte attributeIndex = objectAttributeMemory_getPalette(objectAttributeMemory,
spriteIndex);
  if (inRange == TRUE) {
    int i;
    for (i=0; i < PPU_HORIZONTAL_PIXELS_PER_TILE; i++) {
      if (ppu->spriteColoursForScanlineSet[spriteLeftX+i] == FALSE) {
80006376:	0d 88       	ld.ub	r8,r6[0x0]
80006378:	e4 08 18 00 	cp.b	r8,r2
8000637c:	c2 21       	brne	800063c0 <ppu_updateScanlineSpriteColour8+0x124>
8000637e:	0e 95       	mov	r5,r7
80006380:	5c 55       	castu.b	r5
        Byte x = i;
        if (objectAttributeMemory_isFlippedHorizontal(objectAttributeMemory,
80006382:	08 9b       	mov	r11,r4
80006384:	06 9c       	mov	r12,r3
80006386:	f0 1f 00 25 	mcall	80006418 <ppu_updateScanlineSpriteColour8+0x17c>
8000638a:	30 18       	mov	r8,1
8000638c:	f0 0c 18 00 	cp.b	r12,r8
80006390:	c0 41       	brne	80006398 <ppu_updateScanlineSpriteColour8+0xfc>
80006392:	ea 05 11 07 	rsub	r5,r5,7
80006396:	5c 55       	castu.b	r5
spriteIndex) == TRUE) {
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
80006398:	00 98       	mov	r8,r0
8000639a:	0a 99       	mov	r9,r5
8000639c:	40 1a       	lddsp	r10,sp[0x4]
8000639e:	40 0b       	lddsp	r11,sp[0x0]
800063a0:	02 9c       	mov	r12,r1
800063a2:	f0 1f 00 1f 	mcall	8000641c <ppu_updateScanlineSpriteColour8+0x180>
patternTileNumber, x, y);
        if (patternIndex != 0) {
800063a6:	c0 d0       	breq	800063c0 <ppu_updateScanlineSpriteColour8+0x124>
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
800063a8:	40 28       	lddsp	r8,sp[0x8]
800063aa:	10 0c       	add	r12,r8
800063ac:	ed 6c ff 00 	st.b	r6[-256],r12
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
800063b0:	30 18       	mov	r8,1
800063b2:	ac 88       	st.b	r6[0x0],r8
          ppu->spriteColoursForScanlineIsBehindBackground[spriteLeftX +i] =
objectAttributeMemory_isBehindBackground(objectAttributeMemory, spriteIndex);
800063b4:	08 9b       	mov	r11,r4
800063b6:	06 9c       	mov	r12,r3
800063b8:	f0 1f 00 1a 	mcall	80006420 <ppu_updateScanlineSpriteColour8+0x184>
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
          ppu->spriteColoursForScanlineIsBehindBackground[spriteLeftX +i] =
800063bc:	ed 6c 01 00 	st.b	r6[256],r12
  }
  Byte attributeIndex = objectAttributeMemory_getPalette(objectAttributeMemory,
spriteIndex);
  if (inRange == TRUE) {
    int i;
    for (i=0; i < PPU_HORIZONTAL_PIXELS_PER_TILE; i++) {
800063c0:	2f f7       	sub	r7,-1
800063c2:	2f f6       	sub	r6,-1
800063c4:	58 87       	cp.w	r7,8
800063c6:	cd 81       	brne	80006376 <ppu_updateScanlineSpriteColour8+0xda>
800063c8:	c0 a8       	rjmp	800063dc <ppu_updateScanlineSpriteColour8+0x140>
    if (yOffset < (PPU_VERTICAL_PIXELS_PER_TILE*multiplier)) {
      inRange = TRUE;
    }
  }
  Byte y = yOffset;
  Byte patternTileNumber = objectAttributeMemory_getTileNumber(objectAttributeMemory,
800063ca:	30 0a       	mov	r10,0
800063cc:	08 9b       	mov	r11,r4
800063ce:	0a 9c       	mov	r12,r5
800063d0:	f0 1f 00 0f 	mcall	8000640c <ppu_updateScanlineSpriteColour8+0x170>
800063d4:	18 90       	mov	r0,r12
800063d6:	30 06       	mov	r6,0
800063d8:	0c 91       	mov	r1,r6
800063da:	ca eb       	rjmp	80006336 <ppu_updateScanlineSpriteColour8+0x9a>
objectAttributeMemory_isBehindBackground(objectAttributeMemory, spriteIndex);
        }
      }
    }
  }
}
800063dc:	2f dd       	sub	sp,-12
800063de:	d8 32       	popm	r0-r7,pc
800063e0:	80 01       	ld.sh	r1,r0[0x0]
800063e2:	31 44       	mov	r4,20
800063e4:	80 01       	ld.sh	r1,r0[0x0]
800063e6:	59 7c       	cp.w	r12,23
800063e8:	80 01       	ld.sh	r1,r0[0x0]
800063ea:	4f 94       	lddpc	r4,800065cc <ppu_step+0x1a8>
800063ec:	80 00       	ld.sh	r0,r0[0x0]
800063ee:	c1 a0       	breq	80006422 <ppu_updateScanlineSpriteColour8+0x186>
800063f0:	80 00       	ld.sh	r0,r0[0x0]
800063f2:	50 48       	stdsp	sp[0x10],r8
800063f4:	80 01       	ld.sh	r1,r0[0x0]
800063f6:	41 74       	lddsp	r4,sp[0x5c]
800063f8:	80 00       	ld.sh	r0,r0[0x0]
800063fa:	51 28       	stdsp	sp[0x48],r8
800063fc:	80 01       	ld.sh	r1,r0[0x0]
800063fe:	41 54       	lddsp	r4,sp[0x54]
80006400:	80 00       	ld.sh	r0,r0[0x0]
80006402:	5f a8       	srle	r8
80006404:	80 00       	ld.sh	r0,r0[0x0]
80006406:	58 3c       	cp.w	r12,3
80006408:	80 00       	ld.sh	r0,r0[0x0]
8000640a:	59 e4       	cp.w	r4,30
8000640c:	80 00       	ld.sh	r0,r0[0x0]
8000640e:	59 6c       	cp.w	r12,22
80006410:	80 00       	ld.sh	r0,r0[0x0]
80006412:	58 a8       	cp.w	r8,10
80006414:	80 00       	ld.sh	r0,r0[0x0]
80006416:	59 38       	cp.w	r8,19
80006418:	80 00       	ld.sh	r0,r0[0x0]
8000641a:	58 d8       	cp.w	r8,13
8000641c:	80 00       	ld.sh	r0,r0[0x0]
8000641e:	60 94       	ld.w	r4,r0[0x24]
80006420:	80 00       	ld.sh	r0,r0[0x0]
80006422:	59 08       	cp.w	r8,16

80006424 <ppu_step>:
  Colour colour =
colour_init(systemPalette[currentSpriteColour].red,systemPalette[currentSpriteColour].green,systemPalette[currentSpriteColour].blue);
gui_drawPixel(gui,ppu_getCurrentX(ppu),ppu_getCurrentY(ppu),colour_getRed(colour),colour_getGreen(colour),colour_getBlue(colour));
  colour_destroy(colour);
}
void ppu_step(NES nes) {
80006424:	d4 31       	pushm	r0-r7,lr
80006426:	20 4d       	sub	sp,16
80006428:	18 96       	mov	r6,r12
  assert(nes != NULL);
8000642a:	58 0c       	cp.w	r12,0
8000642c:	c0 b1       	brne	80006442 <ppu_step+0x1e>
8000642e:	fe f9 05 ba 	ld.w	r9,pc[1466]
80006432:	fe fa 05 ba 	ld.w	r10,pc[1466]
80006436:	e0 6b 02 f1 	mov	r11,753
8000643a:	fe fc 05 b6 	ld.w	r12,pc[1462]
8000643e:	f0 1f 01 6e 	mcall	800069f4 <ppu_step+0x5d0>
  GUI gui = nes_getGUI(nes);
80006442:	f0 1f 01 6e 	mcall	800069f8 <ppu_step+0x5d4>
80006446:	18 95       	mov	r5,r12
  assert(gui != NULL);
80006448:	c0 b1       	brne	8000645e <ppu_step+0x3a>
8000644a:	fe f9 05 b2 	ld.w	r9,pc[1458]
8000644e:	fe fa 05 9e 	ld.w	r10,pc[1438]
80006452:	e0 6b 02 f3 	mov	r11,755
80006456:	fe fc 05 9a 	ld.w	r12,pc[1434]
8000645a:	f0 1f 01 67 	mcall	800069f4 <ppu_step+0x5d0>
  debug_printf("ppu_step\n");
8000645e:	fe fc 05 a2 	ld.w	r12,pc[1442]
80006462:	f0 1f 01 69 	mcall	80006a04 <ppu_step+0x5e0>
  PPU ppu = nes_getPPU(nes);
80006466:	0c 9c       	mov	r12,r6
80006468:	f0 1f 01 68 	mcall	80006a08 <ppu_step+0x5e4>
8000646c:	18 97       	mov	r7,r12
  assert(ppu != NULL);
8000646e:	c0 b1       	brne	80006484 <ppu_step+0x60>
80006470:	fe f9 05 9c 	ld.w	r9,pc[1436]
80006474:	fe fa 05 78 	ld.w	r10,pc[1400]
80006478:	e0 6b 02 f6 	mov	r11,758
8000647c:	fe fc 05 74 	ld.w	r12,pc[1396]
80006480:	f0 1f 01 5d 	mcall	800069f4 <ppu_step+0x5d0>
  if (ppu->currentCycle == 0) {
80006484:	78 48       	ld.w	r8,r12[0x10]
    ppu->statusRegister = 0; // everything is cleared on line 0
80006486:	58 08       	cp.w	r8,0
80006488:	f9 f8 0e 02 	st.beq	r12[0x2],r8
  }
  if (ppu->currentScanline >=0 && ppu->currentScanline <= 19) {
8000648c:	78 58       	ld.w	r8,r12[0x14]
8000648e:	10 99       	mov	r9,r8
80006490:	59 38       	cp.w	r8,19
80006492:	e0 88 02 46 	brls	8000691e <ppu_step+0x4fa>
    // do nothing, we are in vblank
  } else if (ppu->currentScanline == 20) {
80006496:	59 48       	cp.w	r8,20
80006498:	e0 80 02 43 	breq	8000691e <ppu_step+0x4fa>
    scanline. Other than that, the operation of this scanline is identical to
    any other. The primary reason this scanline exists is to start the object
    render pipeline, since it takes 256 cc's worth of time to determine which
    objects are in range or not for any particular scanline.
    */
  } else if (ppu->currentScanline >= 21 && ppu->currentScanline <= 260) {
8000649c:	21 59       	sub	r9,21
8000649e:	e0 49 00 ef 	cp.w	r9,239
800064a2:	e0 8b 02 34 	brhi	8000690a <ppu_step+0x4e6>
    /*
    21..260: after rendering 1 dummy scanline, the PPU starts to render the
    actual data to be displayed on the screen. This is done for 240 scanlines,
    of course.
    */
    if (ppu->currentScanlineCycle >=0 && ppu->currentScanlineCycle <
800064a6:	78 68       	ld.w	r8,r12[0x18]
800064a8:	e0 48 00 ff 	cp.w	r8,255
800064ac:	e0 8b 02 39 	brhi	8000691e <ppu_step+0x4fa>
  assert(systemColourIndex < PPU_NUM_SYSTEM_COLOURS);
  return systemColourIndex;
}
static void ppu_renderCurrentPixel(NES nes) {
  assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
800064b0:	0c 9c       	mov	r12,r6
800064b2:	f0 1f 01 56 	mcall	80006a08 <ppu_step+0x5e4>
800064b6:	50 0c       	stdsp	sp[0x0],r12
  assert(ppu != NULL);
800064b8:	c0 b1       	brne	800064ce <ppu_step+0xaa>
800064ba:	fe f9 05 52 	ld.w	r9,pc[1362]
800064be:	fe fa 05 52 	ld.w	r10,pc[1362]
800064c2:	e0 6b 02 e3 	mov	r11,739
800064c6:	fe fc 05 2a 	ld.w	r12,pc[1322]
800064ca:	f0 1f 01 4b 	mcall	800069f4 <ppu_step+0x5d0>
  GUI gui = nes_getGUI(nes);
800064ce:	0c 9c       	mov	r12,r6
800064d0:	f0 1f 01 4a 	mcall	800069f8 <ppu_step+0x5d4>
800064d4:	50 2c       	stdsp	sp[0x8],r12
  assert(gui != NULL);
800064d6:	c0 b1       	brne	800064ec <ppu_step+0xc8>
800064d8:	fe f9 05 24 	ld.w	r9,pc[1316]
800064dc:	fe fa 05 34 	ld.w	r10,pc[1332]
800064e0:	e0 6b 02 e5 	mov	r11,741
800064e4:	fe fc 05 0c 	ld.w	r12,pc[1292]
800064e8:	f0 1f 01 43 	mcall	800069f4 <ppu_step+0x5d0>
  if (ppu->currentScanlineCycle == 0) {
800064ec:	40 0a       	lddsp	r10,sp[0x0]
800064ee:	74 68       	ld.w	r8,r10[0x18]
800064f0:	58 08       	cp.w	r8,0
800064f2:	c4 e1       	brne	8000658e <ppu_step+0x16a>
spriteIndex);
  ppu_updateScanlineSpriteColour8(nes, spriteIndex, basePatternAddress, 2);
}
static void ppu_calculateSpriteColoursForCurrentScanline(NES nes) {
  assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
800064f4:	0c 9c       	mov	r12,r6
800064f6:	f0 1f 01 45 	mcall	80006a08 <ppu_step+0x5e4>
800064fa:	18 93       	mov	r3,r12
  assert(ppu != NULL);
800064fc:	c0 b1       	brne	80006512 <ppu_step+0xee>
800064fe:	fe f9 05 0e 	ld.w	r9,pc[1294]
80006502:	fe fa 05 12 	ld.w	r10,pc[1298]
80006506:	e0 6b 02 b7 	mov	r11,695
8000650a:	fe fc 04 e6 	ld.w	r12,pc[1254]
8000650e:	f0 1f 01 3a 	mcall	800069f4 <ppu_step+0x5d0>
  ppu_resetSpriteColoursForScanline(ppu);
80006512:	f0 1f 01 42 	mcall	80006a18 <ppu_step+0x5f4>
  if ( ppu_getMaskSpriteVisibility(ppu) == TRUE) {
80006516:	06 9c       	mov	r12,r3
80006518:	f0 1f 01 41 	mcall	80006a1c <ppu_step+0x5f8>
8000651c:	30 18       	mov	r8,1
8000651e:	f0 0c 18 00 	cp.b	r12,r8
80006522:	c3 61       	brne	8000658e <ppu_step+0x16a>
80006524:	30 04       	mov	r4,0
    Byte spriteIndex;
    for (spriteIndex = 0; spriteIndex < OAM_NUMBER_OF_SPRITES; spriteIndex++) {
      Address basePatternAddress;
      if (ppu_getControlSpriteTileTable(ppu) == FALSE) {
80006526:	e0 60 10 00 	mov	r0,4096
        basePatternAddress = PPU_PATTERN_TABLE_0_FIRST_ADDRESS;
      } else {
        basePatternAddress = PPU_PATTERN_TABLE_1_FIRST_ADDRESS;
      }
      if (ppu_getControlSpriteSize(ppu) == TRUE) {
8000652a:	10 91       	mov	r1,r8
    assert(nes != NULL);
  Memory objectAttributeMemory = nes_getObjectAttributeMemory(nes);
  assert(objectAttributeMemory != NULL);
  Address basePatternAddress = objectAttributeMemory_getBankNumber(objectAttributeMemory,
spriteIndex);
  ppu_updateScanlineSpriteColour8(nes, spriteIndex, basePatternAddress, 2);
8000652c:	0e 92       	mov	r2,r7
  ppu_resetSpriteColoursForScanline(ppu);
  if ( ppu_getMaskSpriteVisibility(ppu) == TRUE) {
    Byte spriteIndex;
    for (spriteIndex = 0; spriteIndex < OAM_NUMBER_OF_SPRITES; spriteIndex++) {
      Address basePatternAddress;
      if (ppu_getControlSpriteTileTable(ppu) == FALSE) {
8000652e:	06 9c       	mov	r12,r3
80006530:	f0 1f 01 3c 	mcall	80006a20 <ppu_step+0x5fc>
80006534:	f9 b7 00 00 	moveq	r7,0
80006538:	e0 07 17 10 	movne	r7,r0
        basePatternAddress = PPU_PATTERN_TABLE_0_FIRST_ADDRESS;
      } else {
        basePatternAddress = PPU_PATTERN_TABLE_1_FIRST_ADDRESS;
      }
      if (ppu_getControlSpriteSize(ppu) == TRUE) {
8000653c:	06 9c       	mov	r12,r3
8000653e:	f0 1f 01 3a 	mcall	80006a24 <ppu_step+0x600>
80006542:	e2 0c 18 00 	cp.b	r12,r1
80006546:	c1 91       	brne	80006578 <ppu_step+0x154>
}
// this is almost a copy paste of ppu_updateScanlineSpriteColour8
// think of a better way
static void ppu_updateScanlineSpriteColour16(NES nes, Byte spriteIndex) {
    assert(nes != NULL);
  Memory objectAttributeMemory = nes_getObjectAttributeMemory(nes);
80006548:	0c 9c       	mov	r12,r6
8000654a:	f0 1f 01 38 	mcall	80006a28 <ppu_step+0x604>
  assert(objectAttributeMemory != NULL);
8000654e:	c0 b1       	brne	80006564 <ppu_step+0x140>
80006550:	fe f9 04 dc 	ld.w	r9,pc[1244]
80006554:	fe fa 04 dc 	ld.w	r10,pc[1244]
80006558:	e0 6b 02 af 	mov	r11,687
8000655c:	fe fc 04 94 	ld.w	r12,pc[1172]
80006560:	f0 1f 01 25 	mcall	800069f4 <ppu_step+0x5d0>
  Address basePatternAddress = objectAttributeMemory_getBankNumber(objectAttributeMemory,
80006564:	08 9b       	mov	r11,r4
80006566:	f0 1f 01 34 	mcall	80006a34 <ppu_step+0x610>
spriteIndex);
  ppu_updateScanlineSpriteColour8(nes, spriteIndex, basePatternAddress, 2);
8000656a:	30 29       	mov	r9,2
8000656c:	18 9a       	mov	r10,r12
8000656e:	08 9b       	mov	r11,r4
80006570:	0c 9c       	mov	r12,r6
80006572:	f0 1f 01 32 	mcall	80006a38 <ppu_step+0x614>
80006576:	c0 78       	rjmp	80006584 <ppu_step+0x160>
        basePatternAddress = PPU_PATTERN_TABLE_1_FIRST_ADDRESS;
      }
      if (ppu_getControlSpriteSize(ppu) == TRUE) {
        ppu_updateScanlineSpriteColour16(nes, spriteIndex);
      } else {
        ppu_updateScanlineSpriteColour8(nes, spriteIndex, basePatternAddress, 1);
80006578:	30 19       	mov	r9,1
8000657a:	0e 9a       	mov	r10,r7
8000657c:	08 9b       	mov	r11,r4
8000657e:	0c 9c       	mov	r12,r6
80006580:	f0 1f 01 2e 	mcall	80006a38 <ppu_step+0x614>
80006584:	2f f4       	sub	r4,-1
  PPU ppu = nes_getPPU(nes);
  assert(ppu != NULL);
  ppu_resetSpriteColoursForScanline(ppu);
  if ( ppu_getMaskSpriteVisibility(ppu) == TRUE) {
    Byte spriteIndex;
    for (spriteIndex = 0; spriteIndex < OAM_NUMBER_OF_SPRITES; spriteIndex++) {
80006586:	e0 44 00 40 	cp.w	r4,64
8000658a:	cd 21       	brne	8000652e <ppu_step+0x10a>
8000658c:	04 97       	mov	r7,r2
  Byte systemIndex = nes_readPPUMemory(nes, address);
  return systemIndex;
}
static Byte ppu_getCurrentBackgroundColour(NES nes) {
  assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
8000658e:	0c 9c       	mov	r12,r6
80006590:	f0 1f 01 1e 	mcall	80006a08 <ppu_step+0x5e4>
80006594:	18 91       	mov	r1,r12
  assert(ppu != NULL);
80006596:	c0 b1       	brne	800065ac <ppu_step+0x188>
80006598:	fe f9 04 74 	ld.w	r9,pc[1140]
8000659c:	fe fa 04 a0 	ld.w	r10,pc[1184]
800065a0:	e0 6b 02 56 	mov	r11,598
800065a4:	fe fc 04 4c 	ld.w	r12,pc[1100]
800065a8:	f0 1f 01 13 	mcall	800069f4 <ppu_step+0x5d0>
  Address basePatternAddress;
  if (ppu_getControlBackgroundTileTable(ppu) == FALSE) {
800065ac:	f0 1f 01 25 	mcall	80006a40 <ppu_step+0x61c>
800065b0:	e0 68 10 00 	mov	r8,4096
800065b4:	f9 b8 00 00 	moveq	r8,0
800065b8:	50 18       	stdsp	sp[0x4],r8
    basePatternAddress = PPU_PATTERN_TABLE_0_FIRST_ADDRESS;
  } else {
    basePatternAddress = PPU_PATTERN_TABLE_1_FIRST_ADDRESS;
  }
  Byte x = ppu_getCurrentX(ppu);
800065ba:	02 9c       	mov	r12,r1
800065bc:	f0 1f 01 22 	mcall	80006a44 <ppu_step+0x620>
800065c0:	50 3c       	stdsp	sp[0xc],r12
  Byte y = ppu_getCurrentY(ppu);
800065c2:	02 9c       	mov	r12,r1
800065c4:	f0 1f 01 21 	mcall	80006a48 <ppu_step+0x624>
800065c8:	18 90       	mov	r0,r12
  Word tileNumber = horizontalOffset + verticalOffset;
  return tileNumber;
}
static Byte ppu_getBackgroundNametableByte(NES nes) {
  assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
800065ca:	0c 9c       	mov	r12,r6
800065cc:	f0 1f 01 0f 	mcall	80006a08 <ppu_step+0x5e4>
800065d0:	18 93       	mov	r3,r12
  assert(ppu != NULL);
800065d2:	c0 b1       	brne	800065e8 <ppu_step+0x1c4>
800065d4:	fe f9 04 38 	ld.w	r9,pc[1080]
800065d8:	fe fa 04 74 	ld.w	r10,pc[1140]
800065dc:	e0 6b 01 e0 	mov	r11,480
800065e0:	fe fc 04 10 	ld.w	r12,pc[1040]
800065e4:	f0 1f 01 04 	mcall	800069f4 <ppu_step+0x5d0>
  Address nametableStart = ppu_getCurrentBaseNametableAddress(ppu);
800065e8:	f0 1f 01 1a 	mcall	80006a50 <ppu_step+0x62c>
800065ec:	e9 dc b0 10 	bfexts	r4,r12,0x0,0x10
  assert(nametableStart == PPU_NAME_TABLE_0_FIRST_ADDRESS ||
800065f0:	e0 68 20 00 	mov	r8,8192
800065f4:	f0 04 19 00 	cp.h	r4,r8
800065f8:	5f 19       	srne	r9
800065fa:	e0 68 24 00 	mov	r8,9216
800065fe:	f0 04 19 00 	cp.h	r4,r8
80006602:	5f 18       	srne	r8
80006604:	f3 e8 00 08 	and	r8,r9,r8
80006608:	c1 80       	breq	80006638 <ppu_step+0x214>
8000660a:	e0 68 28 00 	mov	r8,10240
8000660e:	f0 04 19 00 	cp.h	r4,r8
80006612:	5f 19       	srne	r9
80006614:	e0 68 2c 00 	mov	r8,11264
80006618:	f0 04 19 00 	cp.h	r4,r8
8000661c:	5f 18       	srne	r8
8000661e:	f3 e8 00 08 	and	r8,r9,r8
80006622:	c0 b0       	breq	80006638 <ppu_step+0x214>
80006624:	fe f9 04 30 	ld.w	r9,pc[1072]
80006628:	fe fa 04 24 	ld.w	r10,pc[1060]
8000662c:	e0 6b 01 e5 	mov	r11,485
80006630:	fe fc 03 c0 	ld.w	r12,pc[960]
80006634:	f0 1f 00 f0 	mcall	800069f4 <ppu_step+0x5d0>
         nametableStart == PPU_NAME_TABLE_1_FIRST_ADDRESS ||
         nametableStart == PPU_NAME_TABLE_2_FIRST_ADDRESS ||
         nametableStart == PPU_NAME_TABLE_3_FIRST_ADDRESS);
  Word x = ppu_getCurrentX(ppu);
80006638:	06 9c       	mov	r12,r3
8000663a:	f0 1f 01 03 	mcall	80006a44 <ppu_step+0x620>
8000663e:	18 92       	mov	r2,r12
  Word y = ppu_getCurrentY(ppu);
80006640:	06 9c       	mov	r12,r3
80006642:	f0 1f 01 02 	mcall	80006a48 <ppu_step+0x624>
  Word tileNumber = ppu_getBackgroundTileNumber(x, y);
80006646:	18 9b       	mov	r11,r12
80006648:	04 9c       	mov	r12,r2
8000664a:	f0 1f 01 04 	mcall	80006a58 <ppu_step+0x634>
  Address nametableByteAddress = nametableStart + tileNumber;
8000664e:	f8 04 00 0b 	add	r11,r12,r4
80006652:	5c 8b       	casts.h	r11
  VALIDATE_NAMETABLE_ADDRESS(nametableByteAddress);
80006654:	e0 68 1f ff 	mov	r8,8191
80006658:	f0 0b 19 00 	cp.h	r11,r8
8000665c:	e0 8b 00 0c 	brhi	80006674 <ppu_step+0x250>
80006660:	fe f9 03 fc 	ld.w	r9,pc[1020]
80006664:	fe fa 03 e8 	ld.w	r10,pc[1000]
80006668:	e0 6b 01 ea 	mov	r11,490
8000666c:	fe fc 03 84 	ld.w	r12,pc[900]
80006670:	f0 1f 00 e1 	mcall	800069f4 <ppu_step+0x5d0>
80006674:	e0 68 3e ff 	mov	r8,16127
80006678:	f0 0b 19 00 	cp.h	r11,r8
8000667c:	e0 88 00 0c 	brls	80006694 <ppu_step+0x270>
80006680:	fe f9 03 e0 	ld.w	r9,pc[992]
80006684:	fe fa 03 c8 	ld.w	r10,pc[968]
80006688:	e0 6b 01 ea 	mov	r11,490
8000668c:	fe fc 03 64 	ld.w	r12,pc[868]
80006690:	f0 1f 00 d9 	mcall	800069f4 <ppu_step+0x5d0>
  return nes_readPPUMemory(nes,nametableByteAddress);
80006694:	5c 7b       	castu.h	r11
80006696:	0c 9c       	mov	r12,r6
80006698:	f0 1f 00 f3 	mcall	80006a64 <ppu_step+0x640>
    basePatternAddress = PPU_PATTERN_TABLE_1_FIRST_ADDRESS;
  }
  Byte x = ppu_getCurrentX(ppu);
  Byte y = ppu_getCurrentY(ppu);
  Byte patternTileNumber = ppu_getBackgroundNametableByte(nes);
  Byte patternColourIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
8000669c:	00 98       	mov	r8,r0
8000669e:	40 39       	lddsp	r9,sp[0xc]
800066a0:	18 9a       	mov	r10,r12
800066a2:	40 1b       	lddsp	r11,sp[0x4]
800066a4:	0c 9c       	mov	r12,r6
800066a6:	f0 1f 00 f1 	mcall	80006a68 <ppu_step+0x644>
800066aa:	50 1c       	stdsp	sp[0x4],r12
  Byte attributeByte = nes_readPPUMemory(nes,attributeByteAddress);
  return attributeByte;
}
static Byte ppu_getBackgroundAttributeColourIndex(NES nes) {
  assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
800066ac:	0c 9c       	mov	r12,r6
800066ae:	f0 1f 00 d7 	mcall	80006a08 <ppu_step+0x5e4>
800066b2:	18 92       	mov	r2,r12
  assert(ppu != NULL);
800066b4:	c0 b1       	brne	800066ca <ppu_step+0x2a6>
800066b6:	fe f9 03 56 	ld.w	r9,pc[854]
800066ba:	fe fa 03 b2 	ld.w	r10,pc[946]
800066be:	e0 6b 02 24 	mov	r11,548
800066c2:	fe fc 03 2e 	ld.w	r12,pc[814]
800066c6:	f0 1f 00 cc 	mcall	800069f4 <ppu_step+0x5d0>
  Address patternIndex = ppu_combinePatternBytes(ppu, pattern1, pattern2, x);
  return patternIndex;
}
static Byte ppu_getBackgroundAttributeByte(NES nes) {
  assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
800066ca:	0c 9c       	mov	r12,r6
800066cc:	f0 1f 00 cf 	mcall	80006a08 <ppu_step+0x5e4>
800066d0:	18 93       	mov	r3,r12
  assert(ppu != NULL);
800066d2:	c0 b1       	brne	800066e8 <ppu_step+0x2c4>
800066d4:	fe f9 03 38 	ld.w	r9,pc[824]
800066d8:	fe fa 03 98 	ld.w	r10,pc[920]
800066dc:	e0 6b 02 0a 	mov	r11,522
800066e0:	fe fc 03 10 	ld.w	r12,pc[784]
800066e4:	f0 1f 00 c4 	mcall	800069f4 <ppu_step+0x5d0>
  Address nametableStart = ppu_getCurrentBaseNametableAddress(ppu);
800066e8:	f0 1f 00 da 	mcall	80006a50 <ppu_step+0x62c>
800066ec:	e9 dc b0 10 	bfexts	r4,r12,0x0,0x10
  assert(nametableStart == PPU_NAME_TABLE_0_FIRST_ADDRESS ||
800066f0:	e0 68 20 00 	mov	r8,8192
800066f4:	f0 04 19 00 	cp.h	r4,r8
800066f8:	5f 19       	srne	r9
800066fa:	e0 68 24 00 	mov	r8,9216
800066fe:	f0 04 19 00 	cp.h	r4,r8
80006702:	5f 18       	srne	r8
80006704:	f3 e8 00 08 	and	r8,r9,r8
80006708:	c1 80       	breq	80006738 <ppu_step+0x314>
8000670a:	e0 68 28 00 	mov	r8,10240
8000670e:	f0 04 19 00 	cp.h	r4,r8
80006712:	5f 19       	srne	r9
80006714:	e0 68 2c 00 	mov	r8,11264
80006718:	f0 04 19 00 	cp.h	r4,r8
8000671c:	5f 18       	srne	r8
8000671e:	f3 e8 00 08 	and	r8,r9,r8
80006722:	c0 b0       	breq	80006738 <ppu_step+0x314>
80006724:	fe f9 03 30 	ld.w	r9,pc[816]
80006728:	fe fa 03 48 	ld.w	r10,pc[840]
8000672c:	e0 6b 02 0f 	mov	r11,527
80006730:	fe fc 02 c0 	ld.w	r12,pc[704]
80006734:	f0 1f 00 b0 	mcall	800069f4 <ppu_step+0x5d0>
         nametableStart == PPU_NAME_TABLE_1_FIRST_ADDRESS ||
         nametableStart == PPU_NAME_TABLE_2_FIRST_ADDRESS ||
         nametableStart == PPU_NAME_TABLE_3_FIRST_ADDRESS);
  Word x = ppu_getCurrentX(ppu);
80006738:	06 9c       	mov	r12,r3
8000673a:	f0 1f 00 c3 	mcall	80006a44 <ppu_step+0x620>
8000673e:	18 90       	mov	r0,r12
  Word y = ppu_getCurrentY(ppu);
80006740:	06 9c       	mov	r12,r3
80006742:	f0 1f 00 c2 	mcall	80006a48 <ppu_step+0x624>
  assert(PPU_NAMETABLE_BYTES_BEFORE_ATTRIBUTE_TABLE == 960);
  Address attributetableStart = nametableStart +
PPU_NAMETABLE_BYTES_BEFORE_ATTRIBUTE_TABLE;
  Word tileNumber = ppu_getBackgroundTileNumber(x, y);
80006746:	18 9b       	mov	r11,r12
80006748:	00 9c       	mov	r12,r0
8000674a:	f0 1f 00 c4 	mcall	80006a58 <ppu_step+0x634>
8000674e:	5c 8c       	casts.h	r12
  Word tileColumnNumber = tileNumber % PPU_BACKGROUND_TILES_PER_ROW;
  Word horizontalOffset = (tileColumnNumber / PPU_HORIZONTAL_TILES_PER_ATTRIBUTE_BYTE);
  Word verticalOffset = (tileRowNumber / PPU_VERTICAL_TILES_PER_ATTRIBUTE_BYTE) *
PPU_ATTRIBUTE_BYTES_PER_ROW;
  Address attributeByteAddress = attributetableStart + horizontalOffset +
verticalOffset;
80006750:	e8 cb fc 40 	sub	r11,r4,-960
80006754:	f1 dc c0 43 	bfextu	r8,r12,0x2,0x3
80006758:	10 0b       	add	r11,r8
8000675a:	f9 dc c0 e9 	bfextu	r12,r12,0x7,0x9
8000675e:	a3 7c       	lsl	r12,0x3
80006760:	18 0b       	add	r11,r12
80006762:	5c 8b       	casts.h	r11
  VALIDATE_NAMETABLE_ADDRESS(attributeByteAddress);
80006764:	e0 68 1f ff 	mov	r8,8191
80006768:	f0 0b 19 00 	cp.h	r11,r8
8000676c:	e0 8b 00 0c 	brhi	80006784 <ppu_step+0x360>
80006770:	fe f9 03 04 	ld.w	r9,pc[772]
80006774:	fe fa 02 fc 	ld.w	r10,pc[764]
80006778:	e0 6b 02 1d 	mov	r11,541
8000677c:	fe fc 02 74 	ld.w	r12,pc[628]
80006780:	f0 1f 00 9d 	mcall	800069f4 <ppu_step+0x5d0>
80006784:	e0 68 3e ff 	mov	r8,16127
80006788:	f0 0b 19 00 	cp.h	r11,r8
8000678c:	e0 88 00 0c 	brls	800067a4 <ppu_step+0x380>
80006790:	fe f9 02 e8 	ld.w	r9,pc[744]
80006794:	fe fa 02 dc 	ld.w	r10,pc[732]
80006798:	e0 6b 02 1d 	mov	r11,541
8000679c:	fe fc 02 54 	ld.w	r12,pc[596]
800067a0:	f0 1f 00 95 	mcall	800069f4 <ppu_step+0x5d0>
  Byte attributeByte = nes_readPPUMemory(nes,attributeByteAddress);
800067a4:	5c 7b       	castu.h	r11
800067a6:	0c 9c       	mov	r12,r6
800067a8:	f0 1f 00 af 	mcall	80006a64 <ppu_step+0x640>
800067ac:	18 94       	mov	r4,r12
static Byte ppu_getBackgroundAttributeColourIndex(NES nes) {
  assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
  assert(ppu != NULL);
  Byte attributeByte = ppu_getBackgroundAttributeByte(nes);
  Word x = ppu_getCurrentX(ppu);
800067ae:	04 9c       	mov	r12,r2
800067b0:	f0 1f 00 a5 	mcall	80006a44 <ppu_step+0x620>
800067b4:	18 93       	mov	r3,r12
  Word y = ppu_getCurrentY(ppu);
800067b6:	04 9c       	mov	r12,r2
800067b8:	f0 1f 00 a4 	mcall	80006a48 <ppu_step+0x624>
  Word tileNumber = ppu_getBackgroundTileNumber(x, y);
800067bc:	18 9b       	mov	r11,r12
800067be:	06 9c       	mov	r12,r3
800067c0:	f0 1f 00 a6 	mcall	80006a58 <ppu_step+0x634>
  Word horizontalOffset = (tileNumber % PPU_HORIZONTAL_TILES_PER_ATTRIBUTE_BYTE);
  Word tileRowNumber = (tileNumber / PPU_BACKGROUND_TILES_PER_ROW);
  Word verticalOffset = (tileRowNumber % PPU_VERTICAL_TILES_PER_ATTRIBUTE_BYTE);
  int attributeTileNumber = attributeTableLookup[verticalOffset][horizontalOffset];
  Byte attributeColourIndex = 0;
  switch(attributeTileNumber) {
800067c4:	5c 7c       	castu.h	r12
800067c6:	f1 dc c0 02 	bfextu	r8,r12,0x0,0x2
800067ca:	f9 dc c0 a2 	bfextu	r12,r12,0x5,0x2
800067ce:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800067d2:	fe f8 02 aa 	ld.w	r8,pc[682]
800067d6:	f0 0c 07 08 	ld.ub	r8,r8[r12]
800067da:	58 f8       	cp.w	r8,15
800067dc:	e0 8b 00 06 	brhi	800067e8 <ppu_step+0x3c4>
800067e0:	fe f9 02 a0 	ld.w	r9,pc[672]
800067e4:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
800067e8:	30 04       	mov	r4,0
800067ea:	c0 98       	rjmp	800067fc <ppu_step+0x3d8>
    case 0x0:
    case 0x1:
    case 0x2:
    case 0x3:
      attributeColourIndex = (attributeByte << 6 );
800067ec:	a7 64       	lsl	r4,0x6
800067ee:	5c 54       	castu.b	r4
800067f0:	c0 68       	rjmp	800067fc <ppu_step+0x3d8>
      break;
    case 0x4:
    case 0x5:
    case 0x6:
    case 0x7:
      attributeColourIndex = (attributeByte << 4 );
800067f2:	a5 64       	lsl	r4,0x4
800067f4:	5c 54       	castu.b	r4
800067f6:	c0 38       	rjmp	800067fc <ppu_step+0x3d8>
      break;
    case 0x8:
    case 0x9:
    case 0xA:
    case 0xB:
      attributeColourIndex = (attributeByte << 2 );
800067f8:	a3 64       	lsl	r4,0x2
800067fa:	5c 54       	castu.b	r4
  Byte patternColourIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
  Byte attributeColourIndex = ppu_getBackgroundAttributeColourIndex(nes);
  Byte backgroundColourIndex = 0;
  // if transparent, use the background colour
  if (patternColourIndex == 0) {
800067fc:	40 19       	lddsp	r9,sp[0x4]
800067fe:	58 09       	cp.w	r9,0
80006800:	c0 31       	brne	80006806 <ppu_step+0x3e2>
80006802:	30 03       	mov	r3,0
80006804:	c0 78       	rjmp	80006812 <ppu_step+0x3ee>
    backgroundColourIndex = 0;
  } else {
    backgroundColourIndex = patternColourIndex + attributeColourIndex ;
80006806:	e8 03 16 06 	lsr	r3,r4,0x6
8000680a:	40 18       	lddsp	r8,sp[0x4]
8000680c:	f0 03 00 23 	add	r3,r8,r3<<0x2
80006810:	5c 53       	castu.b	r3
  }
  if (ppu_getMaskBackgroundVisibility(ppu) == FALSE) {
80006812:	02 9c       	mov	r12,r1
80006814:	f0 1f 00 9c 	mcall	80006a84 <ppu_step+0x660>
80006818:	f9 b3 00 00 	moveq	r3,0
    }
  }
}
static Byte ppu_getCurrentSpriteColour(NES nes, Byte currentBackgroundColour) {
  assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
8000681c:	0c 9c       	mov	r12,r6
8000681e:	f0 1f 00 7b 	mcall	80006a08 <ppu_step+0x5e4>
80006822:	18 94       	mov	r4,r12
  assert(ppu != NULL);
80006824:	c0 91       	brne	80006836 <ppu_step+0x412>
80006826:	4f a9       	lddpc	r9,80006a0c <ppu_step+0x5e8>
80006828:	fe fa 02 60 	ld.w	r10,pc[608]
8000682c:	e0 6b 02 cd 	mov	r11,717
80006830:	4f 0c       	lddpc	r12,800069f0 <ppu_step+0x5cc>
80006832:	f0 1f 00 71 	mcall	800069f4 <ppu_step+0x5d0>
  assert(gui != NULL);
  if (ppu->currentScanlineCycle == 0) {
    ppu_calculateSpriteColoursForCurrentScanline(nes);
  }
  Byte currentBackgroundColour = ppu_getCurrentBackgroundColour(nes);
  Byte currentSpriteColour = ppu_getCurrentSpriteColour(nes, currentBackgroundColour);
80006836:	06 92       	mov	r2,r3
}
static Byte ppu_getCurrentSpriteColour(NES nes, Byte currentBackgroundColour) {
  assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
  assert(ppu != NULL);
  Byte screenX = ppu_getCurrentX(ppu);
80006838:	f0 1f 00 83 	mcall	80006a44 <ppu_step+0x620>
  Byte systemColourIndex = 0;
  if (ppu->spriteColoursForScanlineSet[screenX] == FALSE) {
8000683c:	18 93       	mov	r3,r12
8000683e:	e8 0c 00 08 	add	r8,r4,r12
80006842:	f1 39 01 20 	ld.ub	r9,r8[288]
80006846:	30 08       	mov	r8,0
80006848:	f0 09 18 00 	cp.b	r9,r8
8000684c:	c0 71       	brne	8000685a <ppu_step+0x436>
    systemColourIndex = ppu_getSystemIndexFromBackgroundIndex(nes,
8000684e:	04 9b       	mov	r11,r2
80006850:	0c 9c       	mov	r12,r6
80006852:	f0 1f 00 8f 	mcall	80006a8c <ppu_step+0x668>
80006856:	18 93       	mov	r3,r12
80006858:	c2 38       	rjmp	8000689e <ppu_step+0x47a>
currentBackgroundColour);
             //one of the lower two bits set
  } else if ((ppu->spriteColoursForScanlineIsBehindBackground[screenX] == TRUE) &&
8000685a:	e8 0c 00 08 	add	r8,r4,r12
8000685e:	f1 39 02 20 	ld.ub	r9,r8[544]
80006862:	30 18       	mov	r8,1
80006864:	f0 09 18 00 	cp.b	r9,r8
80006868:	c0 e1       	brne	80006884 <ppu_step+0x460>
8000686a:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
8000686e:	c0 b0       	breq	80006884 <ppu_step+0x460>
(currentBackgroundColour % 4 != 0)) {
    systemColourIndex = ppu_getSystemIndexFromBackgroundIndex(nes,
80006870:	04 9b       	mov	r11,r2
80006872:	0c 9c       	mov	r12,r6
80006874:	f0 1f 00 86 	mcall	80006a8c <ppu_step+0x668>
80006878:	18 93       	mov	r3,r12
currentBackgroundColour);
    ppu_setStatusSpriteCollisionHit(ppu, TRUE);
8000687a:	30 1b       	mov	r11,1
8000687c:	08 9c       	mov	r12,r4
8000687e:	f0 1f 00 85 	mcall	80006a90 <ppu_step+0x66c>
80006882:	c0 e8       	rjmp	8000689e <ppu_step+0x47a>
  } else {
    ppu_setStatusSpriteCollisionHit(ppu, TRUE);
80006884:	30 1b       	mov	r11,1
80006886:	08 9c       	mov	r12,r4
80006888:	f0 1f 00 82 	mcall	80006a90 <ppu_step+0x66c>
}
static Byte ppu_getSystemIndexFromSpriteIndex(NES nes, Byte spriteColourIndex) {
  assert(nes != NULL);
  Address address = PPU_SPRITE_PALETTE_FIRST_ADDRESS;
  address += spriteColourIndex;
  Byte systemIndex = nes_readPPUMemory(nes, address);
8000688c:	06 04       	add	r4,r3
8000688e:	e9 3b 00 20 	ld.ub	r11,r4[32]
80006892:	f6 cb c0 f0 	sub	r11,r11,-16144
80006896:	0c 9c       	mov	r12,r6
80006898:	f0 1f 00 73 	mcall	80006a64 <ppu_step+0x640>
8000689c:	18 93       	mov	r3,r12
    ppu_setStatusSpriteCollisionHit(ppu, TRUE);
  } else {
    ppu_setStatusSpriteCollisionHit(ppu, TRUE);
    systemColourIndex = ppu_getSystemIndexFromSpriteIndex(nes, ppu->spriteColoursForScanline[screenX]);
  }
  assert(systemColourIndex < PPU_NUM_SYSTEM_COLOURS);
8000689e:	33 f8       	mov	r8,63
800068a0:	f0 03 18 00 	cp.b	r3,r8
800068a4:	e0 88 00 09 	brls	800068b6 <ppu_step+0x492>
800068a8:	4f b9       	lddpc	r9,80006a94 <ppu_step+0x670>
800068aa:	4f 8a       	lddpc	r10,80006a88 <ppu_step+0x664>
800068ac:	e0 6b 02 dd 	mov	r11,733
800068b0:	4d 0c       	lddpc	r12,800069f0 <ppu_step+0x5cc>
800068b2:	f0 1f 00 51 	mcall	800069f4 <ppu_step+0x5d0>
    ppu_calculateSpriteColoursForCurrentScanline(nes);
  }
  Byte currentBackgroundColour = ppu_getCurrentBackgroundColour(nes);
  Byte currentSpriteColour = ppu_getCurrentSpriteColour(nes, currentBackgroundColour);
  Colour colour =
colour_init(systemPalette[currentSpriteColour].red,systemPalette[currentSpriteColour].green,systemPalette[currentSpriteColour].blue);
800068b6:	e6 03 00 13 	add	r3,r3,r3<<0x1
800068ba:	4f 88       	lddpc	r8,80006a98 <ppu_step+0x674>
800068bc:	f0 03 00 03 	add	r3,r8,r3
800068c0:	07 aa       	ld.ub	r10,r3[0x2]
800068c2:	07 9b       	ld.ub	r11,r3[0x1]
800068c4:	07 8c       	ld.ub	r12,r3[0x0]
800068c6:	f0 1f 00 76 	mcall	80006a9c <ppu_step+0x678>
800068ca:	18 94       	mov	r4,r12
gui_drawPixel(gui,ppu_getCurrentX(ppu),ppu_getCurrentY(ppu),colour_getRed(colour),colour_getGreen(colour),colour_getBlue(colour));
800068cc:	f0 1f 00 75 	mcall	80006aa0 <ppu_step+0x67c>
800068d0:	18 93       	mov	r3,r12
800068d2:	08 9c       	mov	r12,r4
800068d4:	f0 1f 00 74 	mcall	80006aa4 <ppu_step+0x680>
800068d8:	18 92       	mov	r2,r12
800068da:	08 9c       	mov	r12,r4
800068dc:	f0 1f 00 73 	mcall	80006aa8 <ppu_step+0x684>
800068e0:	18 91       	mov	r1,r12
800068e2:	40 0c       	lddsp	r12,sp[0x0]
800068e4:	f0 1f 00 59 	mcall	80006a48 <ppu_step+0x624>
800068e8:	18 90       	mov	r0,r12
800068ea:	40 0c       	lddsp	r12,sp[0x0]
800068ec:	f0 1f 00 56 	mcall	80006a44 <ppu_step+0x620>
800068f0:	1a d3       	st.w	--sp,r3
800068f2:	04 98       	mov	r8,r2
800068f4:	02 99       	mov	r9,r1
800068f6:	00 9a       	mov	r10,r0
800068f8:	18 9b       	mov	r11,r12
800068fa:	40 3c       	lddsp	r12,sp[0xc]
800068fc:	f0 1f 00 6c 	mcall	80006aac <ppu_step+0x688>
  colour_destroy(colour);
80006900:	08 9c       	mov	r12,r4
80006902:	f0 1f 00 6c 	mcall	80006ab0 <ppu_step+0x68c>
80006906:	2f fd       	sub	sp,-4
80006908:	c0 b8       	rjmp	8000691e <ppu_step+0x4fa>
    */
    if (ppu->currentScanlineCycle >=0 && ppu->currentScanlineCycle <
PPU_SCREEN_WIDTH_IN_PIXELS) {
      ppu_renderCurrentPixel(nes);
    }
  } else if (ppu->currentScanline == 261) {
8000690a:	e0 48 01 05 	cp.w	r8,261
8000690e:	c0 80       	breq	8000691e <ppu_step+0x4fa>
    for 1 scanline (i.e. the programmer gets screwed out of perfectly good VINT
    time). When this scanline finishes, the VINT flag is set, and the process of
    drawing lines starts all over again.
    */
  } else {
    assert(FALSE);
80006910:	4e 99       	lddpc	r9,80006ab4 <ppu_step+0x690>
80006912:	4b 7a       	lddpc	r10,800069ec <ppu_step+0x5c8>
80006914:	e0 6b 03 1c 	mov	r11,796
80006918:	4b 6c       	lddpc	r12,800069f0 <ppu_step+0x5cc>
8000691a:	f0 1f 00 37 	mcall	800069f4 <ppu_step+0x5d0>
  }
  ppu->currentCycle++;
8000691e:	6e 48       	ld.w	r8,r7[0x10]
80006920:	2f f8       	sub	r8,-1
80006922:	8f 48       	st.w	r7[0x10],r8
  ppu->currentScanlineCycle++;
80006924:	6e 69       	ld.w	r9,r7[0x18]
80006926:	2f f9       	sub	r9,-1
80006928:	8f 69       	st.w	r7[0x18],r9
  if (ppu->currentCycle % PPU_CYCLES_PER_SCANLINE == 0) {
8000692a:	e0 6b 03 01 	mov	r11,769
8000692e:	ea 1b 30 0c 	orh	r11,0x300c
80006932:	f0 0b 04 4a 	muls.d	r10,r8,r11
80006936:	f6 09 14 06 	asr	r9,r11,0x6
8000693a:	f0 0a 14 1f 	asr	r10,r8,0x1f
8000693e:	14 19       	sub	r9,r10
80006940:	e0 6a 01 55 	mov	r10,341
80006944:	b5 39       	mul	r9,r10
80006946:	f0 09 01 09 	sub	r9,r8,r9
8000694a:	c4 c1       	brne	800069e2 <ppu_step+0x5be>
    ppu->currentScanline++;
8000694c:	6e 59       	ld.w	r9,r7[0x14]
8000694e:	2f f9       	sub	r9,-1
80006950:	8f 59       	st.w	r7[0x14],r9
    ppu->currentScanlineCycle = 0;
80006952:	30 0a       	mov	r10,0
80006954:	8f 6a       	st.w	r7[0x18],r10
    if (ppu->currentScanline == 20) {
80006956:	59 49       	cp.w	r9,20
80006958:	c1 81       	brne	80006988 <ppu_step+0x564>
      // The VBL flag is cleared 6820 PPU clocks, or exactly 20 scanlines, after it isset.
      assert(ppu->currentCycle == 6820);
8000695a:	e0 48 1a a4 	cp.w	r8,6820
8000695e:	c0 80       	breq	8000696e <ppu_step+0x54a>
80006960:	4d 69       	lddpc	r9,80006ab8 <ppu_step+0x694>
80006962:	4a 3a       	lddpc	r10,800069ec <ppu_step+0x5c8>
80006964:	e0 6b 03 25 	mov	r11,805
80006968:	4a 2c       	lddpc	r12,800069f0 <ppu_step+0x5cc>
8000696a:	f0 1f 00 23 	mcall	800069f4 <ppu_step+0x5d0>
      ppu_setStatusSpriteOverflow(ppu, FALSE);
8000696e:	30 0b       	mov	r11,0
80006970:	0e 9c       	mov	r12,r7
80006972:	f0 1f 00 53 	mcall	80006abc <ppu_step+0x698>
      ppu_setStatusSpriteCollisionHit(ppu, FALSE);
80006976:	30 0b       	mov	r11,0
80006978:	0e 9c       	mov	r12,r7
8000697a:	f0 1f 00 46 	mcall	80006a90 <ppu_step+0x66c>
      ppu_setStatusVerticalBlank(ppu, FALSE);
8000697e:	30 0b       	mov	r11,0
80006980:	0e 9c       	mov	r12,r7
80006982:	f0 1f 00 50 	mcall	80006ac0 <ppu_step+0x69c>
80006986:	c2 e8       	rjmp	800069e2 <ppu_step+0x5be>
    } else if (ppu->currentScanline % PPU_SCANLINES_PER_FRAME == 0) {
80006988:	e0 6b cb 3d 	mov	r11,52029
8000698c:	ea 1b 3e 88 	orh	r11,0x3e88
80006990:	f2 0b 04 4a 	muls.d	r10,r9,r11
80006994:	f6 08 14 06 	asr	r8,r11,0x6
80006998:	f2 0a 14 1f 	asr	r10,r9,0x1f
8000699c:	14 18       	sub	r8,r10
8000699e:	e0 6a 01 06 	mov	r10,262
800069a2:	b5 38       	mul	r8,r10
800069a4:	10 19       	sub	r9,r8
800069a6:	c1 e1       	brne	800069e2 <ppu_step+0x5be>
      // $2002.5 and $2002.6 after being set, stay that way for the first 20
      // scanlines of the new frame, relative to the VINT.
      ppu_setStatusVerticalBlank(ppu, TRUE);
800069a8:	30 1b       	mov	r11,1
800069aa:	0e 9c       	mov	r12,r7
800069ac:	f0 1f 00 45 	mcall	80006ac0 <ppu_step+0x69c>
      ppu->currentCycle = 0;
800069b0:	30 08       	mov	r8,0
800069b2:	8f 48       	st.w	r7[0x10],r8
      ppu->currentScanline = 0;
800069b4:	8f 58       	st.w	r7[0x14],r8
      ppu->currentFrame++;
800069b6:	6e 78       	ld.w	r8,r7[0x1c]
800069b8:	2f f8       	sub	r8,-1
800069ba:	8f 78       	st.w	r7[0x1c],r8
      gui_refresh(gui);
800069bc:	0a 9c       	mov	r12,r5
800069be:	f0 1f 00 42 	mcall	80006ac4 <ppu_step+0x6a0>
      printf("Frame: %d\n", ppu->currentFrame);
800069c2:	6e 78       	ld.w	r8,r7[0x1c]
800069c4:	1a d8       	st.w	--sp,r8
800069c6:	4c 1c       	lddpc	r12,80006ac8 <ppu_step+0x6a4>
800069c8:	f0 1f 00 41 	mcall	80006acc <ppu_step+0x6a8>
      if (ppu_getControlNMI(ppu) == TRUE) {
800069cc:	0e 9c       	mov	r12,r7
800069ce:	f0 1f 00 41 	mcall	80006ad0 <ppu_step+0x6ac>
800069d2:	2f fd       	sub	sp,-4
800069d4:	30 18       	mov	r8,1
800069d6:	f0 0c 18 00 	cp.b	r12,r8
800069da:	c0 41       	brne	800069e2 <ppu_step+0x5be>
        nes_generateNMI(nes);
800069dc:	0c 9c       	mov	r12,r6
800069de:	f0 1f 00 3e 	mcall	80006ad4 <ppu_step+0x6b0>
      }
    }
  }
}
800069e2:	2f cd       	sub	sp,-16
800069e4:	d8 32       	popm	r0-r7,pc
800069e6:	00 00       	add	r0,r0
800069e8:	80 01       	ld.sh	r1,r0[0x0]
800069ea:	31 44       	mov	r4,20
800069ec:	80 01       	ld.sh	r1,r0[0x0]
800069ee:	59 70       	cp.w	r0,23
800069f0:	80 01       	ld.sh	r1,r0[0x0]
800069f2:	4f 94       	lddpc	r4,80006bd4 <ppuMemory_init+0x88>
800069f4:	80 00       	ld.sh	r0,r0[0x0]
800069f6:	c1 a0       	breq	80006a2a <ppu_step+0x606>
800069f8:	80 00       	ld.sh	r0,r0[0x0]
800069fa:	50 e8       	stdsp	sp[0x38],r8
800069fc:	80 01       	ld.sh	r1,r0[0x0]
800069fe:	43 44       	lddsp	r4,sp[0xd0]
80006a00:	80 01       	ld.sh	r1,r0[0x0]
80006a02:	4f bc       	lddpc	r12,80006bec <ppuMemory_init+0xa0>
80006a04:	80 00       	ld.sh	r0,r0[0x0]
80006a06:	43 cc       	lddsp	r12,sp[0xf0]
80006a08:	80 00       	ld.sh	r0,r0[0x0]
80006a0a:	50 48       	stdsp	sp[0x10],r8
80006a0c:	80 01       	ld.sh	r1,r0[0x0]
80006a0e:	41 74       	lddsp	r4,sp[0x5c]
80006a10:	80 01       	ld.sh	r1,r0[0x0]
80006a12:	58 ec       	cp.w	r12,14
80006a14:	80 01       	ld.sh	r1,r0[0x0]
80006a16:	5a 90       	cp.w	r0,-23
80006a18:	80 00       	ld.sh	r0,r0[0x0]
80006a1a:	5f 08       	sreq	r8
80006a1c:	80 00       	ld.sh	r0,r0[0x0]
80006a1e:	5c c4       	swap.bh	r4
80006a20:	80 00       	ld.sh	r0,r0[0x0]
80006a22:	5b e8       	cp.w	r8,-2
80006a24:	80 00       	ld.sh	r0,r0[0x0]
80006a26:	5c 40       	abs	r0
80006a28:	80 00       	ld.sh	r0,r0[0x0]
80006a2a:	51 28       	stdsp	sp[0x48],r8
80006a2c:	80 01       	ld.sh	r1,r0[0x0]
80006a2e:	41 54       	lddsp	r4,sp[0x54]
80006a30:	80 01       	ld.sh	r1,r0[0x0]
80006a32:	4f 3c       	lddpc	r12,80006bfc <ppuMemory_init+0xb0>
80006a34:	80 00       	ld.sh	r0,r0[0x0]
80006a36:	59 ac       	cp.w	r12,26
80006a38:	80 00       	ld.sh	r0,r0[0x0]
80006a3a:	62 9c       	ld.w	r12,r1[0x24]
80006a3c:	80 01       	ld.sh	r1,r0[0x0]
80006a3e:	5a e0       	cp.w	r0,-18
80006a40:	80 00       	ld.sh	r0,r0[0x0]
80006a42:	5c 14       	scr	r4
80006a44:	80 00       	ld.sh	r0,r0[0x0]
80006a46:	5f d4       	srvc	r4
80006a48:	80 00       	ld.sh	r0,r0[0x0]
80006a4a:	5f a8       	srle	r8
80006a4c:	80 01       	ld.sh	r1,r0[0x0]
80006a4e:	59 1c       	cp.w	r12,17
80006a50:	80 00       	ld.sh	r0,r0[0x0]
80006a52:	5f 48       	srge	r8
80006a54:	80 01       	ld.sh	r1,r0[0x0]
80006a56:	4f c8       	lddpc	r8,80006c44 <ppuMemory_paletteMirror_getLowestAddress+0x20>
80006a58:	80 00       	ld.sh	r0,r0[0x0]
80006a5a:	5a 48       	cp.w	r8,-28
80006a5c:	80 01       	ld.sh	r1,r0[0x0]
80006a5e:	50 98       	stdsp	sp[0x24],r8
80006a60:	80 01       	ld.sh	r1,r0[0x0]
80006a62:	50 d0       	stdsp	sp[0x34],r0
80006a64:	80 00       	ld.sh	r0,r0[0x0]
80006a66:	52 c8       	stdsp	sp[0xb0],r8
80006a68:	80 00       	ld.sh	r0,r0[0x0]
80006a6a:	60 94       	ld.w	r4,r0[0x24]
80006a6c:	80 01       	ld.sh	r1,r0[0x0]
80006a6e:	5b bc       	cp.w	r12,-5
80006a70:	80 01       	ld.sh	r1,r0[0x0]
80006a72:	59 bc       	cp.w	r12,27
80006a74:	80 01       	ld.sh	r1,r0[0x0]
80006a76:	51 0c       	stdsp	sp[0x40],r12
80006a78:	80 01       	ld.sh	r1,r0[0x0]
80006a7a:	51 44       	stdsp	sp[0x50],r4
80006a7c:	00 00       	add	r0,r0
80006a7e:	00 10       	sub	r0,r0
80006a80:	80 01       	ld.sh	r1,r0[0x0]
80006a82:	4e b0       	lddpc	r0,80006c2c <ppuMemory_paletteMirror_getLowestAddress+0x8>
80006a84:	80 00       	ld.sh	r0,r0[0x0]
80006a86:	5c 98       	brev	r8
80006a88:	80 01       	ld.sh	r1,r0[0x0]
80006a8a:	58 5c       	cp.w	r12,5
80006a8c:	80 00       	ld.sh	r0,r0[0x0]
80006a8e:	61 44       	ld.w	r4,r0[0x50]
80006a90:	80 00       	ld.sh	r0,r0[0x0]
80006a92:	5a e4       	cp.w	r4,-18
80006a94:	80 01       	ld.sh	r1,r0[0x0]
80006a96:	51 80       	stdsp	sp[0x60],r0
80006a98:	00 00       	add	r0,r0
80006a9a:	00 20       	rsub	r0,r0
80006a9c:	80 00       	ld.sh	r0,r0[0x0]
80006a9e:	27 74       	sub	r4,119
80006aa0:	80 00       	ld.sh	r0,r0[0x0]
80006aa2:	26 d0       	sub	r0,109
80006aa4:	80 00       	ld.sh	r0,r0[0x0]
80006aa6:	26 f8       	sub	r8,111
80006aa8:	80 00       	ld.sh	r0,r0[0x0]
80006aaa:	27 20       	sub	r0,114
80006aac:	80 00       	ld.sh	r0,r0[0x0]
80006aae:	45 24       	lddsp	r4,sp[0x148]
80006ab0:	80 00       	ld.sh	r0,r0[0x0]
80006ab2:	27 48       	sub	r8,116
80006ab4:	80 01       	ld.sh	r1,r0[0x0]
80006ab6:	56 cc       	stdsp	sp[0x1b0],r12
80006ab8:	80 01       	ld.sh	r1,r0[0x0]
80006aba:	51 ac       	stdsp	sp[0x68],r12
80006abc:	80 00       	ld.sh	r0,r0[0x0]
80006abe:	5a a4       	cp.w	r4,-22
80006ac0:	80 00       	ld.sh	r0,r0[0x0]
80006ac2:	5a 5c       	cp.w	r12,-27
80006ac4:	80 00       	ld.sh	r0,r0[0x0]
80006ac6:	44 94       	lddsp	r4,sp[0x124]
80006ac8:	80 01       	ld.sh	r1,r0[0x0]
80006aca:	51 c8       	stdsp	sp[0x70],r8
80006acc:	80 00       	ld.sh	r0,r0[0x0]
80006ace:	c7 94       	brge	80006bc0 <ppuMemory_init+0x74>
80006ad0:	80 00       	ld.sh	r0,r0[0x0]
80006ad2:	5c 6c       	casts.b	r12
80006ad4:	80 00       	ld.sh	r0,r0[0x0]
80006ad6:	53 94       	stdsp	sp[0xe4],r4

80006ad8 <ppu_init>:
    ppu->spriteColoursForScanline[i] = 0;
    ppu->spriteColoursForScanlineSet[i] = FALSE;
    ppu->spriteColoursForScanlineIsBehindBackground[i] = FALSE;
  }
}
PPU ppu_init(void) {
80006ad8:	eb cd 40 e0 	pushm	r5-r7,lr
  PPU ppu = (PPU) malloc(sizeof(struct ppu));
80006adc:	e0 6c 03 20 	mov	r12,800
80006ae0:	f0 1f 00 15 	mcall	80006b34 <ppu_init+0x5c>
80006ae4:	18 97       	mov	r7,r12
  assert(ppu != NULL);
80006ae6:	c0 71       	brne	80006af4 <ppu_init+0x1c>
80006ae8:	49 49       	lddpc	r9,80006b38 <ppu_init+0x60>
80006aea:	49 5a       	lddpc	r10,80006b3c <ppu_init+0x64>
80006aec:	37 9b       	mov	r11,121
80006aee:	49 5c       	lddpc	r12,80006b40 <ppu_init+0x68>
80006af0:	f0 1f 00 15 	mcall	80006b44 <ppu_init+0x6c>
  ppu->controlRegister = 0;
80006af4:	30 06       	mov	r6,0
80006af6:	b8 86       	st.b	r12[0x0],r6
  ppu->maskRegister = 0;
80006af8:	b8 96       	st.b	r12[0x1],r6
  ppu->statusRegister = 0;
80006afa:	b8 a6       	st.b	r12[0x2],r6
  ppu->spriteAddressRegister = 0;
80006afc:	b8 b6       	st.b	r12[0x3],r6
  ppu->spriteDataRegister = 0;    // unused?
80006afe:	b8 c6       	st.b	r12[0x4],r6
  ppu->ppuAddressLow = 0;
80006b00:	f9 66 00 0c 	st.b	r12[12],r6
  ppu->ppuAddressHigh = 0;
80006b04:	f9 66 00 0d 	st.b	r12[13],r6
  ppu->ppuMemoryAddressRegister = 0;
80006b08:	b8 e6       	st.b	r12[0x6],r6
  ppu->ppuMemoryDataRegister = 0;
80006b0a:	b8 f6       	st.b	r12[0x7],r6
  ppu->hasPartial = FALSE;
80006b0c:	f9 66 00 0b 	st.b	r12[11],r6
  ppu->verticalScroll = 0;
80006b10:	f9 66 00 09 	st.b	r12[9],r6
  ppu->horizontalScroll = 0;
80006b14:	f9 66 00 0a 	st.b	r12[10],r6
  ppu->scrollRegister = 0;
80006b18:	b8 d6       	st.b	r12[0x5],r6
  ppu->currentCycle = 0;
80006b1a:	30 05       	mov	r5,0
80006b1c:	99 45       	st.w	r12[0x10],r5
  ppu->currentScanline = 0;
80006b1e:	99 55       	st.w	r12[0x14],r5
  ppu->currentScanlineCycle = 0;
80006b20:	99 65       	st.w	r12[0x18],r5
  ppu_resetSpriteColoursForScanline(ppu);
80006b22:	f0 1f 00 0a 	mcall	80006b48 <ppu_init+0x70>
  ppu->ppuMemoryReadBuffer = 0;
80006b26:	ef 66 00 08 	st.b	r7[8],r6
  ppu->currentFrame = 0;
80006b2a:	8f 75       	st.w	r7[0x1c],r5
  return ppu;
}
80006b2c:	0e 9c       	mov	r12,r7
80006b2e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006b32:	00 00       	add	r0,r0
80006b34:	80 00       	ld.sh	r0,r0[0x0]
80006b36:	c1 fc       	rcall	80006b74 <ppuMemory_init+0x28>
80006b38:	80 01       	ld.sh	r1,r0[0x0]
80006b3a:	41 74       	lddsp	r4,sp[0x5c]
80006b3c:	80 01       	ld.sh	r1,r0[0x0]
80006b3e:	5a 64       	cp.w	r4,-26
80006b40:	80 01       	ld.sh	r1,r0[0x0]
80006b42:	4f 94       	lddpc	r4,80006d24 <ppuMemory_nametableMirror_reader+0xc>
80006b44:	80 00       	ld.sh	r0,r0[0x0]
80006b46:	c1 a0       	breq	80006b7a <ppuMemory_init+0x2e>
80006b48:	80 00       	ld.sh	r0,r0[0x0]
80006b4a:	5f 08       	sreq	r8

80006b4c <ppuMemory_init>:
  Byte data = memory_read_callback(nes, ppuMemory, address);
  return data;
}
////////////////////////////////////////////////////////////////////////////////////////
//
Memory ppuMemory_init(void) {
80006b4c:	eb cd 40 f8 	pushm	r3-r7,lr
  Memory memory = memory_init(PPU_NUM_REAL_ADDRESSES);
80006b50:	e0 6c 40 00 	mov	r12,16384
80006b54:	f0 1f 00 2b 	mcall	80006c00 <ppuMemory_init+0xb4>
80006b58:	18 95       	mov	r5,r12
  //assert(memory != NULL);
  Address address;
  // first setup the name table mirror
 
  for (address = PPU_NAME_TABLE_MIRROR_FIRST_ADDRESS; address <=PPU_NAME_TABLE_MIRROR_FIRST_ADDRESS; address++) {
    memory_setWriteCallback(memory, address, &ppuMemory_nametableMirror_writer);
80006b5a:	4a ba       	lddpc	r10,80006c04 <ppuMemory_init+0xb8>
80006b5c:	e0 6b 30 00 	mov	r11,12288
80006b60:	f0 1f 00 2a 	mcall	80006c08 <ppuMemory_init+0xbc>
    memory_setReadCallback(memory, address, &ppuMemory_nametableMirror_reader);
80006b64:	4a aa       	lddpc	r10,80006c0c <ppuMemory_init+0xc0>
80006b66:	e0 6b 30 00 	mov	r11,12288
80006b6a:	0a 9c       	mov	r12,r5
80006b6c:	f0 1f 00 29 	mcall	80006c10 <ppuMemory_init+0xc4>
  }
  // setup the background mirrors for the first byte in each sub palette of the spritepalette
  memory_setWriteCallback(memory, PPU_SPRITE_PALETTE_0_FIRST_ADDRESS,
80006b70:	4a 97       	lddpc	r7,80006c14 <ppuMemory_init+0xc8>
80006b72:	0e 9a       	mov	r10,r7
80006b74:	e0 6b 3f 10 	mov	r11,16144
80006b78:	0a 9c       	mov	r12,r5
80006b7a:	f0 1f 00 24 	mcall	80006c08 <ppuMemory_init+0xbc>
&ppuMemory_transparencyMirror_writer);
  memory_setReadCallback(memory, PPU_SPRITE_PALETTE_0_FIRST_ADDRESS,
80006b7e:	4a 76       	lddpc	r6,80006c18 <ppuMemory_init+0xcc>
80006b80:	0c 9a       	mov	r10,r6
80006b82:	e0 6b 3f 10 	mov	r11,16144
80006b86:	0a 9c       	mov	r12,r5
80006b88:	f0 1f 00 22 	mcall	80006c10 <ppuMemory_init+0xc4>
&ppuMemory_transparencyMirror_reader);
  memory_setWriteCallback(memory, PPU_SPRITE_PALETTE_1_FIRST_ADDRESS,
80006b8c:	0e 9a       	mov	r10,r7
80006b8e:	e0 6b 3f 14 	mov	r11,16148
80006b92:	0a 9c       	mov	r12,r5
80006b94:	f0 1f 00 1d 	mcall	80006c08 <ppuMemory_init+0xbc>
&ppuMemory_transparencyMirror_writer);
  memory_setReadCallback(memory, PPU_SPRITE_PALETTE_1_FIRST_ADDRESS,
80006b98:	0c 9a       	mov	r10,r6
80006b9a:	e0 6b 3f 14 	mov	r11,16148
80006b9e:	0a 9c       	mov	r12,r5
80006ba0:	f0 1f 00 1c 	mcall	80006c10 <ppuMemory_init+0xc4>
&ppuMemory_transparencyMirror_reader);
  memory_setWriteCallback(memory, PPU_SPRITE_PALETTE_2_FIRST_ADDRESS,
80006ba4:	0e 9a       	mov	r10,r7
80006ba6:	e0 6b 3f 18 	mov	r11,16152
80006baa:	0a 9c       	mov	r12,r5
80006bac:	f0 1f 00 17 	mcall	80006c08 <ppuMemory_init+0xbc>
&ppuMemory_transparencyMirror_writer);
  memory_setReadCallback(memory, PPU_SPRITE_PALETTE_2_FIRST_ADDRESS,
80006bb0:	0c 9a       	mov	r10,r6
80006bb2:	e0 6b 3f 18 	mov	r11,16152
80006bb6:	0a 9c       	mov	r12,r5
80006bb8:	f0 1f 00 16 	mcall	80006c10 <ppuMemory_init+0xc4>
&ppuMemory_transparencyMirror_reader);
  memory_setWriteCallback(memory, PPU_SPRITE_PALETTE_3_FIRST_ADDRESS,
80006bbc:	0e 9a       	mov	r10,r7
80006bbe:	e0 6b 3f 1c 	mov	r11,16156
80006bc2:	0a 9c       	mov	r12,r5
80006bc4:	f0 1f 00 11 	mcall	80006c08 <ppuMemory_init+0xbc>
&ppuMemory_transparencyMirror_writer);
  memory_setReadCallback(memory, PPU_SPRITE_PALETTE_3_FIRST_ADDRESS,
80006bc8:	0c 9a       	mov	r10,r6
80006bca:	e0 6b 3f 1c 	mov	r11,16156
80006bce:	0a 9c       	mov	r12,r5
80006bd0:	f0 1f 00 10 	mcall	80006c10 <ppuMemory_init+0xc4>
80006bd4:	30 07       	mov	r7,0
&ppuMemory_transparencyMirror_reader);
  // now setup the mirror proper
  for (address=PPU_PALETTE_MIRROR_FIRST_ADDRESS; address <=
PPU_PALETTE_MIRROR_LAST_ADDRESS; address++) {
    memory_setWriteCallback(memory, address, &ppuMemory_paletteMirror_writer);
80006bd6:	49 24       	lddpc	r4,80006c1c <ppuMemory_init+0xd0>
    memory_setReadCallback(memory, address, &ppuMemory_paletteMirror_reader);
80006bd8:	49 23       	lddpc	r3,80006c20 <ppuMemory_init+0xd4>
&ppuMemory_transparencyMirror_writer);
  memory_setReadCallback(memory, PPU_SPRITE_PALETTE_2_FIRST_ADDRESS,
&ppuMemory_transparencyMirror_reader);
  memory_setWriteCallback(memory, PPU_SPRITE_PALETTE_3_FIRST_ADDRESS,
&ppuMemory_transparencyMirror_writer);
  memory_setReadCallback(memory, PPU_SPRITE_PALETTE_3_FIRST_ADDRESS,
80006bda:	ee c6 c0 e0 	sub	r6,r7,-16160
&ppuMemory_transparencyMirror_reader);
  // now setup the mirror proper
  for (address=PPU_PALETTE_MIRROR_FIRST_ADDRESS; address <=
PPU_PALETTE_MIRROR_LAST_ADDRESS; address++) {
    memory_setWriteCallback(memory, address, &ppuMemory_paletteMirror_writer);
80006bde:	08 9a       	mov	r10,r4
80006be0:	0c 9b       	mov	r11,r6
80006be2:	0a 9c       	mov	r12,r5
80006be4:	f0 1f 00 09 	mcall	80006c08 <ppuMemory_init+0xbc>
    memory_setReadCallback(memory, address, &ppuMemory_paletteMirror_reader);
80006be8:	06 9a       	mov	r10,r3
80006bea:	0c 9b       	mov	r11,r6
80006bec:	0a 9c       	mov	r12,r5
80006bee:	f0 1f 00 09 	mcall	80006c10 <ppuMemory_init+0xc4>
80006bf2:	2f f7       	sub	r7,-1
  memory_setWriteCallback(memory, PPU_SPRITE_PALETTE_3_FIRST_ADDRESS,
&ppuMemory_transparencyMirror_writer);
  memory_setReadCallback(memory, PPU_SPRITE_PALETTE_3_FIRST_ADDRESS,
&ppuMemory_transparencyMirror_reader);
  // now setup the mirror proper
  for (address=PPU_PALETTE_MIRROR_FIRST_ADDRESS; address <=
80006bf4:	e0 47 00 e0 	cp.w	r7,224
80006bf8:	cf 11       	brne	80006bda <ppuMemory_init+0x8e>
PPU_PALETTE_MIRROR_LAST_ADDRESS; address++) {
    memory_setWriteCallback(memory, address, &ppuMemory_paletteMirror_writer);
    memory_setReadCallback(memory, address, &ppuMemory_paletteMirror_reader);
  }
  return memory;
80006bfa:	0a 9c       	mov	r12,r5
80006bfc:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80006c00:	80 00       	ld.sh	r0,r0[0x0]
80006c02:	49 1c       	lddpc	r12,80006c44 <ppuMemory_paletteMirror_getLowestAddress+0x20>
80006c04:	80 00       	ld.sh	r0,r0[0x0]
80006c06:	6e 6c       	ld.w	r12,r7[0x18]
80006c08:	80 00       	ld.sh	r0,r0[0x0]
80006c0a:	47 cc       	lddsp	r12,sp[0x1f0]
80006c0c:	80 00       	ld.sh	r0,r0[0x0]
80006c0e:	6d 18       	ld.w	r8,r6[0x44]
80006c10:	80 00       	ld.sh	r0,r0[0x0]
80006c12:	47 a0       	lddsp	r0,sp[0x1e8]
80006c14:	80 00       	ld.sh	r0,r0[0x0]
80006c16:	6d e8       	ld.w	r8,r6[0x78]
80006c18:	80 00       	ld.sh	r0,r0[0x0]
80006c1a:	6c 98       	ld.w	r8,r6[0x24]
80006c1c:	80 00       	ld.sh	r0,r0[0x0]
80006c1e:	6d 98       	ld.w	r8,r6[0x64]
80006c20:	80 00       	ld.sh	r0,r0[0x0]
80006c22:	6c 48       	ld.w	r8,r6[0x10]

80006c24 <ppuMemory_paletteMirror_getLowestAddress>:
  return data;
}
////////////////////////////////////////////////////////////////////////////////////////
//
static Address ppuMemory_paletteMirror_getLowestAddress(Address address) {
  while(address > PPU_GENUINE_PALETTE_LAST_ADDRESS) {
80006c24:	e0 68 3f 1f 	mov	r8,16159
80006c28:	f0 0c 19 00 	cp.h	r12,r8
80006c2c:	5e 8c       	retls	r12
    address -= PPU_PALETTE_MIRRORED_SIZE;
80006c2e:	f8 c8 00 20 	sub	r8,r12,32
  Byte data = memory_read_callback(nes, ppuMemory, address);
  return data;
}
////////////////////////////////////////////////////////////////////////////////////////
//
static Address ppuMemory_paletteMirror_getLowestAddress(Address address) {
80006c32:	fe 3c 3f 20 	sub	r12,-49376
80006c36:	f9 dc c0 ab 	bfextu	r12,r12,0x5,0xb
80006c3a:	f8 0c 10 e0 	mul	r12,r12,-32
80006c3e:	f0 0c 00 0c 	add	r12,r8,r12
80006c42:	5c 8c       	casts.h	r12
  while(address > PPU_GENUINE_PALETTE_LAST_ADDRESS) {
    address -= PPU_PALETTE_MIRRORED_SIZE;
  }
  assert(address <= PPU_GENUINE_PALETTE_LAST_ADDRESS);
  return address;
}
80006c44:	5e fc       	retal	r12
80006c46:	d7 03       	nop

80006c48 <ppuMemory_paletteMirror_reader>:
  Memory ppuMemory = nes_getPPUMemory(nes);
  assert(ppuMemory != NULL);
  address = ppuMemory_paletteMirror_getLowestAddress(address);
  memory_write_callback(nes, ppuMemory, address, data);
}
static Byte ppuMemory_paletteMirror_reader(NES nes, Address address) {
80006c48:	eb cd 40 e0 	pushm	r5-r7,lr
80006c4c:	18 95       	mov	r5,r12
80006c4e:	16 96       	mov	r6,r11
  Memory ppuMemory = nes_getPPUMemory(nes);
80006c50:	f0 1f 00 0b 	mcall	80006c7c <ppuMemory_paletteMirror_reader+0x34>
80006c54:	18 97       	mov	r7,r12
  assert(ppuMemory != NULL);
80006c56:	c0 71       	brne	80006c64 <ppuMemory_paletteMirror_reader+0x1c>
80006c58:	48 a9       	lddpc	r9,80006c80 <ppuMemory_paletteMirror_reader+0x38>
80006c5a:	48 ba       	lddpc	r10,80006c84 <ppuMemory_paletteMirror_reader+0x3c>
80006c5c:	32 db       	mov	r11,45
80006c5e:	48 bc       	lddpc	r12,80006c88 <ppuMemory_paletteMirror_reader+0x40>
80006c60:	f0 1f 00 0b 	mcall	80006c8c <ppuMemory_paletteMirror_reader+0x44>
  address = ppuMemory_paletteMirror_getLowestAddress(address);
80006c64:	f9 d6 c0 10 	bfextu	r12,r6,0x0,0x10
80006c68:	f0 1f 00 0a 	mcall	80006c90 <ppuMemory_paletteMirror_reader+0x48>
  Byte data = memory_read_callback(nes, ppuMemory, address);
80006c6c:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80006c70:	0e 9b       	mov	r11,r7
80006c72:	0a 9c       	mov	r12,r5
80006c74:	f0 1f 00 08 	mcall	80006c94 <ppuMemory_paletteMirror_reader+0x4c>
  return data;
}
80006c78:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006c7c:	80 00       	ld.sh	r0,r0[0x0]
80006c7e:	50 98       	stdsp	sp[0x24],r8
80006c80:	80 01       	ld.sh	r1,r0[0x0]
80006c82:	46 d0       	lddsp	r0,sp[0x1b4]
80006c84:	80 01       	ld.sh	r1,r0[0x0]
80006c86:	5c 78       	castu.h	r8
80006c88:	80 01       	ld.sh	r1,r0[0x0]
80006c8a:	5d 28       	mustr	r8
80006c8c:	80 00       	ld.sh	r0,r0[0x0]
80006c8e:	c1 a0       	breq	80006cc2 <ppuMemory_transparencyMirror_reader+0x2a>
80006c90:	80 00       	ld.sh	r0,r0[0x0]
80006c92:	6c 24       	ld.w	r4,r6[0x8]
80006c94:	80 00       	ld.sh	r0,r0[0x0]
80006c96:	48 40       	lddpc	r0,80006ca4 <ppuMemory_transparencyMirror_reader+0xc>

80006c98 <ppuMemory_transparencyMirror_reader>:
  address -= PPU_BACKGROUND_PALETTE_TOTAL_SIZE;
  assert(address >= PPU_BACKGROUND_PALETTE_FIRST_ADDRESS);
  assert(address <= PPU_BACKGROUND_PALETTE_LAST_ADDRESS);
  memory_write_callback(nes, ppuMemory, address, data);
}
static Byte ppuMemory_transparencyMirror_reader(NES nes, Address address) {
80006c98:	eb cd 40 c0 	pushm	r6-r7,lr
80006c9c:	18 96       	mov	r6,r12
80006c9e:	16 97       	mov	r7,r11
  Memory ppuMemory = nes_getPPUMemory(nes);
80006ca0:	f0 1f 00 16 	mcall	80006cf8 <ppuMemory_transparencyMirror_reader+0x60>
  assert(ppuMemory != NULL);
80006ca4:	c0 71       	brne	80006cb2 <ppuMemory_transparencyMirror_reader+0x1a>
80006ca6:	49 69       	lddpc	r9,80006cfc <ppuMemory_transparencyMirror_reader+0x64>
80006ca8:	49 6a       	lddpc	r10,80006d00 <ppuMemory_transparencyMirror_reader+0x68>
80006caa:	31 4b       	mov	r11,20
80006cac:	49 6c       	lddpc	r12,80006d04 <ppuMemory_transparencyMirror_reader+0x6c>
80006cae:	f0 1f 00 17 	mcall	80006d08 <ppuMemory_transparencyMirror_reader+0x70>
  address -= PPU_BACKGROUND_PALETTE_TOTAL_SIZE;
80006cb2:	21 07       	sub	r7,16
80006cb4:	f5 d7 b0 10 	bfexts	r10,r7,0x0,0x10
  assert(address >= PPU_BACKGROUND_PALETTE_FIRST_ADDRESS);
80006cb8:	e0 68 3e ff 	mov	r8,16127
80006cbc:	f0 0a 19 00 	cp.h	r10,r8
80006cc0:	e0 8b 00 08 	brhi	80006cd0 <ppuMemory_transparencyMirror_reader+0x38>
80006cc4:	49 29       	lddpc	r9,80006d0c <ppuMemory_transparencyMirror_reader+0x74>
80006cc6:	48 fa       	lddpc	r10,80006d00 <ppuMemory_transparencyMirror_reader+0x68>
80006cc8:	31 6b       	mov	r11,22
80006cca:	48 fc       	lddpc	r12,80006d04 <ppuMemory_transparencyMirror_reader+0x6c>
80006ccc:	f0 1f 00 0f 	mcall	80006d08 <ppuMemory_transparencyMirror_reader+0x70>
  assert(address <= PPU_BACKGROUND_PALETTE_LAST_ADDRESS);
80006cd0:	e0 68 3f 0f 	mov	r8,16143
80006cd4:	f0 0a 19 00 	cp.h	r10,r8
80006cd8:	e0 88 00 08 	brls	80006ce8 <ppuMemory_transparencyMirror_reader+0x50>
80006cdc:	48 d9       	lddpc	r9,80006d10 <ppuMemory_transparencyMirror_reader+0x78>
80006cde:	48 9a       	lddpc	r10,80006d00 <ppuMemory_transparencyMirror_reader+0x68>
80006ce0:	31 7b       	mov	r11,23
80006ce2:	48 9c       	lddpc	r12,80006d04 <ppuMemory_transparencyMirror_reader+0x6c>
80006ce4:	f0 1f 00 09 	mcall	80006d08 <ppuMemory_transparencyMirror_reader+0x70>
  Byte data = memory_read_callback(nes, ppuMemory, address);
80006ce8:	5c 7a       	castu.h	r10
80006cea:	18 9b       	mov	r11,r12
80006cec:	0c 9c       	mov	r12,r6
80006cee:	f0 1f 00 0a 	mcall	80006d14 <ppuMemory_transparencyMirror_reader+0x7c>
  return data;
}
80006cf2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006cf6:	00 00       	add	r0,r0
80006cf8:	80 00       	ld.sh	r0,r0[0x0]
80006cfa:	50 98       	stdsp	sp[0x24],r8
80006cfc:	80 01       	ld.sh	r1,r0[0x0]
80006cfe:	46 d0       	lddsp	r0,sp[0x1b4]
80006d00:	80 01       	ld.sh	r1,r0[0x0]
80006d02:	5c bc       	swap.b	r12
80006d04:	80 01       	ld.sh	r1,r0[0x0]
80006d06:	5d 28       	mustr	r8
80006d08:	80 00       	ld.sh	r0,r0[0x0]
80006d0a:	c1 a0       	breq	80006d3e <ppuMemory_nametableMirror_reader+0x26>
80006d0c:	80 01       	ld.sh	r1,r0[0x0]
80006d0e:	5d 40       	*unknown*
80006d10:	80 01       	ld.sh	r1,r0[0x0]
80006d12:	5d 70       	*unknown*
80006d14:	80 00       	ld.sh	r0,r0[0x0]
80006d16:	48 40       	lddpc	r0,80006d24 <ppuMemory_nametableMirror_reader+0xc>

80006d18 <ppuMemory_nametableMirror_reader>:
  address -= PPU_NAME_TABLE_TOTAL_SIZE;
  assert(address >= PPU_NAME_TABLE_0_FIRST_ADDRESS);
  assert(address <= PPU_NAME_TABLE_3_FIRST_ADDRESS);
  memory_write_callback(nes, ppuMemory, address, data);
}
static Byte ppuMemory_nametableMirror_reader(NES nes, Address address) {
80006d18:	eb cd 40 c0 	pushm	r6-r7,lr
80006d1c:	18 96       	mov	r6,r12
80006d1e:	16 97       	mov	r7,r11
  Memory ppuMemory = nes_getPPUMemory(nes);
80006d20:	f0 1f 00 16 	mcall	80006d78 <ppuMemory_nametableMirror_reader+0x60>
  assert(ppuMemory != NULL);
80006d24:	c0 71       	brne	80006d32 <ppuMemory_nametableMirror_reader+0x1a>
80006d26:	49 69       	lddpc	r9,80006d7c <ppuMemory_nametableMirror_reader+0x64>
80006d28:	49 6a       	lddpc	r10,80006d80 <ppuMemory_nametableMirror_reader+0x68>
80006d2a:	33 eb       	mov	r11,62
80006d2c:	49 6c       	lddpc	r12,80006d84 <ppuMemory_nametableMirror_reader+0x6c>
80006d2e:	f0 1f 00 17 	mcall	80006d88 <ppuMemory_nametableMirror_reader+0x70>
  address -= PPU_NAME_TABLE_TOTAL_SIZE;
80006d32:	ee c7 10 00 	sub	r7,r7,4096
80006d36:	f5 d7 b0 10 	bfexts	r10,r7,0x0,0x10
  assert(address >= PPU_NAME_TABLE_0_FIRST_ADDRESS);
80006d3a:	e0 68 1f ff 	mov	r8,8191
80006d3e:	f0 0a 19 00 	cp.h	r10,r8
80006d42:	e0 8b 00 08 	brhi	80006d52 <ppuMemory_nametableMirror_reader+0x3a>
80006d46:	49 29       	lddpc	r9,80006d8c <ppuMemory_nametableMirror_reader+0x74>
80006d48:	48 ea       	lddpc	r10,80006d80 <ppuMemory_nametableMirror_reader+0x68>
80006d4a:	34 0b       	mov	r11,64
80006d4c:	48 ec       	lddpc	r12,80006d84 <ppuMemory_nametableMirror_reader+0x6c>
80006d4e:	f0 1f 00 0f 	mcall	80006d88 <ppuMemory_nametableMirror_reader+0x70>
  assert(address <= PPU_NAME_TABLE_3_FIRST_ADDRESS);
80006d52:	e0 68 2c 00 	mov	r8,11264
80006d56:	f0 0a 19 00 	cp.h	r10,r8
80006d5a:	e0 88 00 08 	brls	80006d6a <ppuMemory_nametableMirror_reader+0x52>
80006d5e:	48 d9       	lddpc	r9,80006d90 <ppuMemory_nametableMirror_reader+0x78>
80006d60:	48 8a       	lddpc	r10,80006d80 <ppuMemory_nametableMirror_reader+0x68>
80006d62:	34 1b       	mov	r11,65
80006d64:	48 8c       	lddpc	r12,80006d84 <ppuMemory_nametableMirror_reader+0x6c>
80006d66:	f0 1f 00 09 	mcall	80006d88 <ppuMemory_nametableMirror_reader+0x70>
  Byte data = memory_read_callback(nes, ppuMemory, address);
80006d6a:	5c 7a       	castu.h	r10
80006d6c:	18 9b       	mov	r11,r12
80006d6e:	0c 9c       	mov	r12,r6
80006d70:	f0 1f 00 09 	mcall	80006d94 <ppuMemory_nametableMirror_reader+0x7c>
  return data;
}
80006d74:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006d78:	80 00       	ld.sh	r0,r0[0x0]
80006d7a:	50 98       	stdsp	sp[0x24],r8
80006d7c:	80 01       	ld.sh	r1,r0[0x0]
80006d7e:	46 d0       	lddsp	r0,sp[0x1b4]
80006d80:	80 01       	ld.sh	r1,r0[0x0]
80006d82:	5d 04       	ror	r4
80006d84:	80 01       	ld.sh	r1,r0[0x0]
80006d86:	5d 28       	mustr	r8
80006d88:	80 00       	ld.sh	r0,r0[0x0]
80006d8a:	c1 a0       	breq	80006dbe <ppuMemory_paletteMirror_writer+0x26>
80006d8c:	80 01       	ld.sh	r1,r0[0x0]
80006d8e:	5d a0       	*unknown*
80006d90:	80 01       	ld.sh	r1,r0[0x0]
80006d92:	5d cc       	*unknown*
80006d94:	80 00       	ld.sh	r0,r0[0x0]
80006d96:	48 40       	lddpc	r0,80006da4 <ppuMemory_paletteMirror_writer+0xc>

80006d98 <ppuMemory_paletteMirror_writer>:
  }
  assert(address <= PPU_GENUINE_PALETTE_LAST_ADDRESS);
  return address;
}
// Both palettes are also mirrored to $3F20-$3FFF.
static void ppuMemory_paletteMirror_writer(NES nes, Address address, Byte data) {
80006d98:	d4 21       	pushm	r4-r7,lr
80006d9a:	18 94       	mov	r4,r12
80006d9c:	16 96       	mov	r6,r11
80006d9e:	14 95       	mov	r5,r10
  Memory ppuMemory = nes_getPPUMemory(nes);
80006da0:	f0 1f 00 0b 	mcall	80006dcc <ppuMemory_paletteMirror_writer+0x34>
80006da4:	18 97       	mov	r7,r12
  assert(ppuMemory != NULL);
80006da6:	c0 71       	brne	80006db4 <ppuMemory_paletteMirror_writer+0x1c>
80006da8:	48 a9       	lddpc	r9,80006dd0 <ppuMemory_paletteMirror_writer+0x38>
80006daa:	48 ba       	lddpc	r10,80006dd4 <ppuMemory_paletteMirror_writer+0x3c>
80006dac:	32 7b       	mov	r11,39
80006dae:	48 bc       	lddpc	r12,80006dd8 <ppuMemory_paletteMirror_writer+0x40>
80006db0:	f0 1f 00 0b 	mcall	80006ddc <ppuMemory_paletteMirror_writer+0x44>
  address = ppuMemory_paletteMirror_getLowestAddress(address);
80006db4:	f9 d6 c0 10 	bfextu	r12,r6,0x0,0x10
80006db8:	f0 1f 00 0a 	mcall	80006de0 <ppuMemory_paletteMirror_writer+0x48>
  memory_write_callback(nes, ppuMemory, address, data);
80006dbc:	0a 99       	mov	r9,r5
80006dbe:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80006dc2:	0e 9b       	mov	r11,r7
80006dc4:	08 9c       	mov	r12,r4
80006dc6:	f0 1f 00 08 	mcall	80006de4 <ppuMemory_paletteMirror_writer+0x4c>
}
80006dca:	d8 22       	popm	r4-r7,pc
80006dcc:	80 00       	ld.sh	r0,r0[0x0]
80006dce:	50 98       	stdsp	sp[0x24],r8
80006dd0:	80 01       	ld.sh	r1,r0[0x0]
80006dd2:	46 d0       	lddsp	r0,sp[0x1b4]
80006dd4:	80 01       	ld.sh	r1,r0[0x0]
80006dd6:	5d f8       	*unknown*
80006dd8:	80 01       	ld.sh	r1,r0[0x0]
80006dda:	5d 28       	mustr	r8
80006ddc:	80 00       	ld.sh	r0,r0[0x0]
80006dde:	c1 a0       	breq	80006e12 <ppuMemory_transparencyMirror_writer+0x2a>
80006de0:	80 00       	ld.sh	r0,r0[0x0]
80006de2:	6c 24       	ld.w	r4,r6[0x8]
80006de4:	80 00       	ld.sh	r0,r0[0x0]
80006de6:	48 d0       	lddpc	r0,80006e18 <ppuMemory_transparencyMirror_writer+0x30>

80006de8 <ppuMemory_transparencyMirror_writer>:
#include "ppuMemory.h"
#include "nes.h"
////////////////////////////////////////////////////////////////////////////////////////
//
// Addresses $3F10/$3F14/$3F18/$3F1C are mirrors of $3F00/$3F04/$3F08/$3F0C.
static void ppuMemory_transparencyMirror_writer(NES nes, Address address, Byte data) {
80006de8:	eb cd 40 e0 	pushm	r5-r7,lr
80006dec:	18 95       	mov	r5,r12
80006dee:	16 97       	mov	r7,r11
80006df0:	14 96       	mov	r6,r10
  Memory ppuMemory = nes_getPPUMemory(nes);
80006df2:	f0 1f 00 17 	mcall	80006e4c <ppuMemory_transparencyMirror_writer+0x64>
  assert(ppuMemory != NULL);
80006df6:	c0 71       	brne	80006e04 <ppuMemory_transparencyMirror_writer+0x1c>
80006df8:	49 69       	lddpc	r9,80006e50 <ppuMemory_transparencyMirror_writer+0x68>
80006dfa:	49 7a       	lddpc	r10,80006e54 <ppuMemory_transparencyMirror_writer+0x6c>
80006dfc:	30 cb       	mov	r11,12
80006dfe:	49 7c       	lddpc	r12,80006e58 <ppuMemory_transparencyMirror_writer+0x70>
80006e00:	f0 1f 00 17 	mcall	80006e5c <ppuMemory_transparencyMirror_writer+0x74>
  address -= PPU_BACKGROUND_PALETTE_TOTAL_SIZE;
80006e04:	21 07       	sub	r7,16
80006e06:	f5 d7 b0 10 	bfexts	r10,r7,0x0,0x10
  assert(address >= PPU_BACKGROUND_PALETTE_FIRST_ADDRESS);
80006e0a:	e0 68 3e ff 	mov	r8,16127
80006e0e:	f0 0a 19 00 	cp.h	r10,r8
80006e12:	e0 8b 00 08 	brhi	80006e22 <ppuMemory_transparencyMirror_writer+0x3a>
80006e16:	49 39       	lddpc	r9,80006e60 <ppuMemory_transparencyMirror_writer+0x78>
80006e18:	48 fa       	lddpc	r10,80006e54 <ppuMemory_transparencyMirror_writer+0x6c>
80006e1a:	30 eb       	mov	r11,14
80006e1c:	48 fc       	lddpc	r12,80006e58 <ppuMemory_transparencyMirror_writer+0x70>
80006e1e:	f0 1f 00 10 	mcall	80006e5c <ppuMemory_transparencyMirror_writer+0x74>
  assert(address <= PPU_BACKGROUND_PALETTE_LAST_ADDRESS);
80006e22:	e0 68 3f 0f 	mov	r8,16143
80006e26:	f0 0a 19 00 	cp.h	r10,r8
80006e2a:	e0 88 00 08 	brls	80006e3a <ppuMemory_transparencyMirror_writer+0x52>
80006e2e:	48 e9       	lddpc	r9,80006e64 <ppuMemory_transparencyMirror_writer+0x7c>
80006e30:	48 9a       	lddpc	r10,80006e54 <ppuMemory_transparencyMirror_writer+0x6c>
80006e32:	30 fb       	mov	r11,15
80006e34:	48 9c       	lddpc	r12,80006e58 <ppuMemory_transparencyMirror_writer+0x70>
80006e36:	f0 1f 00 0a 	mcall	80006e5c <ppuMemory_transparencyMirror_writer+0x74>
  memory_write_callback(nes, ppuMemory, address, data);
80006e3a:	0c 99       	mov	r9,r6
80006e3c:	5c 7a       	castu.h	r10
80006e3e:	18 9b       	mov	r11,r12
80006e40:	0a 9c       	mov	r12,r5
80006e42:	f0 1f 00 0a 	mcall	80006e68 <ppuMemory_transparencyMirror_writer+0x80>
}
80006e46:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006e4a:	00 00       	add	r0,r0
80006e4c:	80 00       	ld.sh	r0,r0[0x0]
80006e4e:	50 98       	stdsp	sp[0x24],r8
80006e50:	80 01       	ld.sh	r1,r0[0x0]
80006e52:	46 d0       	lddsp	r0,sp[0x1b4]
80006e54:	80 01       	ld.sh	r1,r0[0x0]
80006e56:	5c e0       	tnbz	r0
80006e58:	80 01       	ld.sh	r1,r0[0x0]
80006e5a:	5d 28       	mustr	r8
80006e5c:	80 00       	ld.sh	r0,r0[0x0]
80006e5e:	c1 a0       	breq	80006e92 <ppuMemory_nametableMirror_writer+0x26>
80006e60:	80 01       	ld.sh	r1,r0[0x0]
80006e62:	5d 40       	*unknown*
80006e64:	80 01       	ld.sh	r1,r0[0x0]
80006e66:	5d 70       	*unknown*
80006e68:	80 00       	ld.sh	r0,r0[0x0]
80006e6a:	48 d0       	lddpc	r0,80006e9c <ppuMemory_nametableMirror_writer+0x30>

80006e6c <ppuMemory_nametableMirror_writer>:
  Byte data = memory_read_callback(nes, ppuMemory, address);
  return data;
}
////////////////////////////////////////////////////////////////////////////////////////
//
static void ppuMemory_nametableMirror_writer(NES nes, Address address, Byte data) {
80006e6c:	eb cd 40 e0 	pushm	r5-r7,lr
80006e70:	18 95       	mov	r5,r12
80006e72:	16 97       	mov	r7,r11
80006e74:	14 96       	mov	r6,r10
  Memory ppuMemory = nes_getPPUMemory(nes);
80006e76:	f0 1f 00 17 	mcall	80006ed0 <ppuMemory_nametableMirror_writer+0x64>
  assert(ppuMemory != NULL);
80006e7a:	c0 71       	brne	80006e88 <ppuMemory_nametableMirror_writer+0x1c>
80006e7c:	49 69       	lddpc	r9,80006ed4 <ppuMemory_nametableMirror_writer+0x68>
80006e7e:	49 7a       	lddpc	r10,80006ed8 <ppuMemory_nametableMirror_writer+0x6c>
80006e80:	33 6b       	mov	r11,54
80006e82:	49 7c       	lddpc	r12,80006edc <ppuMemory_nametableMirror_writer+0x70>
80006e84:	f0 1f 00 17 	mcall	80006ee0 <ppuMemory_nametableMirror_writer+0x74>
  address -= PPU_NAME_TABLE_TOTAL_SIZE;
80006e88:	ee c7 10 00 	sub	r7,r7,4096
80006e8c:	f5 d7 b0 10 	bfexts	r10,r7,0x0,0x10
  assert(address >= PPU_NAME_TABLE_0_FIRST_ADDRESS);
80006e90:	e0 68 1f ff 	mov	r8,8191
80006e94:	f0 0a 19 00 	cp.h	r10,r8
80006e98:	e0 8b 00 08 	brhi	80006ea8 <ppuMemory_nametableMirror_writer+0x3c>
80006e9c:	49 29       	lddpc	r9,80006ee4 <ppuMemory_nametableMirror_writer+0x78>
80006e9e:	48 fa       	lddpc	r10,80006ed8 <ppuMemory_nametableMirror_writer+0x6c>
80006ea0:	33 8b       	mov	r11,56
80006ea2:	48 fc       	lddpc	r12,80006edc <ppuMemory_nametableMirror_writer+0x70>
80006ea4:	f0 1f 00 0f 	mcall	80006ee0 <ppuMemory_nametableMirror_writer+0x74>
  assert(address <= PPU_NAME_TABLE_3_FIRST_ADDRESS);
80006ea8:	e0 68 2c 00 	mov	r8,11264
80006eac:	f0 0a 19 00 	cp.h	r10,r8
80006eb0:	e0 88 00 08 	brls	80006ec0 <ppuMemory_nametableMirror_writer+0x54>
80006eb4:	48 d9       	lddpc	r9,80006ee8 <ppuMemory_nametableMirror_writer+0x7c>
80006eb6:	48 9a       	lddpc	r10,80006ed8 <ppuMemory_nametableMirror_writer+0x6c>
80006eb8:	33 9b       	mov	r11,57
80006eba:	48 9c       	lddpc	r12,80006edc <ppuMemory_nametableMirror_writer+0x70>
80006ebc:	f0 1f 00 09 	mcall	80006ee0 <ppuMemory_nametableMirror_writer+0x74>
  memory_write_callback(nes, ppuMemory, address, data);
80006ec0:	0c 99       	mov	r9,r6
80006ec2:	5c 7a       	castu.h	r10
80006ec4:	18 9b       	mov	r11,r12
80006ec6:	0a 9c       	mov	r12,r5
80006ec8:	f0 1f 00 09 	mcall	80006eec <ppuMemory_nametableMirror_writer+0x80>
}
80006ecc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006ed0:	80 00       	ld.sh	r0,r0[0x0]
80006ed2:	50 98       	stdsp	sp[0x24],r8
80006ed4:	80 01       	ld.sh	r1,r0[0x0]
80006ed6:	46 d0       	lddsp	r0,sp[0x1b4]
80006ed8:	80 01       	ld.sh	r1,r0[0x0]
80006eda:	5c 98       	brev	r8
80006edc:	80 01       	ld.sh	r1,r0[0x0]
80006ede:	5d 28       	mustr	r8
80006ee0:	80 00       	ld.sh	r0,r0[0x0]
80006ee2:	c1 a0       	breq	80006f16 <et024006_SetLimits+0x26>
80006ee4:	80 01       	ld.sh	r1,r0[0x0]
80006ee6:	5d a0       	*unknown*
80006ee8:	80 01       	ld.sh	r1,r0[0x0]
80006eea:	5d cc       	*unknown*
80006eec:	80 00       	ld.sh	r0,r0[0x0]
80006eee:	48 d0       	lddpc	r0,80006f20 <et024006_SetLimits+0x30>

80006ef0 <et024006_SetLimits>:
/*! \brief Sets the display limits according to the corner coordinates.
 *  Writing to the display will result in writing to the area specified through
 *  this function.
 */
void et024006_SetLimits( uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2 )
{
80006ef0:	eb cd 40 80 	pushm	r7,lr

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006ef4:	fc 1e c0 00 	movh	lr,0xc000
80006ef8:	30 28       	mov	r8,2
80006efa:	bc 08       	st.h	lr[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006efc:	ef dc c1 08 	bfextu	r7,r12,0x8,0x8
80006f00:	fc 18 c0 20 	movh	r8,0xc020
80006f04:	b0 07       	st.h	r8[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006f06:	30 37       	mov	r7,3
80006f08:	bc 07       	st.h	lr[0x0],r7
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006f0a:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006f0c:	30 4c       	mov	r12,4
80006f0e:	bc 0c       	st.h	lr[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006f10:	f9 da c1 08 	bfextu	r12,r10,0x8,0x8
80006f14:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006f16:	30 5c       	mov	r12,5
80006f18:	bc 0c       	st.h	lr[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006f1a:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006f1c:	30 6a       	mov	r10,6
80006f1e:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006f20:	f5 db c1 08 	bfextu	r10,r11,0x8,0x8
80006f24:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006f26:	30 7a       	mov	r10,7
80006f28:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006f2a:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006f2c:	30 8a       	mov	r10,8
80006f2e:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006f30:	f5 d9 c1 08 	bfextu	r10,r9,0x8,0x8
80006f34:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006f36:	30 9a       	mov	r10,9
80006f38:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006f3a:	b0 09       	st.h	r8[0x0],r9
  et024006_WriteRegister( HIMAX_COL_ADDR_END1, (x2 & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START2, (y1 >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START1, (y1 & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_END2, (y2 >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_END1, (y2 & 0xff) );
}
80006f3c:	e3 cd 80 80 	ldm	sp++,r7,pc

80006f40 <et024006_SetQuickLimits>:

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006f40:	fc 19 c0 00 	movh	r9,0xc000
80006f44:	30 28       	mov	r8,2
80006f46:	b2 08       	st.h	r9[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006f48:	f5 dc c1 08 	bfextu	r10,r12,0x8,0x8
80006f4c:	fc 18 c0 20 	movh	r8,0xc020
80006f50:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006f52:	30 3a       	mov	r10,3
80006f54:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006f56:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006f58:	30 6a       	mov	r10,6
80006f5a:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006f5c:	f5 db c1 08 	bfextu	r10,r11,0x8,0x8
80006f60:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006f62:	30 7a       	mov	r10,7
80006f64:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006f66:	b0 0b       	st.h	r8[0x0],r11
{
  et024006_WriteRegister( HIMAX_COL_ADDR_START2, (x >> 8) );
  et024006_WriteRegister( HIMAX_COL_ADDR_START1, (x & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START2, (y >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START1, (y & 0xff) );
}
80006f68:	5e fc       	retal	r12
80006f6a:	d7 03       	nop

80006f6c <et024006_DrawQuickPixel>:
  et024006_WriteRegister( HIMAX_ROW_ADDR_END1, (y & 0xff) );
}


void et024006_DrawQuickPixel( uint16_t x, uint16_t y, et024006_color_t color )
{
80006f6c:	eb cd 40 80 	pushm	r7,lr
80006f70:	14 97       	mov	r7,r10
  // Sanity check on parameters.
  Assert( x < ET024006_WIDTH );
  Assert( y < ET024006_HEIGHT );

  // Set up draw area and write the two bytes of pixel data.
  et024006_SetQuickLimits( x, y );
80006f72:	5c 7b       	castu.h	r11
80006f74:	5c 7c       	castu.h	r12
80006f76:	f0 1f 00 06 	mcall	80006f8c <et024006_DrawQuickPixel+0x20>
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006f7a:	32 29       	mov	r9,34
80006f7c:	fc 18 c0 00 	movh	r8,0xc000
80006f80:	b0 09       	st.h	r8[0x0],r9
  et024006_SendSPI( color & 0xff );
  et024006_SendSPI( color >> 8 );
  et024006_DeselectSPI();
#endif
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  *ET024006_PARAM_ADDR = color;
80006f82:	fc 18 c0 20 	movh	r8,0xc020
80006f86:	b0 07       	st.h	r8[0x0],r7
#endif

}
80006f88:	e3 cd 80 80 	ldm	sp++,r7,pc
80006f8c:	80 00       	ld.sh	r0,r0[0x0]
80006f8e:	6f 40       	ld.w	r0,r7[0x50]

80006f90 <et024006_PrintString>:
void et024006_PrintString(char *lcd_string, const unsigned char *font_style,
                          uint16_t x,
                          uint16_t y,
                          uint16_t fcolor,
                          int bcolor)
{
80006f90:	d4 31       	pushm	r0-r7,lr
80006f92:	20 dd       	sub	sp,52
80006f94:	18 97       	mov	r7,r12
80006f96:	50 6b       	stdsp	sp[0x18],r11
80006f98:	50 8a       	stdsp	sp[0x20],r10
80006f9a:	50 29       	stdsp	sp[0x8],r9
80006f9c:	10 94       	mov	r4,r8
80006f9e:	41 63       	lddsp	r3,sp[0x58]
  unsigned char mask = 0, xfont, yfont, font_size;
  const unsigned char *data;
  uint16_t saved_x = x;

  // if string is empty there is nothing to do
  if( *lcd_string == '\0')
80006fa0:	19 89       	ld.ub	r9,r12[0x0]
80006fa2:	30 08       	mov	r8,0
80006fa4:	f0 09 18 00 	cp.b	r9,r8
80006fa8:	e0 80 01 0c 	breq	800071c0 <et024006_PrintString+0x230>
    return;

  data = font_style;  // point to the start of the font table
  xfont = *data;  // get font x width
80006fac:	16 98       	mov	r8,r11
80006fae:	11 3a       	ld.ub	r10,r8++
80006fb0:	50 4a       	stdsp	sp[0x10],r10
  data++;
  yfont = *data;  // get font y length
80006fb2:	11 89       	ld.ub	r9,r8[0x0]
80006fb4:	50 39       	stdsp	sp[0xc],r9
  data++;
  font_size = *data;  // get data bytes per font
80006fb6:	11 98       	ld.ub	r8,r8[0x1]
80006fb8:	50 58       	stdsp	sp[0x14],r8

  // If transparent mode
  if(bcolor == -1)
80006fba:	5b f3       	cp.w	r3,-1
80006fbc:	e0 81 00 8d 	brne	800070d6 <et024006_PrintString+0x146>
  {
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );
80006fc0:	e0 69 00 ef 	mov	r9,239
80006fc4:	e0 6a 01 3f 	mov	r10,319
80006fc8:	30 0b       	mov	r11,0
80006fca:	16 9c       	mov	r12,r11
80006fcc:	f0 1f 00 7e 	mcall	800071c4 <et024006_PrintString+0x234>
        data =  (font_style + font_size) +  // header offset
          (font_size * (int)(*lcd_string - 32)); // character select
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;
80006fd0:	40 58       	lddsp	r8,sp[0x14]
80006fd2:	50 c8       	stdsp	sp[0x30],r8
80006fd4:	f0 08 00 18 	add	r8,r8,r8<<0x1
80006fd8:	a5 78       	lsl	r8,0x5
80006fda:	40 69       	lddsp	r9,sp[0x18]
80006fdc:	10 09       	add	r9,r8
80006fde:	50 b9       	stdsp	sp[0x2c],r9
80006fe0:	ee c8 ff ff 	sub	r8,r7,-1
80006fe4:	50 98       	stdsp	sp[0x24],r8
80006fe6:	40 8a       	lddsp	r10,sp[0x20]
80006fe8:	5c 8a       	casts.h	r10
80006fea:	50 aa       	stdsp	sp[0x28],r10
      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
        {
          if (*data & mask) // if pixel data then put dot
80006fec:	30 03       	mov	r3,0
          {
            et024006_DrawQuickPixel( col, row, fcolor );
80006fee:	08 90       	mov	r0,r4
80006ff0:	5c 70       	castu.h	r0
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );

    do
    {
      if(*lcd_string =='\n') {
80006ff2:	40 99       	lddsp	r9,sp[0x24]
80006ff4:	f3 38 ff ff 	ld.ub	r8,r9[-1]
80006ff8:	30 aa       	mov	r10,10
80006ffa:	f4 08 18 00 	cp.b	r8,r10
80006ffe:	c0 b1       	brne	80007014 <et024006_PrintString+0x84>
        x = saved_x;
        y += yfont;
80007000:	40 28       	lddsp	r8,sp[0x8]
80007002:	40 39       	lddsp	r9,sp[0xc]
80007004:	12 08       	add	r8,r9
80007006:	5c 88       	casts.h	r8
80007008:	50 28       	stdsp	sp[0x8],r8
8000700a:	40 98       	lddsp	r8,sp[0x24]
8000700c:	40 8a       	lddsp	r10,sp[0x20]
8000700e:	5c 8a       	casts.h	r10
80007010:	50 aa       	stdsp	sp[0x28],r10
        lcd_string++;  // next character in string
        continue;
80007012:	c5 a8       	rjmp	800070c6 <et024006_PrintString+0x136>
      } else if(*lcd_string =='\t') {
80007014:	30 99       	mov	r9,9
80007016:	f2 08 18 00 	cp.b	r8,r9
8000701a:	c0 81       	brne	8000702a <et024006_PrintString+0x9a>
        x += xfont;
8000701c:	40 a8       	lddsp	r8,sp[0x28]
8000701e:	40 49       	lddsp	r9,sp[0x10]
80007020:	12 08       	add	r8,r9
80007022:	5c 88       	casts.h	r8
80007024:	50 a8       	stdsp	sp[0x28],r8
80007026:	40 98       	lddsp	r8,sp[0x24]
        lcd_string++;  // next character in string
        continue;
80007028:	c4 f8       	rjmp	800070c6 <et024006_PrintString+0x136>
      }
      // Checks if the character can be printed
      if (*lcd_string >= 32 && *lcd_string < (32 + 96))
8000702a:	f0 ca 00 20 	sub	r10,r8,32
8000702e:	35 f9       	mov	r9,95
80007030:	f2 0a 18 00 	cp.b	r10,r9
80007034:	e0 88 00 04 	brls	8000703c <et024006_PrintString+0xac>
80007038:	40 b5       	lddsp	r5,sp[0x2c]
8000703a:	c0 a8       	rjmp	8000704e <et024006_PrintString+0xbe>
      {
        // point to character data in font table
        data =  (font_style + font_size) +  // header offset
8000703c:	22 08       	sub	r8,32
8000703e:	40 ca       	lddsp	r10,sp[0x30]
80007040:	f0 0a 02 45 	mul	r5,r8,r10
80007044:	40 59       	lddsp	r9,sp[0x14]
80007046:	12 05       	add	r5,r9
80007048:	40 68       	lddsp	r8,sp[0x18]
8000704a:	f0 05 00 05 	add	r5,r8,r5
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
8000704e:	40 22       	lddsp	r2,sp[0x8]
80007050:	5c 72       	castu.h	r2
80007052:	40 3a       	lddsp	r10,sp[0xc]
80007054:	e4 0a 00 0a 	add	r10,r2,r10
80007058:	50 1a       	stdsp	sp[0x4],r10
8000705a:	04 3a       	cp.w	r10,r2
8000705c:	e0 8a 00 2f 	brle	800070ba <et024006_PrintString+0x12a>
80007060:	40 21       	lddsp	r1,sp[0x8]
80007062:	5c 81       	casts.h	r1
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
80007064:	40 a9       	lddsp	r9,sp[0x28]
80007066:	5c 79       	castu.h	r9
80007068:	50 09       	stdsp	sp[0x0],r9
8000706a:	12 94       	mov	r4,r9
8000706c:	40 48       	lddsp	r8,sp[0x10]
8000706e:	10 04       	add	r4,r8
80007070:	40 aa       	lddsp	r10,sp[0x28]
80007072:	5c 8a       	casts.h	r10
80007074:	50 7a       	stdsp	sp[0x1c],r10
80007076:	c1 b8       	rjmp	800070ac <et024006_PrintString+0x11c>
        {
          if (*data & mask) // if pixel data then put dot
          {
            et024006_DrawQuickPixel( col, row, fcolor );
          }
          mask >>= 1;
80007078:	a1 96       	lsr	r6,0x1
      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
        {
          if (*data & mask) // if pixel data then put dot
8000707a:	0b 88       	ld.ub	r8,r5[0x0]
8000707c:	ed e8 00 08 	and	r8,r6,r8
80007080:	e6 08 18 00 	cp.b	r8,r3
80007084:	c0 50       	breq	8000708e <et024006_PrintString+0xfe>
          {
            et024006_DrawQuickPixel( col, row, fcolor );
80007086:	00 9a       	mov	r10,r0
80007088:	04 9b       	mov	r11,r2
8000708a:	f0 1f 00 50 	mcall	800071c8 <et024006_PrintString+0x238>
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
8000708e:	2f f7       	sub	r7,-1
80007090:	5c 87       	casts.h	r7
80007092:	0e 9c       	mov	r12,r7
80007094:	5c 7c       	castu.h	r12
80007096:	08 3c       	cp.w	r12,r4
80007098:	cf 05       	brlt	80007078 <et024006_PrintString+0xe8>
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
8000709a:	2f f1       	sub	r1,-1
8000709c:	5c 81       	casts.h	r1
8000709e:	e5 d1 c0 10 	bfextu	r2,r1,0x0,0x10
800070a2:	40 19       	lddsp	r9,sp[0x4]
800070a4:	04 39       	cp.w	r9,r2
800070a6:	e0 8a 00 0a 	brle	800070ba <et024006_PrintString+0x12a>
            et024006_DrawQuickPixel( col, row, fcolor );
          }
          mask >>= 1;
        }
        // Next row data
        data++;
800070aa:	2f f5       	sub	r5,-1
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
800070ac:	40 0c       	lddsp	r12,sp[0x0]
800070ae:	08 3c       	cp.w	r12,r4
800070b0:	cf 54       	brge	8000709a <et024006_PrintString+0x10a>
800070b2:	40 77       	lddsp	r7,sp[0x1c]
800070b4:	e0 66 00 80 	mov	r6,128
800070b8:	ce 1b       	rjmp	8000707a <et024006_PrintString+0xea>
        }
        // Next row data
        data++;
      }
      // move to next character start pixel
      x += xfont;
800070ba:	40 a8       	lddsp	r8,sp[0x28]
800070bc:	40 4a       	lddsp	r10,sp[0x10]
800070be:	14 08       	add	r8,r10
800070c0:	5c 88       	casts.h	r8
800070c2:	50 a8       	stdsp	sp[0x28],r8
800070c4:	40 98       	lddsp	r8,sp[0x24]
800070c6:	40 99       	lddsp	r9,sp[0x24]
800070c8:	2f f9       	sub	r9,-1
800070ca:	50 99       	stdsp	sp[0x24],r9
      lcd_string++;  // next character in string

    }while(*lcd_string !='\0');  // keep spitting chars out until end of string
800070cc:	11 88       	ld.ub	r8,r8[0x0]
800070ce:	e6 08 18 00 	cp.b	r8,r3
800070d2:	c9 01       	brne	80006ff2 <et024006_PrintString+0x62>
800070d4:	c7 68       	rjmp	800071c0 <et024006_PrintString+0x230>
800070d6:	f8 c8 ff ff 	sub	r8,r12,-1
800070da:	50 08       	stdsp	sp[0x0],r8
800070dc:	40 8c       	lddsp	r12,sp[0x20]
800070de:	5c 8c       	casts.h	r12
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
800070e0:	30 06       	mov	r6,0
          {
            *ET024006_PARAM_ADDR = fcolor;
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
800070e2:	5c 83       	casts.h	r3
800070e4:	fc 15 c0 20 	movh	r5,0xc020
  }
  else
  {
    do
    {
      if(*lcd_string =='\n') {
800070e8:	40 0a       	lddsp	r10,sp[0x0]
800070ea:	f5 31 ff ff 	ld.ub	r1,r10[-1]
800070ee:	30 a8       	mov	r8,10
800070f0:	f0 01 18 00 	cp.b	r1,r8
800070f4:	c0 b1       	brne	8000710a <et024006_PrintString+0x17a>
        x = saved_x;
        y += yfont;
800070f6:	40 28       	lddsp	r8,sp[0x8]
800070f8:	40 39       	lddsp	r9,sp[0xc]
800070fa:	12 08       	add	r8,r9
800070fc:	5c 88       	casts.h	r8
800070fe:	50 28       	stdsp	sp[0x8],r8
80007100:	14 98       	mov	r8,r10
80007102:	40 8a       	lddsp	r10,sp[0x20]
80007104:	5c 8a       	casts.h	r10
80007106:	50 1a       	stdsp	sp[0x4],r10
        lcd_string++;  // next character in string
        continue;
80007108:	c5 28       	rjmp	800071ac <et024006_PrintString+0x21c>
      } else if(*lcd_string =='\t') {
8000710a:	30 98       	mov	r8,9
8000710c:	f0 01 18 00 	cp.b	r1,r8
80007110:	c0 71       	brne	8000711e <et024006_PrintString+0x18e>
        x += xfont;
80007112:	40 49       	lddsp	r9,sp[0x10]
80007114:	12 0c       	add	r12,r9
80007116:	5c 8c       	casts.h	r12
80007118:	50 1c       	stdsp	sp[0x4],r12
8000711a:	40 08       	lddsp	r8,sp[0x0]
        lcd_string++;  // next character in string
        continue;
8000711c:	c4 88       	rjmp	800071ac <et024006_PrintString+0x21c>
      // point to character data in font table
      data =  (font_style + font_size) +  // header offset
        (font_size * (int)(*lcd_string - 32)); // character select

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
8000711e:	40 32       	lddsp	r2,sp[0xc]
80007120:	40 47       	lddsp	r7,sp[0x10]
80007122:	f8 07 00 08 	add	r8,r12,r7
80007126:	5c 88       	casts.h	r8
80007128:	50 18       	stdsp	sp[0x4],r8
8000712a:	04 99       	mov	r9,r2
8000712c:	20 19       	sub	r9,1
8000712e:	40 28       	lddsp	r8,sp[0x8]
80007130:	10 09       	add	r9,r8
80007132:	40 1a       	lddsp	r10,sp[0x4]
80007134:	20 1a       	sub	r10,1
80007136:	5c 79       	castu.h	r9
80007138:	5c 7a       	castu.h	r10
8000713a:	10 9b       	mov	r11,r8
8000713c:	5c 7b       	castu.h	r11
8000713e:	5c 7c       	castu.h	r12
80007140:	f0 1f 00 21 	mcall	800071c4 <et024006_PrintString+0x234>
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80007144:	32 29       	mov	r9,34
80007146:	fc 18 c0 00 	movh	r8,0xc000
8000714a:	b0 09       	st.h	r8[0x0],r9

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
8000714c:	40 3a       	lddsp	r10,sp[0xc]
8000714e:	58 0a       	cp.w	r10,0
80007150:	c2 d0       	breq	800071aa <et024006_PrintString+0x21a>
        x += xfont;
        lcd_string++;  // next character in string
        continue;
      }
      // point to character data in font table
      data =  (font_style + font_size) +  // header offset
80007152:	e2 ce 00 20 	sub	lr,r1,32
80007156:	40 59       	lddsp	r9,sp[0x14]
80007158:	f2 0e 02 4e 	mul	lr,r9,lr
8000715c:	12 0e       	add	lr,r9
8000715e:	40 68       	lddsp	r8,sp[0x18]
80007160:	f0 0e 00 0e 	add	lr,r8,lr
80007164:	30 0c       	mov	r12,0
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
80007166:	e0 60 00 80 	mov	r0,128
8000716a:	18 91       	mov	r1,r12
8000716c:	c1 98       	rjmp	8000719e <et024006_PrintString+0x20e>
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
          }
          mask >>= 1;
8000716e:	a1 99       	lsr	r9,0x1
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
80007170:	f3 eb 00 0a 	and	r10,r9,r11
          {
            *ET024006_PARAM_ADDR = fcolor;
80007174:	ec 0a 18 00 	cp.b	r10,r6
80007178:	e8 0a 17 10 	movne	r10,r4
8000717c:	eb fa 1c 00 	st.hne	r5[0x0],r10
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
80007180:	eb f3 0c 00 	st.heq	r5[0x0],r3
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
80007184:	2f f8       	sub	r8,-1
80007186:	5c 88       	casts.h	r8
80007188:	f0 07 19 00 	cp.h	r7,r8
8000718c:	fe 9b ff f1 	brhi	8000716e <et024006_PrintString+0x1de>

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
80007190:	2f fc       	sub	r12,-1
80007192:	5c 8c       	casts.h	r12
80007194:	f8 02 19 00 	cp.h	r2,r12
80007198:	e0 88 00 09 	brls	800071aa <et024006_PrintString+0x21a>
          }
          mask >>= 1;
        }

        // Next row data
        data++;
8000719c:	2f fe       	sub	lr,-1
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
8000719e:	58 07       	cp.w	r7,0
800071a0:	cf 80       	breq	80007190 <et024006_PrintString+0x200>
        {
          if (*data & mask) // if pixel data then put dot
800071a2:	1d 8b       	ld.ub	r11,lr[0x0]
800071a4:	00 99       	mov	r9,r0
800071a6:	02 98       	mov	r8,r1
800071a8:	ce 4b       	rjmp	80007170 <et024006_PrintString+0x1e0>
800071aa:	40 08       	lddsp	r8,sp[0x0]
800071ac:	40 09       	lddsp	r9,sp[0x0]
800071ae:	2f f9       	sub	r9,-1
800071b0:	50 09       	stdsp	sp[0x0],r9
      }
      // move to next character start pixel
      x += xfont;
      lcd_string++;  // next character in string

    }while(*lcd_string !='\0');  // keep spitting chars out until end of string
800071b2:	11 88       	ld.ub	r8,r8[0x0]
800071b4:	ec 08 18 00 	cp.b	r8,r6
800071b8:	c0 40       	breq	800071c0 <et024006_PrintString+0x230>
800071ba:	40 1c       	lddsp	r12,sp[0x4]
800071bc:	5c 8c       	casts.h	r12
800071be:	c9 5b       	rjmp	800070e8 <et024006_PrintString+0x158>
  }
}
800071c0:	2f 3d       	sub	sp,-52
800071c2:	d8 32       	popm	r0-r7,pc
800071c4:	80 00       	ld.sh	r0,r0[0x0]
800071c6:	6e f0       	ld.w	r0,r7[0x3c]
800071c8:	80 00       	ld.sh	r0,r0[0x0]
800071ca:	6f 6c       	ld.w	r12,r7[0x58]

800071cc <et024006_DuplicatePixel>:
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800071cc:	32 29       	mov	r9,34
800071ce:	fc 18 c0 00 	movh	r8,0xc000
800071d2:	b0 09       	st.h	r8[0x0],r9
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  //uint8_t countLowByte = count;
  while (count >= 8) {
800071d4:	58 7b       	cp.w	r11,7
800071d6:	e0 88 00 13 	brls	800071fc <et024006_DuplicatePixel+0x30>
800071da:	16 99       	mov	r9,r11
    *ET024006_PARAM_ADDR = color;
800071dc:	fc 18 c0 20 	movh	r8,0xc020
800071e0:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800071e2:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800071e4:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800071e6:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800071e8:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800071ea:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800071ec:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800071ee:	b0 0c       	st.h	r8[0x0],r12
    count-=8;
800071f0:	20 89       	sub	r9,8
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  //uint8_t countLowByte = count;
  while (count >= 8) {
800071f2:	58 79       	cp.w	r9,7
800071f4:	fe 9b ff f6 	brhi	800071e0 <et024006_DuplicatePixel+0x14>



/* --- Pixel block operations --- */

void et024006_DuplicatePixel( et024006_color_t color, uint32_t count )
800071f8:	f7 db c0 03 	bfextu	r11,r11,0x0,0x3
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    count-=8;
  }
  while (count > 0) {
800071fc:	58 0b       	cp.w	r11,0
800071fe:	5e 0c       	reteq	r12
    *ET024006_PARAM_ADDR = color;
80007200:	fc 18 c0 20 	movh	r8,0xc020
80007204:	b0 0c       	st.h	r8[0x0],r12
    --count;
80007206:	20 1b       	sub	r11,1
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    count-=8;
  }
  while (count > 0) {
80007208:	cf e1       	brne	80007204 <et024006_DuplicatePixel+0x38>
8000720a:	5e fc       	retal	r12

8000720c <et024006_DrawFilledRect>:
  }
}


void et024006_DrawFilledRect( uint16_t x, uint16_t y, uint16_t width, uint16_t height, et024006_color_t color )
{
8000720c:	eb cd 40 e0 	pushm	r5-r7,lr
80007210:	14 97       	mov	r7,r10
80007212:	12 96       	mov	r6,r9
80007214:	10 95       	mov	r5,r8
  // More sanity check.
  Assert( x2 < ET024006_WIDTH );
  Assert( y2 < ET024006_HEIGHT );

  // Set up draw area and copy pixel color until area is full.
  et024006_SetLimits( x, y, x2, y2 );
80007216:	f6 c9 00 01 	sub	r9,r11,1
8000721a:	0c 09       	add	r9,r6
8000721c:	f8 ca 00 01 	sub	r10,r12,1
80007220:	0e 0a       	add	r10,r7
80007222:	5c 79       	castu.h	r9
80007224:	5c 7a       	castu.h	r10
80007226:	5c 7b       	castu.h	r11
80007228:	5c 7c       	castu.h	r12
8000722a:	f0 1f 00 07 	mcall	80007244 <et024006_DrawFilledRect+0x38>
  uint32_t count = (uint32_t) width * height;
  et024006_DuplicatePixel( color, count );
8000722e:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80007232:	5c 77       	castu.h	r7
80007234:	af 3b       	mul	r11,r7
80007236:	f9 d5 c0 10 	bfextu	r12,r5,0x0,0x10
8000723a:	f0 1f 00 04 	mcall	80007248 <et024006_DrawFilledRect+0x3c>
}
8000723e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80007242:	00 00       	add	r0,r0
80007244:	80 00       	ld.sh	r0,r0[0x0]
80007246:	6e f0       	ld.w	r0,r7[0x3c]
80007248:	80 00       	ld.sh	r0,r0[0x0]
8000724a:	71 cc       	ld.w	r12,r8[0x70]

8000724c <et024006_AdjustGamma>:

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000724c:	fc 19 c0 00 	movh	r9,0xc000
80007250:	34 6a       	mov	r10,70
80007252:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80007254:	fc 18 c0 20 	movh	r8,0xc020
80007258:	e0 6b 00 94 	mov	r11,148
8000725c:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000725e:	34 7b       	mov	r11,71
80007260:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80007262:	34 1b       	mov	r11,65
80007264:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80007266:	34 8b       	mov	r11,72
80007268:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000726a:	30 0b       	mov	r11,0
8000726c:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000726e:	34 9b       	mov	r11,73
80007270:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80007272:	33 3b       	mov	r11,51
80007274:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80007276:	34 ab       	mov	r11,74
80007278:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000727a:	32 5b       	mov	r11,37
8000727c:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000727e:	34 bb       	mov	r11,75
80007280:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80007282:	34 5b       	mov	r11,69
80007284:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80007286:	34 cb       	mov	r11,76
80007288:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000728a:	34 4b       	mov	r11,68
8000728c:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000728e:	34 db       	mov	r11,77
80007290:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80007292:	37 7b       	mov	r11,119
80007294:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80007296:	34 eb       	mov	r11,78
80007298:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000729a:	31 2b       	mov	r11,18
8000729c:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000729e:	34 fb       	mov	r11,79
800072a0:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800072a2:	e0 6b 00 cc 	mov	r11,204
800072a6:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800072a8:	35 0b       	mov	r11,80
800072aa:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800072ac:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800072ae:	35 1a       	mov	r10,81
800072b0:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800072b2:	e0 69 00 82 	mov	r9,130
800072b6:	b0 09       	st.h	r8[0x0],r9
  et024006_WriteRegister( HIMAX_GAMMACTRL8, 0x77 );
  et024006_WriteRegister( HIMAX_GAMMACTRL9, 0x12 );
  et024006_WriteRegister( HIMAX_GAMMACTRL10, 0xCC );
  et024006_WriteRegister( HIMAX_GAMMACTRL11, 0x46 );
  et024006_WriteRegister( HIMAX_GAMMACTRL12, 0x82 );
}
800072b8:	5e fc       	retal	r12
800072ba:	d7 03       	nop

800072bc <et024006_Init>:
 *  @param cpu_hz CPU speed in Hz. This is needed for power up timings.
 *  @param hsb_hz HSB bus speed in Hz. This parameter is needed to set up the SMC.
 *  If SPI mode is used then this parameter is ignored.
 */
void et024006_Init( unsigned long cpu_hz, unsigned long hsb_hz )
{
800072bc:	eb cd 40 c0 	pushm	r6-r7,lr
  tft_data.cpu_hz = cpu_hz;
800072c0:	fe f7 04 80 	ld.w	r7,pc[1152]
800072c4:	8f 0c       	st.w	r7[0x0],r12
  tft_data.hsb_hz = hsb_hz;
800072c6:	8f 1b       	st.w	r7[0x4],r11

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_SPI)
  et024006_InitSPI();
#endif
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  smc_init(tft_data.hsb_hz);
800072c8:	16 9c       	mov	r12,r11
800072ca:	f0 1f 01 1f 	mcall	80007744 <et024006_Init+0x488>
static void et024006_SetupInterface( void )
{

  // et024006_TE (tearing sync) signal from display is input
  // without any pull resistors
  gpio_enable_gpio_pin(ET024006DHU_TE_PIN);
800072ce:	35 5c       	mov	r12,85
800072d0:	f0 1f 01 1e 	mcall	80007748 <et024006_Init+0x48c>

  // Backlight pin (PWM) for display is output
  gpio_enable_module_pin(ET024006DHU_BL_PIN, ET024006DHU_BL_FUNCTION);
800072d4:	30 2b       	mov	r11,2
800072d6:	33 2c       	mov	r12,50
800072d8:	f0 1f 01 1d 	mcall	8000774c <et024006_Init+0x490>
  // Turns backlight ON
  /*TODO Add backlight driver */

  // Reset pin for display is output
  gpio_set_gpio_pin(ET024006DHU_RESET_PIN);
800072dc:	35 2c       	mov	r12,82
800072de:	f0 1f 01 1d 	mcall	80007750 <et024006_Init+0x494>
/*! \brief Does a hard reset of the display.
 */
static void et024006_ResetDisplay( void )
{
  // clear reset line
  gpio_clr_gpio_pin(ET024006DHU_RESET_PIN);
800072e2:	35 2c       	mov	r12,82
800072e4:	f0 1f 01 1c 	mcall	80007754 <et024006_Init+0x498>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
800072e8:	6e 07       	ld.w	r7,r7[0x0]
800072ea:	33 28       	mov	r8,50
800072ec:	ee 08 06 46 	mulu.d	r6,r7,r8
800072f0:	ee 78 42 40 	mov	r8,1000000
800072f4:	30 09       	mov	r9,0
800072f6:	ee 7a 42 3f 	mov	r10,999999
800072fa:	30 0b       	mov	r11,0
800072fc:	ec 0a 00 0a 	add	r10,r6,r10
80007300:	ee 0b 00 4b 	adc	r11,r7,r11
80007304:	f0 1f 01 15 	mcall	80007758 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80007308:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000730c:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80007310:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80007314:	14 38       	cp.w	r8,r10
80007316:	e0 88 00 09 	brls	80007328 <et024006_Init+0x6c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000731a:	12 38       	cp.w	r8,r9
8000731c:	fe 98 ff fa 	brls	80007310 <et024006_Init+0x54>
80007320:	12 3a       	cp.w	r10,r9
80007322:	e0 83 00 a2 	brlo	80007466 <et024006_Init+0x1aa>
80007326:	cf 5b       	rjmp	80007310 <et024006_Init+0x54>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80007328:	12 38       	cp.w	r8,r9
8000732a:	e0 8b 00 9e 	brhi	80007466 <et024006_Init+0x1aa>
8000732e:	12 3a       	cp.w	r10,r9
80007330:	e0 83 00 9b 	brlo	80007466 <et024006_Init+0x1aa>
80007334:	ce eb       	rjmp	80007310 <et024006_Init+0x54>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80007336:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000733a:	14 38       	cp.w	r8,r10
8000733c:	e0 88 00 09 	brls	8000734e <et024006_Init+0x92>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80007340:	12 38       	cp.w	r8,r9
80007342:	fe 98 ff fa 	brls	80007336 <et024006_Init+0x7a>
80007346:	12 3a       	cp.w	r10,r9
80007348:	e0 83 00 a9 	brlo	8000749a <et024006_Init+0x1de>
8000734c:	cf 5b       	rjmp	80007336 <et024006_Init+0x7a>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000734e:	12 38       	cp.w	r8,r9
80007350:	e0 8b 00 a5 	brhi	8000749a <et024006_Init+0x1de>
80007354:	12 3a       	cp.w	r10,r9
80007356:	e0 83 00 a2 	brlo	8000749a <et024006_Init+0x1de>
8000735a:	ce eb       	rjmp	80007336 <et024006_Init+0x7a>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000735c:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80007360:	14 38       	cp.w	r8,r10
80007362:	e0 88 00 09 	brls	80007374 <et024006_Init+0xb8>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80007366:	12 38       	cp.w	r8,r9
80007368:	fe 98 ff fa 	brls	8000735c <et024006_Init+0xa0>
8000736c:	12 3a       	cp.w	r10,r9
8000736e:	e0 83 01 1e 	brlo	800075aa <et024006_Init+0x2ee>
80007372:	cf 5b       	rjmp	8000735c <et024006_Init+0xa0>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80007374:	12 38       	cp.w	r8,r9
80007376:	e0 8b 01 1a 	brhi	800075aa <et024006_Init+0x2ee>
8000737a:	12 3a       	cp.w	r10,r9
8000737c:	e0 83 01 17 	brlo	800075aa <et024006_Init+0x2ee>
80007380:	ce eb       	rjmp	8000735c <et024006_Init+0xa0>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80007382:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80007386:	14 38       	cp.w	r8,r10
80007388:	e0 88 00 09 	brls	8000739a <et024006_Init+0xde>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000738c:	12 38       	cp.w	r8,r9
8000738e:	fe 98 ff fa 	brls	80007382 <et024006_Init+0xc6>
80007392:	12 3a       	cp.w	r10,r9
80007394:	e0 83 01 29 	brlo	800075e6 <et024006_Init+0x32a>
80007398:	cf 5b       	rjmp	80007382 <et024006_Init+0xc6>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000739a:	12 38       	cp.w	r8,r9
8000739c:	e0 8b 01 25 	brhi	800075e6 <et024006_Init+0x32a>
800073a0:	12 3a       	cp.w	r10,r9
800073a2:	e0 83 01 22 	brlo	800075e6 <et024006_Init+0x32a>
800073a6:	ce eb       	rjmp	80007382 <et024006_Init+0xc6>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800073a8:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800073ac:	14 38       	cp.w	r8,r10
800073ae:	e0 88 00 09 	brls	800073c0 <et024006_Init+0x104>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800073b2:	12 38       	cp.w	r8,r9
800073b4:	fe 98 ff fa 	brls	800073a8 <et024006_Init+0xec>
800073b8:	12 3a       	cp.w	r10,r9
800073ba:	e0 83 01 35 	brlo	80007624 <et024006_Init+0x368>
800073be:	cf 5b       	rjmp	800073a8 <et024006_Init+0xec>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800073c0:	12 38       	cp.w	r8,r9
800073c2:	e0 8b 01 31 	brhi	80007624 <et024006_Init+0x368>
800073c6:	12 3a       	cp.w	r10,r9
800073c8:	e0 83 01 2e 	brlo	80007624 <et024006_Init+0x368>
800073cc:	ce eb       	rjmp	800073a8 <et024006_Init+0xec>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800073ce:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800073d2:	14 38       	cp.w	r8,r10
800073d4:	e0 88 00 09 	brls	800073e6 <et024006_Init+0x12a>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800073d8:	12 38       	cp.w	r8,r9
800073da:	fe 98 ff fa 	brls	800073ce <et024006_Init+0x112>
800073de:	12 3a       	cp.w	r10,r9
800073e0:	e0 83 01 40 	brlo	80007660 <et024006_Init+0x3a4>
800073e4:	cf 5b       	rjmp	800073ce <et024006_Init+0x112>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800073e6:	12 38       	cp.w	r8,r9
800073e8:	e0 8b 01 3c 	brhi	80007660 <et024006_Init+0x3a4>
800073ec:	12 3a       	cp.w	r10,r9
800073ee:	e0 83 01 39 	brlo	80007660 <et024006_Init+0x3a4>
800073f2:	ce eb       	rjmp	800073ce <et024006_Init+0x112>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800073f4:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800073f8:	14 38       	cp.w	r8,r10
800073fa:	e0 88 00 09 	brls	8000740c <et024006_Init+0x150>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800073fe:	12 38       	cp.w	r8,r9
80007400:	fe 98 ff fa 	brls	800073f4 <et024006_Init+0x138>
80007404:	12 3a       	cp.w	r10,r9
80007406:	e0 83 01 4b 	brlo	8000769c <et024006_Init+0x3e0>
8000740a:	cf 5b       	rjmp	800073f4 <et024006_Init+0x138>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000740c:	12 38       	cp.w	r8,r9
8000740e:	e0 8b 01 47 	brhi	8000769c <et024006_Init+0x3e0>
80007412:	12 3a       	cp.w	r10,r9
80007414:	e0 83 01 44 	brlo	8000769c <et024006_Init+0x3e0>
80007418:	ce eb       	rjmp	800073f4 <et024006_Init+0x138>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000741a:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000741e:	14 38       	cp.w	r8,r10
80007420:	e0 88 00 09 	brls	80007432 <et024006_Init+0x176>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80007424:	12 38       	cp.w	r8,r9
80007426:	fe 98 ff fa 	brls	8000741a <et024006_Init+0x15e>
8000742a:	12 3a       	cp.w	r10,r9
8000742c:	e0 83 01 56 	brlo	800076d8 <et024006_Init+0x41c>
80007430:	cf 5b       	rjmp	8000741a <et024006_Init+0x15e>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80007432:	12 38       	cp.w	r8,r9
80007434:	e0 8b 01 52 	brhi	800076d8 <et024006_Init+0x41c>
80007438:	12 3a       	cp.w	r10,r9
8000743a:	e0 83 01 4f 	brlo	800076d8 <et024006_Init+0x41c>
8000743e:	ce eb       	rjmp	8000741a <et024006_Init+0x15e>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80007440:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80007444:	14 38       	cp.w	r8,r10
80007446:	e0 88 00 09 	brls	80007458 <et024006_Init+0x19c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000744a:	12 38       	cp.w	r8,r9
8000744c:	fe 98 ff fa 	brls	80007440 <et024006_Init+0x184>
80007450:	12 3a       	cp.w	r10,r9
80007452:	e0 83 01 64 	brlo	8000771a <et024006_Init+0x45e>
80007456:	cf 5b       	rjmp	80007440 <et024006_Init+0x184>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80007458:	12 38       	cp.w	r8,r9
8000745a:	e0 8b 01 60 	brhi	8000771a <et024006_Init+0x45e>
8000745e:	12 3a       	cp.w	r10,r9
80007460:	e0 83 01 5d 	brlo	8000771a <et024006_Init+0x45e>
80007464:	ce eb       	rjmp	80007440 <et024006_Init+0x184>
  // 50us delay
  cpu_delay_us( 50, tft_data.cpu_hz );

  gpio_set_gpio_pin(ET024006DHU_RESET_PIN);
80007466:	35 2c       	mov	r12,82
80007468:	f0 1f 00 ba 	mcall	80007750 <et024006_Init+0x494>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000746c:	fe f8 02 d4 	ld.w	r8,pc[724]
80007470:	70 07       	ld.w	r7,r8[0x0]
80007472:	30 58       	mov	r8,5
80007474:	ee 08 06 46 	mulu.d	r6,r7,r8
80007478:	e0 68 03 e8 	mov	r8,1000
8000747c:	30 09       	mov	r9,0
8000747e:	e0 6a 03 e7 	mov	r10,999
80007482:	30 0b       	mov	r11,0
80007484:	ec 0a 00 0a 	add	r10,r6,r10
80007488:	ee 0b 00 4b 	adc	r11,r7,r11
8000748c:	f0 1f 00 b3 	mcall	80007758 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80007490:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80007494:	f0 0a 00 0a 	add	r10,r8,r10
80007498:	c4 fb       	rjmp	80007336 <et024006_Init+0x7a>
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  smc_init(tft_data.hsb_hz);
#endif
  et024006_SetupInterface();
  et024006_ResetDisplay();
  et024006_AdjustGamma();
8000749a:	f0 1f 00 b1 	mcall	8000775c <et024006_Init+0x4a0>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000749e:	fc 19 c0 00 	movh	r9,0xc000
800074a2:	30 1a       	mov	r10,1
800074a4:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800074a6:	fc 18 c0 20 	movh	r8,0xc020
800074aa:	30 6b       	mov	r11,6
800074ac:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800074ae:	33 ab       	mov	r11,58
800074b0:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800074b2:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800074b4:	33 bb       	mov	r11,59
800074b6:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800074b8:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800074ba:	33 ca       	mov	r10,60
800074bc:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800074be:	e0 6a 00 f0 	mov	r10,240
800074c2:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800074c4:	33 db       	mov	r11,61
800074c6:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800074c8:	30 07       	mov	r7,0
800074ca:	b0 07       	st.h	r8[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800074cc:	33 eb       	mov	r11,62
800074ce:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800074d0:	33 8b       	mov	r11,56
800074d2:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800074d4:	34 0c       	mov	r12,64
800074d6:	b2 0c       	st.h	r9[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
800074d8:	30 fe       	mov	lr,15
800074da:	b0 0e       	st.h	r8[0x0],lr

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800074dc:	34 1e       	mov	lr,65
800074de:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
800074e0:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800074e2:	32 7a       	mov	r10,39
800074e4:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800074e6:	30 2a       	mov	r10,2
800074e8:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800074ea:	32 8e       	mov	lr,40
800074ec:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
800074ee:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800074f0:	32 9e       	mov	lr,41
800074f2:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
800074f4:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800074f6:	32 ae       	mov	lr,42
800074f8:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
800074fa:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800074fc:	32 ce       	mov	lr,44
800074fe:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80007500:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80007502:	32 de       	mov	lr,45
80007504:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80007506:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80007508:	31 9a       	mov	r10,25
8000750a:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000750c:	34 9a       	mov	r10,73
8000750e:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80007510:	e0 6a 00 93 	mov	r10,147
80007514:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80007516:	30 8a       	mov	r10,8
80007518:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000751a:	31 6a       	mov	r10,22
8000751c:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000751e:	36 8a       	mov	r10,104
80007520:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80007522:	32 3a       	mov	r10,35
80007524:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80007526:	e0 6a 00 95 	mov	r10,149
8000752a:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000752c:	32 4e       	mov	lr,36
8000752e:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80007530:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80007532:	32 5a       	mov	r10,37
80007534:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80007536:	e0 6a 00 ff 	mov	r10,255
8000753a:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000753c:	e0 6a 00 90 	mov	r10,144
80007540:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80007542:	37 fa       	mov	r10,127
80007544:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80007546:	33 5a       	mov	r10,53
80007548:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000754a:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000754c:	33 6a       	mov	r10,54
8000754e:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80007550:	37 8a       	mov	r10,120
80007552:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80007554:	31 da       	mov	r10,29
80007556:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80007558:	30 7a       	mov	r10,7
8000755a:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000755c:	31 ea       	mov	r10,30
8000755e:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80007560:	b0 07       	st.h	r8[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80007562:	31 fa       	mov	r10,31
80007564:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80007566:	30 4a       	mov	r10,4
80007568:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000756a:	32 0a       	mov	r10,32
8000756c:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000756e:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80007570:	34 4a       	mov	r10,68
80007572:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80007574:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80007576:	34 5a       	mov	r10,69
80007578:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000757a:	31 29       	mov	r9,18
8000757c:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000757e:	4f 18       	lddpc	r8,80007740 <et024006_Init+0x484>
80007580:	70 07       	ld.w	r7,r8[0x0]
80007582:	30 a8       	mov	r8,10
80007584:	ee 08 06 46 	mulu.d	r6,r7,r8
80007588:	e0 68 03 e8 	mov	r8,1000
8000758c:	30 09       	mov	r9,0
8000758e:	e0 6a 03 e7 	mov	r10,999
80007592:	30 0b       	mov	r11,0
80007594:	ec 0a 00 0a 	add	r10,r6,r10
80007598:	ee 0b 00 4b 	adc	r11,r7,r11
8000759c:	f0 1f 00 6f 	mcall	80007758 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800075a0:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800075a4:	f0 0a 00 0a 	add	r10,r8,r10
800075a8:	cd aa       	rjmp	8000735c <et024006_Init+0xa0>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800075aa:	31 c9       	mov	r9,28
800075ac:	fc 18 c0 00 	movh	r8,0xc000
800075b0:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
800075b2:	30 49       	mov	r9,4
800075b4:	fc 18 c0 20 	movh	r8,0xc020
800075b8:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800075ba:	4e 28       	lddpc	r8,80007740 <et024006_Init+0x484>
800075bc:	70 07       	ld.w	r7,r8[0x0]
800075be:	31 48       	mov	r8,20
800075c0:	ee 08 06 46 	mulu.d	r6,r7,r8
800075c4:	e0 68 03 e8 	mov	r8,1000
800075c8:	30 09       	mov	r9,0
800075ca:	e0 6a 03 e7 	mov	r10,999
800075ce:	30 0b       	mov	r11,0
800075d0:	ec 0a 00 0a 	add	r10,r6,r10
800075d4:	ee 0b 00 4b 	adc	r11,r7,r11
800075d8:	f0 1f 00 60 	mcall	80007758 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800075dc:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800075e0:	f0 0a 00 0a 	add	r10,r8,r10
800075e4:	cc fa       	rjmp	80007382 <et024006_Init+0xc6>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800075e6:	34 39       	mov	r9,67
800075e8:	fc 18 c0 00 	movh	r8,0xc000
800075ec:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
800075ee:	e0 69 00 80 	mov	r9,128
800075f2:	fc 18 c0 20 	movh	r8,0xc020
800075f6:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800075f8:	4d 28       	lddpc	r8,80007740 <et024006_Init+0x484>
800075fa:	70 07       	ld.w	r7,r8[0x0]
800075fc:	30 58       	mov	r8,5
800075fe:	ee 08 06 46 	mulu.d	r6,r7,r8
80007602:	e0 68 03 e8 	mov	r8,1000
80007606:	30 09       	mov	r9,0
80007608:	e0 6a 03 e7 	mov	r10,999
8000760c:	30 0b       	mov	r11,0
8000760e:	ec 0a 00 0a 	add	r10,r6,r10
80007612:	ee 0b 00 4b 	adc	r11,r7,r11
80007616:	f0 1f 00 51 	mcall	80007758 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000761a:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000761e:	f0 0a 00 0a 	add	r10,r8,r10
80007622:	cc 3a       	rjmp	800073a8 <et024006_Init+0xec>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80007624:	31 b9       	mov	r9,27
80007626:	fc 18 c0 00 	movh	r8,0xc000
8000762a:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000762c:	30 89       	mov	r9,8
8000762e:	fc 18 c0 20 	movh	r8,0xc020
80007632:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80007634:	4c 38       	lddpc	r8,80007740 <et024006_Init+0x484>
80007636:	70 07       	ld.w	r7,r8[0x0]
80007638:	32 88       	mov	r8,40
8000763a:	ee 08 06 46 	mulu.d	r6,r7,r8
8000763e:	e0 68 03 e8 	mov	r8,1000
80007642:	30 09       	mov	r9,0
80007644:	e0 6a 03 e7 	mov	r10,999
80007648:	30 0b       	mov	r11,0
8000764a:	ec 0a 00 0a 	add	r10,r6,r10
8000764e:	ee 0b 00 4b 	adc	r11,r7,r11
80007652:	f0 1f 00 42 	mcall	80007758 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80007656:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000765a:	f0 0a 00 0a 	add	r10,r8,r10
8000765e:	cb 8a       	rjmp	800073ce <et024006_Init+0x112>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80007660:	31 b9       	mov	r9,27
80007662:	fc 18 c0 00 	movh	r8,0xc000
80007666:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80007668:	31 09       	mov	r9,16
8000766a:	fc 18 c0 20 	movh	r8,0xc020
8000766e:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80007670:	4b 48       	lddpc	r8,80007740 <et024006_Init+0x484>
80007672:	70 07       	ld.w	r7,r8[0x0]
80007674:	32 88       	mov	r8,40
80007676:	ee 08 06 46 	mulu.d	r6,r7,r8
8000767a:	e0 68 03 e8 	mov	r8,1000
8000767e:	30 09       	mov	r9,0
80007680:	e0 6a 03 e7 	mov	r10,999
80007684:	30 0b       	mov	r11,0
80007686:	ec 0a 00 0a 	add	r10,r6,r10
8000768a:	ee 0b 00 4b 	adc	r11,r7,r11
8000768e:	f0 1f 00 33 	mcall	80007758 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80007692:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80007696:	f0 0a 00 0a 	add	r10,r8,r10
8000769a:	ca da       	rjmp	800073f4 <et024006_Init+0x138>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000769c:	32 69       	mov	r9,38
8000769e:	fc 18 c0 00 	movh	r8,0xc000
800076a2:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
800076a4:	30 49       	mov	r9,4
800076a6:	fc 18 c0 20 	movh	r8,0xc020
800076aa:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800076ac:	4a 58       	lddpc	r8,80007740 <et024006_Init+0x484>
800076ae:	70 07       	ld.w	r7,r8[0x0]
800076b0:	32 88       	mov	r8,40
800076b2:	ee 08 06 46 	mulu.d	r6,r7,r8
800076b6:	e0 68 03 e8 	mov	r8,1000
800076ba:	30 09       	mov	r9,0
800076bc:	e0 6a 03 e7 	mov	r10,999
800076c0:	30 0b       	mov	r11,0
800076c2:	ec 0a 00 0a 	add	r10,r6,r10
800076c6:	ee 0b 00 4b 	adc	r11,r7,r11
800076ca:	f0 1f 00 24 	mcall	80007758 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800076ce:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800076d2:	f0 0a 00 0a 	add	r10,r8,r10
800076d6:	ca 2a       	rjmp	8000741a <et024006_Init+0x15e>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800076d8:	fc 19 c0 00 	movh	r9,0xc000
800076dc:	32 6a       	mov	r10,38
800076de:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800076e0:	fc 18 c0 20 	movh	r8,0xc020
800076e4:	32 4b       	mov	r11,36
800076e6:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800076e8:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800076ea:	32 c9       	mov	r9,44
800076ec:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800076ee:	49 58       	lddpc	r8,80007740 <et024006_Init+0x484>
800076f0:	70 07       	ld.w	r7,r8[0x0]
800076f2:	32 88       	mov	r8,40
800076f4:	ee 08 06 46 	mulu.d	r6,r7,r8
800076f8:	e0 68 03 e8 	mov	r8,1000
800076fc:	30 09       	mov	r9,0
800076fe:	e0 6a 03 e7 	mov	r10,999
80007702:	30 0b       	mov	r11,0
80007704:	ec 0a 00 0a 	add	r10,r6,r10
80007708:	ee 0b 00 4b 	adc	r11,r7,r11
8000770c:	f0 1f 00 13 	mcall	80007758 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80007710:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80007714:	f0 0a 00 0a 	add	r10,r8,r10
80007718:	c9 4a       	rjmp	80007440 <et024006_Init+0x184>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000771a:	fc 19 c0 00 	movh	r9,0xc000
8000771e:	32 68       	mov	r8,38
80007720:	b2 08       	st.h	r9[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
80007722:	fc 18 c0 20 	movh	r8,0xc020
80007726:	33 ca       	mov	r10,60
80007728:	b0 0a       	st.h	r8[0x0],r10
}

__always_inline static uint8_t et024006_ReadRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000772a:	37 0a       	mov	r10,112
8000772c:	b2 0a       	st.h	r9[0x0],r10
  return *ET024006_PARAM_ADDR;
8000772e:	90 0b       	ld.sh	r11,r8[0x0]
80007730:	5c 5b       	castu.b	r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80007732:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80007734:	16 99       	mov	r9,r11
80007736:	a3 b9       	sbr	r9,0x3
80007738:	b0 09       	st.h	r8[0x0],r9
  et024006_GeneralSettings();
  et024006_InterfaceSettings();
  et024006_PowerSettings();
  et024006_PowerUp();
  et024006_PowerOn();
}
8000773a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000773e:	00 00       	add	r0,r0
80007740:	00 00       	add	r0,r0
80007742:	06 40       	or	r0,r3
80007744:	80 00       	ld.sh	r0,r0[0x0]
80007746:	84 74       	ld.sh	r4,r2[0xe]
80007748:	80 00       	ld.sh	r0,r0[0x0]
8000774a:	86 14       	ld.sh	r4,r3[0x2]
8000774c:	80 00       	ld.sh	r0,r0[0x0]
8000774e:	85 90       	st.w	r2[0x24],r0
80007750:	80 00       	ld.sh	r0,r0[0x0]
80007752:	86 2c       	ld.sh	r12,r3[0x4]
80007754:	80 00       	ld.sh	r0,r0[0x0]
80007756:	86 48       	ld.sh	r8,r3[0x8]
80007758:	80 00       	ld.sh	r0,r0[0x0]
8000775a:	bf 3a       	mul	r10,pc
8000775c:	80 00       	ld.sh	r0,r0[0x0]
8000775e:	72 4c       	ld.w	r12,r9[0x10]

80007760 <sd_mmc_spi_get_capacity>:
//!         [39]    == data[11] && 0x80
//!
//! @return bit
//!         true
void sd_mmc_spi_get_capacity(void)
{
80007760:	d4 01       	pushm	lr
  uint8_t  read_bl_len;
  uint8_t  erase_grp_size;
  uint8_t  erase_grp_mult;

  // extract variables from CSD array
  read_bl_len = csd[5] & 0x0F;
80007762:	4c 18       	lddpc	r8,80007864 <sd_mmc_spi_get_capacity+0x104>
80007764:	11 db       	ld.ub	r11,r8[0x5]
  if (card_type == SD_CARD_2_SDHC) {
80007766:	4c 18       	lddpc	r8,80007868 <sd_mmc_spi_get_capacity+0x108>
80007768:	11 8a       	ld.ub	r10,r8[0x0]
8000776a:	30 38       	mov	r8,3
8000776c:	f0 0a 18 00 	cp.b	r10,r8
80007770:	c2 71       	brne	800077be <sd_mmc_spi_get_capacity+0x5e>
    c_size = ((csd[7] & 0x3F) << 16) | (csd[8] << 8) | csd[9];
80007772:	4b d8       	lddpc	r8,80007864 <sd_mmc_spi_get_capacity+0x104>
80007774:	f1 3a 00 08 	ld.ub	r10,r8[8]
80007778:	f1 39 00 09 	ld.ub	r9,r8[9]
8000777c:	f3 ea 10 89 	or	r9,r9,r10<<0x8
80007780:	11 fa       	ld.ub	r10,r8[0x7]
80007782:	f5 da c0 06 	bfextu	r10,r10,0x0,0x6
80007786:	f3 ea 11 0a 	or	r10,r9,r10<<0x10
    ++c_size;
8000778a:	2f fa       	sub	r10,-1
    capacity = (uint64_t)c_size << 19;
8000778c:	f4 0b 16 0d 	lsr	r11,r10,0xd
80007790:	16 99       	mov	r9,r11
80007792:	f4 08 15 13 	lsl	r8,r10,0x13
80007796:	4b 6a       	lddpc	r10,8000786c <sd_mmc_spi_get_capacity+0x10c>
80007798:	f4 e9 00 00 	st.d	r10[0],r8
    capacity_mult = (c_size >> 13) & 0x01FF;
8000779c:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
800077a0:	4b 48       	lddpc	r8,80007870 <sd_mmc_spi_get_capacity+0x110>
800077a2:	b0 0b       	st.h	r8[0x0],r11
    sd_mmc_spi_last_block_address = (capacity >> 9) + (capacity_mult << 23) - 1;
800077a4:	f4 ea 00 00 	ld.d	r10,r10[0]
800077a8:	90 09       	ld.sh	r9,r8[0x0]
800077aa:	f4 08 16 09 	lsr	r8,r10,0x9
800077ae:	f1 eb 11 78 	or	r8,r8,r11<<0x17
800077b2:	20 18       	sub	r8,1
800077b4:	b7 79       	lsl	r9,0x17
800077b6:	12 08       	add	r8,r9
800077b8:	4a f9       	lddpc	r9,80007874 <sd_mmc_spi_get_capacity+0x114>
800077ba:	93 08       	st.w	r9[0x0],r8
800077bc:	c4 28       	rjmp	80007840 <sd_mmc_spi_get_capacity+0xe0>
  } else {
    c_size      = ((csd[6] & 0x03) << 10) + (csd[7] << 2) + ((csd[8] & 0xC0) >> 6);
    c_size_mult = ((csd[9] & 0x03) << 1) + ((csd[10] & 0x80) >> 7);
800077be:	4a a8       	lddpc	r8,80007864 <sd_mmc_spi_get_capacity+0x104>
800077c0:	f1 3c 00 0a 	ld.ub	r12,r8[10]
    sd_mmc_spi_last_block_address = ((uint32_t)(c_size + 1) * (uint32_t)((1 << (c_size_mult + 2)))) - 1;
800077c4:	f1 39 00 08 	ld.ub	r9,r8[8]
800077c8:	a7 89       	lsr	r9,0x6
800077ca:	11 fe       	ld.ub	lr,r8[0x7]
800077cc:	f2 0e 00 29 	add	r9,r9,lr<<0x2
800077d0:	11 ee       	ld.ub	lr,r8[0x6]
800077d2:	fd de c0 02 	bfextu	lr,lr,0x0,0x2
800077d6:	ab 6e       	lsl	lr,0xa
800077d8:	1c 09       	add	r9,lr
800077da:	2f f9       	sub	r9,-1
800077dc:	f1 38 00 09 	ld.ub	r8,r8[9]
800077e0:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800077e4:	f8 0e 16 07 	lsr	lr,r12,0x7
800077e8:	fc 08 00 18 	add	r8,lr,r8<<0x1
800077ec:	2f e8       	sub	r8,-2
800077ee:	f2 08 09 49 	lsl	r9,r9,r8
800077f2:	20 19       	sub	r9,1
800077f4:	4a 08       	lddpc	r8,80007874 <sd_mmc_spi_get_capacity+0x114>
800077f6:	91 09       	st.w	r8[0x0],r9
    capacity = (1 << read_bl_len) * (sd_mmc_spi_last_block_address + 1);
800077f8:	70 0e       	ld.w	lr,r8[0x0]
800077fa:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
800077fe:	2f fe       	sub	lr,-1
80007800:	fc 0b 09 48 	lsl	r8,lr,r11
80007804:	30 09       	mov	r9,0
80007806:	49 ae       	lddpc	lr,8000786c <sd_mmc_spi_get_capacity+0x10c>
80007808:	fc e9 00 00 	st.d	lr[0],r8
    capacity_mult = 0;
8000780c:	49 98       	lddpc	r8,80007870 <sd_mmc_spi_get_capacity+0x110>
8000780e:	b0 09       	st.h	r8[0x0],r9
    if (read_bl_len > 9) {  // 9 means 2^9 = 512b
80007810:	30 98       	mov	r8,9
80007812:	f0 0b 18 00 	cp.b	r11,r8
80007816:	e0 88 00 08 	brls	80007826 <sd_mmc_spi_get_capacity+0xc6>
      sd_mmc_spi_last_block_address <<= (read_bl_len - 9);
8000781a:	49 78       	lddpc	r8,80007874 <sd_mmc_spi_get_capacity+0x114>
8000781c:	70 09       	ld.w	r9,r8[0x0]
8000781e:	20 9b       	sub	r11,9
80007820:	f2 0b 09 4b 	lsl	r11,r9,r11
80007824:	91 0b       	st.w	r8[0x0],r11
    }
  }
  if (card_type == MMC_CARD)
80007826:	58 0a       	cp.w	r10,0
80007828:	c0 c1       	brne	80007840 <sd_mmc_spi_get_capacity+0xe0>
  {
    erase_grp_size = ((csd[10] & 0x7C) >> 2);
8000782a:	f1 dc c0 45 	bfextu	r8,r12,0x2,0x5
    erase_grp_mult = ((csd[10] & 0x03) << 3) | ((csd[11] & 0xE0) >> 5);
8000782e:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80007832:	48 d9       	lddpc	r9,80007864 <sd_mmc_spi_get_capacity+0x104>
80007834:	f3 39 00 0b 	ld.ub	r9,r9[11]
80007838:	a3 7c       	lsl	r12,0x3
8000783a:	f9 e9 12 59 	or	r9,r12,r9>>0x5
8000783e:	c0 c8       	rjmp	80007856 <sd_mmc_spi_get_capacity+0xf6>
  }
  else
  {
    erase_grp_size = ((csd[10] & 0x3F) << 1) + ((csd[11] & 0x80) >> 7);
80007840:	48 9a       	lddpc	r10,80007864 <sd_mmc_spi_get_capacity+0x104>
80007842:	f5 39 00 0a 	ld.ub	r9,r10[10]
80007846:	f3 d9 c0 06 	bfextu	r9,r9,0x0,0x6
8000784a:	f5 38 00 0b 	ld.ub	r8,r10[11]
8000784e:	a7 98       	lsr	r8,0x7
80007850:	f0 09 00 18 	add	r8,r8,r9<<0x1
80007854:	30 09       	mov	r9,0
    erase_grp_mult = 0;
  }
  erase_group_size = (erase_grp_size + 1) * (erase_grp_mult + 1);
80007856:	2f f9       	sub	r9,-1
80007858:	2f f8       	sub	r8,-1
8000785a:	b1 39       	mul	r9,r8
8000785c:	48 78       	lddpc	r8,80007878 <sd_mmc_spi_get_capacity+0x118>
8000785e:	b0 09       	st.h	r8[0x0],r9
}
80007860:	d8 02       	popm	pc
80007862:	00 00       	add	r0,r0
80007864:	00 00       	add	r0,r0
80007866:	09 c0       	ld.ub	r0,r4[0x4]
80007868:	00 00       	add	r0,r0
8000786a:	09 be       	ld.ub	lr,r4[0x3]
8000786c:	00 00       	add	r0,r0
8000786e:	09 ac       	ld.ub	r12,r4[0x2]
80007870:	00 00       	add	r0,r0
80007872:	09 b4       	ld.ub	r4,r4[0x3]
80007874:	00 00       	add	r0,r0
80007876:	09 b8       	ld.ub	r8,r4[0x3]
80007878:	00 00       	add	r0,r0
8000787a:	09 b6       	ld.ub	r6,r4[0x3]

8000787c <sd_mmc_spi_write_close>:
//! page programming.
//!
void sd_mmc_spi_write_close (void)
{

}
8000787c:	5e fc       	retal	r12
8000787e:	d7 03       	nop

80007880 <sd_mmc_spi_read_close_PDCA>:
//! Stop PDCA transfer
//! @brief This function closes a PDCA read transfer
//! page programming.
//!
void sd_mmc_spi_read_close_PDCA (void)
{
80007880:	d4 01       	pushm	lr

  // load 16-bit CRC (ignored)
  spi_write(SD_MMC_SPI,0xFF);
80007882:	e0 6b 00 ff 	mov	r11,255
80007886:	fe 7c 24 00 	mov	r12,-56320
8000788a:	f0 1f 00 0e 	mcall	800078c0 <sd_mmc_spi_read_close_PDCA+0x40>
  spi_write(SD_MMC_SPI,0xFF);
8000788e:	e0 6b 00 ff 	mov	r11,255
80007892:	fe 7c 24 00 	mov	r12,-56320
80007896:	f0 1f 00 0b 	mcall	800078c0 <sd_mmc_spi_read_close_PDCA+0x40>

  // continue delivering some clock cycles
  spi_write(SD_MMC_SPI,0xFF);
8000789a:	e0 6b 00 ff 	mov	r11,255
8000789e:	fe 7c 24 00 	mov	r12,-56320
800078a2:	f0 1f 00 08 	mcall	800078c0 <sd_mmc_spi_read_close_PDCA+0x40>
  spi_write(SD_MMC_SPI,0xFF);
800078a6:	e0 6b 00 ff 	mov	r11,255
800078aa:	fe 7c 24 00 	mov	r12,-56320
800078ae:	f0 1f 00 05 	mcall	800078c0 <sd_mmc_spi_read_close_PDCA+0x40>

  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800078b2:	30 1b       	mov	r11,1
800078b4:	fe 7c 24 00 	mov	r12,-56320
800078b8:	f0 1f 00 03 	mcall	800078c4 <sd_mmc_spi_read_close_PDCA+0x44>

}
800078bc:	d8 02       	popm	pc
800078be:	00 00       	add	r0,r0
800078c0:	80 00       	ld.sh	r0,r0[0x0]
800078c2:	8b 8a       	st.w	r5[0x20],r10
800078c4:	80 00       	ld.sh	r0,r0[0x0]
800078c6:	8a a6       	ld.uh	r6,r5[0x4]

800078c8 <sd_mmc_spi_send_and_read>:
//! @param  data_to_send   byte to send over SPI
//!
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
800078c8:	d4 01       	pushm	lr
800078ca:	20 1d       	sub	sp,4
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
800078cc:	18 9b       	mov	r11,r12
800078ce:	fe 7c 24 00 	mov	r12,-56320
800078d2:	f0 1f 00 09 	mcall	800078f4 <sd_mmc_spi_send_and_read+0x2c>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
800078d6:	fa cb ff fe 	sub	r11,sp,-2
800078da:	fe 7c 24 00 	mov	r12,-56320
800078de:	f0 1f 00 07 	mcall	800078f8 <sd_mmc_spi_send_and_read+0x30>
800078e2:	58 1c       	cp.w	r12,1
800078e4:	c0 41       	brne	800078ec <sd_mmc_spi_send_and_read+0x24>
800078e6:	e0 6c 00 ff 	mov	r12,255
800078ea:	c0 28       	rjmp	800078ee <sd_mmc_spi_send_and_read+0x26>
     return 0xFF;
   return data_read;
800078ec:	1b bc       	ld.ub	r12,sp[0x3]
}
800078ee:	2f fd       	sub	sp,-4
800078f0:	d8 02       	popm	pc
800078f2:	00 00       	add	r0,r0
800078f4:	80 00       	ld.sh	r0,r0[0x0]
800078f6:	8b 8a       	st.w	r5[0x20],r10
800078f8:	80 00       	ld.sh	r0,r0[0x0]
800078fa:	8b a6       	st.w	r5[0x28],r6

800078fc <sd_mmc_spi_wait_not_busy>:
//! @brief This function waits until the SD/MMC is not busy.
//!
//! @return bit
//!          true when card is not busy
bool sd_mmc_spi_wait_not_busy(void)
{
800078fc:	d4 21       	pushm	r4-r7,lr
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
800078fe:	30 1b       	mov	r11,1
80007900:	fe 7c 24 00 	mov	r12,-56320
80007904:	f0 1f 00 10 	mcall	80007944 <sd_mmc_spi_wait_not_busy+0x48>
80007908:	30 07       	mov	r7,0
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
8000790a:	e0 65 00 ff 	mov	r5,255
8000790e:	48 f4       	lddpc	r4,80007948 <sd_mmc_spi_wait_not_busy+0x4c>
80007910:	3f f6       	mov	r6,-1
80007912:	c0 b8       	rjmp	80007928 <sd_mmc_spi_wait_not_busy+0x2c>
  {
    retry++;
80007914:	2f f7       	sub	r7,-1
    if (retry == 200000)
80007916:	e2 57 0d 40 	cp.w	r7,200000
8000791a:	c0 71       	brne	80007928 <sd_mmc_spi_wait_not_busy+0x2c>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000791c:	30 1b       	mov	r11,1
8000791e:	fe 7c 24 00 	mov	r12,-56320
80007922:	f0 1f 00 0b 	mcall	8000794c <sd_mmc_spi_wait_not_busy+0x50>
80007926:	d8 2a       	popm	r4-r7,pc,r12=0
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
80007928:	0a 9c       	mov	r12,r5
8000792a:	f0 1f 00 0a 	mcall	80007950 <sd_mmc_spi_wait_not_busy+0x54>
8000792e:	a8 8c       	st.b	r4[0x0],r12
80007930:	ec 0c 18 00 	cp.b	r12,r6
80007934:	cf 01       	brne	80007914 <sd_mmc_spi_wait_not_busy+0x18>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
      return false;
    }
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80007936:	30 1b       	mov	r11,1
80007938:	fe 7c 24 00 	mov	r12,-56320
8000793c:	f0 1f 00 04 	mcall	8000794c <sd_mmc_spi_wait_not_busy+0x50>
80007940:	da 2a       	popm	r4-r7,pc,r12=1
80007942:	00 00       	add	r0,r0
80007944:	80 00       	ld.sh	r0,r0[0x0]
80007946:	8a 5a       	ld.sh	r10,r5[0xa]
80007948:	00 00       	add	r0,r0
8000794a:	09 d0       	ld.ub	r0,r4[0x5]
8000794c:	80 00       	ld.sh	r0,r0[0x0]
8000794e:	8a a6       	ld.uh	r6,r5[0x4]
80007950:	80 00       	ld.sh	r0,r0[0x0]
80007952:	78 c8       	ld.w	r8,r12[0x30]

80007954 <sd_mmc_spi_write_open>:
//! @param  pos   Sector address
//!
//! @return bit
//!   The open succeeded      -> true
bool sd_mmc_spi_write_open (uint32_t pos)
{
80007954:	d4 01       	pushm	lr
  // Set the global memory ptr at a Byte address.
  gl_ptr_mem = pos << 9; // gl_ptr_mem = pos * 512
80007956:	a9 7c       	lsl	r12,0x9
80007958:	48 38       	lddpc	r8,80007964 <sd_mmc_spi_write_open+0x10>
8000795a:	91 0c       	st.w	r8[0x0],r12

  // wait for MMC not busy
  return sd_mmc_spi_wait_not_busy();
8000795c:	f0 1f 00 03 	mcall	80007968 <sd_mmc_spi_write_open+0x14>
}
80007960:	d8 02       	popm	pc
80007962:	00 00       	add	r0,r0
80007964:	00 00       	add	r0,r0
80007966:	06 48       	or	r8,r3
80007968:	80 00       	ld.sh	r0,r0[0x0]
8000796a:	78 fc       	ld.w	r12,r12[0x3c]

8000796c <sd_mmc_spi_read_close>:

//!
//! @brief This function unselects the current SD_MMC memory.
//!
bool sd_mmc_spi_read_close (void)
{
8000796c:	d4 01       	pushm	lr
  if (false == sd_mmc_spi_wait_not_busy())
8000796e:	f0 1f 00 02 	mcall	80007974 <sd_mmc_spi_read_close+0x8>
    return false;
  return true;
}
80007972:	d8 02       	popm	pc
80007974:	80 00       	ld.sh	r0,r0[0x0]
80007976:	78 fc       	ld.w	r12,r12[0x3c]

80007978 <sd_mmc_spi_read_open>:
//! @param  pos   Sector address
//!
//! @return bit
//!   The open succeeded      -> true
bool sd_mmc_spi_read_open (uint32_t pos)
{
80007978:	d4 01       	pushm	lr
  // Set the global memory ptr at a Byte address.
  gl_ptr_mem = pos << 9;        // gl_ptr_mem = pos * 512
8000797a:	a9 7c       	lsl	r12,0x9
8000797c:	48 38       	lddpc	r8,80007988 <sd_mmc_spi_read_open+0x10>
8000797e:	91 0c       	st.w	r8[0x0],r12

  // wait for MMC not busy
  return sd_mmc_spi_wait_not_busy();
80007980:	f0 1f 00 03 	mcall	8000798c <sd_mmc_spi_read_open+0x14>
}
80007984:	d8 02       	popm	pc
80007986:	00 00       	add	r0,r0
80007988:	00 00       	add	r0,r0
8000798a:	06 48       	or	r8,r3
8000798c:	80 00       	ld.sh	r0,r0[0x0]
8000798e:	78 fc       	ld.w	r12,r12[0x3c]

80007990 <sd_mmc_spi_command>:
//! @param  arg       argument of the command
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF time out error)
uint8_t sd_mmc_spi_command(uint8_t command, uint32_t arg)
{
80007990:	eb cd 40 f8 	pushm	r3-r7,lr
80007994:	18 96       	mov	r6,r12
80007996:	16 97       	mov	r7,r11
  uint8_t retry;

  spi_write(SD_MMC_SPI, 0xFF);            // write dummy byte
80007998:	e0 6b 00 ff 	mov	r11,255
8000799c:	fe 7c 24 00 	mov	r12,-56320
800079a0:	f0 1f 00 2b 	mcall	80007a4c <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, command | 0x40);  // send command
800079a4:	0c 9b       	mov	r11,r6
800079a6:	a7 ab       	sbr	r11,0x6
800079a8:	5c 5b       	castu.b	r11
800079aa:	fe 7c 24 00 	mov	r12,-56320
800079ae:	f0 1f 00 28 	mcall	80007a4c <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg>>24);         // send parameter
800079b2:	ee 0b 16 18 	lsr	r11,r7,0x18
800079b6:	fe 7c 24 00 	mov	r12,-56320
800079ba:	f0 1f 00 25 	mcall	80007a4c <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg>>16);
800079be:	ee 0b 16 10 	lsr	r11,r7,0x10
800079c2:	fe 7c 24 00 	mov	r12,-56320
800079c6:	f0 1f 00 22 	mcall	80007a4c <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg>>8 );
800079ca:	f7 d7 c1 10 	bfextu	r11,r7,0x8,0x10
800079ce:	fe 7c 24 00 	mov	r12,-56320
800079d2:	f0 1f 00 1f 	mcall	80007a4c <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg    );
800079d6:	0e 9b       	mov	r11,r7
800079d8:	5c 7b       	castu.h	r11
800079da:	fe 7c 24 00 	mov	r12,-56320
800079de:	f0 1f 00 1c 	mcall	80007a4c <sd_mmc_spi_command+0xbc>
  switch(command)
800079e2:	30 08       	mov	r8,0
800079e4:	f0 06 18 00 	cp.b	r6,r8
800079e8:	c0 60       	breq	800079f4 <sd_mmc_spi_command+0x64>
800079ea:	30 88       	mov	r8,8
800079ec:	f0 06 18 00 	cp.b	r6,r8
800079f0:	c1 01       	brne	80007a10 <sd_mmc_spi_command+0x80>
800079f2:	c0 88       	rjmp	80007a02 <sd_mmc_spi_command+0x72>
  {
      case MMC_GO_IDLE_STATE:
         spi_write(SD_MMC_SPI, 0x95);
800079f4:	e0 6b 00 95 	mov	r11,149
800079f8:	fe 7c 24 00 	mov	r12,-56320
800079fc:	f0 1f 00 14 	mcall	80007a4c <sd_mmc_spi_command+0xbc>
         break;
80007a00:	c0 e8       	rjmp	80007a1c <sd_mmc_spi_command+0x8c>
      case MMC_SEND_IF_COND:
         spi_write(SD_MMC_SPI, 0x87);
80007a02:	e0 6b 00 87 	mov	r11,135
80007a06:	fe 7c 24 00 	mov	r12,-56320
80007a0a:	f0 1f 00 11 	mcall	80007a4c <sd_mmc_spi_command+0xbc>
         break;
80007a0e:	c0 78       	rjmp	80007a1c <sd_mmc_spi_command+0x8c>
      default:
         spi_write(SD_MMC_SPI, 0xff);
80007a10:	e0 6b 00 ff 	mov	r11,255
80007a14:	fe 7c 24 00 	mov	r12,-56320
80007a18:	f0 1f 00 0d 	mcall	80007a4c <sd_mmc_spi_command+0xbc>

  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
80007a1c:	3f f9       	mov	r9,-1
80007a1e:	48 d8       	lddpc	r8,80007a50 <sd_mmc_spi_command+0xc0>
80007a20:	b0 89       	st.b	r8[0x0],r9
80007a22:	30 07       	mov	r7,0
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80007a24:	e0 64 00 ff 	mov	r4,255
80007a28:	10 93       	mov	r3,r8
80007a2a:	12 96       	mov	r6,r9
  {
    retry++;
    if(retry > 10) break;
80007a2c:	30 b5       	mov	r5,11
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80007a2e:	c0 68       	rjmp	80007a3a <sd_mmc_spi_command+0xaa>
  {
    retry++;
80007a30:	2f f7       	sub	r7,-1
80007a32:	5c 57       	castu.b	r7
    if(retry > 10) break;
80007a34:	ea 07 18 00 	cp.b	r7,r5
80007a38:	c0 80       	breq	80007a48 <sd_mmc_spi_command+0xb8>
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80007a3a:	08 9c       	mov	r12,r4
80007a3c:	f0 1f 00 06 	mcall	80007a54 <sd_mmc_spi_command+0xc4>
80007a40:	a6 8c       	st.b	r3[0x0],r12
80007a42:	ec 0c 18 00 	cp.b	r12,r6
80007a46:	cf 50       	breq	80007a30 <sd_mmc_spi_command+0xa0>
  {
    retry++;
    if(retry > 10) break;
  }
  return r1;
}
80007a48:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80007a4c:	80 00       	ld.sh	r0,r0[0x0]
80007a4e:	8b 8a       	st.w	r5[0x20],r10
80007a50:	00 00       	add	r0,r0
80007a52:	09 d0       	ld.ub	r0,r4[0x5]
80007a54:	80 00       	ld.sh	r0,r0[0x0]
80007a56:	78 c8       	ld.w	r8,r12[0x30]

80007a58 <sd_mmc_spi_send_command>:
//! @param  arg       argument of the command
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
80007a58:	eb cd 40 c0 	pushm	r6-r7,lr
80007a5c:	18 97       	mov	r7,r12
80007a5e:	16 96       	mov	r6,r11
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80007a60:	30 1b       	mov	r11,1
80007a62:	fe 7c 24 00 	mov	r12,-56320
80007a66:	f0 1f 00 09 	mcall	80007a88 <sd_mmc_spi_send_command+0x30>
  r1 = sd_mmc_spi_command(command, arg);
80007a6a:	0c 9b       	mov	r11,r6
80007a6c:	0e 9c       	mov	r12,r7
80007a6e:	f0 1f 00 08 	mcall	80007a8c <sd_mmc_spi_send_command+0x34>
80007a72:	48 87       	lddpc	r7,80007a90 <sd_mmc_spi_send_command+0x38>
80007a74:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80007a76:	30 1b       	mov	r11,1
80007a78:	fe 7c 24 00 	mov	r12,-56320
80007a7c:	f0 1f 00 06 	mcall	80007a94 <sd_mmc_spi_send_command+0x3c>
  return r1;
}
80007a80:	0f 8c       	ld.ub	r12,r7[0x0]
80007a82:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007a86:	00 00       	add	r0,r0
80007a88:	80 00       	ld.sh	r0,r0[0x0]
80007a8a:	8a 5a       	ld.sh	r10,r5[0xa]
80007a8c:	80 00       	ld.sh	r0,r0[0x0]
80007a8e:	79 90       	ld.w	r0,r12[0x64]
80007a90:	00 00       	add	r0,r0
80007a92:	09 d0       	ld.ub	r0,r4[0x5]
80007a94:	80 00       	ld.sh	r0,r0[0x0]
80007a96:	8a a6       	ld.uh	r6,r5[0x4]

80007a98 <sd_mmc_spi_check_presence>:
//!
//! @return bit
//!   The memory is present (true)
//!   The memory does not respond (disconnected) (false)
bool sd_mmc_spi_check_presence(void)
{
80007a98:	eb cd 40 fe 	pushm	r1-r7,lr
  uint16_t retry;

  retry = 0;
  if (sd_mmc_spi_init_done == false)
80007a9c:	49 a8       	lddpc	r8,80007b04 <sd_mmc_spi_check_presence+0x6c>
80007a9e:	11 89       	ld.ub	r9,r8[0x0]
80007aa0:	30 08       	mov	r8,0
80007aa2:	f0 09 18 00 	cp.b	r9,r8
80007aa6:	c1 f1       	brne	80007ae4 <sd_mmc_spi_check_presence+0x4c>
80007aa8:	30 07       	mov	r7,0
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80007aaa:	0e 94       	mov	r4,r7
80007aac:	49 73       	lddpc	r3,80007b08 <sd_mmc_spi_check_presence+0x70>
80007aae:	30 16       	mov	r6,1
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80007ab0:	e0 62 00 ff 	mov	r2,255
80007ab4:	fe 71 24 00 	mov	r1,-56320
      retry++;
      if (retry > 10)
80007ab8:	30 b5       	mov	r5,11
80007aba:	c0 c8       	rjmp	80007ad2 <sd_mmc_spi_check_presence+0x3a>
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80007abc:	04 9b       	mov	r11,r2
80007abe:	02 9c       	mov	r12,r1
80007ac0:	f0 1f 00 13 	mcall	80007b0c <sd_mmc_spi_check_presence+0x74>
      retry++;
80007ac4:	2f f7       	sub	r7,-1
80007ac6:	5c 87       	casts.h	r7
      if (retry > 10)
80007ac8:	ea 07 19 00 	cp.h	r7,r5
80007acc:	c0 31       	brne	80007ad2 <sd_mmc_spi_check_presence+0x3a>
80007ace:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80007ad2:	08 9b       	mov	r11,r4
80007ad4:	08 9c       	mov	r12,r4
80007ad6:	f0 1f 00 0f 	mcall	80007b10 <sd_mmc_spi_check_presence+0x78>
80007ada:	a6 8c       	st.b	r3[0x0],r12
80007adc:	ec 0c 18 00 	cp.b	r12,r6
80007ae0:	ce e1       	brne	80007abc <sd_mmc_spi_check_presence+0x24>
80007ae2:	c0 e8       	rjmp	80007afe <sd_mmc_spi_check_presence+0x66>
    return true;
  }
  else
  {
    // If memory already initialized, send a CRC command (CMD59) (supported only if card is initialized)
    if ((r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0)) == 0x00)
80007ae4:	30 0b       	mov	r11,0
80007ae6:	33 bc       	mov	r12,59
80007ae8:	f0 1f 00 0a 	mcall	80007b10 <sd_mmc_spi_check_presence+0x78>
80007aec:	48 78       	lddpc	r8,80007b08 <sd_mmc_spi_check_presence+0x70>
80007aee:	b0 8c       	st.b	r8[0x0],r12
80007af0:	58 0c       	cp.w	r12,0
80007af2:	c0 60       	breq	80007afe <sd_mmc_spi_check_presence+0x66>
      return true;
    sd_mmc_spi_init_done = false;
80007af4:	30 09       	mov	r9,0
80007af6:	48 48       	lddpc	r8,80007b04 <sd_mmc_spi_check_presence+0x6c>
80007af8:	b0 89       	st.b	r8[0x0],r9
80007afa:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
    return false;
80007afe:	e3 cf 90 fe 	ldm	sp++,r1-r7,pc,r12=1
80007b02:	00 00       	add	r0,r0
80007b04:	00 00       	add	r0,r0
80007b06:	06 60       	and	r0,r3
80007b08:	00 00       	add	r0,r0
80007b0a:	09 d0       	ld.ub	r0,r4[0x5]
80007b0c:	80 00       	ld.sh	r0,r0[0x0]
80007b0e:	8b 8a       	st.w	r5[0x20],r10
80007b10:	80 00       	ld.sh	r0,r0[0x0]
80007b12:	7a 58       	ld.w	r8,sp[0x14]

80007b14 <sd_mmc_spi_write_sector_from_ram>:
//! @return bit
//!   The write succeeded   -> true
//!   The write failed      -> false
//!
bool sd_mmc_spi_write_sector_from_ram(const void *ram)
{
80007b14:	eb cd 40 e0 	pushm	r5-r7,lr
80007b18:	18 97       	mov	r7,r12
  const uint8_t *_ram = ram;
  uint16_t i;

  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80007b1a:	f0 1f 00 49 	mcall	80007c3c <sd_mmc_spi_write_sector_from_ram+0x128>
80007b1e:	e0 80 00 8c 	breq	80007c36 <sd_mmc_spi_write_sector_from_ram+0x122>
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80007b22:	30 1b       	mov	r11,1
80007b24:	fe 7c 24 00 	mov	r12,-56320
80007b28:	f0 1f 00 46 	mcall	80007c40 <sd_mmc_spi_write_sector_from_ram+0x12c>

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
80007b2c:	4c 68       	lddpc	r8,80007c44 <sd_mmc_spi_write_sector_from_ram+0x130>
80007b2e:	11 89       	ld.ub	r9,r8[0x0]
80007b30:	30 38       	mov	r8,3
80007b32:	f0 09 18 00 	cp.b	r9,r8
80007b36:	c0 a1       	brne	80007b4a <sd_mmc_spi_write_sector_from_ram+0x36>
    r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem>>9);
80007b38:	4c 48       	lddpc	r8,80007c48 <sd_mmc_spi_write_sector_from_ram+0x134>
80007b3a:	70 0b       	ld.w	r11,r8[0x0]
80007b3c:	a9 9b       	lsr	r11,0x9
80007b3e:	31 8c       	mov	r12,24
80007b40:	f0 1f 00 43 	mcall	80007c4c <sd_mmc_spi_write_sector_from_ram+0x138>
80007b44:	4c 38       	lddpc	r8,80007c50 <sd_mmc_spi_write_sector_from_ram+0x13c>
80007b46:	b0 8c       	st.b	r8[0x0],r12
80007b48:	c0 88       	rjmp	80007b58 <sd_mmc_spi_write_sector_from_ram+0x44>
  } else {
    r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem);
80007b4a:	4c 08       	lddpc	r8,80007c48 <sd_mmc_spi_write_sector_from_ram+0x134>
80007b4c:	70 0b       	ld.w	r11,r8[0x0]
80007b4e:	31 8c       	mov	r12,24
80007b50:	f0 1f 00 3f 	mcall	80007c4c <sd_mmc_spi_write_sector_from_ram+0x138>
80007b54:	4b f8       	lddpc	r8,80007c50 <sd_mmc_spi_write_sector_from_ram+0x13c>
80007b56:	b0 8c       	st.b	r8[0x0],r12
  }

  // check for valid response
  if(r1 != 0x00)
80007b58:	4b e8       	lddpc	r8,80007c50 <sd_mmc_spi_write_sector_from_ram+0x13c>
80007b5a:	11 89       	ld.ub	r9,r8[0x0]
80007b5c:	30 08       	mov	r8,0
80007b5e:	f0 09 18 00 	cp.b	r9,r8
80007b62:	c0 80       	breq	80007b72 <sd_mmc_spi_write_sector_from_ram+0x5e>
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80007b64:	30 1b       	mov	r11,1
80007b66:	fe 7c 24 00 	mov	r12,-56320
80007b6a:	f0 1f 00 3b 	mcall	80007c54 <sd_mmc_spi_write_sector_from_ram+0x140>
80007b6e:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
    return false;
  }
  // send dummy
  spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction
80007b72:	e0 6b 00 ff 	mov	r11,255
80007b76:	fe 7c 24 00 	mov	r12,-56320
80007b7a:	f0 1f 00 38 	mcall	80007c58 <sd_mmc_spi_write_sector_from_ram+0x144>

  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
80007b7e:	e0 6b 00 fe 	mov	r11,254
80007b82:	fe 7c 24 00 	mov	r12,-56320
80007b86:	f0 1f 00 35 	mcall	80007c58 <sd_mmc_spi_write_sector_from_ram+0x144>
//!
//! @return bit
//!   The write succeeded   -> true
//!   The write failed      -> false
//!
bool sd_mmc_spi_write_sector_from_ram(const void *ram)
80007b8a:	ee c6 fe 00 	sub	r6,r7,-512
  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
  // write data
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,*_ram++);
80007b8e:	fe 75 24 00 	mov	r5,-56320
80007b92:	0f 3b       	ld.ub	r11,r7++
80007b94:	0a 9c       	mov	r12,r5
80007b96:	f0 1f 00 31 	mcall	80007c58 <sd_mmc_spi_write_sector_from_ram+0x144>
  spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction

  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
  // write data
  for(i=0;i<MMC_SECTOR_SIZE;i++)
80007b9a:	0c 37       	cp.w	r7,r6
80007b9c:	cf b1       	brne	80007b92 <sd_mmc_spi_write_sector_from_ram+0x7e>
  {
    spi_write(SD_MMC_SPI,*_ram++);
  }

  spi_write(SD_MMC_SPI,0xFF);    // send CRC (field required but value ignored)
80007b9e:	e0 6b 00 ff 	mov	r11,255
80007ba2:	fe 7c 24 00 	mov	r12,-56320
80007ba6:	f0 1f 00 2d 	mcall	80007c58 <sd_mmc_spi_write_sector_from_ram+0x144>
  spi_write(SD_MMC_SPI,0xFF);
80007baa:	e0 6b 00 ff 	mov	r11,255
80007bae:	fe 7c 24 00 	mov	r12,-56320
80007bb2:	f0 1f 00 2a 	mcall	80007c58 <sd_mmc_spi_write_sector_from_ram+0x144>

  // read data response token
  r1 = sd_mmc_spi_send_and_read(0xFF);
80007bb6:	e0 6c 00 ff 	mov	r12,255
80007bba:	f0 1f 00 29 	mcall	80007c5c <sd_mmc_spi_write_sector_from_ram+0x148>
80007bbe:	4a 58       	lddpc	r8,80007c50 <sd_mmc_spi_write_sector_from_ram+0x13c>
80007bc0:	b0 8c       	st.b	r8[0x0],r12
  if( (r1&MMC_DR_MASK) != MMC_DR_ACCEPT)
80007bc2:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80007bc6:	58 5c       	cp.w	r12,5
80007bc8:	c1 40       	breq	80007bf0 <sd_mmc_spi_write_sector_from_ram+0xdc>
  {
    spi_write(SD_MMC_SPI,0xFF);    // send dummy bytes
80007bca:	e0 6b 00 ff 	mov	r11,255
80007bce:	fe 7c 24 00 	mov	r12,-56320
80007bd2:	f0 1f 00 22 	mcall	80007c58 <sd_mmc_spi_write_sector_from_ram+0x144>
    spi_write(SD_MMC_SPI,0xFF);
80007bd6:	e0 6b 00 ff 	mov	r11,255
80007bda:	fe 7c 24 00 	mov	r12,-56320
80007bde:	f0 1f 00 1f 	mcall	80007c58 <sd_mmc_spi_write_sector_from_ram+0x144>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80007be2:	30 1b       	mov	r11,1
80007be4:	fe 7c 24 00 	mov	r12,-56320
80007be8:	f0 1f 00 1b 	mcall	80007c54 <sd_mmc_spi_write_sector_from_ram+0x140>
80007bec:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
    return false;         // return ERROR byte
  }

  spi_write(SD_MMC_SPI,0xFF);    // send dummy bytes
80007bf0:	e0 6b 00 ff 	mov	r11,255
80007bf4:	fe 7c 24 00 	mov	r12,-56320
80007bf8:	f0 1f 00 18 	mcall	80007c58 <sd_mmc_spi_write_sector_from_ram+0x144>
  spi_write(SD_MMC_SPI,0xFF);
80007bfc:	e0 6b 00 ff 	mov	r11,255
80007c00:	fe 7c 24 00 	mov	r12,-56320
80007c04:	f0 1f 00 15 	mcall	80007c58 <sd_mmc_spi_write_sector_from_ram+0x144>

  // release chip select
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80007c08:	30 1b       	mov	r11,1
80007c0a:	fe 7c 24 00 	mov	r12,-56320
80007c0e:	f0 1f 00 12 	mcall	80007c54 <sd_mmc_spi_write_sector_from_ram+0x140>
  gl_ptr_mem += 512;        // Update the memory pointer.
80007c12:	48 e8       	lddpc	r8,80007c48 <sd_mmc_spi_write_sector_from_ram+0x134>
80007c14:	70 09       	ld.w	r9,r8[0x0]
80007c16:	f2 c9 fe 00 	sub	r9,r9,-512
80007c1a:	91 09       	st.w	r8[0x0],r9
80007c1c:	30 07       	mov	r7,0
  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
  {
    i++;
    if (i == 10)
80007c1e:	30 a6       	mov	r6,10
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
  gl_ptr_mem += 512;        // Update the memory pointer.

  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
80007c20:	c0 68       	rjmp	80007c2c <sd_mmc_spi_write_sector_from_ram+0x118>
  {
    i++;
80007c22:	2f f7       	sub	r7,-1
80007c24:	5c 87       	casts.h	r7
    if (i == 10)
80007c26:	ec 07 19 00 	cp.h	r7,r6
80007c2a:	c0 60       	breq	80007c36 <sd_mmc_spi_write_sector_from_ram+0x122>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
  gl_ptr_mem += 512;        // Update the memory pointer.

  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
80007c2c:	f0 1f 00 04 	mcall	80007c3c <sd_mmc_spi_write_sector_from_ram+0x128>
80007c30:	cf 90       	breq	80007c22 <sd_mmc_spi_write_sector_from_ram+0x10e>
80007c32:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80007c36:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80007c3a:	00 00       	add	r0,r0
80007c3c:	80 00       	ld.sh	r0,r0[0x0]
80007c3e:	78 fc       	ld.w	r12,r12[0x3c]
80007c40:	80 00       	ld.sh	r0,r0[0x0]
80007c42:	8a 5a       	ld.sh	r10,r5[0xa]
80007c44:	00 00       	add	r0,r0
80007c46:	09 be       	ld.ub	lr,r4[0x3]
80007c48:	00 00       	add	r0,r0
80007c4a:	06 48       	or	r8,r3
80007c4c:	80 00       	ld.sh	r0,r0[0x0]
80007c4e:	79 90       	ld.w	r0,r12[0x64]
80007c50:	00 00       	add	r0,r0
80007c52:	09 d0       	ld.ub	r0,r4[0x5]
80007c54:	80 00       	ld.sh	r0,r0[0x0]
80007c56:	8a a6       	ld.uh	r6,r5[0x4]
80007c58:	80 00       	ld.sh	r0,r0[0x0]
80007c5a:	8b 8a       	st.w	r5[0x20],r10
80007c5c:	80 00       	ld.sh	r0,r0[0x0]
80007c5e:	78 c8       	ld.w	r8,r12[0x30]

80007c60 <sd_mmc_spi_check_hc>:
//!           SD_CARD      Detected card is SD
//!           ERROR


int sd_mmc_spi_check_hc(void)
{
80007c60:	eb cd 40 c0 	pushm	r6-r7,lr
  unsigned char hc_bit;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80007c64:	f0 1f 00 1c 	mcall	80007cd4 <sd_mmc_spi_check_hc+0x74>
80007c68:	c0 31       	brne	80007c6e <sd_mmc_spi_check_hc+0xe>
80007c6a:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
    return SD_FAILURE;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80007c6e:	30 1b       	mov	r11,1
80007c70:	fe 7c 24 00 	mov	r12,-56320
80007c74:	f0 1f 00 19 	mcall	80007cd8 <sd_mmc_spi_check_hc+0x78>
  r1 = sd_mmc_spi_command(SD_READ_OCR, 0);
80007c78:	30 0b       	mov	r11,0
80007c7a:	33 ac       	mov	r12,58
80007c7c:	f0 1f 00 18 	mcall	80007cdc <sd_mmc_spi_check_hc+0x7c>
80007c80:	49 88       	lddpc	r8,80007ce0 <sd_mmc_spi_check_hc+0x80>
80007c82:	b0 8c       	st.b	r8[0x0],r12
  // check for valid response
  if(r1 != 0) {
80007c84:	58 0c       	cp.w	r12,0
80007c86:	c0 80       	breq	80007c96 <sd_mmc_spi_check_hc+0x36>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80007c88:	30 1b       	mov	r11,1
80007c8a:	fe 7c 24 00 	mov	r12,-56320
80007c8e:	f0 1f 00 16 	mcall	80007ce4 <sd_mmc_spi_check_hc+0x84>
80007c92:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
    return SD_FAILURE;
  }
  hc_bit = sd_mmc_spi_send_and_read(0xFF);
80007c96:	e0 6c 00 ff 	mov	r12,255
80007c9a:	f0 1f 00 14 	mcall	80007ce8 <sd_mmc_spi_check_hc+0x88>
80007c9e:	18 96       	mov	r6,r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
80007ca0:	e0 6c 00 ff 	mov	r12,255
80007ca4:	f0 1f 00 11 	mcall	80007ce8 <sd_mmc_spi_check_hc+0x88>
80007ca8:	48 e7       	lddpc	r7,80007ce0 <sd_mmc_spi_check_hc+0x80>
80007caa:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
80007cac:	e0 6c 00 ff 	mov	r12,255
80007cb0:	f0 1f 00 0e 	mcall	80007ce8 <sd_mmc_spi_check_hc+0x88>
80007cb4:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
80007cb6:	e0 6c 00 ff 	mov	r12,255
80007cba:	f0 1f 00 0c 	mcall	80007ce8 <sd_mmc_spi_check_hc+0x88>
80007cbe:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80007cc0:	30 1b       	mov	r11,1
80007cc2:	fe 7c 24 00 	mov	r12,-56320
80007cc6:	f0 1f 00 08 	mcall	80007ce4 <sd_mmc_spi_check_hc+0x84>
80007cca:	f9 d6 c0 c1 	bfextu	r12,r6,0x6,0x1
  if(hc_bit & 0x40) {
      return SDHC_CARD;
  }
  return 0;
}
80007cce:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007cd2:	00 00       	add	r0,r0
80007cd4:	80 00       	ld.sh	r0,r0[0x0]
80007cd6:	78 fc       	ld.w	r12,r12[0x3c]
80007cd8:	80 00       	ld.sh	r0,r0[0x0]
80007cda:	8a 5a       	ld.sh	r10,r5[0xa]
80007cdc:	80 00       	ld.sh	r0,r0[0x0]
80007cde:	79 90       	ld.w	r0,r12[0x64]
80007ce0:	00 00       	add	r0,r0
80007ce2:	09 d0       	ld.ub	r0,r4[0x5]
80007ce4:	80 00       	ld.sh	r0,r0[0x0]
80007ce6:	8a a6       	ld.uh	r6,r5[0x4]
80007ce8:	80 00       	ld.sh	r0,r0[0x0]
80007cea:	78 c8       	ld.w	r8,r12[0x30]

80007cec <sd_mmc_spi_get_if>:
//!                true
//!                SD_MMC


int sd_mmc_spi_get_if(void)
{
80007cec:	eb cd 40 80 	pushm	r7,lr
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80007cf0:	f0 1f 00 27 	mcall	80007d8c <sd_mmc_spi_get_if+0xa0>
80007cf4:	c0 31       	brne	80007cfa <sd_mmc_spi_get_if+0xe>
80007cf6:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
    return SD_FAILURE;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80007cfa:	30 1b       	mov	r11,1
80007cfc:	fe 7c 24 00 	mov	r12,-56320
80007d00:	f0 1f 00 24 	mcall	80007d90 <sd_mmc_spi_get_if+0xa4>
  r1 = sd_mmc_spi_command(MMC_SEND_IF_COND, 0x000001AA);
80007d04:	e0 6b 01 aa 	mov	r11,426
80007d08:	30 8c       	mov	r12,8
80007d0a:	f0 1f 00 23 	mcall	80007d94 <sd_mmc_spi_get_if+0xa8>
80007d0e:	4a 38       	lddpc	r8,80007d98 <sd_mmc_spi_get_if+0xac>
80007d10:	b0 8c       	st.b	r8[0x0],r12
  // check for valid response
  if((r1 & MMC_R1_ILLEGAL_COM) != 0) {
80007d12:	e2 1c 00 04 	andl	r12,0x4,COH
80007d16:	c0 80       	breq	80007d26 <sd_mmc_spi_get_if+0x3a>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80007d18:	30 1b       	mov	r11,1
80007d1a:	fe 7c 24 00 	mov	r12,-56320
80007d1e:	f0 1f 00 20 	mcall	80007d9c <sd_mmc_spi_get_if+0xb0>
80007d22:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
    return SD_MMC;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
80007d26:	e0 6c 00 ff 	mov	r12,255
80007d2a:	f0 1f 00 1e 	mcall	80007da0 <sd_mmc_spi_get_if+0xb4>
80007d2e:	49 b7       	lddpc	r7,80007d98 <sd_mmc_spi_get_if+0xac>
80007d30:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
80007d32:	e0 6c 00 ff 	mov	r12,255
80007d36:	f0 1f 00 1b 	mcall	80007da0 <sd_mmc_spi_get_if+0xb4>
80007d3a:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
80007d3c:	e0 6c 00 ff 	mov	r12,255
80007d40:	f0 1f 00 18 	mcall	80007da0 <sd_mmc_spi_get_if+0xb4>
80007d44:	ae 8c       	st.b	r7[0x0],r12
  if((r1 & 0x01) == 0) {
80007d46:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80007d4a:	c0 81       	brne	80007d5a <sd_mmc_spi_get_if+0x6e>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80007d4c:	30 1b       	mov	r11,1
80007d4e:	fe 7c 24 00 	mov	r12,-56320
80007d52:	f0 1f 00 13 	mcall	80007d9c <sd_mmc_spi_get_if+0xb0>
80007d56:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
    return SD_FAILURE;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
80007d5a:	e0 6c 00 ff 	mov	r12,255
80007d5e:	f0 1f 00 11 	mcall	80007da0 <sd_mmc_spi_get_if+0xb4>
80007d62:	48 e8       	lddpc	r8,80007d98 <sd_mmc_spi_get_if+0xac>
80007d64:	b0 8c       	st.b	r8[0x0],r12
  if(r1 != 0xaa) {
80007d66:	3a a8       	mov	r8,-86
80007d68:	f0 0c 18 00 	cp.b	r12,r8
80007d6c:	c0 80       	breq	80007d7c <sd_mmc_spi_get_if+0x90>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80007d6e:	30 1b       	mov	r11,1
80007d70:	fe 7c 24 00 	mov	r12,-56320
80007d74:	f0 1f 00 0a 	mcall	80007d9c <sd_mmc_spi_get_if+0xb0>
80007d78:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
    return SD_FAILURE; /* wrong test pattern */
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80007d7c:	30 1b       	mov	r11,1
80007d7e:	fe 7c 24 00 	mov	r12,-56320
80007d82:	f0 1f 00 07 	mcall	80007d9c <sd_mmc_spi_get_if+0xb0>
80007d86:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
80007d8a:	00 00       	add	r0,r0
80007d8c:	80 00       	ld.sh	r0,r0[0x0]
80007d8e:	78 fc       	ld.w	r12,r12[0x3c]
80007d90:	80 00       	ld.sh	r0,r0[0x0]
80007d92:	8a 5a       	ld.sh	r10,r5[0xa]
80007d94:	80 00       	ld.sh	r0,r0[0x0]
80007d96:	79 90       	ld.w	r0,r12[0x64]
80007d98:	00 00       	add	r0,r0
80007d9a:	09 d0       	ld.ub	r0,r4[0x5]
80007d9c:	80 00       	ld.sh	r0,r0[0x0]
80007d9e:	8a a6       	ld.uh	r6,r5[0x4]
80007da0:	80 00       	ld.sh	r0,r0[0x0]
80007da2:	78 c8       	ld.w	r8,r12[0x30]

80007da4 <sd_mmc_spi_read_sector_to_ram>:
//! @return bit
//!   The read succeeded   -> true
//!   The read failed (bad address, etc.)  -> false
//!/
bool sd_mmc_spi_read_sector_to_ram(void *ram)
{
80007da4:	eb cd 40 f8 	pushm	r3-r7,lr
80007da8:	20 1d       	sub	sp,4
80007daa:	18 93       	mov	r3,r12
  uint8_t *_ram = ram;
  uint16_t  i;
  uint16_t  read_time_out;
  unsigned short data_read;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80007dac:	f0 1f 00 48 	mcall	80007ecc <sd_mmc_spi_read_sector_to_ram+0x128>
80007db0:	e0 80 00 8a 	breq	80007ec4 <sd_mmc_spi_read_sector_to_ram+0x120>
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80007db4:	30 1b       	mov	r11,1
80007db6:	fe 7c 24 00 	mov	r12,-56320
80007dba:	f0 1f 00 46 	mcall	80007ed0 <sd_mmc_spi_read_sector_to_ram+0x12c>

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
80007dbe:	4c 68       	lddpc	r8,80007ed4 <sd_mmc_spi_read_sector_to_ram+0x130>
80007dc0:	11 89       	ld.ub	r9,r8[0x0]
80007dc2:	30 38       	mov	r8,3
80007dc4:	f0 09 18 00 	cp.b	r9,r8
80007dc8:	c0 a1       	brne	80007ddc <sd_mmc_spi_read_sector_to_ram+0x38>
    r1 = sd_mmc_spi_command(MMC_READ_SINGLE_BLOCK, gl_ptr_mem>>9);
80007dca:	4c 48       	lddpc	r8,80007ed8 <sd_mmc_spi_read_sector_to_ram+0x134>
80007dcc:	70 0b       	ld.w	r11,r8[0x0]
80007dce:	a9 9b       	lsr	r11,0x9
80007dd0:	31 1c       	mov	r12,17
80007dd2:	f0 1f 00 43 	mcall	80007edc <sd_mmc_spi_read_sector_to_ram+0x138>
80007dd6:	4c 38       	lddpc	r8,80007ee0 <sd_mmc_spi_read_sector_to_ram+0x13c>
80007dd8:	b0 8c       	st.b	r8[0x0],r12
80007dda:	c0 88       	rjmp	80007dea <sd_mmc_spi_read_sector_to_ram+0x46>
  } else {
    r1 = sd_mmc_spi_command(MMC_READ_SINGLE_BLOCK, gl_ptr_mem);
80007ddc:	4b f8       	lddpc	r8,80007ed8 <sd_mmc_spi_read_sector_to_ram+0x134>
80007dde:	70 0b       	ld.w	r11,r8[0x0]
80007de0:	31 1c       	mov	r12,17
80007de2:	f0 1f 00 3f 	mcall	80007edc <sd_mmc_spi_read_sector_to_ram+0x138>
80007de6:	4b f8       	lddpc	r8,80007ee0 <sd_mmc_spi_read_sector_to_ram+0x13c>
80007de8:	b0 8c       	st.b	r8[0x0],r12
  }

  // check for valid response
  if (r1 != 0x00)
80007dea:	4b e8       	lddpc	r8,80007ee0 <sd_mmc_spi_read_sector_to_ram+0x13c>
80007dec:	11 89       	ld.ub	r9,r8[0x0]
80007dee:	30 08       	mov	r8,0
80007df0:	f0 09 18 00 	cp.b	r9,r8
80007df4:	c1 20       	breq	80007e18 <sd_mmc_spi_read_sector_to_ram+0x74>
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80007df6:	30 1b       	mov	r11,1
80007df8:	fe 7c 24 00 	mov	r12,-56320
80007dfc:	f0 1f 00 3a 	mcall	80007ee4 <sd_mmc_spi_read_sector_to_ram+0x140>
80007e00:	30 0c       	mov	r12,0
    return false;
80007e02:	c6 18       	rjmp	80007ec4 <sd_mmc_spi_read_sector_to_ram+0x120>

  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
  {
     read_time_out--;
80007e04:	20 17       	sub	r7,1
80007e06:	5c 87       	casts.h	r7
     if (read_time_out == 0)   // TIME-OUT
80007e08:	c0 e1       	brne	80007e24 <sd_mmc_spi_read_sector_to_ram+0x80>
     {
       spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS); // unselect SD_MMC_SPI
80007e0a:	30 1b       	mov	r11,1
80007e0c:	fe 7c 24 00 	mov	r12,-56320
80007e10:	f0 1f 00 35 	mcall	80007ee4 <sd_mmc_spi_read_sector_to_ram+0x140>
80007e14:	30 0c       	mov	r12,0
       return false;
80007e16:	c5 78       	rjmp	80007ec4 <sd_mmc_spi_read_sector_to_ram+0x120>
80007e18:	e0 67 75 30 	mov	r7,30000
    return false;
  }

  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80007e1c:	e0 65 00 ff 	mov	r5,255
80007e20:	4b 04       	lddpc	r4,80007ee0 <sd_mmc_spi_read_sector_to_ram+0x13c>
80007e22:	3f f6       	mov	r6,-1
80007e24:	0a 9c       	mov	r12,r5
80007e26:	f0 1f 00 31 	mcall	80007ee8 <sd_mmc_spi_read_sector_to_ram+0x144>
80007e2a:	a8 8c       	st.b	r4[0x0],r12
80007e2c:	ec 0c 18 00 	cp.b	r12,r6
80007e30:	ce a0       	breq	80007e04 <sd_mmc_spi_read_sector_to_ram+0x60>
       return false;
     }
  }

  // check token
  if (r1 != MMC_STARTBLOCK_READ)
80007e32:	3f e8       	mov	r8,-2
80007e34:	f0 0c 18 00 	cp.b	r12,r8
80007e38:	c0 e0       	breq	80007e54 <sd_mmc_spi_read_sector_to_ram+0xb0>
  {
    spi_write(SD_MMC_SPI,0xFF);
80007e3a:	e0 6b 00 ff 	mov	r11,255
80007e3e:	fe 7c 24 00 	mov	r12,-56320
80007e42:	f0 1f 00 2b 	mcall	80007eec <sd_mmc_spi_read_sector_to_ram+0x148>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80007e46:	30 1b       	mov	r11,1
80007e48:	fe 7c 24 00 	mov	r12,-56320
80007e4c:	f0 1f 00 26 	mcall	80007ee4 <sd_mmc_spi_read_sector_to_ram+0x140>
80007e50:	30 0c       	mov	r12,0
    return false;
80007e52:	c3 98       	rjmp	80007ec4 <sd_mmc_spi_read_sector_to_ram+0x120>
//!   The read succeeded   -> true
//!   The read failed (bad address, etc.)  -> false
//!/
bool sd_mmc_spi_read_sector_to_ram(void *ram)
{
  uint8_t *_ram = ram;
80007e54:	06 97       	mov	r7,r3
//!
//! @return bit
//!   The read succeeded   -> true
//!   The read failed (bad address, etc.)  -> false
//!/
bool sd_mmc_spi_read_sector_to_ram(void *ram)
80007e56:	e6 c5 fe 00 	sub	r5,r3,-512
  }

  // store datablock
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,0xFF);
80007e5a:	e0 64 00 ff 	mov	r4,255
80007e5e:	fe 76 24 00 	mov	r6,-56320
    spi_read(SD_MMC_SPI,&data_read);
80007e62:	fa c3 ff fe 	sub	r3,sp,-2
  }

  // store datablock
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,0xFF);
80007e66:	08 9b       	mov	r11,r4
80007e68:	0c 9c       	mov	r12,r6
80007e6a:	f0 1f 00 21 	mcall	80007eec <sd_mmc_spi_read_sector_to_ram+0x148>
    spi_read(SD_MMC_SPI,&data_read);
80007e6e:	06 9b       	mov	r11,r3
80007e70:	0c 9c       	mov	r12,r6
80007e72:	f0 1f 00 20 	mcall	80007ef0 <sd_mmc_spi_read_sector_to_ram+0x14c>
    *_ram++=data_read;
80007e76:	9a 18       	ld.sh	r8,sp[0x2]
80007e78:	0e c8       	st.b	r7++,r8
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return false;
  }

  // store datablock
  for(i=0;i<MMC_SECTOR_SIZE;i++)
80007e7a:	0a 37       	cp.w	r7,r5
80007e7c:	cf 51       	brne	80007e66 <sd_mmc_spi_read_sector_to_ram+0xc2>
  {
    spi_write(SD_MMC_SPI,0xFF);
    spi_read(SD_MMC_SPI,&data_read);
    *_ram++=data_read;
  }
  gl_ptr_mem += 512;     // Update the memory pointer.
80007e7e:	49 78       	lddpc	r8,80007ed8 <sd_mmc_spi_read_sector_to_ram+0x134>
80007e80:	70 09       	ld.w	r9,r8[0x0]
80007e82:	f2 c9 fe 00 	sub	r9,r9,-512
80007e86:	91 09       	st.w	r8[0x0],r9

  // load 16-bit CRC (ignored)
  spi_write(SD_MMC_SPI,0xFF);
80007e88:	e0 6b 00 ff 	mov	r11,255
80007e8c:	fe 7c 24 00 	mov	r12,-56320
80007e90:	f0 1f 00 17 	mcall	80007eec <sd_mmc_spi_read_sector_to_ram+0x148>
  spi_write(SD_MMC_SPI,0xFF);
80007e94:	e0 6b 00 ff 	mov	r11,255
80007e98:	fe 7c 24 00 	mov	r12,-56320
80007e9c:	f0 1f 00 14 	mcall	80007eec <sd_mmc_spi_read_sector_to_ram+0x148>

  // continue delivering some clock cycles
  spi_write(SD_MMC_SPI,0xFF);
80007ea0:	e0 6b 00 ff 	mov	r11,255
80007ea4:	fe 7c 24 00 	mov	r12,-56320
80007ea8:	f0 1f 00 11 	mcall	80007eec <sd_mmc_spi_read_sector_to_ram+0x148>
  spi_write(SD_MMC_SPI,0xFF);
80007eac:	e0 6b 00 ff 	mov	r11,255
80007eb0:	fe 7c 24 00 	mov	r12,-56320
80007eb4:	f0 1f 00 0e 	mcall	80007eec <sd_mmc_spi_read_sector_to_ram+0x148>

  // release chip select
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80007eb8:	30 1b       	mov	r11,1
80007eba:	fe 7c 24 00 	mov	r12,-56320
80007ebe:	f0 1f 00 0a 	mcall	80007ee4 <sd_mmc_spi_read_sector_to_ram+0x140>
80007ec2:	30 1c       	mov	r12,1

  return true;   // Read done.
}
80007ec4:	2f fd       	sub	sp,-4
80007ec6:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80007eca:	00 00       	add	r0,r0
80007ecc:	80 00       	ld.sh	r0,r0[0x0]
80007ece:	78 fc       	ld.w	r12,r12[0x3c]
80007ed0:	80 00       	ld.sh	r0,r0[0x0]
80007ed2:	8a 5a       	ld.sh	r10,r5[0xa]
80007ed4:	00 00       	add	r0,r0
80007ed6:	09 be       	ld.ub	lr,r4[0x3]
80007ed8:	00 00       	add	r0,r0
80007eda:	06 48       	or	r8,r3
80007edc:	80 00       	ld.sh	r0,r0[0x0]
80007ede:	79 90       	ld.w	r0,r12[0x64]
80007ee0:	00 00       	add	r0,r0
80007ee2:	09 d0       	ld.ub	r0,r4[0x5]
80007ee4:	80 00       	ld.sh	r0,r0[0x0]
80007ee6:	8a a6       	ld.uh	r6,r5[0x4]
80007ee8:	80 00       	ld.sh	r0,r0[0x0]
80007eea:	78 c8       	ld.w	r8,r12[0x30]
80007eec:	80 00       	ld.sh	r0,r0[0x0]
80007eee:	8b 8a       	st.w	r5[0x20],r10
80007ef0:	80 00       	ld.sh	r0,r0[0x0]
80007ef2:	8b a6       	st.w	r5[0x28],r6

80007ef4 <sd_mmc_spi_get_csd>:
//! @param  buffer to fill
//!
//! @return bit
//!         true / false
bool sd_mmc_spi_get_csd(uint8_t *buffer)
{
80007ef4:	eb cd 40 fc 	pushm	r2-r7,lr
80007ef8:	20 1d       	sub	sp,4
80007efa:	18 92       	mov	r2,r12
uint8_t retry;
unsigned short data_read;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80007efc:	f0 1f 00 32 	mcall	80007fc4 <sd_mmc_spi_get_csd+0xd0>
80007f00:	c5 f0       	breq	80007fbe <sd_mmc_spi_get_csd+0xca>
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80007f02:	30 1b       	mov	r11,1
80007f04:	fe 7c 24 00 	mov	r12,-56320
80007f08:	f0 1f 00 30 	mcall	80007fc8 <sd_mmc_spi_get_csd+0xd4>
  // issue command
  r1 = sd_mmc_spi_command(MMC_SEND_CSD, 0);
80007f0c:	30 0b       	mov	r11,0
80007f0e:	30 9c       	mov	r12,9
80007f10:	f0 1f 00 2f 	mcall	80007fcc <sd_mmc_spi_get_csd+0xd8>
80007f14:	4a f8       	lddpc	r8,80007fd0 <sd_mmc_spi_get_csd+0xdc>
80007f16:	b0 8c       	st.b	r8[0x0],r12
  // check for valid response
  if(r1 != 0x00)
80007f18:	58 0c       	cp.w	r12,0
80007f1a:	c0 81       	brne	80007f2a <sd_mmc_spi_get_csd+0x36>
80007f1c:	30 07       	mov	r7,0
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
80007f1e:	e0 64 00 ff 	mov	r4,255
80007f22:	10 93       	mov	r3,r8
80007f24:	3f e6       	mov	r6,-2
  {
    if (retry > 8)
80007f26:	30 95       	mov	r5,9
80007f28:	c1 78       	rjmp	80007f56 <sd_mmc_spi_get_csd+0x62>
  // issue command
  r1 = sd_mmc_spi_command(MMC_SEND_CSD, 0);
  // check for valid response
  if(r1 != 0x00)
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80007f2a:	30 1b       	mov	r11,1
80007f2c:	fe 7c 24 00 	mov	r12,-56320
80007f30:	f0 1f 00 29 	mcall	80007fd4 <sd_mmc_spi_get_csd+0xe0>
    sd_mmc_spi_init_done = false;
80007f34:	30 09       	mov	r9,0
80007f36:	4a 98       	lddpc	r8,80007fd8 <sd_mmc_spi_get_csd+0xe4>
80007f38:	b0 89       	st.b	r8[0x0],r9
80007f3a:	30 0c       	mov	r12,0
    return false;
80007f3c:	c4 18       	rjmp	80007fbe <sd_mmc_spi_get_csd+0xca>
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
  {
    if (retry > 8)
80007f3e:	ea 07 18 00 	cp.b	r7,r5
80007f42:	c0 81       	brne	80007f52 <sd_mmc_spi_get_csd+0x5e>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80007f44:	30 1b       	mov	r11,1
80007f46:	fe 7c 24 00 	mov	r12,-56320
80007f4a:	f0 1f 00 23 	mcall	80007fd4 <sd_mmc_spi_get_csd+0xe0>
80007f4e:	30 0c       	mov	r12,0
      return false;
80007f50:	c3 78       	rjmp	80007fbe <sd_mmc_spi_get_csd+0xca>
    }
    retry++;
80007f52:	2f f7       	sub	r7,-1
80007f54:	5c 57       	castu.b	r7
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
80007f56:	08 9c       	mov	r12,r4
80007f58:	f0 1f 00 21 	mcall	80007fdc <sd_mmc_spi_get_csd+0xe8>
80007f5c:	a6 8c       	st.b	r3[0x0],r12
80007f5e:	ec 0c 18 00 	cp.b	r12,r6
80007f62:	ce e1       	brne	80007f3e <sd_mmc_spi_get_csd+0x4a>
80007f64:	30 07       	mov	r7,0
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80007f66:	e0 65 00 ff 	mov	r5,255
80007f6a:	fe 76 24 00 	mov	r6,-56320
   spi_read(SD_MMC_SPI,&data_read);
80007f6e:	fa c4 ff fe 	sub	r4,sp,-2
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80007f72:	0a 9b       	mov	r11,r5
80007f74:	0c 9c       	mov	r12,r6
80007f76:	f0 1f 00 1b 	mcall	80007fe0 <sd_mmc_spi_get_csd+0xec>
   spi_read(SD_MMC_SPI,&data_read);
80007f7a:	08 9b       	mov	r11,r4
80007f7c:	0c 9c       	mov	r12,r6
80007f7e:	f0 1f 00 1a 	mcall	80007fe4 <sd_mmc_spi_get_csd+0xf0>
    buffer[retry] = data_read;
80007f82:	9a 18       	ld.sh	r8,sp[0x2]
80007f84:	e4 07 0b 08 	st.b	r2[r7],r8
80007f88:	2f f7       	sub	r7,-1
      return false;
    }
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
80007f8a:	59 07       	cp.w	r7,16
80007f8c:	cf 31       	brne	80007f72 <sd_mmc_spi_get_csd+0x7e>
  {
   spi_write(SD_MMC_SPI,0xFF);
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
  }
   spi_write(SD_MMC_SPI,0xFF);   // load CRC (not used)
80007f8e:	e0 6b 00 ff 	mov	r11,255
80007f92:	fe 7c 24 00 	mov	r12,-56320
80007f96:	f0 1f 00 13 	mcall	80007fe0 <sd_mmc_spi_get_csd+0xec>
   spi_write(SD_MMC_SPI,0xFF);
80007f9a:	e0 6b 00 ff 	mov	r11,255
80007f9e:	fe 7c 24 00 	mov	r12,-56320
80007fa2:	f0 1f 00 10 	mcall	80007fe0 <sd_mmc_spi_get_csd+0xec>
   spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction
80007fa6:	e0 6b 00 ff 	mov	r11,255
80007faa:	fe 7c 24 00 	mov	r12,-56320
80007fae:	f0 1f 00 0d 	mcall	80007fe0 <sd_mmc_spi_get_csd+0xec>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80007fb2:	30 1b       	mov	r11,1
80007fb4:	fe 7c 24 00 	mov	r12,-56320
80007fb8:	f0 1f 00 07 	mcall	80007fd4 <sd_mmc_spi_get_csd+0xe0>
80007fbc:	30 1c       	mov	r12,1
  return true;
}
80007fbe:	2f fd       	sub	sp,-4
80007fc0:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80007fc4:	80 00       	ld.sh	r0,r0[0x0]
80007fc6:	78 fc       	ld.w	r12,r12[0x3c]
80007fc8:	80 00       	ld.sh	r0,r0[0x0]
80007fca:	8a 5a       	ld.sh	r10,r5[0xa]
80007fcc:	80 00       	ld.sh	r0,r0[0x0]
80007fce:	79 90       	ld.w	r0,r12[0x64]
80007fd0:	00 00       	add	r0,r0
80007fd2:	09 d0       	ld.ub	r0,r4[0x5]
80007fd4:	80 00       	ld.sh	r0,r0[0x0]
80007fd6:	8a a6       	ld.uh	r6,r5[0x4]
80007fd8:	00 00       	add	r0,r0
80007fda:	06 60       	and	r0,r3
80007fdc:	80 00       	ld.sh	r0,r0[0x0]
80007fde:	78 c8       	ld.w	r8,r12[0x30]
80007fe0:	80 00       	ld.sh	r0,r0[0x0]
80007fe2:	8b 8a       	st.w	r5[0x20],r10
80007fe4:	80 00       	ld.sh	r0,r0[0x0]
80007fe6:	8b a6       	st.w	r5[0x28],r6

80007fe8 <sd_mmc_spi_internal_init>:
//!
//!
//! @return bit
//!   The memory is ready     -> true (always)
bool sd_mmc_spi_internal_init(void)
{
80007fe8:	d4 31       	pushm	r0-r7,lr
  uint16_t retry;
  int i;
  int if_cond;

  // Start at low frequency
  sd_mmc_opt.baudrate = 400000;
80007fea:	fe fb 02 66 	ld.w	r11,pc[614]
80007fee:	e6 68 1a 80 	mov	r8,400000
80007ff2:	97 18       	st.w	r11[0x4],r8
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
80007ff4:	fe f8 02 60 	ld.w	r8,pc[608]
80007ff8:	70 0a       	ld.w	r10,r8[0x0]
80007ffa:	fe 7c 24 00 	mov	r12,-56320
80007ffe:	f0 1f 00 97 	mcall	80008258 <sd_mmc_spi_internal_init+0x270>

  /* card needs 74 cycles minimum to start up */
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80008002:	30 1b       	mov	r11,1
80008004:	fe 7c 24 00 	mov	r12,-56320
80008008:	f0 1f 00 95 	mcall	8000825c <sd_mmc_spi_internal_init+0x274>
8000800c:	30 07       	mov	r7,0
  for(i = 0; i < 10; ++i) {
    spi_write(SD_MMC_SPI,0xFF);
8000800e:	e0 66 00 ff 	mov	r6,255
80008012:	fe 75 24 00 	mov	r5,-56320
80008016:	0c 9b       	mov	r11,r6
80008018:	0a 9c       	mov	r12,r5
8000801a:	f0 1f 00 92 	mcall	80008260 <sd_mmc_spi_internal_init+0x278>
  sd_mmc_opt.baudrate = 400000;
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);

  /* card needs 74 cycles minimum to start up */
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  for(i = 0; i < 10; ++i) {
8000801e:	2f f7       	sub	r7,-1
80008020:	58 a7       	cp.w	r7,10
80008022:	cf a1       	brne	80008016 <sd_mmc_spi_internal_init+0x2e>
    spi_write(SD_MMC_SPI,0xFF);
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80008024:	30 1b       	mov	r11,1
80008026:	fe 7c 24 00 	mov	r12,-56320
8000802a:	f0 1f 00 8f 	mcall	80008264 <sd_mmc_spi_internal_init+0x27c>

  // RESET THE MEMORY CARD
  sd_mmc_spi_init_done = false;
8000802e:	30 08       	mov	r8,0
80008030:	fe f9 02 38 	ld.w	r9,pc[568]
80008034:	b2 88       	st.b	r9[0x0],r8
  card_type = MMC_CARD;
80008036:	fe f9 02 36 	ld.w	r9,pc[566]
8000803a:	b2 88       	st.b	r9[0x0],r8
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
8000803c:	30 0b       	mov	r11,0
8000803e:	16 9c       	mov	r12,r11
80008040:	f0 1f 00 8c 	mcall	80008270 <sd_mmc_spi_internal_init+0x288>
80008044:	fe f8 02 30 	ld.w	r8,pc[560]
80008048:	b0 8c       	st.b	r8[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000804a:	e0 6b 00 ff 	mov	r11,255
8000804e:	fe 7c 24 00 	mov	r12,-56320
80008052:	f0 1f 00 84 	mcall	80008260 <sd_mmc_spi_internal_init+0x278>
80008056:	30 17       	mov	r7,1
    // do retry counter
    retry++;
    if(retry > 100)
      return false;
  }
  while(r1 != 0x01);   // check memory enters idle_state
80008058:	fe f6 02 1c 	ld.w	r6,pc[540]
8000805c:	30 15       	mov	r5,1
  card_type = MMC_CARD;
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
8000805e:	30 03       	mov	r3,0
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80008060:	e0 62 00 ff 	mov	r2,255
80008064:	fe 71 24 00 	mov	r1,-56320
    // do retry counter
    retry++;
    if(retry > 100)
80008068:	36 54       	mov	r4,101
8000806a:	c1 08       	rjmp	8000808a <sd_mmc_spi_internal_init+0xa2>
  card_type = MMC_CARD;
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
8000806c:	06 9b       	mov	r11,r3
8000806e:	06 9c       	mov	r12,r3
80008070:	f0 1f 00 80 	mcall	80008270 <sd_mmc_spi_internal_init+0x288>
80008074:	ac 8c       	st.b	r6[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80008076:	04 9b       	mov	r11,r2
80008078:	02 9c       	mov	r12,r1
8000807a:	f0 1f 00 7a 	mcall	80008260 <sd_mmc_spi_internal_init+0x278>
    // do retry counter
    retry++;
8000807e:	2f f7       	sub	r7,-1
80008080:	5c 87       	casts.h	r7
    if(retry > 100)
80008082:	e8 07 19 00 	cp.h	r7,r4
80008086:	e0 80 00 e4 	breq	8000824e <sd_mmc_spi_internal_init+0x266>
      return false;
  }
  while(r1 != 0x01);   // check memory enters idle_state
8000808a:	0d 88       	ld.ub	r8,r6[0x0]
8000808c:	ea 08 18 00 	cp.b	r8,r5
80008090:	ce e1       	brne	8000806c <sd_mmc_spi_internal_init+0x84>

  if_cond = sd_mmc_spi_get_if();
80008092:	f0 1f 00 7a 	mcall	80008278 <sd_mmc_spi_internal_init+0x290>
  if(if_cond == -1) {
80008096:	5b fc       	cp.w	r12,-1
80008098:	e0 80 00 db 	breq	8000824e <sd_mmc_spi_internal_init+0x266>
      return false; // card is bad
  } else if (if_cond == 1) {
8000809c:	58 1c       	cp.w	r12,1
8000809e:	c0 51       	brne	800080a8 <sd_mmc_spi_internal_init+0xc0>
      card_type = SD_CARD_2;
800080a0:	30 29       	mov	r9,2
800080a2:	4f 38       	lddpc	r8,8000826c <sd_mmc_spi_internal_init+0x284>
800080a4:	b0 89       	st.b	r8[0x0],r9
800080a6:	c4 c8       	rjmp	8000813e <sd_mmc_spi_internal_init+0x156>
  } else {
    // IDENTIFICATION OF THE CARD TYPE (SD or MMC)
    // Both cards will accept CMD55 command but only the SD card will respond to ACMD41
    r1 = sd_mmc_spi_send_command(SD_APP_CMD55,0);
800080a8:	30 0b       	mov	r11,0
800080aa:	33 7c       	mov	r12,55
800080ac:	f0 1f 00 71 	mcall	80008270 <sd_mmc_spi_internal_init+0x288>
800080b0:	4f 17       	lddpc	r7,80008274 <sd_mmc_spi_internal_init+0x28c>
800080b2:	ae 8c       	st.b	r7[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte
800080b4:	e0 6b 00 ff 	mov	r11,255
800080b8:	fe 7c 24 00 	mov	r12,-56320
800080bc:	f0 1f 00 69 	mcall	80008260 <sd_mmc_spi_internal_init+0x278>

    r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
800080c0:	30 0b       	mov	r11,0
800080c2:	32 9c       	mov	r12,41
800080c4:	f0 1f 00 6b 	mcall	80008270 <sd_mmc_spi_internal_init+0x288>
800080c8:	ae 8c       	st.b	r7[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte
800080ca:	e0 6b 00 ff 	mov	r11,255
800080ce:	fe 7c 24 00 	mov	r12,-56320
800080d2:	f0 1f 00 64 	mcall	80008260 <sd_mmc_spi_internal_init+0x278>

    if ((r1&0xFE) == 0) {   // ignore "in_idle_state" flag bit
800080d6:	0f 88       	ld.ub	r8,r7[0x0]
800080d8:	e2 18 00 fe 	andl	r8,0xfe,COH
800080dc:	c0 51       	brne	800080e6 <sd_mmc_spi_internal_init+0xfe>
      card_type = SD_CARD;    // card has accepted the command, this is a SD card
800080de:	30 19       	mov	r9,1
800080e0:	4e 38       	lddpc	r8,8000826c <sd_mmc_spi_internal_init+0x284>
800080e2:	b0 89       	st.b	r8[0x0],r9
800080e4:	c2 d8       	rjmp	8000813e <sd_mmc_spi_internal_init+0x156>
    } else {
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
800080e6:	30 09       	mov	r9,0
800080e8:	4e 18       	lddpc	r8,8000826c <sd_mmc_spi_internal_init+0x284>
800080ea:	b0 89       	st.b	r8[0x0],r9
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
800080ec:	30 0b       	mov	r11,0
800080ee:	16 9c       	mov	r12,r11
800080f0:	f0 1f 00 60 	mcall	80008270 <sd_mmc_spi_internal_init+0x288>
800080f4:	4e 08       	lddpc	r8,80008274 <sd_mmc_spi_internal_init+0x28c>
800080f6:	b0 8c       	st.b	r8[0x0],r12
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800080f8:	e0 6b 00 ff 	mov	r11,255
800080fc:	fe 7c 24 00 	mov	r12,-56320
80008100:	f0 1f 00 58 	mcall	80008260 <sd_mmc_spi_internal_init+0x278>
80008104:	30 17       	mov	r7,1
        // do retry counter
        retry++;
        if(retry > 100)
          return false;
      }
      while(r1 != 0x01);   // check memory enters idle_state
80008106:	4d c6       	lddpc	r6,80008274 <sd_mmc_spi_internal_init+0x28c>
80008108:	30 15       	mov	r5,1
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
8000810a:	30 03       	mov	r3,0
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000810c:	e0 62 00 ff 	mov	r2,255
80008110:	fe 71 24 00 	mov	r1,-56320
        // do retry counter
        retry++;
        if(retry > 100)
80008114:	36 54       	mov	r4,101
80008116:	c1 08       	rjmp	80008136 <sd_mmc_spi_internal_init+0x14e>
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
80008118:	06 9b       	mov	r11,r3
8000811a:	06 9c       	mov	r12,r3
8000811c:	f0 1f 00 55 	mcall	80008270 <sd_mmc_spi_internal_init+0x288>
80008120:	ac 8c       	st.b	r6[0x0],r12
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80008122:	04 9b       	mov	r11,r2
80008124:	02 9c       	mov	r12,r1
80008126:	f0 1f 00 4f 	mcall	80008260 <sd_mmc_spi_internal_init+0x278>
        // do retry counter
        retry++;
8000812a:	2f f7       	sub	r7,-1
8000812c:	5c 87       	casts.h	r7
        if(retry > 100)
8000812e:	e8 07 19 00 	cp.h	r7,r4
80008132:	e0 80 00 8e 	breq	8000824e <sd_mmc_spi_internal_init+0x266>
          return false;
      }
      while(r1 != 0x01);   // check memory enters idle_state
80008136:	0d 88       	ld.ub	r8,r6[0x0]
80008138:	ea 08 18 00 	cp.b	r8,r5
8000813c:	ce e1       	brne	80008118 <sd_mmc_spi_internal_init+0x130>
8000813e:	30 07       	mov	r7,0

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
  do {
    switch(card_type) {
80008140:	4c b4       	lddpc	r4,8000826c <sd_mmc_spi_internal_init+0x284>
80008142:	30 15       	mov	r5,1
    case MMC_CARD:
      r1 = sd_mmc_spi_send_command(MMC_SEND_OP_COND, 0);
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
      break;
    case SD_CARD:
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
80008144:	0e 93       	mov	r3,r7
80008146:	33 70       	mov	r0,55
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
80008148:	4c b6       	lddpc	r6,80008274 <sd_mmc_spi_internal_init+0x28c>
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000814a:	e0 62 00 ff 	mov	r2,255
8000814e:	fe 71 24 00 	mov	r1,-56320

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
  do {
    switch(card_type) {
80008152:	09 88       	ld.ub	r8,r4[0x0]
80008154:	ea 08 18 00 	cp.b	r8,r5
80008158:	c1 10       	breq	8000817a <sd_mmc_spi_internal_init+0x192>
8000815a:	c0 63       	brcs	80008166 <sd_mmc_spi_internal_init+0x17e>
8000815c:	30 29       	mov	r9,2
8000815e:	f2 08 18 00 	cp.b	r8,r9
80008162:	c2 81       	brne	800081b2 <sd_mmc_spi_internal_init+0x1ca>
80008164:	c1 98       	rjmp	80008196 <sd_mmc_spi_internal_init+0x1ae>
    case MMC_CARD:
      r1 = sd_mmc_spi_send_command(MMC_SEND_OP_COND, 0);
80008166:	06 9b       	mov	r11,r3
80008168:	30 1c       	mov	r12,1
8000816a:	f0 1f 00 42 	mcall	80008270 <sd_mmc_spi_internal_init+0x288>
8000816e:	ac 8c       	st.b	r6[0x0],r12
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80008170:	04 9b       	mov	r11,r2
80008172:	02 9c       	mov	r12,r1
80008174:	f0 1f 00 3b 	mcall	80008260 <sd_mmc_spi_internal_init+0x278>
      break;
80008178:	c1 d8       	rjmp	800081b2 <sd_mmc_spi_internal_init+0x1ca>
    case SD_CARD:
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
8000817a:	06 9b       	mov	r11,r3
8000817c:	00 9c       	mov	r12,r0
8000817e:	f0 1f 00 3d 	mcall	80008270 <sd_mmc_spi_internal_init+0x288>
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
80008182:	06 9b       	mov	r11,r3
80008184:	32 9c       	mov	r12,41
80008186:	f0 1f 00 3b 	mcall	80008270 <sd_mmc_spi_internal_init+0x288>
8000818a:	ac 8c       	st.b	r6[0x0],r12
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000818c:	04 9b       	mov	r11,r2
8000818e:	02 9c       	mov	r12,r1
80008190:	f0 1f 00 34 	mcall	80008260 <sd_mmc_spi_internal_init+0x278>
      break;
80008194:	c0 f8       	rjmp	800081b2 <sd_mmc_spi_internal_init+0x1ca>
    case SD_CARD_2:
      // set high capacity bit mask
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
80008196:	06 9b       	mov	r11,r3
80008198:	00 9c       	mov	r12,r0
8000819a:	f0 1f 00 36 	mcall	80008270 <sd_mmc_spi_internal_init+0x288>
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0x40000000);
8000819e:	fc 1b 40 00 	movh	r11,0x4000
800081a2:	32 9c       	mov	r12,41
800081a4:	f0 1f 00 33 	mcall	80008270 <sd_mmc_spi_internal_init+0x288>
800081a8:	ac 8c       	st.b	r6[0x0],r12
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800081aa:	04 9b       	mov	r11,r2
800081ac:	02 9c       	mov	r12,r1
800081ae:	f0 1f 00 2d 	mcall	80008260 <sd_mmc_spi_internal_init+0x278>
      break;
    }
     // do retry counter
     retry++;
800081b2:	2f f7       	sub	r7,-1
800081b4:	5c 87       	casts.h	r7
     if(retry == 50000)    // measured approx. 500 on several cards
800081b6:	fe 78 c3 50 	mov	r8,-15536
800081ba:	f0 07 19 00 	cp.h	r7,r8
800081be:	c4 80       	breq	8000824e <sd_mmc_spi_internal_init+0x266>
        return false;
  } while (r1);
800081c0:	0d 89       	ld.ub	r9,r6[0x0]
800081c2:	30 08       	mov	r8,0
800081c4:	f0 09 18 00 	cp.b	r9,r8
800081c8:	cc 51       	brne	80008152 <sd_mmc_spi_internal_init+0x16a>

  // CHECK FOR SDHC
  if(card_type == SD_CARD_2) {
800081ca:	4a 98       	lddpc	r8,8000826c <sd_mmc_spi_internal_init+0x284>
800081cc:	11 89       	ld.ub	r9,r8[0x0]
800081ce:	30 28       	mov	r8,2
800081d0:	f0 09 18 00 	cp.b	r9,r8
800081d4:	c0 a1       	brne	800081e8 <sd_mmc_spi_internal_init+0x200>
    if_cond = sd_mmc_spi_check_hc();
800081d6:	f0 1f 00 2a 	mcall	8000827c <sd_mmc_spi_internal_init+0x294>
    if (if_cond == -1) {
800081da:	5b fc       	cp.w	r12,-1
800081dc:	c3 90       	breq	8000824e <sd_mmc_spi_internal_init+0x266>
      return false;
    } else if (if_cond == 1){
800081de:	58 1c       	cp.w	r12,1
800081e0:	c0 41       	brne	800081e8 <sd_mmc_spi_internal_init+0x200>
          card_type = SD_CARD_2_SDHC;
800081e2:	30 39       	mov	r9,3
800081e4:	4a 28       	lddpc	r8,8000826c <sd_mmc_spi_internal_init+0x284>
800081e6:	b0 89       	st.b	r8[0x0],r9
      }
  }

  // DISABLE CRC TO SIMPLIFY AND SPEED UP COMMUNICATIONS
  r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0);  // disable CRC (should be already initialized on SPI init)
800081e8:	30 0b       	mov	r11,0
800081ea:	33 bc       	mov	r12,59
800081ec:	f0 1f 00 21 	mcall	80008270 <sd_mmc_spi_internal_init+0x288>
800081f0:	4a 17       	lddpc	r7,80008274 <sd_mmc_spi_internal_init+0x28c>
800081f2:	ae 8c       	st.b	r7[0x0],r12
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800081f4:	e0 6b 00 ff 	mov	r11,255
800081f8:	fe 7c 24 00 	mov	r12,-56320
800081fc:	f0 1f 00 19 	mcall	80008260 <sd_mmc_spi_internal_init+0x278>

  // SET BLOCK LENGTH TO 512 BYTES
  r1 = sd_mmc_spi_send_command(MMC_SET_BLOCKLEN, 512);
80008200:	e0 6b 02 00 	mov	r11,512
80008204:	31 0c       	mov	r12,16
80008206:	f0 1f 00 1b 	mcall	80008270 <sd_mmc_spi_internal_init+0x288>
8000820a:	ae 8c       	st.b	r7[0x0],r12
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000820c:	e0 6b 00 ff 	mov	r11,255
80008210:	fe 7c 24 00 	mov	r12,-56320
80008214:	f0 1f 00 13 	mcall	80008260 <sd_mmc_spi_internal_init+0x278>
  if (r1 != 0x00)
80008218:	0f 89       	ld.ub	r9,r7[0x0]
8000821a:	30 08       	mov	r8,0
8000821c:	f0 09 18 00 	cp.b	r9,r8
80008220:	c1 71       	brne	8000824e <sd_mmc_spi_internal_init+0x266>
    return false;    // card unsupported if block length of 512b is not accepted

  // GET CARD SPECIFIC DATA
  if (false ==  sd_mmc_spi_get_csd(csd))
80008222:	49 8c       	lddpc	r12,80008280 <sd_mmc_spi_internal_init+0x298>
80008224:	f0 1f 00 18 	mcall	80008284 <sd_mmc_spi_internal_init+0x29c>
80008228:	c1 30       	breq	8000824e <sd_mmc_spi_internal_init+0x266>
    return false;

  // GET CARD CAPACITY and NUMBER OF SECTORS
  sd_mmc_spi_get_capacity();
8000822a:	f0 1f 00 18 	mcall	80008288 <sd_mmc_spi_internal_init+0x2a0>
#if (defined SD_MMC_READ_CID) && (SD_MMC_READ_CID == true)
  if (false ==  sd_mmc_spi_get_cid(cid))
    return false;
#endif

  sd_mmc_spi_init_done = true;
8000822e:	30 19       	mov	r9,1
80008230:	48 e8       	lddpc	r8,80008268 <sd_mmc_spi_internal_init+0x280>
80008232:	b0 89       	st.b	r8[0x0],r9

  // Set SPI Speed to MAX
  sd_mmc_opt.baudrate = SD_MMC_SPI_MASTER_SPEED;
80008234:	48 7b       	lddpc	r11,80008250 <sd_mmc_spi_internal_init+0x268>
80008236:	e0 68 1b 00 	mov	r8,6912
8000823a:	ea 18 00 b7 	orh	r8,0xb7
8000823e:	97 18       	st.w	r11[0x4],r8
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
80008240:	48 58       	lddpc	r8,80008254 <sd_mmc_spi_internal_init+0x26c>
80008242:	70 0a       	ld.w	r10,r8[0x0]
80008244:	fe 7c 24 00 	mov	r12,-56320
80008248:	f0 1f 00 04 	mcall	80008258 <sd_mmc_spi_internal_init+0x270>
8000824c:	da 3a       	popm	r0-r7,pc,r12=1
  return true;
8000824e:	d8 3a       	popm	r0-r7,pc,r12=0
80008250:	00 00       	add	r0,r0
80008252:	06 4c       	or	r12,r3
80008254:	00 00       	add	r0,r0
80008256:	06 5c       	eor	r12,r3
80008258:	80 00       	ld.sh	r0,r0[0x0]
8000825a:	8a cc       	ld.uh	r12,r5[0x8]
8000825c:	80 00       	ld.sh	r0,r0[0x0]
8000825e:	8a 5a       	ld.sh	r10,r5[0xa]
80008260:	80 00       	ld.sh	r0,r0[0x0]
80008262:	8b 8a       	st.w	r5[0x20],r10
80008264:	80 00       	ld.sh	r0,r0[0x0]
80008266:	8a a6       	ld.uh	r6,r5[0x4]
80008268:	00 00       	add	r0,r0
8000826a:	06 60       	and	r0,r3
8000826c:	00 00       	add	r0,r0
8000826e:	09 be       	ld.ub	lr,r4[0x3]
80008270:	80 00       	ld.sh	r0,r0[0x0]
80008272:	7a 58       	ld.w	r8,sp[0x14]
80008274:	00 00       	add	r0,r0
80008276:	09 d0       	ld.ub	r0,r4[0x5]
80008278:	80 00       	ld.sh	r0,r0[0x0]
8000827a:	7c ec       	ld.w	r12,lr[0x38]
8000827c:	80 00       	ld.sh	r0,r0[0x0]
8000827e:	7c 60       	ld.w	r0,lr[0x18]
80008280:	00 00       	add	r0,r0
80008282:	09 c0       	ld.ub	r0,r4[0x4]
80008284:	80 00       	ld.sh	r0,r0[0x0]
80008286:	7e f4       	ld.w	r4,pc[0x3c]
80008288:	80 00       	ld.sh	r0,r0[0x0]
8000828a:	77 60       	ld.w	r0,r11[0x58]

8000828c <sd_mmc_spi_mem_check>:
//!
//! @return bit
//!   The memory is ready     -> true
//!   The memory check failed -> false
bool sd_mmc_spi_mem_check(void)
{
8000828c:	d4 01       	pushm	lr
  if (sd_mmc_spi_check_presence())
8000828e:	f0 1f 00 07 	mcall	800082a8 <sd_mmc_spi_mem_check+0x1c>
80008292:	c0 a0       	breq	800082a6 <sd_mmc_spi_mem_check+0x1a>
  {
    if (sd_mmc_spi_init_done == false)
80008294:	48 68       	lddpc	r8,800082ac <sd_mmc_spi_mem_check+0x20>
80008296:	11 89       	ld.ub	r9,r8[0x0]
80008298:	30 08       	mov	r8,0
8000829a:	f0 09 18 00 	cp.b	r9,r8
8000829e:	c0 20       	breq	800082a2 <sd_mmc_spi_mem_check+0x16>
800082a0:	da 0a       	popm	pc,r12=1
    {
      return sd_mmc_spi_internal_init();
800082a2:	f0 1f 00 04 	mcall	800082b0 <sd_mmc_spi_mem_check+0x24>
    }
    else
      return true;
  }
  return false;
}
800082a6:	d8 02       	popm	pc
800082a8:	80 00       	ld.sh	r0,r0[0x0]
800082aa:	7a 98       	ld.w	r8,sp[0x24]
800082ac:	00 00       	add	r0,r0
800082ae:	06 60       	and	r0,r3
800082b0:	80 00       	ld.sh	r0,r0[0x0]
800082b2:	7f e8       	ld.w	r8,pc[0x78]

800082b4 <sd_mmc_spi_init>:
//!
//!
//! @return bit
//!   The memory is ready     -> true (always)
bool sd_mmc_spi_init(spi_options_t spiOptions, unsigned int pba_hz)
{
800082b4:	eb cd 40 10 	pushm	r4,lr
800082b8:	fa c4 ff f8 	sub	r4,sp,-8
  // Keep SPI options internally
  sd_mmc_pba_hz = pba_hz;
800082bc:	48 88       	lddpc	r8,800082dc <sd_mmc_spi_init+0x28>
800082be:	91 0c       	st.w	r8[0x0],r12
  memcpy( &sd_mmc_opt, &spiOptions, sizeof(spi_options_t) );
800082c0:	48 88       	lddpc	r8,800082e0 <sd_mmc_spi_init+0x2c>
800082c2:	e8 ea 00 00 	ld.d	r10,r4[0]
800082c6:	f0 eb 00 00 	st.d	r8[0],r10
800082ca:	e8 ea 00 08 	ld.d	r10,r4[8]
800082ce:	f0 eb 00 08 	st.d	r8[8],r10

  // Initialize the SD/MMC controller.
  return sd_mmc_spi_internal_init();
800082d2:	f0 1f 00 05 	mcall	800082e4 <sd_mmc_spi_init+0x30>
}
800082d6:	e3 cd 80 10 	ldm	sp++,r4,pc
800082da:	00 00       	add	r0,r0
800082dc:	00 00       	add	r0,r0
800082de:	06 5c       	eor	r12,r3
800082e0:	00 00       	add	r0,r0
800082e2:	06 4c       	or	r12,r3
800082e4:	80 00       	ld.sh	r0,r0[0x0]
800082e6:	7f e8       	ld.w	r8,pc[0x78]

800082e8 <sd_mmc_spi_wr_protect>:
//! @return false  -> the memory is not write-protected (always)
//!/
bool  sd_mmc_spi_wr_protect(void)
{
   return false;
}
800082e8:	5e fd       	retal	0

800082ea <sd_mmc_spi_removal>:
//!/
bool  sd_mmc_spi_removal(void)
{
  return false;
//  return ((sd_mmc_spi_check_presence()) ? false : true);
}
800082ea:	5e fd       	retal	0

800082ec <sd_mmc_spi_test_unit_ready>:
}



Ctrl_status sd_mmc_spi_test_unit_ready(void)
{
800082ec:	d4 01       	pushm	lr
  Sd_mmc_spi_access_signal_on();
  switch (sd_mmc_spi_presence_status)
800082ee:	49 88       	lddpc	r8,8000834c <sd_mmc_spi_test_unit_ready+0x60>
800082f0:	11 88       	ld.ub	r8,r8[0x0]
800082f2:	30 19       	mov	r9,1
800082f4:	f2 08 18 00 	cp.b	r8,r9
800082f8:	c1 40       	breq	80008320 <sd_mmc_spi_test_unit_ready+0x34>
800082fa:	c0 63       	brcs	80008306 <sd_mmc_spi_test_unit_ready+0x1a>
800082fc:	30 29       	mov	r9,2
800082fe:	f2 08 18 00 	cp.b	r8,r9
80008302:	c2 01       	brne	80008342 <sd_mmc_spi_test_unit_ready+0x56>
80008304:	c1 a8       	rjmp	80008338 <sd_mmc_spi_test_unit_ready+0x4c>
  {
    case SD_MMC_REMOVED:
      sd_mmc_spi_init_done = false;
80008306:	30 09       	mov	r9,0
80008308:	49 28       	lddpc	r8,80008350 <sd_mmc_spi_test_unit_ready+0x64>
8000830a:	b0 89       	st.b	r8[0x0],r9
      if (sd_mmc_spi_mem_check())
8000830c:	f0 1f 00 12 	mcall	80008354 <sd_mmc_spi_test_unit_ready+0x68>
80008310:	c0 31       	brne	80008316 <sd_mmc_spi_test_unit_ready+0x2a>
80008312:	30 2c       	mov	r12,2
80008314:	d8 02       	popm	pc
      {
        sd_mmc_spi_presence_status = SD_MMC_INSERTED;
80008316:	30 19       	mov	r9,1
80008318:	48 d8       	lddpc	r8,8000834c <sd_mmc_spi_test_unit_ready+0x60>
8000831a:	b0 89       	st.b	r8[0x0],r9
8000831c:	30 3c       	mov	r12,3
        Sd_mmc_spi_access_signal_off();
        return CTRL_BUSY;
8000831e:	d8 02       	popm	pc
      }
      Sd_mmc_spi_access_signal_off();
      return CTRL_NO_PRESENT;

    case SD_MMC_INSERTED:
      if (!sd_mmc_spi_mem_check())
80008320:	f0 1f 00 0d 	mcall	80008354 <sd_mmc_spi_test_unit_ready+0x68>
80008324:	c0 20       	breq	80008328 <sd_mmc_spi_test_unit_ready+0x3c>
80008326:	d8 0a       	popm	pc,r12=0
      {
        sd_mmc_spi_presence_status = SD_MMC_REMOVING;
80008328:	30 29       	mov	r9,2
8000832a:	48 98       	lddpc	r8,8000834c <sd_mmc_spi_test_unit_ready+0x60>
8000832c:	b0 89       	st.b	r8[0x0],r9
        sd_mmc_spi_init_done = false;
8000832e:	30 09       	mov	r9,0
80008330:	48 88       	lddpc	r8,80008350 <sd_mmc_spi_test_unit_ready+0x64>
80008332:	b0 89       	st.b	r8[0x0],r9
80008334:	30 3c       	mov	r12,3
        Sd_mmc_spi_access_signal_off();
        return CTRL_BUSY;
80008336:	d8 02       	popm	pc
      }
      Sd_mmc_spi_access_signal_off();
      return CTRL_GOOD;

    case SD_MMC_REMOVING:
      sd_mmc_spi_presence_status = SD_MMC_REMOVED;
80008338:	30 09       	mov	r9,0
8000833a:	48 58       	lddpc	r8,8000834c <sd_mmc_spi_test_unit_ready+0x60>
8000833c:	b0 89       	st.b	r8[0x0],r9
8000833e:	30 2c       	mov	r12,2
      Sd_mmc_spi_access_signal_off();
      return CTRL_NO_PRESENT;
80008340:	d8 02       	popm	pc

    default:
      sd_mmc_spi_presence_status = SD_MMC_REMOVED;
80008342:	30 09       	mov	r9,0
80008344:	48 28       	lddpc	r8,8000834c <sd_mmc_spi_test_unit_ready+0x60>
80008346:	b0 89       	st.b	r8[0x0],r9
80008348:	30 3c       	mov	r12,3
    }
    else
      return CTRL_NO_PRESENT;
  }
*/
}
8000834a:	d8 02       	popm	pc
8000834c:	00 00       	add	r0,r0
8000834e:	00 e0       	st.h	--r0,r0
80008350:	00 00       	add	r0,r0
80008352:	06 60       	and	r0,r3
80008354:	80 00       	ld.sh	r0,r0[0x0]
80008356:	82 8c       	ld.uh	r12,r1[0x0]

80008358 <sd_mmc_spi_mem_init>:

//_____ D E C L A R A T I O N ______________________________________________


void sd_mmc_spi_mem_init(void)
{
80008358:	d4 01       	pushm	lr
  sd_mmc_spi_internal_init();        // Restart Init of SD/MMC card after previous first init
8000835a:	f0 1f 00 02 	mcall	80008360 <sd_mmc_spi_mem_init+0x8>
}
8000835e:	d8 02       	popm	pc
80008360:	80 00       	ld.sh	r0,r0[0x0]
80008362:	7f e8       	ld.w	r8,pc[0x78]

80008364 <sd_mmc_spi_ram_2_mem>:
//! @return                Ctrl_status
//!   It is ready      ->    CTRL_GOOD
//!   An error occurs  ->    CTRL_FAIL
//!
Ctrl_status    sd_mmc_spi_ram_2_mem(uint32_t addr, const void *ram)
{
80008364:	eb cd 40 c0 	pushm	r6-r7,lr
80008368:	18 96       	mov	r6,r12
8000836a:	16 97       	mov	r7,r11
   Sd_mmc_spi_access_signal_on();
   sd_mmc_spi_check_presence();
8000836c:	f0 1f 00 12 	mcall	800083b4 <sd_mmc_spi_ram_2_mem+0x50>

   if (!sd_mmc_spi_init_done)
80008370:	49 28       	lddpc	r8,800083b8 <sd_mmc_spi_ram_2_mem+0x54>
80008372:	11 89       	ld.ub	r9,r8[0x0]
80008374:	30 08       	mov	r8,0
80008376:	f0 09 18 00 	cp.b	r9,r8
8000837a:	c0 c1       	brne	80008392 <sd_mmc_spi_ram_2_mem+0x2e>
   {
      sd_mmc_spi_mem_init();
8000837c:	f0 1f 00 10 	mcall	800083bc <sd_mmc_spi_ram_2_mem+0x58>
   }

   if (sd_mmc_spi_init_done)
80008380:	48 e8       	lddpc	r8,800083b8 <sd_mmc_spi_ram_2_mem+0x54>
80008382:	11 89       	ld.ub	r9,r8[0x0]
80008384:	30 08       	mov	r8,0
80008386:	f0 09 18 00 	cp.b	r9,r8
8000838a:	c0 41       	brne	80008392 <sd_mmc_spi_ram_2_mem+0x2e>
8000838c:	30 2c       	mov	r12,2
8000838e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
   {
     sd_mmc_spi_write_open(addr);
80008392:	0c 9c       	mov	r12,r6
80008394:	f0 1f 00 0b 	mcall	800083c0 <sd_mmc_spi_ram_2_mem+0x5c>
     if (!sd_mmc_spi_write_sector_from_ram(ram))
80008398:	0e 9c       	mov	r12,r7
8000839a:	f0 1f 00 0b 	mcall	800083c4 <sd_mmc_spi_ram_2_mem+0x60>
8000839e:	c0 61       	brne	800083aa <sd_mmc_spi_ram_2_mem+0x46>
     {
       sd_mmc_spi_write_close();
800083a0:	f0 1f 00 0a 	mcall	800083c8 <sd_mmc_spi_ram_2_mem+0x64>
800083a4:	30 2c       	mov	r12,2
       Sd_mmc_spi_access_signal_off();
       return CTRL_NO_PRESENT;
800083a6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
     }
     sd_mmc_spi_write_close();
800083aa:	f0 1f 00 08 	mcall	800083c8 <sd_mmc_spi_ram_2_mem+0x64>
800083ae:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
800083b2:	00 00       	add	r0,r0
800083b4:	80 00       	ld.sh	r0,r0[0x0]
800083b6:	7a 98       	ld.w	r8,sp[0x24]
800083b8:	00 00       	add	r0,r0
800083ba:	06 60       	and	r0,r3
800083bc:	80 00       	ld.sh	r0,r0[0x0]
800083be:	83 58       	st.w	r1[0x14],r8
800083c0:	80 00       	ld.sh	r0,r0[0x0]
800083c2:	79 54       	ld.w	r4,r12[0x54]
800083c4:	80 00       	ld.sh	r0,r0[0x0]
800083c6:	7b 14       	ld.w	r4,sp[0x44]
800083c8:	80 00       	ld.sh	r0,r0[0x0]
800083ca:	78 7c       	ld.w	r12,r12[0x1c]

800083cc <sd_mmc_spi_mem_2_ram>:
//------------ Standard functions for read/write 1 sector to 1 sector ram buffer -----------------

#if ACCESS_MEM_TO_RAM == true

Ctrl_status sd_mmc_spi_mem_2_ram(uint32_t addr, void *ram)
{
800083cc:	eb cd 40 c0 	pushm	r6-r7,lr
800083d0:	18 97       	mov	r7,r12
800083d2:	16 96       	mov	r6,r11
   Sd_mmc_spi_access_signal_on();
   sd_mmc_spi_check_presence();
800083d4:	f0 1f 00 12 	mcall	8000841c <sd_mmc_spi_mem_2_ram+0x50>

   if (!sd_mmc_spi_init_done)
800083d8:	49 28       	lddpc	r8,80008420 <sd_mmc_spi_mem_2_ram+0x54>
800083da:	11 89       	ld.ub	r9,r8[0x0]
800083dc:	30 08       	mov	r8,0
800083de:	f0 09 18 00 	cp.b	r9,r8
800083e2:	c0 c1       	brne	800083fa <sd_mmc_spi_mem_2_ram+0x2e>
   {
      sd_mmc_spi_mem_init();
800083e4:	f0 1f 00 10 	mcall	80008424 <sd_mmc_spi_mem_2_ram+0x58>
   }

   if (!sd_mmc_spi_init_done)
800083e8:	48 e8       	lddpc	r8,80008420 <sd_mmc_spi_mem_2_ram+0x54>
800083ea:	11 89       	ld.ub	r9,r8[0x0]
800083ec:	30 08       	mov	r8,0
800083ee:	f0 09 18 00 	cp.b	r9,r8
800083f2:	c0 41       	brne	800083fa <sd_mmc_spi_mem_2_ram+0x2e>
800083f4:	30 2c       	mov	r12,2
800083f6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
     return CTRL_NO_PRESENT;

   if( !sd_mmc_spi_read_open(addr) )
800083fa:	0e 9c       	mov	r12,r7
800083fc:	f0 1f 00 0b 	mcall	80008428 <sd_mmc_spi_mem_2_ram+0x5c>
80008400:	c0 c0       	breq	80008418 <sd_mmc_spi_mem_2_ram+0x4c>
     goto sd_mmc_spi_mem_2_ram_fail;

   if( !sd_mmc_spi_read_sector_to_ram(ram))
80008402:	0c 9c       	mov	r12,r6
80008404:	f0 1f 00 0a 	mcall	8000842c <sd_mmc_spi_mem_2_ram+0x60>
80008408:	c0 80       	breq	80008418 <sd_mmc_spi_mem_2_ram+0x4c>
     goto sd_mmc_spi_mem_2_ram_fail;

   if( !sd_mmc_spi_read_close() )
8000840a:	f0 1f 00 0a 	mcall	80008430 <sd_mmc_spi_mem_2_ram+0x64>
8000840e:	ec 1c 00 01 	eorl	r12,0x1
80008412:	5c 5c       	castu.b	r12
80008414:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80008418:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000841c:	80 00       	ld.sh	r0,r0[0x0]
8000841e:	7a 98       	ld.w	r8,sp[0x24]
80008420:	00 00       	add	r0,r0
80008422:	06 60       	and	r0,r3
80008424:	80 00       	ld.sh	r0,r0[0x0]
80008426:	83 58       	st.w	r1[0x14],r8
80008428:	80 00       	ld.sh	r0,r0[0x0]
8000842a:	79 78       	ld.w	r8,r12[0x5c]
8000842c:	80 00       	ld.sh	r0,r0[0x0]
8000842e:	7d a4       	ld.w	r4,lr[0x68]
80008430:	80 00       	ld.sh	r0,r0[0x0]
80008432:	79 6c       	ld.w	r12,r12[0x58]

80008434 <sd_mmc_spi_read_capacity>:
}



Ctrl_status sd_mmc_spi_read_capacity(uint32_t *nb_sector)
{
80008434:	eb cd 40 80 	pushm	r7,lr
80008438:	18 97       	mov	r7,r12
//   sd_mmc_spi_check_presence();   // omitted because creates interferences with "sd_mmc_spi_test_unit_ready()" function
   Sd_mmc_spi_access_signal_on();

   if (!sd_mmc_spi_init_done)
8000843a:	48 c8       	lddpc	r8,80008468 <sd_mmc_spi_read_capacity+0x34>
8000843c:	11 89       	ld.ub	r9,r8[0x0]
8000843e:	30 08       	mov	r8,0
80008440:	f0 09 18 00 	cp.b	r9,r8
80008444:	c0 c1       	brne	8000845c <sd_mmc_spi_read_capacity+0x28>
   {
      sd_mmc_spi_mem_init();
80008446:	f0 1f 00 0a 	mcall	8000846c <sd_mmc_spi_read_capacity+0x38>
   }

   if (sd_mmc_spi_init_done)
8000844a:	48 88       	lddpc	r8,80008468 <sd_mmc_spi_read_capacity+0x34>
8000844c:	11 89       	ld.ub	r9,r8[0x0]
8000844e:	30 08       	mov	r8,0
80008450:	f0 09 18 00 	cp.b	r9,r8
80008454:	c0 41       	brne	8000845c <sd_mmc_spi_read_capacity+0x28>
80008456:	30 2c       	mov	r12,2
80008458:	e3 cd 80 80 	ldm	sp++,r7,pc
   {
     *nb_sector = sd_mmc_spi_last_block_address+1;
8000845c:	48 58       	lddpc	r8,80008470 <sd_mmc_spi_read_capacity+0x3c>
8000845e:	70 08       	ld.w	r8,r8[0x0]
80008460:	2f f8       	sub	r8,-1
80008462:	8f 08       	st.w	r7[0x0],r8
80008464:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
80008468:	00 00       	add	r0,r0
8000846a:	06 60       	and	r0,r3
8000846c:	80 00       	ld.sh	r0,r0[0x0]
8000846e:	83 58       	st.w	r1[0x14],r8
80008470:	00 00       	add	r0,r0
80008472:	09 b8       	ld.ub	r8,r4[0x3]

80008474 <smc_init>:

static void smc_enable_muxed_pins(void);


void smc_init(unsigned long hsb_hz)
{
80008474:	eb cd 40 fc 	pushm	r2-r7,lr
  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
80008478:	ee 78 42 3f 	mov	r8,999999
8000847c:	f8 08 00 09 	add	r9,r12,r8
80008480:	e0 68 de 83 	mov	r8,56963
80008484:	ea 18 43 1b 	orh	r8,0x431b
80008488:	f2 08 06 48 	mulu.d	r8,r9,r8
8000848c:	f2 08 16 12 	lsr	r8,r9,0x12
//! Whether to use the NCS0 pin
#ifdef SMC_USE_NCS0
  #include SMC_COMPONENT_CS0

  // Setup SMC for NCS0
  SMC_CS_SETUP(0)
80008490:	f0 08 00 25 	add	r5,r8,r8<<0x2
80008494:	a3 65       	lsl	r5,0x2
80008496:	ea c5 fc 19 	sub	r5,r5,-999
8000849a:	e0 69 4d d3 	mov	r9,19923
8000849e:	ea 19 10 62 	orh	r9,0x1062
800084a2:	ea 09 06 44 	mulu.d	r4,r5,r9
800084a6:	a7 85       	lsr	r5,0x6
800084a8:	f0 0a 15 04 	lsl	r10,r8,0x4
800084ac:	f4 08 01 07 	sub	r7,r10,r8
800084b0:	a1 77       	lsl	r7,0x1
800084b2:	ee c7 fc 19 	sub	r7,r7,-999
800084b6:	ee 09 06 46 	mulu.d	r6,r7,r9
800084ba:	0e 94       	mov	r4,r7
800084bc:	a7 84       	lsr	r4,0x6
800084be:	f4 08 01 07 	sub	r7,r10,r8
800084c2:	a3 67       	lsl	r7,0x2
800084c4:	ee c7 fc 19 	sub	r7,r7,-999
800084c8:	ee 09 06 46 	mulu.d	r6,r7,r9
800084cc:	a7 87       	lsr	r7,0x6
800084ce:	f0 03 10 5a 	mul	r3,r8,90
800084d2:	e6 c3 fc 19 	sub	r3,r3,-999
800084d6:	e6 09 06 42 	mulu.d	r2,r3,r9
800084da:	e6 0c 16 06 	lsr	r12,r3,0x6
800084de:	e0 63 00 d2 	mov	r3,210
800084e2:	f0 03 02 43 	mul	r3,r8,r3
800084e6:	e6 c3 fc 19 	sub	r3,r3,-999
800084ea:	e6 09 06 42 	mulu.d	r2,r3,r9
800084ee:	e6 06 16 06 	lsr	r6,r3,0x6
800084f2:	f4 08 01 0b 	sub	r11,r10,r8
800084f6:	a5 6b       	lsl	r11,0x4
800084f8:	f6 cb fc 19 	sub	r11,r11,-999
800084fc:	f6 09 06 4a 	mulu.d	r10,r11,r9
80008500:	f6 0e 16 06 	lsr	lr,r11,0x6
80008504:	f0 03 10 64 	mul	r3,r8,100
80008508:	e6 c3 fc 19 	sub	r3,r3,-999
8000850c:	e6 09 06 42 	mulu.d	r2,r3,r9
80008510:	a7 83       	lsr	r3,0x6
80008512:	e0 6a 01 0e 	mov	r10,270
80008516:	b5 38       	mul	r8,r10
80008518:	f0 c8 fc 19 	sub	r8,r8,-999
8000851c:	f0 09 06 48 	mulu.d	r8,r8,r9
80008520:	a7 89       	lsr	r9,0x6
80008522:	ec 04 00 0a 	add	r10,r6,r4
80008526:	1c 3a       	cp.w	r10,lr
80008528:	f4 0e 17 20 	movhs	lr,r10
8000852c:	ee 05 00 0b 	add	r11,r7,r5
80008530:	18 3b       	cp.w	r11,r12
80008532:	f6 0c 17 20 	movhs	r12,r11
80008536:	06 3b       	cp.w	r11,r3
80008538:	e6 0b 17 30 	movlo	r11,r3
8000853c:	12 3a       	cp.w	r10,r9
8000853e:	f4 09 17 20 	movhs	r9,r10
80008542:	eb e4 11 05 	or	r5,r5,r4<<0x10
80008546:	fe 6a 1c 00 	mov	r10,-123904
8000854a:	95 05       	st.w	r10[0x0],r5
8000854c:	ef e6 11 07 	or	r7,r7,r6<<0x10
80008550:	ef ec 10 87 	or	r7,r7,r12<<0x8
80008554:	ef ee 11 87 	or	r7,r7,lr<<0x18
80008558:	95 17       	st.w	r10[0x4],r7
8000855a:	1c 39       	cp.w	r9,lr
8000855c:	f2 0e 17 20 	movhs	lr,r9
80008560:	18 3b       	cp.w	r11,r12
80008562:	f8 0b 17 30 	movlo	r11,r12
80008566:	f7 ee 11 0b 	or	r11,r11,lr<<0x10
8000856a:	95 2b       	st.w	r10[0x8],r11
8000856c:	e0 68 10 03 	mov	r8,4099
80008570:	95 38       	st.w	r10[0xc],r8
80008572:	30 19       	mov	r9,1
80008574:	48 48       	lddpc	r8,80008584 <smc_init+0x110>
80008576:	b0 89       	st.b	r8[0x0],r9
        {ATPASTE2(EBI_NCS_5,_PIN),ATPASTE2(EBI_NCS_5,_FUNCTION)},
    #endif
#endif
 };

  gpio_enable_module(SMC_EBI_GPIO_MAP, sizeof(SMC_EBI_GPIO_MAP) / sizeof(SMC_EBI_GPIO_MAP[0]));
80008578:	31 4b       	mov	r11,20
8000857a:	48 4c       	lddpc	r12,80008588 <smc_init+0x114>
8000857c:	f0 1f 00 04 	mcall	8000858c <smc_init+0x118>
  #undef NCS_CONTROLLED_WRITE
  #undef NWAIT_MODE
#endif
  // Put the multiplexed MCU pins used for the SM under control of the SMC.
  smc_enable_muxed_pins();
}
80008580:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80008584:	00 00       	add	r0,r0
80008586:	06 64       	and	r4,r3
80008588:	80 01       	ld.sh	r1,r0[0x0]
8000858a:	61 20       	ld.w	r0,r0[0x48]
8000858c:	80 00       	ld.sh	r0,r0[0x0]
8000858e:	85 e4       	st.w	r2[0x38],r4

80008590 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80008590:	f8 08 16 05 	lsr	r8,r12,0x5
80008594:	a9 68       	lsl	r8,0x8
80008596:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
8000859a:	58 1b       	cp.w	r11,1
8000859c:	c0 d0       	breq	800085b6 <gpio_enable_module_pin+0x26>
8000859e:	c0 63       	brcs	800085aa <gpio_enable_module_pin+0x1a>
800085a0:	58 2b       	cp.w	r11,2
800085a2:	c1 00       	breq	800085c2 <gpio_enable_module_pin+0x32>
800085a4:	58 3b       	cp.w	r11,3
800085a6:	c1 40       	breq	800085ce <gpio_enable_module_pin+0x3e>
800085a8:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800085aa:	30 19       	mov	r9,1
800085ac:	f2 0c 09 49 	lsl	r9,r9,r12
800085b0:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800085b2:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800085b4:	c1 28       	rjmp	800085d8 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800085b6:	30 19       	mov	r9,1
800085b8:	f2 0c 09 49 	lsl	r9,r9,r12
800085bc:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800085be:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800085c0:	c0 c8       	rjmp	800085d8 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800085c2:	30 19       	mov	r9,1
800085c4:	f2 0c 09 49 	lsl	r9,r9,r12
800085c8:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800085ca:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800085cc:	c0 68       	rjmp	800085d8 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800085ce:	30 19       	mov	r9,1
800085d0:	f2 0c 09 49 	lsl	r9,r9,r12
800085d4:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800085d6:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800085d8:	30 19       	mov	r9,1
800085da:	f2 0c 09 4c 	lsl	r12,r9,r12
800085de:	91 2c       	st.w	r8[0x8],r12
800085e0:	5e fd       	retal	0
800085e2:	d7 03       	nop

800085e4 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800085e4:	d4 21       	pushm	r4-r7,lr
800085e6:	18 97       	mov	r7,r12
800085e8:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800085ea:	58 0b       	cp.w	r11,0
800085ec:	c0 31       	brne	800085f2 <gpio_enable_module+0xe>
800085ee:	30 05       	mov	r5,0
800085f0:	c0 d8       	rjmp	8000860a <gpio_enable_module+0x26>
800085f2:	30 06       	mov	r6,0
800085f4:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800085f6:	6e 1b       	ld.w	r11,r7[0x4]
800085f8:	6e 0c       	ld.w	r12,r7[0x0]
800085fa:	f0 1f 00 06 	mcall	80008610 <gpio_enable_module+0x2c>
800085fe:	18 45       	or	r5,r12
		gpiomap++;
80008600:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80008602:	2f f6       	sub	r6,-1
80008604:	0c 34       	cp.w	r4,r6
80008606:	fe 9b ff f8 	brhi	800085f6 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000860a:	0a 9c       	mov	r12,r5
8000860c:	d8 22       	popm	r4-r7,pc
8000860e:	00 00       	add	r0,r0
80008610:	80 00       	ld.sh	r0,r0[0x0]
80008612:	85 90       	st.w	r2[0x24],r0

80008614 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80008614:	f8 08 16 05 	lsr	r8,r12,0x5
80008618:	a9 68       	lsl	r8,0x8
8000861a:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
8000861e:	30 19       	mov	r9,1
80008620:	f2 0c 09 4c 	lsl	r12,r9,r12
80008624:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80008628:	91 1c       	st.w	r8[0x4],r12
}
8000862a:	5e fc       	retal	r12

8000862c <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000862c:	f8 08 16 05 	lsr	r8,r12,0x5
80008630:	a9 68       	lsl	r8,0x8
80008632:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80008636:	30 19       	mov	r9,1
80008638:	f2 0c 09 4c 	lsl	r12,r9,r12
8000863c:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80008640:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80008644:	91 1c       	st.w	r8[0x4],r12
}
80008646:	5e fc       	retal	r12

80008648 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80008648:	f8 08 16 05 	lsr	r8,r12,0x5
8000864c:	a9 68       	lsl	r8,0x8
8000864e:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80008652:	30 19       	mov	r9,1
80008654:	f2 0c 09 4c 	lsl	r12,r9,r12
80008658:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
8000865c:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80008660:	91 1c       	st.w	r8[0x4],r12
}
80008662:	5e fc       	retal	r12

80008664 <gpio_tgl_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_tgl_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80008664:	f8 08 16 05 	lsr	r8,r12,0x5
80008668:	a9 68       	lsl	r8,0x8
8000866a:	e0 28 f0 00 	sub	r8,61440
	
	/* Toggle the I/O line. */
	gpio_port->ovrt  = 1 << (pin & 0x1F);
8000866e:	30 19       	mov	r9,1
80008670:	f2 0c 09 4c 	lsl	r12,r9,r12
80008674:	f1 4c 00 5c 	st.w	r8[92],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80008678:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000867c:	91 1c       	st.w	r8[0x4],r12
}
8000867e:	5e fc       	retal	r12

80008680 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80008680:	c0 08       	rjmp	80008680 <_unhandled_interrupt>
80008682:	d7 03       	nop

80008684 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80008684:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80008688:	49 99       	lddpc	r9,800086ec <INTC_register_interrupt+0x68>
8000868a:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000868e:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80008692:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80008694:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80008698:	58 0a       	cp.w	r10,0
8000869a:	c0 91       	brne	800086ac <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000869c:	49 59       	lddpc	r9,800086f0 <INTC_register_interrupt+0x6c>
8000869e:	49 6a       	lddpc	r10,800086f4 <INTC_register_interrupt+0x70>
800086a0:	12 1a       	sub	r10,r9
800086a2:	fe 79 08 00 	mov	r9,-63488
800086a6:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800086aa:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
800086ac:	58 1a       	cp.w	r10,1
800086ae:	c0 a1       	brne	800086c2 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800086b0:	49 09       	lddpc	r9,800086f0 <INTC_register_interrupt+0x6c>
800086b2:	49 2a       	lddpc	r10,800086f8 <INTC_register_interrupt+0x74>
800086b4:	12 1a       	sub	r10,r9
800086b6:	bf aa       	sbr	r10,0x1e
800086b8:	fe 79 08 00 	mov	r9,-63488
800086bc:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800086c0:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800086c2:	58 2a       	cp.w	r10,2
800086c4:	c0 a1       	brne	800086d8 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800086c6:	48 b9       	lddpc	r9,800086f0 <INTC_register_interrupt+0x6c>
800086c8:	48 da       	lddpc	r10,800086fc <INTC_register_interrupt+0x78>
800086ca:	12 1a       	sub	r10,r9
800086cc:	bf ba       	sbr	r10,0x1f
800086ce:	fe 79 08 00 	mov	r9,-63488
800086d2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800086d6:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800086d8:	48 69       	lddpc	r9,800086f0 <INTC_register_interrupt+0x6c>
800086da:	48 aa       	lddpc	r10,80008700 <INTC_register_interrupt+0x7c>
800086dc:	12 1a       	sub	r10,r9
800086de:	ea 1a c0 00 	orh	r10,0xc000
800086e2:	fe 79 08 00 	mov	r9,-63488
800086e6:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800086ea:	5e fc       	retal	r12
800086ec:	80 01       	ld.sh	r1,r0[0x0]
800086ee:	61 c0       	ld.w	r0,r0[0x70]
800086f0:	80 01       	ld.sh	r1,r0[0x0]
800086f2:	2e 00       	sub	r0,-32
800086f4:	80 01       	ld.sh	r1,r0[0x0]
800086f6:	2f 04       	sub	r4,-16
800086f8:	80 01       	ld.sh	r1,r0[0x0]
800086fa:	2f 12       	sub	r2,-15
800086fc:	80 01       	ld.sh	r1,r0[0x0]
800086fe:	2f 20       	sub	r0,-14
80008700:	80 01       	ld.sh	r1,r0[0x0]
80008702:	2f 2e       	sub	lr,-14

80008704 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80008704:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80008706:	49 18       	lddpc	r8,80008748 <INTC_init_interrupts+0x44>
80008708:	e3 b8 00 01 	mtsr	0x4,r8
8000870c:	49 0e       	lddpc	lr,8000874c <INTC_init_interrupts+0x48>
8000870e:	30 07       	mov	r7,0
80008710:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80008712:	49 0c       	lddpc	r12,80008750 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80008714:	49 05       	lddpc	r5,80008754 <INTC_init_interrupts+0x50>
80008716:	10 15       	sub	r5,r8
80008718:	fe 76 08 00 	mov	r6,-63488
8000871c:	c1 08       	rjmp	8000873c <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000871e:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80008720:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80008722:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80008724:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80008728:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000872a:	10 3a       	cp.w	r10,r8
8000872c:	fe 9b ff fc 	brhi	80008724 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80008730:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80008734:	2f f7       	sub	r7,-1
80008736:	2f 8e       	sub	lr,-8
80008738:	59 47       	cp.w	r7,20
8000873a:	c0 50       	breq	80008744 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000873c:	7c 08       	ld.w	r8,lr[0x0]
8000873e:	58 08       	cp.w	r8,0
80008740:	ce f1       	brne	8000871e <INTC_init_interrupts+0x1a>
80008742:	cf 7b       	rjmp	80008730 <INTC_init_interrupts+0x2c>
80008744:	d8 22       	popm	r4-r7,pc
80008746:	00 00       	add	r0,r0
80008748:	80 01       	ld.sh	r1,r0[0x0]
8000874a:	2e 00       	sub	r0,-32
8000874c:	80 01       	ld.sh	r1,r0[0x0]
8000874e:	61 c0       	ld.w	r0,r0[0x70]
80008750:	80 00       	ld.sh	r0,r0[0x0]
80008752:	86 80       	ld.uh	r0,r3[0x0]
80008754:	80 01       	ld.sh	r1,r0[0x0]
80008756:	2f 04       	sub	r4,-16

80008758 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80008758:	fe 78 08 00 	mov	r8,-63488
8000875c:	e0 69 00 83 	mov	r9,131
80008760:	f2 0c 01 0c 	sub	r12,r9,r12
80008764:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80008768:	f2 ca ff c0 	sub	r10,r9,-64
8000876c:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80008770:	58 08       	cp.w	r8,0
80008772:	c0 21       	brne	80008776 <_get_interrupt_handler+0x1e>
80008774:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80008776:	f0 08 12 00 	clz	r8,r8
8000877a:	48 5a       	lddpc	r10,8000878c <_get_interrupt_handler+0x34>
8000877c:	f4 09 00 39 	add	r9,r10,r9<<0x3
80008780:	f0 08 11 1f 	rsub	r8,r8,31
80008784:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80008786:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000878a:	5e fc       	retal	r12
8000878c:	80 01       	ld.sh	r1,r0[0x0]
8000878e:	61 c0       	ld.w	r0,r0[0x70]

80008790 <pdca_get_handler>:
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
80008790:	30 e8       	mov	r8,14
80008792:	f0 0c 18 00 	cp.b	r12,r8
80008796:	e0 88 00 03 	brls	8000879c <pdca_get_handler+0xc>
8000879a:	5e fe       	retal	-1

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
8000879c:	a7 6c       	lsl	r12,0x6
8000879e:	e0 3c 00 00 	sub	r12,65536
	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
		return (volatile avr32_pdca_channel_t *)PDCA_INVALID_ARGUMENT;
	}

	return pdca_channel;
}
800087a2:	5e fc       	retal	r12

800087a4 <pdca_disable>:

	return (pdca_channel->sr & AVR32_PDCA_TEN_MASK) != 0;
}

void pdca_disable(uint8_t pdca_ch_number)
{
800087a4:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800087a6:	f0 1f 00 03 	mcall	800087b0 <pdca_disable+0xc>
			pdca_ch_number);

	/* Disable transfer */
	pdca_channel->cr = AVR32_PDCA_TDIS_MASK;
800087aa:	30 28       	mov	r8,2
800087ac:	99 58       	st.w	r12[0x14],r8
}
800087ae:	d8 02       	popm	pc
800087b0:	80 00       	ld.sh	r0,r0[0x0]
800087b2:	87 90       	st.w	r3[0x24],r0

800087b4 <pdca_disable_interrupt_reload_counter_zero>:

	pdca_channel->ier = AVR32_PDCA_TRC_MASK;
}

void pdca_disable_interrupt_reload_counter_zero(uint8_t pdca_ch_number)
{
800087b4:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800087b6:	f0 1f 00 07 	mcall	800087d0 <pdca_disable_interrupt_reload_counter_zero+0x1c>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800087ba:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
800087be:	d3 03       	ssrf	0x10
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_RCZ_MASK;
800087c0:	30 19       	mov	r9,1
800087c2:	99 99       	st.w	r12[0x24],r9
	pdca_channel->isr;
800087c4:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800087c6:	e6 18 00 01 	andh	r8,0x1,COH
800087ca:	c0 21       	brne	800087ce <pdca_disable_interrupt_reload_counter_zero+0x1a>
      cpu_irq_enable();
800087cc:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
800087ce:	d8 02       	popm	pc
800087d0:	80 00       	ld.sh	r0,r0[0x0]
800087d2:	87 90       	st.w	r3[0x24],r0

800087d4 <pdca_disable_interrupt_transfer_complete>:

	pdca_channel->ier = AVR32_PDCA_TERR_MASK;
}

void pdca_disable_interrupt_transfer_complete(uint8_t pdca_ch_number)
{
800087d4:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800087d6:	f0 1f 00 07 	mcall	800087f0 <pdca_disable_interrupt_transfer_complete+0x1c>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800087da:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
800087de:	d3 03       	ssrf	0x10
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_TRC_MASK;
800087e0:	30 29       	mov	r9,2
800087e2:	99 99       	st.w	r12[0x24],r9
	pdca_channel->isr;
800087e4:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800087e6:	e6 18 00 01 	andh	r8,0x1,COH
800087ea:	c0 21       	brne	800087ee <pdca_disable_interrupt_transfer_complete+0x1a>
      cpu_irq_enable();
800087ec:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
800087ee:	d8 02       	popm	pc
800087f0:	80 00       	ld.sh	r0,r0[0x0]
800087f2:	87 90       	st.w	r3[0x24],r0

800087f4 <pdca_init_channel>:
	return pdca_channel;
}

uint32_t pdca_init_channel(uint8_t pdca_ch_number,
		const pdca_channel_options_t *opt)
{
800087f4:	eb cd 40 e0 	pushm	r5-r7,lr
800087f8:	18 95       	mov	r5,r12
800087fa:	16 96       	mov	r6,r11
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800087fc:	f0 1f 00 11 	mcall	80008840 <pdca_init_channel+0x4c>
80008800:	18 97       	mov	r7,r12
			pdca_ch_number);

	pdca_disable_interrupt_transfer_complete(pdca_ch_number); 
80008802:	0a 9c       	mov	r12,r5
80008804:	f0 1f 00 10 	mcall	80008844 <pdca_init_channel+0x50>
	pdca_disable_interrupt_reload_counter_zero(pdca_ch_number);
80008808:	0a 9c       	mov	r12,r5
8000880a:	f0 1f 00 10 	mcall	80008848 <pdca_init_channel+0x54>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000880e:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
80008812:	d3 03       	ssrf	0x10
	
	irqflags_t flags = cpu_irq_save();

	pdca_channel->mar = (uint32_t)opt->addr;
80008814:	6c 09       	ld.w	r9,r6[0x0]
80008816:	8f 09       	st.w	r7[0x0],r9
	pdca_channel->tcr = opt->size;
80008818:	6c 19       	ld.w	r9,r6[0x4]
8000881a:	8f 29       	st.w	r7[0x8],r9
	pdca_channel->psr = opt->pid;
8000881c:	6c 49       	ld.w	r9,r6[0x10]
8000881e:	8f 19       	st.w	r7[0x4],r9
	pdca_channel->marr = (uint32_t)opt->r_addr;
80008820:	6c 29       	ld.w	r9,r6[0x8]
80008822:	8f 39       	st.w	r7[0xc],r9
	pdca_channel->tcrr = opt->r_size;
80008824:	6c 39       	ld.w	r9,r6[0xc]
80008826:	8f 49       	st.w	r7[0x10],r9
	pdca_channel->mr =
80008828:	6c 59       	ld.w	r9,r6[0x14]
8000882a:	8f 69       	st.w	r7[0x18],r9
#if (AVR32_PDCA_H_VERSION >= 120)
			opt->etrig << AVR32_PDCA_ETRIG_OFFSET |
#endif
			opt->transfer_size << AVR32_PDCA_SIZE_OFFSET;
	pdca_channel->cr = AVR32_PDCA_ECLR_MASK;
8000882c:	e0 69 01 00 	mov	r9,256
80008830:	8f 59       	st.w	r7[0x14],r9
	pdca_channel->isr;
80008832:	6e b9       	ld.w	r9,r7[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80008834:	e6 18 00 01 	andh	r8,0x1,COH
80008838:	c0 21       	brne	8000883c <pdca_init_channel+0x48>
      cpu_irq_enable();
8000883a:	d5 03       	csrf	0x10
	
	cpu_irq_restore(flags);

	return PDCA_SUCCESS;
}
8000883c:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80008840:	80 00       	ld.sh	r0,r0[0x0]
80008842:	87 90       	st.w	r3[0x24],r0
80008844:	80 00       	ld.sh	r0,r0[0x0]
80008846:	87 d4       	st.w	r3[0x34],r4
80008848:	80 00       	ld.sh	r0,r0[0x0]
8000884a:	87 b4       	st.w	r3[0x2c],r4

8000884c <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
8000884c:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
8000884e:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80008852:	99 a8       	st.w	r12[0x28],r8
}
80008854:	5e fc       	retal	r12
80008856:	d7 03       	nop

80008858 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80008858:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
8000885a:	ec 5b bb 9f 	cp.w	r11,899999
8000885e:	e0 8b 00 04 	brhi	80008866 <pm_enable_osc0_crystal+0xe>
80008862:	30 4b       	mov	r11,4
80008864:	c1 38       	rjmp	8000888a <pm_enable_osc0_crystal+0x32>
80008866:	e0 68 c6 bf 	mov	r8,50879
8000886a:	ea 18 00 2d 	orh	r8,0x2d
8000886e:	10 3b       	cp.w	r11,r8
80008870:	e0 8b 00 04 	brhi	80008878 <pm_enable_osc0_crystal+0x20>
80008874:	30 5b       	mov	r11,5
80008876:	c0 a8       	rjmp	8000888a <pm_enable_osc0_crystal+0x32>
80008878:	e0 68 12 00 	mov	r8,4608
8000887c:	ea 18 00 7a 	orh	r8,0x7a
80008880:	10 3b       	cp.w	r11,r8
80008882:	f9 bb 03 06 	movlo	r11,6
80008886:	f9 bb 02 07 	movhs	r11,7
8000888a:	f0 1f 00 02 	mcall	80008890 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
8000888e:	d8 02       	popm	pc
80008890:	80 00       	ld.sh	r0,r0[0x0]
80008892:	88 4c       	ld.sh	r12,r4[0x8]

80008894 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80008894:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80008896:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000889a:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
8000889c:	78 08       	ld.w	r8,r12[0x0]
8000889e:	a3 a8       	sbr	r8,0x2
800088a0:	99 08       	st.w	r12[0x0],r8
}
800088a2:	5e fc       	retal	r12

800088a4 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800088a4:	79 58       	ld.w	r8,r12[0x54]
800088a6:	e2 18 00 80 	andl	r8,0x80,COH
800088aa:	cf d0       	breq	800088a4 <pm_wait_for_clk0_ready>
}
800088ac:	5e fc       	retal	r12
800088ae:	d7 03       	nop

800088b0 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
800088b0:	eb cd 40 80 	pushm	r7,lr
800088b4:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
800088b6:	f0 1f 00 04 	mcall	800088c4 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
800088ba:	0e 9c       	mov	r12,r7
800088bc:	f0 1f 00 03 	mcall	800088c8 <pm_enable_clk0+0x18>
}
800088c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800088c4:	80 00       	ld.sh	r0,r0[0x0]
800088c6:	88 94       	ld.uh	r4,r4[0x2]
800088c8:	80 00       	ld.sh	r0,r0[0x0]
800088ca:	88 a4       	ld.uh	r4,r4[0x4]

800088cc <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
800088cc:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
800088ce:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
800088d2:	99 08       	st.w	r12[0x0],r8
}
800088d4:	5e fc       	retal	r12
800088d6:	d7 03       	nop

800088d8 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
800088d8:	eb cd 40 c0 	pushm	r6-r7,lr
800088dc:	18 97       	mov	r7,r12
800088de:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
800088e0:	f0 1f 00 06 	mcall	800088f8 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
800088e4:	0c 9b       	mov	r11,r6
800088e6:	0e 9c       	mov	r12,r7
800088e8:	f0 1f 00 05 	mcall	800088fc <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
800088ec:	30 1b       	mov	r11,1
800088ee:	0e 9c       	mov	r12,r7
800088f0:	f0 1f 00 04 	mcall	80008900 <pm_switch_to_osc0+0x28>
}
800088f4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800088f8:	80 00       	ld.sh	r0,r0[0x0]
800088fa:	88 58       	ld.sh	r8,r4[0xa]
800088fc:	80 00       	ld.sh	r0,r0[0x0]
800088fe:	88 b0       	ld.uh	r0,r4[0x6]
80008900:	80 00       	ld.sh	r0,r0[0x0]
80008902:	88 cc       	ld.uh	r12,r4[0x8]

80008904 <pcl_switch_to_osc>:
        return PASS;
}
#endif // UC3D device-specific implementation

long int pcl_switch_to_osc(pcl_osc_t osc, unsigned int fcrystal, unsigned int startup)
{
80008904:	d4 01       	pushm	lr
#ifndef AVR32_PM_VERSION_RESETVALUE
// Implementation for UC3A, UC3A3, UC3B parts.
  if(PCL_OSC0 == osc)
80008906:	58 0c       	cp.w	r12,0
80008908:	c0 40       	breq	80008910 <pcl_switch_to_osc+0xc>
8000890a:	fe 7c d8 f0 	mov	r12,-10000
8000890e:	d8 02       	popm	pc
  {
    // Configure OSC0 in crystal mode, external crystal with a FOSC0 Hz frequency,
    // enable the OSC0, set the main clock source as being OSC0.
    pm_switch_to_osc0(&AVR32_PM, fcrystal, startup);
80008910:	fe 7c 0c 00 	mov	r12,-62464
80008914:	f0 1f 00 02 	mcall	8000891c <pcl_switch_to_osc+0x18>
80008918:	d8 0a       	popm	pc,r12=0
8000891a:	00 00       	add	r0,r0
8000891c:	80 00       	ld.sh	r0,r0[0x0]
8000891e:	88 d8       	ld.uh	r8,r4[0xa]

80008920 <pwm_channel_init>:

int pwm_channel_init( unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (pwm_channel == 0) // Null pointer.
80008920:	58 0b       	cp.w	r11,0
80008922:	c1 90       	breq	80008954 <pwm_channel_init+0x34>
    return PWM_INVALID_ARGUMENT;
  if (channel_id > AVR32_PWM_LINES_MSB) // Control input values.
80008924:	58 6c       	cp.w	r12,6
80008926:	e0 8b 00 17 	brhi	80008954 <pwm_channel_init+0x34>
    return PWM_INVALID_INPUT;

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode.
8000892a:	76 0a       	ld.w	r10,r11[0x0]
8000892c:	fe 78 30 00 	mov	r8,-53248
80008930:	f8 c9 ff f0 	sub	r9,r12,-16
80008934:	a5 79       	lsl	r9,0x5
80008936:	f0 09 00 09 	add	r9,r8,r9
8000893a:	93 0a       	st.w	r9[0x0],r10
  pwm->channel[channel_id].cdty= pwm_channel->cdty; // Duty cycle, should be < CPRD.
8000893c:	76 19       	ld.w	r9,r11[0x4]
8000893e:	a5 7c       	lsl	r12,0x5
80008940:	f0 0c 00 0c 	add	r12,r8,r12
80008944:	f8 c8 fd fc 	sub	r8,r12,-516
80008948:	91 09       	st.w	r8[0x0],r9
  pwm->channel[channel_id].cprd= pwm_channel->cprd; // Channel period.
8000894a:	76 28       	ld.w	r8,r11[0x8]
8000894c:	f8 cc fd f8 	sub	r12,r12,-520
80008950:	99 08       	st.w	r12[0x0],r8
80008952:	5e fd       	retal	0

  return PWM_SUCCESS;
80008954:	5e ff       	retal	1

80008956 <pwm_start_channels>:
}


int pwm_start_channels(unsigned long channels_bitmask)
{
  if (channels_bitmask & ~((1 << (AVR32_PWM_LINES_MSB + 1)) - 1))
80008956:	18 98       	mov	r8,r12
80008958:	e0 18 ff 80 	andl	r8,0xff80
8000895c:	c0 20       	breq	80008960 <pwm_start_channels+0xa>
8000895e:	5e ff       	retal	1
    return PWM_INVALID_INPUT;

  AVR32_PWM.ena = channels_bitmask; // Enable channels.
80008960:	fe 78 30 00 	mov	r8,-53248
80008964:	91 1c       	st.w	r8[0x4],r12
80008966:	5e fd       	retal	0

80008968 <pwm_async_update_channel>:

int pwm_async_update_channel(unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (channel_id > AVR32_PWM_LINES_MSB)
80008968:	58 6c       	cp.w	r12,6
8000896a:	e0 88 00 03 	brls	80008970 <pwm_async_update_channel+0x8>
8000896e:	5e ff       	retal	1
     return PWM_INVALID_INPUT;

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode register: update of the period or duty cycle.
80008970:	76 0a       	ld.w	r10,r11[0x0]
80008972:	fe 78 30 00 	mov	r8,-53248
80008976:	f8 c9 ff f0 	sub	r9,r12,-16
8000897a:	a5 79       	lsl	r9,0x5
8000897c:	f0 09 00 09 	add	r9,r8,r9
80008980:	93 0a       	st.w	r9[0x0],r10
  pwm->channel[channel_id].cupd= pwm_channel->cupd; // Channel update CPRDx or CDTYx according to CPD value in CMRx.
80008982:	76 49       	ld.w	r9,r11[0x10]
80008984:	a5 7c       	lsl	r12,0x5
80008986:	18 08       	add	r8,r12
80008988:	f0 c8 fd f0 	sub	r8,r8,-528
8000898c:	91 09       	st.w	r8[0x0],r9
8000898e:	5e fd       	retal	0

80008990 <pwm_init>:


int pwm_init(const pwm_opt_t *opt)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80008990:	e1 b8 00 00 	mfsr	r8,0x0

  if (opt == 0 ) // Null pointer.
80008994:	58 0c       	cp.w	r12,0
80008996:	c0 21       	brne	8000899a <pwm_init+0xa>
80008998:	5e ff       	retal	1
    return PWM_INVALID_INPUT;

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
8000899a:	e6 18 00 01 	andh	r8,0x1,COH
8000899e:	c0 91       	brne	800089b0 <pwm_init+0x20>
800089a0:	d3 03       	ssrf	0x10
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
800089a2:	fe 78 30 00 	mov	r8,-53248
800089a6:	37 f9       	mov	r9,127
800089a8:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
800089aa:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();
800089ac:	d5 03       	csrf	0x10
800089ae:	c0 68       	rjmp	800089ba <pwm_init+0x2a>
  if (opt == 0 ) // Null pointer.
    return PWM_INVALID_INPUT;

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
800089b0:	fe 78 30 00 	mov	r8,-53248
800089b4:	37 f9       	mov	r9,127
800089b6:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
800089b8:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
    ((opt->diva)<<AVR32_PWM_DIVA_OFFSET) |
800089ba:	78 08       	ld.w	r8,r12[0x0]
800089bc:	78 39       	ld.w	r9,r12[0xc]
800089be:	a9 69       	lsl	r9,0x8
800089c0:	f3 e8 11 09 	or	r9,r9,r8<<0x10
800089c4:	78 18       	ld.w	r8,r12[0x4]
800089c6:	10 49       	or	r9,r8
800089c8:	78 28       	ld.w	r8,r12[0x8]
800089ca:	f3 e8 11 89 	or	r9,r9,r8<<0x18
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
  pwm->isr;
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
800089ce:	fe 78 30 00 	mov	r8,-53248
800089d2:	91 09       	st.w	r8[0x0],r9
800089d4:	5e fd       	retal	0

800089d6 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
800089d6:	f8 c8 00 01 	sub	r8,r12,1
800089da:	f0 0b 00 0b 	add	r11,r8,r11
800089de:	f6 0c 0d 0a 	divu	r10,r11,r12
800089e2:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
800089e4:	f4 c8 00 01 	sub	r8,r10,1
800089e8:	e0 48 00 fe 	cp.w	r8,254
800089ec:	e0 88 00 03 	brls	800089f2 <getBaudDiv+0x1c>
800089f0:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
800089f2:	5c 8c       	casts.h	r12
}
800089f4:	5e fc       	retal	r12

800089f6 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800089f6:	f7 39 00 0d 	ld.ub	r9,r11[13]
800089fa:	30 18       	mov	r8,1
800089fc:	f0 09 18 00 	cp.b	r9,r8
80008a00:	e0 88 00 04 	brls	80008a08 <spi_initMaster+0x12>
80008a04:	30 2c       	mov	r12,2
80008a06:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
80008a08:	e0 68 00 80 	mov	r8,128
80008a0c:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80008a0e:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
80008a10:	30 19       	mov	r9,1
80008a12:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80008a16:	f7 39 00 0d 	ld.ub	r9,r11[13]
80008a1a:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80008a1e:	30 09       	mov	r9,0
80008a20:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80008a24:	30 fa       	mov	r10,15
80008a26:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80008a2a:	99 18       	st.w	r12[0x4],r8
80008a2c:	5e f9       	retal	r9

80008a2e <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80008a2e:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80008a30:	30 18       	mov	r8,1
80008a32:	f0 0b 18 00 	cp.b	r11,r8
80008a36:	5f be       	srhi	lr
80008a38:	f0 0a 18 00 	cp.b	r10,r8
80008a3c:	5f b8       	srhi	r8
80008a3e:	fd e8 10 08 	or	r8,lr,r8
80008a42:	c0 30       	breq	80008a48 <spi_selectionMode+0x1a>
80008a44:	30 2c       	mov	r12,2
80008a46:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80008a48:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80008a4a:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80008a4e:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80008a52:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80008a56:	99 18       	st.w	r12[0x4],r8
80008a58:	d8 0a       	popm	pc,r12=0

80008a5a <spi_selectChip>:
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80008a5a:	78 18       	ld.w	r8,r12[0x4]
80008a5c:	ea 18 00 0f 	orh	r8,0xf
80008a60:	99 18       	st.w	r12[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80008a62:	78 18       	ld.w	r8,r12[0x4]
80008a64:	e2 18 00 04 	andl	r8,0x4,COH
80008a68:	c0 f0       	breq	80008a86 <spi_selectChip+0x2c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80008a6a:	30 e8       	mov	r8,14
80008a6c:	f0 0b 18 00 	cp.b	r11,r8
80008a70:	e0 8b 00 19 	brhi	80008aa2 <spi_selectChip+0x48>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80008a74:	78 18       	ld.w	r8,r12[0x4]
80008a76:	b1 6b       	lsl	r11,0x10
80008a78:	ea 1b ff f0 	orh	r11,0xfff0
80008a7c:	e8 1b ff ff 	orl	r11,0xffff
80008a80:	10 6b       	and	r11,r8
80008a82:	99 1b       	st.w	r12[0x4],r11
80008a84:	5e fd       	retal	0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80008a86:	30 38       	mov	r8,3
80008a88:	f0 0b 18 00 	cp.b	r11,r8
80008a8c:	e0 8b 00 0b 	brhi	80008aa2 <spi_selectChip+0x48>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80008a90:	78 18       	ld.w	r8,r12[0x4]
80008a92:	2f 0b       	sub	r11,-16
80008a94:	30 19       	mov	r9,1
80008a96:	f2 0b 09 4b 	lsl	r11,r9,r11
80008a9a:	5c db       	com	r11
80008a9c:	10 6b       	and	r11,r8
80008a9e:	99 1b       	st.w	r12[0x4],r11
80008aa0:	5e fd       	retal	0
80008aa2:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80008aa4:	5e fc       	retal	r12

80008aa6 <spi_unselectChip>:

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80008aa6:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80008aaa:	c0 58       	rjmp	80008ab4 <spi_unselectChip+0xe>
		if (!timeout--) {
80008aac:	58 08       	cp.w	r8,0
80008aae:	c0 21       	brne	80008ab2 <spi_unselectChip+0xc>
80008ab0:	5e ff       	retal	1
80008ab2:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80008ab4:	78 49       	ld.w	r9,r12[0x10]
80008ab6:	e2 19 02 00 	andl	r9,0x200,COH
80008aba:	cf 90       	breq	80008aac <spi_unselectChip+0x6>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80008abc:	78 18       	ld.w	r8,r12[0x4]
80008abe:	ea 18 00 0f 	orh	r8,0xf
80008ac2:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80008ac4:	fc 18 01 00 	movh	r8,0x100
80008ac8:	99 08       	st.w	r12[0x0],r8
80008aca:	5e fd       	retal	0

80008acc <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80008acc:	eb cd 40 f8 	pushm	r3-r7,lr
80008ad0:	18 95       	mov	r5,r12
80008ad2:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80008ad4:	f7 36 00 0c 	ld.ub	r6,r11[12]
80008ad8:	30 38       	mov	r8,3
80008ada:	f0 06 18 00 	cp.b	r6,r8
80008ade:	e0 8b 00 4d 	brhi	80008b78 <spi_setupChipReg+0xac>
			options->stay_act > 1 ||
80008ae2:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80008ae6:	30 18       	mov	r8,1
80008ae8:	f0 04 18 00 	cp.b	r4,r8
80008aec:	e0 8b 00 46 	brhi	80008b78 <spi_setupChipReg+0xac>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80008af0:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80008af4:	30 78       	mov	r8,7
80008af6:	f0 03 18 00 	cp.b	r3,r8
80008afa:	e0 88 00 3f 	brls	80008b78 <spi_setupChipReg+0xac>
80008afe:	31 08       	mov	r8,16
80008b00:	f0 03 18 00 	cp.b	r3,r8
80008b04:	e0 8b 00 3a 	brhi	80008b78 <spi_setupChipReg+0xac>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80008b08:	14 9b       	mov	r11,r10
80008b0a:	6e 1c       	ld.w	r12,r7[0x4]
80008b0c:	f0 1f 00 1d 	mcall	80008b80 <spi_setupChipReg+0xb4>

	if (baudDiv < 0) {
80008b10:	c3 45       	brlt	80008b78 <spi_setupChipReg+0xac>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80008b12:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80008b14:	ec 09 16 01 	lsr	r9,r6,0x1
80008b18:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80008b1c:	ec 16 00 01 	eorl	r6,0x1
80008b20:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80008b24:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80008b28:	20 83       	sub	r3,8
80008b2a:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80008b2e:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80008b32:	ef 39 00 09 	ld.ub	r9,r7[9]
80008b36:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80008b3a:	ef 39 00 0a 	ld.ub	r9,r7[10]
80008b3e:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80008b42:	0f 89       	ld.ub	r9,r7[0x0]
80008b44:	30 1a       	mov	r10,1
80008b46:	f4 09 18 00 	cp.b	r9,r10
80008b4a:	c0 e0       	breq	80008b66 <spi_setupChipReg+0x9a>
80008b4c:	c0 a3       	brcs	80008b60 <spi_setupChipReg+0x94>
80008b4e:	30 2a       	mov	r10,2
80008b50:	f4 09 18 00 	cp.b	r9,r10
80008b54:	c0 c0       	breq	80008b6c <spi_setupChipReg+0xa0>
80008b56:	30 3a       	mov	r10,3
80008b58:	f4 09 18 00 	cp.b	r9,r10
80008b5c:	c0 e1       	brne	80008b78 <spi_setupChipReg+0xac>
80008b5e:	c0 a8       	rjmp	80008b72 <spi_setupChipReg+0xa6>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80008b60:	8b c8       	st.w	r5[0x30],r8
80008b62:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		break;

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80008b66:	8b d8       	st.w	r5[0x34],r8
80008b68:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		break;

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80008b6c:	8b e8       	st.w	r5[0x38],r8
80008b6e:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		break;

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80008b72:	8b f8       	st.w	r5[0x3c],r8
80008b74:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		break;
80008b78:	30 2c       	mov	r12,2
		}
	}
#endif

	return SPI_OK;
}
80008b7a:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80008b7e:	00 00       	add	r0,r0
80008b80:	80 00       	ld.sh	r0,r0[0x0]
80008b82:	89 d6       	st.w	r4[0x34],r6

80008b84 <spi_enable>:

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80008b84:	30 18       	mov	r8,1
80008b86:	99 08       	st.w	r12[0x0],r8
}
80008b88:	5e fc       	retal	r12

80008b8a <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80008b8a:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80008b8e:	c0 58       	rjmp	80008b98 <spi_write+0xe>
		if (!timeout--) {
80008b90:	58 08       	cp.w	r8,0
80008b92:	c0 21       	brne	80008b96 <spi_write+0xc>
80008b94:	5e ff       	retal	1
80008b96:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80008b98:	78 49       	ld.w	r9,r12[0x10]
80008b9a:	e2 19 00 02 	andl	r9,0x2,COH
80008b9e:	cf 90       	breq	80008b90 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80008ba0:	5c 7b       	castu.h	r11
80008ba2:	99 3b       	st.w	r12[0xc],r11
80008ba4:	5e fd       	retal	0

80008ba6 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80008ba6:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80008baa:	c0 58       	rjmp	80008bb4 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80008bac:	58 08       	cp.w	r8,0
80008bae:	c0 21       	brne	80008bb2 <spi_read+0xc>
80008bb0:	5e ff       	retal	1
80008bb2:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80008bb4:	78 49       	ld.w	r9,r12[0x10]
80008bb6:	e2 19 02 01 	andl	r9,0x201,COH
80008bba:	e0 49 02 01 	cp.w	r9,513
80008bbe:	cf 71       	brne	80008bac <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80008bc0:	78 28       	ld.w	r8,r12[0x8]
80008bc2:	b6 08       	st.h	r11[0x0],r8
80008bc4:	5e fd       	retal	0

80008bc6 <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80008bc6:	76 09       	ld.w	r9,r11[0x0]
80008bc8:	58 29       	cp.w	r9,2
80008bca:	e0 88 00 03 	brls	80008bd0 <tc_init_waveform+0xa>
80008bce:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80008bd0:	76 18       	ld.w	r8,r11[0x4]
80008bd2:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80008bd6:	af ba       	sbr	r10,0xf
80008bd8:	10 9b       	mov	r11,r8
80008bda:	e6 1b c0 00 	andh	r11,0xc000,COH
80008bde:	16 4a       	or	r10,r11
80008be0:	10 9b       	mov	r11,r8
80008be2:	e6 1b 30 00 	andh	r11,0x3000,COH
80008be6:	16 4a       	or	r10,r11
80008be8:	10 9b       	mov	r11,r8
80008bea:	e6 1b 0c 00 	andh	r11,0xc00,COH
80008bee:	16 4a       	or	r10,r11
80008bf0:	10 9b       	mov	r11,r8
80008bf2:	e6 1b 03 00 	andh	r11,0x300,COH
80008bf6:	16 4a       	or	r10,r11
80008bf8:	10 9b       	mov	r11,r8
80008bfa:	e6 1b 00 c0 	andh	r11,0xc0,COH
80008bfe:	16 4a       	or	r10,r11
80008c00:	10 9b       	mov	r11,r8
80008c02:	e6 1b 00 30 	andh	r11,0x30,COH
80008c06:	16 4a       	or	r10,r11
80008c08:	10 9b       	mov	r11,r8
80008c0a:	e6 1b 00 0c 	andh	r11,0xc,COH
80008c0e:	16 4a       	or	r10,r11
80008c10:	10 9b       	mov	r11,r8
80008c12:	e6 1b 00 03 	andh	r11,0x3,COH
80008c16:	16 4a       	or	r10,r11
80008c18:	10 9b       	mov	r11,r8
80008c1a:	e2 1b 60 00 	andl	r11,0x6000,COH
80008c1e:	16 4a       	or	r10,r11
80008c20:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
80008c24:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
80008c28:	10 9b       	mov	r11,r8
80008c2a:	e2 1b 0c 00 	andl	r11,0xc00,COH
80008c2e:	16 4a       	or	r10,r11
80008c30:	10 9b       	mov	r11,r8
80008c32:	e2 1b 03 00 	andl	r11,0x300,COH
80008c36:	16 4a       	or	r10,r11
80008c38:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
80008c3c:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
80008c40:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
80008c44:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
80008c48:	10 9b       	mov	r11,r8
80008c4a:	e2 1b 00 30 	andl	r11,0x30,COH
80008c4e:	16 4a       	or	r10,r11
80008c50:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80008c54:	f5 e8 10 38 	or	r8,r10,r8<<0x3
80008c58:	a5 69       	lsl	r9,0x4
80008c5a:	2f f9       	sub	r9,-1
80008c5c:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
80008c60:	5e fd       	retal	0

80008c62 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80008c62:	58 2b       	cp.w	r11,2
80008c64:	e0 88 00 03 	brls	80008c6a <tc_start+0x8>
80008c68:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80008c6a:	a7 6b       	lsl	r11,0x6
80008c6c:	16 0c       	add	r12,r11
80008c6e:	30 58       	mov	r8,5
80008c70:	99 08       	st.w	r12[0x0],r8
80008c72:	5e fd       	retal	0

80008c74 <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80008c74:	58 2b       	cp.w	r11,2
80008c76:	e0 88 00 03 	brls	80008c7c <tc_read_sr+0x8>
80008c7a:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
80008c7c:	a7 6b       	lsl	r11,0x6
80008c7e:	2e 0b       	sub	r11,-32
80008c80:	16 0c       	add	r12,r11
80008c82:	78 0c       	ld.w	r12,r12[0x0]
}
80008c84:	5e fc       	retal	r12

80008c86 <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80008c86:	58 2b       	cp.w	r11,2
80008c88:	e0 88 00 03 	brls	80008c8e <tc_write_rc+0x8>
80008c8c:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
80008c8e:	f6 08 15 04 	lsl	r8,r11,0x4
80008c92:	2f f8       	sub	r8,-1
80008c94:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
80008c98:	e2 18 80 00 	andl	r8,0x8000,COH
80008c9c:	c0 c0       	breq	80008cb4 <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
80008c9e:	a7 6b       	lsl	r11,0x6
80008ca0:	16 0c       	add	r12,r11
80008ca2:	2e 4c       	sub	r12,-28
80008ca4:	78 08       	ld.w	r8,r12[0x0]
80008ca6:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80008caa:	e0 18 00 00 	andl	r8,0x0
80008cae:	f3 e8 10 08 	or	r8,r9,r8
80008cb2:	99 08       	st.w	r12[0x0],r8

  return value;
80008cb4:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
80008cb8:	5e fc       	retal	r12

80008cba <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80008cba:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80008cbe:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80008cc2:	58 2b       	cp.w	r11,2
80008cc4:	e0 88 00 04 	brls	80008ccc <tc_configure_interrupts+0x12>
80008cc8:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
80008ccc:	ee 19 00 01 	eorh	r9,0x1
80008cd0:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80008cd4:	74 08       	ld.w	r8,r10[0x0]
80008cd6:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
80008cda:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
80008cde:	a7 6e       	lsl	lr,0x6
80008ce0:	fd e7 10 7e 	or	lr,lr,r7<<0x7
80008ce4:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
80008ce8:	0e 4e       	or	lr,r7
80008cea:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
80008cee:	fd e7 10 5e 	or	lr,lr,r7<<0x5
80008cf2:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
80008cf6:	fd e7 10 4e 	or	lr,lr,r7<<0x4
80008cfa:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
80008cfe:	fd e7 10 3e 	or	lr,lr,r7<<0x3
80008d02:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
80008d06:	fd e7 10 2e 	or	lr,lr,r7<<0x2
80008d0a:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80008d0e:	fd e8 10 18 	or	r8,lr,r8<<0x1
80008d12:	f6 0e 15 06 	lsl	lr,r11,0x6
80008d16:	f8 0e 00 0e 	add	lr,r12,lr
80008d1a:	2d ce       	sub	lr,-36
80008d1c:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80008d1e:	58 09       	cp.w	r9,0
80008d20:	c0 20       	breq	80008d24 <tc_configure_interrupts+0x6a>
80008d22:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80008d24:	74 08       	ld.w	r8,r10[0x0]
80008d26:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80008d2a:	e0 65 00 80 	mov	r5,128
80008d2e:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
80008d32:	74 08       	ld.w	r8,r10[0x0]
80008d34:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80008d38:	f9 b4 00 40 	moveq	r4,64
80008d3c:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
80008d40:	74 08       	ld.w	r8,r10[0x0]
80008d42:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
80008d46:	f9 b3 00 20 	moveq	r3,32
80008d4a:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
80008d4e:	74 08       	ld.w	r8,r10[0x0]
80008d50:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
80008d54:	f9 b2 00 10 	moveq	r2,16
80008d58:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80008d5c:	74 08       	ld.w	r8,r10[0x0]
80008d5e:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80008d62:	f9 b6 00 08 	moveq	r6,8
80008d66:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80008d6a:	74 08       	ld.w	r8,r10[0x0]
80008d6c:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
80008d70:	f9 b7 00 04 	moveq	r7,4
80008d74:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80008d78:	74 08       	ld.w	r8,r10[0x0]
80008d7a:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80008d7e:	f9 be 00 02 	moveq	lr,2
80008d82:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80008d86:	74 08       	ld.w	r8,r10[0x0]
80008d88:	ec 18 00 01 	eorl	r8,0x1
80008d8c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008d90:	eb e8 10 08 	or	r8,r5,r8
80008d94:	08 48       	or	r8,r4
80008d96:	06 48       	or	r8,r3
80008d98:	04 48       	or	r8,r2
80008d9a:	0c 48       	or	r8,r6
80008d9c:	0e 48       	or	r8,r7
80008d9e:	1c 48       	or	r8,lr
80008da0:	f6 0a 15 06 	lsl	r10,r11,0x6
80008da4:	f8 0a 00 0a 	add	r10,r12,r10
80008da8:	2d 8a       	sub	r10,-40
80008daa:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80008dac:	a7 6b       	lsl	r11,0x6
80008dae:	2e 0b       	sub	r11,-32
80008db0:	16 0c       	add	r12,r11
80008db2:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80008db4:	58 09       	cp.w	r9,0
80008db6:	c0 31       	brne	80008dbc <tc_configure_interrupts+0x102>
80008db8:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80008dbc:	d5 03       	csrf	0x10
80008dbe:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

80008dc2 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80008dc2:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80008dc4:	f6 08 15 04 	lsl	r8,r11,0x4
80008dc8:	14 38       	cp.w	r8,r10
80008dca:	f9 b8 08 10 	movls	r8,16
80008dce:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80008dd2:	f0 0b 02 4b 	mul	r11,r8,r11
80008dd6:	f6 09 16 01 	lsr	r9,r11,0x1
80008dda:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80008dde:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80008de2:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80008de6:	f2 cb 00 01 	sub	r11,r9,1
80008dea:	e0 4b ff fe 	cp.w	r11,65534
80008dee:	e0 88 00 03 	brls	80008df4 <usart_set_async_baudrate+0x32>
80008df2:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80008df4:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80008df6:	e8 6e 00 00 	mov	lr,524288
80008dfa:	59 08       	cp.w	r8,16
80008dfc:	fc 08 17 10 	movne	r8,lr
80008e00:	f9 b8 00 00 	moveq	r8,0
80008e04:	e4 1b ff f7 	andh	r11,0xfff7
80008e08:	e0 1b fe cf 	andl	r11,0xfecf
80008e0c:	16 48       	or	r8,r11
80008e0e:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80008e10:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80008e14:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80008e18:	99 89       	st.w	r12[0x20],r9
80008e1a:	d8 0a       	popm	pc,r12=0

80008e1c <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80008e1c:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80008e1e:	e2 18 00 02 	andl	r8,0x2,COH
80008e22:	c0 31       	brne	80008e28 <usart_write_char+0xc>
80008e24:	30 2c       	mov	r12,2
80008e26:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80008e28:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80008e2c:	99 7b       	st.w	r12[0x1c],r11
80008e2e:	5e fd       	retal	0

80008e30 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80008e30:	eb cd 40 e0 	pushm	r5-r7,lr
80008e34:	18 96       	mov	r6,r12
80008e36:	16 95       	mov	r5,r11
80008e38:	e0 67 27 0f 	mov	r7,9999
80008e3c:	c0 68       	rjmp	80008e48 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80008e3e:	58 07       	cp.w	r7,0
80008e40:	c0 31       	brne	80008e46 <usart_putchar+0x16>
80008e42:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80008e46:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80008e48:	0a 9b       	mov	r11,r5
80008e4a:	0c 9c       	mov	r12,r6
80008e4c:	f0 1f 00 03 	mcall	80008e58 <usart_putchar+0x28>
80008e50:	cf 71       	brne	80008e3e <usart_putchar+0xe>

  return USART_SUCCESS;
}
80008e52:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80008e56:	00 00       	add	r0,r0
80008e58:	80 00       	ld.sh	r0,r0[0x0]
80008e5a:	8e 1c       	ld.sh	r12,r7[0x2]

80008e5c <usart_write_line>:
  return c;
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80008e5c:	eb cd 40 c0 	pushm	r6-r7,lr
80008e60:	18 96       	mov	r6,r12
80008e62:	16 97       	mov	r7,r11
  while (*string != '\0')
80008e64:	17 8b       	ld.ub	r11,r11[0x0]
80008e66:	58 0b       	cp.w	r11,0
80008e68:	c0 80       	breq	80008e78 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80008e6a:	2f f7       	sub	r7,-1
80008e6c:	0c 9c       	mov	r12,r6
80008e6e:	f0 1f 00 04 	mcall	80008e7c <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80008e72:	0f 8b       	ld.ub	r11,r7[0x0]
80008e74:	58 0b       	cp.w	r11,0
80008e76:	cf a1       	brne	80008e6a <usart_write_line+0xe>
80008e78:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80008e7c:	80 00       	ld.sh	r0,r0[0x0]
80008e7e:	8e 30       	ld.sh	r0,r7[0x6]

80008e80 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80008e80:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80008e84:	e6 18 00 01 	andh	r8,0x1,COH
80008e88:	c0 71       	brne	80008e96 <usart_reset+0x16>
80008e8a:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80008e8c:	3f f8       	mov	r8,-1
80008e8e:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80008e90:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80008e92:	d5 03       	csrf	0x10
80008e94:	c0 48       	rjmp	80008e9c <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80008e96:	3f f8       	mov	r8,-1
80008e98:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80008e9a:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80008e9c:	30 08       	mov	r8,0
80008e9e:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80008ea0:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80008ea2:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80008ea4:	ea 68 61 0c 	mov	r8,680204
80008ea8:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80008eaa:	5e fc       	retal	r12

80008eac <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80008eac:	eb cd 40 e0 	pushm	r5-r7,lr
80008eb0:	18 96       	mov	r6,r12
80008eb2:	16 97       	mov	r7,r11
80008eb4:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80008eb6:	f0 1f 00 2f 	mcall	80008f70 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80008eba:	58 07       	cp.w	r7,0
80008ebc:	c5 80       	breq	80008f6c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80008ebe:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80008ec0:	30 49       	mov	r9,4
80008ec2:	f2 08 18 00 	cp.b	r8,r9
80008ec6:	e0 88 00 53 	brls	80008f6c <usart_init_rs232+0xc0>
80008eca:	30 99       	mov	r9,9
80008ecc:	f2 08 18 00 	cp.b	r8,r9
80008ed0:	e0 8b 00 4e 	brhi	80008f6c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80008ed4:	0f d9       	ld.ub	r9,r7[0x5]
80008ed6:	30 78       	mov	r8,7
80008ed8:	f0 09 18 00 	cp.b	r9,r8
80008edc:	e0 8b 00 48 	brhi	80008f6c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80008ee0:	8e 39       	ld.sh	r9,r7[0x6]
80008ee2:	e0 68 01 01 	mov	r8,257
80008ee6:	f0 09 19 00 	cp.h	r9,r8
80008eea:	e0 8b 00 41 	brhi	80008f6c <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80008eee:	ef 39 00 08 	ld.ub	r9,r7[8]
80008ef2:	30 38       	mov	r8,3
80008ef4:	f0 09 18 00 	cp.b	r9,r8
80008ef8:	e0 8b 00 3a 	brhi	80008f6c <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80008efc:	0a 9a       	mov	r10,r5
80008efe:	6e 0b       	ld.w	r11,r7[0x0]
80008f00:	0c 9c       	mov	r12,r6
80008f02:	f0 1f 00 1d 	mcall	80008f74 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80008f06:	58 1c       	cp.w	r12,1
80008f08:	c3 20       	breq	80008f6c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80008f0a:	0f c8       	ld.ub	r8,r7[0x4]
80008f0c:	30 99       	mov	r9,9
80008f0e:	f2 08 18 00 	cp.b	r8,r9
80008f12:	c0 51       	brne	80008f1c <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80008f14:	6c 18       	ld.w	r8,r6[0x4]
80008f16:	b1 b8       	sbr	r8,0x11
80008f18:	8d 18       	st.w	r6[0x4],r8
80008f1a:	c0 68       	rjmp	80008f26 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80008f1c:	6c 19       	ld.w	r9,r6[0x4]
80008f1e:	20 58       	sub	r8,5
80008f20:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80008f24:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80008f26:	6c 19       	ld.w	r9,r6[0x4]
80008f28:	ef 3a 00 08 	ld.ub	r10,r7[8]
80008f2c:	0f d8       	ld.ub	r8,r7[0x5]
80008f2e:	a9 78       	lsl	r8,0x9
80008f30:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80008f34:	12 48       	or	r8,r9
80008f36:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80008f38:	8e 38       	ld.sh	r8,r7[0x6]
80008f3a:	30 29       	mov	r9,2
80008f3c:	f2 08 19 00 	cp.h	r8,r9
80008f40:	e0 88 00 09 	brls	80008f52 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80008f44:	6c 18       	ld.w	r8,r6[0x4]
80008f46:	ad b8       	sbr	r8,0xd
80008f48:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80008f4a:	8e b8       	ld.uh	r8,r7[0x6]
80008f4c:	20 28       	sub	r8,2
80008f4e:	8d a8       	st.w	r6[0x28],r8
80008f50:	c0 68       	rjmp	80008f5c <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80008f52:	6c 19       	ld.w	r9,r6[0x4]
80008f54:	5c 78       	castu.h	r8
80008f56:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80008f5a:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80008f5c:	6c 18       	ld.w	r8,r6[0x4]
80008f5e:	e0 18 ff f0 	andl	r8,0xfff0
80008f62:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80008f64:	35 08       	mov	r8,80
80008f66:	8d 08       	st.w	r6[0x0],r8
80008f68:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80008f6c:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80008f70:	80 00       	ld.sh	r0,r0[0x0]
80008f72:	8e 80       	ld.uh	r0,r7[0x0]
80008f74:	80 00       	ld.sh	r0,r0[0x0]
80008f76:	8d c2       	st.w	r6[0x30],r2

80008f78 <fat_check_open>:
//! @return    true  a file is opened
//! @return    false otherwise
//!
bool  fat_check_open( void )
{
   if( Fat_file_isnot_open() )
80008f78:	48 68       	lddpc	r8,80008f90 <fat_check_open+0x18>
80008f7a:	11 89       	ld.ub	r9,r8[0x0]
80008f7c:	30 08       	mov	r8,0
80008f7e:	f0 09 18 00 	cp.b	r9,r8
80008f82:	c0 20       	breq	80008f86 <fat_check_open+0xe>
80008f84:	5e ff       	retal	1
   {
      fs_g_status = FS_ERR_FILE_NO_OPEN;
80008f86:	31 79       	mov	r9,23
80008f88:	48 38       	lddpc	r8,80008f94 <fat_check_open+0x1c>
80008f8a:	b0 89       	st.b	r8[0x0],r9
80008f8c:	5e fd       	retal	0
80008f8e:	00 00       	add	r0,r0
80008f90:	00 00       	add	r0,r0
80008f92:	09 d8       	ld.ub	r8,r4[0x5]
80008f94:	00 00       	add	r0,r0
80008f96:	0c 68       	and	r8,r6

80008f98 <fat_check_select>:
//! @return    true  a file is selected
//! @return    false otherwise
//!
bool  fat_check_select( void )
{
   if (FS_NO_SEL == fs_g_nav_fast.u16_entry_pos_sel_file)
80008f98:	48 68       	lddpc	r8,80008fb0 <fat_check_select+0x18>
80008f9a:	90 19       	ld.sh	r9,r8[0x2]
80008f9c:	3f f8       	mov	r8,-1
80008f9e:	f0 09 19 00 	cp.h	r9,r8
80008fa2:	c0 20       	breq	80008fa6 <fat_check_select+0xe>
80008fa4:	5e ff       	retal	1
   {
      fs_g_status = FS_ERR_NO_FILE_SEL;
80008fa6:	30 f9       	mov	r9,15
80008fa8:	48 38       	lddpc	r8,80008fb4 <fat_check_select+0x1c>
80008faa:	b0 89       	st.b	r8[0x0],r9
80008fac:	5e fd       	retal	0
80008fae:	00 00       	add	r0,r0
80008fb0:	00 00       	add	r0,r0
80008fb2:	0c 64       	and	r4,r6
80008fb4:	00 00       	add	r0,r0
80008fb6:	0c 68       	and	r8,r6

80008fb8 <fat_check_is_file>:
//! @return    true  It is a file and not a directory
//! @return    false otherwise
//!
bool  fat_check_is_file( void )
{
   if( Fat_is_not_a_file )
80008fb8:	48 58       	lddpc	r8,80008fcc <fat_check_is_file+0x14>
80008fba:	11 a8       	ld.ub	r8,r8[0x2]
80008fbc:	e2 18 00 18 	andl	r8,0x18,COH
80008fc0:	c0 21       	brne	80008fc4 <fat_check_is_file+0xc>
80008fc2:	5e ff       	retal	1
   {
      fs_g_status = FS_ERR_NO_FILE;   // It isn't a file, it is a directory or a volume id
80008fc4:	31 39       	mov	r9,19
80008fc6:	48 38       	lddpc	r8,80008fd0 <fat_check_is_file+0x18>
80008fc8:	b0 89       	st.b	r8[0x0],r9
80008fca:	5e fd       	retal	0
80008fcc:	00 00       	add	r0,r0
80008fce:	09 d8       	ld.ub	r8,r4[0x5]
80008fd0:	00 00       	add	r0,r0
80008fd2:	0c 68       	and	r8,r6

80008fd4 <fat_checkcluster>:
//!   fs_g_cluster.u32_val       value to check
//! @endverbatim
//!
uint8_t    fat_checkcluster( void )
{
  if ( !fs_g_cluster.u32_val )
80008fd4:	49 68       	lddpc	r8,8000902c <fat_checkcluster+0x58>
80008fd6:	70 18       	ld.w	r8,r8[0x4]
80008fd8:	58 08       	cp.w	r8,0
80008fda:	c0 21       	brne	80008fde <fat_checkcluster+0xa>
80008fdc:	5e ff       	retal	1
    return FS_CLUS_BAD;

  // Cluster bad if (FAT12 == 0x0FF7) (FAT16 == 0xFFF7) (FAT32 == 0x0FFFFFF7)
  // Last cluster if (FAT12 > 0x0FF7) (FAT16 > 0xFFF7) (FAT32 > 0x0FFFFFF7)
  if ( Is_fat32 )
80008fde:	49 59       	lddpc	r9,80009030 <fat_checkcluster+0x5c>
80008fe0:	13 89       	ld.ub	r9,r9[0x0]
80008fe2:	30 3a       	mov	r10,3
80008fe4:	f4 09 18 00 	cp.b	r9,r10
80008fe8:	c0 a1       	brne	80008ffc <fat_checkcluster+0x28>
  {
    if (fs_g_cluster.u32_val >= 0x0FFFFFF8)
80008fea:	e0 69 ff f7 	mov	r9,65527
80008fee:	ea 19 0f ff 	orh	r9,0xfff
80008ff2:	12 38       	cp.w	r8,r9
80008ff4:	e0 8b 00 19 	brhi	80009026 <fat_checkcluster+0x52>
80008ff8:	5f 0c       	sreq	r12
80008ffa:	5e fc       	retal	r12
      return FS_CLUS_END;
    else if (fs_g_cluster.u32_val == 0x0FFFFFF7)
      return FS_CLUS_BAD;
  }
  else if ( Is_fat16 )
80008ffc:	30 2a       	mov	r10,2
80008ffe:	f4 09 18 00 	cp.b	r9,r10
80009002:	c0 71       	brne	80009010 <fat_checkcluster+0x3c>
  {
    if (fs_g_cluster.u32_val >= 0xFFF8)
80009004:	e0 48 ff f7 	cp.w	r8,65527
80009008:	e0 8b 00 0f 	brhi	80009026 <fat_checkcluster+0x52>
8000900c:	5f 0c       	sreq	r12
8000900e:	5e fc       	retal	r12
      return FS_CLUS_END;
    else if (fs_g_cluster.u32_val == 0xFFF7)
      return FS_CLUS_BAD;
  }
  else if ( Is_fat12 )
80009010:	30 1a       	mov	r10,1
80009012:	f4 09 18 00 	cp.b	r9,r10
80009016:	c0 20       	breq	8000901a <fat_checkcluster+0x46>
80009018:	5e fd       	retal	0
  {
    if (fs_g_cluster.u32_val >= 0xFF8)
8000901a:	e0 48 0f f7 	cp.w	r8,4087
8000901e:	e0 8b 00 04 	brhi	80009026 <fat_checkcluster+0x52>
80009022:	5f 0c       	sreq	r12
80009024:	5e fc       	retal	r12
80009026:	30 2c       	mov	r12,2
    else if (fs_g_cluster.u32_val == 0xFF7)
      return FS_CLUS_BAD;
  }

  return FS_CLUS_OK;
}
80009028:	5e fc       	retal	r12
8000902a:	00 00       	add	r0,r0
8000902c:	00 00       	add	r0,r0
8000902e:	0c b8       	st.h	r6++,r8
80009030:	00 00       	add	r0,r0
80009032:	0c 64       	and	r4,r6

80009034 <fat_cache_clusterlist_reset>:
//! This function resets the cluster list caches
//!
void  fat_cache_clusterlist_reset( void )
{
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
80009034:	30 0a       	mov	r10,0
80009036:	48 88       	lddpc	r8,80009054 <fat_cache_clusterlist_reset+0x20>
80009038:	b0 8a       	st.b	r8[0x0],r10
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
8000903a:	48 88       	lddpc	r8,80009058 <fat_cache_clusterlist_reset+0x24>
8000903c:	30 19       	mov	r9,1
8000903e:	b0 89       	st.b	r8[0x0],r9
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
80009040:	3f f9       	mov	r9,-1
80009042:	b0 a9       	st.b	r8[0x2],r9
      fs_g_cache_clusterlist[u8_i].u8_level_use = 0xFF;
80009044:	b0 99       	st.b	r8[0x1],r9
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
80009046:	f1 6a 00 14 	st.b	r8[20],r10
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
8000904a:	f1 69 00 16 	st.b	r8[22],r9
      fs_g_cache_clusterlist[u8_i].u8_level_use = 0xFF;
8000904e:	f1 69 00 15 	st.b	r8[21],r9
   }
}
80009052:	5e fc       	retal	r12
80009054:	00 00       	add	r0,r0
80009056:	0c 6a       	and	r10,r6
80009058:	00 00       	add	r0,r0
8000905a:	09 ec       	ld.ub	r12,r4[0x6]

8000905c <fat_cache_clusterlist_update_start>:
//! This function initializes a cache in cluster list caches
//!
//! @param     b_for_file  If true then it is a file cluster list else a directory cluster list  <br>
//!
void  fat_cache_clusterlist_update_start( bool b_for_file )
{
8000905c:	48 ea       	lddpc	r10,80009094 <fat_cache_clusterlist_update_start+0x38>
8000905e:	15 88       	ld.ub	r8,r10[0x0]
80009060:	f8 08 18 00 	cp.b	r8,r12
80009064:	5f 18       	srne	r8
         if( (FS_NB_CACHE_CLUSLIST-2) < fs_g_cache_clusterlist[u8_i].u8_level_use )
#endif
            break;
      }
   }
   fs_g_u8_current_cache = u8_i;
80009066:	48 d9       	lddpc	r9,80009098 <fat_cache_clusterlist_update_start+0x3c>
80009068:	b2 88       	st.b	r9[0x0],r8
   fs_g_cache_clusterlist[fs_g_u8_current_cache].b_cache_file = b_for_file;
8000906a:	f0 0b 15 02 	lsl	r11,r8,0x2
8000906e:	f6 08 00 09 	add	r9,r11,r8
80009072:	f4 09 00 29 	add	r9,r10,r9<<0x2
80009076:	b2 8c       	st.b	r9[0x0],r12
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = 0xFF;                     // invalid cache
80009078:	3f fc       	mov	r12,-1
8000907a:	b2 ac       	st.b	r9[0x2],r12
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_cluster  = fs_g_cluster.u32_pos;
8000907c:	f6 08 00 08 	add	r8,r11,r8
80009080:	2f f8       	sub	r8,-1
80009082:	48 7b       	lddpc	r11,8000909c <fat_cache_clusterlist_update_start+0x40>
80009084:	76 0b       	ld.w	r11,r11[0x0]
80009086:	f4 08 09 2b 	st.w	r10[r8<<0x2],r11
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start    = fs_g_seg.u32_size_or_pos;
8000908a:	48 68       	lddpc	r8,800090a0 <fat_cache_clusterlist_update_start+0x44>
8000908c:	70 18       	ld.w	r8,r8[0x4]
8000908e:	93 28       	st.w	r9[0x8],r8
}
80009090:	5e fc       	retal	r12
80009092:	00 00       	add	r0,r0
80009094:	00 00       	add	r0,r0
80009096:	09 ec       	ld.ub	r12,r4[0x6]
80009098:	00 00       	add	r0,r0
8000909a:	0c 6a       	and	r10,r6
8000909c:	00 00       	add	r0,r0
8000909e:	0c b8       	st.h	r6++,r8
800090a0:	00 00       	add	r0,r0
800090a2:	0c c0       	st.b	r6++,r0

800090a4 <fat_cache_clusterlist_update_select>:
{
   uint8_t u8_i;
   uint8_t u8_level_to_update;
   bool b_file_cache;

   b_file_cache         = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].b_cache_file;
800090a4:	49 88       	lddpc	r8,80009104 <fat_cache_clusterlist_update_select+0x60>
800090a6:	11 88       	ld.ub	r8,r8[0x0]
800090a8:	49 8a       	lddpc	r10,80009108 <fat_cache_clusterlist_update_select+0x64>
800090aa:	f0 08 00 2b 	add	r11,r8,r8<<0x2
800090ae:	f4 0b 00 2b 	add	r11,r10,r11<<0x2
800090b2:	17 89       	ld.ub	r9,r11[0x0]
   u8_level_to_update   = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].u8_level_use;
800090b4:	17 9b       	ld.ub	r11,r11[0x1]
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( fs_g_cache_clusterlist[u8_i].b_cache_file == b_file_cache )
800090b6:	15 8a       	ld.ub	r10,r10[0x0]
800090b8:	f2 0a 18 00 	cp.b	r10,r9
800090bc:	c0 a1       	brne	800090d0 <fat_cache_clusterlist_update_select+0x2c>
         if( u8_level_to_update > fs_g_cache_clusterlist[u8_i].u8_level_use )
800090be:	49 3a       	lddpc	r10,80009108 <fat_cache_clusterlist_update_select+0x64>
800090c0:	15 9a       	ld.ub	r10,r10[0x1]
800090c2:	f4 0b 18 00 	cp.b	r11,r10
800090c6:	e0 88 00 05 	brls	800090d0 <fat_cache_clusterlist_update_select+0x2c>
           fs_g_cache_clusterlist[u8_i].u8_level_use++;
800090ca:	2f fa       	sub	r10,-1
800090cc:	48 fc       	lddpc	r12,80009108 <fat_cache_clusterlist_update_select+0x64>
800090ce:	b8 9a       	st.b	r12[0x1],r10

   b_file_cache         = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].b_cache_file;
   u8_level_to_update   = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].u8_level_use;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( fs_g_cache_clusterlist[u8_i].b_cache_file == b_file_cache )
800090d0:	48 ea       	lddpc	r10,80009108 <fat_cache_clusterlist_update_select+0x64>
800090d2:	f5 3a 00 14 	ld.ub	r10,r10[20]
800090d6:	f2 0a 18 00 	cp.b	r10,r9
800090da:	c0 c1       	brne	800090f2 <fat_cache_clusterlist_update_select+0x4e>
         if( u8_level_to_update > fs_g_cache_clusterlist[u8_i].u8_level_use )
800090dc:	48 b9       	lddpc	r9,80009108 <fat_cache_clusterlist_update_select+0x64>
800090de:	f3 39 00 15 	ld.ub	r9,r9[21]
800090e2:	f2 0b 18 00 	cp.b	r11,r9
800090e6:	e0 88 00 06 	brls	800090f2 <fat_cache_clusterlist_update_select+0x4e>
           fs_g_cache_clusterlist[u8_i].u8_level_use++;
800090ea:	2f f9       	sub	r9,-1
800090ec:	48 7a       	lddpc	r10,80009108 <fat_cache_clusterlist_update_select+0x64>
800090ee:	f5 69 00 15 	st.b	r10[21],r9
   }
   fs_g_cache_clusterlist[  fs_g_u8_current_cache  ].u8_level_use = 0;
800090f2:	f0 08 00 28 	add	r8,r8,r8<<0x2
800090f6:	48 59       	lddpc	r9,80009108 <fat_cache_clusterlist_update_select+0x64>
800090f8:	f2 08 00 28 	add	r8,r9,r8<<0x2
800090fc:	30 09       	mov	r9,0
800090fe:	b0 99       	st.b	r8[0x1],r9
}
80009100:	5e fc       	retal	r12
80009102:	00 00       	add	r0,r0
80009104:	00 00       	add	r0,r0
80009106:	0c 6a       	and	r10,r6
80009108:	00 00       	add	r0,r0
8000910a:	09 ec       	ld.ub	r12,r4[0x6]

8000910c <fat_cache_clusterlist_update_finish>:


//! This function updates a cache of cluster list caches
//!
void  fat_cache_clusterlist_update_finish( void )
{
8000910c:	eb cd 40 c0 	pushm	r6-r7,lr
   uint8_t u8_cluster_offset = fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start % fs_g_nav.u8_BPB_SecPerClus;
80009110:	49 08       	lddpc	r8,80009150 <fat_cache_clusterlist_update_finish+0x44>
80009112:	11 88       	ld.ub	r8,r8[0x0]
80009114:	f0 08 00 28 	add	r8,r8,r8<<0x2
80009118:	48 f9       	lddpc	r9,80009154 <fat_cache_clusterlist_update_finish+0x48>
8000911a:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000911e:	f0 ca ff f8 	sub	r10,r8,-8
80009122:	48 eb       	lddpc	r11,80009158 <fat_cache_clusterlist_update_finish+0x4c>
80009124:	17 97       	ld.ub	r7,r11[0x1]
80009126:	74 09       	ld.w	r9,r10[0x0]
80009128:	f2 07 0d 06 	divu	r6,r9,r7
8000912c:	0e 99       	mov	r9,r7
8000912e:	5c 59       	castu.b	r9
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = fs_g_nav.u8_lun;          // valid cache
80009130:	17 8b       	ld.ub	r11,r11[0x0]
80009132:	b0 ab       	st.b	r8[0x2],r11
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start   -= u8_cluster_offset;
80009134:	74 0b       	ld.w	r11,r10[0x0]
80009136:	12 1b       	sub	r11,r9
80009138:	95 0b       	st.w	r10[0x0],r11
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_addr     = fs_g_seg.u32_addr - u8_cluster_offset;
8000913a:	48 9a       	lddpc	r10,8000915c <fat_cache_clusterlist_update_finish+0x50>
8000913c:	74 0b       	ld.w	r11,r10[0x0]
8000913e:	12 1b       	sub	r11,r9
80009140:	91 3b       	st.w	r8[0xc],r11
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_size     = fs_g_seg.u32_size_or_pos + u8_cluster_offset;
80009142:	74 1a       	ld.w	r10,r10[0x4]
80009144:	14 09       	add	r9,r10
80009146:	91 49       	st.w	r8[0x10],r9

   // Update the "level used" of cache
   fat_cache_clusterlist_update_select();
80009148:	f0 1f 00 06 	mcall	80009160 <fat_cache_clusterlist_update_finish+0x54>
}
8000914c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009150:	00 00       	add	r0,r0
80009152:	0c 6a       	and	r10,r6
80009154:	00 00       	add	r0,r0
80009156:	09 ec       	ld.ub	r12,r4[0x6]
80009158:	00 00       	add	r0,r0
8000915a:	0c 18       	sub	r8,r6
8000915c:	00 00       	add	r0,r0
8000915e:	0c c0       	st.b	r6++,r0
80009160:	80 00       	ld.sh	r0,r0[0x0]
80009162:	90 a4       	ld.uh	r4,r8[0x4]

80009164 <fat_cache_clusterlist_update_read>:
//!
//! @return    true  cluster list found and global variable fs_g_seg updated
//! @return    false no found in cluster list caches
//!
bool  fat_cache_clusterlist_update_read( bool b_for_file )
{
80009164:	eb cd 40 c0 	pushm	r6-r7,lr
   uint32_t u32_tmp;
   uint8_t u8_i;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( (fs_g_cache_clusterlist[u8_i].b_cache_file == b_for_file)
      &&  (fs_g_cache_clusterlist[u8_i].u8_lun == fs_g_nav.u8_lun ) )
80009168:	4c 18       	lddpc	r8,8000926c <fat_cache_clusterlist_update_read+0x108>
8000916a:	11 89       	ld.ub	r9,r8[0x0]
      {
         if( fs_g_cache_clusterlist[u8_i].u32_cluster == fs_g_cluster.u32_pos )
8000916c:	4c 18       	lddpc	r8,80009270 <fat_cache_clusterlist_update_read+0x10c>
8000916e:	70 0a       	ld.w	r10,r8[0x0]
         {
            if( fs_g_cache_clusterlist[u8_i].u32_start <= fs_g_seg.u32_size_or_pos )
80009170:	4c 18       	lddpc	r8,80009274 <fat_cache_clusterlist_update_read+0x110>
80009172:	70 1b       	ld.w	r11,r8[0x4]
{
   uint32_t u32_tmp;
   uint8_t u8_i;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( (fs_g_cache_clusterlist[u8_i].b_cache_file == b_for_file)
80009174:	4c 18       	lddpc	r8,80009278 <fat_cache_clusterlist_update_read+0x114>
80009176:	11 88       	ld.ub	r8,r8[0x0]
80009178:	f8 08 18 00 	cp.b	r8,r12
8000917c:	c1 11       	brne	8000919e <fat_cache_clusterlist_update_read+0x3a>
8000917e:	4b f8       	lddpc	r8,80009278 <fat_cache_clusterlist_update_read+0x114>
80009180:	11 a8       	ld.ub	r8,r8[0x2]
80009182:	f2 08 18 00 	cp.b	r8,r9
80009186:	c0 c1       	brne	8000919e <fat_cache_clusterlist_update_read+0x3a>
      &&  (fs_g_cache_clusterlist[u8_i].u8_lun == fs_g_nav.u8_lun ) )
      {
         if( fs_g_cache_clusterlist[u8_i].u32_cluster == fs_g_cluster.u32_pos )
80009188:	4b c8       	lddpc	r8,80009278 <fat_cache_clusterlist_update_read+0x114>
8000918a:	70 18       	ld.w	r8,r8[0x4]
8000918c:	14 38       	cp.w	r8,r10
8000918e:	c0 81       	brne	8000919e <fat_cache_clusterlist_update_read+0x3a>
         {
            if( fs_g_cache_clusterlist[u8_i].u32_start <= fs_g_seg.u32_size_or_pos )
80009190:	4b a8       	lddpc	r8,80009278 <fat_cache_clusterlist_update_read+0x114>
80009192:	70 28       	ld.w	r8,r8[0x8]
80009194:	10 3b       	cp.w	r11,r8
80009196:	c0 43       	brcs	8000919e <fat_cache_clusterlist_update_read+0x3a>
80009198:	30 0a       	mov	r10,0
8000919a:	14 99       	mov	r9,r10
8000919c:	c1 88       	rjmp	800091cc <fat_cache_clusterlist_update_read+0x68>
{
   uint32_t u32_tmp;
   uint8_t u8_i;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( (fs_g_cache_clusterlist[u8_i].b_cache_file == b_for_file)
8000919e:	4b 78       	lddpc	r8,80009278 <fat_cache_clusterlist_update_read+0x114>
800091a0:	f1 38 00 14 	ld.ub	r8,r8[20]
800091a4:	f8 08 18 00 	cp.b	r8,r12
800091a8:	c5 e1       	brne	80009264 <fat_cache_clusterlist_update_read+0x100>
800091aa:	4b 48       	lddpc	r8,80009278 <fat_cache_clusterlist_update_read+0x114>
800091ac:	f1 38 00 16 	ld.ub	r8,r8[22]
800091b0:	f2 08 18 00 	cp.b	r8,r9
800091b4:	c5 81       	brne	80009264 <fat_cache_clusterlist_update_read+0x100>
      &&  (fs_g_cache_clusterlist[u8_i].u8_lun == fs_g_nav.u8_lun ) )
      {
         if( fs_g_cache_clusterlist[u8_i].u32_cluster == fs_g_cluster.u32_pos )
800091b6:	4b 18       	lddpc	r8,80009278 <fat_cache_clusterlist_update_read+0x114>
800091b8:	70 68       	ld.w	r8,r8[0x18]
800091ba:	14 38       	cp.w	r8,r10
800091bc:	c5 41       	brne	80009264 <fat_cache_clusterlist_update_read+0x100>
         {
            if( fs_g_cache_clusterlist[u8_i].u32_start <= fs_g_seg.u32_size_or_pos )
800091be:	4a f8       	lddpc	r8,80009278 <fat_cache_clusterlist_update_read+0x114>
800091c0:	70 78       	ld.w	r8,r8[0x1c]
800091c2:	16 38       	cp.w	r8,r11
800091c4:	e0 8b 00 50 	brhi	80009264 <fat_cache_clusterlist_update_read+0x100>
800091c8:	30 1a       	mov	r10,1
800091ca:	14 99       	mov	r9,r10
            {
               // The segment research is in or after the cache
               if( fs_g_cache_clusterlist[u8_i].u32_size  > (fs_g_seg.u32_size_or_pos-fs_g_cache_clusterlist[u8_i].u32_start) )
800091cc:	f2 0e 15 02 	lsl	lr,r9,0x2
800091d0:	12 0e       	add	lr,r9
800091d2:	4a ac       	lddpc	r12,80009278 <fat_cache_clusterlist_update_read+0x114>
800091d4:	f8 0e 00 2c 	add	r12,r12,lr<<0x2
800091d8:	78 4c       	ld.w	r12,r12[0x10]
800091da:	f6 08 01 08 	sub	r8,r11,r8
800091de:	10 3c       	cp.w	r12,r8
800091e0:	e0 88 00 16 	brls	8000920c <fat_cache_clusterlist_update_read+0xa8>
               {
                  //** The segment research is in cache, then compute the segment infos
                  fs_g_seg.u32_size_or_pos -= fs_g_cache_clusterlist[u8_i].u32_start;
                  fs_g_seg.u32_addr = fs_g_cache_clusterlist[u8_i].u32_addr + fs_g_seg.u32_size_or_pos;
800091e4:	4a 4b       	lddpc	r11,80009274 <fat_cache_clusterlist_update_read+0x110>
800091e6:	f2 0e 15 02 	lsl	lr,r9,0x2
800091ea:	fc 09 00 09 	add	r9,lr,r9
800091ee:	4a 3e       	lddpc	lr,80009278 <fat_cache_clusterlist_update_read+0x114>
800091f0:	fc 09 00 29 	add	r9,lr,r9<<0x2
800091f4:	72 39       	ld.w	r9,r9[0xc]
800091f6:	f0 09 00 09 	add	r9,r8,r9
800091fa:	97 09       	st.w	r11[0x0],r9
                  fs_g_seg.u32_size_or_pos = fs_g_cache_clusterlist[u8_i].u32_size - fs_g_seg.u32_size_or_pos;
800091fc:	10 1c       	sub	r12,r8
800091fe:	97 1c       	st.w	r11[0x4],r12
                  fs_g_u8_current_cache = u8_i;
80009200:	49 f8       	lddpc	r8,8000927c <fat_cache_clusterlist_update_read+0x118>
80009202:	b0 8a       	st.b	r8[0x0],r10
                  fat_cache_clusterlist_update_select();
80009204:	f0 1f 00 1f 	mcall	80009280 <fat_cache_clusterlist_update_read+0x11c>
80009208:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
                  return true;   // the segment is in cluster list cache
               }else{
                  //** It is after the cache then get cache information and continue to read the cluster list in FAT
                  // Store the result in this cache
                  fs_g_u8_current_cache = u8_i;
8000920c:	49 c8       	lddpc	r8,8000927c <fat_cache_clusterlist_update_read+0x118>
8000920e:	b0 8a       	st.b	r8[0x0],r10
                  fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = 0xFF;   // invalid cache
80009210:	f2 08 15 02 	lsl	r8,r9,0x2
80009214:	f0 09 00 09 	add	r9,r8,r9
80009218:	49 88       	lddpc	r8,80009278 <fat_cache_clusterlist_update_read+0x114>
8000921a:	f0 09 00 28 	add	r8,r8,r9<<0x2
8000921e:	3f f9       	mov	r9,-1
80009220:	b0 a9       	st.b	r8[0x2],r9
                  // fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_cluster  = fs_g_cluster.u32_pos;  // It is the same cluster start

                  // Get cache information to take time during the next FAT access
                  // Compute the cluster number corresponding at the last cluster of the cluster list cache
                  fs_g_cluster.u32_pos     = ((fs_g_cache_clusterlist[u8_i].u32_addr -fs_g_nav.u32_ptr_fat - fs_g_nav.u32_offset_data + fs_g_cache_clusterlist[u8_i].u32_size -1)
80009222:	70 4c       	ld.w	r12,r8[0x10]
80009224:	49 2a       	lddpc	r10,8000926c <fat_cache_clusterlist_update_read+0x108>
80009226:	15 99       	ld.ub	r9,r10[0x1]
80009228:	70 3e       	ld.w	lr,r8[0xc]
8000922a:	f8 0e 00 0e 	add	lr,r12,lr
8000922e:	20 1e       	sub	lr,1
80009230:	74 57       	ld.w	r7,r10[0x14]
80009232:	fc 07 01 07 	sub	r7,lr,r7
80009236:	74 4a       	ld.w	r10,r10[0x10]
80009238:	14 17       	sub	r7,r10
8000923a:	ee 09 0d 06 	divu	r6,r7,r9
8000923e:	0c 97       	mov	r7,r6
80009240:	2f e7       	sub	r7,-2
80009242:	48 ca       	lddpc	r10,80009270 <fat_cache_clusterlist_update_read+0x10c>
80009244:	95 07       	st.w	r10[0x0],r7
                                             / fs_g_nav.u8_BPB_SecPerClus) +2;
                  u32_tmp  = fs_g_seg.u32_size_or_pos;                                 // save position ask
                  // Compute the position of the end of cluster list cache, and decrement the position asked
                  fs_g_seg.u32_size_or_pos-= ((fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start + fs_g_cache_clusterlist[u8_i].u32_size -1)
80009246:	2f 88       	sub	r8,-8
80009248:	70 0a       	ld.w	r10,r8[0x0]
8000924a:	14 0c       	add	r12,r10
8000924c:	f8 c7 00 01 	sub	r7,r12,1
80009250:	ee 09 0d 06 	divu	r6,r7,r9
80009254:	ad 39       	mul	r9,r6
80009256:	48 8a       	lddpc	r10,80009274 <fat_cache_clusterlist_update_read+0x110>
80009258:	f6 09 01 09 	sub	r9,r11,r9
8000925c:	95 19       	st.w	r10[0x4],r9
                                             / fs_g_nav.u8_BPB_SecPerClus)
                                             * fs_g_nav.u8_BPB_SecPerClus;
                  fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start = u32_tmp;   // Update cache with the position asked
8000925e:	91 0b       	st.w	r8[0x0],r11
80009260:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
            }
         }
      }
   }
   // No found in cache then read FAT and store the result in cache
   fat_cache_clusterlist_update_start(b_for_file);
80009264:	f0 1f 00 08 	mcall	80009284 <fat_cache_clusterlist_update_read+0x120>
80009268:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
8000926c:	00 00       	add	r0,r0
8000926e:	0c 18       	sub	r8,r6
80009270:	00 00       	add	r0,r0
80009272:	0c b8       	st.h	r6++,r8
80009274:	00 00       	add	r0,r0
80009276:	0c c0       	st.b	r6++,r0
80009278:	00 00       	add	r0,r0
8000927a:	09 ec       	ld.ub	r12,r4[0x6]
8000927c:	00 00       	add	r0,r0
8000927e:	0c 6a       	and	r10,r6
80009280:	80 00       	ld.sh	r0,r0[0x0]
80009282:	90 a4       	ld.uh	r4,r8[0x4]
80009284:	80 00       	ld.sh	r0,r0[0x0]
80009286:	90 5c       	ld.sh	r12,r8[0xa]

80009288 <fat_entry_is_dir>:
//! @return    true,    this entry is a directory
//! @return    false,   otherwise
//!
bool  fat_entry_is_dir(void)
{
   fs_g_status = FS_ERR_NO_DIR;
80009288:	30 d9       	mov	r9,13
8000928a:	48 48       	lddpc	r8,80009298 <fat_entry_is_dir+0x10>
8000928c:	b0 89       	st.b	r8[0x0],r9
8000928e:	48 48       	lddpc	r8,8000929c <fat_entry_is_dir+0x14>
80009290:	11 ac       	ld.ub	r12,r8[0x2]
   return (FS_ATTR_DIRECTORY & fs_g_nav_entry.u8_attr);
}
80009292:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
80009296:	5e fc       	retal	r12
80009298:	00 00       	add	r0,r0
8000929a:	0c 68       	and	r8,r6
8000929c:	00 00       	add	r0,r0
8000929e:	09 d8       	ld.ub	r8,r4[0x5]

800092a0 <fat_clear_entry_info_and_ptr>:

//! This function resets the selection pointers
//!
void  fat_clear_entry_info_and_ptr( void )
{
   fs_g_nav_fast.u16_entry_pos_sel_file= FS_NO_SEL;
800092a0:	3f f9       	mov	r9,-1
800092a2:	48 c8       	lddpc	r8,800092d0 <fat_clear_entry_info_and_ptr+0x30>
800092a4:	b0 19       	st.h	r8[0x2],r9
   fs_g_nav.u16_pos_sel_file           = FS_NO_SEL;
800092a6:	48 c8       	lddpc	r8,800092d4 <fat_clear_entry_info_and_ptr+0x34>
800092a8:	f1 59 00 24 	st.h	r8[36],r9
   if( !fs_g_nav.b_mode_nav_single )
800092ac:	f1 39 00 2d 	ld.ub	r9,r8[45]
800092b0:	30 08       	mov	r8,0
800092b2:	f0 09 18 00 	cp.b	r9,r8
800092b6:	c0 51       	brne	800092c0 <fat_clear_entry_info_and_ptr+0x20>
   {
      fs_g_nav.b_mode_nav                 = FS_DIR;
800092b8:	10 99       	mov	r9,r8
800092ba:	48 78       	lddpc	r8,800092d4 <fat_clear_entry_info_and_ptr+0x34>
800092bc:	f1 69 00 2c 	st.b	r8[44],r9
   }
   fs_g_nav_entry.u8_attr     = 0;
800092c0:	48 68       	lddpc	r8,800092d8 <fat_clear_entry_info_and_ptr+0x38>
800092c2:	30 09       	mov	r9,0
800092c4:	b0 a9       	st.b	r8[0x2],r9
   fs_g_nav_entry.u32_cluster = 0;
800092c6:	30 0a       	mov	r10,0
800092c8:	91 1a       	st.w	r8[0x4],r10
   fs_g_nav_entry.u32_size    = 0;
800092ca:	91 2a       	st.w	r8[0x8],r10
   Fat_file_close();
800092cc:	b0 89       	st.b	r8[0x0],r9
}
800092ce:	5e fc       	retal	r12
800092d0:	00 00       	add	r0,r0
800092d2:	0c 64       	and	r4,r6
800092d4:	00 00       	add	r0,r0
800092d6:	0c 18       	sub	r8,r6
800092d8:	00 00       	add	r0,r0
800092da:	09 d8       	ld.ub	r8,r4[0x5]

800092dc <fat_check_eof_name>:
//! @return    true, it is a character to signal a end of name (0,'\\','/')
//! @return    false, otherwise
//!
bool  fat_check_eof_name( uint16_t character )
{
   return (('\0'==character)||('\\'==character)||('/'==character));
800092dc:	30 08       	mov	r8,0
800092de:	f0 0c 19 00 	cp.h	r12,r8
800092e2:	5f 0a       	sreq	r10
800092e4:	35 c9       	mov	r9,92
800092e6:	f2 0c 19 00 	cp.h	r12,r9
800092ea:	5f 09       	sreq	r9
800092ec:	f5 e9 10 09 	or	r9,r10,r9
800092f0:	f0 09 18 00 	cp.b	r9,r8
800092f4:	c0 20       	breq	800092f8 <fat_check_eof_name+0x1c>
800092f6:	5e ff       	retal	1
800092f8:	32 f8       	mov	r8,47
800092fa:	f0 0c 19 00 	cp.h	r12,r8
800092fe:	5f 0c       	sreq	r12
}
80009300:	5e fc       	retal	r12
80009302:	d7 03       	nop

80009304 <fat_get_ptr_entry>:
//! This function returns a cache pointer on the current entry
//!
//! @return a pointer on the internal cache
//!
PTR_CACHE fat_get_ptr_entry( void )
{
80009304:	48 48       	lddpc	r8,80009314 <fat_get_ptr_entry+0x10>
80009306:	90 98       	ld.uh	r8,r8[0x2]
80009308:	a5 78       	lsl	r8,0x5
8000930a:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
   return &fs_g_sector[(fs_g_nav_fast.u16_entry_pos_sel_file * FS_SIZE_FILE_ENTRY) & FS_512B_MASK];
}
8000930e:	48 3c       	lddpc	r12,80009318 <fat_get_ptr_entry+0x14>
80009310:	10 0c       	add	r12,r8
80009312:	5e fc       	retal	r12
80009314:	00 00       	add	r0,r0
80009316:	0c 64       	and	r4,r6
80009318:	00 00       	add	r0,r0
8000931a:	0a 18       	sub	r8,r5

8000931c <fat_entry_longname>:
//!   fs_g_sector       The directory sector corresponding at the current position
//!   fs_g_nav_fast.u16_entry_pos_sel_file    Position in directory of the entry file (unit entry)
//! @endverbatim
//!
bool  fat_entry_longname( FS_STRING sz_name , uint8_t u8_size_max , bool b_mode , bool b_match_case )
{
8000931c:	d4 31       	pushm	r0-r7,lr
8000931e:	20 3d       	sub	sp,12
80009320:	18 97       	mov	r7,r12
80009322:	16 94       	mov	r4,r11
80009324:	14 96       	mov	r6,r10
80009326:	50 09       	stdsp	sp[0x0],r9
   uint8_t u8_pos_name;
   PTR_CACHE ptr_entry;
   uint16_t u16_unicode_entry;
   uint16_t u16_unicode_szname;

   ptr_entry = fat_get_ptr_entry();
80009328:	f0 1f 00 5e 	mcall	800094a0 <fat_entry_longname+0x184>

   if( (FS_ENTRY_END == *ptr_entry )            // end of directory
8000932c:	19 88       	ld.ub	r8,r12[0x0]
8000932e:	30 09       	mov	r9,0
80009330:	f2 08 18 00 	cp.b	r8,r9
80009334:	5f 0b       	sreq	r11
80009336:	3e 5a       	mov	r10,-27
80009338:	f4 08 18 00 	cp.b	r8,r10
8000933c:	5f 0a       	sreq	r10
8000933e:	f7 ea 10 0a 	or	r10,r11,r10
80009342:	f2 0a 18 00 	cp.b	r10,r9
80009346:	c0 71       	brne	80009354 <fat_entry_longname+0x38>
   ||  (FS_ENTRY_DEL == *ptr_entry )            // entry deleted
   ||  (FS_ATTR_LFN_ENTRY != ptr_entry[11]) )   // no long name
80009348:	f9 3a 00 0b 	ld.ub	r10,r12[11]
8000934c:	30 f9       	mov	r9,15
8000934e:	f2 0a 18 00 	cp.b	r10,r9
80009352:	c0 60       	breq	8000935e <fat_entry_longname+0x42>
   {
      fs_g_status = FS_ERR_ENTRY_BAD;
80009354:	30 b9       	mov	r9,11
80009356:	4d 48       	lddpc	r8,800094a4 <fat_entry_longname+0x188>
80009358:	b0 89       	st.b	r8[0x0],r9
8000935a:	30 0c       	mov	r12,0
      return false;
8000935c:	c9 c8       	rjmp	80009494 <fat_entry_longname+0x178>
   }

   if( g_b_string_length )
8000935e:	4d 39       	lddpc	r9,800094a8 <fat_entry_longname+0x18c>
80009360:	13 8a       	ld.ub	r10,r9[0x0]
80009362:	30 09       	mov	r9,0
80009364:	f2 0a 18 00 	cp.b	r10,r9
80009368:	c0 90       	breq	8000937a <fat_entry_longname+0x5e>
   {
      if ( 0 == (FS_ENTRY_LFN_LAST & *ptr_entry))
8000936a:	e2 18 00 40 	andl	r8,0x40,COH
8000936e:	c0 61       	brne	8000937a <fat_entry_longname+0x5e>
      {
         // no necessary -> ((FS_STR_UNICODE)sz_name)[0] = FS_SIZE_LFN_ENTRY;
         fs_g_status = FS_NO_LAST_LFN_ENTRY;
80009370:	31 09       	mov	r9,16
80009372:	4c d8       	lddpc	r8,800094a4 <fat_entry_longname+0x188>
80009374:	b0 89       	st.b	r8[0x0],r9
80009376:	30 0c       	mov	r12,0
         return false;                          // Other entry long name
80009378:	c8 e8       	rjmp	80009494 <fat_entry_longname+0x178>
      }
   }

   ptr_entry++;                                 // The long name start at offset 1 of the entry file
8000937a:	2f fc       	sub	r12,-1
8000937c:	30 08       	mov	r8,0

   u8_pos_name=0;
   while( 1 )
   {
      LSB(u16_unicode_entry) = ptr_entry[0];
8000937e:	fa ca ff f6 	sub	r10,sp,-10
         if( '*' == u16_unicode_szname )
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( ((0 != u16_unicode_entry ) || (( '\\' != u16_unicode_szname) && ( '/' != u16_unicode_szname)) )
80009382:	30 0b       	mov	r11,0
   {
      LSB(u16_unicode_entry) = ptr_entry[0];
      MSB(u16_unicode_entry) = ptr_entry[1];
      if( FS_NAME_GET == b_mode )
      {
         if( !g_b_string_length )
80009384:	4c 95       	lddpc	r5,800094a8 <fat_entry_longname+0x18c>
         {
            // Check the end of buffer
            if( u8_pos_name>=(u8_size_max-1) )
80009386:	20 14       	sub	r4,1
80009388:	50 14       	stdsp	sp[0x4],r4
           fs_g_status = FS_ERR_NAME_INCORRECT; //  The name don't corresponding at filter name
           return false;
         }
      }

      if( 0 == u16_unicode_entry)
8000938a:	30 01       	mov	r1,0
         {
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;
         }
         return true;                           // Last long name entry
      }
      if( 4 == u8_pos_name )
8000938c:	30 44       	mov	r4,4
   ptr_entry++;                                 // The long name start at offset 1 of the entry file

   u8_pos_name=0;
   while( 1 )
   {
      LSB(u16_unicode_entry) = ptr_entry[0];
8000938e:	19 89       	ld.ub	r9,r12[0x0]
80009390:	b4 99       	st.b	r10[0x1],r9
      MSB(u16_unicode_entry) = ptr_entry[1];
80009392:	19 99       	ld.ub	r9,r12[0x1]
80009394:	b4 89       	st.b	r10[0x0],r9
      if( FS_NAME_GET == b_mode )
80009396:	58 06       	cp.w	r6,0
80009398:	c0 f0       	breq	800093b6 <fat_entry_longname+0x9a>
      {
         if( !g_b_string_length )
8000939a:	0b 89       	ld.ub	r9,r5[0x0]
8000939c:	f6 09 18 00 	cp.b	r9,r11
800093a0:	c3 91       	brne	80009412 <fat_entry_longname+0xf6>
         {
            // Check the end of buffer
            if( u8_pos_name>=(u8_size_max-1) )
800093a2:	40 1e       	lddsp	lr,sp[0x4]
800093a4:	1c 38       	cp.w	r8,lr
800093a6:	c0 55       	brlt	800093b0 <fat_entry_longname+0x94>
               // Write end of string
               if( Is_unicode )
               {
                  ((FS_STR_UNICODE)sz_name)[0] = 0;
               }else{
                  sz_name[0] = 0;
800093a8:	30 08       	mov	r8,0
800093aa:	ae 88       	st.b	r7[0x0],r8
800093ac:	30 1c       	mov	r12,1
               }
               return true;                     // the buffer is full
800093ae:	c7 38       	rjmp	80009494 <fat_entry_longname+0x178>
            // Read and store the long name
            if( Is_unicode )
            {
               ((FS_STR_UNICODE)sz_name)[0] = u16_unicode_entry;
            }else{
               sz_name[0] = (uint8_t)u16_unicode_entry;
800093b0:	9a 59       	ld.sh	r9,sp[0xa]
800093b2:	ae 89       	st.b	r7[0x0],r9
800093b4:	c2 f8       	rjmp	80009412 <fat_entry_longname+0xf6>
      {
         if( Is_unicode )
         {
            u16_unicode_szname = ((FS_STR_UNICODE)sz_name)[0];
         }else{
            u16_unicode_szname = sz_name[0];
800093b6:	0f 89       	ld.ub	r9,r7[0x0]
         }
         // Check the name
         if( '*' == u16_unicode_szname )
800093b8:	32 a3       	mov	r3,42
800093ba:	e6 09 19 00 	cp.h	r9,r3
800093be:	c6 a0       	breq	80009492 <fat_entry_longname+0x176>
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( ((0 != u16_unicode_entry ) || (( '\\' != u16_unicode_szname) && ( '/' != u16_unicode_szname)) )
800093c0:	9a 5e       	ld.sh	lr,sp[0xa]
800093c2:	58 0e       	cp.w	lr,0
800093c4:	c0 e1       	brne	800093e0 <fat_entry_longname+0xc4>
800093c6:	35 c0       	mov	r0,92
800093c8:	e0 09 19 00 	cp.h	r9,r0
800093cc:	5f 12       	srne	r2
800093ce:	32 f3       	mov	r3,47
800093d0:	e6 09 19 00 	cp.h	r9,r3
800093d4:	5f 13       	srne	r3
800093d6:	e5 e3 00 03 	and	r3,r2,r3
800093da:	f6 03 18 00 	cp.b	r3,r11
800093de:	c1 e0       	breq	8000941a <fat_entry_longname+0xfe>
         &&  ((u16_unicode_szname != (u16_unicode_entry+('a'-'A'))) || b_match_case)
800093e0:	e7 d9 c0 10 	bfextu	r3,r9,0x0,0x10
800093e4:	e5 de c0 10 	bfextu	r2,lr,0x0,0x10
         if( '*' == u16_unicode_szname )
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( ((0 != u16_unicode_entry ) || (( '\\' != u16_unicode_szname) && ( '/' != u16_unicode_szname)) )
800093e8:	e4 c0 ff e0 	sub	r0,r2,-32
800093ec:	00 33       	cp.w	r3,r0
800093ee:	c0 41       	brne	800093f6 <fat_entry_longname+0xda>
800093f0:	40 00       	lddsp	r0,sp[0x0]
800093f2:	58 00       	cp.w	r0,0
800093f4:	c0 f0       	breq	80009412 <fat_entry_longname+0xf6>
800093f6:	22 02       	sub	r2,32
800093f8:	04 33       	cp.w	r3,r2
800093fa:	c0 41       	brne	80009402 <fat_entry_longname+0xe6>
800093fc:	40 03       	lddsp	r3,sp[0x0]
800093fe:	58 03       	cp.w	r3,0
80009400:	c0 90       	breq	80009412 <fat_entry_longname+0xf6>
80009402:	fc 09 19 00 	cp.h	r9,lr
80009406:	c0 60       	breq	80009412 <fat_entry_longname+0xf6>
         &&  ((u16_unicode_szname != (u16_unicode_entry+('a'-'A'))) || b_match_case)
         &&  ((u16_unicode_szname != (u16_unicode_entry-('a'-'A'))) || b_match_case)
         &&  (u16_unicode_szname != u16_unicode_entry) )
         {
           fs_g_status = FS_ERR_NAME_INCORRECT; //  The name don't corresponding at filter name
80009408:	31 69       	mov	r9,22
8000940a:	4a 78       	lddpc	r8,800094a4 <fat_entry_longname+0x188>
8000940c:	b0 89       	st.b	r8[0x0],r9
8000940e:	30 0c       	mov	r12,0
           return false;
80009410:	c4 28       	rjmp	80009494 <fat_entry_longname+0x178>
         }
      }

      if( 0 == u16_unicode_entry)
80009412:	9a 59       	ld.sh	r9,sp[0xa]
80009414:	e2 09 19 00 	cp.h	r9,r1
80009418:	c0 b1       	brne	8000942e <fat_entry_longname+0x112>
      {
         if( g_b_string_length )
8000941a:	4a 49       	lddpc	r9,800094a8 <fat_entry_longname+0x18c>
8000941c:	13 8a       	ld.ub	r10,r9[0x0]
8000941e:	30 09       	mov	r9,0
80009420:	f2 0a 18 00 	cp.b	r10,r9
80009424:	c3 70       	breq	80009492 <fat_entry_longname+0x176>
         {
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;
80009426:	2f f8       	sub	r8,-1
80009428:	ae 08       	st.h	r7[0x0],r8
8000942a:	30 1c       	mov	r12,1
8000942c:	c3 48       	rjmp	80009494 <fat_entry_longname+0x178>
         }
         return true;                           // Last long name entry
      }
      if( 4 == u8_pos_name )
8000942e:	e8 08 18 00 	cp.b	r8,r4
80009432:	c0 31       	brne	80009438 <fat_entry_longname+0x11c>
         ptr_entry += 3;                        // Go to second character
80009434:	2f dc       	sub	r12,-3
80009436:	c2 58       	rjmp	80009480 <fat_entry_longname+0x164>

      if( 10 == u8_pos_name )
80009438:	30 a9       	mov	r9,10
8000943a:	f2 08 18 00 	cp.b	r8,r9
8000943e:	c0 31       	brne	80009444 <fat_entry_longname+0x128>
         ptr_entry += 2;                        // Go to third character
80009440:	2f ec       	sub	r12,-2
80009442:	c1 f8       	rjmp	80009480 <fat_entry_longname+0x164>

      if( 12 == u8_pos_name )
80009444:	30 c9       	mov	r9,12
80009446:	f2 08 18 00 	cp.b	r8,r9
8000944a:	c1 b1       	brne	80009480 <fat_entry_longname+0x164>
      {  // End of entry long name
         ptr_entry -= (FS_SIZE_FILE_ENTRY-2);   // Go to the first byte of the file entry
         if ( 0 == (FS_ENTRY_LFN_LAST & ptr_entry[0]))
8000944c:	f9 38 ff e2 	ld.ub	r8,r12[-30]
80009450:	e2 18 00 40 	andl	r8,0x40,COH
80009454:	c0 61       	brne	80009460 <fat_entry_longname+0x144>
         {
            fs_g_status = FS_NO_LAST_LFN_ENTRY;
80009456:	31 09       	mov	r9,16
80009458:	49 38       	lddpc	r8,800094a4 <fat_entry_longname+0x188>
8000945a:	b0 89       	st.b	r8[0x0],r9
8000945c:	30 0c       	mov	r12,0
            return false;                       // Other long name entry is present
8000945e:	c1 b8       	rjmp	80009494 <fat_entry_longname+0x178>
         }
         else
         {  // It is the last long name entry
            // then it is the end of name
            if( (FS_NAME_GET == b_mode) && g_b_string_length )
80009460:	58 06       	cp.w	r6,0
80009462:	c0 b0       	breq	80009478 <fat_entry_longname+0x15c>
80009464:	49 18       	lddpc	r8,800094a8 <fat_entry_longname+0x18c>
80009466:	11 89       	ld.ub	r9,r8[0x0]
80009468:	30 08       	mov	r8,0
8000946a:	f0 09 18 00 	cp.b	r9,r8
8000946e:	c1 50       	breq	80009498 <fat_entry_longname+0x17c>
            {
               ((FS_STR_UNICODE)sz_name)[0] = 14;
80009470:	30 e8       	mov	r8,14
80009472:	ae 08       	st.h	r7[0x0],r8
80009474:	30 1c       	mov	r12,1
               return true;
80009476:	c0 f8       	rjmp	80009494 <fat_entry_longname+0x178>
               {
                  u16_unicode_szname = ((FS_STR_UNICODE)sz_name)[0];
               }else{
                  u16_unicode_szname = sz_name[0];
               }
               return fat_check_eof_name(u16_unicode_szname);
80009478:	0f 9c       	ld.ub	r12,r7[0x1]
8000947a:	f0 1f 00 0d 	mcall	800094ac <fat_entry_longname+0x190>
8000947e:	c0 b8       	rjmp	80009494 <fat_entry_longname+0x178>
            }
         }
      }

      if( !g_b_string_length )
80009480:	0b 89       	ld.ub	r9,r5[0x0]
      {
         sz_name += (Is_unicode? 2 : 1 );
80009482:	f6 09 18 00 	cp.b	r9,r11
80009486:	f7 b7 00 ff 	subeq	r7,-1
      }
      u8_pos_name++;
8000948a:	2f f8       	sub	r8,-1
8000948c:	5c 58       	castu.b	r8
      ptr_entry+=2;
8000948e:	2f ec       	sub	r12,-2
   }
80009490:	c7 fb       	rjmp	8000938e <fat_entry_longname+0x72>
80009492:	30 1c       	mov	r12,1
}
80009494:	2f dd       	sub	sp,-12
80009496:	d8 32       	popm	r0-r7,pc
               // Write end of string UNICODE
               if( Is_unicode )
               {
                  ((FS_STR_UNICODE)sz_name)[0] = 0;
               }else{
                  sz_name[0] = 0;
80009498:	30 08       	mov	r8,0
8000949a:	ae 98       	st.b	r7[0x1],r8
8000949c:	30 1c       	mov	r12,1
               }
               return true;
8000949e:	cf bb       	rjmp	80009494 <fat_entry_longname+0x178>
800094a0:	80 00       	ld.sh	r0,r0[0x0]
800094a2:	93 04       	st.w	r9[0x0],r4
800094a4:	00 00       	add	r0,r0
800094a6:	0c 68       	and	r8,r6
800094a8:	00 00       	add	r0,r0
800094aa:	0c 69       	and	r9,r6
800094ac:	80 00       	ld.sh	r0,r0[0x0]
800094ae:	92 dc       	ld.uh	r12,r9[0xa]

800094b0 <fat_entry_shortname>:
//!   fs_g_sector       The directory sector corresponding at the current position
//!   fs_g_nav_fast.u16_entry_pos_sel_file    Position in directory of the entry file (unit entry)
//! @endverbatim
//!
bool  fat_entry_shortname( FS_STRING sz_name , uint8_t u8_size_max , bool b_mode )
{
800094b0:	d4 31       	pushm	r0-r7,lr
800094b2:	20 2d       	sub	sp,8
800094b4:	18 97       	mov	r7,r12
800094b6:	50 1b       	stdsp	sp[0x4],r11
800094b8:	14 96       	mov	r6,r10
   uint8_t u8_pos_name;
   uint8_t u8_entry_char, u8_szname_char;
   PTR_CACHE ptr_entry;
   uint8_t u8_pos_entry;

   fs_g_status = FS_ERR_NAME_INCORRECT;  // by default the name don't corresponding at filter name
800094ba:	31 69       	mov	r9,22
800094bc:	4b c8       	lddpc	r8,800095ac <fat_entry_shortname+0xfc>
800094be:	b0 89       	st.b	r8[0x0],r9

   u8_pos_name = 0;
   u8_pos_entry = 0;
   ptr_entry = fat_get_ptr_entry();
800094c0:	f0 1f 00 3c 	mcall	800095b0 <fat_entry_shortname+0x100>
800094c4:	30 08       	mov	r8,0
800094c6:	10 9a       	mov	r10,r8
800094c8:	30 1b       	mov	r11,1
800094ca:	50 0b       	stdsp	sp[0x0],r11

   // for each characters of short name
   while( 1 )
   {
      if( FS_SIZE_SFNAME == u8_pos_entry )
800094cc:	30 be       	mov	lr,11
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT == u8_pos_entry) && b_extension_nostart)  // end of name and '.' character not written
         ||  ( ' ' == u8_entry_char) )
         {
            // end of name or extension
            if( (FS_SIZE_SFNAME_WITHOUT_EXT >= u8_pos_entry)         // End of name without extension
            &&  (' ' != ptr_entry[ FS_SIZE_SFNAME_WITHOUT_EXT ]) )   // extension exists
800094ce:	10 93       	mov	r3,r8
         u8_entry_char = 0;   // end of name
      }
      else
      {
         u8_entry_char = ptr_entry[ u8_pos_entry ];
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT == u8_pos_entry) && b_extension_nostart)  // end of name and '.' character not written
800094d0:	30 85       	mov	r5,8
         ||  ( ' ' == u8_entry_char) )
         {
            // end of name or extension
            if( (FS_SIZE_SFNAME_WITHOUT_EXT >= u8_pos_entry)         // End of name without extension
            &&  (' ' != ptr_entry[ FS_SIZE_SFNAME_WITHOUT_EXT ]) )   // extension exists
800094d2:	32 04       	mov	r4,32
         {
            u8_szname_char = ((FS_STR_UNICODE)sz_name)[0];
         }else{
            u8_szname_char = sz_name[0];
         }
         if ('*' == u8_szname_char)
800094d4:	32 a2       	mov	r2,42
   ptr_entry = fat_get_ptr_entry();

   // for each characters of short name
   while( 1 )
   {
      if( FS_SIZE_SFNAME == u8_pos_entry )
800094d6:	fc 08 18 00 	cp.b	r8,lr
800094da:	c1 90       	breq	8000950c <fat_entry_shortname+0x5c>
      {
         u8_entry_char = 0;   // end of name
      }
      else
      {
         u8_entry_char = ptr_entry[ u8_pos_entry ];
800094dc:	f8 08 07 09 	ld.ub	r9,r12[r8]
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT == u8_pos_entry) && b_extension_nostart)  // end of name and '.' character not written
800094e0:	ea 08 18 00 	cp.b	r8,r5
800094e4:	c0 41       	brne	800094ec <fat_entry_shortname+0x3c>
800094e6:	40 01       	lddsp	r1,sp[0x0]
800094e8:	58 01       	cp.w	r1,0
800094ea:	c0 81       	brne	800094fa <fat_entry_shortname+0x4a>
800094ec:	e8 09 18 00 	cp.b	r9,r4
800094f0:	c0 f1       	brne	8000950e <fat_entry_shortname+0x5e>
         ||  ( ' ' == u8_entry_char) )
         {
            // end of name or extension
            if( (FS_SIZE_SFNAME_WITHOUT_EXT >= u8_pos_entry)         // End of name without extension
800094f2:	ea 08 18 00 	cp.b	r8,r5
800094f6:	e0 8b 00 0b 	brhi	8000950c <fat_entry_shortname+0x5c>
            &&  (' ' != ptr_entry[ FS_SIZE_SFNAME_WITHOUT_EXT ]) )   // extension exists
800094fa:	f9 39 00 08 	ld.ub	r9,r12[8]
800094fe:	e8 09 18 00 	cp.b	r9,r4
80009502:	c0 50       	breq	8000950c <fat_entry_shortname+0x5c>
80009504:	30 78       	mov	r8,7
80009506:	32 e9       	mov	r9,46
80009508:	50 03       	stdsp	sp[0x0],r3
8000950a:	c0 28       	rjmp	8000950e <fat_entry_shortname+0x5e>
8000950c:	06 99       	mov	r9,r3
               u8_entry_char = 0;                                    // end of name
            }
         }
      }

      if( FS_NAME_GET == b_mode )
8000950e:	58 06       	cp.w	r6,0
80009510:	c1 80       	breq	80009540 <fat_entry_shortname+0x90>
      {
         if( !g_b_string_length )
80009512:	4a 9b       	lddpc	r11,800095b4 <fat_entry_shortname+0x104>
80009514:	17 81       	ld.ub	r1,r11[0x0]
80009516:	30 0b       	mov	r11,0
80009518:	f6 01 18 00 	cp.b	r1,r11
8000951c:	c2 c1       	brne	80009574 <fat_entry_shortname+0xc4>
         {
            if(u8_pos_name >= (u8_size_max-1))
8000951e:	40 1b       	lddsp	r11,sp[0x4]
80009520:	20 1b       	sub	r11,1
80009522:	16 3a       	cp.w	r10,r11
80009524:	c0 35       	brlt	8000952a <fat_entry_shortname+0x7a>
80009526:	06 99       	mov	r9,r3
80009528:	c0 a8       	rjmp	8000953c <fat_entry_shortname+0x8c>
               u8_entry_char = 0;                                    // buffer full then force end of string

            if( ('A'<=u8_entry_char) && (u8_entry_char<='Z'))
8000952a:	f2 c1 00 41 	sub	r1,r9,65
8000952e:	31 9b       	mov	r11,25
80009530:	f6 01 18 00 	cp.b	r1,r11
80009534:	e0 8b 00 04 	brhi	8000953c <fat_entry_shortname+0x8c>
               u8_entry_char += ('a'-'A');                           // display short name in down case
80009538:	2e 09       	sub	r9,-32
8000953a:	5c 59       	castu.b	r9

            if( Is_unicode )
            {
               ((FS_STR_UNICODE)sz_name)[0] = u8_entry_char;
            }else{
               sz_name[0] = u8_entry_char;
8000953c:	ae 89       	st.b	r7[0x0],r9
8000953e:	c1 b8       	rjmp	80009574 <fat_entry_shortname+0xc4>

         if( Is_unicode )
         {
            u8_szname_char = ((FS_STR_UNICODE)sz_name)[0];
         }else{
            u8_szname_char = sz_name[0];
80009540:	0f 8b       	ld.ub	r11,r7[0x0]
         }
         if ('*' == u8_szname_char)
80009542:	e4 0b 18 00 	cp.b	r11,r2
80009546:	c2 f0       	breq	800095a4 <fat_entry_shortname+0xf4>
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( (0 != u8_entry_char) || (('\\' != u8_szname_char) && ('/' != u8_szname_char)) )
80009548:	58 09       	cp.w	r9,0
8000954a:	c0 c1       	brne	80009562 <fat_entry_shortname+0xb2>
8000954c:	35 c1       	mov	r1,92
8000954e:	e2 0b 18 00 	cp.b	r11,r1
80009552:	5f 10       	srne	r0
80009554:	32 f1       	mov	r1,47
80009556:	e2 0b 18 00 	cp.b	r11,r1
8000955a:	5f 11       	srne	r1
8000955c:	e1 e1 00 01 	and	r1,r0,r1
80009560:	c0 c0       	breq	80009578 <fat_entry_shortname+0xc8>
         {
            if((u8_szname_char != u8_entry_char)
80009562:	f2 0b 18 00 	cp.b	r11,r9
80009566:	c0 70       	breq	80009574 <fat_entry_shortname+0xc4>
80009568:	f2 c1 ff e0 	sub	r1,r9,-32
8000956c:	02 3b       	cp.w	r11,r1
8000956e:	c0 30       	breq	80009574 <fat_entry_shortname+0xc4>
80009570:	30 0c       	mov	r12,0
80009572:	c1 a8       	rjmp	800095a6 <fat_entry_shortname+0xf6>
               return false;  // short name not equal
         }
      }

      // For each characters
      if (0 == u8_entry_char)
80009574:	58 09       	cp.w	r9,0
80009576:	c0 b1       	brne	8000958c <fat_entry_shortname+0xdc>
      {
         if( g_b_string_length )
80009578:	48 f8       	lddpc	r8,800095b4 <fat_entry_shortname+0x104>
8000957a:	11 89       	ld.ub	r9,r8[0x0]
8000957c:	30 08       	mov	r8,0
8000957e:	f0 09 18 00 	cp.b	r9,r8
80009582:	c1 10       	breq	800095a4 <fat_entry_shortname+0xf4>
         {
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;      // Get length name
80009584:	2f fa       	sub	r10,-1
80009586:	ae 0a       	st.h	r7[0x0],r10
80009588:	30 1c       	mov	r12,1
8000958a:	c0 e8       	rjmp	800095a6 <fat_entry_shortname+0xf6>
         }
         return true;   // End of test correct or end of get name
      }
      if( !g_b_string_length )
8000958c:	48 a9       	lddpc	r9,800095b4 <fat_entry_shortname+0x104>
8000958e:	13 8b       	ld.ub	r11,r9[0x0]
80009590:	30 09       	mov	r9,0
      {
         sz_name += (Is_unicode? 2 : 1 );
80009592:	f2 0b 18 00 	cp.b	r11,r9
80009596:	f7 b7 00 ff 	subeq	r7,-1
      }
      u8_pos_name++;
8000959a:	2f fa       	sub	r10,-1
8000959c:	5c 5a       	castu.b	r10
      u8_pos_entry++;
8000959e:	2f f8       	sub	r8,-1
800095a0:	5c 58       	castu.b	r8
   }
800095a2:	c9 ab       	rjmp	800094d6 <fat_entry_shortname+0x26>
800095a4:	30 1c       	mov	r12,1
}
800095a6:	2f ed       	sub	sp,-8
800095a8:	d8 32       	popm	r0-r7,pc
800095aa:	00 00       	add	r0,r0
800095ac:	00 00       	add	r0,r0
800095ae:	0c 68       	and	r8,r6
800095b0:	80 00       	ld.sh	r0,r0[0x0]
800095b2:	93 04       	st.w	r9[0x0],r4
800095b4:	00 00       	add	r0,r0
800095b6:	0c 69       	and	r9,r6

800095b8 <fat_get_entry_info>:
//! OUT:
//!   fs_g_nav_entry. u32_cluster, u8_attr, u32_size
//! @endverbatim
//!
void  fat_get_entry_info( void )
{
800095b8:	d4 01       	pushm	lr
   PTR_CACHE ptr_entry;

   ptr_entry = fat_get_ptr_entry();
800095ba:	f0 1f 00 10 	mcall	800095f8 <fat_get_entry_info+0x40>

   // Get Attribute
   ptr_entry+= 11;
   fs_g_nav_entry.u8_attr = ptr_entry[0];
800095be:	49 08       	lddpc	r8,800095fc <fat_get_entry_info+0x44>
800095c0:	f9 39 00 0b 	ld.ub	r9,r12[11]
800095c4:	b0 a9       	st.b	r8[0x2],r9

   // Get the first cluster of the file cluster list
   ptr_entry += (20-11);
800095c6:	f8 ca ff ec 	sub	r10,r12,-20
   LSB2(fs_g_nav_entry.u32_cluster) = ptr_entry[0];
800095ca:	f0 c9 ff fc 	sub	r9,r8,-4
800095ce:	15 8b       	ld.ub	r11,r10[0x0]
800095d0:	b2 9b       	st.b	r9[0x1],r11
   LSB3(fs_g_nav_entry.u32_cluster) = ptr_entry[1];
800095d2:	15 9a       	ld.ub	r10,r10[0x1]
800095d4:	b2 8a       	st.b	r9[0x0],r10
   ptr_entry += (26-20);
800095d6:	f8 ca ff e6 	sub	r10,r12,-26
   LSB0(fs_g_nav_entry.u32_cluster) = ptr_entry[0];
800095da:	15 8b       	ld.ub	r11,r10[0x0]
800095dc:	b2 bb       	st.b	r9[0x3],r11
   LSB1(fs_g_nav_entry.u32_cluster) = ptr_entry[1];
800095de:	15 9a       	ld.ub	r10,r10[0x1]
800095e0:	b2 aa       	st.b	r9[0x2],r10

   // Get the size of file
   ptr_entry += (28-26);
800095e2:	2e 4c       	sub	r12,-28
   LSB0(fs_g_nav_entry.u32_size) = ptr_entry[0];
800095e4:	2f 88       	sub	r8,-8
800095e6:	19 89       	ld.ub	r9,r12[0x0]
800095e8:	b0 b9       	st.b	r8[0x3],r9
   LSB1(fs_g_nav_entry.u32_size) = ptr_entry[1];
800095ea:	19 99       	ld.ub	r9,r12[0x1]
800095ec:	b0 a9       	st.b	r8[0x2],r9
   LSB2(fs_g_nav_entry.u32_size) = ptr_entry[2];
800095ee:	19 a9       	ld.ub	r9,r12[0x2]
800095f0:	b0 99       	st.b	r8[0x1],r9
   LSB3(fs_g_nav_entry.u32_size) = ptr_entry[3];
800095f2:	19 b9       	ld.ub	r9,r12[0x3]
800095f4:	b0 89       	st.b	r8[0x0],r9
}
800095f6:	d8 02       	popm	pc
800095f8:	80 00       	ld.sh	r0,r0[0x0]
800095fa:	93 04       	st.w	r9[0x0],r4
800095fc:	00 00       	add	r0,r0
800095fe:	09 d8       	ld.ub	r8,r4[0x5]

80009600 <fat_entry_checkext>:
//!   fs_g_sector       The directory sector corresponding at the current position
//!   fs_g_nav_fast.u16_entry_pos_sel_file    Position in directory of the entry file (unit entry)
//! @endverbatim
//!
bool  fat_entry_checkext( FS_STRING sz_filter )
{
80009600:	eb cd 40 fc 	pushm	r2-r7,lr
80009604:	18 97       	mov	r7,r12
   PTR_CACHE u8_ptr_entry;
   uint8_t u8_i, u8_filter_char, u8_entry_char;

   u8_ptr_entry = fat_get_ptr_entry();
80009606:	f0 1f 00 26 	mcall	8000969c <fat_entry_checkext+0x9c>

   // Compare the extension with filter
   for( u8_i=0 ; u8_i<3 ; u8_i++)
   {
      u8_filter_char = *sz_filter;
8000960a:	0f 88       	ld.ub	r8,r7[0x0]
      if ('*' == u8_filter_char)
8000960c:	32 a9       	mov	r9,42
8000960e:	f2 08 18 00 	cp.b	r8,r9
80009612:	c3 f0       	breq	80009690 <fat_entry_checkext+0x90>
80009614:	30 0a       	mov	r10,0
   uint8_t u8_i, u8_filter_char, u8_entry_char;

   u8_ptr_entry = fat_get_ptr_entry();

   // Compare the extension with filter
   for( u8_i=0 ; u8_i<3 ; u8_i++)
80009616:	30 25       	mov	r5,2
      // Compare the extension filter to extension file (this one ignore the case)
      if( (u8_filter_char!=  u8_entry_char     )
      &&  (u8_filter_char!= (u8_entry_char+('a'-'A'))) )
      {
         if ( (',' == u8_filter_char)
         ||   ( 0  == u8_filter_char) )
80009618:	30 0e       	mov	lr,0

      // Compare the extension filter to extension file (this one ignore the case)
      if( (u8_filter_char!=  u8_entry_char     )
      &&  (u8_filter_char!= (u8_entry_char+('a'-'A'))) )
      {
         if ( (',' == u8_filter_char)
8000961a:	32 c9       	mov	r9,44
         ||   ( 0  == u8_filter_char) )
         {
           // It is the end of filter
           if (' ' == u8_entry_char)
8000961c:	32 03       	mov	r3,32
            sz_filter++;
            u8_filter_char = *sz_filter;
         }
         u8_i = 0xFF;          // restart loop compare
      }
      sz_filter++; // go to next char of filter
8000961e:	14 94       	mov	r4,r10

   // Compare the extension with filter
   for( u8_i=0 ; u8_i<3 ; u8_i++)
   {
      u8_filter_char = *sz_filter;
      if ('*' == u8_filter_char)
80009620:	32 a6       	mov	r6,42
80009622:	c0 68       	rjmp	8000962e <fat_entry_checkext+0x2e>
            sz_filter++;
            u8_filter_char = *sz_filter;
         }
         u8_i = 0xFF;          // restart loop compare
      }
      sz_filter++; // go to next char of filter
80009624:	2f f7       	sub	r7,-1
   u8_ptr_entry = fat_get_ptr_entry();

   // Compare the extension with filter
   for( u8_i=0 ; u8_i<3 ; u8_i++)
   {
      u8_filter_char = *sz_filter;
80009626:	0f 88       	ld.ub	r8,r7[0x0]
      if ('*' == u8_filter_char)
80009628:	ec 08 18 00 	cp.b	r8,r6
8000962c:	c3 20       	breq	80009690 <fat_entry_checkext+0x90>
         break; // All extension is good

      u8_entry_char = u8_ptr_entry[8+u8_i];
8000962e:	f8 0a 00 0b 	add	r11,r12,r10
80009632:	f7 3b 00 08 	ld.ub	r11,r11[8]

      // Compare the extension filter to extension file (this one ignore the case)
      if( (u8_filter_char!=  u8_entry_char     )
80009636:	f6 08 18 00 	cp.b	r8,r11
8000963a:	c2 20       	breq	8000967e <fat_entry_checkext+0x7e>
8000963c:	f6 c2 ff e0 	sub	r2,r11,-32
80009640:	04 38       	cp.w	r8,r2
80009642:	c1 e0       	breq	8000967e <fat_entry_checkext+0x7e>
      &&  (u8_filter_char!= (u8_entry_char+('a'-'A'))) )
      {
         if ( (',' == u8_filter_char)
         ||   ( 0  == u8_filter_char) )
80009644:	fc 08 18 00 	cp.b	r8,lr
80009648:	5f 0a       	sreq	r10

      // Compare the extension filter to extension file (this one ignore the case)
      if( (u8_filter_char!=  u8_entry_char     )
      &&  (u8_filter_char!= (u8_entry_char+('a'-'A'))) )
      {
         if ( (',' == u8_filter_char)
8000964a:	f2 08 18 00 	cp.b	r8,r9
8000964e:	5f 02       	sreq	r2
80009650:	f5 e2 10 02 	or	r2,r10,r2
80009654:	fc 02 18 00 	cp.b	r2,lr
80009658:	c0 71       	brne	80009666 <fat_entry_checkext+0x66>
              break; // it is the end of extension file -> extension good
         }
         // here, bad extension

         // Search the next filter
         while( ',' != u8_filter_char )
8000965a:	f2 08 18 00 	cp.b	r8,r9
8000965e:	c1 b0       	breq	80009694 <fat_entry_checkext+0x94>
         {
            if (0  == u8_filter_char)
80009660:	58 0a       	cp.w	r10,0
80009662:	c0 80       	breq	80009672 <fat_entry_checkext+0x72>
80009664:	c1 48       	rjmp	8000968c <fat_entry_checkext+0x8c>
      {
         if ( (',' == u8_filter_char)
         ||   ( 0  == u8_filter_char) )
         {
           // It is the end of filter
           if (' ' == u8_entry_char)
80009666:	e6 0b 18 00 	cp.b	r11,r3
8000966a:	cf 81       	brne	8000965a <fat_entry_checkext+0x5a>
8000966c:	c1 28       	rjmp	80009690 <fat_entry_checkext+0x90>
         // here, bad extension

         // Search the next filter
         while( ',' != u8_filter_char )
         {
            if (0  == u8_filter_char)
8000966e:	58 08       	cp.w	r8,0
80009670:	c0 e0       	breq	8000968c <fat_entry_checkext+0x8c>
            {
               return false;   // it is the last filter
            }
            sz_filter++;
80009672:	2f f7       	sub	r7,-1
            u8_filter_char = *sz_filter;
80009674:	0f 88       	ld.ub	r8,r7[0x0]
              break; // it is the end of extension file -> extension good
         }
         // here, bad extension

         // Search the next filter
         while( ',' != u8_filter_char )
80009676:	f2 08 18 00 	cp.b	r8,r9
8000967a:	cf a1       	brne	8000966e <fat_entry_checkext+0x6e>
8000967c:	c0 c8       	rjmp	80009694 <fat_entry_checkext+0x94>
   uint8_t u8_i, u8_filter_char, u8_entry_char;

   u8_ptr_entry = fat_get_ptr_entry();

   // Compare the extension with filter
   for( u8_i=0 ; u8_i<3 ; u8_i++)
8000967e:	2f fa       	sub	r10,-1
80009680:	5c 5a       	castu.b	r10
80009682:	ea 0a 18 00 	cp.b	r10,r5
80009686:	fe 98 ff cf 	brls	80009624 <fat_entry_checkext+0x24>
8000968a:	c0 38       	rjmp	80009690 <fat_entry_checkext+0x90>
8000968c:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80009690:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
            sz_filter++;
            u8_filter_char = *sz_filter;
         }
         u8_i = 0xFF;          // restart loop compare
      }
      sz_filter++; // go to next char of filter
80009694:	2f f7       	sub	r7,-1
80009696:	08 9a       	mov	r10,r4
80009698:	cc 7b       	rjmp	80009626 <fat_entry_checkext+0x26>
8000969a:	00 00       	add	r0,r0
8000969c:	80 00       	ld.sh	r0,r0[0x0]
8000969e:	93 04       	st.w	r9[0x0],r4

800096a0 <fat_entry_check>:
//!   fs_g_sector       The directory sector corresponding at the current position
//!   fs_g_nav_fast.u16_entry_pos_sel_file    Position in directory of the entry file (unit entry)
//! @endverbatim
//!
bool  fat_entry_check( bool b_type )
{
800096a0:	eb cd 40 80 	pushm	r7,lr
800096a4:	18 97       	mov	r7,r12
   PTR_CACHE u8_ptr_entry;
   uint8_t u8_first_byte, u8_seconde_byte;
   uint8_t u8_attribut;

   u8_ptr_entry = fat_get_ptr_entry();
800096a6:	f0 1f 00 14 	mcall	800096f4 <fat_entry_check+0x54>

   u8_first_byte = u8_ptr_entry[0];
800096aa:	19 88       	ld.ub	r8,r12[0x0]
   if ( FS_ENTRY_END == u8_first_byte )
800096ac:	58 08       	cp.w	r8,0
800096ae:	c0 61       	brne	800096ba <fat_entry_check+0x1a>
   {
      fs_g_status = FS_ERR_ENTRY_EMPTY;   // end of directory
800096b0:	30 a9       	mov	r9,10
800096b2:	49 28       	lddpc	r8,800096f8 <fat_entry_check+0x58>
800096b4:	b0 89       	st.b	r8[0x0],r9
800096b6:	30 07       	mov	r7,0
      return false;
800096b8:	c1 a8       	rjmp	800096ec <fat_entry_check+0x4c>
   }
   fs_g_status = FS_ERR_ENTRY_BAD;        // by default BAD ENTRY
800096ba:	30 ba       	mov	r10,11
800096bc:	48 f9       	lddpc	r9,800096f8 <fat_entry_check+0x58>
800096be:	b2 8a       	st.b	r9[0x0],r10
   if ( FS_ENTRY_DEL == u8_first_byte )      { return false;   } // entry deleted
800096c0:	3e 59       	mov	r9,-27
800096c2:	f2 08 18 00 	cp.b	r8,r9
800096c6:	c1 20       	breq	800096ea <fat_entry_check+0x4a>
   if (   '.'  == u8_first_byte )            { return false;   } // current dir "."
800096c8:	32 e9       	mov	r9,46
800096ca:	f2 08 18 00 	cp.b	r8,r9
800096ce:	c0 e0       	breq	800096ea <fat_entry_check+0x4a>
   if ( ('.'  == u8_first_byte)
   &&   ('.'  == u8_seconde_byte) )          { return false;   } // current dir ".."

   // Check Attribute
   u8_attribut = u8_ptr_entry[11];
   if ( FS_ATTR_VOLUME_ID & u8_attribut )    { return false;   } // volume id
800096d0:	f9 38 00 0b 	ld.ub	r8,r12[11]
800096d4:	10 99       	mov	r9,r8
800096d6:	e2 19 00 08 	andl	r9,0x8,COH
800096da:	c0 81       	brne	800096ea <fat_entry_check+0x4a>
   // Optimization, this line isn't necessary because the next test control this case
   // if ( FS_ATTR_LFN_ENTRY == *u8_ptr_entry) { return false;   } // long file name

   // Check entry type
   if( FS_ATTR_DIRECTORY & u8_attribut )
800096dc:	e2 18 00 10 	andl	r8,0x10,COH
800096e0:	c0 60       	breq	800096ec <fat_entry_check+0x4c>
   {
      return (FS_DIR == b_type);
800096e2:	ec 17 00 01 	eorl	r7,0x1
800096e6:	5c 57       	castu.b	r7
800096e8:	c0 28       	rjmp	800096ec <fat_entry_check+0x4c>
800096ea:	30 07       	mov	r7,0
   }else{
      return (FS_FILE == b_type);
   }
}
800096ec:	0e 9c       	mov	r12,r7
800096ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800096f2:	00 00       	add	r0,r0
800096f4:	80 00       	ld.sh	r0,r0[0x0]
800096f6:	93 04       	st.w	r9[0x0],r4
800096f8:	00 00       	add	r0,r0
800096fa:	0c 68       	and	r8,r6

800096fc <fat_cache_reset>:

//! This function resets the sector cache
//!
void  fat_cache_reset( void )
{
   fs_g_sectorcache.u8_lun                = FS_BUF_SECTOR_EMPTY;
800096fc:	48 58       	lddpc	r8,80009710 <fat_cache_reset+0x14>
800096fe:	3f f9       	mov	r9,-1
80009700:	b0 89       	st.b	r8[0x0],r9
   fs_g_sectorcache.u8_dirty              = false;
80009702:	30 09       	mov	r9,0
80009704:	f1 69 00 08 	st.b	r8[8],r9
   fs_g_sectorcache.u32_clusterlist_start = 0xFFFFFFFF;
80009708:	3f f9       	mov	r9,-1
8000970a:	91 39       	st.w	r8[0xc],r9
}
8000970c:	5e fc       	retal	r12
8000970e:	00 00       	add	r0,r0
80009710:	00 00       	add	r0,r0
80009712:	0c a0       	st.w	r6++,r0

80009714 <fat_cache_mark_sector_as_dirty>:

//! This function sets a flag to signal that sector cache is modified
//!
void  fat_cache_mark_sector_as_dirty( void )
{
   fs_g_sectorcache.u8_dirty = true;
80009714:	30 19       	mov	r9,1
80009716:	48 38       	lddpc	r8,80009720 <fat_cache_mark_sector_as_dirty+0xc>
80009718:	f1 69 00 08 	st.b	r8[8],r9
}
8000971c:	5e fc       	retal	r12
8000971e:	00 00       	add	r0,r0
80009720:	00 00       	add	r0,r0
80009722:	0c a0       	st.w	r6++,r0

80009724 <fat_write_entry_file>:
//! OUT:
//!   fs_g_sector    Updated
//! @endverbatim
//!
void  fat_write_entry_file( void )
{
80009724:	d4 01       	pushm	lr
   PTR_CACHE ptr_entry;

   fat_cache_mark_sector_as_dirty();
80009726:	f0 1f 00 11 	mcall	80009768 <fat_write_entry_file+0x44>
   ptr_entry = fat_get_ptr_entry();
8000972a:	f0 1f 00 11 	mcall	8000976c <fat_write_entry_file+0x48>
         fs_g_nav_entry.u32_cluster = 0;
   }

   //! Write the Attribute
   ptr_entry+= 11;
   ptr_entry[0] = fs_g_nav_entry.u8_attr;
8000972e:	49 18       	lddpc	r8,80009770 <fat_write_entry_file+0x4c>
80009730:	11 a9       	ld.ub	r9,r8[0x2]
80009732:	f9 69 00 0b 	st.b	r12[11],r9

   // Write the first cluster of file cluster list
   ptr_entry += (20-11);
80009736:	f8 ca ff ec 	sub	r10,r12,-20
   ptr_entry[0] = LSB2(fs_g_nav_entry.u32_cluster);
8000973a:	f0 c9 ff fc 	sub	r9,r8,-4
8000973e:	13 9b       	ld.ub	r11,r9[0x1]
80009740:	b4 8b       	st.b	r10[0x0],r11
   ptr_entry[1] = LSB3(fs_g_nav_entry.u32_cluster);
80009742:	13 8b       	ld.ub	r11,r9[0x0]
80009744:	b4 9b       	st.b	r10[0x1],r11
   ptr_entry += (26-20);
80009746:	f8 ca ff e6 	sub	r10,r12,-26
   ptr_entry[0] = LSB0(fs_g_nav_entry.u32_cluster);
8000974a:	13 bb       	ld.ub	r11,r9[0x3]
8000974c:	b4 8b       	st.b	r10[0x0],r11
   ptr_entry[1] = LSB1(fs_g_nav_entry.u32_cluster);
8000974e:	13 a9       	ld.ub	r9,r9[0x2]
80009750:	b4 99       	st.b	r10[0x1],r9

   //! Write the size of file
   ptr_entry += (28-26);
80009752:	2e 4c       	sub	r12,-28
   ptr_entry[0] = LSB0(fs_g_nav_entry.u32_size);
80009754:	2f 88       	sub	r8,-8
80009756:	11 b9       	ld.ub	r9,r8[0x3]
80009758:	b8 89       	st.b	r12[0x0],r9
   ptr_entry[1] = LSB1(fs_g_nav_entry.u32_size);
8000975a:	11 a9       	ld.ub	r9,r8[0x2]
8000975c:	b8 99       	st.b	r12[0x1],r9
   ptr_entry[2] = LSB2(fs_g_nav_entry.u32_size);
8000975e:	11 99       	ld.ub	r9,r8[0x1]
80009760:	b8 a9       	st.b	r12[0x2],r9
   ptr_entry[3] = LSB3(fs_g_nav_entry.u32_size);
80009762:	11 88       	ld.ub	r8,r8[0x0]
80009764:	b8 b8       	st.b	r12[0x3],r8
}
80009766:	d8 02       	popm	pc
80009768:	80 00       	ld.sh	r0,r0[0x0]
8000976a:	97 14       	st.w	r11[0x4],r4
8000976c:	80 00       	ld.sh	r0,r0[0x0]
8000976e:	93 04       	st.w	r9[0x0],r4
80009770:	00 00       	add	r0,r0
80009772:	09 d8       	ld.ub	r8,r4[0x5]

80009774 <fat_check_nav_access_file>:

   // For each navigators
   for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
   {
      // Disk mounted ?
      if( FS_TYPE_FAT_UNM != fs_g_navext_fast[i].u8_type_fat )
80009774:	49 88       	lddpc	r8,800097d4 <fat_check_nav_access_file+0x60>
80009776:	11 89       	ld.ub	r9,r8[0x0]
80009778:	30 08       	mov	r8,0
8000977a:	f0 09 18 00 	cp.b	r9,r8
8000977e:	c2 a0       	breq	800097d2 <fat_check_nav_access_file+0x5e>
      // Is it the same disk ?
      if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
80009780:	49 68       	lddpc	r8,800097d8 <fat_check_nav_access_file+0x64>
80009782:	11 89       	ld.ub	r9,r8[0x0]
80009784:	49 68       	lddpc	r8,800097dc <fat_check_nav_access_file+0x68>
80009786:	11 88       	ld.ub	r8,r8[0x0]
80009788:	f0 09 18 00 	cp.b	r9,r8
8000978c:	c2 31       	brne	800097d2 <fat_check_nav_access_file+0x5e>
#if (FS_MULTI_PARTITION == true)
      // Is it the same partition ?
      if( fs_g_nav.u8_partition == fs_g_navext[i].u8_partition )
#endif
      // Is it the same directory ?
      if( fs_g_nav.u32_cluster_sel_dir == fs_g_navext[i].u32_cluster_sel_dir )
8000978e:	49 38       	lddpc	r8,800097d8 <fat_check_nav_access_file+0x64>
80009790:	70 89       	ld.w	r9,r8[0x20]
80009792:	49 38       	lddpc	r8,800097dc <fat_check_nav_access_file+0x68>
80009794:	70 88       	ld.w	r8,r8[0x20]
80009796:	10 39       	cp.w	r9,r8
80009798:	c1 d1       	brne	800097d2 <fat_check_nav_access_file+0x5e>
      // Is it the same file ?
      if( fs_g_nav_fast.u16_entry_pos_sel_file == fs_g_navext_fast[i].u16_entry_pos_sel_file )
8000979a:	49 28       	lddpc	r8,800097e0 <fat_check_nav_access_file+0x6c>
8000979c:	90 19       	ld.sh	r9,r8[0x2]
8000979e:	48 e8       	lddpc	r8,800097d4 <fat_check_nav_access_file+0x60>
800097a0:	90 18       	ld.sh	r8,r8[0x2]
800097a2:	f0 09 19 00 	cp.h	r9,r8
800097a6:	c1 61       	brne	800097d2 <fat_check_nav_access_file+0x5e>
      {
         if( mode )
800097a8:	58 0c       	cp.w	r12,0
800097aa:	c0 b0       	breq	800097c0 <fat_check_nav_access_file+0x4c>
         {
            // Is it open ?
            if( fs_g_navext_entry[i].u8_open_mode!=0 )
800097ac:	48 e8       	lddpc	r8,800097e4 <fat_check_nav_access_file+0x70>
800097ae:	11 89       	ld.ub	r9,r8[0x0]
800097b0:	30 08       	mov	r8,0
800097b2:	f0 09 18 00 	cp.b	r9,r8
800097b6:	c0 e0       	breq	800097d2 <fat_check_nav_access_file+0x5e>
            {
               fs_g_status = FS_ERR_FILE_OPEN;
800097b8:	32 89       	mov	r9,40
800097ba:	48 c8       	lddpc	r8,800097e8 <fat_check_nav_access_file+0x74>
800097bc:	b0 89       	st.b	r8[0x0],r9
800097be:	5e fd       	retal	0
            }
         }
         else
         {
            // Is it open in write mode ?
            if( fs_g_navext_entry[i].u8_open_mode & FOPEN_WRITE_ACCESS )
800097c0:	48 98       	lddpc	r8,800097e4 <fat_check_nav_access_file+0x70>
800097c2:	11 88       	ld.ub	r8,r8[0x0]
800097c4:	e2 18 00 02 	andl	r8,0x2,COH
800097c8:	c0 50       	breq	800097d2 <fat_check_nav_access_file+0x5e>
            {
               fs_g_status = FS_ERR_FILE_OPEN_WR;
800097ca:	32 99       	mov	r9,41
800097cc:	48 78       	lddpc	r8,800097e8 <fat_check_nav_access_file+0x74>
800097ce:	b0 89       	st.b	r8[0x0],r9
800097d0:	5e fd       	retal	0
               return false;  // File opened in write mode then read access not possible
800097d2:	5e ff       	retal	1
800097d4:	00 00       	add	r0,r0
800097d6:	0c 60       	and	r0,r6
800097d8:	00 00       	add	r0,r0
800097da:	0c 18       	sub	r8,r6
800097dc:	00 00       	add	r0,r0
800097de:	0c 6c       	and	r12,r6
800097e0:	00 00       	add	r0,r0
800097e2:	0c 64       	and	r4,r6
800097e4:	00 00       	add	r0,r0
800097e6:	0c 50       	eor	r0,r6
800097e8:	00 00       	add	r0,r0
800097ea:	0c 68       	and	r8,r6

800097ec <fat_invert_nav>:
//! This function inverts the current navigation with another
//!
//! @param     u8_idnav    Id navigator to invert
//!
void  fat_invert_nav( uint8_t u8_idnav )
{
800097ec:	d4 21       	pushm	r4-r7,lr
800097ee:	20 dd       	sub	sp,52
   _MEM_TYPE_SLOW_ uint8_t Temp[Max(Max(sizeof(Fs_management),sizeof(Fs_management_entry)),sizeof(Fs_management_fast))];

   if( u8_idnav == 0 )
800097f0:	58 0c       	cp.w	r12,0
800097f2:	c5 a0       	breq	800098a6 <fat_invert_nav+0xba>
      return;
   u8_idnav--;

   memcpy_ram2ram(Temp,                              (uint8_t*)&fs_g_nav,                     sizeof(Fs_management));
800097f4:	1a 97       	mov	r7,sp
800097f6:	4a e8       	lddpc	r8,800098ac <fat_invert_nav+0xc0>
800097f8:	f0 ea 00 00 	ld.d	r10,r8[0]
800097fc:	fa eb 00 00 	st.d	sp[0],r10
80009800:	f0 ea 00 08 	ld.d	r10,r8[8]
80009804:	fa eb 00 08 	st.d	sp[8],r10
80009808:	f0 ea 00 10 	ld.d	r10,r8[16]
8000980c:	fa eb 00 10 	st.d	sp[16],r10
80009810:	f0 ea 00 18 	ld.d	r10,r8[24]
80009814:	fa eb 00 18 	st.d	sp[24],r10
80009818:	f0 ea 00 20 	ld.d	r10,r8[32]
8000981c:	fa eb 00 20 	st.d	sp[32],r10
80009820:	f0 ea 00 28 	ld.d	r10,r8[40]
80009824:	fa eb 00 28 	st.d	sp[40],r10
80009828:	70 c9       	ld.w	r9,r8[0x30]
8000982a:	50 c9       	stdsp	sp[0x30],r9
   memcpy_ram2ram((uint8_t*)&fs_g_nav,                    (uint8_t*)&fs_g_navext[u8_idnav],        sizeof(Fs_management));
8000982c:	f8 c6 00 01 	sub	r6,r12,1
80009830:	5c 56       	castu.b	r6
80009832:	ec 04 10 34 	mul	r4,r6,52
80009836:	49 f9       	lddpc	r9,800098b0 <fat_invert_nav+0xc4>
80009838:	12 04       	add	r4,r9
8000983a:	33 45       	mov	r5,52
8000983c:	0a 9a       	mov	r10,r5
8000983e:	08 9b       	mov	r11,r4
80009840:	10 9c       	mov	r12,r8
80009842:	f0 1f 00 1d 	mcall	800098b4 <fat_invert_nav+0xc8>
   memcpy_ram2ram((uint8_t*)&fs_g_navext[u8_idnav],       Temp,                               sizeof(Fs_management));
80009846:	0a 9a       	mov	r10,r5
80009848:	1a 9b       	mov	r11,sp
8000984a:	08 9c       	mov	r12,r4
8000984c:	f0 1f 00 1a 	mcall	800098b4 <fat_invert_nav+0xc8>

   memcpy_ram2ram(Temp,                              (uint8_t*)&fs_g_nav_entry,               sizeof(Fs_management_entry));
80009850:	49 ac       	lddpc	r12,800098b8 <fat_invert_nav+0xcc>
80009852:	f8 e8 00 00 	ld.d	r8,r12[0]
80009856:	fa e9 00 00 	st.d	sp[0],r8
8000985a:	f8 e8 00 08 	ld.d	r8,r12[8]
8000985e:	fa e9 00 08 	st.d	sp[8],r8
   memcpy_ram2ram((uint8_t*)&fs_g_nav_entry,              (uint8_t*)&fs_g_navext_entry[u8_idnav],  sizeof(Fs_management_entry));
80009862:	ec 04 15 04 	lsl	r4,r6,0x4
80009866:	49 68       	lddpc	r8,800098bc <fat_invert_nav+0xd0>
80009868:	10 04       	add	r4,r8
8000986a:	31 05       	mov	r5,16
8000986c:	0a 9a       	mov	r10,r5
8000986e:	08 9b       	mov	r11,r4
80009870:	f0 1f 00 11 	mcall	800098b4 <fat_invert_nav+0xc8>
   memcpy_ram2ram((uint8_t*)&fs_g_navext_entry[u8_idnav], Temp,                               sizeof(Fs_management_entry));
80009874:	0a 9a       	mov	r10,r5
80009876:	1a 9b       	mov	r11,sp
80009878:	08 9c       	mov	r12,r4
8000987a:	f0 1f 00 0f 	mcall	800098b4 <fat_invert_nav+0xc8>

   memcpy_ram2ram(Temp,                              (uint8_t*)&fs_g_nav_fast,                sizeof(Fs_management_fast));
8000987e:	49 14       	lddpc	r4,800098c0 <fat_invert_nav+0xd4>
80009880:	30 45       	mov	r5,4
80009882:	0a 9a       	mov	r10,r5
80009884:	08 9b       	mov	r11,r4
80009886:	1a 9c       	mov	r12,sp
80009888:	f0 1f 00 0b 	mcall	800098b4 <fat_invert_nav+0xc8>
   memcpy_ram2ram((uint8_t*)&fs_g_nav_fast,               (uint8_t*)&fs_g_navext_fast[u8_idnav],   sizeof(Fs_management_fast));
8000988c:	48 e8       	lddpc	r8,800098c4 <fat_invert_nav+0xd8>
8000988e:	f0 06 00 26 	add	r6,r8,r6<<0x2
80009892:	0a 9a       	mov	r10,r5
80009894:	0c 9b       	mov	r11,r6
80009896:	08 9c       	mov	r12,r4
80009898:	f0 1f 00 07 	mcall	800098b4 <fat_invert_nav+0xc8>
   memcpy_ram2ram((uint8_t*)&fs_g_navext_fast[u8_idnav],  Temp,                               sizeof(Fs_management_fast));
8000989c:	0a 9a       	mov	r10,r5
8000989e:	1a 9b       	mov	r11,sp
800098a0:	0c 9c       	mov	r12,r6
800098a2:	f0 1f 00 05 	mcall	800098b4 <fat_invert_nav+0xc8>
}
800098a6:	2f 3d       	sub	sp,-52
800098a8:	d8 22       	popm	r4-r7,pc
800098aa:	00 00       	add	r0,r0
800098ac:	00 00       	add	r0,r0
800098ae:	0c 18       	sub	r8,r6
800098b0:	00 00       	add	r0,r0
800098b2:	0c 6c       	and	r12,r6
800098b4:	80 00       	ld.sh	r0,r0[0x0]
800098b6:	c6 38       	rjmp	8000997c <fat_cache_read_sector+0x48>
800098b8:	00 00       	add	r0,r0
800098ba:	09 d8       	ld.ub	r8,r4[0x5]
800098bc:	00 00       	add	r0,r0
800098be:	0c 50       	eor	r0,r6
800098c0:	00 00       	add	r0,r0
800098c2:	0c 64       	and	r4,r6
800098c4:	00 00       	add	r0,r0
800098c6:	0c 60       	and	r0,r6

800098c8 <fat_cache_flush>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_cache_flush( void )
{
800098c8:	d4 01       	pushm	lr
   // If the cache is modified, then write the sector cache on the device
   if ( true == fs_g_sectorcache.u8_dirty )
800098ca:	49 08       	lddpc	r8,80009908 <fat_cache_flush+0x40>
800098cc:	f1 39 00 08 	ld.ub	r9,r8[8]
800098d0:	30 18       	mov	r8,1
800098d2:	f0 09 18 00 	cp.b	r9,r8
800098d6:	c1 81       	brne	80009906 <fat_cache_flush+0x3e>
   {
      fs_g_sectorcache.u8_dirty = false; // Always clear, although an error occur
800098d8:	48 c8       	lddpc	r8,80009908 <fat_cache_flush+0x40>
800098da:	30 09       	mov	r9,0
800098dc:	f1 69 00 08 	st.b	r8[8],r9
      if( mem_wr_protect( fs_g_sectorcache.u8_lun  ))
800098e0:	11 8c       	ld.ub	r12,r8[0x0]
800098e2:	f0 1f 00 0b 	mcall	8000990c <fat_cache_flush+0x44>
800098e6:	c0 50       	breq	800098f0 <fat_cache_flush+0x28>
      {
         fs_g_status = FS_LUN_WP;
800098e8:	31 49       	mov	r9,20
800098ea:	48 a8       	lddpc	r8,80009910 <fat_cache_flush+0x48>
800098ec:	b0 89       	st.b	r8[0x0],r9
800098ee:	d8 0a       	popm	pc,r12=0
         return false;
      }
      if (CTRL_GOOD != ram_2_memory( fs_g_sectorcache.u8_lun , fs_g_sectorcache.u32_addr , fs_g_sector ))
800098f0:	48 68       	lddpc	r8,80009908 <fat_cache_flush+0x40>
800098f2:	48 9a       	lddpc	r10,80009914 <fat_cache_flush+0x4c>
800098f4:	70 1b       	ld.w	r11,r8[0x4]
800098f6:	11 8c       	ld.ub	r12,r8[0x0]
800098f8:	f0 1f 00 08 	mcall	80009918 <fat_cache_flush+0x50>
800098fc:	c0 50       	breq	80009906 <fat_cache_flush+0x3e>
      {
         fs_g_status = FS_ERR_HW;
800098fe:	30 19       	mov	r9,1
80009900:	48 48       	lddpc	r8,80009910 <fat_cache_flush+0x48>
80009902:	b0 89       	st.b	r8[0x0],r9
80009904:	d8 0a       	popm	pc,r12=0
         return false;
80009906:	da 0a       	popm	pc,r12=1
80009908:	00 00       	add	r0,r0
8000990a:	0c a0       	st.w	r6++,r0
8000990c:	80 00       	ld.sh	r0,r0[0x0]
8000990e:	b3 64       	lsl	r4,0x12
80009910:	00 00       	add	r0,r0
80009912:	0c 68       	and	r8,r6
80009914:	00 00       	add	r0,r0
80009916:	0a 18       	sub	r8,r5
80009918:	80 00       	ld.sh	r0,r0[0x0]
8000991a:	b3 94       	lsr	r4,0x13

8000991c <fat_cache_clear>:

#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
//! This function clears the sector cache
//!
void  fat_cache_clear( void )
{
8000991c:	d4 01       	pushm	lr
   memset( fs_g_sector , 0 , FS_CACHE_SIZE );
8000991e:	e0 6a 02 00 	mov	r10,512
80009922:	30 0b       	mov	r11,0
80009924:	48 2c       	lddpc	r12,8000992c <fat_cache_clear+0x10>
80009926:	f0 1f 00 03 	mcall	80009930 <fat_cache_clear+0x14>
}
8000992a:	d8 02       	popm	pc
8000992c:	00 00       	add	r0,r0
8000992e:	0a 18       	sub	r8,r5
80009930:	80 00       	ld.sh	r0,r0[0x0]
80009932:	c7 80       	breq	80009a22 <fat_cluster_readnext+0x6e>

80009934 <fat_cache_read_sector>:
//!   fs_g_nav.u8_lun      drive number to read
//!   fs_gu32_addrsector   address to read (unit sector)
//! @endverbatim
//!
bool  fat_cache_read_sector( bool b_load )
{
80009934:	eb cd 40 80 	pushm	r7,lr
80009938:	18 97       	mov	r7,r12
   // Check if the sector asked is the same in cache
   if( (fs_g_sectorcache.u8_lun     == fs_g_nav.u8_lun )
8000993a:	49 78       	lddpc	r8,80009994 <fat_cache_read_sector+0x60>
8000993c:	11 89       	ld.ub	r9,r8[0x0]
8000993e:	49 78       	lddpc	r8,80009998 <fat_cache_read_sector+0x64>
80009940:	11 88       	ld.ub	r8,r8[0x0]
80009942:	f0 09 18 00 	cp.b	r9,r8
80009946:	c0 91       	brne	80009958 <fat_cache_read_sector+0x24>
80009948:	49 38       	lddpc	r8,80009994 <fat_cache_read_sector+0x60>
8000994a:	70 19       	ld.w	r9,r8[0x4]
8000994c:	49 48       	lddpc	r8,8000999c <fat_cache_read_sector+0x68>
8000994e:	70 08       	ld.w	r8,r8[0x0]
80009950:	10 39       	cp.w	r9,r8
80009952:	c0 31       	brne	80009958 <fat_cache_read_sector+0x24>
80009954:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
   {
      return true;
   }

   // Write previous cache before fill cache with a new sector
   if( !fat_cache_flush())
80009958:	f0 1f 00 12 	mcall	800099a0 <fat_cache_read_sector+0x6c>
8000995c:	c1 90       	breq	8000998e <fat_cache_read_sector+0x5a>
      return false;

   // Delete informations about the caches
   fat_cache_reset();
8000995e:	f0 1f 00 12 	mcall	800099a4 <fat_cache_read_sector+0x70>

   // Init sector cache
   fs_g_sectorcache.u32_addr = fs_gu32_addrsector;
80009962:	48 f8       	lddpc	r8,8000999c <fat_cache_read_sector+0x68>
80009964:	70 0b       	ld.w	r11,r8[0x0]
80009966:	48 c8       	lddpc	r8,80009994 <fat_cache_read_sector+0x60>
80009968:	91 1b       	st.w	r8[0x4],r11
   if( b_load )
8000996a:	58 07       	cp.w	r7,0
8000996c:	c0 c0       	breq	80009984 <fat_cache_read_sector+0x50>
   {
      // Load the sector from memory
      if( CTRL_GOOD != memory_2_ram( fs_g_nav.u8_lun  , fs_g_sectorcache.u32_addr, fs_g_sector))
8000996e:	48 fa       	lddpc	r10,800099a8 <fat_cache_read_sector+0x74>
80009970:	48 a8       	lddpc	r8,80009998 <fat_cache_read_sector+0x64>
80009972:	11 8c       	ld.ub	r12,r8[0x0]
80009974:	f0 1f 00 0e 	mcall	800099ac <fat_cache_read_sector+0x78>
80009978:	c0 60       	breq	80009984 <fat_cache_read_sector+0x50>
      {
         fs_g_status = FS_ERR_HW;
8000997a:	30 19       	mov	r9,1
8000997c:	48 d8       	lddpc	r8,800099b0 <fat_cache_read_sector+0x7c>
8000997e:	b0 89       	st.b	r8[0x0],r9
80009980:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
         return false;
      }
   }
   // Valid sector cache
   fs_g_sectorcache.u8_lun = fs_g_nav.u8_lun;
80009984:	48 58       	lddpc	r8,80009998 <fat_cache_read_sector+0x64>
80009986:	11 89       	ld.ub	r9,r8[0x0]
80009988:	48 38       	lddpc	r8,80009994 <fat_cache_read_sector+0x60>
8000998a:	b0 89       	st.b	r8[0x0],r9
8000998c:	30 1c       	mov	r12,1
   return true;
}
8000998e:	e3 cd 80 80 	ldm	sp++,r7,pc
80009992:	00 00       	add	r0,r0
80009994:	00 00       	add	r0,r0
80009996:	0c a0       	st.w	r6++,r0
80009998:	00 00       	add	r0,r0
8000999a:	0c 18       	sub	r8,r6
8000999c:	00 00       	add	r0,r0
8000999e:	09 d4       	ld.ub	r4,r4[0x5]
800099a0:	80 00       	ld.sh	r0,r0[0x0]
800099a2:	98 c8       	ld.uh	r8,r12[0x8]
800099a4:	80 00       	ld.sh	r0,r0[0x0]
800099a6:	96 fc       	ld.uh	r12,r11[0xe]
800099a8:	00 00       	add	r0,r0
800099aa:	0a 18       	sub	r8,r5
800099ac:	80 00       	ld.sh	r0,r0[0x0]
800099ae:	b3 78       	lsl	r8,0x13
800099b0:	00 00       	add	r0,r0
800099b2:	0c 68       	and	r8,r6

800099b4 <fat_cluster_readnext>:
//!   fs_g_u16_pos_fat        read cluster position in FAT
//!   fs_g_cluster.u32_val    value of cluster read
//! @endverbatim
//!
bool  fat_cluster_readnext( void )
{
800099b4:	d4 01       	pushm	lr
   // Compute the next cluster position in FAT
   if ( Is_fat32 )
800099b6:	49 f8       	lddpc	r8,80009a30 <fat_cluster_readnext+0x7c>
800099b8:	11 89       	ld.ub	r9,r8[0x0]
800099ba:	30 38       	mov	r8,3
800099bc:	f0 09 18 00 	cp.b	r9,r8
800099c0:	c0 61       	brne	800099cc <fat_cluster_readnext+0x18>
   {
      fs_g_u16_pos_fat += 4;
800099c2:	49 d8       	lddpc	r8,80009a34 <fat_cluster_readnext+0x80>
800099c4:	90 09       	ld.sh	r9,r8[0x0]
800099c6:	2f c9       	sub	r9,-4
800099c8:	b0 09       	st.h	r8[0x0],r9
800099ca:	c0 58       	rjmp	800099d4 <fat_cluster_readnext+0x20>
   }else{
      // Is_fat16
      fs_g_u16_pos_fat += 2;
800099cc:	49 a8       	lddpc	r8,80009a34 <fat_cluster_readnext+0x80>
800099ce:	90 09       	ld.sh	r9,r8[0x0]
800099d0:	2f e9       	sub	r9,-2
800099d2:	b0 09       	st.h	r8[0x0],r9
   }

   // Check if next cluster is in internal cache
   if( FS_CACHE_SIZE == fs_g_u16_pos_fat )
800099d4:	49 88       	lddpc	r8,80009a34 <fat_cluster_readnext+0x80>
800099d6:	90 09       	ld.sh	r9,r8[0x0]
800099d8:	e0 68 02 00 	mov	r8,512
800099dc:	f0 09 19 00 	cp.h	r9,r8
800099e0:	c0 c1       	brne	800099f8 <fat_cluster_readnext+0x44>
   {
      // Update cache
      fs_g_u16_pos_fat = 0;
800099e2:	30 09       	mov	r9,0
800099e4:	49 48       	lddpc	r8,80009a34 <fat_cluster_readnext+0x80>
800099e6:	b0 09       	st.h	r8[0x0],r9
      fs_gu32_addrsector++;
800099e8:	49 48       	lddpc	r8,80009a38 <fat_cluster_readnext+0x84>
800099ea:	70 09       	ld.w	r9,r8[0x0]
800099ec:	2f f9       	sub	r9,-1
800099ee:	91 09       	st.w	r8[0x0],r9
      if( !fat_cache_read_sector( true ))
800099f0:	30 1c       	mov	r12,1
800099f2:	f0 1f 00 13 	mcall	80009a3c <fat_cluster_readnext+0x88>
800099f6:	c1 b0       	breq	80009a2c <fat_cluster_readnext+0x78>
         return false;
   }

   //**** Read the cluster value
   LSB0( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+0];  // FAT 16,32
800099f8:	49 28       	lddpc	r8,80009a40 <fat_cluster_readnext+0x8c>
800099fa:	2f c8       	sub	r8,-4
800099fc:	48 e9       	lddpc	r9,80009a34 <fat_cluster_readnext+0x80>
800099fe:	92 89       	ld.uh	r9,r9[0x0]
80009a00:	49 1a       	lddpc	r10,80009a44 <fat_cluster_readnext+0x90>
80009a02:	f4 09 07 0b 	ld.ub	r11,r10[r9]
80009a06:	b0 bb       	st.b	r8[0x3],r11
   LSB1( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+1];  // FAT 16,32
80009a08:	12 0a       	add	r10,r9
80009a0a:	15 9a       	ld.ub	r10,r10[0x1]
80009a0c:	b0 aa       	st.b	r8[0x2],r10

   if ( Is_fat32 )
80009a0e:	48 9a       	lddpc	r10,80009a30 <fat_cluster_readnext+0x7c>
80009a10:	15 8b       	ld.ub	r11,r10[0x0]
80009a12:	30 3a       	mov	r10,3
80009a14:	f4 0b 18 00 	cp.b	r11,r10
80009a18:	c0 20       	breq	80009a1c <fat_cluster_readnext+0x68>
80009a1a:	da 0a       	popm	pc,r12=1
   {  // FAT 32
      LSB2( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+2];
80009a1c:	48 aa       	lddpc	r10,80009a44 <fat_cluster_readnext+0x90>
80009a1e:	f4 09 00 09 	add	r9,r10,r9
80009a22:	13 aa       	ld.ub	r10,r9[0x2]
80009a24:	b0 9a       	st.b	r8[0x1],r10
      LSB3( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+3];
80009a26:	13 b9       	ld.ub	r9,r9[0x3]
80009a28:	b0 89       	st.b	r8[0x0],r9
80009a2a:	30 1c       	mov	r12,1
   }
   return true;
}
80009a2c:	d8 02       	popm	pc
80009a2e:	00 00       	add	r0,r0
80009a30:	00 00       	add	r0,r0
80009a32:	0c 64       	and	r4,r6
80009a34:	00 00       	add	r0,r0
80009a36:	09 e8       	ld.ub	r8,r4[0x6]
80009a38:	00 00       	add	r0,r0
80009a3a:	09 d4       	ld.ub	r4,r4[0x5]
80009a3c:	80 00       	ld.sh	r0,r0[0x0]
80009a3e:	99 34       	st.w	r12[0xc],r4
80009a40:	00 00       	add	r0,r0
80009a42:	0c b8       	st.h	r6++,r8
80009a44:	00 00       	add	r0,r0
80009a46:	0a 18       	sub	r8,r5

80009a48 <fat_cluster_val>:
//!   fs_g_u16_pos_fat        position in FAT of the cluster to read or write
//!                           value init in case of the fat_cluster_readnext() routine is used after
//! @endverbatim
//!
bool  fat_cluster_val( bool b_mode )
{
80009a48:	d4 31       	pushm	r0-r7,lr
80009a4a:	18 95       	mov	r5,r12
   _MEM_TYPE_FAST_ uint32_t   u32_offset_fat =0;
   _MEM_TYPE_FAST_ uint8_t    u8_data1, u8_data2,u8_data3,u8_data4;
   _MEM_TYPE_FAST_ PTR_CACHE u8_ptr_cluster;

   //**** Compute the cluster position in FAT (sector address & position in sector)
   if ( Is_fat32 )
80009a4c:	fe f8 02 18 	ld.w	r8,pc[536]
80009a50:	11 88       	ld.ub	r8,r8[0x0]
80009a52:	30 39       	mov	r9,3
80009a54:	f2 08 18 00 	cp.b	r8,r9
80009a58:	c0 d1       	brne	80009a72 <fat_cluster_val+0x2a>
   {
      // FAT 32
      // Optimization of -> u32_offset_fat = fs_g_cluster.pos * 4 / FS_CACHE_SIZE;
      // Optimization of -> u32_offset_fat = fs_g_cluster.pos / 128
      u32_offset_fat = fs_g_cluster.u32_pos >> (8-1);
80009a5a:	fe fa 02 0e 	ld.w	r10,pc[526]
80009a5e:	74 09       	ld.w	r9,r10[0x0]
80009a60:	a7 99       	lsr	r9,0x7

      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos * 4) % FS_CACHE_SIZE;
      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos % 128) * 4
      fs_g_u16_pos_fat = ((uint16_t)(LSB0(fs_g_cluster.u32_pos) & 0x7F))<< 2;
80009a62:	15 bb       	ld.ub	r11,r10[0x3]
80009a64:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
80009a68:	a3 6b       	lsl	r11,0x2
80009a6a:	fe fa 02 02 	ld.w	r10,pc[514]
80009a6e:	b4 0b       	st.h	r10[0x0],r11
80009a70:	c2 08       	rjmp	80009ab0 <fat_cluster_val+0x68>
   }
   else if ( Is_fat16 )
80009a72:	30 29       	mov	r9,2
80009a74:	f2 08 18 00 	cp.b	r8,r9
80009a78:	c0 81       	brne	80009a88 <fat_cluster_val+0x40>
   {
      // FAT 16
      // Optimization of -> u32_offset_fat = fs_g_cluster.u32_pos * 2 / FS_CACHE_SIZE = fs_g_cluster.u32_pos / 256;
      u32_offset_fat = LSB1(fs_g_cluster.u32_pos);
80009a7a:	4f ca       	lddpc	r10,80009c68 <fat_cluster_val+0x220>
80009a7c:	15 a9       	ld.ub	r9,r10[0x2]
      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos * 2) % FS_CACHE_SIZE;
      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos % 256) * 2
      fs_g_u16_pos_fat = ((uint16_t)LSB0(fs_g_cluster.u32_pos)) <<1;
80009a7e:	15 bb       	ld.ub	r11,r10[0x3]
80009a80:	a1 7b       	lsl	r11,0x1
80009a82:	4f ba       	lddpc	r10,80009c6c <fat_cluster_val+0x224>
80009a84:	b4 0b       	st.h	r10[0x0],r11
80009a86:	c1 58       	rjmp	80009ab0 <fat_cluster_val+0x68>
   }
   else if ( Is_fat12 )
80009a88:	30 19       	mov	r9,1
80009a8a:	f2 08 18 00 	cp.b	r8,r9
80009a8e:	c0 30       	breq	80009a94 <fat_cluster_val+0x4c>
80009a90:	30 09       	mov	r9,0
80009a92:	c0 f8       	rjmp	80009ab0 <fat_cluster_val+0x68>
   {
      // FAT 12
      // Optimization of -> fs_g_u16_pos_fat = fs_g_cluster.u32_pos + (fs_g_cluster.u32_pos/ 2)
      fs_g_u16_pos_fat = (uint16_t)fs_g_cluster.u32_pos + ((uint16_t)fs_g_cluster.u32_pos >>1);
80009a94:	4f 59       	lddpc	r9,80009c68 <fat_cluster_val+0x220>
80009a96:	72 09       	ld.w	r9,r9[0x0]
80009a98:	4f 5a       	lddpc	r10,80009c6c <fat_cluster_val+0x224>
80009a9a:	f7 d9 c0 2f 	bfextu	r11,r9,0x1,0xf
80009a9e:	12 0b       	add	r11,r9
80009aa0:	b4 0b       	st.h	r10[0x0],r11
      // Optimization of -> u32_offset_fat = fs_g_cluster.u32_pos / FS_CACHE_SIZE
      u32_offset_fat = MSB(fs_g_u16_pos_fat) >> 1;
80009aa2:	f7 db c1 08 	bfextu	r11,r11,0x8,0x8
80009aa6:	f6 09 16 01 	lsr	r9,r11,0x1
      // Optimization of -> fs_g_u16_pos_fat = fs_g_u16_pos_fat % FS_CACHE_SIZE
      MSB( fs_g_u16_pos_fat ) &= 0x01;
80009aaa:	f7 db c0 01 	bfextu	r11,r11,0x0,0x1
80009aae:	b4 8b       	st.b	r10[0x0],r11
   }

#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
   if (b_mode)
80009ab0:	58 05       	cp.w	r5,0
80009ab2:	c2 20       	breq	80009af6 <fat_cluster_val+0xae>
   {
      // Update information about FAT modification
      if( fs_g_u32_first_mod_fat > u32_offset_fat )
80009ab4:	4e fa       	lddpc	r10,80009c70 <fat_cluster_val+0x228>
80009ab6:	74 0a       	ld.w	r10,r10[0x0]
80009ab8:	14 39       	cp.w	r9,r10
80009aba:	c0 32       	brcc	80009ac0 <fat_cluster_val+0x78>
      {
         fs_g_u32_first_mod_fat = u32_offset_fat;
80009abc:	4e da       	lddpc	r10,80009c70 <fat_cluster_val+0x228>
80009abe:	95 09       	st.w	r10[0x0],r9
      }
      if( fs_g_u32_last_mod_fat < u32_offset_fat )
80009ac0:	4e da       	lddpc	r10,80009c74 <fat_cluster_val+0x22c>
80009ac2:	74 0a       	ld.w	r10,r10[0x0]
80009ac4:	14 39       	cp.w	r9,r10
80009ac6:	e0 88 00 04 	brls	80009ace <fat_cluster_val+0x86>
      {
         fs_g_u32_last_mod_fat = u32_offset_fat;
80009aca:	4e ba       	lddpc	r10,80009c74 <fat_cluster_val+0x22c>
80009acc:	95 09       	st.w	r10[0x0],r9
      }
      if ( Is_fat12 )
80009ace:	30 1a       	mov	r10,1
80009ad0:	f4 08 18 00 	cp.b	r8,r10
80009ad4:	c1 11       	brne	80009af6 <fat_cluster_val+0xae>
      {  // A cluster may be stored on two sectors
         if( fs_g_u16_pos_fat == (FS_CACHE_SIZE-1) )
80009ad6:	4e 68       	lddpc	r8,80009c6c <fat_cluster_val+0x224>
80009ad8:	90 0a       	ld.sh	r10,r8[0x0]
80009ada:	e0 68 01 ff 	mov	r8,511
80009ade:	f0 0a 19 00 	cp.h	r10,r8
80009ae2:	c0 a1       	brne	80009af6 <fat_cluster_val+0xae>
         {  // Count the next FAT sector
            if( fs_g_u32_last_mod_fat < (u32_offset_fat+1) )
80009ae4:	f2 c8 ff ff 	sub	r8,r9,-1
80009ae8:	4e 3a       	lddpc	r10,80009c74 <fat_cluster_val+0x22c>
80009aea:	74 0a       	ld.w	r10,r10[0x0]
80009aec:	14 38       	cp.w	r8,r10
80009aee:	e0 88 00 04 	brls	80009af6 <fat_cluster_val+0xae>
            {
               fs_g_u32_last_mod_fat = (u32_offset_fat+1);
80009af2:	4e 1a       	lddpc	r10,80009c74 <fat_cluster_val+0x22c>
80009af4:	95 08       	st.w	r10[0x0],r8
      }
   }
#endif  // FS_LEVEL_FEATURES

   //**** Read cluster sector in FAT
   fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + u32_offset_fat;   // Computed logical sector address
80009af6:	4e 18       	lddpc	r8,80009c78 <fat_cluster_val+0x230>
80009af8:	70 48       	ld.w	r8,r8[0x10]
80009afa:	10 09       	add	r9,r8
80009afc:	4e 08       	lddpc	r8,80009c7c <fat_cluster_val+0x234>
80009afe:	91 09       	st.w	r8[0x0],r9
   if( !fat_cache_read_sector( true ))
80009b00:	30 1c       	mov	r12,1
80009b02:	f0 1f 00 60 	mcall	80009c80 <fat_cluster_val+0x238>
80009b06:	e0 80 00 ad 	breq	80009c60 <fat_cluster_val+0x218>
      return false;

   // Read cluster information
   u8_ptr_cluster = &fs_g_sector[fs_g_u16_pos_fat];
80009b0a:	4d 98       	lddpc	r8,80009c6c <fat_cluster_val+0x224>
80009b0c:	90 08       	ld.sh	r8,r8[0x0]
80009b0e:	ed d8 c0 10 	bfextu	r6,r8,0x0,0x10
80009b12:	4d d9       	lddpc	r9,80009c84 <fat_cluster_val+0x23c>
80009b14:	12 06       	add	r6,r9
   u8_data1 = u8_ptr_cluster[0];
80009b16:	0c 97       	mov	r7,r6
80009b18:	0f 32       	ld.ub	r2,r7++
   // Remark: if (fs_g_u16_pos_fat+1)=512 then it isn't a mistake, because this value will be erase in next lines
   u8_data2 = u8_ptr_cluster[1];
80009b1a:	0f 8b       	ld.ub	r11,r7[0x0]
   u8_data3 = u8_ptr_cluster[2];
80009b1c:	ec c4 ff fe 	sub	r4,r6,-2
80009b20:	09 81       	ld.ub	r1,r4[0x0]
   u8_data4 = u8_ptr_cluster[3];
80009b22:	ec c3 ff fd 	sub	r3,r6,-3
80009b26:	07 80       	ld.ub	r0,r3[0x0]

   if ( Is_fat12 )
80009b28:	4c f9       	lddpc	r9,80009c64 <fat_cluster_val+0x21c>
80009b2a:	13 8a       	ld.ub	r10,r9[0x0]
80009b2c:	30 19       	mov	r9,1
80009b2e:	f2 0a 18 00 	cp.b	r10,r9
80009b32:	c1 11       	brne	80009b54 <fat_cluster_val+0x10c>
   {   // A cluster may be stored on two sectors
      if(  fs_g_u16_pos_fat == (FS_CACHE_SIZE-1) )
80009b34:	e0 69 01 ff 	mov	r9,511
80009b38:	f2 08 19 00 	cp.h	r8,r9
80009b3c:	c0 c1       	brne	80009b54 <fat_cluster_val+0x10c>
      {  // Go to next sector
         fs_gu32_addrsector++;
80009b3e:	4d 08       	lddpc	r8,80009c7c <fat_cluster_val+0x234>
80009b40:	70 09       	ld.w	r9,r8[0x0]
80009b42:	2f f9       	sub	r9,-1
80009b44:	91 09       	st.w	r8[0x0],r9
         if( !fat_cache_read_sector( true ))
80009b46:	30 1c       	mov	r12,1
80009b48:	f0 1f 00 4e 	mcall	80009c80 <fat_cluster_val+0x238>
80009b4c:	e0 80 00 8a 	breq	80009c60 <fat_cluster_val+0x218>
           return false;
         u8_data2 = fs_g_sector[0];
80009b50:	4c d8       	lddpc	r8,80009c84 <fat_cluster_val+0x23c>
80009b52:	11 8b       	ld.ub	r11,r8[0x0]
      }
   }

   if (false == b_mode)
80009b54:	58 05       	cp.w	r5,0
80009b56:	c3 11       	brne	80009bb8 <fat_cluster_val+0x170>
   {
      //**** Read the cluster value
      LSB0( fs_g_cluster.u32_val ) = u8_data1;  // FAT 12,16,32
80009b58:	4c 48       	lddpc	r8,80009c68 <fat_cluster_val+0x220>
80009b5a:	f0 c9 ff fc 	sub	r9,r8,-4
80009b5e:	f0 cc ff f9 	sub	r12,r8,-7
80009b62:	b8 82       	st.b	r12[0x0],r2
      LSB1( fs_g_cluster.u32_val ) = u8_data2;  // FAT 12,16,32
80009b64:	2f a8       	sub	r8,-6
80009b66:	b0 8b       	st.b	r8[0x0],r11

      if ( Is_fat32 )
80009b68:	4b fa       	lddpc	r10,80009c64 <fat_cluster_val+0x21c>
80009b6a:	15 8a       	ld.ub	r10,r10[0x0]
80009b6c:	30 3b       	mov	r11,3
80009b6e:	f6 0a 18 00 	cp.b	r10,r11
80009b72:	c0 61       	brne	80009b7e <fat_cluster_val+0x136>
      {  // FAT 32
         LSB2( fs_g_cluster.u32_val ) = u8_data3;
80009b74:	b2 91       	st.b	r9[0x1],r1
         LSB3( fs_g_cluster.u32_val ) = u8_data4 & 0x0F; // The high 4 bits are reserved
80009b76:	e1 d0 c0 04 	bfextu	r0,r0,0x0,0x4
80009b7a:	b2 80       	st.b	r9[0x0],r0
80009b7c:	da 3a       	popm	r0-r7,pc,r12=1
      }
      else
      {  // FAT 12 & 16 don't use the high bytes
         LSB2( fs_g_cluster.u32_val ) = 0;
80009b7e:	30 0b       	mov	r11,0
80009b80:	b2 9b       	st.b	r9[0x1],r11
         LSB3( fs_g_cluster.u32_val ) = 0;
80009b82:	b2 8b       	st.b	r9[0x0],r11

         // FAT 12 translate 16bits value to 12bits
         if ( Is_fat12 )
80009b84:	30 19       	mov	r9,1
80009b86:	f2 0a 18 00 	cp.b	r10,r9
80009b8a:	c0 20       	breq	80009b8e <fat_cluster_val+0x146>
80009b8c:	da 3a       	popm	r0-r7,pc,r12=1
         {
            if ( 0x01 & LSB0(fs_g_cluster.u32_pos) )
80009b8e:	4b 79       	lddpc	r9,80009c68 <fat_cluster_val+0x220>
80009b90:	13 b9       	ld.ub	r9,r9[0x3]
80009b92:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80009b96:	c0 c0       	breq	80009bae <fat_cluster_val+0x166>
            {  // Read cluster is ODD
               LSB0( fs_g_cluster.u32_val ) = (LSB1( fs_g_cluster.u32_val ) <<4 ) + (LSB0( fs_g_cluster.u32_val ) >>4 );
80009b98:	19 8b       	ld.ub	r11,r12[0x0]
80009b9a:	a5 8b       	lsr	r11,0x4
80009b9c:	11 89       	ld.ub	r9,r8[0x0]
80009b9e:	f2 0a 15 04 	lsl	r10,r9,0x4
80009ba2:	f6 0a 00 0a 	add	r10,r11,r10
80009ba6:	b8 8a       	st.b	r12[0x0],r10
               LSB1( fs_g_cluster.u32_val ) =  LSB1( fs_g_cluster.u32_val ) >>4 ;
80009ba8:	a5 89       	lsr	r9,0x4
80009baa:	b0 89       	st.b	r8[0x0],r9
80009bac:	da 3a       	popm	r0-r7,pc,r12=1
            }
            else
            {  // Read cluster is EVEN
               LSB1( fs_g_cluster.u32_val ) &= 0x0F;
80009bae:	11 89       	ld.ub	r9,r8[0x0]
80009bb0:	f3 d9 c0 04 	bfextu	r9,r9,0x0,0x4
80009bb4:	b0 89       	st.b	r8[0x0],r9
80009bb6:	da 3a       	popm	r0-r7,pc,r12=1
         }
      }
   } else {
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
      //**** Write the cluster value
      if ( Is_fat12 )
80009bb8:	4a b8       	lddpc	r8,80009c64 <fat_cluster_val+0x21c>
80009bba:	11 88       	ld.ub	r8,r8[0x0]
80009bbc:	30 19       	mov	r9,1
80009bbe:	f2 08 18 00 	cp.b	r8,r9
80009bc2:	c3 a1       	brne	80009c36 <fat_cluster_val+0x1ee>
      {
         // FAT 12, translate cluster value
         if ( 0x01 & LSB0(fs_g_cluster.u32_pos) )
80009bc4:	4a 98       	lddpc	r8,80009c68 <fat_cluster_val+0x220>
80009bc6:	11 b8       	ld.ub	r8,r8[0x3]
80009bc8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80009bcc:	c1 10       	breq	80009bee <fat_cluster_val+0x1a6>
         {  // Cluster writing is ODD
            u8_data1 = (u8_data1 & 0x0F) + (LSB0( fs_g_cluster.u32_val )<<4);
80009bce:	eb d2 c0 04 	bfextu	r5,r2,0x0,0x4
80009bd2:	4a 68       	lddpc	r8,80009c68 <fat_cluster_val+0x220>
80009bd4:	2f c8       	sub	r8,-4
80009bd6:	11 b9       	ld.ub	r9,r8[0x3]
80009bd8:	f2 0a 15 04 	lsl	r10,r9,0x4
80009bdc:	14 05       	add	r5,r10
80009bde:	5c 55       	castu.b	r5
            u8_data2 = (LSB1( fs_g_cluster.u32_val )<<4) + (LSB0( fs_g_cluster.u32_val )>>4) ;
80009be0:	a5 89       	lsr	r9,0x4
80009be2:	11 a8       	ld.ub	r8,r8[0x2]
80009be4:	a5 68       	lsl	r8,0x4
80009be6:	f2 08 00 0a 	add	r10,r9,r8
80009bea:	5c 5a       	castu.b	r10
80009bec:	c0 c8       	rjmp	80009c04 <fat_cluster_val+0x1bc>
         } else {
            // Cluster writing is EVEN
            u8_data1 = LSB0( fs_g_cluster.u32_val );
80009bee:	49 f8       	lddpc	r8,80009c68 <fat_cluster_val+0x220>
80009bf0:	2f c8       	sub	r8,-4
80009bf2:	11 b5       	ld.ub	r5,r8[0x3]
            u8_data2 = (u8_data2 & 0xF0) + (LSB1( fs_g_cluster.u32_val ) & 0x0F) ;
80009bf4:	16 9a       	mov	r10,r11
80009bf6:	e2 1a 00 f0 	andl	r10,0xf0,COH
80009bfa:	11 a8       	ld.ub	r8,r8[0x2]
80009bfc:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009c00:	10 0a       	add	r10,r8
80009c02:	5c 5a       	castu.b	r10
         }

         // A cluster may be stored on two sectors
         if( fs_g_u16_pos_fat == (FS_CACHE_SIZE-1) )
80009c04:	49 a8       	lddpc	r8,80009c6c <fat_cluster_val+0x224>
80009c06:	90 09       	ld.sh	r9,r8[0x0]
80009c08:	e0 68 01 ff 	mov	r8,511
80009c0c:	f0 09 19 00 	cp.h	r9,r8
80009c10:	c2 31       	brne	80009c56 <fat_cluster_val+0x20e>
         {
            fs_g_sector[0] = u8_data2;
80009c12:	49 d8       	lddpc	r8,80009c84 <fat_cluster_val+0x23c>
80009c14:	b0 8a       	st.b	r8[0x0],r10
            fat_cache_mark_sector_as_dirty();
80009c16:	f0 1f 00 1d 	mcall	80009c88 <fat_cluster_val+0x240>
            // Go to previous sector
            fs_gu32_addrsector--;
80009c1a:	49 98       	lddpc	r8,80009c7c <fat_cluster_val+0x234>
80009c1c:	70 09       	ld.w	r9,r8[0x0]
80009c1e:	20 19       	sub	r9,1
80009c20:	91 09       	st.w	r8[0x0],r9
            if( !fat_cache_read_sector( true ))
80009c22:	30 1c       	mov	r12,1
80009c24:	f0 1f 00 17 	mcall	80009c80 <fat_cluster_val+0x238>
80009c28:	c1 c0       	breq	80009c60 <fat_cluster_val+0x218>
              return false;
            // Modify the previous sector
            fs_g_sector[ FS_CACHE_SIZE-1 ] = u8_data1;
80009c2a:	49 78       	lddpc	r8,80009c84 <fat_cluster_val+0x23c>
80009c2c:	f1 65 01 ff 	st.b	r8[511],r5
            fat_cache_mark_sector_as_dirty();
80009c30:	f0 1f 00 16 	mcall	80009c88 <fat_cluster_val+0x240>
80009c34:	da 3a       	popm	r0-r7,pc,r12=1
         }
      }
      else
      {
         // FAT 16 & 32
         u8_data1 = LSB0( fs_g_cluster.u32_val );
80009c36:	48 d9       	lddpc	r9,80009c68 <fat_cluster_val+0x220>
80009c38:	2f c9       	sub	r9,-4
80009c3a:	13 b5       	ld.ub	r5,r9[0x3]
         u8_data2 = LSB1( fs_g_cluster.u32_val );
80009c3c:	13 aa       	ld.ub	r10,r9[0x2]
         if ( Is_fat32 )
80009c3e:	30 3b       	mov	r11,3
80009c40:	f6 08 18 00 	cp.b	r8,r11
80009c44:	c0 91       	brne	80009c56 <fat_cluster_val+0x20e>
         {  // FAT 32
            u8_ptr_cluster[2] = LSB2( fs_g_cluster.u32_val );
80009c46:	13 98       	ld.ub	r8,r9[0x1]
80009c48:	a8 88       	st.b	r4[0x0],r8
            u8_ptr_cluster[3] = LSB3( fs_g_cluster.u32_val ) + (u8_data4 & 0xF0); // The high 4 bits are reserved
80009c4a:	e0 10 ff f0 	andl	r0,0xfff0
80009c4e:	13 88       	ld.ub	r8,r9[0x0]
80009c50:	f0 00 00 00 	add	r0,r8,r0
80009c54:	a6 80       	st.b	r3[0x0],r0
         }
      }
      // Here for FAT 32, 16 & 12 (only if the cluster values are in the same sector)
      u8_ptr_cluster[0] = u8_data1;
80009c56:	ac 85       	st.b	r6[0x0],r5
      u8_ptr_cluster[1] = u8_data2;
80009c58:	ae 8a       	st.b	r7[0x0],r10
      fat_cache_mark_sector_as_dirty();
80009c5a:	f0 1f 00 0c 	mcall	80009c88 <fat_cluster_val+0x240>
80009c5e:	da 3a       	popm	r0-r7,pc,r12=1
80009c60:	d8 3a       	popm	r0-r7,pc,r12=0
80009c62:	00 00       	add	r0,r0
80009c64:	00 00       	add	r0,r0
80009c66:	0c 64       	and	r4,r6
80009c68:	00 00       	add	r0,r0
80009c6a:	0c b8       	st.h	r6++,r8
80009c6c:	00 00       	add	r0,r0
80009c6e:	09 e8       	ld.ub	r8,r4[0x6]
80009c70:	00 00       	add	r0,r0
80009c72:	0c 4c       	or	r12,r6
80009c74:	00 00       	add	r0,r0
80009c76:	0a 14       	sub	r4,r5
80009c78:	00 00       	add	r0,r0
80009c7a:	0c 18       	sub	r8,r6
80009c7c:	00 00       	add	r0,r0
80009c7e:	09 d4       	ld.ub	r4,r4[0x5]
80009c80:	80 00       	ld.sh	r0,r0[0x0]
80009c82:	99 34       	st.w	r12[0xc],r4
80009c84:	00 00       	add	r0,r0
80009c86:	0a 18       	sub	r8,r5
80009c88:	80 00       	ld.sh	r0,r0[0x0]
80009c8a:	97 14       	st.w	r11[0x4],r4

80009c8c <fat_cluster_list>:
//!   fs_g_seg.u32_addr          The memory segment address corresponding at the beginning of cluster list (only for action FS_CLUST_ACT_SEG & FS_CLUST_ACT_ONE)
//!   fs_g_seg.u32_size_or_pos   The memory segment size corresponding at cluster list read or cleared (unit 512B)
//! @endverbatim
//!
bool  fat_cluster_list( uint8_t opt_action, bool b_for_file )
{
80009c8c:	d4 31       	pushm	r0-r7,lr
80009c8e:	20 2d       	sub	sp,8
80009c90:	18 93       	mov	r3,r12
80009c92:	16 97       	mov	r7,r11
   _MEM_TYPE_FAST_ uint32_t u32_tmp;
   _MEM_TYPE_FAST_ uint8_t u8_cluster_status;

   fs_g_status = FS_ERR_FS;      // By default system error
80009c94:	30 89       	mov	r9,8
80009c96:	fe f8 02 86 	ld.w	r8,pc[646]
80009c9a:	b0 89       	st.b	r8[0x0],r9

   if(  Is_fat32
   &&  (FS_CLUST_ACT_CLR == opt_action) )
80009c9c:	30 38       	mov	r8,3
80009c9e:	f0 0c 18 00 	cp.b	r12,r8
80009ca2:	5f 0a       	sreq	r10
80009ca4:	50 0a       	stdsp	sp[0x0],r10
   _MEM_TYPE_FAST_ uint32_t u32_tmp;
   _MEM_TYPE_FAST_ uint8_t u8_cluster_status;

   fs_g_status = FS_ERR_FS;      // By default system error

   if(  Is_fat32
80009ca6:	fe f9 02 7a 	ld.w	r9,pc[634]
80009caa:	13 89       	ld.ub	r9,r9[0x0]
80009cac:	f0 09 18 00 	cp.b	r9,r8
80009cb0:	5f 08       	sreq	r8
80009cb2:	f5 e8 00 08 	and	r8,r10,r8
80009cb6:	c0 60       	breq	80009cc2 <fat_cluster_list+0x36>
   &&  (FS_CLUST_ACT_CLR == opt_action) )
   {
#if (FSFEATURE_WRITE_COMPLET == (FS_LEVEL_FEATURES & FSFEATURE_WRITE_COMPLET) )
      // Clear free space information storage in FAT32
      if( !fat_write_fat32_FSInfo( 0xFFFFFFFF ))
80009cb8:	3f fc       	mov	r12,-1
80009cba:	f0 1f 00 9b 	mcall	80009f24 <fat_cluster_list+0x298>
80009cbe:	e0 80 01 2c 	breq	80009f16 <fat_cluster_list+0x28a>
#else
      return false;
#endif
   }

   if ( 0 == fs_g_seg.u32_addr )
80009cc2:	fe f8 02 66 	ld.w	r8,pc[614]
80009cc6:	70 08       	ld.w	r8,r8[0x0]
80009cc8:	58 08       	cp.w	r8,0
80009cca:	c3 81       	brne	80009d3a <fat_cluster_list+0xae>
   {
      // Cluster list of root directory
      if( FS_CLUST_ACT_CLR == opt_action )
80009ccc:	40 09       	lddsp	r9,sp[0x0]
80009cce:	58 09       	cp.w	r9,0
80009cd0:	e0 81 01 23 	brne	80009f16 <fat_cluster_list+0x28a>
         return false;           // Impossible to erase ROOT DIR

      if ( Is_fat12 || Is_fat16 )
80009cd4:	fe f8 02 4c 	ld.w	r8,pc[588]
80009cd8:	11 88       	ld.ub	r8,r8[0x0]
80009cda:	f0 ca 00 01 	sub	r10,r8,1
80009cde:	30 19       	mov	r9,1
80009ce0:	f2 0a 18 00 	cp.b	r10,r9
80009ce4:	e0 8b 00 22 	brhi	80009d28 <fat_cluster_list+0x9c>
      {
         // For a FAT 12 & 16, the root dir isn't a cluster list
         // Check the position
         if ( fs_g_seg.u32_size_or_pos < fs_g_nav.rootdir.seg.u16_size )
80009ce8:	fe f8 02 40 	ld.w	r8,pc[576]
80009cec:	70 18       	ld.w	r8,r8[0x4]
80009cee:	fe f9 02 3e 	ld.w	r9,pc[574]
80009cf2:	f3 19 00 1a 	ld.uh	r9,r9[26]
80009cf6:	12 38       	cp.w	r8,r9
80009cf8:	c1 32       	brcc	80009d1e <fat_cluster_list+0x92>
         {
            // Compute the start address and the size
            fs_g_seg.u32_addr = fs_g_nav.u32_ptr_fat + fs_g_nav.rootdir.seg.u16_pos + fs_g_seg.u32_size_or_pos;
80009cfa:	fe f9 02 2e 	ld.w	r9,pc[558]
80009cfe:	fe fa 02 2e 	ld.w	r10,pc[558]
80009d02:	74 4b       	ld.w	r11,r10[0x10]
80009d04:	16 08       	add	r8,r11
80009d06:	f5 1b 00 18 	ld.uh	r11,r10[24]
80009d0a:	16 08       	add	r8,r11
80009d0c:	93 08       	st.w	r9[0x0],r8
            fs_g_seg.u32_size_or_pos = fs_g_nav.rootdir.seg.u16_size - fs_g_seg.u32_size_or_pos;
80009d0e:	f5 1a 00 1a 	ld.uh	r10,r10[26]
80009d12:	72 18       	ld.w	r8,r9[0x4]
80009d14:	f4 08 01 08 	sub	r8,r10,r8
80009d18:	93 18       	st.w	r9[0x4],r8
80009d1a:	30 1c       	mov	r12,1
            return true;
80009d1c:	cf e8       	rjmp	80009f18 <fat_cluster_list+0x28c>
         } else {
            fs_g_status = FS_ERR_OUT_LIST;
80009d1e:	31 a9       	mov	r9,26
80009d20:	4f f8       	lddpc	r8,80009f1c <fat_cluster_list+0x290>
80009d22:	b0 89       	st.b	r8[0x0],r9
80009d24:	30 0c       	mov	r12,0
            return false;        // Position outside the root area
80009d26:	cf 98       	rjmp	80009f18 <fat_cluster_list+0x28c>
         }
      }
      if ( Is_fat32 )
80009d28:	30 39       	mov	r9,3
80009d2a:	f2 08 18 00 	cp.b	r8,r9
80009d2e:	c0 81       	brne	80009d3e <fat_cluster_list+0xb2>
      {
         // For FAT 32, the root is a cluster list and the first cluster is reading during the mount
         fs_g_cluster.u32_pos = fs_g_nav.rootdir.u32_cluster;
80009d30:	4f f8       	lddpc	r8,80009f2c <fat_cluster_list+0x2a0>
80009d32:	70 69       	ld.w	r9,r8[0x18]
80009d34:	4f f8       	lddpc	r8,80009f30 <fat_cluster_list+0x2a4>
80009d36:	91 09       	st.w	r8[0x0],r9
80009d38:	c0 38       	rjmp	80009d3e <fat_cluster_list+0xb2>
      }
   } else {
      // It is the first cluster of a cluster list
      fs_g_cluster.u32_pos = fs_g_seg.u32_addr;
80009d3a:	4f e9       	lddpc	r9,80009f30 <fat_cluster_list+0x2a4>
80009d3c:	93 08       	st.w	r9[0x0],r8
   }

   // Management of cluster list caches
   if( FS_CLUST_ACT_CLR != opt_action )
80009d3e:	30 38       	mov	r8,3
80009d40:	f0 03 18 00 	cp.b	r3,r8
80009d44:	c0 70       	breq	80009d52 <fat_cluster_list+0xc6>
   {
      if( fat_cache_clusterlist_update_read( b_for_file ) )
80009d46:	0e 9c       	mov	r12,r7
80009d48:	f0 1f 00 7b 	mcall	80009f34 <fat_cluster_list+0x2a8>
80009d4c:	c0 70       	breq	80009d5a <fat_cluster_list+0xce>
80009d4e:	30 1c       	mov	r12,1
80009d50:	ce 48       	rjmp	80009f18 <fat_cluster_list+0x28c>
         return true;            // Segment found in cache
      // Segment not found & cache ready to update
   }else{
      fat_cache_clusterlist_reset();   // It is a clear action then clear cluster list caches
80009d52:	f0 1f 00 7a 	mcall	80009f38 <fat_cluster_list+0x2ac>
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
      fat_clear_info_fat_mod();        // Init cache on fat modification range
80009d56:	f0 1f 00 7a 	mcall	80009f3c <fat_cluster_list+0x2b0>
#endif  // FS_LEVEL_FEATURES
   }

   // Init loop with a start segment no found
   MSB0( fs_g_seg.u32_addr ) = 0xFF;
80009d5a:	4f 40       	lddpc	r0,80009f28 <fat_cluster_list+0x29c>
80009d5c:	3f f8       	mov	r8,-1
80009d5e:	a0 88       	st.b	r0[0x0],r8

   //**** Loop to read the cluster list
   while ( 1 )
   {
      if ( fs_g_seg.u32_size_or_pos < fs_g_nav.u8_BPB_SecPerClus )
80009d60:	00 96       	mov	r6,r0
80009d62:	4f 35       	lddpc	r5,80009f2c <fat_cluster_list+0x2a0>
      {
         // The segment starts in this cluster
         // Compute the sector address of this cluster
         fs_g_seg.u32_addr = ((fs_g_cluster.u32_pos - 2) * fs_g_nav.u8_BPB_SecPerClus)
80009d64:	4f 37       	lddpc	r7,80009f30 <fat_cluster_list+0x2a4>
                           + fs_g_nav.u32_ptr_fat + fs_g_nav.u32_offset_data + fs_g_seg.u32_size_or_pos;

         if ( FS_CLUST_ACT_ONE == opt_action )
80009d66:	30 21       	mov	r1,2
            // Send a size of one sector
            fs_g_seg.u32_size_or_pos = 1;
            return true;
         }
         // Update the segment size
         fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus - LSB0( fs_g_seg.u32_size_or_pos );
80009d68:	e0 c8 ff f9 	sub	r8,r0,-7
80009d6c:	50 18       	stdsp	sp[0x4],r8

         // Take time, during read cluster list on FAT 16 & 32
         if( (FS_CLUST_ACT_SEG == opt_action)
80009d6e:	30 12       	mov	r2,1
   MSB0( fs_g_seg.u32_addr ) = 0xFF;

   //**** Loop to read the cluster list
   while ( 1 )
   {
      if ( fs_g_seg.u32_size_or_pos < fs_g_nav.u8_BPB_SecPerClus )
80009d70:	6c 19       	ld.w	r9,r6[0x4]
80009d72:	0b 98       	ld.ub	r8,r5[0x1]
80009d74:	10 39       	cp.w	r9,r8
80009d76:	c4 32       	brcc	80009dfc <fat_cluster_list+0x170>
      {
         // The segment starts in this cluster
         // Compute the sector address of this cluster
         fs_g_seg.u32_addr = ((fs_g_cluster.u32_pos - 2) * fs_g_nav.u8_BPB_SecPerClus)
80009d78:	6a 4a       	ld.w	r10,r5[0x10]
80009d7a:	14 09       	add	r9,r10
80009d7c:	6a 5a       	ld.w	r10,r5[0x14]
80009d7e:	14 09       	add	r9,r10
80009d80:	6e 0a       	ld.w	r10,r7[0x0]
80009d82:	20 2a       	sub	r10,2
80009d84:	f4 08 02 48 	mul	r8,r10,r8
80009d88:	f2 08 00 08 	add	r8,r9,r8
80009d8c:	8d 08       	st.w	r6[0x0],r8
                           + fs_g_nav.u32_ptr_fat + fs_g_nav.u32_offset_data + fs_g_seg.u32_size_or_pos;

         if ( FS_CLUST_ACT_ONE == opt_action )
80009d8e:	e2 03 18 00 	cp.b	r3,r1
80009d92:	c0 d1       	brne	80009dac <fat_cluster_list+0x120>
         {
            // Compute the maximum size
            fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus-fs_g_seg.u32_size_or_pos;
80009d94:	4e 57       	lddpc	r7,80009f28 <fat_cluster_list+0x29c>
80009d96:	4e 68       	lddpc	r8,80009f2c <fat_cluster_list+0x2a0>
80009d98:	11 99       	ld.ub	r9,r8[0x1]
80009d9a:	6e 18       	ld.w	r8,r7[0x4]
80009d9c:	f2 08 01 08 	sub	r8,r9,r8
80009da0:	8f 18       	st.w	r7[0x4],r8
            fat_cache_clusterlist_update_finish();
80009da2:	f0 1f 00 68 	mcall	80009f40 <fat_cluster_list+0x2b4>
            // Send a size of one sector
            fs_g_seg.u32_size_or_pos = 1;
80009da6:	30 1c       	mov	r12,1
80009da8:	8f 1c       	st.w	r7[0x4],r12
            return true;
80009daa:	cb 78       	rjmp	80009f18 <fat_cluster_list+0x28c>
         }
         // Update the segment size
         fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus - LSB0( fs_g_seg.u32_size_or_pos );
80009dac:	0b 99       	ld.ub	r9,r5[0x1]
80009dae:	40 1a       	lddsp	r10,sp[0x4]
80009db0:	15 88       	ld.ub	r8,r10[0x0]
80009db2:	f2 08 01 08 	sub	r8,r9,r8
80009db6:	8d 18       	st.w	r6[0x4],r8

         // Take time, during read cluster list on FAT 16 & 32
         if( (FS_CLUST_ACT_SEG == opt_action)
80009db8:	e4 03 18 00 	cp.b	r3,r2
80009dbc:	c2 01       	brne	80009dfc <fat_cluster_list+0x170>
80009dbe:	4d 99       	lddpc	r9,80009f20 <fat_cluster_list+0x294>
80009dc0:	13 88       	ld.ub	r8,r9[0x0]
80009dc2:	e4 08 18 00 	cp.b	r8,r2
80009dc6:	c1 b0       	breq	80009dfc <fat_cluster_list+0x170>
         &&  (!Is_fat12) )
         {
            // Init loop with the current cluster
            u32_tmp = fs_g_cluster.u32_pos;
80009dc8:	6e 04       	ld.w	r4,r7[0x0]
            if( !fat_cluster_val( FS_CLUST_VAL_READ ))
80009dca:	30 0c       	mov	r12,0
80009dcc:	f0 1f 00 5e 	mcall	80009f44 <fat_cluster_list+0x2b8>
80009dd0:	e0 80 00 a3 	breq	80009f16 <fat_cluster_list+0x28a>
               return false;
            // Read cluster list, while this one is continue
            while(1)
            {
               if ( (++fs_g_cluster.u32_pos) != fs_g_cluster.u32_val )
80009dd4:	6e 09       	ld.w	r9,r7[0x0]
80009dd6:	f2 c8 ff ff 	sub	r8,r9,-1
80009dda:	8f 08       	st.w	r7[0x0],r8
80009ddc:	6e 1a       	ld.w	r10,r7[0x4]
80009dde:	14 38       	cp.w	r8,r10
80009de0:	c0 a0       	breq	80009df4 <fat_cluster_list+0x168>
               {
                  fs_g_cluster.u32_pos--;                   // Recompute previous value
80009de2:	8f 09       	st.w	r7[0x0],r9
                  u32_tmp = fs_g_cluster.u32_pos - u32_tmp; // Compute the size of cluster list
                  fs_g_seg.u32_size_or_pos += u32_tmp * fs_g_nav.u8_BPB_SecPerClus;
80009de4:	08 19       	sub	r9,r4
80009de6:	0b 98       	ld.ub	r8,r5[0x1]
80009de8:	b1 39       	mul	r9,r8
80009dea:	6c 18       	ld.w	r8,r6[0x4]
80009dec:	f2 08 00 08 	add	r8,r9,r8
80009df0:	8d 18       	st.w	r6[0x4],r8
                  break;
80009df2:	c0 58       	rjmp	80009dfc <fat_cluster_list+0x170>
               }
               if( !fat_cluster_readnext() )
80009df4:	f0 1f 00 55 	mcall	80009f48 <fat_cluster_list+0x2bc>
80009df8:	ce e1       	brne	80009dd4 <fat_cluster_list+0x148>
80009dfa:	c8 e8       	rjmp	80009f16 <fat_cluster_list+0x28a>
                  return false;
            }
         }
      }
      // Get the cluster value
      if( !fat_cluster_val( FS_CLUST_VAL_READ ))
80009dfc:	30 0c       	mov	r12,0
80009dfe:	f0 1f 00 52 	mcall	80009f44 <fat_cluster_list+0x2b8>
80009e02:	e0 80 00 8a 	breq	80009f16 <fat_cluster_list+0x28a>
         return false;

      // Read and check the status of the new cluster
      u8_cluster_status = fat_checkcluster();
80009e06:	f0 1f 00 52 	mcall	80009f4c <fat_cluster_list+0x2c0>
80009e0a:	18 94       	mov	r4,r12
      if (FS_CLUS_BAD == u8_cluster_status)
80009e0c:	e4 0c 18 00 	cp.b	r12,r2
80009e10:	e0 80 00 83 	breq	80009f16 <fat_cluster_list+0x28a>
         return false; // error, end of cluster list

      if (0xFF == MSB0(fs_g_seg.u32_addr))
80009e14:	01 89       	ld.ub	r9,r0[0x0]
80009e16:	3f f8       	mov	r8,-1
80009e18:	f0 09 18 00 	cp.b	r9,r8
80009e1c:	c4 61       	brne	80009ea8 <fat_cluster_list+0x21c>
      {
         // The beginning of the segment isn't found
         if (FS_CLUS_END == u8_cluster_status)
80009e1e:	e2 0c 18 00 	cp.b	r12,r1
80009e22:	c2 b1       	brne	80009e78 <fat_cluster_list+0x1ec>
         {
            u32_tmp = fs_g_seg.u32_size_or_pos;       // Save number of sector remaining
80009e24:	4c 18       	lddpc	r8,80009f28 <fat_cluster_list+0x29c>
80009e26:	70 17       	ld.w	r7,r8[0x4]

            // Compute the sector address of this last cluster to take time during a future request with the same cluster list
            fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start -= fs_g_seg.u32_size_or_pos;
80009e28:	4c a9       	lddpc	r9,80009f50 <fat_cluster_list+0x2c4>
80009e2a:	13 89       	ld.ub	r9,r9[0x0]
80009e2c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80009e30:	4c 9a       	lddpc	r10,80009f54 <fat_cluster_list+0x2c8>
80009e32:	f4 09 00 29 	add	r9,r10,r9<<0x2
80009e36:	72 2a       	ld.w	r10,r9[0x8]
80009e38:	0e 1a       	sub	r10,r7
80009e3a:	93 2a       	st.w	r9[0x8],r10
            fs_g_seg.u32_addr = ((fs_g_cluster.u32_pos - 2) * fs_g_nav.u8_BPB_SecPerClus)
80009e3c:	4b c9       	lddpc	r9,80009f2c <fat_cluster_list+0x2a0>
80009e3e:	72 5b       	ld.w	r11,r9[0x14]
80009e40:	72 4a       	ld.w	r10,r9[0x10]
80009e42:	14 0b       	add	r11,r10
80009e44:	13 99       	ld.ub	r9,r9[0x1]
80009e46:	4b ba       	lddpc	r10,80009f30 <fat_cluster_list+0x2a4>
80009e48:	74 0a       	ld.w	r10,r10[0x0]
80009e4a:	20 2a       	sub	r10,2
80009e4c:	f2 0a 02 4a 	mul	r10,r9,r10
80009e50:	f6 0a 00 0a 	add	r10,r11,r10
80009e54:	91 0a       	st.w	r8[0x0],r10
                              + fs_g_nav.u32_ptr_fat + fs_g_nav.u32_offset_data;
            fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus;
80009e56:	91 19       	st.w	r8[0x4],r9
            if (FS_CLUST_ACT_CLR != opt_action)
80009e58:	30 38       	mov	r8,3
80009e5a:	f0 03 18 00 	cp.b	r3,r8
80009e5e:	c0 30       	breq	80009e64 <fat_cluster_list+0x1d8>
               fat_cache_clusterlist_update_finish();
80009e60:	f0 1f 00 38 	mcall	80009f40 <fat_cluster_list+0x2b4>

            // The position is outside the cluster list
            fs_g_seg.u32_addr = fs_g_cluster.u32_pos; // Send the last cluster value
80009e64:	4b 18       	lddpc	r8,80009f28 <fat_cluster_list+0x29c>
80009e66:	4b 39       	lddpc	r9,80009f30 <fat_cluster_list+0x2a4>
80009e68:	72 09       	ld.w	r9,r9[0x0]
80009e6a:	91 09       	st.w	r8[0x0],r9
            fs_g_seg.u32_size_or_pos = u32_tmp;       // Restore number of sector remaining
80009e6c:	91 17       	st.w	r8[0x4],r7
            fs_g_status = FS_ERR_OUT_LIST;
80009e6e:	31 a9       	mov	r9,26
80009e70:	4a b8       	lddpc	r8,80009f1c <fat_cluster_list+0x290>
80009e72:	b0 89       	st.b	r8[0x0],r9
80009e74:	30 0c       	mov	r12,0
            return false;
80009e76:	c5 18       	rjmp	80009f18 <fat_cluster_list+0x28c>
         }
         // Good cluster then continue
         fs_g_seg.u32_size_or_pos -= fs_g_nav.u8_BPB_SecPerClus;
80009e78:	0b 98       	ld.ub	r8,r5[0x1]
80009e7a:	6c 19       	ld.w	r9,r6[0x4]
80009e7c:	f2 08 01 08 	sub	r8,r9,r8
80009e80:	8d 18       	st.w	r6[0x4],r8
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
         if (FS_CLUST_ACT_CLR == opt_action)
80009e82:	40 0a       	lddsp	r10,sp[0x0]
80009e84:	58 0a       	cp.w	r10,0
80009e86:	c4 50       	breq	80009f10 <fat_cluster_list+0x284>
         {
            if( fs_g_seg.u32_size_or_pos == 0)
80009e88:	58 08       	cp.w	r8,0
80009e8a:	c4 31       	brne	80009f10 <fat_cluster_list+0x284>
            {
               // At cluster position, set the flag end of cluster list
               fs_g_seg.u32_addr = fs_g_cluster.u32_val; // Save the next cluster
80009e8c:	6e 18       	ld.w	r8,r7[0x4]
80009e8e:	8d 08       	st.w	r6[0x0],r8
               fs_g_cluster.u32_val = FS_CLUST_VAL_EOL;
80009e90:	e0 68 ff ff 	mov	r8,65535
80009e94:	ea 18 0f ff 	orh	r8,0xfff
80009e98:	8f 18       	st.w	r7[0x4],r8
               if( !fat_cluster_val( FS_CLUST_VAL_WRITE ))
80009e9a:	30 1c       	mov	r12,1
80009e9c:	f0 1f 00 2a 	mcall	80009f44 <fat_cluster_list+0x2b8>
80009ea0:	c3 b0       	breq	80009f16 <fat_cluster_list+0x28a>
                  return false;
               fs_g_cluster.u32_val = fs_g_seg.u32_addr; // Restore the next cluster
80009ea2:	6c 08       	ld.w	r8,r6[0x0]
80009ea4:	8f 18       	st.w	r7[0x4],r8
80009ea6:	c3 58       	rjmp	80009f10 <fat_cluster_list+0x284>
#endif  // FS_LEVEL_FEATURES
      }
      else
      {
         // The beginning of segment is found
         if (FS_CLUST_ACT_SEG == opt_action)
80009ea8:	e4 03 18 00 	cp.b	r3,r2
80009eac:	c0 a1       	brne	80009ec0 <fat_cluster_list+0x234>
         {
            if ( (fs_g_cluster.u32_pos+1) != fs_g_cluster.u32_val )
80009eae:	6e 09       	ld.w	r9,r7[0x0]
80009eb0:	2f f9       	sub	r9,-1
80009eb2:	6e 18       	ld.w	r8,r7[0x4]
80009eb4:	10 39       	cp.w	r9,r8
80009eb6:	c1 b0       	breq	80009eec <fat_cluster_list+0x260>
            {
               // The cluster is not a continue cluster or a invalid cluster
               fat_cache_clusterlist_update_finish();
80009eb8:	f0 1f 00 22 	mcall	80009f40 <fat_cluster_list+0x2b4>
80009ebc:	30 1c       	mov	r12,1
               return true;                              // End of segment
80009ebe:	c2 d8       	rjmp	80009f18 <fat_cluster_list+0x28c>
            }
         }
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
         if (FS_CLUST_ACT_CLR == opt_action)
80009ec0:	40 09       	lddsp	r9,sp[0x0]
80009ec2:	58 09       	cp.w	r9,0
80009ec4:	c1 40       	breq	80009eec <fat_cluster_list+0x260>
         {
            //** Clear cluster position
            fs_g_seg.u32_addr = fs_g_cluster.u32_val;    // Save the next cluster
80009ec6:	6e 18       	ld.w	r8,r7[0x4]
80009ec8:	8d 08       	st.w	r6[0x0],r8
            fs_g_cluster.u32_val = 0;                    // by default free cluster
80009eca:	30 08       	mov	r8,0
80009ecc:	8f 18       	st.w	r7[0x4],r8
            // If it is the first cluster (fs_g_seg.u32_size_or_pos <= fs_g_nav.u8_BPB_SecPerClus)
            // and doesn't start at the beginning of cluster (fs_g_seg.u32_size_or_pos != fs_g_nav.u8_BPB_SecPerClus)
            if (fs_g_seg.u32_size_or_pos < fs_g_nav.u8_BPB_SecPerClus)
80009ece:	0b 98       	ld.ub	r8,r5[0x1]
80009ed0:	6c 19       	ld.w	r9,r6[0x4]
80009ed2:	10 39       	cp.w	r9,r8
80009ed4:	c0 62       	brcc	80009ee0 <fat_cluster_list+0x254>
            {
               fs_g_cluster.u32_val = FS_CLUST_VAL_EOL;  // End of cluster list allocated
80009ed6:	e0 68 ff ff 	mov	r8,65535
80009eda:	ea 18 0f ff 	orh	r8,0xfff
80009ede:	8f 18       	st.w	r7[0x4],r8
            }
            if( !fat_cluster_val( FS_CLUST_VAL_WRITE ))
80009ee0:	30 1c       	mov	r12,1
80009ee2:	f0 1f 00 19 	mcall	80009f44 <fat_cluster_list+0x2b8>
80009ee6:	c1 80       	breq	80009f16 <fat_cluster_list+0x28a>
               return false;
            fs_g_cluster.u32_val = fs_g_seg.u32_addr;    // Restore the next cluster
80009ee8:	6c 08       	ld.w	r8,r6[0x0]
80009eea:	8f 18       	st.w	r7[0x4],r8
            // !!!! because it isn't possible that MSB0( fs_g_cluster.val ) = 0xFF.
         }
#endif  // FS_LEVEL_FEATURES

         // Check the end of cluster list
         if (FS_CLUS_END == u8_cluster_status)
80009eec:	e2 04 18 00 	cp.b	r4,r1
80009ef0:	c0 b1       	brne	80009f06 <fat_cluster_list+0x27a>
         {
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
            if (FS_CLUST_ACT_CLR == opt_action)
80009ef2:	40 0a       	lddsp	r10,sp[0x0]
80009ef4:	58 0a       	cp.w	r10,0
80009ef6:	c0 40       	breq	80009efe <fat_cluster_list+0x272>
            {
               return fat_update_fat2();
80009ef8:	f0 1f 00 18 	mcall	80009f58 <fat_cluster_list+0x2cc>
80009efc:	c0 e8       	rjmp	80009f18 <fat_cluster_list+0x28c>
            }
#endif  // FS_LEVEL_FEATURES
            fat_cache_clusterlist_update_finish();
80009efe:	f0 1f 00 11 	mcall	80009f40 <fat_cluster_list+0x2b4>
80009f02:	30 1c       	mov	r12,1
            return true; // End of segment
80009f04:	c0 a8       	rjmp	80009f18 <fat_cluster_list+0x28c>
         }

         // Update the segment size
         fs_g_seg.u32_size_or_pos += fs_g_nav.u8_BPB_SecPerClus;
80009f06:	0b 99       	ld.ub	r9,r5[0x1]
80009f08:	6c 18       	ld.w	r8,r6[0x4]
80009f0a:	f2 08 00 08 	add	r8,r9,r8
80009f0e:	8d 18       	st.w	r6[0x4],r8
      }
      // HERE, Continue to read the cluster list
      // The next cluster is the value of previous cluster
      fs_g_cluster.u32_pos = fs_g_cluster.u32_val;
80009f10:	6e 18       	ld.w	r8,r7[0x4]
80009f12:	8f 08       	st.w	r7[0x0],r8
   }  // End of main loop
80009f14:	c2 eb       	rjmp	80009d70 <fat_cluster_list+0xe4>
80009f16:	30 0c       	mov	r12,0
}
80009f18:	2f ed       	sub	sp,-8
80009f1a:	d8 32       	popm	r0-r7,pc
80009f1c:	00 00       	add	r0,r0
80009f1e:	0c 68       	and	r8,r6
80009f20:	00 00       	add	r0,r0
80009f22:	0c 64       	and	r4,r6
80009f24:	80 00       	ld.sh	r0,r0[0x0]
80009f26:	a2 ec       	st.b	r1[0x6],r12
80009f28:	00 00       	add	r0,r0
80009f2a:	0c c0       	st.b	r6++,r0
80009f2c:	00 00       	add	r0,r0
80009f2e:	0c 18       	sub	r8,r6
80009f30:	00 00       	add	r0,r0
80009f32:	0c b8       	st.h	r6++,r8
80009f34:	80 00       	ld.sh	r0,r0[0x0]
80009f36:	91 64       	st.w	r8[0x18],r4
80009f38:	80 00       	ld.sh	r0,r0[0x0]
80009f3a:	90 34       	ld.sh	r4,r8[0x6]
80009f3c:	80 00       	ld.sh	r0,r0[0x0]
80009f3e:	a2 60       	st.h	r1[0xc],r0
80009f40:	80 00       	ld.sh	r0,r0[0x0]
80009f42:	91 0c       	st.w	r8[0x0],r12
80009f44:	80 00       	ld.sh	r0,r0[0x0]
80009f46:	9a 48       	ld.sh	r8,sp[0x8]
80009f48:	80 00       	ld.sh	r0,r0[0x0]
80009f4a:	99 b4       	st.w	r12[0x2c],r4
80009f4c:	80 00       	ld.sh	r0,r0[0x0]
80009f4e:	8f d4       	st.w	r7[0x34],r4
80009f50:	00 00       	add	r0,r0
80009f52:	0c 6a       	and	r10,r6
80009f54:	00 00       	add	r0,r0
80009f56:	09 ec       	ld.ub	r12,r4[0x6]
80009f58:	80 00       	ld.sh	r0,r0[0x0]
80009f5a:	a2 78       	st.h	r1[0xe],r8

80009f5c <fat_read_dir>:
//!   fs_g_nav.u32_cluster_sel_dir           First cluster of current directory
//!   fs_g_nav_fast.u16_entry_pos_sel_file   Position in directory (unit entry)
//! @endverbatim
//!
bool  fat_read_dir( void )
{
80009f5c:	eb cd 40 80 	pushm	r7,lr
   uint32_t u32_cluster_pos;

   // Compute the cluster list position corresponding of the current entry
   u32_cluster_pos = fs_g_nav_fast.u16_entry_pos_sel_file >> (FS_512B_SHIFT_BIT - FS_SHIFT_B_TO_FILE_ENTRY);
80009f60:	49 98       	lddpc	r8,80009fc4 <fat_read_dir+0x68>
80009f62:	90 97       	ld.uh	r7,r8[0x2]
80009f64:	a5 87       	lsr	r7,0x4

   if( (fs_g_sectorcache.u8_lun                 == fs_g_nav.u8_lun )
80009f66:	49 98       	lddpc	r8,80009fc8 <fat_read_dir+0x6c>
80009f68:	11 89       	ld.ub	r9,r8[0x0]
80009f6a:	49 98       	lddpc	r8,80009fcc <fat_read_dir+0x70>
80009f6c:	11 88       	ld.ub	r8,r8[0x0]
80009f6e:	f0 09 18 00 	cp.b	r9,r8
80009f72:	c0 d1       	brne	80009f8c <fat_read_dir+0x30>
80009f74:	49 58       	lddpc	r8,80009fc8 <fat_read_dir+0x6c>
80009f76:	70 39       	ld.w	r9,r8[0xc]
80009f78:	49 58       	lddpc	r8,80009fcc <fat_read_dir+0x70>
80009f7a:	70 88       	ld.w	r8,r8[0x20]
80009f7c:	10 39       	cp.w	r9,r8
80009f7e:	c0 71       	brne	80009f8c <fat_read_dir+0x30>
80009f80:	49 28       	lddpc	r8,80009fc8 <fat_read_dir+0x6c>
80009f82:	70 48       	ld.w	r8,r8[0x10]
80009f84:	0e 38       	cp.w	r8,r7
80009f86:	c0 31       	brne	80009f8c <fat_read_dir+0x30>
80009f88:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
   {
         return true;      // The internal cache contains the sector asked
   }

   // Get sector address corresponding at cluster list position
   fs_g_seg.u32_addr = fs_g_nav.u32_cluster_sel_dir;
80009f8c:	49 18       	lddpc	r8,80009fd0 <fat_read_dir+0x74>
80009f8e:	49 09       	lddpc	r9,80009fcc <fat_read_dir+0x70>
80009f90:	72 89       	ld.w	r9,r9[0x20]
80009f92:	91 09       	st.w	r8[0x0],r9
   fs_g_seg.u32_size_or_pos = u32_cluster_pos;
80009f94:	91 17       	st.w	r8[0x4],r7
   if( fat_cluster_list( FS_CLUST_ACT_ONE, false ) )
80009f96:	30 0b       	mov	r11,0
80009f98:	30 2c       	mov	r12,2
80009f9a:	f0 1f 00 0f 	mcall	80009fd4 <fat_read_dir+0x78>
80009f9e:	c1 00       	breq	80009fbe <fat_read_dir+0x62>
   {
      // Read the sector
      fs_gu32_addrsector = fs_g_seg.u32_addr;
80009fa0:	48 c8       	lddpc	r8,80009fd0 <fat_read_dir+0x74>
80009fa2:	70 09       	ld.w	r9,r8[0x0]
80009fa4:	48 d8       	lddpc	r8,80009fd8 <fat_read_dir+0x7c>
80009fa6:	91 09       	st.w	r8[0x0],r9
      if( fat_cache_read_sector( true ) )
80009fa8:	30 1c       	mov	r12,1
80009faa:	f0 1f 00 0d 	mcall	80009fdc <fat_read_dir+0x80>
80009fae:	c0 80       	breq	80009fbe <fat_read_dir+0x62>
      {
         // Update information about internal sector cache
         fs_g_sectorcache.u32_clusterlist_start  = fs_g_nav.u32_cluster_sel_dir;
80009fb0:	48 68       	lddpc	r8,80009fc8 <fat_read_dir+0x6c>
80009fb2:	48 79       	lddpc	r9,80009fcc <fat_read_dir+0x70>
80009fb4:	72 89       	ld.w	r9,r9[0x20]
80009fb6:	91 39       	st.w	r8[0xc],r9
         fs_g_sectorcache.u32_clusterlist_pos    = u32_cluster_pos;
80009fb8:	91 47       	st.w	r8[0x10],r7
80009fba:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
         return true;
80009fbe:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
80009fc2:	00 00       	add	r0,r0
80009fc4:	00 00       	add	r0,r0
80009fc6:	0c 64       	and	r4,r6
80009fc8:	00 00       	add	r0,r0
80009fca:	0c a0       	st.w	r6++,r0
80009fcc:	00 00       	add	r0,r0
80009fce:	0c 18       	sub	r8,r6
80009fd0:	00 00       	add	r0,r0
80009fd2:	0c c0       	st.b	r6++,r0
80009fd4:	80 00       	ld.sh	r0,r0[0x0]
80009fd6:	9c 8c       	ld.uh	r12,lr[0x0]
80009fd8:	00 00       	add	r0,r0
80009fda:	09 d4       	ld.ub	r4,r4[0x5]
80009fdc:	80 00       	ld.sh	r0,r0[0x0]
80009fde:	99 34       	st.w	r12[0xc],r4

80009fe0 <fat_read_file>:
//!   fs_g_nav_entry.u32_cluster       First cluster of selected file
//!   fs_g_nav_entry.u32_pos_in_file   Position in file (unit byte)
//! @endverbatim
//!
bool  fat_read_file( uint8_t mode )
{
80009fe0:	eb cd 40 c0 	pushm	r6-r7,lr
80009fe4:	18 97       	mov	r7,r12
   uint32_t   u32_sector_pos;

   // Compute sector position
   u32_sector_pos = fs_g_nav_entry.u32_pos_in_file >> FS_512B_SHIFT_BIT;
80009fe6:	4a e8       	lddpc	r8,8000a09c <fat_read_file+0xbc>
80009fe8:	70 38       	ld.w	r8,r8[0xc]
80009fea:	f0 06 16 09 	lsr	r6,r8,0x9

   if(FS_CLUST_ACT_ONE  == mode)
80009fee:	30 29       	mov	r9,2
80009ff0:	f2 0c 18 00 	cp.b	r12,r9
80009ff4:	c1 31       	brne	8000a01a <fat_read_file+0x3a>
   {
      if( (fs_g_sectorcache.u8_lun                 == fs_g_nav.u8_lun )
80009ff6:	4a b8       	lddpc	r8,8000a0a0 <fat_read_file+0xc0>
80009ff8:	11 89       	ld.ub	r9,r8[0x0]
80009ffa:	4a b8       	lddpc	r8,8000a0a4 <fat_read_file+0xc4>
80009ffc:	11 88       	ld.ub	r8,r8[0x0]
80009ffe:	f0 09 18 00 	cp.b	r9,r8
8000a002:	c1 91       	brne	8000a034 <fat_read_file+0x54>
8000a004:	4a 78       	lddpc	r8,8000a0a0 <fat_read_file+0xc0>
8000a006:	70 39       	ld.w	r9,r8[0xc]
8000a008:	4a 58       	lddpc	r8,8000a09c <fat_read_file+0xbc>
8000a00a:	70 18       	ld.w	r8,r8[0x4]
8000a00c:	10 39       	cp.w	r9,r8
8000a00e:	c1 31       	brne	8000a034 <fat_read_file+0x54>
8000a010:	4a 48       	lddpc	r8,8000a0a0 <fat_read_file+0xc0>
8000a012:	70 48       	ld.w	r8,r8[0x10]
8000a014:	0c 38       	cp.w	r8,r6
8000a016:	c0 f1       	brne	8000a034 <fat_read_file+0x54>
8000a018:	c3 38       	rjmp	8000a07e <fat_read_file+0x9e>
         return true;      // The internal cache contains the sector requested
      }
   }
   else
   {
      if( FS_CLUST_ACT_CLR == mode )
8000a01a:	30 39       	mov	r9,3
8000a01c:	f2 0c 18 00 	cp.b	r12,r9
8000a020:	c3 31       	brne	8000a086 <fat_read_file+0xa6>
      {
         // Clear cluster list
         if( 0 == fs_g_nav_entry.u32_cluster )
8000a022:	49 f9       	lddpc	r9,8000a09c <fat_read_file+0xbc>
8000a024:	72 19       	ld.w	r9,r9[0x4]
8000a026:	58 09       	cp.w	r9,0
8000a028:	c2 b0       	breq	8000a07e <fat_read_file+0x9e>
            return true;   // No cluster list is linked with the file, then no clear is necessary

         if(0 != (fs_g_nav_entry.u32_pos_in_file & FS_512B_MASK) )
8000a02a:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
8000a02e:	c2 c0       	breq	8000a086 <fat_read_file+0xa6>
         {
            // The actual sector is used, then start clear on the next sector
            u32_sector_pos++;
8000a030:	2f f6       	sub	r6,-1
8000a032:	c2 a8       	rjmp	8000a086 <fat_read_file+0xa6>
         }
      }
   }

   // Get the segment which start at the current position
   fs_g_seg.u32_addr = fs_g_nav_entry.u32_cluster;
8000a034:	49 d8       	lddpc	r8,8000a0a8 <fat_read_file+0xc8>
8000a036:	49 a9       	lddpc	r9,8000a09c <fat_read_file+0xbc>
8000a038:	72 19       	ld.w	r9,r9[0x4]
8000a03a:	91 09       	st.w	r8[0x0],r9
   fs_g_seg.u32_size_or_pos = u32_sector_pos;
8000a03c:	91 16       	st.w	r8[0x4],r6
      if( fat_cluster_list( mode, true ) )
         return true;      // Get or clear segment OK
   }
   else
   {
      if( fat_cluster_list( FS_CLUST_ACT_SEG, true ) )   // Read all segment
8000a03e:	30 1b       	mov	r11,1
8000a040:	16 9c       	mov	r12,r11
8000a042:	f0 1f 00 1b 	mcall	8000a0ac <fat_read_file+0xcc>
8000a046:	c1 e0       	breq	8000a082 <fat_read_file+0xa2>
      {
         // Read the sector corresponding at the position file (= first sector of segment)
         fs_gu32_addrsector = fs_g_seg.u32_addr ;
8000a048:	49 88       	lddpc	r8,8000a0a8 <fat_read_file+0xc8>
8000a04a:	70 09       	ld.w	r9,r8[0x0]
8000a04c:	49 98       	lddpc	r8,8000a0b0 <fat_read_file+0xd0>
8000a04e:	91 09       	st.w	r8[0x0],r9
         if( fat_cache_read_sector( true ) )
8000a050:	30 1c       	mov	r12,1
8000a052:	f0 1f 00 19 	mcall	8000a0b4 <fat_read_file+0xd4>
8000a056:	c1 60       	breq	8000a082 <fat_read_file+0xa2>
         {
            fs_g_sectorcache.u32_clusterlist_start  = fs_g_nav_entry.u32_cluster;
8000a058:	49 28       	lddpc	r8,8000a0a0 <fat_read_file+0xc0>
8000a05a:	49 19       	lddpc	r9,8000a09c <fat_read_file+0xbc>
8000a05c:	72 19       	ld.w	r9,r9[0x4]
8000a05e:	91 39       	st.w	r8[0xc],r9
            fs_g_sectorcache.u32_clusterlist_pos    = u32_sector_pos;
8000a060:	91 46       	st.w	r8[0x10],r6
8000a062:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
            return true;
         }
      }
   }
   if( (FS_CLUST_ACT_CLR == mode       )
8000a066:	30 38       	mov	r8,3
8000a068:	f0 07 18 00 	cp.b	r7,r8
8000a06c:	c0 b1       	brne	8000a082 <fat_read_file+0xa2>
//! IN :
//!   fs_g_nav_entry.u32_cluster       First cluster of selected file
//!   fs_g_nav_entry.u32_pos_in_file   Position in file (unit byte)
//! @endverbatim
//!
bool  fat_read_file( uint8_t mode )
8000a06e:	49 38       	lddpc	r8,8000a0b8 <fat_read_file+0xd8>
8000a070:	11 89       	ld.ub	r9,r8[0x0]
8000a072:	31 a8       	mov	r8,26
8000a074:	f0 09 18 00 	cp.b	r9,r8
8000a078:	5f 0c       	sreq	r12
8000a07a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000a07e:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000a082:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
         }
      }
   }

   // Get the segment which start at the current position
   fs_g_seg.u32_addr = fs_g_nav_entry.u32_cluster;
8000a086:	48 98       	lddpc	r8,8000a0a8 <fat_read_file+0xc8>
8000a088:	48 59       	lddpc	r9,8000a09c <fat_read_file+0xbc>
8000a08a:	72 19       	ld.w	r9,r9[0x4]
8000a08c:	91 09       	st.w	r8[0x0],r9
   fs_g_seg.u32_size_or_pos = u32_sector_pos;
8000a08e:	91 16       	st.w	r8[0x4],r6
   if( FS_CLUST_ACT_ONE != mode )
   {
      if( fat_cluster_list( mode, true ) )
8000a090:	30 1b       	mov	r11,1
8000a092:	0e 9c       	mov	r12,r7
8000a094:	f0 1f 00 06 	mcall	8000a0ac <fat_read_file+0xcc>
8000a098:	ce 70       	breq	8000a066 <fat_read_file+0x86>
8000a09a:	cf 2b       	rjmp	8000a07e <fat_read_file+0x9e>
8000a09c:	00 00       	add	r0,r0
8000a09e:	09 d8       	ld.ub	r8,r4[0x5]
8000a0a0:	00 00       	add	r0,r0
8000a0a2:	0c a0       	st.w	r6++,r0
8000a0a4:	00 00       	add	r0,r0
8000a0a6:	0c 18       	sub	r8,r6
8000a0a8:	00 00       	add	r0,r0
8000a0aa:	0c c0       	st.b	r6++,r0
8000a0ac:	80 00       	ld.sh	r0,r0[0x0]
8000a0ae:	9c 8c       	ld.uh	r12,lr[0x0]
8000a0b0:	00 00       	add	r0,r0
8000a0b2:	09 d4       	ld.ub	r4,r4[0x5]
8000a0b4:	80 00       	ld.sh	r0,r0[0x0]
8000a0b6:	99 34       	st.w	r12[0xc],r4
8000a0b8:	00 00       	add	r0,r0
8000a0ba:	0c 68       	and	r8,r6

8000a0bc <fat_check_device>:
//! @verbatim
//! This function updates all navigator data when the device state change.
//! @endverbatim
//!
bool  fat_check_device( void )
{
8000a0bc:	d4 31       	pushm	r0-r7,lr
   uint8_t i;
#endif
   Ctrl_status status;

   // Possibility to ignore the disk check. Used to take time during multi read/write access
   if( g_b_no_check_disk )
8000a0be:	4a 28       	lddpc	r8,8000a144 <fat_check_device+0x88>
8000a0c0:	11 89       	ld.ub	r9,r8[0x0]
8000a0c2:	30 08       	mov	r8,0
8000a0c4:	f0 09 18 00 	cp.b	r9,r8
8000a0c8:	c3 c1       	brne	8000a140 <fat_check_device+0x84>
      return true;

   if( 0xFF == fs_g_nav.u8_lun )
8000a0ca:	4a 08       	lddpc	r8,8000a148 <fat_check_device+0x8c>
8000a0cc:	11 89       	ld.ub	r9,r8[0x0]
8000a0ce:	3f f8       	mov	r8,-1
8000a0d0:	f0 09 18 00 	cp.b	r9,r8
8000a0d4:	c0 51       	brne	8000a0de <fat_check_device+0x22>
   {
      fs_g_status = FS_ERR_HW;
8000a0d6:	30 19       	mov	r9,1
8000a0d8:	49 d8       	lddpc	r8,8000a14c <fat_check_device+0x90>
8000a0da:	b0 89       	st.b	r8[0x0],r9
8000a0dc:	d8 3a       	popm	r0-r7,pc,r12=0
      return false;                                // No device selected
8000a0de:	30 02       	mov	r2,0
   }

   for( retry=0 ; retry<100 ; retry++ )
   {
      // Check device
      status = mem_test_unit_ready( fs_g_nav.u8_lun );
8000a0e0:	49 a5       	lddpc	r5,8000a148 <fat_check_device+0x8c>
      if( CTRL_GOOD       == status )
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
8000a0e2:	49 c1       	lddpc	r1,8000a150 <fat_check_device+0x94>
8000a0e4:	30 06       	mov	r6,0
      Fat_file_close();                            // By default the file is not open
8000a0e6:	49 c0       	lddpc	r0,8000a154 <fat_check_device+0x98>
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
8000a0e8:	49 c4       	lddpc	r4,8000a158 <fat_check_device+0x9c>
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
         }
      }
#endif
      // If the internal cache corresponding at device then clean it
      if( fs_g_nav.u8_lun == fs_g_sectorcache.u8_lun )
8000a0ea:	49 d3       	lddpc	r3,8000a15c <fat_check_device+0xa0>
   }

   for( retry=0 ; retry<100 ; retry++ )
   {
      // Check device
      status = mem_test_unit_ready( fs_g_nav.u8_lun );
8000a0ec:	0b 8c       	ld.ub	r12,r5[0x0]
8000a0ee:	f0 1f 00 1d 	mcall	8000a160 <fat_check_device+0xa4>
8000a0f2:	18 97       	mov	r7,r12
      if( CTRL_GOOD       == status )
8000a0f4:	c2 60       	breq	8000a140 <fat_check_device+0x84>
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
8000a0f6:	a2 86       	st.b	r1[0x0],r6
      Fat_file_close();                            // By default the file is not open
8000a0f8:	a0 86       	st.b	r0[0x0],r6
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
8000a0fa:	0b 88       	ld.ub	r8,r5[0x0]
8000a0fc:	09 89       	ld.ub	r9,r4[0x0]
8000a0fe:	f0 09 18 00 	cp.b	r9,r8
8000a102:	c0 51       	brne	8000a10c <fat_check_device+0x50>
         {
            fs_g_navext_fast[i].u8_type_fat     = FS_TYPE_FAT_UNM;   // By default the fat isn't mounted
8000a104:	49 89       	lddpc	r9,8000a164 <fat_check_device+0xa8>
8000a106:	b2 86       	st.b	r9[0x0],r6
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
8000a108:	49 89       	lddpc	r9,8000a168 <fat_check_device+0xac>
8000a10a:	b2 86       	st.b	r9[0x0],r6
         }
      }
#endif
      // If the internal cache corresponding at device then clean it
      if( fs_g_nav.u8_lun == fs_g_sectorcache.u8_lun )
8000a10c:	07 89       	ld.ub	r9,r3[0x0]
8000a10e:	f0 09 18 00 	cp.b	r9,r8
8000a112:	c0 31       	brne	8000a118 <fat_check_device+0x5c>
      {
         fat_cache_reset();
8000a114:	f0 1f 00 16 	mcall	8000a16c <fat_check_device+0xb0>
      }
      fat_cache_clusterlist_reset();
8000a118:	f0 1f 00 16 	mcall	8000a170 <fat_check_device+0xb4>

      fs_g_status = FS_ERR_HW;                     // By default HW error
8000a11c:	30 18       	mov	r8,1
8000a11e:	48 c9       	lddpc	r9,8000a14c <fat_check_device+0x90>
8000a120:	b2 88       	st.b	r9[0x0],r8
      if( CTRL_BUSY == status )
8000a122:	58 37       	cp.w	r7,3
8000a124:	c0 81       	brne	8000a134 <fat_check_device+0x78>
   {
      fs_g_status = FS_ERR_HW;
      return false;                                // No device selected
   }

   for( retry=0 ; retry<100 ; retry++ )
8000a126:	10 02       	add	r2,r8
8000a128:	5c 52       	castu.b	r2
8000a12a:	36 48       	mov	r8,100
8000a12c:	f0 02 18 00 	cp.b	r2,r8
8000a130:	cd e1       	brne	8000a0ec <fat_check_device+0x30>
8000a132:	c0 88       	rjmp	8000a142 <fat_check_device+0x86>

      fs_g_status = FS_ERR_HW;                     // By default HW error
      if( CTRL_BUSY == status )
         continue;                                 // If device busy then retry

      if( CTRL_NO_PRESENT == status )
8000a134:	58 27       	cp.w	r7,2
8000a136:	c0 61       	brne	8000a142 <fat_check_device+0x86>
         fs_g_status = FS_ERR_HW_NO_PRESENT;       // Update error flag
8000a138:	31 89       	mov	r9,24
8000a13a:	48 58       	lddpc	r8,8000a14c <fat_check_device+0x90>
8000a13c:	b0 89       	st.b	r8[0x0],r9
8000a13e:	d8 3a       	popm	r0-r7,pc,r12=0
8000a140:	da 3a       	popm	r0-r7,pc,r12=1
8000a142:	d8 3a       	popm	r0-r7,pc,r12=0
8000a144:	00 00       	add	r0,r0
8000a146:	09 ea       	ld.ub	r10,r4[0x6]
8000a148:	00 00       	add	r0,r0
8000a14a:	0c 18       	sub	r8,r6
8000a14c:	00 00       	add	r0,r0
8000a14e:	0c 68       	and	r8,r6
8000a150:	00 00       	add	r0,r0
8000a152:	0c 64       	and	r4,r6
8000a154:	00 00       	add	r0,r0
8000a156:	09 d8       	ld.ub	r8,r4[0x5]
8000a158:	00 00       	add	r0,r0
8000a15a:	0c 6c       	and	r12,r6
8000a15c:	00 00       	add	r0,r0
8000a15e:	0c a0       	st.w	r6++,r0
8000a160:	80 00       	ld.sh	r0,r0[0x0]
8000a162:	b3 48       	asr	r8,0x12
8000a164:	00 00       	add	r0,r0
8000a166:	0c 60       	and	r0,r6
8000a168:	00 00       	add	r0,r0
8000a16a:	0c 50       	eor	r0,r6
8000a16c:	80 00       	ld.sh	r0,r0[0x0]
8000a16e:	96 fc       	ld.uh	r12,r11[0xe]
8000a170:	80 00       	ld.sh	r0,r0[0x0]
8000a172:	90 34       	ld.sh	r4,r8[0x6]

8000a174 <fat_check_noopen>:
//!
//! @return    true  no file opened
//! @return    false otherwise
//!
bool  fat_check_noopen( void )
{
8000a174:	d4 01       	pushm	lr
   if( !fat_check_device() )
8000a176:	f0 1f 00 0b 	mcall	8000a1a0 <fat_check_noopen+0x2c>
8000a17a:	c1 10       	breq	8000a19c <fat_check_noopen+0x28>
      return true;
   if (FS_TYPE_FAT_UNM == fs_g_nav_fast.u8_type_fat)
8000a17c:	48 a8       	lddpc	r8,8000a1a4 <fat_check_noopen+0x30>
8000a17e:	11 89       	ld.ub	r9,r8[0x0]
8000a180:	30 08       	mov	r8,0
8000a182:	f0 09 18 00 	cp.b	r9,r8
8000a186:	c0 b0       	breq	8000a19c <fat_check_noopen+0x28>
      return true;
   if( Fat_file_is_open() )
8000a188:	48 88       	lddpc	r8,8000a1a8 <fat_check_noopen+0x34>
8000a18a:	11 89       	ld.ub	r9,r8[0x0]
8000a18c:	30 08       	mov	r8,0
8000a18e:	f0 09 18 00 	cp.b	r9,r8
8000a192:	c0 50       	breq	8000a19c <fat_check_noopen+0x28>
   {
      fs_g_status = FS_ERR_TOO_FILE_OPEN;  // The navigation have already open a file
8000a194:	30 59       	mov	r9,5
8000a196:	48 68       	lddpc	r8,8000a1ac <fat_check_noopen+0x38>
8000a198:	b0 89       	st.b	r8[0x0],r9
8000a19a:	d8 0a       	popm	pc,r12=0
      return false;
8000a19c:	da 0a       	popm	pc,r12=1
8000a19e:	00 00       	add	r0,r0
8000a1a0:	80 00       	ld.sh	r0,r0[0x0]
8000a1a2:	a0 bc       	st.b	r0[0x3],r12
8000a1a4:	00 00       	add	r0,r0
8000a1a6:	0c 64       	and	r4,r6
8000a1a8:	00 00       	add	r0,r0
8000a1aa:	09 d8       	ld.ub	r8,r4[0x5]
8000a1ac:	00 00       	add	r0,r0
8000a1ae:	0c 68       	and	r8,r6

8000a1b0 <fat_check_mount>:
//!
//! @return    true  partition mounted
//! @return    false otherwise
//!
bool  fat_check_mount( void )
{
8000a1b0:	d4 01       	pushm	lr
   if( !fat_check_device() )
8000a1b2:	f0 1f 00 0a 	mcall	8000a1d8 <fat_check_mount+0x28>
8000a1b6:	c0 f0       	breq	8000a1d4 <fat_check_mount+0x24>
      return false;
   if (FS_TYPE_FAT_UNM == fs_g_nav_fast.u8_type_fat)
8000a1b8:	48 98       	lddpc	r8,8000a1dc <fat_check_mount+0x2c>
8000a1ba:	11 89       	ld.ub	r9,r8[0x0]
8000a1bc:	30 08       	mov	r8,0
8000a1be:	f0 09 18 00 	cp.b	r9,r8
8000a1c2:	c0 81       	brne	8000a1d2 <fat_check_mount+0x22>
   {
      if( !fat_mount() )
8000a1c4:	f0 1f 00 07 	mcall	8000a1e0 <fat_check_mount+0x30>
8000a1c8:	c0 51       	brne	8000a1d2 <fat_check_mount+0x22>
      {
         fs_g_status = FS_ERR_NO_MOUNT;
8000a1ca:	30 e9       	mov	r9,14
8000a1cc:	48 68       	lddpc	r8,8000a1e4 <fat_check_mount+0x34>
8000a1ce:	b0 89       	st.b	r8[0x0],r9
         return false;
8000a1d0:	d8 02       	popm	pc
8000a1d2:	30 1c       	mov	r12,1
      }
   }
   return true;
}
8000a1d4:	d8 02       	popm	pc
8000a1d6:	00 00       	add	r0,r0
8000a1d8:	80 00       	ld.sh	r0,r0[0x0]
8000a1da:	a0 bc       	st.b	r0[0x3],r12
8000a1dc:	00 00       	add	r0,r0
8000a1de:	0c 64       	and	r4,r6
8000a1e0:	80 00       	ld.sh	r0,r0[0x0]
8000a1e2:	a3 8c       	lsr	r12,0x2
8000a1e4:	00 00       	add	r0,r0
8000a1e6:	0c 68       	and	r8,r6

8000a1e8 <fat_check_mount_select>:
//!
//! @return    true  partition mounted and a file is selected
//! @return    false otherwise
//!
bool  fat_check_mount_select( void )
{
8000a1e8:	d4 01       	pushm	lr
   if( !fat_check_mount() )
8000a1ea:	f0 1f 00 04 	mcall	8000a1f8 <fat_check_mount_select+0x10>
8000a1ee:	c0 30       	breq	8000a1f4 <fat_check_mount_select+0xc>
      return false;
   return fat_check_select();
8000a1f0:	f0 1f 00 03 	mcall	8000a1fc <fat_check_mount_select+0x14>
}
8000a1f4:	d8 02       	popm	pc
8000a1f6:	00 00       	add	r0,r0
8000a1f8:	80 00       	ld.sh	r0,r0[0x0]
8000a1fa:	a1 b0       	sbr	r0,0x1
8000a1fc:	80 00       	ld.sh	r0,r0[0x0]
8000a1fe:	8f 98       	st.w	r7[0x24],r8

8000a200 <fat_check_mount_select_open>:
//!
//! @return    true  partition mounted and a file is opened
//! @return    false otherwise
//!
bool  fat_check_mount_select_open( void )
{
8000a200:	d4 01       	pushm	lr
   if( !fat_check_mount() )
8000a202:	f0 1f 00 06 	mcall	8000a218 <fat_check_mount_select_open+0x18>
8000a206:	c0 70       	breq	8000a214 <fat_check_mount_select_open+0x14>
      return false;
   if( !fat_check_select() )
8000a208:	f0 1f 00 05 	mcall	8000a21c <fat_check_mount_select_open+0x1c>
8000a20c:	c0 40       	breq	8000a214 <fat_check_mount_select_open+0x14>
      return false;
   return fat_check_open();
8000a20e:	f0 1f 00 05 	mcall	8000a220 <fat_check_mount_select_open+0x20>
8000a212:	d8 02       	popm	pc
8000a214:	d8 0a       	popm	pc,r12=0
8000a216:	00 00       	add	r0,r0
8000a218:	80 00       	ld.sh	r0,r0[0x0]
8000a21a:	a1 b0       	sbr	r0,0x1
8000a21c:	80 00       	ld.sh	r0,r0[0x0]
8000a21e:	8f 98       	st.w	r7[0x24],r8
8000a220:	80 00       	ld.sh	r0,r0[0x0]
8000a222:	8f 78       	st.w	r7[0x1c],r8

8000a224 <fat_check_mount_select_noopen>:
//!
//! @return    true  partition mounted and no file is opened and a file is selected
//! @return    false otherwise
//!
bool  fat_check_mount_select_noopen( void )
{
8000a224:	d4 01       	pushm	lr
   if( !fat_check_mount() )
8000a226:	f0 1f 00 06 	mcall	8000a23c <fat_check_mount_select_noopen+0x18>
8000a22a:	c0 70       	breq	8000a238 <fat_check_mount_select_noopen+0x14>
      return false;
   if( !fat_check_select() )
8000a22c:	f0 1f 00 05 	mcall	8000a240 <fat_check_mount_select_noopen+0x1c>
8000a230:	c0 40       	breq	8000a238 <fat_check_mount_select_noopen+0x14>
      return false;
   return fat_check_noopen();
8000a232:	f0 1f 00 05 	mcall	8000a244 <fat_check_mount_select_noopen+0x20>
8000a236:	d8 02       	popm	pc
8000a238:	d8 0a       	popm	pc,r12=0
8000a23a:	00 00       	add	r0,r0
8000a23c:	80 00       	ld.sh	r0,r0[0x0]
8000a23e:	a1 b0       	sbr	r0,0x1
8000a240:	80 00       	ld.sh	r0,r0[0x0]
8000a242:	8f 98       	st.w	r7[0x24],r8
8000a244:	80 00       	ld.sh	r0,r0[0x0]
8000a246:	a1 74       	lsl	r4,0x1

8000a248 <fat_check_mount_noopen>:
//!
//! @return    true  partition mounted and no file is opened
//! @return    false otherwise
//!
bool  fat_check_mount_noopen( void )
{
8000a248:	d4 01       	pushm	lr
   if( !fat_check_mount() )
8000a24a:	f0 1f 00 04 	mcall	8000a258 <fat_check_mount_noopen+0x10>
8000a24e:	c0 30       	breq	8000a254 <fat_check_mount_noopen+0xc>
      return false;
   return fat_check_noopen();
8000a250:	f0 1f 00 03 	mcall	8000a25c <fat_check_mount_noopen+0x14>
}
8000a254:	d8 02       	popm	pc
8000a256:	00 00       	add	r0,r0
8000a258:	80 00       	ld.sh	r0,r0[0x0]
8000a25a:	a1 b0       	sbr	r0,0x1
8000a25c:	80 00       	ld.sh	r0,r0[0x0]
8000a25e:	a1 74       	lsl	r4,0x1

8000a260 <fat_clear_info_fat_mod>:
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
//! This function clears the cache information about FAT modifications
//!
void  fat_clear_info_fat_mod( void )
{
   fs_g_u32_first_mod_fat = 0xFFFFFFFF;
8000a260:	3f f9       	mov	r9,-1
8000a262:	48 48       	lddpc	r8,8000a270 <fat_clear_info_fat_mod+0x10>
8000a264:	91 09       	st.w	r8[0x0],r9
   fs_g_u32_last_mod_fat = 0;
8000a266:	30 09       	mov	r9,0
8000a268:	48 38       	lddpc	r8,8000a274 <fat_clear_info_fat_mod+0x14>
8000a26a:	91 09       	st.w	r8[0x0],r9
}
8000a26c:	5e fc       	retal	r12
8000a26e:	00 00       	add	r0,r0
8000a270:	00 00       	add	r0,r0
8000a272:	0c 4c       	or	r12,r6
8000a274:	00 00       	add	r0,r0
8000a276:	0a 14       	sub	r4,r5

8000a278 <fat_update_fat2>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_update_fat2( void )
{
8000a278:	eb cd 40 fc 	pushm	r2-r7,lr
  while( fs_g_u32_first_mod_fat <= fs_g_u32_last_mod_fat )
8000a27c:	49 68       	lddpc	r8,8000a2d4 <fat_update_fat2+0x5c>
8000a27e:	70 08       	ld.w	r8,r8[0x0]
8000a280:	49 69       	lddpc	r9,8000a2d8 <fat_update_fat2+0x60>
8000a282:	72 09       	ld.w	r9,r9[0x0]
8000a284:	12 38       	cp.w	r8,r9
8000a286:	e0 8b 00 25 	brhi	8000a2d0 <fat_update_fat2+0x58>
  {
     // Compute the modification position of FAT 1
     fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + fs_g_u32_first_mod_fat;
8000a28a:	49 55       	lddpc	r5,8000a2dc <fat_update_fat2+0x64>
8000a28c:	49 57       	lddpc	r7,8000a2e0 <fat_update_fat2+0x68>
     // Read FAT1
      if( !fat_cache_read_sector( true ))
8000a28e:	30 13       	mov	r3,1
         return false;
     // Compute the modification position of FAT 2
     fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + (fs_g_u32_first_mod_fat + fs_g_nav.u32_fat_size);
8000a290:	49 16       	lddpc	r6,8000a2d4 <fat_update_fat2+0x5c>
     // Init the sector FAT2 with the previous sector of the FAT1
     if( !fat_cache_read_sector( false ))
8000a292:	30 02       	mov	r2,0
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_update_fat2( void )
{
  while( fs_g_u32_first_mod_fat <= fs_g_u32_last_mod_fat )
8000a294:	49 14       	lddpc	r4,8000a2d8 <fat_update_fat2+0x60>
  {
     // Compute the modification position of FAT 1
     fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + fs_g_u32_first_mod_fat;
8000a296:	6e 49       	ld.w	r9,r7[0x10]
8000a298:	12 08       	add	r8,r9
8000a29a:	8b 08       	st.w	r5[0x0],r8
     // Read FAT1
      if( !fat_cache_read_sector( true ))
8000a29c:	06 9c       	mov	r12,r3
8000a29e:	f0 1f 00 12 	mcall	8000a2e4 <fat_update_fat2+0x6c>
8000a2a2:	c1 50       	breq	8000a2cc <fat_update_fat2+0x54>
         return false;
     // Compute the modification position of FAT 2
     fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + (fs_g_u32_first_mod_fat + fs_g_nav.u32_fat_size);
8000a2a4:	6e 19       	ld.w	r9,r7[0x4]
8000a2a6:	6e 48       	ld.w	r8,r7[0x10]
8000a2a8:	f2 08 00 08 	add	r8,r9,r8
8000a2ac:	6c 09       	ld.w	r9,r6[0x0]
8000a2ae:	12 08       	add	r8,r9
8000a2b0:	8b 08       	st.w	r5[0x0],r8
     // Init the sector FAT2 with the previous sector of the FAT1
     if( !fat_cache_read_sector( false ))
8000a2b2:	04 9c       	mov	r12,r2
8000a2b4:	f0 1f 00 0c 	mcall	8000a2e4 <fat_update_fat2+0x6c>
8000a2b8:	c0 a0       	breq	8000a2cc <fat_update_fat2+0x54>
         return false;
     // Flag the sector FAT2 like modify
     fat_cache_mark_sector_as_dirty();
8000a2ba:	f0 1f 00 0c 	mcall	8000a2e8 <fat_update_fat2+0x70>
     fs_g_u32_first_mod_fat++;
8000a2be:	6c 08       	ld.w	r8,r6[0x0]
8000a2c0:	2f f8       	sub	r8,-1
8000a2c2:	8d 08       	st.w	r6[0x0],r8
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_update_fat2( void )
{
  while( fs_g_u32_first_mod_fat <= fs_g_u32_last_mod_fat )
8000a2c4:	68 09       	ld.w	r9,r4[0x0]
8000a2c6:	10 39       	cp.w	r9,r8
8000a2c8:	ce 72       	brcc	8000a296 <fat_update_fat2+0x1e>
8000a2ca:	c0 38       	rjmp	8000a2d0 <fat_update_fat2+0x58>
8000a2cc:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
8000a2d0:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
8000a2d4:	00 00       	add	r0,r0
8000a2d6:	0c 4c       	or	r12,r6
8000a2d8:	00 00       	add	r0,r0
8000a2da:	0a 14       	sub	r4,r5
8000a2dc:	00 00       	add	r0,r0
8000a2de:	09 d4       	ld.ub	r4,r4[0x5]
8000a2e0:	00 00       	add	r0,r0
8000a2e2:	0c 18       	sub	r8,r6
8000a2e4:	80 00       	ld.sh	r0,r0[0x0]
8000a2e6:	99 34       	st.w	r12[0xc],r4
8000a2e8:	80 00       	ld.sh	r0,r0[0x0]
8000a2ea:	97 14       	st.w	r11[0x4],r4

8000a2ec <fat_write_fat32_FSInfo>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_write_fat32_FSInfo( uint32_t u32_nb_free_cluster )
{
8000a2ec:	eb cd 40 c0 	pushm	r6-r7,lr
8000a2f0:	20 1d       	sub	sp,4
8000a2f2:	50 0c       	stdsp	sp[0x0],r12
   // Init sector
   fs_gu32_addrsector = fs_g_nav.u32_ptr_fat - fs_g_nav.u16_offset_FSInfo;
8000a2f4:	49 c8       	lddpc	r8,8000a364 <fat_write_fat32_FSInfo+0x78>
8000a2f6:	90 c9       	ld.uh	r9,r8[0x8]
8000a2f8:	70 4a       	ld.w	r10,r8[0x10]
8000a2fa:	49 c8       	lddpc	r8,8000a368 <fat_write_fat32_FSInfo+0x7c>
8000a2fc:	12 1a       	sub	r10,r9
8000a2fe:	91 0a       	st.w	r8[0x0],r10

   if( !fat_cache_read_sector( false ))
8000a300:	30 0c       	mov	r12,0
8000a302:	f0 1f 00 1b 	mcall	8000a36c <fat_write_fat32_FSInfo+0x80>
8000a306:	c2 c0       	breq	8000a35e <fat_write_fat32_FSInfo+0x72>
      return false;
   fat_cache_mark_sector_as_dirty();
8000a308:	f0 1f 00 1a 	mcall	8000a370 <fat_write_fat32_FSInfo+0x84>
   fat_cache_clear();
8000a30c:	f0 1f 00 1a 	mcall	8000a374 <fat_write_fat32_FSInfo+0x88>

   // Fill sector
   // offset 00-04, This lead signature
   memcpy_code2ram( &fs_g_sector[0], const_FSI_LeadSig, sizeof(const_FSI_LeadSig) );
8000a310:	49 a7       	lddpc	r7,8000a378 <fat_write_fat32_FSInfo+0x8c>
8000a312:	30 46       	mov	r6,4
8000a314:	0c 9a       	mov	r10,r6
8000a316:	49 ab       	lddpc	r11,8000a37c <fat_write_fat32_FSInfo+0x90>
8000a318:	0e 9c       	mov	r12,r7
8000a31a:	f0 1f 00 1a 	mcall	8000a380 <fat_write_fat32_FSInfo+0x94>
   // offset 004-483, reserved (fill with 0)
   // offset 484-487, signature
   memcpy_code2ram( &fs_g_sector[484], const_FSI_StrucSig, sizeof(const_FSI_StrucSig) );
8000a31e:	0c 9a       	mov	r10,r6
8000a320:	49 9b       	lddpc	r11,8000a384 <fat_write_fat32_FSInfo+0x98>
8000a322:	ee cc fe 1c 	sub	r12,r7,-484
8000a326:	f0 1f 00 17 	mcall	8000a380 <fat_write_fat32_FSInfo+0x94>
   // offset 488-491, free cluster count (by default NO value)
   fs_g_sector[488] = LSB0(u32_nb_free_cluster);
8000a32a:	1b b9       	ld.ub	r9,sp[0x3]
8000a32c:	ef 69 01 e8 	st.b	r7[488],r9
   fs_g_sector[489] = LSB1(u32_nb_free_cluster);
8000a330:	1b a9       	ld.ub	r9,sp[0x2]
8000a332:	ef 69 01 e9 	st.b	r7[489],r9
   fs_g_sector[490] = LSB2(u32_nb_free_cluster);
8000a336:	1b 99       	ld.ub	r9,sp[0x1]
8000a338:	ef 69 01 ea 	st.b	r7[490],r9
   fs_g_sector[491] = LSB3(u32_nb_free_cluster);
8000a33c:	1b 88       	ld.ub	r8,sp[0x0]
8000a33e:	ef 68 01 eb 	st.b	r7[491],r8
   // offset 492-495, indicates the cluster number at which the driver should start looking for free clusters (by default NO value)
   memset( &fs_g_sector[492] , 0xFF , 4 );
8000a342:	0c 9a       	mov	r10,r6
8000a344:	e0 6b 00 ff 	mov	r11,255
8000a348:	ee cc fe 14 	sub	r12,r7,-492
8000a34c:	f0 1f 00 0f 	mcall	8000a388 <fat_write_fat32_FSInfo+0x9c>
   // offset 496-509, reserved (fill with 0)
   // offset 510-511, Signature
   fs_g_sector[510] = FS_BR_SIGNATURE_LOW;
8000a350:	35 58       	mov	r8,85
8000a352:	ef 68 01 fe 	st.b	r7[510],r8
   fs_g_sector[511] = FS_BR_SIGNATURE_HIGH;
8000a356:	3a a8       	mov	r8,-86
8000a358:	ef 68 01 ff 	st.b	r7[511],r8
8000a35c:	30 1c       	mov	r12,1
   return true;
}
8000a35e:	2f fd       	sub	sp,-4
8000a360:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000a364:	00 00       	add	r0,r0
8000a366:	0c 18       	sub	r8,r6
8000a368:	00 00       	add	r0,r0
8000a36a:	09 d4       	ld.ub	r4,r4[0x5]
8000a36c:	80 00       	ld.sh	r0,r0[0x0]
8000a36e:	99 34       	st.w	r12[0xc],r4
8000a370:	80 00       	ld.sh	r0,r0[0x0]
8000a372:	97 14       	st.w	r11[0x4],r4
8000a374:	80 00       	ld.sh	r0,r0[0x0]
8000a376:	99 1c       	st.w	r12[0x4],r12
8000a378:	00 00       	add	r0,r0
8000a37a:	0a 18       	sub	r8,r5
8000a37c:	80 01       	ld.sh	r1,r0[0x0]
8000a37e:	62 60       	ld.w	r0,r1[0x18]
8000a380:	80 00       	ld.sh	r0,r0[0x0]
8000a382:	c6 38       	rjmp	8000a448 <fat_mount+0xbc>
8000a384:	80 01       	ld.sh	r1,r0[0x0]
8000a386:	62 64       	ld.w	r4,r1[0x18]
8000a388:	80 00       	ld.sh	r0,r0[0x0]
8000a38a:	c7 80       	breq	8000a47a <fat_mount+0xee>

8000a38c <fat_mount>:
//! If the FS_MULTI_PARTITION option is disabled
//! then the mount routine selects the first partition supported by file system. <br>
//! @endverbatim
//!
bool  fat_mount( void )
{
8000a38c:	d4 31       	pushm	r0-r7,lr
8000a38e:	20 3d       	sub	sp,12
   uint8_t  u8_tmp;
   uint16_t u16_tmp;
   uint32_t u32_tmp;

   // Select the root directory
   fs_g_nav.u32_cluster_sel_dir   = 0;
8000a390:	30 07       	mov	r7,0
8000a392:	fe f8 02 d2 	ld.w	r8,pc[722]
8000a396:	91 87       	st.w	r8[0x20],r7
   // No selected file
   fat_clear_entry_info_and_ptr();
8000a398:	f0 1f 00 b4 	mcall	8000a668 <fat_mount+0x2dc>

   fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM;
8000a39c:	fe f8 02 d0 	ld.w	r8,pc[720]
8000a3a0:	b0 87       	st.b	r8[0x0],r7
   fs_gu32_addrsector = 0;    // Start read at the beginning of memory
8000a3a2:	fe f8 02 ce 	ld.w	r8,pc[718]
8000a3a6:	91 07       	st.w	r8[0x0],r7

   // Check if the drive is available
   if( !fat_check_device() )
8000a3a8:	f0 1f 00 b3 	mcall	8000a674 <fat_mount+0x2e8>
8000a3ac:	e0 80 01 58 	breq	8000a65c <fat_mount+0x2d0>
      // Read one sector
      if( !fat_cache_read_sector( true ))
         return false;

      // Check PBR/MBR signature
      if ( (fs_g_sector[510] != FS_BR_SIGNATURE_LOW  )
8000a3b0:	fe f5 02 c8 	ld.w	r5,pc[712]
      {
         fs_g_status = FS_ERR_NO_FORMAT;
         return false;
      }

      if ( 0 == fs_gu32_addrsector )
8000a3b4:	ea c8 fe 42 	sub	r8,r5,-446
8000a3b8:	50 08       	stdsp	sp[0x0],r8
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
         {
            // The first sector must be a MBR, then check the partition entry in the MBR
            if ( ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_BOOTABLE             )||
8000a3ba:	38 04       	mov	r4,-128
8000a3bc:	30 46       	mov	r6,4
      return false;

   while( 1 )  // Search a valid partition
   {
      // Read one sector
      if( !fat_cache_read_sector( true ))
8000a3be:	30 1c       	mov	r12,1
8000a3c0:	f0 1f 00 af 	mcall	8000a67c <fat_mount+0x2f0>
8000a3c4:	e0 80 01 4c 	breq	8000a65c <fat_mount+0x2d0>
         return false;

      // Check PBR/MBR signature
      if ( (fs_g_sector[510] != FS_BR_SIGNATURE_LOW  )
8000a3c8:	eb 39 01 fe 	ld.ub	r9,r5[510]
8000a3cc:	35 58       	mov	r8,85
8000a3ce:	f0 09 18 00 	cp.b	r9,r8
8000a3d2:	c0 d0       	breq	8000a3ec <fat_mount+0x60>
      &&   (fs_g_sector[511] != FS_BR_SIGNATURE_HIGH ) )
8000a3d4:	eb 39 01 ff 	ld.ub	r9,r5[511]
8000a3d8:	3a a8       	mov	r8,-86
8000a3da:	f0 09 18 00 	cp.b	r9,r8
8000a3de:	c0 70       	breq	8000a3ec <fat_mount+0x60>
      {
         fs_g_status = FS_ERR_NO_FORMAT;
8000a3e0:	30 29       	mov	r9,2
8000a3e2:	fe f8 02 9e 	ld.w	r8,pc[670]
8000a3e6:	b0 89       	st.b	r8[0x0],r9
8000a3e8:	30 0c       	mov	r12,0
         return false;
8000a3ea:	c3 a9       	rjmp	8000a65e <fat_mount+0x2d2>
      }

      if ( 0 == fs_gu32_addrsector )
8000a3ec:	fe f8 02 84 	ld.w	r8,pc[644]
8000a3f0:	70 08       	ld.w	r8,r8[0x0]
8000a3f2:	58 08       	cp.w	r8,0
8000a3f4:	c5 21       	brne	8000a498 <fat_mount+0x10c>
8000a3f6:	40 08       	lddsp	r8,sp[0x0]
8000a3f8:	30 0a       	mov	r10,0
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
         {
            // The first sector must be a MBR, then check the partition entry in the MBR
            if ( ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_BOOTABLE             )||
8000a3fa:	30 1e       	mov	lr,1
8000a3fc:	30 63       	mov	r3,6
8000a3fe:	30 e2       	mov	r2,14
8000a400:	30 b1       	mov	r1,11
8000a402:	30 c0       	mov	r0,12
8000a404:	11 89       	ld.ub	r9,r8[0x0]
8000a406:	e8 09 18 00 	cp.b	r9,r4
8000a40a:	5f 0b       	sreq	r11
8000a40c:	ee 09 18 00 	cp.b	r9,r7
8000a410:	5f 09       	sreq	r9
8000a412:	f7 e9 10 09 	or	r9,r11,r9
8000a416:	ee 09 18 00 	cp.b	r9,r7
8000a41a:	c1 90       	breq	8000a44c <fat_mount+0xc0>
                  (fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_NO_BOOTABLE          )  )
            &&   ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+4] == FS_PART_TYPE_FAT12           )||
8000a41c:	11 c9       	ld.ub	r9,r8[0x4]
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
         {
            // The first sector must be a MBR, then check the partition entry in the MBR
            if ( ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_BOOTABLE             )||
8000a41e:	fc 09 18 00 	cp.b	r9,lr
8000a422:	5f 0c       	sreq	r12
8000a424:	ec 09 18 00 	cp.b	r9,r6
8000a428:	5f 0b       	sreq	r11
8000a42a:	f9 eb 10 0b 	or	r11,r12,r11
8000a42e:	ee 0b 18 00 	cp.b	r11,r7
8000a432:	c1 41       	brne	8000a45a <fat_mount+0xce>
8000a434:	e6 09 18 00 	cp.b	r9,r3
8000a438:	c1 10       	breq	8000a45a <fat_mount+0xce>
8000a43a:	e4 09 18 00 	cp.b	r9,r2
8000a43e:	c0 e0       	breq	8000a45a <fat_mount+0xce>
8000a440:	e2 09 18 00 	cp.b	r9,r1
8000a444:	c0 b0       	breq	8000a45a <fat_mount+0xce>
8000a446:	e0 09 18 00 	cp.b	r9,r0
8000a44a:	c0 80       	breq	8000a45a <fat_mount+0xce>
         //** first sector then check a MBR structure
         // Search the first partition supported
#if (FS_MULTI_PARTITION == true)
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
8000a44c:	2f fa       	sub	r10,-1
8000a44e:	5c 5a       	castu.b	r10
8000a450:	2f 08       	sub	r8,-16
8000a452:	ec 0a 18 00 	cp.b	r10,r6
8000a456:	cd 71       	brne	8000a404 <fat_mount+0x78>
8000a458:	c2 08       	rjmp	8000a498 <fat_mount+0x10c>
#else
               break;
#endif
            }
         }
         if( u8_tmp != 4 )
8000a45a:	ec 0a 18 00 	cp.b	r10,r6
8000a45e:	c1 d0       	breq	8000a498 <fat_mount+0x10c>
         {
            // Partition found -> Get partition position (unit sector) at offset 8
            LSB0(fs_gu32_addrsector) = fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+8];
8000a460:	fe f3 02 10 	ld.w	r3,pc[528]
8000a464:	a5 6a       	lsl	r10,0x4
8000a466:	f4 ca fe 42 	sub	r10,r10,-446
8000a46a:	ea 0a 00 0a 	add	r10,r5,r10
8000a46e:	f5 38 00 08 	ld.ub	r8,r10[8]
8000a472:	a6 b8       	st.b	r3[0x3],r8
            LSB1(fs_gu32_addrsector) = fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+9];
8000a474:	f5 38 00 09 	ld.ub	r8,r10[9]
8000a478:	a6 a8       	st.b	r3[0x2],r8
            LSB2(fs_gu32_addrsector) = fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+10];
8000a47a:	f5 38 00 0a 	ld.ub	r8,r10[10]
8000a47e:	a6 98       	st.b	r3[0x1],r8
            LSB3(fs_gu32_addrsector) = fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+11];
8000a480:	f5 38 00 0b 	ld.ub	r8,r10[11]
8000a484:	a6 88       	st.b	r3[0x0],r8
            fs_gu32_addrsector *= mem_sector_size( fs_g_nav.u8_lun );
8000a486:	4f 88       	lddpc	r8,8000a664 <fat_mount+0x2d8>
8000a488:	11 8c       	ld.ub	r12,r8[0x0]
8000a48a:	f0 1f 00 7f 	mcall	8000a684 <fat_mount+0x2f8>
8000a48e:	66 08       	ld.w	r8,r3[0x0]
8000a490:	f8 08 02 48 	mul	r8,r12,r8
8000a494:	87 08       	st.w	r3[0x0],r8
         break;   // valid PBR found
      }
      // PBR not found
      fs_g_status = FS_ERR_NO_PART;
      return false;
   }
8000a496:	c9 4b       	rjmp	8000a3be <fat_mount+0x32>
         }
#endif
      }

      //** Check a PBR structure
      if ( (fs_g_sector[0] == 0xEB) &&          // PBR Byte 0
8000a498:	4f 88       	lddpc	r8,8000a678 <fat_mount+0x2ec>
8000a49a:	11 89       	ld.ub	r9,r8[0x0]
8000a49c:	3e b8       	mov	r8,-21
8000a49e:	f0 09 18 00 	cp.b	r9,r8
8000a4a2:	c0 f1       	brne	8000a4c0 <fat_mount+0x134>
           (fs_g_sector[2] == 0x90) &&          // PBR Byte 2
8000a4a4:	4f 58       	lddpc	r8,8000a678 <fat_mount+0x2ec>
8000a4a6:	11 a9       	ld.ub	r9,r8[0x2]
8000a4a8:	39 08       	mov	r8,-112
8000a4aa:	f0 09 18 00 	cp.b	r9,r8
8000a4ae:	c0 91       	brne	8000a4c0 <fat_mount+0x134>
           ((fs_g_sector[21] & 0xF0) == 0xF0) ) // PBR Byte 21 : Media byte
8000a4b0:	4f 28       	lddpc	r8,8000a678 <fat_mount+0x2ec>
8000a4b2:	f1 38 00 15 	ld.ub	r8,r8[21]
8000a4b6:	e2 18 00 f0 	andl	r8,0xf0,COH
8000a4ba:	e0 48 00 f0 	cp.w	r8,240
8000a4be:	c0 60       	breq	8000a4ca <fat_mount+0x13e>
      {
         break;   // valid PBR found
      }
      // PBR not found
      fs_g_status = FS_ERR_NO_PART;
8000a4c0:	30 39       	mov	r9,3
8000a4c2:	4f 08       	lddpc	r8,8000a680 <fat_mount+0x2f4>
8000a4c4:	b0 89       	st.b	r8[0x0],r9
8000a4c6:	30 0c       	mov	r12,0
      return false;
8000a4c8:	cc b8       	rjmp	8000a65e <fat_mount+0x2d2>
   }

   fs_g_status = FS_ERR_NO_SUPPORT_PART;  // by default partition no supported
8000a4ca:	30 49       	mov	r9,4
8000a4cc:	4e d8       	lddpc	r8,8000a680 <fat_mount+0x2f4>
8000a4ce:	b0 89       	st.b	r8[0x0],r9

   // Get sector size of File System (unit 512B)
   // To translate from sector disk unit to sector 512B unit
   u8_sector_size = HIGH_16_BPB_BytsPerSec/2;
8000a4d0:	4e aa       	lddpc	r10,8000a678 <fat_mount+0x2ec>
8000a4d2:	f5 39 00 0c 	ld.ub	r9,r10[12]
8000a4d6:	a1 99       	lsr	r9,0x1

   // Read BPB_SecPerClus (unit sector)
   fs_g_nav.u8_BPB_SecPerClus = U8_BPB_SecPerClus * u8_sector_size;
8000a4d8:	f5 38 00 0d 	ld.ub	r8,r10[13]
8000a4dc:	b3 38       	mul	r8,r9
8000a4de:	5c 58       	castu.b	r8
8000a4e0:	4e 1b       	lddpc	r11,8000a664 <fat_mount+0x2d8>
8000a4e2:	b6 98       	st.b	r11[0x1],r8

   //** FAT Type determination (algorithm of "Hardware White Paper FAT")
   // Get FAT size (unit sector)
   u32_tmp=0;
8000a4e4:	30 0b       	mov	r11,0
8000a4e6:	50 1b       	stdsp	sp[0x4],r11
   LSB0( u32_tmp ) = LOW_16_BPB_FATSz16;
8000a4e8:	fa cb ff fc 	sub	r11,sp,-4
8000a4ec:	fa c7 ff f9 	sub	r7,sp,-7
8000a4f0:	f5 3c 00 16 	ld.ub	r12,r10[22]
8000a4f4:	ae 8c       	st.b	r7[0x0],r12
   LSB1( u32_tmp ) = HIGH_16_BPB_FATSz16;
8000a4f6:	fa ce ff fa 	sub	lr,sp,-6
8000a4fa:	f5 3a 00 17 	ld.ub	r10,r10[23]
8000a4fe:	bc 8a       	st.b	lr[0x0],r10
   if ( 0==u32_tmp )
8000a500:	40 1a       	lddsp	r10,sp[0x4]
8000a502:	58 0a       	cp.w	r10,0
8000a504:	c0 e1       	brne	8000a520 <fat_mount+0x194>
   {
      LSB0( u32_tmp ) = LOW0_32_BPB_FATSz32;
8000a506:	4d da       	lddpc	r10,8000a678 <fat_mount+0x2ec>
8000a508:	f5 3c 00 24 	ld.ub	r12,r10[36]
8000a50c:	ae 8c       	st.b	r7[0x0],r12
      LSB1( u32_tmp ) = LOW1_32_BPB_FATSz32;
8000a50e:	f5 3c 00 25 	ld.ub	r12,r10[37]
8000a512:	bc 8c       	st.b	lr[0x0],r12
      LSB2( u32_tmp ) = LOW2_32_BPB_FATSz32;
8000a514:	f5 3c 00 26 	ld.ub	r12,r10[38]
8000a518:	b6 9c       	st.b	r11[0x1],r12
      LSB3( u32_tmp ) = LOW3_32_BPB_FATSz32;
8000a51a:	f5 3a 00 27 	ld.ub	r10,r10[39]
8000a51e:	b6 8a       	st.b	r11[0x0],r10
   }
   fs_g_nav.u32_fat_size = u32_tmp * u8_sector_size;
8000a520:	12 95       	mov	r5,r9
8000a522:	40 1c       	lddsp	r12,sp[0x4]
8000a524:	f2 0c 02 4c 	mul	r12,r9,r12
8000a528:	4c fa       	lddpc	r10,8000a664 <fat_mount+0x2d8>
8000a52a:	95 1c       	st.w	r10[0x4],r12

   // Get total count of sectors in partition
   if ( (0==LOW_16_BPB_TotSec16) && (0==HIGH_16_BPB_TotSec16) )
8000a52c:	4d 3a       	lddpc	r10,8000a678 <fat_mount+0x2ec>
8000a52e:	f5 3a 00 13 	ld.ub	r10,r10[19]
8000a532:	58 0a       	cp.w	r10,0
8000a534:	c1 61       	brne	8000a560 <fat_mount+0x1d4>
8000a536:	4d 16       	lddpc	r6,8000a678 <fat_mount+0x2ec>
8000a538:	ed 34 00 14 	ld.ub	r4,r6[20]
8000a53c:	30 06       	mov	r6,0
8000a53e:	ec 04 18 00 	cp.b	r4,r6
8000a542:	c0 f1       	brne	8000a560 <fat_mount+0x1d4>
   {
      LSB0( u32_tmp ) = LOW0_32_BPB_TotSec32;
8000a544:	4c da       	lddpc	r10,8000a678 <fat_mount+0x2ec>
8000a546:	f5 36 00 20 	ld.ub	r6,r10[32]
8000a54a:	ae 86       	st.b	r7[0x0],r6
      LSB1( u32_tmp ) = LOW1_32_BPB_TotSec32;
8000a54c:	f5 37 00 21 	ld.ub	r7,r10[33]
8000a550:	bc 87       	st.b	lr[0x0],r7
      LSB2( u32_tmp ) = LOW2_32_BPB_TotSec32;
8000a552:	f5 3e 00 22 	ld.ub	lr,r10[34]
8000a556:	b6 9e       	st.b	r11[0x1],lr
      LSB3( u32_tmp ) = LOW3_32_BPB_TotSec32;
8000a558:	f5 3a 00 23 	ld.ub	r10,r10[35]
8000a55c:	b6 8a       	st.b	r11[0x0],r10
      LSB3( u32_tmp ) = LOW3_32_BPB_FATSz32;
   }
   fs_g_nav.u32_fat_size = u32_tmp * u8_sector_size;

   // Get total count of sectors in partition
   if ( (0==LOW_16_BPB_TotSec16) && (0==HIGH_16_BPB_TotSec16) )
8000a55e:	c0 98       	rjmp	8000a570 <fat_mount+0x1e4>
      LSB2( u32_tmp ) = LOW2_32_BPB_TotSec32;
      LSB3( u32_tmp ) = LOW3_32_BPB_TotSec32;
   }
   else
   {
      LSB0( u32_tmp ) = LOW_16_BPB_TotSec16;
8000a560:	ae 8a       	st.b	r7[0x0],r10
      LSB1( u32_tmp ) = HIGH_16_BPB_TotSec16;
8000a562:	4c 6a       	lddpc	r10,8000a678 <fat_mount+0x2ec>
8000a564:	f5 3a 00 14 	ld.ub	r10,r10[20]
8000a568:	bc 8a       	st.b	lr[0x0],r10
      LSB2( u32_tmp ) = 0;
8000a56a:	30 0a       	mov	r10,0
8000a56c:	b6 9a       	st.b	r11[0x1],r10
      LSB3( u32_tmp ) = 0;
8000a56e:	b6 8a       	st.b	r11[0x0],r10
   }
   u32_tmp *= u8_sector_size;   // Translate from sector disk unit to sector 512B unit
8000a570:	40 14       	lddsp	r4,sp[0x4]

   // Compute the offset (unit 512B) between the end of FAT (beginning of root dir in FAT1x) and the beginning of PBR
   fs_g_nav.rootdir.seg.u16_pos = FS_NB_FAT * (uint16_t)fs_g_nav.u32_fat_size;
8000a572:	4b da       	lddpc	r10,8000a664 <fat_mount+0x2d8>
8000a574:	f8 0b 15 01 	lsl	r11,r12,0x1
8000a578:	f5 5b 00 18 	st.h	r10[24],r11

   // Compute the root directory size (unit sector), for FAT32 is always 0
   LSB( u16_tmp ) = LOW_16_BPB_RootEntCnt;
8000a57c:	fa c6 ff f6 	sub	r6,sp,-10
8000a580:	fa c7 ff f4 	sub	r7,sp,-12
8000a584:	4b db       	lddpc	r11,8000a678 <fat_mount+0x2ec>
8000a586:	f7 3e 00 11 	ld.ub	lr,r11[17]
8000a58a:	0e fe       	st.b	--r7,lr
   MSB( u16_tmp ) = HIGH_16_BPB_RootEntCnt;
8000a58c:	f7 3e 00 12 	ld.ub	lr,r11[18]
8000a590:	ac 8e       	st.b	r6[0x0],lr
   fs_g_nav.rootdir.seg.u16_size = ((u16_tmp * FS_SIZE_FILE_ENTRY) + ((FS_512B*u8_sector_size)-1)) / (FS_512B*u8_sector_size);
   fs_g_nav.rootdir.seg.u16_size *= u8_sector_size;
8000a592:	f2 03 15 04 	lsl	r3,r9,0x4
8000a596:	9a de       	ld.uh	lr,sp[0xa]
8000a598:	e6 0e 00 0e 	add	lr,r3,lr
8000a59c:	a5 7e       	lsl	lr,0x5
8000a59e:	20 1e       	sub	lr,1
8000a5a0:	f2 03 15 09 	lsl	r3,r9,0x9
8000a5a4:	fc 03 0c 02 	divs	r2,lr,r3
8000a5a8:	e4 09 02 4e 	mul	lr,r2,r9
8000a5ac:	f5 5e 00 1a 	st.h	r10[26],lr

   // Get number of reserved sector
   LSB( u16_tmp ) = LOW_16_BPB_ResvSecCnt;
8000a5b0:	f7 33 00 0e 	ld.ub	r3,r11[14]
8000a5b4:	ae 83       	st.b	r7[0x0],r3
   MSB( u16_tmp ) = HIGH_16_BPB_ResvSecCnt;
8000a5b6:	f7 37 00 0f 	ld.ub	r7,r11[15]
8000a5ba:	ac 87       	st.b	r6[0x0],r7
   // Get FSInfo position
   fs_g_nav.u16_offset_FSInfo = (u16_tmp-LOW_16_BPB_FSInfo)*u8_sector_size;
8000a5bc:	9a 57       	ld.sh	r7,sp[0xa]
8000a5be:	f7 3b 00 30 	ld.ub	r11,r11[48]
8000a5c2:	0e 96       	mov	r6,r7
8000a5c4:	ee 0b 01 0b 	sub	r11,r7,r11
8000a5c8:	b3 3b       	mul	r11,r9
8000a5ca:	b4 4b       	st.h	r10[0x8],r11
   u16_tmp *= u8_sector_size; // number of reserved sector translated in unit 512B

   // Compute the FAT address (unit 512B)
   fs_g_nav.u32_ptr_fat = fs_gu32_addrsector + u16_tmp;
8000a5cc:	ee 09 02 49 	mul	r9,r7,r9
8000a5d0:	5c 79       	castu.h	r9
8000a5d2:	4a 8b       	lddpc	r11,8000a670 <fat_mount+0x2e4>
8000a5d4:	76 0b       	ld.w	r11,r11[0x0]
8000a5d6:	f2 0b 00 0b 	add	r11,r9,r11
8000a5da:	95 4b       	st.w	r10[0x10],r11

   // Compute the offset (unit 512B) between the first data cluster and the FAT beginning
   fs_g_nav.u32_offset_data = (FS_NB_FAT * fs_g_nav.u32_fat_size) + (uint32_t)fs_g_nav.rootdir.seg.u16_size;
8000a5dc:	5c 7e       	castu.h	lr
8000a5de:	fc 0c 00 1c 	add	r12,lr,r12<<0x1
8000a5e2:	95 5c       	st.w	r10[0x14],r12
   // Compute the data region (clusters space = Total - Sector used) size (unit 512B)
   u32_tmp -= ((uint32_t)u16_tmp + fs_g_nav.u32_offset_data);

   // Compute the count of CLUSTER in the data region
   // !!!Optimization -> u32_CountofCluster (unit 512B)/ fs_g_nav.u8_BPB_SecPerClus (unit 512B & power of 2)
   if (!fs_g_nav.u8_BPB_SecPerClus)
8000a5e4:	58 08       	cp.w	r8,0
8000a5e6:	c3 b0       	breq	8000a65c <fat_mount+0x2d0>

   // Compute the offset (unit 512B) between the first data cluster and the FAT beginning
   fs_g_nav.u32_offset_data = (FS_NB_FAT * fs_g_nav.u32_fat_size) + (uint32_t)fs_g_nav.rootdir.seg.u16_size;

   // Compute the data region (clusters space = Total - Sector used) size (unit 512B)
   u32_tmp -= ((uint32_t)u16_tmp + fs_g_nav.u32_offset_data);
8000a5e8:	a9 35       	mul	r5,r4
8000a5ea:	ea 09 01 09 	sub	r9,r5,r9
8000a5ee:	18 19       	sub	r9,r12
8000a5f0:	50 19       	stdsp	sp[0x4],r9

   // Compute the count of CLUSTER in the data region
   // !!!Optimization -> u32_CountofCluster (unit 512B)/ fs_g_nav.u8_BPB_SecPerClus (unit 512B & power of 2)
   if (!fs_g_nav.u8_BPB_SecPerClus)
     return false;
   for( u8_tmp = fs_g_nav.u8_BPB_SecPerClus; u8_tmp!=1 ; u8_tmp >>= 1 )
8000a5f2:	30 1a       	mov	r10,1
8000a5f4:	f4 08 18 00 	cp.b	r8,r10
8000a5f8:	c0 70       	breq	8000a606 <fat_mount+0x27a>
   {
     u32_tmp  >>= 1;   // This computation round down
8000a5fa:	a1 99       	lsr	r9,0x1

   // Compute the count of CLUSTER in the data region
   // !!!Optimization -> u32_CountofCluster (unit 512B)/ fs_g_nav.u8_BPB_SecPerClus (unit 512B & power of 2)
   if (!fs_g_nav.u8_BPB_SecPerClus)
     return false;
   for( u8_tmp = fs_g_nav.u8_BPB_SecPerClus; u8_tmp!=1 ; u8_tmp >>= 1 )
8000a5fc:	a1 98       	lsr	r8,0x1
8000a5fe:	f4 08 18 00 	cp.b	r8,r10
8000a602:	cf c1       	brne	8000a5fa <fat_mount+0x26e>
8000a604:	50 19       	stdsp	sp[0x4],r9
   {
     u32_tmp  >>= 1;   // This computation round down
   }
   fs_g_nav.u32_CountofCluster = u32_tmp+2; // The total of cluster include the two reserved clusters
8000a606:	40 18       	lddsp	r8,sp[0x4]
8000a608:	f0 ca ff fe 	sub	r10,r8,-2
8000a60c:	49 69       	lddpc	r9,8000a664 <fat_mount+0x2d8>
8000a60e:	93 3a       	st.w	r9[0xc],r10

   // Determine the FAT type
   if (u32_tmp < FS_FAT12_MAX_CLUSTERS)
8000a610:	e0 48 0f f4 	cp.w	r8,4084
8000a614:	e0 8b 00 07 	brhi	8000a622 <fat_mount+0x296>
   {
      // Is FAT 12
#if (FS_FAT_12 == false)
      return false;
#endif
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_12;
8000a618:	30 19       	mov	r9,1
8000a61a:	49 58       	lddpc	r8,8000a66c <fat_mount+0x2e0>
8000a61c:	b0 89       	st.b	r8[0x0],r9
8000a61e:	30 1c       	mov	r12,1
8000a620:	c1 f8       	rjmp	8000a65e <fat_mount+0x2d2>
   } else {
   if (u32_tmp < FS_FAT16_MAX_CLUSTERS)
8000a622:	e0 48 ff f4 	cp.w	r8,65524
8000a626:	e0 8b 00 07 	brhi	8000a634 <fat_mount+0x2a8>
   {
      // Is FAT 16
#if (FS_FAT_16 == false)
      return FS_NO_SUPPORT_PART;
#endif
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_16;
8000a62a:	30 29       	mov	r9,2
8000a62c:	49 08       	lddpc	r8,8000a66c <fat_mount+0x2e0>
8000a62e:	b0 89       	st.b	r8[0x0],r9
8000a630:	30 1c       	mov	r12,1
8000a632:	c1 68       	rjmp	8000a65e <fat_mount+0x2d2>
   } else {
      // Is FAT 32
#if (FS_FAT_32 == false)
      return false;
#endif
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_32;
8000a634:	30 39       	mov	r9,3
8000a636:	48 e8       	lddpc	r8,8000a66c <fat_mount+0x2e0>
8000a638:	b0 89       	st.b	r8[0x0],r9
      // In FAT32, the root dir is like another directory, this one have a cluster list
      // Get the first cluster number of root
      LSB0( fs_g_nav.rootdir.u32_cluster ) = LOW0_32_BPB_RootClus;
8000a63a:	48 b8       	lddpc	r8,8000a664 <fat_mount+0x2d8>
8000a63c:	2e 88       	sub	r8,-24
8000a63e:	48 f9       	lddpc	r9,8000a678 <fat_mount+0x2ec>
8000a640:	f3 3a 00 2c 	ld.ub	r10,r9[44]
8000a644:	b0 ba       	st.b	r8[0x3],r10
      LSB1( fs_g_nav.rootdir.u32_cluster ) = LOW1_32_BPB_RootClus;
8000a646:	f3 3a 00 2d 	ld.ub	r10,r9[45]
8000a64a:	b0 aa       	st.b	r8[0x2],r10
      LSB2( fs_g_nav.rootdir.u32_cluster ) = LOW2_32_BPB_RootClus;
8000a64c:	f3 3a 00 2e 	ld.ub	r10,r9[46]
8000a650:	b0 9a       	st.b	r8[0x1],r10
      LSB3( fs_g_nav.rootdir.u32_cluster ) = LOW3_32_BPB_RootClus;
8000a652:	f3 39 00 2f 	ld.ub	r9,r9[47]
8000a656:	b0 89       	st.b	r8[0x0],r9
8000a658:	30 1c       	mov	r12,1
8000a65a:	c0 28       	rjmp	8000a65e <fat_mount+0x2d2>
8000a65c:	30 0c       	mov	r12,0
   }
   }

   return true;
}
8000a65e:	2f dd       	sub	sp,-12
8000a660:	d8 32       	popm	r0-r7,pc
8000a662:	00 00       	add	r0,r0
8000a664:	00 00       	add	r0,r0
8000a666:	0c 18       	sub	r8,r6
8000a668:	80 00       	ld.sh	r0,r0[0x0]
8000a66a:	92 a0       	ld.uh	r0,r9[0x4]
8000a66c:	00 00       	add	r0,r0
8000a66e:	0c 64       	and	r4,r6
8000a670:	00 00       	add	r0,r0
8000a672:	09 d4       	ld.ub	r4,r4[0x5]
8000a674:	80 00       	ld.sh	r0,r0[0x0]
8000a676:	a0 bc       	st.b	r0[0x3],r12
8000a678:	00 00       	add	r0,r0
8000a67a:	0a 18       	sub	r8,r5
8000a67c:	80 00       	ld.sh	r0,r0[0x0]
8000a67e:	99 34       	st.w	r12[0xc],r4
8000a680:	00 00       	add	r0,r0
8000a682:	0c 68       	and	r8,r6
8000a684:	80 00       	ld.sh	r0,r0[0x0]
8000a686:	b3 5c       	asr	r12,0x13

8000a688 <file_eof>:
//! @return    1     the position is at the end of file
//! @return    0     the position isn't at the end of file
//! @return    FFh   error
//!
uint8_t    file_eof( void )
{
8000a688:	d4 01       	pushm	lr
   if( !fat_check_mount_select_open() )
8000a68a:	f0 1f 00 07 	mcall	8000a6a4 <file_eof+0x1c>
8000a68e:	c0 41       	brne	8000a696 <file_eof+0xe>
8000a690:	e0 6c 00 ff 	mov	r12,255
8000a694:	d8 02       	popm	pc
      return 0xFF;
   return (fs_g_nav_entry.u32_size <= fs_g_nav_entry.u32_pos_in_file );
8000a696:	48 58       	lddpc	r8,8000a6a8 <file_eof+0x20>
8000a698:	70 29       	ld.w	r9,r8[0x8]
8000a69a:	70 38       	ld.w	r8,r8[0xc]
8000a69c:	10 39       	cp.w	r9,r8
8000a69e:	5f 8c       	srls	r12
}
8000a6a0:	d8 02       	popm	pc
8000a6a2:	00 00       	add	r0,r0
8000a6a4:	80 00       	ld.sh	r0,r0[0x0]
8000a6a6:	a2 00       	st.h	r1[0x0],r0
8000a6a8:	00 00       	add	r0,r0
8000a6aa:	09 d8       	ld.ub	r8,r4[0x5]

8000a6ac <file_bof>:
//! @return    1     the position is at the beginning of file
//! @return    0     the position isn't at the beginning of file
//! @return    FFh   error
//!
uint8_t    file_bof( void )
{
8000a6ac:	d4 01       	pushm	lr
   if( !fat_check_mount_select_open() )
8000a6ae:	f0 1f 00 06 	mcall	8000a6c4 <file_bof+0x18>
8000a6b2:	c0 41       	brne	8000a6ba <file_bof+0xe>
8000a6b4:	e0 6c 00 ff 	mov	r12,255
8000a6b8:	d8 02       	popm	pc
      return 0xFF;

   return (0 == fs_g_nav_entry.u32_pos_in_file );
8000a6ba:	48 48       	lddpc	r8,8000a6c8 <file_bof+0x1c>
8000a6bc:	70 38       	ld.w	r8,r8[0xc]
8000a6be:	58 08       	cp.w	r8,0
8000a6c0:	5f 0c       	sreq	r12
}
8000a6c2:	d8 02       	popm	pc
8000a6c4:	80 00       	ld.sh	r0,r0[0x0]
8000a6c6:	a2 00       	st.h	r1[0x0],r0
8000a6c8:	00 00       	add	r0,r0
8000a6ca:	09 d8       	ld.ub	r8,r4[0x5]

8000a6cc <file_seek>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  file_seek( uint32_t u32_pos , uint8_t u8_whence )
{
8000a6cc:	eb cd 40 c0 	pushm	r6-r7,lr
8000a6d0:	18 96       	mov	r6,r12
8000a6d2:	16 97       	mov	r7,r11
   if( !fat_check_mount_select_open())
8000a6d4:	f0 1f 00 28 	mcall	8000a774 <file_seek+0xa8>
8000a6d8:	c4 c0       	breq	8000a770 <file_seek+0xa4>
      return false;

   switch(u8_whence)
8000a6da:	30 18       	mov	r8,1
8000a6dc:	f0 07 18 00 	cp.b	r7,r8
8000a6e0:	c2 90       	breq	8000a732 <file_seek+0x66>
8000a6e2:	c1 a3       	brcs	8000a716 <file_seek+0x4a>
8000a6e4:	30 28       	mov	r8,2
8000a6e6:	f0 07 18 00 	cp.b	r7,r8
8000a6ea:	c0 70       	breq	8000a6f8 <file_seek+0x2c>
8000a6ec:	30 38       	mov	r8,3
8000a6ee:	f0 07 18 00 	cp.b	r7,r8
8000a6f2:	c3 00       	breq	8000a752 <file_seek+0x86>
8000a6f4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
   {
      case FS_SEEK_CUR_RE:
      if( fs_g_nav_entry.u32_pos_in_file < u32_pos )
8000a6f8:	4a 08       	lddpc	r8,8000a778 <file_seek+0xac>
8000a6fa:	70 38       	ld.w	r8,r8[0xc]
8000a6fc:	0c 38       	cp.w	r8,r6
8000a6fe:	c0 62       	brcc	8000a70a <file_seek+0x3e>
      {  // Out of the limit
         fs_g_status = FS_ERR_BAD_POS;
8000a700:	30 79       	mov	r9,7
8000a702:	49 f8       	lddpc	r8,8000a77c <file_seek+0xb0>
8000a704:	b0 89       	st.b	r8[0x0],r9
8000a706:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
         return false;
      }
      // update the position
      fs_g_nav_entry.u32_pos_in_file -= u32_pos;
8000a70a:	49 c9       	lddpc	r9,8000a778 <file_seek+0xac>
8000a70c:	f0 06 01 06 	sub	r6,r8,r6
8000a710:	93 36       	st.w	r9[0xc],r6
8000a712:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
      break;

      case FS_SEEK_SET:
      if( fs_g_nav_entry.u32_size < u32_pos )
8000a716:	49 98       	lddpc	r8,8000a778 <file_seek+0xac>
8000a718:	70 28       	ld.w	r8,r8[0x8]
8000a71a:	10 36       	cp.w	r6,r8
8000a71c:	e0 88 00 07 	brls	8000a72a <file_seek+0x5e>
      {  // Out of the limit
         fs_g_status = FS_ERR_BAD_POS;
8000a720:	30 79       	mov	r9,7
8000a722:	49 78       	lddpc	r8,8000a77c <file_seek+0xb0>
8000a724:	b0 89       	st.b	r8[0x0],r9
8000a726:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
         return false;
      }
      // update the position
      fs_g_nav_entry.u32_pos_in_file = u32_pos;
8000a72a:	49 48       	lddpc	r8,8000a778 <file_seek+0xac>
8000a72c:	91 36       	st.w	r8[0xc],r6
8000a72e:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
      break;

      case FS_SEEK_END:
      if( fs_g_nav_entry.u32_size < u32_pos )
8000a732:	49 28       	lddpc	r8,8000a778 <file_seek+0xac>
8000a734:	70 28       	ld.w	r8,r8[0x8]
8000a736:	10 36       	cp.w	r6,r8
8000a738:	e0 88 00 07 	brls	8000a746 <file_seek+0x7a>
      {  // Out of the limit
         fs_g_status = FS_ERR_BAD_POS;
8000a73c:	30 79       	mov	r9,7
8000a73e:	49 08       	lddpc	r8,8000a77c <file_seek+0xb0>
8000a740:	b0 89       	st.b	r8[0x0],r9
8000a742:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
         return false;
      }
      // update the position
      fs_g_nav_entry.u32_pos_in_file = fs_g_nav_entry.u32_size - u32_pos;
8000a746:	48 d9       	lddpc	r9,8000a778 <file_seek+0xac>
8000a748:	f0 06 01 06 	sub	r6,r8,r6
8000a74c:	93 36       	st.w	r9[0xc],r6
8000a74e:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
      break;

      case FS_SEEK_CUR_FW:
      u32_pos += fs_g_nav_entry.u32_pos_in_file;
8000a752:	48 a8       	lddpc	r8,8000a778 <file_seek+0xac>
8000a754:	70 39       	ld.w	r9,r8[0xc]
8000a756:	12 06       	add	r6,r9
      if( fs_g_nav_entry.u32_size < u32_pos )
8000a758:	70 28       	ld.w	r8,r8[0x8]
8000a75a:	10 36       	cp.w	r6,r8
8000a75c:	e0 88 00 07 	brls	8000a76a <file_seek+0x9e>
      {  // Out of the limit
         fs_g_status = FS_ERR_BAD_POS;
8000a760:	30 79       	mov	r9,7
8000a762:	48 78       	lddpc	r8,8000a77c <file_seek+0xb0>
8000a764:	b0 89       	st.b	r8[0x0],r9
8000a766:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
         return false;
      }
      // update the position
      fs_g_nav_entry.u32_pos_in_file = u32_pos;
8000a76a:	48 48       	lddpc	r8,8000a778 <file_seek+0xac>
8000a76c:	91 36       	st.w	r8[0xc],r6
8000a76e:	30 1c       	mov	r12,1
      break;
   }
   return true;
}
8000a770:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000a774:	80 00       	ld.sh	r0,r0[0x0]
8000a776:	a2 00       	st.h	r1[0x0],r0
8000a778:	00 00       	add	r0,r0
8000a77a:	09 d8       	ld.ub	r8,r4[0x5]
8000a77c:	00 00       	add	r0,r0
8000a77e:	0c 68       	and	r8,r6

8000a780 <file_close>:


//! This function closes the file
//!
void  file_close( void )
{
8000a780:	d4 01       	pushm	lr
   // If a file is opened, then close this one
   if( fat_check_mount_select_open() )
8000a782:	f0 1f 00 0a 	mcall	8000a7a8 <file_close+0x28>
8000a786:	c1 00       	breq	8000a7a6 <file_close+0x26>
   {

#if (FSFEATURE_WRITE == (FS_LEVEL_FEATURES & FSFEATURE_WRITE))
      if( FOPEN_WRITE_ACCESS & fs_g_nav_entry.u8_open_mode )
8000a788:	48 98       	lddpc	r8,8000a7ac <file_close+0x2c>
8000a78a:	11 88       	ld.ub	r8,r8[0x0]
8000a78c:	e2 18 00 02 	andl	r8,0x2,COH
8000a790:	c0 80       	breq	8000a7a0 <file_close+0x20>
      {
         // Write file information
         if( !fat_read_dir() )
8000a792:	f0 1f 00 08 	mcall	8000a7b0 <file_close+0x30>
8000a796:	c0 80       	breq	8000a7a6 <file_close+0x26>
            return;           // error
         fat_write_entry_file();
8000a798:	f0 1f 00 07 	mcall	8000a7b4 <file_close+0x34>
         fat_cache_flush();   // In case of error during writing data, flush the data before exit function
8000a79c:	f0 1f 00 07 	mcall	8000a7b8 <file_close+0x38>
      }
#endif  // FS_LEVEL_FEATURES
      Fat_file_close();
8000a7a0:	30 09       	mov	r9,0
8000a7a2:	48 38       	lddpc	r8,8000a7ac <file_close+0x2c>
8000a7a4:	b0 89       	st.b	r8[0x0],r9
8000a7a6:	d8 02       	popm	pc
8000a7a8:	80 00       	ld.sh	r0,r0[0x0]
8000a7aa:	a2 00       	st.h	r1[0x0],r0
8000a7ac:	00 00       	add	r0,r0
8000a7ae:	09 d8       	ld.ub	r8,r4[0x5]
8000a7b0:	80 00       	ld.sh	r0,r0[0x0]
8000a7b2:	9f 5c       	st.w	pc[0x14],r12
8000a7b4:	80 00       	ld.sh	r0,r0[0x0]
8000a7b6:	97 24       	st.w	r11[0x8],r4
8000a7b8:	80 00       	ld.sh	r0,r0[0x0]
8000a7ba:	98 c8       	ld.uh	r8,r12[0x8]

8000a7bc <file_getc>:
//!
//! @return    The byte read
//! @return    EOF, in case of error or end of file
//!
uint16_t   file_getc( void )
{
8000a7bc:	d4 01       	pushm	lr
   uint16_t   u16_byte;

   while(1)
   {
      if(!(FOPEN_READ_ACCESS & fs_g_nav_entry.u8_open_mode))
8000a7be:	49 78       	lddpc	r8,8000a818 <file_getc+0x5c>
8000a7c0:	11 88       	ld.ub	r8,r8[0x0]
8000a7c2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a7c6:	c0 51       	brne	8000a7d0 <file_getc+0x14>
      {
         fs_g_status = FS_ERR_WRITE_ONLY;
8000a7c8:	31 e9       	mov	r9,30
8000a7ca:	49 58       	lddpc	r8,8000a81c <file_getc+0x60>
8000a7cc:	b0 89       	st.b	r8[0x0],r9
8000a7ce:	dc 0a       	popm	pc,r12=-1
         break;
      }
      if( fs_g_nav_entry.u32_size <= fs_g_nav_entry.u32_pos_in_file )
8000a7d0:	49 28       	lddpc	r8,8000a818 <file_getc+0x5c>
8000a7d2:	70 29       	ld.w	r9,r8[0x8]
8000a7d4:	70 38       	ld.w	r8,r8[0xc]
8000a7d6:	10 39       	cp.w	r9,r8
8000a7d8:	e0 8b 00 06 	brhi	8000a7e4 <file_getc+0x28>
      {
         fs_g_status = FS_ERR_EOF;
8000a7dc:	32 09       	mov	r9,32
8000a7de:	49 08       	lddpc	r8,8000a81c <file_getc+0x60>
8000a7e0:	b0 89       	st.b	r8[0x0],r9
8000a7e2:	dc 0a       	popm	pc,r12=-1
         break;
      }

      if( !fat_read_file( FS_CLUST_ACT_ONE ))
8000a7e4:	30 2c       	mov	r12,2
8000a7e6:	f0 1f 00 0f 	mcall	8000a820 <file_getc+0x64>
8000a7ea:	c0 c1       	brne	8000a802 <file_getc+0x46>
      {
         if( FS_ERR_OUT_LIST == fs_g_status )
8000a7ec:	48 c8       	lddpc	r8,8000a81c <file_getc+0x60>
8000a7ee:	11 89       	ld.ub	r9,r8[0x0]
8000a7f0:	31 a8       	mov	r8,26
8000a7f2:	f0 09 18 00 	cp.b	r9,r8
8000a7f6:	c0 20       	breq	8000a7fa <file_getc+0x3e>
8000a7f8:	dc 0a       	popm	pc,r12=-1
         {  // Translate the error
            fs_g_status = FS_ERR_EOF;   // End of file
8000a7fa:	32 09       	mov	r9,32
8000a7fc:	48 88       	lddpc	r8,8000a81c <file_getc+0x60>
8000a7fe:	b0 89       	st.b	r8[0x0],r9
8000a800:	dc 0a       	popm	pc,r12=-1
         }
         break;
      }

      u16_byte = fs_g_sector[ fs_g_nav_entry.u32_pos_in_file & FS_512B_MASK ];
8000a802:	48 68       	lddpc	r8,8000a818 <file_getc+0x5c>
8000a804:	70 39       	ld.w	r9,r8[0xc]
8000a806:	f5 d9 c0 09 	bfextu	r10,r9,0x0,0x9
8000a80a:	48 7b       	lddpc	r11,8000a824 <file_getc+0x68>
8000a80c:	f6 0a 07 0c 	ld.ub	r12,r11[r10]
      fs_g_nav_entry.u32_pos_in_file++;
8000a810:	2f f9       	sub	r9,-1
8000a812:	91 39       	st.w	r8[0xc],r9
      return u16_byte;
   }
   return FS_EOF;   // No data read
}
8000a814:	d8 02       	popm	pc
8000a816:	00 00       	add	r0,r0
8000a818:	00 00       	add	r0,r0
8000a81a:	09 d8       	ld.ub	r8,r4[0x5]
8000a81c:	00 00       	add	r0,r0
8000a81e:	0c 68       	and	r8,r6
8000a820:	80 00       	ld.sh	r0,r0[0x0]
8000a822:	9f e0       	st.w	pc[0x38],r0
8000a824:	00 00       	add	r0,r0
8000a826:	0a 18       	sub	r8,r5

8000a828 <file_read_buf>:
//!
//! @return    number of byte read
//! @return    0, in case of error
//!
uint16_t   file_read_buf( uint8_t _MEM_TYPE_SLOW_ *buffer , uint16_t u16_buf_size )
{
8000a828:	d4 31       	pushm	r0-r7,lr
8000a82a:	20 1d       	sub	sp,4
8000a82c:	18 95       	mov	r5,r12
8000a82e:	16 94       	mov	r4,r11
   _MEM_TYPE_FAST_ uint16_t u16_nb_read_tmp;
   _MEM_TYPE_FAST_ uint16_t u16_nb_read;
   _MEM_TYPE_FAST_ uint16_t u16_pos_in_sector;
   _MEM_TYPE_FAST_ uint32_t u32_byte_remaining;

   if( !fat_check_mount_select_open())
8000a830:	f0 1f 00 58 	mcall	8000a990 <file_read_buf+0x168>
8000a834:	e0 80 00 a9 	breq	8000a986 <file_read_buf+0x15e>
      return false;

   if(!(FOPEN_READ_ACCESS & fs_g_nav_entry.u8_open_mode))
8000a838:	4d 78       	lddpc	r8,8000a994 <file_read_buf+0x16c>
8000a83a:	11 88       	ld.ub	r8,r8[0x0]
8000a83c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a840:	c0 40       	breq	8000a848 <file_read_buf+0x20>
      return false;
   }

   u16_nb_read = 0;

   while( 0 != u16_buf_size )
8000a842:	58 04       	cp.w	r4,0
8000a844:	c0 71       	brne	8000a852 <file_read_buf+0x2a>
8000a846:	ca 08       	rjmp	8000a986 <file_read_buf+0x15e>
   if( !fat_check_mount_select_open())
      return false;

   if(!(FOPEN_READ_ACCESS & fs_g_nav_entry.u8_open_mode))
   {
      fs_g_status = FS_ERR_WRITE_ONLY;
8000a848:	31 e9       	mov	r9,30
8000a84a:	4d 48       	lddpc	r8,8000a998 <file_read_buf+0x170>
8000a84c:	b0 89       	st.b	r8[0x0],r9
8000a84e:	30 00       	mov	r0,0
      return false;
8000a850:	c9 c8       	rjmp	8000a988 <file_read_buf+0x160>
8000a852:	30 00       	mov	r0,0
      if ( file_eof() )
      {
         fs_g_status = FS_ERR_EOF;
         return u16_nb_read;     // End of the file
      }
      u32_byte_remaining = fs_g_nav_entry.u32_size-fs_g_nav_entry.u32_pos_in_file;
8000a854:	4d 03       	lddpc	r3,8000a994 <file_read_buf+0x16c>
      u16_pos_in_sector = fs_g_nav_entry.u32_pos_in_file % FS_512B;

      if( (0== u16_pos_in_sector)
8000a856:	30 09       	mov	r9,0
8000a858:	ba b9       	st.b	sp[0x3],r9
            if( FS_ERR_OUT_LIST == fs_g_status )
               fs_g_status = FS_ERR_EOF;  // translate the error
            return u16_nb_read;
         }
         // Truncate the segment size found if more larger than asked size
         if( u16_nb_read_tmp > fs_g_seg.u32_size_or_pos )
8000a85a:	4d 17       	lddpc	r7,8000a99c <file_read_buf+0x174>

   u16_nb_read = 0;

   while( 0 != u16_buf_size )
   {
      if ( file_eof() )
8000a85c:	f0 1f 00 51 	mcall	8000a9a0 <file_read_buf+0x178>
8000a860:	c0 50       	breq	8000a86a <file_read_buf+0x42>
      {
         fs_g_status = FS_ERR_EOF;
8000a862:	32 09       	mov	r9,32
8000a864:	4c d8       	lddpc	r8,8000a998 <file_read_buf+0x170>
8000a866:	b0 89       	st.b	r8[0x0],r9
         return u16_nb_read;     // End of the file
8000a868:	c9 08       	rjmp	8000a988 <file_read_buf+0x160>
      }
      u32_byte_remaining = fs_g_nav_entry.u32_size-fs_g_nav_entry.u32_pos_in_file;
8000a86a:	66 31       	ld.w	r1,r3[0xc]
8000a86c:	66 26       	ld.w	r6,r3[0x8]
8000a86e:	02 16       	sub	r6,r1
      u16_pos_in_sector = fs_g_nav_entry.u32_pos_in_file % FS_512B;
8000a870:	e3 d1 c0 09 	bfextu	r1,r1,0x0,0x9

      if( (0== u16_pos_in_sector)
8000a874:	30 08       	mov	r8,0
8000a876:	f0 01 19 00 	cp.h	r1,r8
8000a87a:	5f 09       	sreq	r9
8000a87c:	e0 46 01 ff 	cp.w	r6,511
8000a880:	5f b8       	srhi	r8
8000a882:	f3 e8 00 08 	and	r8,r9,r8
8000a886:	1b b9       	ld.ub	r9,sp[0x3]
8000a888:	f2 08 18 00 	cp.b	r8,r9
8000a88c:	c4 90       	breq	8000a91e <file_read_buf+0xf6>
8000a88e:	e0 68 01 ff 	mov	r8,511
8000a892:	f0 04 19 00 	cp.h	r4,r8
8000a896:	e0 88 00 44 	brls	8000a91e <file_read_buf+0xf6>
8000a89a:	f1 d5 c0 02 	bfextu	r8,r5,0x0,0x2
8000a89e:	c4 01       	brne	8000a91e <file_read_buf+0xf6>
      &&  (Test_align((uint32_t)buffer, sizeof(uint32_t)))
#endif
      )
      {
         // The file data sector can been directly transfer from memory to buffer (don't use internal cache)
         if( u16_buf_size <= u32_byte_remaining)
8000a8a0:	08 98       	mov	r8,r4
8000a8a2:	5c 78       	castu.h	r8
8000a8a4:	10 36       	cp.w	r6,r8
8000a8a6:	c0 43       	brcs	8000a8ae <file_read_buf+0x86>
8000a8a8:	08 96       	mov	r6,r4
8000a8aa:	5c 86       	casts.h	r6
8000a8ac:	c0 28       	rjmp	8000a8b0 <file_read_buf+0x88>
         {
            u16_nb_read_tmp = u16_buf_size;
         }else{
            u16_nb_read_tmp = u32_byte_remaining;
8000a8ae:	5c 86       	casts.h	r6
         }
         u16_nb_read_tmp = u16_nb_read_tmp / FS_512B;  // read a modulo sector size

         // Get following sector segment of file
         if( !fat_read_file(FS_CLUST_ACT_SEG))
8000a8b0:	30 1c       	mov	r12,1
8000a8b2:	f0 1f 00 3d 	mcall	8000a9a4 <file_read_buf+0x17c>
8000a8b6:	c0 b1       	brne	8000a8cc <file_read_buf+0xa4>
         {
            if( FS_ERR_OUT_LIST == fs_g_status )
8000a8b8:	4b 88       	lddpc	r8,8000a998 <file_read_buf+0x170>
8000a8ba:	11 89       	ld.ub	r9,r8[0x0]
8000a8bc:	31 a8       	mov	r8,26
8000a8be:	f0 09 18 00 	cp.b	r9,r8
8000a8c2:	c6 31       	brne	8000a988 <file_read_buf+0x160>
               fs_g_status = FS_ERR_EOF;  // translate the error
8000a8c4:	32 09       	mov	r9,32
8000a8c6:	4b 58       	lddpc	r8,8000a998 <file_read_buf+0x170>
8000a8c8:	b0 89       	st.b	r8[0x0],r9
8000a8ca:	c5 f8       	rjmp	8000a988 <file_read_buf+0x160>
         {
            u16_nb_read_tmp = u16_buf_size;
         }else{
            u16_nb_read_tmp = u32_byte_remaining;
         }
         u16_nb_read_tmp = u16_nb_read_tmp / FS_512B;  // read a modulo sector size
8000a8cc:	ed d6 c1 27 	bfextu	r6,r6,0x9,0x7
            if( FS_ERR_OUT_LIST == fs_g_status )
               fs_g_status = FS_ERR_EOF;  // translate the error
            return u16_nb_read;
         }
         // Truncate the segment size found if more larger than asked size
         if( u16_nb_read_tmp > fs_g_seg.u32_size_or_pos )
8000a8d0:	f1 d6 c0 10 	bfextu	r8,r6,0x0,0x10
8000a8d4:	6e 19       	ld.w	r9,r7[0x4]
8000a8d6:	12 38       	cp.w	r8,r9
8000a8d8:	e0 88 00 08 	brls	8000a8e8 <file_read_buf+0xc0>
         {
            u16_nb_read_tmp = fs_g_seg.u32_size_or_pos;
8000a8dc:	ed d9 b0 10 	bfexts	r6,r9,0x0,0x10
         }else{
            fs_g_seg.u32_size_or_pos = u16_nb_read_tmp;
         }

         // Directly data transfers from memory to buffer
         while( 0 != fs_g_seg.u32_size_or_pos )
8000a8e0:	6e 18       	ld.w	r8,r7[0x4]
8000a8e2:	58 08       	cp.w	r8,0
8000a8e4:	c0 41       	brne	8000a8ec <file_read_buf+0xc4>
8000a8e6:	c1 88       	rjmp	8000a916 <file_read_buf+0xee>
         // Truncate the segment size found if more larger than asked size
         if( u16_nb_read_tmp > fs_g_seg.u32_size_or_pos )
         {
            u16_nb_read_tmp = fs_g_seg.u32_size_or_pos;
         }else{
            fs_g_seg.u32_size_or_pos = u16_nb_read_tmp;
8000a8e8:	8f 18       	st.w	r7[0x4],r8
8000a8ea:	cf bb       	rjmp	8000a8e0 <file_read_buf+0xb8>
         }

         // Directly data transfers from memory to buffer
         while( 0 != fs_g_seg.u32_size_or_pos )
         {
            if( CTRL_GOOD != memory_2_ram( fs_g_nav.u8_lun  , fs_g_seg.u32_addr, buffer))
8000a8ec:	0a 9a       	mov	r10,r5
8000a8ee:	6e 0b       	ld.w	r11,r7[0x0]
8000a8f0:	4a e8       	lddpc	r8,8000a9a8 <file_read_buf+0x180>
8000a8f2:	11 8c       	ld.ub	r12,r8[0x0]
8000a8f4:	f0 1f 00 2e 	mcall	8000a9ac <file_read_buf+0x184>
8000a8f8:	c0 50       	breq	8000a902 <file_read_buf+0xda>
            {
               fs_g_status = FS_ERR_HW;
8000a8fa:	30 19       	mov	r9,1
8000a8fc:	4a 78       	lddpc	r8,8000a998 <file_read_buf+0x170>
8000a8fe:	b0 89       	st.b	r8[0x0],r9
               return u16_nb_read;
8000a900:	c4 48       	rjmp	8000a988 <file_read_buf+0x160>
            }
            fs_g_seg.u32_size_or_pos--;
8000a902:	6e 18       	ld.w	r8,r7[0x4]
8000a904:	20 18       	sub	r8,1
8000a906:	8f 18       	st.w	r7[0x4],r8
            fs_g_seg.u32_addr++;
8000a908:	6e 09       	ld.w	r9,r7[0x0]
8000a90a:	2f f9       	sub	r9,-1
8000a90c:	8f 09       	st.w	r7[0x0],r9
            buffer += FS_512B;
8000a90e:	ea c5 fe 00 	sub	r5,r5,-512
         }else{
            fs_g_seg.u32_size_or_pos = u16_nb_read_tmp;
         }

         // Directly data transfers from memory to buffer
         while( 0 != fs_g_seg.u32_size_or_pos )
8000a912:	58 08       	cp.w	r8,0
8000a914:	ce c1       	brne	8000a8ec <file_read_buf+0xc4>
            fs_g_seg.u32_size_or_pos--;
            fs_g_seg.u32_addr++;
            buffer += FS_512B;
         }
         // Translate from sector unit to byte unit
         u16_nb_read_tmp *= FS_512B;
8000a916:	a9 76       	lsl	r6,0x9
8000a918:	e5 d6 b0 10 	bfexts	r2,r6,0x0,0x10
         return u16_nb_read;     // End of the file
      }
      u32_byte_remaining = fs_g_nav_entry.u32_size-fs_g_nav_entry.u32_pos_in_file;
      u16_pos_in_sector = fs_g_nav_entry.u32_pos_in_file % FS_512B;

      if( (0== u16_pos_in_sector)
8000a91c:	c2 78       	rjmp	8000a96a <file_read_buf+0x142>
      else
      {
         // The file data can't been directly transfer from memory to buffer, the internal cache must be used

         // Transfer data from memory to internal cache
         if( !fat_read_file( FS_CLUST_ACT_ONE ))
8000a91e:	30 2c       	mov	r12,2
8000a920:	f0 1f 00 21 	mcall	8000a9a4 <file_read_buf+0x17c>
8000a924:	c0 b1       	brne	8000a93a <file_read_buf+0x112>
         {
            if( FS_ERR_OUT_LIST == fs_g_status )
8000a926:	49 d8       	lddpc	r8,8000a998 <file_read_buf+0x170>
8000a928:	11 89       	ld.ub	r9,r8[0x0]
8000a92a:	31 a8       	mov	r8,26
8000a92c:	f0 09 18 00 	cp.b	r9,r8
8000a930:	c2 c1       	brne	8000a988 <file_read_buf+0x160>
            {  // Translate the error
               fs_g_status = FS_ERR_EOF;   // End of file
8000a932:	32 09       	mov	r9,32
8000a934:	49 98       	lddpc	r8,8000a998 <file_read_buf+0x170>
8000a936:	b0 89       	st.b	r8[0x0],r9
8000a938:	c2 88       	rjmp	8000a988 <file_read_buf+0x160>
            }
            return u16_nb_read;
         }

         // Compute the number of data to transfer
         u16_nb_read_tmp = FS_512B - u16_pos_in_sector;  // The number is limited at sector size
8000a93a:	e0 62 02 00 	mov	r2,512
8000a93e:	02 12       	sub	r2,r1
8000a940:	5c 82       	casts.h	r2
         if( u16_nb_read_tmp > u32_byte_remaining )
8000a942:	f1 d2 c0 10 	bfextu	r8,r2,0x0,0x10
8000a946:	10 36       	cp.w	r6,r8
8000a948:	c0 32       	brcc	8000a94e <file_read_buf+0x126>
            u16_nb_read_tmp = u32_byte_remaining;
8000a94a:	e5 d6 b0 10 	bfexts	r2,r6,0x0,0x10
8000a94e:	e4 04 19 00 	cp.h	r4,r2
8000a952:	e8 02 17 30 	movlo	r2,r4
8000a956:	5c 82       	casts.h	r2
         if( u16_nb_read_tmp > u16_buf_size )
            u16_nb_read_tmp = u16_buf_size;

         // Transfer data from internal cache to buffer
         memcpy_ram2ram( buffer , &fs_g_sector[ u16_pos_in_sector ], u16_nb_read_tmp );
8000a958:	ed d2 c0 10 	bfextu	r6,r2,0x0,0x10
8000a95c:	0c 9a       	mov	r10,r6
8000a95e:	49 5b       	lddpc	r11,8000a9b0 <file_read_buf+0x188>
8000a960:	02 0b       	add	r11,r1
8000a962:	0a 9c       	mov	r12,r5
8000a964:	f0 1f 00 14 	mcall	8000a9b4 <file_read_buf+0x18c>
         buffer += u16_nb_read_tmp;
8000a968:	0c 05       	add	r5,r6
      }
      // Update positions
      fs_g_nav_entry.u32_pos_in_file   += u16_nb_read_tmp;
8000a96a:	f3 d2 c0 10 	bfextu	r9,r2,0x0,0x10
8000a96e:	66 38       	ld.w	r8,r3[0xc]
8000a970:	f2 08 00 08 	add	r8,r9,r8
8000a974:	87 38       	st.w	r3[0xc],r8
      u16_nb_read                      += u16_nb_read_tmp;
8000a976:	e4 00 00 00 	add	r0,r2,r0
8000a97a:	5c 80       	casts.h	r0
      u16_buf_size                     -= u16_nb_read_tmp;
8000a97c:	04 14       	sub	r4,r2
8000a97e:	5c 84       	casts.h	r4
      return false;
   }

   u16_nb_read = 0;

   while( 0 != u16_buf_size )
8000a980:	fe 91 ff 6e 	brne	8000a85c <file_read_buf+0x34>
8000a984:	c0 28       	rjmp	8000a988 <file_read_buf+0x160>
8000a986:	30 00       	mov	r0,0
      fs_g_nav_entry.u32_pos_in_file   += u16_nb_read_tmp;
      u16_nb_read                      += u16_nb_read_tmp;
      u16_buf_size                     -= u16_nb_read_tmp;
   }
   return u16_nb_read;  // Buffer is full
}
8000a988:	00 9c       	mov	r12,r0
8000a98a:	2f fd       	sub	sp,-4
8000a98c:	d8 32       	popm	r0-r7,pc
8000a98e:	00 00       	add	r0,r0
8000a990:	80 00       	ld.sh	r0,r0[0x0]
8000a992:	a2 00       	st.h	r1[0x0],r0
8000a994:	00 00       	add	r0,r0
8000a996:	09 d8       	ld.ub	r8,r4[0x5]
8000a998:	00 00       	add	r0,r0
8000a99a:	0c 68       	and	r8,r6
8000a99c:	00 00       	add	r0,r0
8000a99e:	0c c0       	st.b	r6++,r0
8000a9a0:	80 00       	ld.sh	r0,r0[0x0]
8000a9a2:	a6 88       	st.b	r3[0x0],r8
8000a9a4:	80 00       	ld.sh	r0,r0[0x0]
8000a9a6:	9f e0       	st.w	pc[0x38],r0
8000a9a8:	00 00       	add	r0,r0
8000a9aa:	0c 18       	sub	r8,r6
8000a9ac:	80 00       	ld.sh	r0,r0[0x0]
8000a9ae:	b3 78       	lsl	r8,0x13
8000a9b0:	00 00       	add	r0,r0
8000a9b2:	0a 18       	sub	r8,r5
8000a9b4:	80 00       	ld.sh	r0,r0[0x0]
8000a9b6:	c6 38       	rjmp	8000aa7c <nav_file_lgt>

8000a9b8 <file_open>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  file_open( uint8_t fopen_mode )
{
8000a9b8:	eb cd 40 c0 	pushm	r6-r7,lr
8000a9bc:	18 97       	mov	r7,r12
   if( !fat_check_mount_select_noopen())
8000a9be:	f0 1f 00 20 	mcall	8000aa3c <file_open+0x84>
8000a9c2:	c3 a0       	breq	8000aa36 <file_open+0x7e>
      return false;

   if( !fat_check_is_file())
8000a9c4:	f0 1f 00 1f 	mcall	8000aa40 <file_open+0x88>
8000a9c8:	c3 70       	breq	8000aa36 <file_open+0x7e>
      return false;

   if(FOPEN_WRITE_ACCESS & fopen_mode)
8000a9ca:	0e 96       	mov	r6,r7
8000a9cc:	0e 98       	mov	r8,r7
8000a9ce:	e2 18 00 02 	andl	r8,0x2,COH
8000a9d2:	c1 90       	breq	8000aa04 <file_open+0x4c>
   {
      if( !fat_check_nav_access_file( true ) )
8000a9d4:	30 1c       	mov	r12,1
8000a9d6:	f0 1f 00 1c 	mcall	8000aa44 <file_open+0x8c>
8000a9da:	c2 e0       	breq	8000aa36 <file_open+0x7e>
         return false;
#if (FSFEATURE_WRITE == (FS_LEVEL_FEATURES & FSFEATURE_WRITE))
      if (FS_ATTR_READ_ONLY & fs_g_nav_entry.u8_attr)
8000a9dc:	49 b8       	lddpc	r8,8000aa48 <file_open+0x90>
8000a9de:	11 a8       	ld.ub	r8,r8[0x2]
8000a9e0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a9e4:	c0 60       	breq	8000a9f0 <file_open+0x38>
      {
         fs_g_status = FS_ERR_READ_ONLY;  // File is read only
8000a9e6:	31 59       	mov	r9,21
8000a9e8:	49 98       	lddpc	r8,8000aa4c <file_open+0x94>
8000a9ea:	b0 89       	st.b	r8[0x0],r9
8000a9ec:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
         return false;
      }
      if( mem_wr_protect( fs_g_nav.u8_lun  ))
8000a9f0:	49 88       	lddpc	r8,8000aa50 <file_open+0x98>
8000a9f2:	11 8c       	ld.ub	r12,r8[0x0]
8000a9f4:	f0 1f 00 18 	mcall	8000aa54 <file_open+0x9c>
8000a9f8:	c0 a0       	breq	8000aa0c <file_open+0x54>
      {
         fs_g_status = FS_LUN_WP;  // Disk read only
8000a9fa:	31 49       	mov	r9,20
8000a9fc:	49 48       	lddpc	r8,8000aa4c <file_open+0x94>
8000a9fe:	b0 89       	st.b	r8[0x0],r9
8000aa00:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      return false;
#endif  // FS_LEVEL_FEATURES
   }
   else
   {
      if( !fat_check_nav_access_file( false ) )
8000aa04:	30 0c       	mov	r12,0
8000aa06:	f0 1f 00 10 	mcall	8000aa44 <file_open+0x8c>
8000aa0a:	c1 60       	breq	8000aa36 <file_open+0x7e>
         return false;
   }

   if(FOPEN_CLEAR_SIZE & fopen_mode)
8000aa0c:	0c 98       	mov	r8,r6
8000aa0e:	e2 18 00 04 	andl	r8,0x4,COH
8000aa12:	c0 40       	breq	8000aa1a <file_open+0x62>
   {
      fs_g_nav_entry.u32_size    = 0;     // The size is null
8000aa14:	30 09       	mov	r9,0
8000aa16:	48 d8       	lddpc	r8,8000aa48 <file_open+0x90>
8000aa18:	91 29       	st.w	r8[0x8],r9
   }
   if(FOPEN_CLEAR_PTR & fopen_mode)
8000aa1a:	e2 16 00 08 	andl	r6,0x8,COH
8000aa1e:	c0 50       	breq	8000aa28 <file_open+0x70>
   {
      fs_g_nav_entry.u32_pos_in_file = 0;
8000aa20:	30 09       	mov	r9,0
8000aa22:	48 a8       	lddpc	r8,8000aa48 <file_open+0x90>
8000aa24:	91 39       	st.w	r8[0xc],r9
8000aa26:	c0 48       	rjmp	8000aa2e <file_open+0x76>
   }
   else
   {  // Go to at the end of file
      fs_g_nav_entry.u32_pos_in_file = fs_g_nav_entry.u32_size;
8000aa28:	48 88       	lddpc	r8,8000aa48 <file_open+0x90>
8000aa2a:	70 29       	ld.w	r9,r8[0x8]
8000aa2c:	91 39       	st.w	r8[0xc],r9
   }
   fs_g_nav_entry.u8_open_mode = fopen_mode;
8000aa2e:	48 78       	lddpc	r8,8000aa48 <file_open+0x90>
8000aa30:	b0 87       	st.b	r8[0x0],r7
8000aa32:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
   return true;
8000aa36:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
8000aa3a:	00 00       	add	r0,r0
8000aa3c:	80 00       	ld.sh	r0,r0[0x0]
8000aa3e:	a2 24       	st.h	r1[0x4],r4
8000aa40:	80 00       	ld.sh	r0,r0[0x0]
8000aa42:	8f b8       	st.w	r7[0x2c],r8
8000aa44:	80 00       	ld.sh	r0,r0[0x0]
8000aa46:	97 74       	st.w	r11[0x1c],r4
8000aa48:	00 00       	add	r0,r0
8000aa4a:	09 d8       	ld.ub	r8,r4[0x5]
8000aa4c:	00 00       	add	r0,r0
8000aa4e:	0c 68       	and	r8,r6
8000aa50:	00 00       	add	r0,r0
8000aa52:	0c 18       	sub	r8,r6
8000aa54:	80 00       	ld.sh	r0,r0[0x0]
8000aa56:	b3 64       	lsl	r4,0x12

8000aa58 <nav_checkdisk_disable>:
//! This check can reduce the speed access on specific disk.
//! @endverbatim
//!
void  nav_checkdisk_disable( void )
{
   g_b_no_check_disk = true;
8000aa58:	30 19       	mov	r9,1
8000aa5a:	48 28       	lddpc	r8,8000aa60 <nav_checkdisk_disable+0x8>
8000aa5c:	b0 89       	st.b	r8[0x0],r9
}
8000aa5e:	5e fc       	retal	r12
8000aa60:	00 00       	add	r0,r0
8000aa62:	09 ea       	ld.ub	r10,r4[0x6]

8000aa64 <nav_drive_get>:
      return 0xFF;
   return ((fs_g_nav.u8_lun*4) + fs_g_nav.u8_partition); // Maximum 4 partitions per device
#else
   return (fs_g_nav.u8_lun);
#endif
}
8000aa64:	48 28       	lddpc	r8,8000aa6c <nav_drive_get+0x8>
8000aa66:	11 8c       	ld.ub	r12,r8[0x0]
8000aa68:	5e fc       	retal	r12
8000aa6a:	00 00       	add	r0,r0
8000aa6c:	00 00       	add	r0,r0
8000aa6e:	0c 18       	sub	r8,r6

8000aa70 <nav_filelist_get>:
//! @return    FS_NO_SEL, in case of no file selected
//!
uint16_t   nav_filelist_get( void )
{
   return fs_g_nav.u16_pos_sel_file;
}
8000aa70:	48 28       	lddpc	r8,8000aa78 <nav_filelist_get+0x8>
8000aa72:	f1 0c 00 24 	ld.sh	r12,r8[36]
8000aa76:	5e fc       	retal	r12
8000aa78:	00 00       	add	r0,r0
8000aa7a:	0c 18       	sub	r8,r6

8000aa7c <nav_file_lgt>:
//! @return    Size of selected file (unit byte)
//!
uint32_t   nav_file_lgt( void )
{
   return fs_g_nav_entry.u32_size;
}
8000aa7c:	48 28       	lddpc	r8,8000aa84 <nav_file_lgt+0x8>
8000aa7e:	70 2c       	ld.w	r12,r8[0x8]
8000aa80:	5e fc       	retal	r12
8000aa82:	00 00       	add	r0,r0
8000aa84:	00 00       	add	r0,r0
8000aa86:	09 d8       	ld.ub	r8,r4[0x5]

8000aa88 <nav_file_checkext>:
//!
//! @return    true, the file extension match with extension filter
//! @return    false, in other case
//!
bool  nav_file_checkext( const FS_STRING sz_filterext )
{
8000aa88:	eb cd 40 80 	pushm	r7,lr
8000aa8c:	18 97       	mov	r7,r12
   if ( fat_check_mount_select() )
8000aa8e:	f0 1f 00 07 	mcall	8000aaa8 <nav_file_checkext+0x20>
8000aa92:	c0 90       	breq	8000aaa4 <nav_file_checkext+0x1c>
   {
      // Read selected entry (=short name entry) in directory
      if ( fat_read_dir())
8000aa94:	f0 1f 00 06 	mcall	8000aaac <nav_file_checkext+0x24>
8000aa98:	c0 60       	breq	8000aaa4 <nav_file_checkext+0x1c>
      {
         // Check the extension with filter
         if ( fat_entry_checkext( (FS_STRING) sz_filterext ) )
8000aa9a:	0e 9c       	mov	r12,r7
8000aa9c:	f0 1f 00 05 	mcall	8000aab0 <nav_file_checkext+0x28>
8000aaa0:	e3 cd 80 80 	ldm	sp++,r7,pc
8000aaa4:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
8000aaa8:	80 00       	ld.sh	r0,r0[0x0]
8000aaaa:	a1 e8       	*unknown*
8000aaac:	80 00       	ld.sh	r0,r0[0x0]
8000aaae:	9f 5c       	st.w	pc[0x14],r12
8000aab0:	80 00       	ld.sh	r0,r0[0x0]
8000aab2:	96 00       	ld.sh	r0,r11[0x0]

8000aab4 <nav_file_isdir>:
//!
//! @return    true, it is a directory
//! @return    false, in other case
//!
bool  nav_file_isdir( void )
{
8000aab4:	d4 01       	pushm	lr
   return fat_entry_is_dir();
8000aab6:	f0 1f 00 02 	mcall	8000aabc <nav_file_isdir+0x8>
}
8000aaba:	d8 02       	popm	pc
8000aabc:	80 00       	ld.sh	r0,r0[0x0]
8000aabe:	92 88       	ld.uh	r8,r9[0x0]

8000aac0 <nav_file_name>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_file_name( FS_STRING sz_name , uint8_t u8_size_max , bool b_mode , bool b_match_case  )
{
8000aac0:	d4 31       	pushm	r0-r7,lr
8000aac2:	20 1d       	sub	sp,4
8000aac4:	18 95       	mov	r5,r12
8000aac6:	16 96       	mov	r6,r11
8000aac8:	14 97       	mov	r7,r10
8000aaca:	12 93       	mov	r3,r9
   _MEM_TYPE_SLOW_   uint16_t u16_lgt;   // Only used if LENGTH string mode enabled
   uint16_t  u16_ptr_save_entry;
   bool  b_readshortname = false;

   if ( !fat_check_mount_select())
8000aacc:	f0 1f 00 2f 	mcall	8000ab88 <nav_file_name+0xc8>
8000aad0:	c5 80       	breq	8000ab80 <nav_file_name+0xc0>
      return false;

   // Check if the string size is not 0
   if( (FS_NAME_GET == b_mode)
8000aad2:	58 07       	cp.w	r7,0
8000aad4:	c0 50       	breq	8000aade <nav_file_name+0x1e>
8000aad6:	58 06       	cp.w	r6,0
8000aad8:	c0 31       	brne	8000aade <nav_file_name+0x1e>
8000aada:	30 1c       	mov	r12,1
8000aadc:	c5 38       	rjmp	8000ab82 <nav_file_name+0xc2>
   {
      return true;
   }

   // Save the current entry position
   u16_ptr_save_entry = fs_g_nav_fast.u16_entry_pos_sel_file;
8000aade:	4a c8       	lddpc	r8,8000ab8c <nav_file_name+0xcc>
8000aae0:	90 14       	ld.sh	r4,r8[0x2]
   // if it is the beginning of the directory
   if ( 0 == fs_g_nav_fast.u16_entry_pos_sel_file )
8000aae2:	58 04       	cp.w	r4,0
8000aae4:	c0 31       	brne	8000aaea <nav_file_name+0x2a>
8000aae6:	30 10       	mov	r0,1
8000aae8:	c0 68       	rjmp	8000aaf4 <nav_file_name+0x34>
   {
      b_readshortname = true;                   // It isn't possible to have a long name
   }
   else
   {
      fs_g_nav_fast.u16_entry_pos_sel_file--;   // Initialize entry position to search the first long name entry
8000aaea:	08 99       	mov	r9,r4
8000aaec:	20 19       	sub	r9,1
8000aaee:	4a 88       	lddpc	r8,8000ab8c <nav_file_name+0xcc>
8000aaf0:	b0 19       	st.h	r8[0x2],r9
8000aaf2:	30 00       	mov	r0,0
8000aaf4:	30 09       	mov	r9,0
8000aaf6:	50 09       	stdsp	sp[0x0],r9
         }
         fs_g_nav_fast.u16_entry_pos_sel_file = u16_ptr_save_entry;
         return true;
      }

      if ( FS_NO_LAST_LFN_ENTRY != fs_g_status )
8000aaf8:	31 01       	mov	r1,16
      {
         // Increment the string to store the next part of file name
         sz_name += FS_SIZE_LFN_ENTRY * (Is_unicode? 2 : 1 );
         u8_size_max -= FS_SIZE_LFN_ENTRY;
      }
      fs_g_nav_fast.u16_entry_pos_sel_file--;   // Go to the next part of long file name
8000aafa:	4a 52       	lddpc	r2,8000ab8c <nav_file_name+0xcc>
8000aafc:	c0 28       	rjmp	8000ab00 <nav_file_name+0x40>
   {
      b_readshortname = true;                   // It isn't possible to have a long name
   }
   else
   {
      fs_g_nav_fast.u16_entry_pos_sel_file--;   // Initialize entry position to search the first long name entry
8000aafe:	30 10       	mov	r0,1

   // Loop in directory entry
   u16_lgt = 0;
   while( 1 )
   {
      if ( !fat_read_dir())
8000ab00:	f0 1f 00 24 	mcall	8000ab90 <nav_file_name+0xd0>
8000ab04:	c3 e0       	breq	8000ab80 <nav_file_name+0xc0>
         break; // error

      if ( b_readshortname )
8000ab06:	58 00       	cp.w	r0,0
8000ab08:	c0 70       	breq	8000ab16 <nav_file_name+0x56>
      {
         // No long name present then read short name
         return fat_entry_shortname( sz_name , u8_size_max , b_mode  );
8000ab0a:	0e 9a       	mov	r10,r7
8000ab0c:	0c 9b       	mov	r11,r6
8000ab0e:	0a 9c       	mov	r12,r5
8000ab10:	f0 1f 00 21 	mcall	8000ab94 <nav_file_name+0xd4>
8000ab14:	c3 78       	rjmp	8000ab82 <nav_file_name+0xc2>
      }

      // Check or read the part of long file name in this entry
      if ( fat_entry_longname( sz_name , u8_size_max , b_mode , b_match_case  ))
8000ab16:	06 99       	mov	r9,r3
8000ab18:	0e 9a       	mov	r10,r7
8000ab1a:	0c 9b       	mov	r11,r6
8000ab1c:	0a 9c       	mov	r12,r5
8000ab1e:	f0 1f 00 1f 	mcall	8000ab98 <nav_file_name+0xd8>
8000ab22:	c1 20       	breq	8000ab46 <nav_file_name+0x86>
      {
         if( g_b_string_length )
8000ab24:	49 e8       	lddpc	r8,8000ab9c <nav_file_name+0xdc>
8000ab26:	11 89       	ld.ub	r9,r8[0x0]
8000ab28:	30 08       	mov	r8,0
         {
            ((FS_STR_UNICODE)sz_name )[0] += u16_lgt;
8000ab2a:	f0 09 18 00 	cp.b	r9,r8
8000ab2e:	eb f8 12 00 	ld.shne	r8,r5[0x0]
8000ab32:	fb f9 10 00 	ld.wne	r9,sp[0x0]
8000ab36:	f1 d9 e1 08 	addne	r8,r8,r9
8000ab3a:	eb f8 1c 00 	st.hne	r5[0x0],r8
         }
         fs_g_nav_fast.u16_entry_pos_sel_file = u16_ptr_save_entry;
8000ab3e:	49 48       	lddpc	r8,8000ab8c <nav_file_name+0xcc>
8000ab40:	b0 14       	st.h	r8[0x2],r4
8000ab42:	30 1c       	mov	r12,1
         return true;
8000ab44:	c1 f8       	rjmp	8000ab82 <nav_file_name+0xc2>
      }

      if ( FS_NO_LAST_LFN_ENTRY != fs_g_status )
8000ab46:	49 79       	lddpc	r9,8000aba0 <nav_file_name+0xe0>
8000ab48:	13 88       	ld.ub	r8,r9[0x0]
8000ab4a:	e2 08 18 00 	cp.b	r8,r1
8000ab4e:	c0 70       	breq	8000ab5c <nav_file_name+0x9c>
      {
         // Go to the main entry file (=short name entry)
         fs_g_nav_fast.u16_entry_pos_sel_file = u16_ptr_save_entry;
8000ab50:	a4 14       	st.h	r2[0x2],r4

         if ( FS_ERR_ENTRY_BAD == fs_g_status )
8000ab52:	30 b9       	mov	r9,11
8000ab54:	f2 08 18 00 	cp.b	r8,r9
8000ab58:	c1 41       	brne	8000ab80 <nav_file_name+0xc0>
8000ab5a:	cd 2b       	rjmp	8000aafe <nav_file_name+0x3e>
            continue;                 // restart the loop
         }
         // here, it is a error system or the string don't match with the file name
         break;
      }
      if( g_b_string_length )
8000ab5c:	49 09       	lddpc	r9,8000ab9c <nav_file_name+0xdc>
8000ab5e:	13 88       	ld.ub	r8,r9[0x0]
8000ab60:	30 09       	mov	r9,0
8000ab62:	f2 08 18 00 	cp.b	r8,r9
8000ab66:	c0 60       	breq	8000ab72 <nav_file_name+0xb2>
      {
         u16_lgt += FS_SIZE_LFN_ENTRY;
8000ab68:	40 08       	lddsp	r8,sp[0x0]
8000ab6a:	2f 38       	sub	r8,-13
8000ab6c:	5c 88       	casts.h	r8
8000ab6e:	50 08       	stdsp	sp[0x0],r8
8000ab70:	c0 48       	rjmp	8000ab78 <nav_file_name+0xb8>
      }
      else
      {
         // Increment the string to store the next part of file name
         sz_name += FS_SIZE_LFN_ENTRY * (Is_unicode? 2 : 1 );
8000ab72:	2f 35       	sub	r5,-13
         u8_size_max -= FS_SIZE_LFN_ENTRY;
8000ab74:	20 d6       	sub	r6,13
8000ab76:	5c 56       	castu.b	r6
      }
      fs_g_nav_fast.u16_entry_pos_sel_file--;   // Go to the next part of long file name
8000ab78:	84 18       	ld.sh	r8,r2[0x2]
8000ab7a:	20 18       	sub	r8,1
8000ab7c:	a4 18       	st.h	r2[0x2],r8
8000ab7e:	cc 1b       	rjmp	8000ab00 <nav_file_name+0x40>
8000ab80:	30 0c       	mov	r12,0

   }  // end of loop while(1)
   return false;
}
8000ab82:	2f fd       	sub	sp,-4
8000ab84:	d8 32       	popm	r0-r7,pc
8000ab86:	00 00       	add	r0,r0
8000ab88:	80 00       	ld.sh	r0,r0[0x0]
8000ab8a:	a1 e8       	*unknown*
8000ab8c:	00 00       	add	r0,r0
8000ab8e:	0c 64       	and	r4,r6
8000ab90:	80 00       	ld.sh	r0,r0[0x0]
8000ab92:	9f 5c       	st.w	pc[0x14],r12
8000ab94:	80 00       	ld.sh	r0,r0[0x0]
8000ab96:	94 b0       	ld.uh	r0,r10[0x6]
8000ab98:	80 00       	ld.sh	r0,r0[0x0]
8000ab9a:	93 1c       	st.w	r9[0x4],r12
8000ab9c:	00 00       	add	r0,r0
8000ab9e:	0c 69       	and	r9,r6
8000aba0:	00 00       	add	r0,r0
8000aba2:	0c 68       	and	r8,r6

8000aba4 <nav_file_getname>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool nav_file_getname( FS_STRING sz_name, uint8_t u8_size_max )
{
8000aba4:	d4 01       	pushm	lr
   return nav_file_name( sz_name, u8_size_max, FS_NAME_GET, false );
8000aba6:	30 09       	mov	r9,0
8000aba8:	30 1a       	mov	r10,1
8000abaa:	f0 1f 00 02 	mcall	8000abb0 <nav_file_getname+0xc>
}
8000abae:	d8 02       	popm	pc
8000abb0:	80 00       	ld.sh	r0,r0[0x0]
8000abb2:	aa c0       	st.b	r5[0x4],r0

8000abb4 <nav_filelist_set>:
//! @verbatim
//! Note: if no file is selected then nav_filelist_set( 0 , FS_NEXT ) goes to the first entry of the file list.
//! @endverbatim
//!
bool  nav_filelist_set( uint16_t u16_nb , bool b_direction )
{
8000abb4:	d4 31       	pushm	r0-r7,lr
8000abb6:	20 4d       	sub	sp,16
8000abb8:	50 0c       	stdsp	sp[0x0],r12
8000abba:	16 92       	mov	r2,r11
   uint16_t   u16_ptr_save_entry;
   uint16_t   u16_save_pos_sel_file;
   bool  b_save_entry_type;
   bool  b_find_last_entry = false;

   if ( !fat_check_mount_noopen())
8000abbc:	f0 1f 00 51 	mcall	8000ad00 <nav_filelist_set+0x14c>
8000abc0:	e0 80 00 9e 	breq	8000acfc <nav_filelist_set+0x148>
      return false;

   // Save the current selection
   u16_ptr_save_entry      = fs_g_nav_fast.u16_entry_pos_sel_file;
8000abc4:	4d 08       	lddpc	r8,8000ad04 <nav_filelist_set+0x150>
8000abc6:	90 18       	ld.sh	r8,r8[0x2]
8000abc8:	50 28       	stdsp	sp[0x8],r8
   u16_save_pos_sel_file   = fs_g_nav.u16_pos_sel_file;
8000abca:	4d 08       	lddpc	r8,8000ad08 <nav_filelist_set+0x154>
8000abcc:	f1 0a 00 24 	ld.sh	r10,r8[36]
8000abd0:	50 1a       	stdsp	sp[0x4],r10
   b_save_entry_type       = fs_g_nav.b_mode_nav;
8000abd2:	f1 38 00 2c 	ld.ub	r8,r8[44]
8000abd6:	50 38       	stdsp	sp[0xc],r8
8000abd8:	30 03       	mov	r3,0
         }
         fs_g_nav_fast.u16_entry_pos_sel_file++;      // Update entry position
      }
      else
      {
         if ( FS_NO_SEL == fs_g_nav_fast.u16_entry_pos_sel_file )
8000abda:	4c b7       	lddpc	r7,8000ad04 <nav_filelist_set+0x150>
8000abdc:	3f f0       	mov	r0,-1
            break;
         }
         if ( 0 == fs_g_nav_fast.u16_entry_pos_sel_file )
         {
            // beginning of directory
            if ( (FS_DIR == fs_g_nav.b_mode_nav ) || fs_g_nav.b_mode_nav_single )
8000abde:	4c b6       	lddpc	r6,8000ad08 <nav_filelist_set+0x154>
8000abe0:	30 04       	mov	r4,0
   while( 1 )
   {
      if(( FS_FIND_NEXT == b_direction )
      || ( b_find_last_entry ) )
      {
         if ( FS_END_FIND == fs_g_nav_fast.u16_entry_pos_sel_file )
8000abe2:	3f e1       	mov	r1,-2
           continue;
         }
      }

      // Here error, check type of error
      if(( FS_ERR_ENTRY_EMPTY == fs_g_status )
8000abe4:	4c a5       	lddpc	r5,8000ad0c <nav_filelist_set+0x158>
   b_save_entry_type       = fs_g_nav.b_mode_nav;

   // Loop in directory
   while( 1 )
   {
      if(( FS_FIND_NEXT == b_direction )
8000abe6:	58 02       	cp.w	r2,0
8000abe8:	c0 31       	brne	8000abee <nav_filelist_set+0x3a>
8000abea:	58 03       	cp.w	r3,0
8000abec:	c0 c0       	breq	8000ac04 <nav_filelist_set+0x50>
      || ( b_find_last_entry ) )
      {
         if ( FS_END_FIND == fs_g_nav_fast.u16_entry_pos_sel_file )
8000abee:	8e 18       	ld.sh	r8,r7[0x2]
8000abf0:	e2 08 19 00 	cp.h	r8,r1
8000abf4:	c0 51       	brne	8000abfe <nav_filelist_set+0x4a>
         {
            // Too many files in directory (case impossible)
            fs_g_status = FS_ERR_FS;
8000abf6:	30 89       	mov	r9,8
8000abf8:	4c 58       	lddpc	r8,8000ad0c <nav_filelist_set+0x158>
8000abfa:	b0 89       	st.b	r8[0x0],r9
            break;
8000abfc:	c7 38       	rjmp	8000ace2 <nav_filelist_set+0x12e>
         }
         fs_g_nav_fast.u16_entry_pos_sel_file++;      // Update entry position
8000abfe:	2f f8       	sub	r8,-1
8000ac00:	ae 18       	st.h	r7[0x2],r8
   b_save_entry_type       = fs_g_nav.b_mode_nav;

   // Loop in directory
   while( 1 )
   {
      if(( FS_FIND_NEXT == b_direction )
8000ac02:	c1 d8       	rjmp	8000ac3c <nav_filelist_set+0x88>
         }
         fs_g_nav_fast.u16_entry_pos_sel_file++;      // Update entry position
      }
      else
      {
         if ( FS_NO_SEL == fs_g_nav_fast.u16_entry_pos_sel_file )
8000ac04:	8e 18       	ld.sh	r8,r7[0x2]
8000ac06:	e0 08 19 00 	cp.h	r8,r0
8000ac0a:	c0 51       	brne	8000ac14 <nav_filelist_set+0x60>
         {
            // No selected file then previous action impossible
            fs_g_status = FS_ERR_NO_FIND;
8000ac0c:	30 99       	mov	r9,9
8000ac0e:	4c 08       	lddpc	r8,8000ad0c <nav_filelist_set+0x158>
8000ac10:	b0 89       	st.b	r8[0x0],r9
            break;
8000ac12:	c6 88       	rjmp	8000ace2 <nav_filelist_set+0x12e>
         }
         if ( 0 == fs_g_nav_fast.u16_entry_pos_sel_file )
8000ac14:	58 08       	cp.w	r8,0
8000ac16:	c1 11       	brne	8000ac38 <nav_filelist_set+0x84>
         {
            // beginning of directory
            if ( (FS_DIR == fs_g_nav.b_mode_nav ) || fs_g_nav.b_mode_nav_single )
8000ac18:	ed 38 00 2c 	ld.ub	r8,r6[44]
8000ac1c:	e8 08 18 00 	cp.b	r8,r4
8000ac20:	c0 80       	breq	8000ac30 <nav_filelist_set+0x7c>
8000ac22:	ed 38 00 2d 	ld.ub	r8,r6[45]
8000ac26:	e8 08 18 00 	cp.b	r8,r4
8000ac2a:	c0 31       	brne	8000ac30 <nav_filelist_set+0x7c>
8000ac2c:	30 13       	mov	r3,1
8000ac2e:	c0 78       	rjmp	8000ac3c <nav_filelist_set+0x88>
            {
               // End of directory scan, then no previous action possible
               fs_g_status = FS_ERR_NO_FIND;
8000ac30:	30 99       	mov	r9,9
8000ac32:	4b 78       	lddpc	r8,8000ad0c <nav_filelist_set+0x158>
8000ac34:	b0 89       	st.b	r8[0x0],r9
               break;
8000ac36:	c5 68       	rjmp	8000ace2 <nav_filelist_set+0x12e>
            }
            // End of file scan, then find last directory
            b_find_last_entry = true;
         }else{
            fs_g_nav_fast.u16_entry_pos_sel_file--;   // Update entry position
8000ac38:	20 18       	sub	r8,1
8000ac3a:	ae 18       	st.h	r7[0x2],r8
         }
      }

      if( !fat_read_dir())
8000ac3c:	f0 1f 00 35 	mcall	8000ad10 <nav_filelist_set+0x15c>
8000ac40:	c0 71       	brne	8000ac4e <nav_filelist_set+0x9a>
      {
         if( FS_ERR_OUT_LIST != fs_g_status )
8000ac42:	0b 89       	ld.ub	r9,r5[0x0]
8000ac44:	31 a8       	mov	r8,26
8000ac46:	f0 09 18 00 	cp.b	r9,r8
8000ac4a:	c3 20       	breq	8000acae <nav_filelist_set+0xfa>
8000ac4c:	c4 b8       	rjmp	8000ace2 <nav_filelist_set+0x12e>
            break; // Error
      }else{
         if ( fat_entry_check( fs_g_nav.b_mode_nav ) )
8000ac4e:	ed 38 00 2c 	ld.ub	r8,r6[44]
8000ac52:	e8 08 18 00 	cp.b	r8,r4
8000ac56:	5f 1c       	srne	r12
8000ac58:	f0 1f 00 2f 	mcall	8000ad14 <nav_filelist_set+0x160>
8000ac5c:	c1 c0       	breq	8000ac94 <nav_filelist_set+0xe0>
         {
           // HERE, the file entry match with the type searched

           if( b_find_last_entry )
8000ac5e:	58 03       	cp.w	r3,0
8000ac60:	cc 31       	brne	8000abe6 <nav_filelist_set+0x32>
             continue;  // The search of last directory is on going then continue the search

           // Update position in directory
           if ( FS_FIND_NEXT == b_direction )
              fs_g_nav.u16_pos_sel_file++;
8000ac62:	58 02       	cp.w	r2,0
8000ac64:	ed f8 12 12 	ld.shne	r8,r6[0x24]
8000ac68:	f7 b8 01 ff 	subne	r8,-1
8000ac6c:	ed f8 1c 12 	st.hne	r6[0x24],r8
           else
              fs_g_nav.u16_pos_sel_file--;
8000ac70:	ed f8 02 12 	ld.sheq	r8,r6[0x24]
8000ac74:	f7 b8 00 01 	subeq	r8,1
8000ac78:	ed f8 0c 12 	st.heq	r6[0x24],r8

           if (0 == u16_nb)
8000ac7c:	40 09       	lddsp	r9,sp[0x0]
8000ac7e:	58 09       	cp.w	r9,0
8000ac80:	c0 51       	brne	8000ac8a <nav_filelist_set+0xd6>
           {
              // It is the end of move then update file information
              fat_get_entry_info();
8000ac82:	f0 1f 00 26 	mcall	8000ad18 <nav_filelist_set+0x164>
8000ac86:	30 1c       	mov	r12,1
              return true;         // NB FILE FIND
8000ac88:	c3 a8       	rjmp	8000acfc <nav_filelist_set+0x148>
           }
           u16_nb--;
8000ac8a:	40 08       	lddsp	r8,sp[0x0]
8000ac8c:	20 18       	sub	r8,1
8000ac8e:	5c 88       	casts.h	r8
8000ac90:	50 08       	stdsp	sp[0x0],r8
           continue;
8000ac92:	ca ab       	rjmp	8000abe6 <nav_filelist_set+0x32>
         }
      }

      // Here error, check type of error
      if(( FS_ERR_ENTRY_EMPTY == fs_g_status )
8000ac94:	0b 88       	ld.ub	r8,r5[0x0]
8000ac96:	30 a9       	mov	r9,10
8000ac98:	f2 08 18 00 	cp.b	r8,r9
8000ac9c:	5f 09       	sreq	r9
8000ac9e:	31 aa       	mov	r10,26
8000aca0:	f4 08 18 00 	cp.b	r8,r10
8000aca4:	5f 08       	sreq	r8
8000aca6:	10 49       	or	r9,r8
8000aca8:	e8 09 18 00 	cp.b	r9,r4
8000acac:	c9 d0       	breq	8000abe6 <nav_filelist_set+0x32>
      || ( FS_ERR_OUT_LIST    == fs_g_status ) )
      {
         // Here, end of the directory
         if( b_find_last_entry )
8000acae:	58 03       	cp.w	r3,0
8000acb0:	c0 50       	breq	8000acba <nav_filelist_set+0x106>
         {
            // Re enable the previous command at the end of directory to find the last directory entry
            b_find_last_entry = false;
            fs_g_nav.b_mode_nav = FS_DIR;
8000acb2:	ed 64 00 2c 	st.b	r6[44],r4
8000acb6:	30 03       	mov	r3,0
            continue;
8000acb8:	c9 7b       	rjmp	8000abe6 <nav_filelist_set+0x32>
         }
         // Here, a next action is on going
         if ( (FS_FILE == fs_g_nav.b_mode_nav) || fs_g_nav.b_mode_nav_single )
8000acba:	ed 38 00 2c 	ld.ub	r8,r6[44]
8000acbe:	30 1a       	mov	r10,1
8000acc0:	f4 08 18 00 	cp.b	r8,r10
8000acc4:	c0 60       	breq	8000acd0 <nav_filelist_set+0x11c>
8000acc6:	ed 38 00 2d 	ld.ub	r8,r6[45]
8000acca:	e8 08 18 00 	cp.b	r8,r4
8000acce:	c0 50       	breq	8000acd8 <nav_filelist_set+0x124>
         {
            // End of next file action then end of next action
            fs_g_status = FS_ERR_NO_FIND; // No file found
8000acd0:	30 99       	mov	r9,9
8000acd2:	48 f8       	lddpc	r8,8000ad0c <nav_filelist_set+0x158>
8000acd4:	b0 89       	st.b	r8[0x0],r9
            break;                        // end of search
8000acd6:	c0 68       	rjmp	8000ace2 <nav_filelist_set+0x12e>
         }else{
            // End of next dir action then starts the next file action at the beginning of directory
            fs_g_nav_fast.u16_entry_pos_sel_file = 0xFFFF;
8000acd8:	ae 10       	st.h	r7[0x2],r0
            fs_g_nav.b_mode_nav = FS_FILE;
8000acda:	30 19       	mov	r9,1
8000acdc:	ed 69 00 2c 	st.b	r6[44],r9
8000ace0:	c8 3b       	rjmp	8000abe6 <nav_filelist_set+0x32>
         }
      }
   }  // end of loop while(1)

   fs_g_nav.b_mode_nav                    = b_save_entry_type;
8000ace2:	48 a8       	lddpc	r8,8000ad08 <nav_filelist_set+0x154>
8000ace4:	40 3a       	lddsp	r10,sp[0xc]
8000ace6:	58 0a       	cp.w	r10,0
8000ace8:	5f 19       	srne	r9
8000acea:	f1 69 00 2c 	st.b	r8[44],r9
   fs_g_nav_fast.u16_entry_pos_sel_file   = u16_ptr_save_entry;
8000acee:	48 69       	lddpc	r9,8000ad04 <nav_filelist_set+0x150>
8000acf0:	40 2a       	lddsp	r10,sp[0x8]
8000acf2:	b2 1a       	st.h	r9[0x2],r10
   fs_g_nav.u16_pos_sel_file              = u16_save_pos_sel_file;
8000acf4:	40 19       	lddsp	r9,sp[0x4]
8000acf6:	f1 59 00 24 	st.h	r8[36],r9
8000acfa:	30 0c       	mov	r12,0
   return false;
}
8000acfc:	2f cd       	sub	sp,-16
8000acfe:	d8 32       	popm	r0-r7,pc
8000ad00:	80 00       	ld.sh	r0,r0[0x0]
8000ad02:	a2 48       	st.h	r1[0x8],r8
8000ad04:	00 00       	add	r0,r0
8000ad06:	0c 64       	and	r4,r6
8000ad08:	00 00       	add	r0,r0
8000ad0a:	0c 18       	sub	r8,r6
8000ad0c:	00 00       	add	r0,r0
8000ad0e:	0c 68       	and	r8,r6
8000ad10:	80 00       	ld.sh	r0,r0[0x0]
8000ad12:	9f 5c       	st.w	pc[0x14],r12
8000ad14:	80 00       	ld.sh	r0,r0[0x0]
8000ad16:	96 a0       	ld.uh	r0,r11[0x4]
8000ad18:	80 00       	ld.sh	r0,r0[0x0]
8000ad1a:	95 b8       	st.w	r10[0x2c],r8

8000ad1c <nav_filelist_reset>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filelist_reset( void )
{
8000ad1c:	d4 01       	pushm	lr
   if ( !fat_check_mount_noopen())
8000ad1e:	f0 1f 00 04 	mcall	8000ad2c <nav_filelist_reset+0x10>
8000ad22:	c0 40       	breq	8000ad2a <nav_filelist_reset+0xe>
      return false;

   // No file selected and reset navigation
   fat_clear_entry_info_and_ptr();
8000ad24:	f0 1f 00 03 	mcall	8000ad30 <nav_filelist_reset+0x14>
8000ad28:	30 1c       	mov	r12,1
   return true;
}
8000ad2a:	d8 02       	popm	pc
8000ad2c:	80 00       	ld.sh	r0,r0[0x0]
8000ad2e:	a2 48       	st.h	r1[0x8],r8
8000ad30:	80 00       	ld.sh	r0,r0[0x0]
8000ad32:	92 a0       	ld.uh	r0,r9[0x4]

8000ad34 <nav_filelist_first>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filelist_first( bool b_type )
{
8000ad34:	d4 21       	pushm	r4-r7,lr
8000ad36:	18 97       	mov	r7,r12
   // Reset position
   if ( !nav_filelist_reset())
8000ad38:	f0 1f 00 0b 	mcall	8000ad64 <nav_filelist_first+0x30>
8000ad3c:	c0 71       	brne	8000ad4a <nav_filelist_first+0x16>
8000ad3e:	d8 22       	popm	r4-r7,pc
      return false;
   // Find the first file or directory
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
   {
      if( b_type == fs_g_nav.b_mode_nav )
8000ad40:	e9 38 00 2c 	ld.ub	r8,r4[44]
8000ad44:	10 37       	cp.w	r7,r8
8000ad46:	c0 51       	brne	8000ad50 <nav_filelist_first+0x1c>
8000ad48:	da 2a       	popm	r4-r7,pc,r12=1
{
   // Reset position
   if ( !nav_filelist_reset())
      return false;
   // Find the first file or directory
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
8000ad4a:	30 16       	mov	r6,1
8000ad4c:	30 05       	mov	r5,0
   {
      if( b_type == fs_g_nav.b_mode_nav )
8000ad4e:	48 74       	lddpc	r4,8000ad68 <nav_filelist_first+0x34>
{
   // Reset position
   if ( !nav_filelist_reset())
      return false;
   // Find the first file or directory
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
8000ad50:	0c 9b       	mov	r11,r6
8000ad52:	0a 9c       	mov	r12,r5
8000ad54:	f0 1f 00 06 	mcall	8000ad6c <nav_filelist_first+0x38>
8000ad58:	cf 41       	brne	8000ad40 <nav_filelist_first+0xc>
   {
      if( b_type == fs_g_nav.b_mode_nav )
         return true;   // First file or directory found
   }
   fs_g_status = FS_ERR_NO_FIND;
8000ad5a:	30 99       	mov	r9,9
8000ad5c:	48 58       	lddpc	r8,8000ad70 <nav_filelist_first+0x3c>
8000ad5e:	b0 89       	st.b	r8[0x0],r9
   return false;
}
8000ad60:	d8 22       	popm	r4-r7,pc
8000ad62:	00 00       	add	r0,r0
8000ad64:	80 00       	ld.sh	r0,r0[0x0]
8000ad66:	ad 1c       	ld.d	r12,--r6
8000ad68:	00 00       	add	r0,r0
8000ad6a:	0c 18       	sub	r8,r6
8000ad6c:	80 00       	ld.sh	r0,r0[0x0]
8000ad6e:	ab b4       	sbr	r4,0xb
8000ad70:	00 00       	add	r0,r0
8000ad72:	0c 68       	and	r8,r6

8000ad74 <nav_filelist_nb>:
//!                     FS_FILE to compute the number of files <br>
//!
//! @return    number of files or directories in file list
//!
uint16_t   nav_filelist_nb( bool b_type )
{
8000ad74:	d4 31       	pushm	r0-r7,lr
8000ad76:	18 90       	mov	r0,r12
   uint16_t   u16_save_position;
   uint16_t   u16_save_number_dir;
   uint16_t   u16_save_number_file;

   // Save current position
   u16_save_position = fs_g_nav.u16_pos_sel_file;
8000ad78:	49 88       	lddpc	r8,8000add8 <nav_filelist_nb+0x64>
8000ad7a:	f1 01 00 24 	ld.sh	r1,r8[36]
   // Reset position
   if ( !nav_filelist_reset())
8000ad7e:	f0 1f 00 18 	mcall	8000addc <nav_filelist_nb+0x68>
8000ad82:	c0 31       	brne	8000ad88 <nav_filelist_nb+0x14>
8000ad84:	30 02       	mov	r2,0
8000ad86:	c2 68       	rjmp	8000add2 <nav_filelist_nb+0x5e>
8000ad88:	30 02       	mov	r2,0
8000ad8a:	04 97       	mov	r7,r2
      return 0;
   // Scan all directory
   u16_save_number_dir  = 0;
   u16_save_number_file = 0;
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
8000ad8c:	30 14       	mov	r4,1
8000ad8e:	04 93       	mov	r3,r2
   {
      if( FS_FILE == fs_g_nav.b_mode_nav )
8000ad90:	49 26       	lddpc	r6,8000add8 <nav_filelist_nb+0x64>
8000ad92:	30 15       	mov	r5,1
8000ad94:	c0 b8       	rjmp	8000adaa <nav_filelist_nb+0x36>
8000ad96:	ed 38 00 2c 	ld.ub	r8,r6[44]
8000ad9a:	ea 08 18 00 	cp.b	r8,r5
8000ad9e:	c0 41       	brne	8000ada6 <nav_filelist_nb+0x32>
         u16_save_number_file++;    // It is a file
8000ada0:	2f f2       	sub	r2,-1
8000ada2:	5c 82       	casts.h	r2
8000ada4:	c0 38       	rjmp	8000adaa <nav_filelist_nb+0x36>
      else
         u16_save_number_dir++;     // It is a directory
8000ada6:	2f f7       	sub	r7,-1
8000ada8:	5c 87       	casts.h	r7
   if ( !nav_filelist_reset())
      return 0;
   // Scan all directory
   u16_save_number_dir  = 0;
   u16_save_number_file = 0;
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
8000adaa:	08 9b       	mov	r11,r4
8000adac:	06 9c       	mov	r12,r3
8000adae:	f0 1f 00 0d 	mcall	8000ade0 <nav_filelist_nb+0x6c>
8000adb2:	cf 21       	brne	8000ad96 <nav_filelist_nb+0x22>
         u16_save_number_file++;    // It is a file
      else
         u16_save_number_dir++;     // It is a directory
   }
   // Restore previous position
   nav_filelist_reset();
8000adb4:	f0 1f 00 0a 	mcall	8000addc <nav_filelist_nb+0x68>
   if ( u16_save_position != FS_NO_SEL )
8000adb8:	3f f8       	mov	r8,-1
8000adba:	f0 01 19 00 	cp.h	r1,r8
8000adbe:	c0 60       	breq	8000adca <nav_filelist_nb+0x56>
   {
      nav_filelist_set( u16_save_position , FS_FIND_NEXT );
8000adc0:	30 1b       	mov	r11,1
8000adc2:	f9 d1 c0 10 	bfextu	r12,r1,0x0,0x10
8000adc6:	f0 1f 00 07 	mcall	8000ade0 <nav_filelist_nb+0x6c>
   }
   // Return the value asked
   if( FS_FILE == b_type )
8000adca:	58 00       	cp.w	r0,0
8000adcc:	c0 31       	brne	8000add2 <nav_filelist_nb+0x5e>
8000adce:	0e 92       	mov	r2,r7
8000add0:	5c 82       	casts.h	r2
      return u16_save_number_file;
   else
      return u16_save_number_dir;
}
8000add2:	04 9c       	mov	r12,r2
8000add4:	d8 32       	popm	r0-r7,pc
8000add6:	00 00       	add	r0,r0
8000add8:	00 00       	add	r0,r0
8000adda:	0c 18       	sub	r8,r6
8000addc:	80 00       	ld.sh	r0,r0[0x0]
8000adde:	ad 1c       	ld.d	r12,--r6
8000ade0:	80 00       	ld.sh	r0,r0[0x0]
8000ade2:	ab b4       	sbr	r4,0xb

8000ade4 <nav_filelist_goto>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_filelist_goto( uint16_t u16_newpos )
{
8000ade4:	eb cd 40 80 	pushm	r7,lr
8000ade8:	18 97       	mov	r7,r12
   uint16_t u16_current_pos;

   if( FS_NO_SEL == u16_newpos )
8000adea:	3f f8       	mov	r8,-1
8000adec:	f0 0c 19 00 	cp.h	r12,r8
8000adf0:	c0 51       	brne	8000adfa <nav_filelist_goto+0x16>
      return nav_filelist_reset();
8000adf2:	f0 1f 00 1d 	mcall	8000ae64 <nav_filelist_goto+0x80>
8000adf6:	e3 cd 80 80 	ldm	sp++,r7,pc

   u16_current_pos = nav_filelist_get();
8000adfa:	f0 1f 00 1c 	mcall	8000ae68 <nav_filelist_goto+0x84>
8000adfe:	5c 8c       	casts.h	r12
   if( u16_newpos < (u16_current_pos/2) )
8000ae00:	f1 dc c0 2f 	bfextu	r8,r12,0x1,0xf
8000ae04:	f0 07 19 00 	cp.h	r7,r8
8000ae08:	c0 62       	brcc	8000ae14 <nav_filelist_goto+0x30>
   {
      // Restart at the beginning of list to accelerate the search
      if( !nav_filelist_reset() )
8000ae0a:	f0 1f 00 17 	mcall	8000ae64 <nav_filelist_goto+0x80>
8000ae0e:	c0 71       	brne	8000ae1c <nav_filelist_goto+0x38>
8000ae10:	e3 cd 80 80 	ldm	sp++,r7,pc
         return false;
      u16_current_pos = FS_NO_SEL;
   }
   if (FS_NO_SEL == u16_current_pos)
8000ae14:	3f f8       	mov	r8,-1
8000ae16:	f0 0c 19 00 	cp.h	r12,r8
8000ae1a:	c0 81       	brne	8000ae2a <nav_filelist_goto+0x46>
   {
      return nav_filelist_set( u16_newpos, FS_FIND_NEXT );
8000ae1c:	30 1b       	mov	r11,1
8000ae1e:	0e 9c       	mov	r12,r7
8000ae20:	5c 7c       	castu.h	r12
8000ae22:	f0 1f 00 13 	mcall	8000ae6c <nav_filelist_goto+0x88>
8000ae26:	e3 cd 80 80 	ldm	sp++,r7,pc
   }
   else
   {
      if (u16_newpos < u16_current_pos)
8000ae2a:	f8 07 19 00 	cp.h	r7,r12
8000ae2e:	c0 b2       	brcc	8000ae44 <nav_filelist_goto+0x60>
      {
         return nav_filelist_set( u16_current_pos -u16_newpos -1 , FS_FIND_PREV );
8000ae30:	ee 07 11 ff 	rsub	r7,r7,-1
8000ae34:	ee 0c 00 0c 	add	r12,r7,r12
8000ae38:	30 0b       	mov	r11,0
8000ae3a:	5c 7c       	castu.h	r12
8000ae3c:	f0 1f 00 0c 	mcall	8000ae6c <nav_filelist_goto+0x88>
8000ae40:	e3 cd 80 80 	ldm	sp++,r7,pc
      }
      if (u16_newpos > u16_current_pos)
8000ae44:	f8 07 19 00 	cp.h	r7,r12
8000ae48:	e0 8b 00 04 	brhi	8000ae50 <nav_filelist_goto+0x6c>
8000ae4c:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
      {
         return nav_filelist_set( u16_newpos -u16_current_pos - 1 , FS_FIND_NEXT );
8000ae50:	20 17       	sub	r7,1
8000ae52:	ee 0c 01 0c 	sub	r12,r7,r12
8000ae56:	30 1b       	mov	r11,1
8000ae58:	5c 7c       	castu.h	r12
8000ae5a:	f0 1f 00 05 	mcall	8000ae6c <nav_filelist_goto+0x88>
      }
   }
   return true;
}
8000ae5e:	e3 cd 80 80 	ldm	sp++,r7,pc
8000ae62:	00 00       	add	r0,r0
8000ae64:	80 00       	ld.sh	r0,r0[0x0]
8000ae66:	ad 1c       	ld.d	r12,--r6
8000ae68:	80 00       	ld.sh	r0,r0[0x0]
8000ae6a:	aa 70       	st.h	r5[0xe],r0
8000ae6c:	80 00       	ld.sh	r0,r0[0x0]
8000ae6e:	ab b4       	sbr	r4,0xb

8000ae70 <nav_filelist_single_disable>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filelist_single_disable( void )
{
8000ae70:	d4 01       	pushm	lr
   fs_g_nav.b_mode_nav_single = false;
8000ae72:	30 09       	mov	r9,0
8000ae74:	48 38       	lddpc	r8,8000ae80 <nav_filelist_single_disable+0x10>
8000ae76:	f1 69 00 2d 	st.b	r8[45],r9
   return nav_filelist_reset();
8000ae7a:	f0 1f 00 03 	mcall	8000ae84 <nav_filelist_single_disable+0x14>
}
8000ae7e:	d8 02       	popm	pc
8000ae80:	00 00       	add	r0,r0
8000ae82:	0c 18       	sub	r8,r6
8000ae84:	80 00       	ld.sh	r0,r0[0x0]
8000ae86:	ad 1c       	ld.d	r12,--r6

8000ae88 <nav_filelist_single_enable>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filelist_single_enable( bool b_type )
{
8000ae88:	eb cd 40 80 	pushm	r7,lr
8000ae8c:	18 97       	mov	r7,r12
   if ( !nav_filelist_reset())
8000ae8e:	f0 1f 00 07 	mcall	8000aea8 <nav_filelist_single_enable+0x20>
8000ae92:	c0 80       	breq	8000aea2 <nav_filelist_single_enable+0x1a>
      return false;

   fs_g_nav.b_mode_nav_single = true;
8000ae94:	48 68       	lddpc	r8,8000aeac <nav_filelist_single_enable+0x24>
8000ae96:	30 19       	mov	r9,1
8000ae98:	f1 69 00 2d 	st.b	r8[45],r9
   fs_g_nav.b_mode_nav        = b_type;
8000ae9c:	f1 67 00 2c 	st.b	r8[44],r7
8000aea0:	30 1c       	mov	r12,1
   return true;
}
8000aea2:	e3 cd 80 80 	ldm	sp++,r7,pc
8000aea6:	00 00       	add	r0,r0
8000aea8:	80 00       	ld.sh	r0,r0[0x0]
8000aeaa:	ad 1c       	ld.d	r12,--r6
8000aeac:	00 00       	add	r0,r0
8000aeae:	0c 18       	sub	r8,r6

8000aeb0 <nav_partition_mount>:
//! then the mount routine selects the first partition supported by file system. <br>
//! After mount, the file list contains files and directories of ROOT directory
//! @endverbatim
//!
bool  nav_partition_mount( void )
{
8000aeb0:	d4 01       	pushm	lr
   if ( !fat_check_noopen() )
8000aeb2:	f0 1f 00 0a 	mcall	8000aed8 <nav_partition_mount+0x28>
8000aeb6:	c0 f0       	breq	8000aed4 <nav_partition_mount+0x24>
      return false;

   if( FS_TYPE_FAT_UNM != fs_g_nav_fast.u8_type_fat)
8000aeb8:	48 98       	lddpc	r8,8000aedc <nav_partition_mount+0x2c>
8000aeba:	11 89       	ld.ub	r9,r8[0x0]
8000aebc:	30 08       	mov	r8,0
8000aebe:	f0 09 18 00 	cp.b	r9,r8
8000aec2:	c0 70       	breq	8000aed0 <nav_partition_mount+0x20>
   {
      // Already mounted
      // Go to root directory
      fs_g_nav.u32_cluster_sel_dir   = 0;
8000aec4:	30 09       	mov	r9,0
8000aec6:	48 78       	lddpc	r8,8000aee0 <nav_partition_mount+0x30>
8000aec8:	91 89       	st.w	r8[0x20],r9
      // No file is selected by default
      fat_clear_entry_info_and_ptr();
8000aeca:	f0 1f 00 07 	mcall	8000aee4 <nav_partition_mount+0x34>
8000aece:	da 0a       	popm	pc,r12=1
      return true;
   }

   return fat_mount();
8000aed0:	f0 1f 00 06 	mcall	8000aee8 <nav_partition_mount+0x38>
}
8000aed4:	d8 02       	popm	pc
8000aed6:	00 00       	add	r0,r0
8000aed8:	80 00       	ld.sh	r0,r0[0x0]
8000aeda:	a1 74       	lsl	r4,0x1
8000aedc:	00 00       	add	r0,r0
8000aede:	0c 64       	and	r4,r6
8000aee0:	00 00       	add	r0,r0
8000aee2:	0c 18       	sub	r8,r6
8000aee4:	80 00       	ld.sh	r0,r0[0x0]
8000aee6:	92 a0       	ld.uh	r0,r9[0x4]
8000aee8:	80 00       	ld.sh	r0,r0[0x0]
8000aeea:	a3 8c       	lsr	r12,0x2

8000aeec <nav_dir_root>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_dir_root( void )
{
8000aeec:	d4 01       	pushm	lr
   return nav_partition_mount();
8000aeee:	f0 1f 00 02 	mcall	8000aef4 <nav_dir_root+0x8>
}
8000aef2:	d8 02       	popm	pc
8000aef4:	80 00       	ld.sh	r0,r0[0x0]
8000aef6:	ae b0       	st.b	r7[0x3],r0

8000aef8 <nav_drive_set>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_drive_set( uint8_t u8_number )
{
8000aef8:	eb cd 40 80 	pushm	r7,lr
8000aefc:	18 97       	mov	r7,r12
   if ( !fat_check_noopen() )
8000aefe:	f0 1f 00 0f 	mcall	8000af38 <nav_drive_set+0x40>
8000af02:	c1 90       	breq	8000af34 <nav_drive_set+0x3c>
      return false;

   if (u8_number >= get_nb_lun() )
8000af04:	f0 1f 00 0e 	mcall	8000af3c <nav_drive_set+0x44>
8000af08:	ee 0c 18 00 	cp.b	r12,r7
8000af0c:	e0 8b 00 07 	brhi	8000af1a <nav_drive_set+0x22>
   {
      fs_g_status = FS_ERR_END_OF_DRIVE;   // The drive number is bad
8000af10:	30 69       	mov	r9,6
8000af12:	48 c8       	lddpc	r8,8000af40 <nav_drive_set+0x48>
8000af14:	b0 89       	st.b	r8[0x0],r9
8000af16:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
      return false;
   }

   if ( fs_g_nav.u8_lun == u8_number)
8000af1a:	48 b8       	lddpc	r8,8000af44 <nav_drive_set+0x4c>
8000af1c:	11 88       	ld.ub	r8,r8[0x0]
8000af1e:	ee 08 18 00 	cp.b	r8,r7
8000af22:	c0 31       	brne	8000af28 <nav_drive_set+0x30>
8000af24:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
      return true;   // It is the same drive number

   // Go to the device
   fs_g_nav.u8_lun = u8_number;
8000af28:	48 78       	lddpc	r8,8000af44 <nav_drive_set+0x4c>
8000af2a:	b0 87       	st.b	r8[0x0],r7
   fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM;
8000af2c:	30 09       	mov	r9,0
8000af2e:	48 78       	lddpc	r8,8000af48 <nav_drive_set+0x50>
8000af30:	b0 89       	st.b	r8[0x0],r9
8000af32:	30 1c       	mov	r12,1
#if (FS_MULTI_PARTITION  ==  true)
   fs_g_nav.u8_partition=0;   // by default select the first partition
#endif
   return true;
}
8000af34:	e3 cd 80 80 	ldm	sp++,r7,pc
8000af38:	80 00       	ld.sh	r0,r0[0x0]
8000af3a:	a1 74       	lsl	r4,0x1
8000af3c:	80 00       	ld.sh	r0,r0[0x0]
8000af3e:	b3 44       	asr	r4,0x12
8000af40:	00 00       	add	r0,r0
8000af42:	0c 68       	and	r8,r6
8000af44:	00 00       	add	r0,r0
8000af46:	0c 18       	sub	r8,r6
8000af48:	00 00       	add	r0,r0
8000af4a:	0c 64       	and	r4,r6

8000af4c <nav_drive_nb>:
//! @verbatim
//! This value may be dynamic because it depends of memory drivers (e.g. Mass Storage disk on USB host mode)
//! @endverbatim
//!
uint8_t    nav_drive_nb( void )
{
8000af4c:	d4 01       	pushm	lr
   return get_nb_lun(); // Number of devices = Number of lun
8000af4e:	f0 1f 00 02 	mcall	8000af54 <nav_drive_nb+0x8>
}
8000af52:	d8 02       	popm	pc
8000af54:	80 00       	ld.sh	r0,r0[0x0]
8000af56:	b3 44       	asr	r4,0x12

8000af58 <nav_select>:
//!
//! @return    false if ID navigator don't exist
//! @return    true otherwise
//!
bool  nav_select( uint8_t u8_idnav )
{
8000af58:	eb cd 40 80 	pushm	r7,lr
8000af5c:	18 97       	mov	r7,r12
   if( FS_NB_NAVIGATOR <= u8_idnav )
8000af5e:	30 18       	mov	r8,1
8000af60:	f0 0c 18 00 	cp.b	r12,r8
8000af64:	e0 88 00 07 	brls	8000af72 <nav_select+0x1a>
   {
      fs_g_status = FS_ERR_BAD_NAV;             // The navigator doesn't exist
8000af68:	32 79       	mov	r9,39
8000af6a:	48 b8       	lddpc	r8,8000af94 <nav_select+0x3c>
8000af6c:	b0 89       	st.b	r8[0x0],r9
8000af6e:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
      return false;
   }
#if (FS_NB_NAVIGATOR > 1)
   if( fs_g_u8_nav_selected != u8_idnav )
8000af72:	48 a8       	lddpc	r8,8000af98 <nav_select+0x40>
8000af74:	11 8c       	ld.ub	r12,r8[0x0]
8000af76:	ee 0c 18 00 	cp.b	r12,r7
8000af7a:	c0 31       	brne	8000af80 <nav_select+0x28>
8000af7c:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
   {
      fat_invert_nav( fs_g_u8_nav_selected );   // Deselect previous navigator = Select default navigator
8000af80:	f0 1f 00 07 	mcall	8000af9c <nav_select+0x44>
      fat_invert_nav( u8_idnav );               // Select new navigator
8000af84:	0e 9c       	mov	r12,r7
8000af86:	f0 1f 00 06 	mcall	8000af9c <nav_select+0x44>
      fs_g_u8_nav_selected = u8_idnav;
8000af8a:	48 48       	lddpc	r8,8000af98 <nav_select+0x40>
8000af8c:	b0 87       	st.b	r8[0x0],r7
8000af8e:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
8000af92:	00 00       	add	r0,r0
8000af94:	00 00       	add	r0,r0
8000af96:	0c 68       	and	r8,r6
8000af98:	00 00       	add	r0,r0
8000af9a:	0c e0       	st.h	--r6,r0
8000af9c:	80 00       	ld.sh	r0,r0[0x0]
8000af9e:	97 ec       	st.w	r11[0x38],r12

8000afa0 <nav_reset>:
//! @verbatim
//! Call this at the program startup or before a new session (e.g. USB Device exit)
//! @endverbatim
//!
void  nav_reset( void )
{
8000afa0:	eb cd 40 f8 	pushm	r3-r7,lr
#if ( (FS_ASCII   == true) && (FS_UNICODE == true))
   g_b_unicode = true;
#endif
   g_b_string_length = false;
8000afa4:	30 07       	mov	r7,0
8000afa6:	49 18       	lddpc	r8,8000afe8 <nav_reset+0x48>
8000afa8:	b0 87       	st.b	r8[0x0],r7
   g_b_no_check_disk = false;
8000afaa:	49 18       	lddpc	r8,8000afec <nav_reset+0x4c>
8000afac:	b0 87       	st.b	r8[0x0],r7

   fat_cache_reset();
8000afae:	f0 1f 00 11 	mcall	8000aff0 <nav_reset+0x50>
   fat_cache_clusterlist_reset();
8000afb2:	f0 1f 00 11 	mcall	8000aff4 <nav_reset+0x54>
   {
   uint8_t i;
   // Reset variables of each navigators
   for( i=0 ; i!=FS_NB_NAVIGATOR ; i++ )
   {
      nav_select(i);
8000afb6:	30 0c       	mov	r12,0
8000afb8:	f0 1f 00 10 	mcall	8000aff8 <nav_reset+0x58>
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
8000afbc:	49 03       	lddpc	r3,8000affc <nav_reset+0x5c>
8000afbe:	a6 87       	st.b	r3[0x0],r7
      fs_g_nav.u8_lun = 0xFF;                      // By default don't select a drive
8000afc0:	49 05       	lddpc	r5,8000b000 <nav_reset+0x60>
8000afc2:	3f f4       	mov	r4,-1
8000afc4:	aa 84       	st.b	r5[0x0],r4
#if (FS_MULTI_PARTITION  ==  true)
      fs_g_nav.u8_partition=0;                     // By default select the first partition
#endif
      Fat_file_close();                            // By default no file is opened
8000afc6:	49 06       	lddpc	r6,8000b004 <nav_reset+0x64>
8000afc8:	ac 87       	st.b	r6[0x0],r7
      fs_g_nav.b_mode_nav_single = false;          // By default display files and directories
8000afca:	eb 67 00 2d 	st.b	r5[45],r7
   {
   uint8_t i;
   // Reset variables of each navigators
   for( i=0 ; i!=FS_NB_NAVIGATOR ; i++ )
   {
      nav_select(i);
8000afce:	30 1c       	mov	r12,1
8000afd0:	f0 1f 00 0a 	mcall	8000aff8 <nav_reset+0x58>
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
8000afd4:	a6 87       	st.b	r3[0x0],r7
      fs_g_nav.u8_lun = 0xFF;                      // By default don't select a drive
8000afd6:	aa 84       	st.b	r5[0x0],r4
#if (FS_MULTI_PARTITION  ==  true)
      fs_g_nav.u8_partition=0;                     // By default select the first partition
#endif
      Fat_file_close();                            // By default no file is opened
8000afd8:	ac 87       	st.b	r6[0x0],r7
      fs_g_nav.b_mode_nav_single = false;          // By default display files and directories
8000afda:	eb 67 00 2d 	st.b	r5[45],r7
   }
   // By default select the navigator 0
   fs_g_u8_nav_selected = 0;
8000afde:	48 b8       	lddpc	r8,8000b008 <nav_reset+0x68>
8000afe0:	b0 87       	st.b	r8[0x0],r7
#  if (FS_MULTI_PARTITION  ==  true)
   fs_g_nav.u8_partition=0;                        // By default select the first partition
#  endif
   Fat_file_close();                               // By default no file is opened
#endif // (FS_NB_NAVIGATOR > 1)
}
8000afe2:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000afe6:	00 00       	add	r0,r0
8000afe8:	00 00       	add	r0,r0
8000afea:	0c 69       	and	r9,r6
8000afec:	00 00       	add	r0,r0
8000afee:	09 ea       	ld.ub	r10,r4[0x6]
8000aff0:	80 00       	ld.sh	r0,r0[0x0]
8000aff2:	96 fc       	ld.uh	r12,r11[0xe]
8000aff4:	80 00       	ld.sh	r0,r0[0x0]
8000aff6:	90 34       	ld.sh	r4,r8[0x6]
8000aff8:	80 00       	ld.sh	r0,r0[0x0]
8000affa:	af 58       	asr	r8,0xf
8000affc:	00 00       	add	r0,r0
8000affe:	0c 64       	and	r4,r6
8000b000:	00 00       	add	r0,r0
8000b002:	0c 18       	sub	r8,r6
8000b004:	00 00       	add	r0,r0
8000b006:	09 d8       	ld.ub	r8,r4[0x5]
8000b008:	00 00       	add	r0,r0
8000b00a:	0c e0       	st.h	--r6,r0

8000b00c <update_counter>:
//! @param  counter the counter
//! @return false if the counter reaches the end
//!         true otherwise
static bool update_counter(uint8_t *counter)
{
  if (*counter)
8000b00c:	19 88       	ld.ub	r8,r12[0x0]
    (*counter)--;
8000b00e:	58 08       	cp.w	r8,0
8000b010:	f7 b8 01 01 	subne	r8,1
8000b014:	f9 f8 1e 00 	st.bne	r12[0x0],r8
8000b018:	19 89       	ld.ub	r9,r12[0x0]
8000b01a:	30 08       	mov	r8,0
8000b01c:	f0 09 18 00 	cp.b	r9,r8
  if (!*counter)
    return false;
  return true;
}
8000b020:	5f 1c       	srne	r12
8000b022:	5e fc       	retal	r12

8000b024 <nav_filterlist_root>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filterlist_root( void )
{
8000b024:	d4 01       	pushm	lr
   fs_g_nav.u16_pos_filterlist = FS_NO_SEL;
8000b026:	3f f9       	mov	r9,-1
8000b028:	48 38       	lddpc	r8,8000b034 <nav_filterlist_root+0x10>
8000b02a:	f1 59 00 26 	st.h	r8[38],r9
   return nav_dir_root();
8000b02e:	f0 1f 00 03 	mcall	8000b038 <nav_filterlist_root+0x14>
}
8000b032:	d8 02       	popm	pc
8000b034:	00 00       	add	r0,r0
8000b036:	0c 18       	sub	r8,r6
8000b038:	80 00       	ld.sh	r0,r0[0x0]
8000b03a:	ae ec       	st.b	r7[0x6],r12

8000b03c <nav_filterlist_previous>:
//!
//! @return    false in case of an error or no next file, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_filterlist_previous( void )
{
8000b03c:	eb cd 40 e0 	pushm	r5-r7,lr
   uint16_t u16_current_pos;
   u16_current_pos = nav_filelist_get();
8000b040:	f0 1f 00 11 	mcall	8000b084 <nav_filterlist_previous+0x48>
8000b044:	eb dc b0 10 	bfexts	r5,r12,0x0,0x10
   while( nav_filelist_set( 0, FS_FIND_PREV ) )
8000b048:	30 07       	mov	r7,0
   {
      if( nav_file_isdir()
8000b04a:	49 06       	lddpc	r6,8000b088 <nav_filterlist_previous+0x4c>
//!
bool  nav_filterlist_previous( void )
{
   uint16_t u16_current_pos;
   u16_current_pos = nav_filelist_get();
   while( nav_filelist_set( 0, FS_FIND_PREV ) )
8000b04c:	c1 08       	rjmp	8000b06c <nav_filterlist_previous+0x30>
   {
      if( nav_file_isdir()
8000b04e:	f0 1f 00 10 	mcall	8000b08c <nav_filterlist_previous+0x50>
8000b052:	c0 51       	brne	8000b05c <nav_filterlist_previous+0x20>
8000b054:	6c ac       	ld.w	r12,r6[0x28]
8000b056:	f0 1f 00 0f 	mcall	8000b090 <nav_filterlist_previous+0x54>
8000b05a:	c0 90       	breq	8000b06c <nav_filterlist_previous+0x30>
      ||  nav_file_checkext( fs_g_nav.sz_filterext ) )
      {
         fs_g_nav.u16_pos_filterlist--;
8000b05c:	48 b8       	lddpc	r8,8000b088 <nav_filterlist_previous+0x4c>
8000b05e:	f1 09 00 26 	ld.sh	r9,r8[38]
8000b062:	20 19       	sub	r9,1
8000b064:	f1 59 00 26 	st.h	r8[38],r9
8000b068:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
//!
bool  nav_filterlist_previous( void )
{
   uint16_t u16_current_pos;
   u16_current_pos = nav_filelist_get();
   while( nav_filelist_set( 0, FS_FIND_PREV ) )
8000b06c:	0e 9b       	mov	r11,r7
8000b06e:	0e 9c       	mov	r12,r7
8000b070:	f0 1f 00 09 	mcall	8000b094 <nav_filterlist_previous+0x58>
8000b074:	ce d1       	brne	8000b04e <nav_filterlist_previous+0x12>
      {
         fs_g_nav.u16_pos_filterlist--;
         return true;
      }
   }
   nav_filelist_goto( u16_current_pos );
8000b076:	f9 d5 c0 10 	bfextu	r12,r5,0x0,0x10
8000b07a:	f0 1f 00 08 	mcall	8000b098 <nav_filterlist_previous+0x5c>
8000b07e:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
8000b082:	00 00       	add	r0,r0
8000b084:	80 00       	ld.sh	r0,r0[0x0]
8000b086:	aa 70       	st.h	r5[0xe],r0
8000b088:	00 00       	add	r0,r0
8000b08a:	0c 18       	sub	r8,r6
8000b08c:	80 00       	ld.sh	r0,r0[0x0]
8000b08e:	aa b4       	st.b	r5[0x3],r4
8000b090:	80 00       	ld.sh	r0,r0[0x0]
8000b092:	aa 88       	st.b	r5[0x0],r8
8000b094:	80 00       	ld.sh	r0,r0[0x0]
8000b096:	ab b4       	sbr	r4,0xb
8000b098:	80 00       	ld.sh	r0,r0[0x0]
8000b09a:	ad e4       	*unknown*

8000b09c <nav_filterlist_next>:
//!
//! @return    false in case of error or no next file, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_filterlist_next( void )
{
8000b09c:	d4 21       	pushm	r4-r7,lr
   uint16_t u16_current_pos;
   u16_current_pos = nav_filelist_get();
8000b09e:	f0 1f 00 15 	mcall	8000b0f0 <nav_filterlist_next+0x54>
8000b0a2:	e9 dc b0 10 	bfexts	r4,r12,0x0,0x10
   while( nav_filelist_set( 0, FS_FIND_NEXT ) )
8000b0a6:	30 16       	mov	r6,1
8000b0a8:	30 07       	mov	r7,0
   {
      if( nav_file_isdir()
8000b0aa:	49 35       	lddpc	r5,8000b0f4 <nav_filterlist_next+0x58>
//!
bool  nav_filterlist_next( void )
{
   uint16_t u16_current_pos;
   u16_current_pos = nav_filelist_get();
   while( nav_filelist_set( 0, FS_FIND_NEXT ) )
8000b0ac:	c1 88       	rjmp	8000b0dc <nav_filterlist_next+0x40>
   {
      if( nav_file_isdir()
8000b0ae:	f0 1f 00 13 	mcall	8000b0f8 <nav_filterlist_next+0x5c>
8000b0b2:	c0 51       	brne	8000b0bc <nav_filterlist_next+0x20>
8000b0b4:	6a ac       	ld.w	r12,r5[0x28]
8000b0b6:	f0 1f 00 12 	mcall	8000b0fc <nav_filterlist_next+0x60>
8000b0ba:	c1 10       	breq	8000b0dc <nav_filterlist_next+0x40>
      ||  nav_file_checkext( fs_g_nav.sz_filterext ) )
      {
         if( FS_NO_SEL == u16_current_pos )
8000b0bc:	3f f8       	mov	r8,-1
8000b0be:	f0 04 19 00 	cp.h	r4,r8
8000b0c2:	c0 61       	brne	8000b0ce <nav_filterlist_next+0x32>
         {
            fs_g_nav.u16_pos_filterlist = 0;
8000b0c4:	30 09       	mov	r9,0
8000b0c6:	48 c8       	lddpc	r8,8000b0f4 <nav_filterlist_next+0x58>
8000b0c8:	f1 59 00 26 	st.h	r8[38],r9
8000b0cc:	da 2a       	popm	r4-r7,pc,r12=1
         }else{
            fs_g_nav.u16_pos_filterlist++;
8000b0ce:	48 a8       	lddpc	r8,8000b0f4 <nav_filterlist_next+0x58>
8000b0d0:	f1 09 00 26 	ld.sh	r9,r8[38]
8000b0d4:	2f f9       	sub	r9,-1
8000b0d6:	f1 59 00 26 	st.h	r8[38],r9
8000b0da:	da 2a       	popm	r4-r7,pc,r12=1
//!
bool  nav_filterlist_next( void )
{
   uint16_t u16_current_pos;
   u16_current_pos = nav_filelist_get();
   while( nav_filelist_set( 0, FS_FIND_NEXT ) )
8000b0dc:	0c 9b       	mov	r11,r6
8000b0de:	0e 9c       	mov	r12,r7
8000b0e0:	f0 1f 00 08 	mcall	8000b100 <nav_filterlist_next+0x64>
8000b0e4:	ce 51       	brne	8000b0ae <nav_filterlist_next+0x12>
            fs_g_nav.u16_pos_filterlist++;
         }
         return true;
      }
   }
   nav_filelist_goto( u16_current_pos );
8000b0e6:	08 9c       	mov	r12,r4
8000b0e8:	5c 7c       	castu.h	r12
8000b0ea:	f0 1f 00 07 	mcall	8000b104 <nav_filterlist_next+0x68>
8000b0ee:	d8 2a       	popm	r4-r7,pc,r12=0
8000b0f0:	80 00       	ld.sh	r0,r0[0x0]
8000b0f2:	aa 70       	st.h	r5[0xe],r0
8000b0f4:	00 00       	add	r0,r0
8000b0f6:	0c 18       	sub	r8,r6
8000b0f8:	80 00       	ld.sh	r0,r0[0x0]
8000b0fa:	aa b4       	st.b	r5[0x3],r4
8000b0fc:	80 00       	ld.sh	r0,r0[0x0]
8000b0fe:	aa 88       	st.b	r5[0x0],r8
8000b100:	80 00       	ld.sh	r0,r0[0x0]
8000b102:	ab b4       	sbr	r4,0xb
8000b104:	80 00       	ld.sh	r0,r0[0x0]
8000b106:	ad e4       	*unknown*

8000b108 <nav_filterlist_reset>:
//!
//! @return  false in case of an error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filterlist_reset( void )
{
8000b108:	d4 01       	pushm	lr
   fs_g_nav.u16_pos_filterlist = FS_NO_SEL;
8000b10a:	3f f9       	mov	r9,-1
8000b10c:	48 38       	lddpc	r8,8000b118 <nav_filterlist_reset+0x10>
8000b10e:	f1 59 00 26 	st.h	r8[38],r9
   return nav_filelist_reset();
8000b112:	f0 1f 00 03 	mcall	8000b11c <nav_filterlist_reset+0x14>
}
8000b116:	d8 02       	popm	pc
8000b118:	00 00       	add	r0,r0
8000b11a:	0c 18       	sub	r8,r6
8000b11c:	80 00       	ld.sh	r0,r0[0x0]
8000b11e:	ad 1c       	ld.d	r12,--r6

8000b120 <nav_filterlist_goto>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_filterlist_goto( uint16_t u16_newpos )
{
8000b120:	eb cd 40 c0 	pushm	r6-r7,lr
8000b124:	18 97       	mov	r7,r12
   if (u16_newpos == FS_NO_SEL)
8000b126:	3f f8       	mov	r8,-1
8000b128:	f0 0c 19 00 	cp.h	r12,r8
8000b12c:	c0 51       	brne	8000b136 <nav_filterlist_goto+0x16>
     return nav_filterlist_reset();
8000b12e:	f0 1f 00 1d 	mcall	8000b1a0 <nav_filterlist_goto+0x80>
8000b132:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

   if( u16_newpos < (fs_g_nav.u16_pos_filterlist/2) )
8000b136:	49 c8       	lddpc	r8,8000b1a4 <nav_filterlist_goto+0x84>
8000b138:	f1 18 00 26 	ld.uh	r8,r8[38]
8000b13c:	a1 98       	lsr	r8,0x1
8000b13e:	f0 0c 19 00 	cp.h	r12,r8
8000b142:	c0 42       	brcc	8000b14a <nav_filterlist_goto+0x2a>
   {
      // Restart at the beginning of list to accelerate search
      if( !nav_filterlist_reset() )
8000b144:	f0 1f 00 17 	mcall	8000b1a0 <nav_filterlist_goto+0x80>
8000b148:	c2 a0       	breq	8000b19c <nav_filterlist_goto+0x7c>
         return false;
   }
   if( FS_NO_SEL == fs_g_nav.u16_pos_filterlist )
8000b14a:	49 78       	lddpc	r8,8000b1a4 <nav_filterlist_goto+0x84>
8000b14c:	f1 09 00 26 	ld.sh	r9,r8[38]
8000b150:	3f f8       	mov	r8,-1
8000b152:	f0 09 19 00 	cp.h	r9,r8
8000b156:	c0 91       	brne	8000b168 <nav_filterlist_goto+0x48>
      if( !nav_filterlist_next() )
8000b158:	f0 1f 00 14 	mcall	8000b1a8 <nav_filterlist_goto+0x88>
8000b15c:	c0 61       	brne	8000b168 <nav_filterlist_goto+0x48>
8000b15e:	c1 f8       	rjmp	8000b19c <nav_filterlist_goto+0x7c>
         return false;  // No file available
   while( u16_newpos > fs_g_nav.u16_pos_filterlist )
   {
      if( !nav_filterlist_next() )
8000b160:	f0 1f 00 12 	mcall	8000b1a8 <nav_filterlist_goto+0x88>
8000b164:	c0 31       	brne	8000b16a <nav_filterlist_goto+0x4a>
8000b166:	c0 c8       	rjmp	8000b17e <nav_filterlist_goto+0x5e>
         return false;
   }
   if( FS_NO_SEL == fs_g_nav.u16_pos_filterlist )
      if( !nav_filterlist_next() )
         return false;  // No file available
   while( u16_newpos > fs_g_nav.u16_pos_filterlist )
8000b168:	48 f6       	lddpc	r6,8000b1a4 <nav_filterlist_goto+0x84>
8000b16a:	ed 08 00 26 	ld.sh	r8,r6[38]
8000b16e:	ee 08 19 00 	cp.h	r8,r7
8000b172:	cf 73       	brcs	8000b160 <nav_filterlist_goto+0x40>
8000b174:	c0 58       	rjmp	8000b17e <nav_filterlist_goto+0x5e>
      if( !nav_filterlist_next() )
         break;
   }
   while( u16_newpos < fs_g_nav.u16_pos_filterlist )
   {
      if( !nav_filterlist_previous() )
8000b176:	f0 1f 00 0e 	mcall	8000b1ac <nav_filterlist_goto+0x8c>
8000b17a:	c0 31       	brne	8000b180 <nav_filterlist_goto+0x60>
8000b17c:	c0 88       	rjmp	8000b18c <nav_filterlist_goto+0x6c>
   while( u16_newpos > fs_g_nav.u16_pos_filterlist )
   {
      if( !nav_filterlist_next() )
         break;
   }
   while( u16_newpos < fs_g_nav.u16_pos_filterlist )
8000b17e:	48 a6       	lddpc	r6,8000b1a4 <nav_filterlist_goto+0x84>
8000b180:	ed 08 00 26 	ld.sh	r8,r6[38]
8000b184:	ee 08 19 00 	cp.h	r8,r7
8000b188:	fe 9b ff f7 	brhi	8000b176 <nav_filterlist_goto+0x56>
   {
      if( !nav_filterlist_previous() )
         break;
   }
   return (u16_newpos == fs_g_nav.u16_pos_filterlist);
8000b18c:	48 68       	lddpc	r8,8000b1a4 <nav_filterlist_goto+0x84>
8000b18e:	f1 08 00 26 	ld.sh	r8,r8[38]
8000b192:	ee 08 19 00 	cp.h	r8,r7
8000b196:	5f 0c       	sreq	r12
8000b198:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000b19c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
8000b1a0:	80 00       	ld.sh	r0,r0[0x0]
8000b1a2:	b1 08       	ld.d	r8,r8
8000b1a4:	00 00       	add	r0,r0
8000b1a6:	0c 18       	sub	r8,r6
8000b1a8:	80 00       	ld.sh	r0,r0[0x0]
8000b1aa:	b0 9c       	st.b	r8[0x1],r12
8000b1ac:	80 00       	ld.sh	r0,r0[0x0]
8000b1ae:	b0 3c       	st.h	r8[0x6],r12

8000b1b0 <nav_filterlist_nb_ex>:
//!                           function is blocking until the result is known.
//!
//! @return     number of files and/or directories present in filtered file list.
//!
bool   nav_filterlist_nb_ex( fl_type_t fl_type, const FS_STRING sz_filterext, uint16_t* p_total, uint8_t retry )
{
8000b1b0:	eb cd 40 fe 	pushm	r1-r7,lr
8000b1b4:	20 1d       	sub	sp,4
8000b1b6:	18 96       	mov	r6,r12
8000b1b8:	16 94       	mov	r4,r11
8000b1ba:	14 97       	mov	r7,r10
8000b1bc:	ba 89       	st.b	sp[0x0],r9
   static uint16_t   u16_save_position;
   bool   b_is_dir;

   // save current position
   if( *p_total==(uint16_t) -1 )
8000b1be:	94 09       	ld.sh	r9,r10[0x0]
8000b1c0:	3f f8       	mov	r8,-1
8000b1c2:	f0 09 19 00 	cp.h	r9,r8
8000b1c6:	c4 c1       	brne	8000b25e <nav_filterlist_nb_ex+0xae>
   {
      u16_save_position = fs_g_nav.u16_pos_filterlist;
8000b1c8:	4b 58       	lddpc	r8,8000b29c <nav_filterlist_nb_ex+0xec>
8000b1ca:	f1 09 00 26 	ld.sh	r9,r8[38]
8000b1ce:	4b 58       	lddpc	r8,8000b2a0 <nav_filterlist_nb_ex+0xf0>
8000b1d0:	b0 09       	st.h	r8[0x0],r9

      // Reset position
      if ( !nav_filterlist_reset())
8000b1d2:	f0 1f 00 35 	mcall	8000b2a4 <nav_filterlist_nb_ex+0xf4>
8000b1d6:	c0 31       	brne	8000b1dc <nav_filterlist_nb_ex+0x2c>
8000b1d8:	30 1c       	mov	r12,1
8000b1da:	c5 e8       	rjmp	8000b296 <nav_filterlist_nb_ex+0xe6>
         return true;

      if (fl_type == FL_DIR)
8000b1dc:	58 16       	cp.w	r6,1
8000b1de:	c0 51       	brne	8000b1e8 <nav_filterlist_nb_ex+0x38>
        nav_filelist_single_enable(FS_DIR);
8000b1e0:	30 0c       	mov	r12,0
8000b1e2:	f0 1f 00 32 	mcall	8000b2a8 <nav_filterlist_nb_ex+0xf8>
8000b1e6:	c0 68       	rjmp	8000b1f2 <nav_filterlist_nb_ex+0x42>
      else if (fl_type == FL_FILE)
8000b1e8:	58 06       	cp.w	r6,0
8000b1ea:	c0 41       	brne	8000b1f2 <nav_filterlist_nb_ex+0x42>
        nav_filelist_single_enable(FS_FILE);
8000b1ec:	30 1c       	mov	r12,1
8000b1ee:	f0 1f 00 2f 	mcall	8000b2a8 <nav_filterlist_nb_ex+0xf8>

      *p_total = 0;
8000b1f2:	30 08       	mov	r8,0
8000b1f4:	ae 08       	st.h	r7[0x0],r8
8000b1f6:	c3 48       	rjmp	8000b25e <nav_filterlist_nb_ex+0xae>
   }

   // Scan all
   while( nav_filelist_set( 0, FS_FIND_NEXT ) )
   {
      b_is_dir = nav_file_isdir();
8000b1f8:	f0 1f 00 2d 	mcall	8000b2ac <nav_filterlist_nb_ex+0xfc>

      // Check if its a file for FL_FILE mode
      if (fl_type == FL_FILE && b_is_dir)
8000b1fc:	58 06       	cp.w	r6,0
8000b1fe:	c0 81       	brne	8000b20e <nav_filterlist_nb_ex+0x5e>
8000b200:	58 0c       	cp.w	r12,0
8000b202:	c1 10       	breq	8000b224 <nav_filterlist_nb_ex+0x74>
      {
        if (!update_counter(&retry))
8000b204:	1a 9c       	mov	r12,sp
8000b206:	f0 1f 00 2b 	mcall	8000b2b0 <nav_filterlist_nb_ex+0x100>
8000b20a:	c2 e1       	brne	8000b266 <nav_filterlist_nb_ex+0xb6>
8000b20c:	c4 48       	rjmp	8000b294 <nav_filterlist_nb_ex+0xe4>
          return false;
        continue;
      }
      // Check if its a directory for FL_DIR mode
      if (fl_type == FL_DIR && !b_is_dir)
8000b20e:	58 16       	cp.w	r6,1
8000b210:	c0 81       	brne	8000b220 <nav_filterlist_nb_ex+0x70>
8000b212:	58 0c       	cp.w	r12,0
8000b214:	c1 d1       	brne	8000b24e <nav_filterlist_nb_ex+0x9e>
      {
        if (!update_counter(&retry))
8000b216:	1a 9c       	mov	r12,sp
8000b218:	f0 1f 00 26 	mcall	8000b2b0 <nav_filterlist_nb_ex+0x100>
8000b21c:	c2 51       	brne	8000b266 <nav_filterlist_nb_ex+0xb6>
8000b21e:	c3 b8       	rjmp	8000b294 <nav_filterlist_nb_ex+0xe4>
          return false;
        continue;
      }
      // If the selection is on a file
      if (!b_is_dir)
8000b220:	58 0c       	cp.w	r12,0
8000b222:	c1 61       	brne	8000b24e <nav_filterlist_nb_ex+0x9e>
      {
        // Check the extension of the file
        if (!((sz_filterext)?nav_file_checkext(sz_filterext):nav_file_checkext(fs_g_nav.sz_filterext)))
8000b224:	58 04       	cp.w	r4,0
8000b226:	c0 80       	breq	8000b236 <nav_filterlist_nb_ex+0x86>
8000b228:	08 9c       	mov	r12,r4
8000b22a:	f0 1f 00 23 	mcall	8000b2b4 <nav_filterlist_nb_ex+0x104>
8000b22e:	ec 1c 00 01 	eorl	r12,0x1
8000b232:	5c 5c       	castu.b	r12
8000b234:	c0 78       	rjmp	8000b242 <nav_filterlist_nb_ex+0x92>
8000b236:	62 ac       	ld.w	r12,r1[0x28]
8000b238:	f0 1f 00 1f 	mcall	8000b2b4 <nav_filterlist_nb_ex+0x104>
8000b23c:	ec 1c 00 01 	eorl	r12,0x1
8000b240:	5c 5c       	castu.b	r12
8000b242:	58 0c       	cp.w	r12,0
8000b244:	c0 50       	breq	8000b24e <nav_filterlist_nb_ex+0x9e>
          if (!update_counter(&retry))
8000b246:	1a 9c       	mov	r12,sp
8000b248:	f0 1f 00 1a 	mcall	8000b2b0 <nav_filterlist_nb_ex+0x100>
8000b24c:	c2 40       	breq	8000b294 <nav_filterlist_nb_ex+0xe4>
            return false;
      }

      (*p_total)++;
8000b24e:	8e 08       	ld.sh	r8,r7[0x0]
8000b250:	2f f8       	sub	r8,-1
8000b252:	ae 08       	st.h	r7[0x0],r8
      if (!update_counter(&retry))
8000b254:	1a 9c       	mov	r12,sp
8000b256:	f0 1f 00 17 	mcall	8000b2b0 <nav_filterlist_nb_ex+0x100>
8000b25a:	c0 61       	brne	8000b266 <nav_filterlist_nb_ex+0xb6>
8000b25c:	c1 c8       	rjmp	8000b294 <nav_filterlist_nb_ex+0xe4>

      *p_total = 0;
   }

   // Scan all
   while( nav_filelist_set( 0, FS_FIND_NEXT ) )
8000b25e:	30 13       	mov	r3,1
8000b260:	30 02       	mov	r2,0
          if (!update_counter(&retry))
            return false;
      }

      (*p_total)++;
      if (!update_counter(&retry))
8000b262:	1a 95       	mov	r5,sp
      }
      // If the selection is on a file
      if (!b_is_dir)
      {
        // Check the extension of the file
        if (!((sz_filterext)?nav_file_checkext(sz_filterext):nav_file_checkext(fs_g_nav.sz_filterext)))
8000b264:	48 e1       	lddpc	r1,8000b29c <nav_filterlist_nb_ex+0xec>

      *p_total = 0;
   }

   // Scan all
   while( nav_filelist_set( 0, FS_FIND_NEXT ) )
8000b266:	06 9b       	mov	r11,r3
8000b268:	04 9c       	mov	r12,r2
8000b26a:	f0 1f 00 14 	mcall	8000b2b8 <nav_filterlist_nb_ex+0x108>
8000b26e:	cc 51       	brne	8000b1f8 <nav_filterlist_nb_ex+0x48>
      (*p_total)++;
      if (!update_counter(&retry))
         return false;
   }

   nav_filelist_single_disable();
8000b270:	f0 1f 00 13 	mcall	8000b2bc <nav_filterlist_nb_ex+0x10c>

   // Restore previous position
   if ( u16_save_position != FS_NO_SEL )
8000b274:	48 b8       	lddpc	r8,8000b2a0 <nav_filterlist_nb_ex+0xf0>
8000b276:	90 09       	ld.sh	r9,r8[0x0]
8000b278:	3f f8       	mov	r8,-1
8000b27a:	f0 09 19 00 	cp.h	r9,r8
8000b27e:	c0 50       	breq	8000b288 <nav_filterlist_nb_ex+0xd8>
   {
      nav_filterlist_reset();
8000b280:	f0 1f 00 09 	mcall	8000b2a4 <nav_filterlist_nb_ex+0xf4>
8000b284:	30 1c       	mov	r12,1
8000b286:	c0 88       	rjmp	8000b296 <nav_filterlist_nb_ex+0xe6>
   }else{
      // After operation, there are a file selected
      nav_filterlist_goto( u16_save_position );
8000b288:	e0 6c ff ff 	mov	r12,65535
8000b28c:	f0 1f 00 0d 	mcall	8000b2c0 <nav_filterlist_nb_ex+0x110>
8000b290:	30 1c       	mov	r12,1
8000b292:	c0 28       	rjmp	8000b296 <nav_filterlist_nb_ex+0xe6>
8000b294:	30 0c       	mov	r12,0
   }
   return true;
}
8000b296:	2f fd       	sub	sp,-4
8000b298:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000b29c:	00 00       	add	r0,r0
8000b29e:	0c 18       	sub	r8,r6
8000b2a0:	00 00       	add	r0,r0
8000b2a2:	07 58       	ld.sh	r8,--r3
8000b2a4:	80 00       	ld.sh	r0,r0[0x0]
8000b2a6:	b1 08       	ld.d	r8,r8
8000b2a8:	80 00       	ld.sh	r0,r0[0x0]
8000b2aa:	ae 88       	st.b	r7[0x0],r8
8000b2ac:	80 00       	ld.sh	r0,r0[0x0]
8000b2ae:	aa b4       	st.b	r5[0x3],r4
8000b2b0:	80 00       	ld.sh	r0,r0[0x0]
8000b2b2:	b0 0c       	st.h	r8[0x0],r12
8000b2b4:	80 00       	ld.sh	r0,r0[0x0]
8000b2b6:	aa 88       	st.b	r5[0x0],r8
8000b2b8:	80 00       	ld.sh	r0,r0[0x0]
8000b2ba:	ab b4       	sbr	r4,0xb
8000b2bc:	80 00       	ld.sh	r0,r0[0x0]
8000b2be:	ae 70       	st.h	r7[0xe],r0
8000b2c0:	80 00       	ld.sh	r0,r0[0x0]
8000b2c2:	b1 20       	st.d	r8++,r0

8000b2c4 <nav_filterlist_nb>:
//!                           This argument is also ignored for b_type == FS_DIR.
//!
//! @return     number of files and/or directories present in filtered file list.
//!
uint16_t   nav_filterlist_nb( fl_type_t fl_type, const FS_STRING sz_filterext )
{
8000b2c4:	d4 21       	pushm	r4-r7,lr
8000b2c6:	20 1d       	sub	sp,4
8000b2c8:	18 96       	mov	r6,r12
8000b2ca:	16 95       	mov	r5,r11
   uint16_t total=(uint16_t)-1; // Initialization is mandatory
8000b2cc:	fa c7 ff fc 	sub	r7,sp,-4
8000b2d0:	3f f8       	mov	r8,-1
8000b2d2:	0e e8       	st.h	--r7,r8
   while( !nav_filterlist_nb_ex( fl_type, sz_filterext, &total, 0 ) );
8000b2d4:	30 04       	mov	r4,0
8000b2d6:	08 99       	mov	r9,r4
8000b2d8:	0e 9a       	mov	r10,r7
8000b2da:	0a 9b       	mov	r11,r5
8000b2dc:	0c 9c       	mov	r12,r6
8000b2de:	f0 1f 00 04 	mcall	8000b2ec <nav_filterlist_nb+0x28>
8000b2e2:	cf a0       	breq	8000b2d6 <nav_filterlist_nb+0x12>
   return total;
}
8000b2e4:	9a 1c       	ld.sh	r12,sp[0x2]
8000b2e6:	2f fd       	sub	sp,-4
8000b2e8:	d8 22       	popm	r4-r7,pc
8000b2ea:	00 00       	add	r0,r0
8000b2ec:	80 00       	ld.sh	r0,r0[0x0]
8000b2ee:	b1 b0       	sbr	r0,0x11

8000b2f0 <nav_filterlist_setfilter>:
//! This function affiliates an extension filter at current navigator
//!
//! @param     sz_filterext   extension filter (ASCII format, e.g.: "txt" or "txt,d*,wk" )
//!
void  nav_filterlist_setfilter( const FS_STRING sz_filterext  )
{
8000b2f0:	d4 01       	pushm	lr
   fs_g_nav.sz_filterext = sz_filterext;
8000b2f2:	48 38       	lddpc	r8,8000b2fc <nav_filterlist_setfilter+0xc>
8000b2f4:	91 ac       	st.w	r8[0x28],r12
   nav_filterlist_reset();
8000b2f6:	f0 1f 00 03 	mcall	8000b300 <nav_filterlist_setfilter+0x10>
}
8000b2fa:	d8 02       	popm	pc
8000b2fc:	00 00       	add	r0,r0
8000b2fe:	0c 18       	sub	r8,r6
8000b300:	80 00       	ld.sh	r0,r0[0x0]
8000b302:	b1 08       	ld.d	r8,r8

8000b304 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
8000b304:	e0 7d 00 00 	mov	sp,65536

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
8000b308:	fe c0 85 08 	sub	r0,pc,-31480

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
8000b30c:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
8000b310:	d5 53       	csrf	0x15
  cp      r0, r1
8000b312:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
8000b314:	e0 61 06 40 	mov	r1,1600
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
8000b318:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
8000b31a:	c0 62       	brcc	8000b326 <idata_load_loop_end>
  cp      r0, r1
8000b31c:	48 92       	lddpc	r2,8000b340 <udata_clear_loop_end+0x4>

8000b31e <idata_load_loop>:
  brlo    idata_load_loop
8000b31e:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
8000b320:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
8000b322:	02 30       	cp.w	r0,r1
  cp      r0, r1
8000b324:	cf d3       	brcs	8000b31e <idata_load_loop>

8000b326 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
8000b326:	e0 60 06 40 	mov	r0,1600
  mov     r2, 0
  mov     r3, 0
8000b32a:	e0 61 0f 00 	mov	r1,3840
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
8000b32e:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
8000b330:	c0 62       	brcc	8000b33c <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
8000b332:	30 02       	mov	r2,0
8000b334:	30 03       	mov	r3,0

8000b336 <udata_clear_loop>:
8000b336:	a1 22       	st.d	r0++,r2
8000b338:	02 30       	cp.w	r0,r1
8000b33a:	cf e3       	brcs	8000b336 <udata_clear_loop>

8000b33c <udata_clear_loop_end>:
8000b33c:	fe cf fd e8 	sub	pc,pc,-536
8000b340:	80 01       	ld.sh	r1,r0[0x0]
8000b342:	6f 40       	ld.w	r0,r7[0x50]

8000b344 <get_nb_lun>:

  return nb_lun;
#else
  return MAX_LUN;
#endif
}
8000b344:	5e ff       	retal	1
8000b346:	d7 03       	nop

8000b348 <mem_test_unit_ready>:
  return LUN_ID_0;
}


Ctrl_status mem_test_unit_ready(U8 lun)
{
8000b348:	d4 01       	pushm	lr
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
8000b34a:	58 0c       	cp.w	r12,0
8000b34c:	c0 20       	breq	8000b350 <mem_test_unit_ready+0x8>
8000b34e:	da 0a       	popm	pc,r12=1
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].test_unit_ready() :
8000b350:	48 28       	lddpc	r8,8000b358 <mem_test_unit_ready+0x10>
8000b352:	70 0c       	ld.w	r12,r8[0x0]
8000b354:	5d 1c       	icall	r12
#endif

  Ctrl_access_unlock();

  return status;
}
8000b356:	d8 02       	popm	pc
8000b358:	80 01       	ld.sh	r1,r0[0x0]
8000b35a:	62 68       	ld.w	r8,r1[0x18]

8000b35c <mem_sector_size>:
  return status;
}


U8 mem_sector_size(U8 lun)
{
8000b35c:	58 0c       	cp.w	r12,0
#endif

  Ctrl_access_unlock();

  return sector_size;
}
8000b35e:	5f 0c       	sreq	r12
8000b360:	5e fc       	retal	r12
8000b362:	d7 03       	nop

8000b364 <mem_wr_protect>:

  return unloaded;
}

bool mem_wr_protect(U8 lun)
{
8000b364:	d4 01       	pushm	lr
  bool wr_protect;

  if (!Ctrl_access_lock()) return true;

  wr_protect =
8000b366:	58 0c       	cp.w	r12,0
8000b368:	c0 20       	breq	8000b36c <mem_wr_protect+0x8>
8000b36a:	da 0a       	popm	pc,r12=1
#if MAX_LUN
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
8000b36c:	48 28       	lddpc	r8,8000b374 <mem_wr_protect+0x10>
8000b36e:	70 3c       	ld.w	r12,r8[0xc]
8000b370:	5d 1c       	icall	r12
#endif

  Ctrl_access_unlock();

  return wr_protect;
}
8000b372:	d8 02       	popm	pc
8000b374:	80 01       	ld.sh	r1,r0[0x0]
8000b376:	62 68       	ld.w	r8,r1[0x18]

8000b378 <memory_2_ram>:
 */
//! @{


Ctrl_status memory_2_ram(U8 lun, U32 addr, void *ram)
{
8000b378:	d4 01       	pushm	lr
8000b37a:	16 98       	mov	r8,r11
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
8000b37c:	58 0c       	cp.w	r12,0
8000b37e:	c0 20       	breq	8000b382 <memory_2_ram+0xa>
8000b380:	da 0a       	popm	pc,r12=1
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].mem_2_ram(addr, ram) :
8000b382:	48 49       	lddpc	r9,8000b390 <memory_2_ram+0x18>
8000b384:	72 59       	ld.w	r9,r9[0x14]
8000b386:	14 9b       	mov	r11,r10
8000b388:	10 9c       	mov	r12,r8
8000b38a:	5d 19       	icall	r9
  memory_stop_read_action();

  Ctrl_access_unlock();

  return status;
}
8000b38c:	d8 02       	popm	pc
8000b38e:	00 00       	add	r0,r0
8000b390:	80 01       	ld.sh	r1,r0[0x0]
8000b392:	62 68       	ld.w	r8,r1[0x18]

8000b394 <ram_2_memory>:


Ctrl_status ram_2_memory(U8 lun, U32 addr, const void *ram)
{
8000b394:	d4 01       	pushm	lr
8000b396:	16 98       	mov	r8,r11
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_write_action(1);
  status =
8000b398:	58 0c       	cp.w	r12,0
8000b39a:	c0 20       	breq	8000b39e <ram_2_memory+0xa>
8000b39c:	da 0a       	popm	pc,r12=1
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].ram_2_mem(addr, ram) :
8000b39e:	48 49       	lddpc	r9,8000b3ac <ram_2_memory+0x18>
8000b3a0:	72 69       	ld.w	r9,r9[0x18]
8000b3a2:	14 9b       	mov	r11,r10
8000b3a4:	10 9c       	mov	r12,r8
8000b3a6:	5d 19       	icall	r9
  memory_stop_write_action();

  Ctrl_access_unlock();

  return status;
}
8000b3a8:	d8 02       	popm	pc
8000b3aa:	00 00       	add	r0,r0
8000b3ac:	80 01       	ld.sh	r1,r0[0x0]
8000b3ae:	62 68       	ld.w	r8,r1[0x18]

8000b3b0 <wait>:
		clave[6]='\0';
}

// Software wait
void wait(void)
{
8000b3b0:	20 1d       	sub	sp,4
	volatile int i;
	for(i = 0 ; i < 5000; i++);
8000b3b2:	30 08       	mov	r8,0
8000b3b4:	50 08       	stdsp	sp[0x0],r8
8000b3b6:	40 08       	lddsp	r8,sp[0x0]
8000b3b8:	e0 48 13 87 	cp.w	r8,4999
8000b3bc:	e0 89 00 0a 	brgt	8000b3d0 <wait+0x20>
8000b3c0:	40 08       	lddsp	r8,sp[0x0]
8000b3c2:	2f f8       	sub	r8,-1
8000b3c4:	50 08       	stdsp	sp[0x0],r8
8000b3c6:	40 08       	lddsp	r8,sp[0x0]
8000b3c8:	e0 48 13 87 	cp.w	r8,4999
8000b3cc:	fe 9a ff fa 	brle	8000b3c0 <wait+0x10>
}
8000b3d0:	2f fd       	sub	sp,-4
8000b3d2:	5e fc       	retal	r12

8000b3d4 <init_SD_DMA_RX>:

}


void init_SD_DMA_RX(void)
{
8000b3d4:	eb cd 40 b0 	pushm	r4-r5,r7,lr
8000b3d8:	20 cd       	sub	sp,48
    .size = 512,                              // transfer counter: here the size of the string
    .r_addr = NULL,                           // next memory address after 1st transfer complete
    .r_size = 0,                              // next transfer counter not used here
    .pid = AVR32_PDCA_PID_SPI0_RX,        // select peripheral ID - data are on reception from SPI1 RX line
    .transfer_size = 8 // select size of the transfer: 8,16,32 bits
  };
8000b3da:	49 78       	lddpc	r8,8000b434 <init_SD_DMA_RX+0x60>
8000b3dc:	fa c7 ff e8 	sub	r7,sp,-24
8000b3e0:	f0 ea 00 00 	ld.d	r10,r8[0]
8000b3e4:	ee eb 00 00 	st.d	r7[0],r10
8000b3e8:	f0 ea 00 08 	ld.d	r10,r8[8]
8000b3ec:	ee eb 00 08 	st.d	r7[8],r10
8000b3f0:	f0 e8 00 10 	ld.d	r8,r8[16]
8000b3f4:	ee e9 00 10 	st.d	r7[16],r8
    .size = 512,                              // transfer counter: here the size of the string
    .r_addr = NULL,                           // next memory address after 1st transfer complete
    .r_size = 0,                              // next transfer counter not used here
    .pid = AVR32_PDCA_PID_SPI0_TX,        // select peripheral ID - data are on reception from SPI1 RX line
    .transfer_size = 8 // select size of the transfer: 8,16,32 bits
  };
8000b3f8:	49 08       	lddpc	r8,8000b438 <init_SD_DMA_RX+0x64>
8000b3fa:	1a 9b       	mov	r11,sp
8000b3fc:	f0 e4 00 00 	ld.d	r4,r8[0]
8000b400:	fa e5 00 00 	st.d	sp[0],r4
8000b404:	f0 e4 00 08 	ld.d	r4,r8[8]
8000b408:	fa e5 00 08 	st.d	sp[8],r4
8000b40c:	f0 e8 00 10 	ld.d	r8,r8[16]
8000b410:	fa e9 00 10 	st.d	sp[16],r8

  // Init PDCA transmission channel
  pdca_init_channel(AVR32_PDCA_CHANNEL_SPI_TX, &pdca_options_SPI_TX);
8000b414:	30 1c       	mov	r12,1
8000b416:	f0 1f 00 0a 	mcall	8000b43c <init_SD_DMA_RX+0x68>

  // Init PDCA Reception channel
  pdca_init_channel(AVR32_PDCA_CHANNEL_SPI_RX, &pdca_options_SPI_RX);
8000b41a:	0e 9b       	mov	r11,r7
8000b41c:	30 0c       	mov	r12,0
8000b41e:	f0 1f 00 08 	mcall	8000b43c <init_SD_DMA_RX+0x68>

  //! \brief Enable pdca transfer interrupt when completed
  INTC_register_interrupt(&pdca_int_handler_SD, AVR32_PDCA_IRQ_0, AVR32_INTC_INT1);  // pdca_channel_spi1_RX = 0
8000b422:	30 1a       	mov	r10,1
8000b424:	36 0b       	mov	r11,96
8000b426:	48 7c       	lddpc	r12,8000b440 <init_SD_DMA_RX+0x6c>
8000b428:	f0 1f 00 07 	mcall	8000b444 <init_SD_DMA_RX+0x70>

}
8000b42c:	2f 4d       	sub	sp,-48
8000b42e:	e3 cd 80 b0 	ldm	sp++,r4-r5,r7,pc
8000b432:	00 00       	add	r0,r0
8000b434:	80 01       	ld.sh	r1,r0[0x0]
8000b436:	66 f4       	ld.w	r4,r3[0x3c]
8000b438:	80 01       	ld.sh	r1,r0[0x0]
8000b43a:	67 1c       	ld.w	r12,r3[0x44]
8000b43c:	80 00       	ld.sh	r0,r0[0x0]
8000b43e:	87 f4       	st.w	r3[0x3c],r4
8000b440:	80 00       	ld.sh	r0,r0[0x0]
8000b442:	b4 48       	st.h	r10[0x8],r8
8000b444:	80 00       	ld.sh	r0,r0[0x0]
8000b446:	86 84       	ld.uh	r4,r3[0x0]

8000b448 <pdca_int_handler_SD>:



__attribute__((__interrupt__))
static void pdca_int_handler_SD(void)
{
8000b448:	d4 01       	pushm	lr
  // Disable all interrupts.
  Disable_global_interrupt();
8000b44a:	d3 03       	ssrf	0x10

  // Disable interrupt channel.
  pdca_disable_interrupt_transfer_complete(AVR32_PDCA_CHANNEL_SPI_RX);
8000b44c:	30 0c       	mov	r12,0
8000b44e:	f0 1f 00 0a 	mcall	8000b474 <pdca_int_handler_SD+0x2c>

  sd_mmc_spi_read_close_PDCA();//unselects the SD/MMC memory.
8000b452:	f0 1f 00 0a 	mcall	8000b478 <pdca_int_handler_SD+0x30>
  wait();
8000b456:	f0 1f 00 0a 	mcall	8000b47c <pdca_int_handler_SD+0x34>
  // Disable unnecessary channel
  pdca_disable(AVR32_PDCA_CHANNEL_SPI_TX);
8000b45a:	30 1c       	mov	r12,1
8000b45c:	f0 1f 00 09 	mcall	8000b480 <pdca_int_handler_SD+0x38>
  pdca_disable(AVR32_PDCA_CHANNEL_SPI_RX);
8000b460:	30 0c       	mov	r12,0
8000b462:	f0 1f 00 08 	mcall	8000b480 <pdca_int_handler_SD+0x38>

  // Enable all interrupts.
  Enable_global_interrupt();
8000b466:	d5 03       	csrf	0x10

  end_of_transfer = 1;
8000b468:	30 19       	mov	r9,1
8000b46a:	48 78       	lddpc	r8,8000b484 <pdca_int_handler_SD+0x3c>
8000b46c:	91 09       	st.w	r8[0x0],r9
}
8000b46e:	d4 02       	popm	lr
8000b470:	d6 03       	rete
8000b472:	00 00       	add	r0,r0
8000b474:	80 00       	ld.sh	r0,r0[0x0]
8000b476:	87 d4       	st.w	r3[0x34],r4
8000b478:	80 00       	ld.sh	r0,r0[0x0]
8000b47a:	78 80       	ld.w	r0,r12[0x20]
8000b47c:	80 00       	ld.sh	r0,r0[0x0]
8000b47e:	b3 b0       	sbr	r0,0x13
8000b480:	80 00       	ld.sh	r0,r0[0x0]
8000b482:	87 a4       	st.w	r3[0x28],r4
8000b484:	00 00       	add	r0,r0
8000b486:	07 64       	ld.uh	r4,--r3

8000b488 <init_Usart_DMA_RX>:
}




void init_Usart_DMA_RX(void){
8000b488:	eb cd 40 c0 	pushm	r6-r7,lr
8000b48c:	20 dd       	sub	sp,52
	
	const gpio_map_t usart_gpio_map = {
		{EXAMPLE_USART_RX_PIN, EXAMPLE_USART_RX_FUNCTION},
		{EXAMPLE_USART_TX_PIN, EXAMPLE_USART_TX_FUNCTION}
	};
8000b48e:	30 08       	mov	r8,0
8000b490:	50 98       	stdsp	sp[0x24],r8
8000b492:	50 a8       	stdsp	sp[0x28],r8
8000b494:	30 19       	mov	r9,1
8000b496:	50 b9       	stdsp	sp[0x2c],r9
8000b498:	50 c8       	stdsp	sp[0x30],r8
		.baudrate     = 57600,
		.charlength   = 8,
		.paritytype   = USART_NO_PARITY,
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE,
	};
8000b49a:	49 98       	lddpc	r8,8000b4fc <init_Usart_DMA_RX+0x74>
8000b49c:	fa c6 ff e8 	sub	r6,sp,-24
8000b4a0:	f0 ea 00 00 	ld.d	r10,r8[0]
8000b4a4:	ec eb 00 00 	st.d	r6[0],r10
8000b4a8:	70 28       	ld.w	r8,r8[0x8]
8000b4aa:	8d 28       	st.w	r6[0x8],r8

		/* Next memory address */
		.r_addr = NULL,
		/* Next transfer counter */
		.r_size = 0,
	};
8000b4ac:	49 58       	lddpc	r8,8000b500 <init_Usart_DMA_RX+0x78>
8000b4ae:	1a 97       	mov	r7,sp
8000b4b0:	f0 ea 00 00 	ld.d	r10,r8[0]
8000b4b4:	fa eb 00 00 	st.d	sp[0],r10
8000b4b8:	f0 ea 00 08 	ld.d	r10,r8[8]
8000b4bc:	fa eb 00 08 	st.d	sp[8],r10
8000b4c0:	f0 e8 00 10 	ld.d	r8,r8[16]
8000b4c4:	fa e9 00 10 	st.d	sp[16],r8

	/* Assign GPIO pins to USART. */
	gpio_enable_module(usart_gpio_map,
8000b4c8:	30 2b       	mov	r11,2
8000b4ca:	fa cc ff dc 	sub	r12,sp,-36
8000b4ce:	f0 1f 00 0e 	mcall	8000b504 <init_Usart_DMA_RX+0x7c>
			sizeof(usart_gpio_map) / sizeof(usart_gpio_map[0]));

	/* Initialize the USART in RS232 mode. */
	usart_init_rs232(EXAMPLE_USART, &usart_options,FOSC0);
8000b4d2:	e0 6a 1b 00 	mov	r10,6912
8000b4d6:	ea 1a 00 b7 	orh	r10,0xb7
8000b4da:	0c 9b       	mov	r11,r6
8000b4dc:	fe 7c 14 00 	mov	r12,-60416
8000b4e0:	f0 1f 00 0a 	mcall	8000b508 <init_Usart_DMA_RX+0x80>

	//usart_write_line(EXAMPLE_USART, "PDCA Example.\r\n");

	/* Initialize the PDCA channel with the requested options. */
	pdca_init_channel(PDCA_CHANNEL_USART_EXAMPLE, &PDCA_OPTIONS);
8000b4e4:	1a 9b       	mov	r11,sp
8000b4e6:	30 2c       	mov	r12,2
8000b4e8:	f0 1f 00 09 	mcall	8000b50c <init_Usart_DMA_RX+0x84>
	
	INTC_register_interrupt(&pdca_int_handler_USART, AVR32_PDCA_IRQ_2,
8000b4ec:	30 3a       	mov	r10,3
8000b4ee:	36 2b       	mov	r11,98
8000b4f0:	48 8c       	lddpc	r12,8000b510 <init_Usart_DMA_RX+0x88>
8000b4f2:	f0 1f 00 09 	mcall	8000b514 <init_Usart_DMA_RX+0x8c>
	 * transferred. */
	//pdca_enable_interrupt_reload_counter_zero(PDCA_CHANNEL_USART_EXAMPLE);
	
	//pdca_enable_interrupt_transfer_complete(PDCA_CHANNEL_USART_EXAMPLE);

}
8000b4f6:	2f 3d       	sub	sp,-52
8000b4f8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000b4fc:	80 01       	ld.sh	r1,r0[0x0]
8000b4fe:	62 a0       	ld.w	r0,r1[0x28]
8000b500:	80 01       	ld.sh	r1,r0[0x0]
8000b502:	66 b0       	ld.w	r0,r3[0x2c]
8000b504:	80 00       	ld.sh	r0,r0[0x0]
8000b506:	85 e4       	st.w	r2[0x38],r4
8000b508:	80 00       	ld.sh	r0,r0[0x0]
8000b50a:	8e ac       	ld.uh	r12,r7[0x4]
8000b50c:	80 00       	ld.sh	r0,r0[0x0]
8000b50e:	87 f4       	st.w	r3[0x3c],r4
8000b510:	80 00       	ld.sh	r0,r0[0x0]
8000b512:	b5 18       	ld.d	r8,--r10
8000b514:	80 00       	ld.sh	r0,r0[0x0]
8000b516:	86 84       	ld.uh	r4,r3[0x0]

8000b518 <pdca_int_handler_USART>:
volatile int minutos =0;
volatile int horas=0;

volatile int gana2=1;
__attribute__((__interrupt__))
static void pdca_int_handler_USART(void){
8000b518:	d4 01       	pushm	lr
	Disable_global_interrupt();
8000b51a:	d3 03       	ssrf	0x10
	
	usart_write_line(&AVR32_USART0,"recibido");
8000b51c:	48 9b       	lddpc	r11,8000b540 <pdca_int_handler_USART+0x28>
8000b51e:	fe 7c 14 00 	mov	r12,-60416
8000b522:	f0 1f 00 09 	mcall	8000b544 <pdca_int_handler_USART+0x2c>
	
	pdca_disable_interrupt_transfer_complete(PDCA_CHANNEL_USART_EXAMPLE);
8000b526:	30 2c       	mov	r12,2
8000b528:	f0 1f 00 08 	mcall	8000b548 <pdca_int_handler_USART+0x30>
	pdca_disable(PDCA_CHANNEL_USART_EXAMPLE);
8000b52c:	30 2c       	mov	r12,2
8000b52e:	f0 1f 00 08 	mcall	8000b54c <pdca_int_handler_USART+0x34>
	end_of_transfer=1;
8000b532:	30 19       	mov	r9,1
8000b534:	48 78       	lddpc	r8,8000b550 <pdca_int_handler_USART+0x38>
8000b536:	91 09       	st.w	r8[0x0],r9
	Enable_global_interrupt();
8000b538:	d5 03       	csrf	0x10
	
}
8000b53a:	d4 02       	popm	lr
8000b53c:	d6 03       	rete
8000b53e:	00 00       	add	r0,r0
8000b540:	80 01       	ld.sh	r1,r0[0x0]
8000b542:	67 34       	ld.w	r4,r3[0x4c]
8000b544:	80 00       	ld.sh	r0,r0[0x0]
8000b546:	8e 5c       	ld.sh	r12,r7[0xa]
8000b548:	80 00       	ld.sh	r0,r0[0x0]
8000b54a:	87 d4       	st.w	r3[0x34],r4
8000b54c:	80 00       	ld.sh	r0,r0[0x0]
8000b54e:	87 a4       	st.w	r3[0x28],r4
8000b550:	00 00       	add	r0,r0
8000b552:	07 64       	ld.uh	r4,--r3

8000b554 <main>:
}

 volatile avr32_tc_t *tc =  (&AVR32_TC);
// Main function
int main(void)
{
8000b554:	d4 31       	pushm	r0-r7,lr
8000b556:	20 4d       	sub	sp,16
  U32 i;
  
    // Set CPU and PBA clock
    pcl_switch_to_osc(PCL_OSC0, FOSC0, OSC0_STARTUP);
8000b558:	30 3a       	mov	r10,3
8000b55a:	e0 6b 1b 00 	mov	r11,6912
8000b55e:	ea 1b 00 b7 	orh	r11,0xb7
8000b562:	30 0c       	mov	r12,0
8000b564:	f0 1f 00 b0 	mcall	8000b824 <main+0x2d0>
  };




  gpio_enable_gpio_pin(LED0_GPIO);
8000b568:	33 bc       	mov	r12,59
8000b56a:	f0 1f 00 b0 	mcall	8000b828 <main+0x2d4>
  gpio_enable_gpio_pin(LED1_GPIO);
8000b56e:	33 cc       	mov	r12,60
8000b570:	f0 1f 00 ae 	mcall	8000b828 <main+0x2d4>
  gpio_enable_gpio_pin(LED2_GPIO);
8000b574:	30 5c       	mov	r12,5
8000b576:	f0 1f 00 ad 	mcall	8000b828 <main+0x2d4>
  gpio_enable_gpio_pin(LED3_GPIO);
8000b57a:	30 6c       	mov	r12,6
8000b57c:	f0 1f 00 ab 	mcall	8000b828 <main+0x2d4>

  et024006_Init( FOSC0, FOSC0 );
8000b580:	e0 6b 1b 00 	mov	r11,6912
8000b584:	ea 1b 00 b7 	orh	r11,0xb7
8000b588:	16 9c       	mov	r12,r11
8000b58a:	f0 1f 00 a9 	mcall	8000b82c <main+0x2d8>
  pwm_opt_t opt = {
    .diva = 0,
    .divb = 0,
    .prea = 0,
    .preb = 0
  };
8000b58e:	30 07       	mov	r7,0
8000b590:	50 07       	stdsp	sp[0x0],r7
8000b592:	50 17       	stdsp	sp[0x4],r7
8000b594:	50 27       	stdsp	sp[0x8],r7
8000b596:	50 37       	stdsp	sp[0xc],r7
   * Chosen MCK_DIV_2
   * CPRD = 12MHz / (60kHz * 2) = 100
   *
   * The duty cycle is 100% (CPRD = CDTY)
   * */
  pwm_init(&opt);
8000b598:	1a 9c       	mov	r12,sp
8000b59a:	f0 1f 00 a6 	mcall	8000b830 <main+0x2dc>
  pwm_channel6.CMR.calg = PWM_MODE_LEFT_ALIGNED;
8000b59e:	fe fb 02 96 	ld.w	r11,pc[662]
8000b5a2:	76 08       	ld.w	r8,r11[0x0]
  pwm_channel6.CMR.cpol = PWM_POLARITY_HIGH; //PWM_POLARITY_LOW;//PWM_POLARITY_HIGH;
  pwm_channel6.CMR.cpd = PWM_UPDATE_DUTY;
8000b5a4:	e0 18 f8 ff 	andl	r8,0xf8ff
  pwm_channel6.CMR.cpre = AVR32_PWM_CMR_CPRE_MCK_DIV_2;
8000b5a8:	a9 b8       	sbr	r8,0x9
8000b5aa:	30 19       	mov	r9,1
8000b5ac:	f1 d9 d0 04 	bfins	r8,r9,0x0,0x4
8000b5b0:	97 08       	st.w	r11[0x0],r8

  pwm_channel_init(6, &pwm_channel6);
8000b5b2:	30 6c       	mov	r12,6
8000b5b4:	f0 1f 00 a1 	mcall	8000b838 <main+0x2e4>
  pwm_start_channels(AVR32_PWM_ENA_CHID6_MASK);
8000b5b8:	34 0c       	mov	r12,64
8000b5ba:	f0 1f 00 a1 	mcall	8000b83c <main+0x2e8>
#elif BOARD == EVK1104 || BOARD == UC3C_EK
  gpio_set_gpio_pin(ET024006DHU_BL_PIN);
#endif

  // Clear the display i.e. make it black
  et024006_DrawFilledRect(0 , 0, ET024006_WIDTH, ET024006_HEIGHT, BLACK );
8000b5be:	0e 98       	mov	r8,r7
8000b5c0:	e0 69 00 f0 	mov	r9,240
8000b5c4:	e0 6a 01 40 	mov	r10,320
8000b5c8:	0e 9b       	mov	r11,r7
8000b5ca:	0e 9c       	mov	r12,r7
8000b5cc:	f0 1f 00 9d 	mcall	8000b840 <main+0x2ec>
  
  //Interrupciones
  
  Disable_global_interrupt();
8000b5d0:	d3 03       	ssrf	0x10

  INTC_init_interrupts();
8000b5d2:	f0 1f 00 9d 	mcall	8000b844 <main+0x2f0>
  INTC_register_interrupt(&tc_irq, AVR32_TC_IRQ0, AVR32_INTC_INT0);
8000b5d6:	0e 9a       	mov	r10,r7
8000b5d8:	e0 6b 01 c0 	mov	r11,448
8000b5dc:	fe fc 02 6c 	ld.w	r12,pc[620]
8000b5e0:	f0 1f 00 9b 	mcall	8000b84c <main+0x2f8>
  init_Usart_DMA_RX();
8000b5e4:	f0 1f 00 9b 	mcall	8000b850 <main+0x2fc>
  init_SD_DMA_RX();
8000b5e8:	f0 1f 00 9b 	mcall	8000b854 <main+0x300>
  
  sdramc_init(FOSC0);
8000b5ec:	e0 6c 1b 00 	mov	r12,6912
8000b5f0:	ea 1c 00 b7 	orh	r12,0xb7
8000b5f4:	f0 1f 00 99 	mcall	8000b858 <main+0x304>

  Enable_global_interrupt();
8000b5f8:	d5 03       	csrf	0x10
  
  tc_init_waveform(tc, &WAVEFORM_OPT);         // Initialize the timer/counter waveform.
8000b5fa:	fe f6 02 62 	ld.w	r6,pc[610]
8000b5fe:	fe fb 02 62 	ld.w	r11,pc[610]
8000b602:	6c 0c       	ld.w	r12,r6[0x0]
8000b604:	f0 1f 00 98 	mcall	8000b864 <main+0x310>

  // Set the compare triggers.
  // Remember TC counter is 16-bits, so counting second is not possible with fPBA = 12 MHz.
  // We configure it to count ms.
  // We want: (1/(fPBA/8)) * RC = 0.001 s, hence RC = (fPBA/8) / 1000 = 1500 to get an interrupt every 1 ms.
  tc_write_rc(tc, TC_CHANNEL, 1500);            // Set RC value.
8000b608:	e0 6a 05 dc 	mov	r10,1500
8000b60c:	0e 9b       	mov	r11,r7
8000b60e:	6c 0c       	ld.w	r12,r6[0x0]
8000b610:	f0 1f 00 96 	mcall	8000b868 <main+0x314>

  tc_configure_interrupts(tc, TC_CHANNEL, &TC_INTERRUPT);
8000b614:	fe fa 02 58 	ld.w	r10,pc[600]
8000b618:	0e 9b       	mov	r11,r7
8000b61a:	6c 0c       	ld.w	r12,r6[0x0]
8000b61c:	f0 1f 00 95 	mcall	8000b870 <main+0x31c>

  // Start the timer/counter.
  tc_start(tc, TC_CHANNEL);                    // And start the timer/counter.
8000b620:	0e 9b       	mov	r11,r7
8000b622:	6c 0c       	ld.w	r12,r6[0x0]
8000b624:	f0 1f 00 94 	mcall	8000b874 <main+0x320>
  


  while(pwm_channel6.cdty < pwm_channel6.cprd)
8000b628:	fe f7 02 0c 	ld.w	r7,pc[524]
  {
	  pwm_channel6.cdty++;
	  pwm_channel6.cupd = pwm_channel6.cdty;
	  //pwm_channel6.cdty--;
	  pwm_async_update_channel(AVR32_PWM_ENA_CHID6, &pwm_channel6);
8000b62c:	30 66       	mov	r6,6
  // Start the timer/counter.
  tc_start(tc, TC_CHANNEL);                    // And start the timer/counter.
  


  while(pwm_channel6.cdty < pwm_channel6.cprd)
8000b62e:	c1 e8       	rjmp	8000b66a <main+0x116>
  {
	  pwm_channel6.cdty++;
8000b630:	2f f8       	sub	r8,-1
8000b632:	8f 18       	st.w	r7[0x4],r8
	  pwm_channel6.cupd = pwm_channel6.cdty;
8000b634:	8f 48       	st.w	r7[0x10],r8
	  //pwm_channel6.cdty--;
	  pwm_async_update_channel(AVR32_PWM_ENA_CHID6, &pwm_channel6);
8000b636:	0e 9b       	mov	r11,r7
8000b638:	0c 9c       	mov	r12,r6
8000b63a:	f0 1f 00 90 	mcall	8000b878 <main+0x324>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000b63e:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000b642:	e0 79 d4 c0 	mov	r9,120000
8000b646:	f0 09 00 0a 	add	r10,r8,r9
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000b64a:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000b64e:	14 38       	cp.w	r8,r10
8000b650:	e0 88 00 08 	brls	8000b660 <main+0x10c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000b654:	12 38       	cp.w	r8,r9
8000b656:	fe 98 ff fa 	brls	8000b64a <main+0xf6>
8000b65a:	12 3a       	cp.w	r10,r9
8000b65c:	c0 73       	brcs	8000b66a <main+0x116>
8000b65e:	cf 6b       	rjmp	8000b64a <main+0xf6>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000b660:	12 38       	cp.w	r8,r9
8000b662:	e0 8b 00 04 	brhi	8000b66a <main+0x116>
8000b666:	12 3a       	cp.w	r10,r9
8000b668:	cf 12       	brcc	8000b64a <main+0xf6>
  // Start the timer/counter.
  tc_start(tc, TC_CHANNEL);                    // And start the timer/counter.
  


  while(pwm_channel6.cdty < pwm_channel6.cprd)
8000b66a:	6e 18       	ld.w	r8,r7[0x4]
8000b66c:	6e 29       	ld.w	r9,r7[0x8]
8000b66e:	12 38       	cp.w	r8,r9
8000b670:	ce 03       	brcs	8000b630 <main+0xdc>
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
8000b672:	fe f8 02 0a 	ld.w	r8,pc[522]
8000b676:	1a 97       	mov	r7,sp
8000b678:	f0 ea 00 00 	ld.d	r10,r8[0]
8000b67c:	fa eb 00 00 	st.d	sp[0],r10
8000b680:	f0 e8 00 08 	ld.d	r8,r8[8]
8000b684:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(SD_MMC_SPI_GPIO_MAP,
8000b688:	30 4b       	mov	r11,4
8000b68a:	4f ec       	lddpc	r12,8000b880 <main+0x32c>
8000b68c:	f0 1f 00 7e 	mcall	8000b884 <main+0x330>
	sizeof(SD_MMC_SPI_GPIO_MAP) / sizeof(SD_MMC_SPI_GPIO_MAP[0]));

	// Initialize as master.
	spi_initMaster(SD_MMC_SPI, &spiOptions);
8000b690:	1a 9b       	mov	r11,sp
8000b692:	fe 7c 24 00 	mov	r12,-56320
8000b696:	f0 1f 00 7d 	mcall	8000b888 <main+0x334>

	// Set SPI selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(SD_MMC_SPI, 0, 0, 0);
8000b69a:	30 09       	mov	r9,0
8000b69c:	12 9a       	mov	r10,r9
8000b69e:	12 9b       	mov	r11,r9
8000b6a0:	fe 7c 24 00 	mov	r12,-56320
8000b6a4:	f0 1f 00 7a 	mcall	8000b88c <main+0x338>

	// Enable SPI module.
	spi_enable(SD_MMC_SPI);
8000b6a8:	fe 7c 24 00 	mov	r12,-56320
8000b6ac:	f0 1f 00 79 	mcall	8000b890 <main+0x33c>

	// Initialize SD/MMC driver with SPI clock (PBA).
	sd_mmc_spi_init(spiOptions, PBA_HZ);
8000b6b0:	20 4d       	sub	sp,16
8000b6b2:	ee e8 00 00 	ld.d	r8,r7[0]
8000b6b6:	fa e9 00 00 	st.d	sp[0],r8
8000b6ba:	ee e8 00 08 	ld.d	r8,r7[8]
8000b6be:	fa e9 00 08 	st.d	sp[8],r8
8000b6c2:	e0 6c 1b 00 	mov	r12,6912
8000b6c6:	ea 1c 00 b7 	orh	r12,0xb7
8000b6ca:	f0 1f 00 73 	mcall	8000b894 <main+0x340>
  uint32_t sector =10;
  char disp[50];
  char clave[7];
  
  // Mount file system.
  nav_reset();
8000b6ce:	f0 1f 00 73 	mcall	8000b898 <main+0x344>

  // Display # of drives
  int drives = nav_drive_nb();
8000b6d2:	f0 1f 00 73 	mcall	8000b89c <main+0x348>
  sprintf(mensaje,"%d",drives);
8000b6d6:	4f 35       	lddpc	r5,8000b8a0 <main+0x34c>
8000b6d8:	4f 37       	lddpc	r7,8000b8a4 <main+0x350>
8000b6da:	1a dc       	st.w	--sp,r12
8000b6dc:	0a 9b       	mov	r11,r5
8000b6de:	0e 9c       	mov	r12,r7
8000b6e0:	f0 1f 00 72 	mcall	8000b8a8 <main+0x354>
  et024006_PrintString(mensaje,(const unsigned char*)&FONT8x8,50,70,BLUE,-1);
8000b6e4:	4f 26       	lddpc	r6,8000b8ac <main+0x358>
8000b6e6:	3f f4       	mov	r4,-1
8000b6e8:	1a d4       	st.w	--sp,r4
8000b6ea:	31 f8       	mov	r8,31
8000b6ec:	34 69       	mov	r9,70
8000b6ee:	33 2a       	mov	r10,50
8000b6f0:	0c 9b       	mov	r11,r6
8000b6f2:	0e 9c       	mov	r12,r7
8000b6f4:	f0 1f 00 6f 	mcall	8000b8b0 <main+0x35c>

  // Set Drive #
  nav_drive_set(0);
8000b6f8:	30 0c       	mov	r12,0
8000b6fa:	f0 1f 00 6f 	mcall	8000b8b4 <main+0x360>

  // Display Drive #
  drives = nav_drive_get();
8000b6fe:	f0 1f 00 6f 	mcall	8000b8b8 <main+0x364>
  sprintf(mensaje,"%d",drives);
8000b702:	1a dc       	st.w	--sp,r12
8000b704:	0a 9b       	mov	r11,r5
8000b706:	0e 9c       	mov	r12,r7
8000b708:	f0 1f 00 68 	mcall	8000b8a8 <main+0x354>
  et024006_PrintString(mensaje,(const unsigned char*)&FONT8x8,70,70,BLUE,-1);
8000b70c:	1a d4       	st.w	--sp,r4
8000b70e:	31 f8       	mov	r8,31
8000b710:	34 69       	mov	r9,70
8000b712:	12 9a       	mov	r10,r9
8000b714:	0c 9b       	mov	r11,r6
8000b716:	0e 9c       	mov	r12,r7
8000b718:	f0 1f 00 66 	mcall	8000b8b0 <main+0x35c>
8000b71c:	2f 8d       	sub	sp,-32

  while(!nav_partition_mount()); // If we're unable to mount the partition, halt here.
8000b71e:	f0 1f 00 68 	mcall	8000b8bc <main+0x368>
8000b722:	cf e0       	breq	8000b71e <main+0x1ca>

  nav_checkdisk_disable(); // Skip fat_check_device() for every read.
8000b724:	f0 1f 00 67 	mcall	8000b8c0 <main+0x36c>

  // Display # of files in drive
  drives = nav_filelist_nb(FS_FILE);
8000b728:	30 1c       	mov	r12,1
8000b72a:	f0 1f 00 67 	mcall	8000b8c4 <main+0x370>
  sprintf(mensaje,"%d",drives);
8000b72e:	4d e7       	lddpc	r7,8000b8a4 <main+0x350>
8000b730:	5c 7c       	castu.h	r12
8000b732:	1a dc       	st.w	--sp,r12
8000b734:	4d bb       	lddpc	r11,8000b8a0 <main+0x34c>
8000b736:	0e 9c       	mov	r12,r7
8000b738:	f0 1f 00 5c 	mcall	8000b8a8 <main+0x354>
  et024006_PrintString(mensaje,(const unsigned char*)&FONT8x8,90,70,BLUE,-1);
8000b73c:	3f f8       	mov	r8,-1
8000b73e:	1a d8       	st.w	--sp,r8
8000b740:	31 f8       	mov	r8,31
8000b742:	34 69       	mov	r9,70
8000b744:	35 aa       	mov	r10,90
8000b746:	0c 9b       	mov	r11,r6
8000b748:	0e 9c       	mov	r12,r7
8000b74a:	f0 1f 00 5a 	mcall	8000b8b0 <main+0x35c>

  // Display # of bytes in file
  if(nav_filelist_first(FS_FILE))
8000b74e:	30 1c       	mov	r12,1
8000b750:	f0 1f 00 5e 	mcall	8000b8c8 <main+0x374>
8000b754:	2f ed       	sub	sp,-8
8000b756:	58 0c       	cp.w	r12,0
8000b758:	c1 20       	breq	8000b77c <main+0x228>
  {
	  drives = nav_file_lgt();
8000b75a:	f0 1f 00 5d 	mcall	8000b8cc <main+0x378>
	  sprintf(mensaje,"%d",drives);
8000b75e:	1a dc       	st.w	--sp,r12
8000b760:	4d 0b       	lddpc	r11,8000b8a0 <main+0x34c>
8000b762:	0e 9c       	mov	r12,r7
8000b764:	f0 1f 00 51 	mcall	8000b8a8 <main+0x354>
	  et024006_PrintString(mensaje,(const unsigned char*)&FONT8x8,110,70,BLUE,-1);
8000b768:	3f f8       	mov	r8,-1
8000b76a:	1a d8       	st.w	--sp,r8
8000b76c:	31 f8       	mov	r8,31
8000b76e:	34 69       	mov	r9,70
8000b770:	36 ea       	mov	r10,110
8000b772:	0c 9b       	mov	r11,r6
8000b774:	0e 9c       	mov	r12,r7
8000b776:	f0 1f 00 4f 	mcall	8000b8b0 <main+0x35c>
8000b77a:	2f ed       	sub	sp,-8
  }

  //Apply a filter for *.txt files and display number of files with this file extension
  int wave = nav_filterlist_nb(FL_FILE,"nes");
8000b77c:	4d 55       	lddpc	r5,8000b8d0 <main+0x37c>
8000b77e:	0a 9b       	mov	r11,r5
8000b780:	30 0c       	mov	r12,0
8000b782:	f0 1f 00 55 	mcall	8000b8d4 <main+0x380>
8000b786:	ef dc b0 10 	bfexts	r7,r12,0x0,0x10
  
  et024006_DrawFilledRect(0,0,320,240,BLACK);
8000b78a:	30 08       	mov	r8,0
8000b78c:	e0 69 00 f0 	mov	r9,240
8000b790:	e0 6a 01 40 	mov	r10,320
8000b794:	10 9b       	mov	r11,r8
8000b796:	10 9c       	mov	r12,r8
8000b798:	f0 1f 00 2a 	mcall	8000b840 <main+0x2ec>
  int l=0;
  //Apply a filter for *.bmp files and display the all the files names.
  nav_filterlist_setfilter("nes");
8000b79c:	0a 9c       	mov	r12,r5
8000b79e:	f0 1f 00 4f 	mcall	8000b8d8 <main+0x384>

  nav_filterlist_root();
8000b7a2:	f0 1f 00 4f 	mcall	8000b8dc <main+0x388>

  for(i=0;i<=wave;i++)
8000b7a6:	0e 92       	mov	r2,r7
8000b7a8:	5c 72       	castu.h	r2
8000b7aa:	30 07       	mov	r7,0
8000b7ac:	0e 95       	mov	r5,r7
  {
	  nav_filterlist_goto(i);
	  if(nav_file_getname((FS_STRING) str_buff, 40))
8000b7ae:	4c d4       	lddpc	r4,8000b8e0 <main+0x38c>
8000b7b0:	32 83       	mov	r3,40
	  et024006_PrintString(str_buff,(const unsigned char*)&FONT8x8,40,80+(l+=10),BLUE,-1);
8000b7b2:	3f f1       	mov	r1,-1
8000b7b4:	31 f0       	mov	r0,31

  nav_filterlist_root();

  for(i=0;i<=wave;i++)
  {
	  nav_filterlist_goto(i);
8000b7b6:	0e 9c       	mov	r12,r7
8000b7b8:	5c 7c       	castu.h	r12
8000b7ba:	f0 1f 00 4b 	mcall	8000b8e4 <main+0x390>
	  if(nav_file_getname((FS_STRING) str_buff, 40))
8000b7be:	06 9b       	mov	r11,r3
8000b7c0:	08 9c       	mov	r12,r4
8000b7c2:	f0 1f 00 4a 	mcall	8000b8e8 <main+0x394>
8000b7c6:	c0 d0       	breq	8000b7e0 <main+0x28c>
	  et024006_PrintString(str_buff,(const unsigned char*)&FONT8x8,40,80+(l+=10),BLUE,-1);
8000b7c8:	2f 65       	sub	r5,-10
8000b7ca:	ea c9 ff b0 	sub	r9,r5,-80
8000b7ce:	1a d1       	st.w	--sp,r1
8000b7d0:	00 98       	mov	r8,r0
8000b7d2:	5c 79       	castu.h	r9
8000b7d4:	06 9a       	mov	r10,r3
8000b7d6:	0c 9b       	mov	r11,r6
8000b7d8:	08 9c       	mov	r12,r4
8000b7da:	f0 1f 00 36 	mcall	8000b8b0 <main+0x35c>
8000b7de:	2f fd       	sub	sp,-4
  //Apply a filter for *.bmp files and display the all the files names.
  nav_filterlist_setfilter("nes");

  nav_filterlist_root();

  for(i=0;i<=wave;i++)
8000b7e0:	2f f7       	sub	r7,-1
8000b7e2:	0e 32       	cp.w	r2,r7
8000b7e4:	ce 92       	brcc	8000b7b6 <main+0x262>
  
  
 //while (!gpio_get_pin_value(QT1081_TOUCH_SENSOR_ENTER));
 char z;
 
 usart_write_char(&AVR32_USART0,'d');
8000b7e6:	36 4b       	mov	r11,100
8000b7e8:	fe 7c 14 00 	mov	r12,-60416
8000b7ec:	f0 1f 00 40 	mcall	8000b8ec <main+0x398>
 
//  nav_filterlist_goto(0); //primer archivo, megaman.nes
//  nav_file_getname((FS_STRING) str_buff, 40);
 file_bof();
8000b7f0:	f0 1f 00 40 	mcall	8000b8f0 <main+0x39c>
file_open(FOPEN_MODE_R);
8000b7f4:	30 9c       	mov	r12,9
8000b7f6:	f0 1f 00 40 	mcall	8000b8f4 <main+0x3a0>
usart_write_char(&AVR32_USART0,fs_g_status);
8000b7fa:	4c 08       	lddpc	r8,8000b8f8 <main+0x3a4>
8000b7fc:	11 8b       	ld.ub	r11,r8[0x0]
8000b7fe:	fe 7c 14 00 	mov	r12,-60416
8000b802:	f0 1f 00 3b 	mcall	8000b8ec <main+0x398>
 int filename =2;
 #define DEFAULT_RESOLUTION_WIDTH 256
 #define DEFAULT_RESOLUTION_HEIGHT 240
 int width = DEFAULT_RESOLUTION_WIDTH;
 int height = DEFAULT_RESOLUTION_HEIGHT;
  nes = nes_init(filename, width, height);
8000b806:	e0 6a 00 f0 	mov	r10,240
8000b80a:	e0 6b 01 00 	mov	r11,256
8000b80e:	30 2c       	mov	r12,2
8000b810:	f0 1f 00 3b 	mcall	8000b8fc <main+0x3a8>
8000b814:	4b b8       	lddpc	r8,8000b900 <main+0x3ac>
8000b816:	91 0c       	st.w	r8[0x0],r12
  while (1)
  {
	   nes_run(nes);
8000b818:	10 97       	mov	r7,r8
8000b81a:	6e 0c       	ld.w	r12,r7[0x0]
8000b81c:	f0 1f 00 3a 	mcall	8000b904 <main+0x3b0>
8000b820:	cf db       	rjmp	8000b81a <main+0x2c6>
8000b822:	00 00       	add	r0,r0
8000b824:	80 00       	ld.sh	r0,r0[0x0]
8000b826:	89 04       	st.w	r4[0x0],r4
8000b828:	80 00       	ld.sh	r0,r0[0x0]
8000b82a:	86 14       	ld.sh	r4,r3[0x2]
8000b82c:	80 00       	ld.sh	r0,r0[0x0]
8000b82e:	72 bc       	ld.w	r12,r9[0x2c]
8000b830:	80 00       	ld.sh	r0,r0[0x0]
8000b832:	89 90       	st.w	r4[0x24],r0
8000b834:	00 00       	add	r0,r0
8000b836:	00 e8       	st.h	--r0,r8
8000b838:	80 00       	ld.sh	r0,r0[0x0]
8000b83a:	89 20       	st.w	r4[0x8],r0
8000b83c:	80 00       	ld.sh	r0,r0[0x0]
8000b83e:	89 56       	st.w	r4[0x14],r6
8000b840:	80 00       	ld.sh	r0,r0[0x0]
8000b842:	72 0c       	ld.w	r12,r9[0x0]
8000b844:	80 00       	ld.sh	r0,r0[0x0]
8000b846:	87 04       	st.w	r3[0x0],r4
8000b848:	80 00       	ld.sh	r0,r0[0x0]
8000b84a:	b9 08       	ld.d	r8,r12
8000b84c:	80 00       	ld.sh	r0,r0[0x0]
8000b84e:	86 84       	ld.uh	r4,r3[0x0]
8000b850:	80 00       	ld.sh	r0,r0[0x0]
8000b852:	b4 88       	st.b	r10[0x0],r8
8000b854:	80 00       	ld.sh	r0,r0[0x0]
8000b856:	b3 d4       	cbr	r4,0x13
8000b858:	80 00       	ld.sh	r0,r0[0x0]
8000b85a:	20 2c       	sub	r12,2
8000b85c:	00 00       	add	r0,r0
8000b85e:	00 e4       	st.h	--r0,r4
8000b860:	80 01       	ld.sh	r1,r0[0x0]
8000b862:	66 cc       	ld.w	r12,r3[0x30]
8000b864:	80 00       	ld.sh	r0,r0[0x0]
8000b866:	8b c6       	st.w	r5[0x30],r6
8000b868:	80 00       	ld.sh	r0,r0[0x0]
8000b86a:	8c 86       	ld.uh	r6,r6[0x0]
8000b86c:	80 01       	ld.sh	r1,r0[0x0]
8000b86e:	66 c8       	ld.w	r8,r3[0x30]
8000b870:	80 00       	ld.sh	r0,r0[0x0]
8000b872:	8c ba       	ld.uh	r10,r6[0x6]
8000b874:	80 00       	ld.sh	r0,r0[0x0]
8000b876:	8c 62       	ld.sh	r2,r6[0xc]
8000b878:	80 00       	ld.sh	r0,r0[0x0]
8000b87a:	89 68       	st.w	r4[0x18],r8
8000b87c:	80 01       	ld.sh	r1,r0[0x0]
8000b87e:	67 0c       	ld.w	r12,r3[0x40]
8000b880:	80 01       	ld.sh	r1,r0[0x0]
8000b882:	66 d4       	ld.w	r4,r3[0x34]
8000b884:	80 00       	ld.sh	r0,r0[0x0]
8000b886:	85 e4       	st.w	r2[0x38],r4
8000b888:	80 00       	ld.sh	r0,r0[0x0]
8000b88a:	89 f6       	st.w	r4[0x3c],r6
8000b88c:	80 00       	ld.sh	r0,r0[0x0]
8000b88e:	8a 2e       	ld.sh	lr,r5[0x4]
8000b890:	80 00       	ld.sh	r0,r0[0x0]
8000b892:	8b 84       	st.w	r5[0x20],r4
8000b894:	80 00       	ld.sh	r0,r0[0x0]
8000b896:	82 b4       	ld.uh	r4,r1[0x6]
8000b898:	80 00       	ld.sh	r0,r0[0x0]
8000b89a:	af a0       	sbr	r0,0xe
8000b89c:	80 00       	ld.sh	r0,r0[0x0]
8000b89e:	af 4c       	asr	r12,0xe
8000b8a0:	80 01       	ld.sh	r1,r0[0x0]
8000b8a2:	67 40       	ld.w	r0,r3[0x50]
8000b8a4:	00 00       	add	r0,r0
8000b8a6:	01 10       	ld.sh	r0,r0++
8000b8a8:	80 00       	ld.sh	r0,r0[0x0]
8000b8aa:	c7 e0       	breq	8000b9a6 <__avr32_f64_mul+0x2>
8000b8ac:	80 01       	ld.sh	r1,r0[0x0]
8000b8ae:	5e 18       	retne	r8
8000b8b0:	80 00       	ld.sh	r0,r0[0x0]
8000b8b2:	6f 90       	ld.w	r0,r7[0x64]
8000b8b4:	80 00       	ld.sh	r0,r0[0x0]
8000b8b6:	ae f8       	st.b	r7[0x7],r8
8000b8b8:	80 00       	ld.sh	r0,r0[0x0]
8000b8ba:	aa 64       	st.h	r5[0xc],r4
8000b8bc:	80 00       	ld.sh	r0,r0[0x0]
8000b8be:	ae b0       	st.b	r7[0x3],r0
8000b8c0:	80 00       	ld.sh	r0,r0[0x0]
8000b8c2:	aa 58       	st.h	r5[0xa],r8
8000b8c4:	80 00       	ld.sh	r0,r0[0x0]
8000b8c6:	ad 74       	lsl	r4,0xd
8000b8c8:	80 00       	ld.sh	r0,r0[0x0]
8000b8ca:	ad 34       	mul	r4,r6
8000b8cc:	80 00       	ld.sh	r0,r0[0x0]
8000b8ce:	aa 7c       	st.h	r5[0xe],r12
8000b8d0:	80 01       	ld.sh	r1,r0[0x0]
8000b8d2:	67 44       	ld.w	r4,r3[0x50]
8000b8d4:	80 00       	ld.sh	r0,r0[0x0]
8000b8d6:	b2 c4       	st.b	r9[0x4],r4
8000b8d8:	80 00       	ld.sh	r0,r0[0x0]
8000b8da:	b2 f0       	st.b	r9[0x7],r0
8000b8dc:	80 00       	ld.sh	r0,r0[0x0]
8000b8de:	b0 24       	st.h	r8[0x4],r4
8000b8e0:	00 00       	add	r0,r0
8000b8e2:	01 14       	ld.sh	r4,r0++
8000b8e4:	80 00       	ld.sh	r0,r0[0x0]
8000b8e6:	b1 20       	st.d	r8++,r0
8000b8e8:	80 00       	ld.sh	r0,r0[0x0]
8000b8ea:	ab a4       	sbr	r4,0xa
8000b8ec:	80 00       	ld.sh	r0,r0[0x0]
8000b8ee:	8e 1c       	ld.sh	r12,r7[0x2]
8000b8f0:	80 00       	ld.sh	r0,r0[0x0]
8000b8f2:	a6 ac       	st.b	r3[0x2],r12
8000b8f4:	80 00       	ld.sh	r0,r0[0x0]
8000b8f6:	a9 b8       	sbr	r8,0x9
8000b8f8:	00 00       	add	r0,r0
8000b8fa:	0c 68       	and	r8,r6
8000b8fc:	80 00       	ld.sh	r0,r0[0x0]
8000b8fe:	55 80       	stdsp	sp[0x160],r0
8000b900:	d0 00       	acall	0x0
8000b902:	00 00       	add	r0,r0
8000b904:	80 00       	ld.sh	r0,r0[0x0]
8000b906:	53 c4       	stdsp	sp[0xf0],r4

8000b908 <tc_irq>:
	
} 
*/
__attribute__((__interrupt__))
static void tc_irq(void)
{
8000b908:	eb cd 40 80 	pushm	r7,lr
  // Increment the ms seconds counter
  tc_tick++;
8000b90c:	49 e7       	lddpc	r7,8000b984 <tc_irq+0x7c>
8000b90e:	6e 08       	ld.w	r8,r7[0x0]
8000b910:	2f f8       	sub	r8,-1
8000b912:	8f 08       	st.w	r7[0x0],r8

  // Clear the interrupt flag. This is a side effect of reading the TC SR.
  tc_read_sr(EXAMPLE_TC, TC_CHANNEL);
8000b914:	30 0b       	mov	r11,0
8000b916:	fe 7c 38 00 	mov	r12,-51200
8000b91a:	f0 1f 00 1c 	mcall	8000b988 <tc_irq+0x80>

  // Toggle a GPIO pin (this pin is used as a regular GPIO pin).
  if (tc_tick>=1000)
8000b91e:	6e 08       	ld.w	r8,r7[0x0]
8000b920:	e0 48 03 e7 	cp.w	r8,999
8000b924:	e0 88 00 2c 	brls	8000b97c <tc_irq+0x74>
  {		
	   gpio_tgl_gpio_pin(LED0_GPIO);
8000b928:	33 bc       	mov	r12,59
8000b92a:	f0 1f 00 19 	mcall	8000b98c <tc_irq+0x84>
		  tc_tick =0;
8000b92e:	30 09       	mov	r9,0
8000b930:	8f 09       	st.w	r7[0x0],r9
		  segundos++;
8000b932:	49 88       	lddpc	r8,8000b990 <tc_irq+0x88>
8000b934:	70 09       	ld.w	r9,r8[0x0]
8000b936:	2f f9       	sub	r9,-1
8000b938:	91 09       	st.w	r8[0x0],r9
		  if (segundos>=60)
8000b93a:	70 08       	ld.w	r8,r8[0x0]
8000b93c:	e0 48 00 3b 	cp.w	r8,59
8000b940:	e0 8a 00 1e 	brle	8000b97c <tc_irq+0x74>
		  {
			  segundos=0;
8000b944:	30 09       	mov	r9,0
8000b946:	49 38       	lddpc	r8,8000b990 <tc_irq+0x88>
8000b948:	91 09       	st.w	r8[0x0],r9
			  minutos++;
8000b94a:	49 38       	lddpc	r8,8000b994 <tc_irq+0x8c>
8000b94c:	70 0a       	ld.w	r10,r8[0x0]
8000b94e:	2f fa       	sub	r10,-1
8000b950:	91 0a       	st.w	r8[0x0],r10
			  gana1=0;
8000b952:	49 2a       	lddpc	r10,8000b998 <tc_irq+0x90>
8000b954:	95 09       	st.w	r10[0x0],r9
			  if (minutos>=60)
8000b956:	70 08       	ld.w	r8,r8[0x0]
8000b958:	e0 48 00 3b 	cp.w	r8,59
8000b95c:	e0 8a 00 10 	brle	8000b97c <tc_irq+0x74>
			  {
				  minutos=0;
8000b960:	48 d8       	lddpc	r8,8000b994 <tc_irq+0x8c>
8000b962:	91 09       	st.w	r8[0x0],r9
				  horas++;
8000b964:	48 e8       	lddpc	r8,8000b99c <tc_irq+0x94>
8000b966:	70 0a       	ld.w	r10,r8[0x0]
8000b968:	2f fa       	sub	r10,-1
8000b96a:	91 0a       	st.w	r8[0x0],r10
				  gana2=0;
8000b96c:	48 da       	lddpc	r10,8000b9a0 <tc_irq+0x98>
8000b96e:	95 09       	st.w	r10[0x0],r9
				  if (horas>=24)
8000b970:	70 08       	ld.w	r8,r8[0x0]
8000b972:	59 78       	cp.w	r8,23
8000b974:	e0 8a 00 04 	brle	8000b97c <tc_irq+0x74>
				  {
					  horas=0;
8000b978:	48 98       	lddpc	r8,8000b99c <tc_irq+0x94>
8000b97a:	91 09       	st.w	r8[0x0],r9
		  }  
	 
  }
  

}
8000b97c:	e3 cd 40 80 	ldm	sp++,r7,lr
8000b980:	d6 03       	rete
8000b982:	00 00       	add	r0,r0
8000b984:	00 00       	add	r0,r0
8000b986:	07 68       	ld.uh	r8,--r3
8000b988:	80 00       	ld.sh	r0,r0[0x0]
8000b98a:	8c 74       	ld.sh	r4,r6[0xe]
8000b98c:	80 00       	ld.sh	r0,r0[0x0]
8000b98e:	86 64       	ld.sh	r4,r3[0xc]
8000b990:	00 00       	add	r0,r0
8000b992:	07 6c       	ld.uh	r12,--r3
8000b994:	00 00       	add	r0,r0
8000b996:	07 5c       	ld.sh	r12,--r3
8000b998:	00 00       	add	r0,r0
8000b99a:	01 08       	ld.w	r8,r0++
8000b99c:	00 00       	add	r0,r0
8000b99e:	07 60       	ld.uh	r0,--r3
8000b9a0:	00 00       	add	r0,r0
8000b9a2:	01 0c       	ld.w	r12,r0++

8000b9a4 <__avr32_f64_mul>:
8000b9a4:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b9a8:	e0 80 00 dc 	breq	8000bb60 <__avr32_f64_mul_op1_zero>
8000b9ac:	d4 21       	pushm	r4-r7,lr
8000b9ae:	f7 e9 20 0e 	eor	lr,r11,r9
8000b9b2:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b9b6:	30 15       	mov	r5,1
8000b9b8:	c4 30       	breq	8000ba3e <__avr32_f64_mul_op1_subnormal>
8000b9ba:	ab 6b       	lsl	r11,0xa
8000b9bc:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000b9c0:	ab 6a       	lsl	r10,0xa
8000b9c2:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000b9c6:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b9ca:	c5 c0       	breq	8000ba82 <__avr32_f64_mul_op2_subnormal>
8000b9cc:	a1 78       	lsl	r8,0x1
8000b9ce:	5c f9       	rol	r9
8000b9d0:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b9d4:	e0 47 07 ff 	cp.w	r7,2047
8000b9d8:	c7 70       	breq	8000bac6 <__avr32_f64_mul_op_nan_or_inf>
8000b9da:	e0 46 07 ff 	cp.w	r6,2047
8000b9de:	c7 40       	breq	8000bac6 <__avr32_f64_mul_op_nan_or_inf>
8000b9e0:	ee 06 00 0c 	add	r12,r7,r6
8000b9e4:	e0 2c 03 fe 	sub	r12,1022
8000b9e8:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b9ec:	f4 09 07 44 	macu.d	r4,r10,r9
8000b9f0:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b9f4:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b9f8:	08 07       	add	r7,r4
8000b9fa:	f4 05 00 4a 	adc	r10,r10,r5
8000b9fe:	5c 0b       	acr	r11
8000ba00:	ed bb 00 14 	bld	r11,0x14
8000ba04:	c0 50       	breq	8000ba0e <__avr32_f64_mul+0x6a>
8000ba06:	a1 77       	lsl	r7,0x1
8000ba08:	5c fa       	rol	r10
8000ba0a:	5c fb       	rol	r11
8000ba0c:	20 1c       	sub	r12,1
8000ba0e:	58 0c       	cp.w	r12,0
8000ba10:	e0 8a 00 6f 	brle	8000baee <__avr32_f64_mul_res_subnormal>
8000ba14:	e0 4c 07 ff 	cp.w	r12,2047
8000ba18:	e0 84 00 9c 	brge	8000bb50 <__avr32_f64_mul_res_inf>
8000ba1c:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000ba20:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000ba24:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000ba28:	ee 17 80 00 	eorh	r7,0x8000
8000ba2c:	f1 b7 04 20 	satu	r7,0x1
8000ba30:	0e 0a       	add	r10,r7
8000ba32:	5c 0b       	acr	r11
8000ba34:	ed be 00 1f 	bld	lr,0x1f
8000ba38:	ef bb 00 1f 	bst	r11,0x1f
8000ba3c:	d8 22       	popm	r4-r7,pc

8000ba3e <__avr32_f64_mul_op1_subnormal>:
8000ba3e:	e4 1b 00 0f 	andh	r11,0xf
8000ba42:	f4 0c 12 00 	clz	r12,r10
8000ba46:	f6 06 12 00 	clz	r6,r11
8000ba4a:	f7 bc 03 e1 	sublo	r12,-31
8000ba4e:	f8 06 17 30 	movlo	r6,r12
8000ba52:	f7 b6 02 01 	subhs	r6,1
8000ba56:	e0 46 00 20 	cp.w	r6,32
8000ba5a:	c0 d4       	brge	8000ba74 <__avr32_f64_mul_op1_subnormal+0x36>
8000ba5c:	ec 0c 11 20 	rsub	r12,r6,32
8000ba60:	f6 06 09 4b 	lsl	r11,r11,r6
8000ba64:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000ba68:	18 4b       	or	r11,r12
8000ba6a:	f4 06 09 4a 	lsl	r10,r10,r6
8000ba6e:	20 b6       	sub	r6,11
8000ba70:	0c 17       	sub	r7,r6
8000ba72:	ca ab       	rjmp	8000b9c6 <__avr32_f64_mul+0x22>
8000ba74:	f4 06 09 4b 	lsl	r11,r10,r6
8000ba78:	c6 40       	breq	8000bb40 <__avr32_f64_mul_res_zero>
8000ba7a:	30 0a       	mov	r10,0
8000ba7c:	20 b6       	sub	r6,11
8000ba7e:	0c 17       	sub	r7,r6
8000ba80:	ca 3b       	rjmp	8000b9c6 <__avr32_f64_mul+0x22>

8000ba82 <__avr32_f64_mul_op2_subnormal>:
8000ba82:	e4 19 00 0f 	andh	r9,0xf
8000ba86:	f0 0c 12 00 	clz	r12,r8
8000ba8a:	f2 05 12 00 	clz	r5,r9
8000ba8e:	f7 bc 03 ea 	sublo	r12,-22
8000ba92:	f8 05 17 30 	movlo	r5,r12
8000ba96:	f7 b5 02 0a 	subhs	r5,10
8000ba9a:	e0 45 00 20 	cp.w	r5,32
8000ba9e:	c0 d4       	brge	8000bab8 <__avr32_f64_mul_op2_subnormal+0x36>
8000baa0:	ea 0c 11 20 	rsub	r12,r5,32
8000baa4:	f2 05 09 49 	lsl	r9,r9,r5
8000baa8:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000baac:	18 49       	or	r9,r12
8000baae:	f0 05 09 48 	lsl	r8,r8,r5
8000bab2:	20 25       	sub	r5,2
8000bab4:	0a 16       	sub	r6,r5
8000bab6:	c8 fb       	rjmp	8000b9d4 <__avr32_f64_mul+0x30>
8000bab8:	f0 05 09 49 	lsl	r9,r8,r5
8000babc:	c4 20       	breq	8000bb40 <__avr32_f64_mul_res_zero>
8000babe:	30 08       	mov	r8,0
8000bac0:	20 25       	sub	r5,2
8000bac2:	0a 16       	sub	r6,r5
8000bac4:	c8 8b       	rjmp	8000b9d4 <__avr32_f64_mul+0x30>

8000bac6 <__avr32_f64_mul_op_nan_or_inf>:
8000bac6:	e4 19 00 0f 	andh	r9,0xf
8000baca:	e4 1b 00 0f 	andh	r11,0xf
8000bace:	14 4b       	or	r11,r10
8000bad0:	10 49       	or	r9,r8
8000bad2:	e0 47 07 ff 	cp.w	r7,2047
8000bad6:	c0 91       	brne	8000bae8 <__avr32_f64_mul_op1_not_naninf>
8000bad8:	58 0b       	cp.w	r11,0
8000bada:	c3 81       	brne	8000bb4a <__avr32_f64_mul_res_nan>
8000badc:	e0 46 07 ff 	cp.w	r6,2047
8000bae0:	c3 81       	brne	8000bb50 <__avr32_f64_mul_res_inf>
8000bae2:	58 09       	cp.w	r9,0
8000bae4:	c3 60       	breq	8000bb50 <__avr32_f64_mul_res_inf>
8000bae6:	c3 28       	rjmp	8000bb4a <__avr32_f64_mul_res_nan>

8000bae8 <__avr32_f64_mul_op1_not_naninf>:
8000bae8:	58 09       	cp.w	r9,0
8000baea:	c3 30       	breq	8000bb50 <__avr32_f64_mul_res_inf>
8000baec:	c2 f8       	rjmp	8000bb4a <__avr32_f64_mul_res_nan>

8000baee <__avr32_f64_mul_res_subnormal>:
8000baee:	5c 3c       	neg	r12
8000baf0:	2f fc       	sub	r12,-1
8000baf2:	f1 bc 04 c0 	satu	r12,0x6
8000baf6:	e0 4c 00 20 	cp.w	r12,32
8000bafa:	c1 14       	brge	8000bb1c <__avr32_f64_mul_res_subnormal+0x2e>
8000bafc:	f8 08 11 20 	rsub	r8,r12,32
8000bb00:	0e 46       	or	r6,r7
8000bb02:	ee 0c 0a 47 	lsr	r7,r7,r12
8000bb06:	f4 08 09 49 	lsl	r9,r10,r8
8000bb0a:	12 47       	or	r7,r9
8000bb0c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bb10:	f6 08 09 49 	lsl	r9,r11,r8
8000bb14:	12 4a       	or	r10,r9
8000bb16:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bb1a:	c8 3b       	rjmp	8000ba20 <__avr32_f64_mul+0x7c>
8000bb1c:	f8 08 11 20 	rsub	r8,r12,32
8000bb20:	f9 b9 00 00 	moveq	r9,0
8000bb24:	c0 30       	breq	8000bb2a <__avr32_f64_mul_res_subnormal+0x3c>
8000bb26:	f6 08 09 49 	lsl	r9,r11,r8
8000bb2a:	0e 46       	or	r6,r7
8000bb2c:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000bb30:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bb34:	f3 ea 10 07 	or	r7,r9,r10
8000bb38:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000bb3c:	30 0b       	mov	r11,0
8000bb3e:	c7 1b       	rjmp	8000ba20 <__avr32_f64_mul+0x7c>

8000bb40 <__avr32_f64_mul_res_zero>:
8000bb40:	1c 9b       	mov	r11,lr
8000bb42:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bb46:	30 0a       	mov	r10,0
8000bb48:	d8 22       	popm	r4-r7,pc

8000bb4a <__avr32_f64_mul_res_nan>:
8000bb4a:	3f fb       	mov	r11,-1
8000bb4c:	3f fa       	mov	r10,-1
8000bb4e:	d8 22       	popm	r4-r7,pc

8000bb50 <__avr32_f64_mul_res_inf>:
8000bb50:	f0 6b 00 00 	mov	r11,-1048576
8000bb54:	ed be 00 1f 	bld	lr,0x1f
8000bb58:	ef bb 00 1f 	bst	r11,0x1f
8000bb5c:	30 0a       	mov	r10,0
8000bb5e:	d8 22       	popm	r4-r7,pc

8000bb60 <__avr32_f64_mul_op1_zero>:
8000bb60:	f7 e9 20 0b 	eor	r11,r11,r9
8000bb64:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bb68:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000bb6c:	e0 4c 07 ff 	cp.w	r12,2047
8000bb70:	5e 1c       	retne	r12
8000bb72:	3f fa       	mov	r10,-1
8000bb74:	3f fb       	mov	r11,-1
8000bb76:	5e fc       	retal	r12

8000bb78 <__avr32_f64_sub_from_add>:
8000bb78:	ee 19 80 00 	eorh	r9,0x8000

8000bb7c <__avr32_f64_sub>:
8000bb7c:	f7 e9 20 0c 	eor	r12,r11,r9
8000bb80:	e0 86 00 ca 	brmi	8000bd14 <__avr32_f64_add_from_sub>
8000bb84:	eb cd 40 e0 	pushm	r5-r7,lr
8000bb88:	16 9c       	mov	r12,r11
8000bb8a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000bb8e:	bf db       	cbr	r11,0x1f
8000bb90:	bf d9       	cbr	r9,0x1f
8000bb92:	10 3a       	cp.w	r10,r8
8000bb94:	f2 0b 13 00 	cpc	r11,r9
8000bb98:	c0 92       	brcc	8000bbaa <__avr32_f64_sub+0x2e>
8000bb9a:	16 97       	mov	r7,r11
8000bb9c:	12 9b       	mov	r11,r9
8000bb9e:	0e 99       	mov	r9,r7
8000bba0:	14 97       	mov	r7,r10
8000bba2:	10 9a       	mov	r10,r8
8000bba4:	0e 98       	mov	r8,r7
8000bba6:	ee 1c 80 00 	eorh	r12,0x8000
8000bbaa:	f6 07 16 14 	lsr	r7,r11,0x14
8000bbae:	ab 7b       	lsl	r11,0xb
8000bbb0:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bbb4:	ab 7a       	lsl	r10,0xb
8000bbb6:	bf bb       	sbr	r11,0x1f
8000bbb8:	f2 06 16 14 	lsr	r6,r9,0x14
8000bbbc:	c4 40       	breq	8000bc44 <__avr32_f64_sub_opL_subnormal>
8000bbbe:	ab 79       	lsl	r9,0xb
8000bbc0:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bbc4:	ab 78       	lsl	r8,0xb
8000bbc6:	bf b9       	sbr	r9,0x1f

8000bbc8 <__avr32_f64_sub_opL_subnormal_done>:
8000bbc8:	e0 47 07 ff 	cp.w	r7,2047
8000bbcc:	c4 f0       	breq	8000bc6a <__avr32_f64_sub_opH_nan_or_inf>
8000bbce:	0e 26       	rsub	r6,r7
8000bbd0:	c1 20       	breq	8000bbf4 <__avr32_f64_sub_shift_done>
8000bbd2:	ec 05 11 20 	rsub	r5,r6,32
8000bbd6:	e0 46 00 20 	cp.w	r6,32
8000bbda:	c7 c2       	brcc	8000bcd2 <__avr32_f64_sub_longshift>
8000bbdc:	f0 05 09 4e 	lsl	lr,r8,r5
8000bbe0:	f2 05 09 45 	lsl	r5,r9,r5
8000bbe4:	f0 06 0a 48 	lsr	r8,r8,r6
8000bbe8:	f2 06 0a 49 	lsr	r9,r9,r6
8000bbec:	0a 48       	or	r8,r5
8000bbee:	58 0e       	cp.w	lr,0
8000bbf0:	5f 1e       	srne	lr
8000bbf2:	1c 48       	or	r8,lr

8000bbf4 <__avr32_f64_sub_shift_done>:
8000bbf4:	10 1a       	sub	r10,r8
8000bbf6:	f6 09 01 4b 	sbc	r11,r11,r9
8000bbfa:	f6 06 12 00 	clz	r6,r11
8000bbfe:	c0 e0       	breq	8000bc1a <__avr32_f64_sub_longnormalize_done>
8000bc00:	c7 83       	brcs	8000bcf0 <__avr32_f64_sub_longnormalize>
8000bc02:	ec 0e 11 20 	rsub	lr,r6,32
8000bc06:	f6 06 09 4b 	lsl	r11,r11,r6
8000bc0a:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bc0e:	1c 4b       	or	r11,lr
8000bc10:	f4 06 09 4a 	lsl	r10,r10,r6
8000bc14:	0c 17       	sub	r7,r6
8000bc16:	e0 8a 00 39 	brle	8000bc88 <__avr32_f64_sub_subnormal_result>

8000bc1a <__avr32_f64_sub_longnormalize_done>:
8000bc1a:	f4 09 15 15 	lsl	r9,r10,0x15
8000bc1e:	ab 9a       	lsr	r10,0xb
8000bc20:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bc24:	ab 9b       	lsr	r11,0xb
8000bc26:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bc2a:	18 4b       	or	r11,r12

8000bc2c <__avr32_f64_sub_round>:
8000bc2c:	fc 17 80 00 	movh	r7,0x8000
8000bc30:	ed ba 00 00 	bld	r10,0x0
8000bc34:	f7 b7 01 ff 	subne	r7,-1
8000bc38:	0e 39       	cp.w	r9,r7
8000bc3a:	5f 29       	srhs	r9
8000bc3c:	12 0a       	add	r10,r9
8000bc3e:	5c 0b       	acr	r11
8000bc40:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bc44 <__avr32_f64_sub_opL_subnormal>:
8000bc44:	ab 79       	lsl	r9,0xb
8000bc46:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bc4a:	ab 78       	lsl	r8,0xb
8000bc4c:	f3 e8 10 0e 	or	lr,r9,r8
8000bc50:	f9 b6 01 01 	movne	r6,1
8000bc54:	ee 0e 11 00 	rsub	lr,r7,0
8000bc58:	f9 b7 00 01 	moveq	r7,1
8000bc5c:	ef bb 00 1f 	bst	r11,0x1f
8000bc60:	f7 ea 10 0e 	or	lr,r11,r10
8000bc64:	f9 b7 00 00 	moveq	r7,0
8000bc68:	cb 0b       	rjmp	8000bbc8 <__avr32_f64_sub_opL_subnormal_done>

8000bc6a <__avr32_f64_sub_opH_nan_or_inf>:
8000bc6a:	bf db       	cbr	r11,0x1f
8000bc6c:	f7 ea 10 0e 	or	lr,r11,r10
8000bc70:	c0 81       	brne	8000bc80 <__avr32_f64_sub_return_nan>
8000bc72:	e0 46 07 ff 	cp.w	r6,2047
8000bc76:	c0 50       	breq	8000bc80 <__avr32_f64_sub_return_nan>
8000bc78:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000bc7c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bc80 <__avr32_f64_sub_return_nan>:
8000bc80:	3f fa       	mov	r10,-1
8000bc82:	3f fb       	mov	r11,-1
8000bc84:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bc88 <__avr32_f64_sub_subnormal_result>:
8000bc88:	5c 37       	neg	r7
8000bc8a:	2f f7       	sub	r7,-1
8000bc8c:	f1 b7 04 c0 	satu	r7,0x6
8000bc90:	e0 47 00 20 	cp.w	r7,32
8000bc94:	c1 14       	brge	8000bcb6 <__avr32_f64_sub_subnormal_result+0x2e>
8000bc96:	ee 08 11 20 	rsub	r8,r7,32
8000bc9a:	f4 08 09 49 	lsl	r9,r10,r8
8000bc9e:	5f 16       	srne	r6
8000bca0:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bca4:	0c 4a       	or	r10,r6
8000bca6:	f6 08 09 49 	lsl	r9,r11,r8
8000bcaa:	f5 e9 10 0a 	or	r10,r10,r9
8000bcae:	f4 07 0a 4b 	lsr	r11,r10,r7
8000bcb2:	30 07       	mov	r7,0
8000bcb4:	cb 3b       	rjmp	8000bc1a <__avr32_f64_sub_longnormalize_done>
8000bcb6:	ee 08 11 40 	rsub	r8,r7,64
8000bcba:	f6 08 09 49 	lsl	r9,r11,r8
8000bcbe:	14 49       	or	r9,r10
8000bcc0:	5f 16       	srne	r6
8000bcc2:	f6 07 0a 4a 	lsr	r10,r11,r7
8000bcc6:	0c 4a       	or	r10,r6
8000bcc8:	30 0b       	mov	r11,0
8000bcca:	30 07       	mov	r7,0
8000bccc:	ca 7b       	rjmp	8000bc1a <__avr32_f64_sub_longnormalize_done>
8000bcce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bcd2 <__avr32_f64_sub_longshift>:
8000bcd2:	f1 b6 04 c0 	satu	r6,0x6
8000bcd6:	f0 0e 17 00 	moveq	lr,r8
8000bcda:	c0 40       	breq	8000bce2 <__avr32_f64_sub_longshift+0x10>
8000bcdc:	f2 05 09 4e 	lsl	lr,r9,r5
8000bce0:	10 4e       	or	lr,r8
8000bce2:	f2 06 0a 48 	lsr	r8,r9,r6
8000bce6:	30 09       	mov	r9,0
8000bce8:	58 0e       	cp.w	lr,0
8000bcea:	5f 1e       	srne	lr
8000bcec:	1c 48       	or	r8,lr
8000bcee:	c8 3b       	rjmp	8000bbf4 <__avr32_f64_sub_shift_done>

8000bcf0 <__avr32_f64_sub_longnormalize>:
8000bcf0:	f4 06 12 00 	clz	r6,r10
8000bcf4:	f9 b7 03 00 	movlo	r7,0
8000bcf8:	f9 b6 03 00 	movlo	r6,0
8000bcfc:	f9 bc 03 00 	movlo	r12,0
8000bd00:	f7 b6 02 e0 	subhs	r6,-32
8000bd04:	f4 06 09 4b 	lsl	r11,r10,r6
8000bd08:	30 0a       	mov	r10,0
8000bd0a:	0c 17       	sub	r7,r6
8000bd0c:	fe 9a ff be 	brle	8000bc88 <__avr32_f64_sub_subnormal_result>
8000bd10:	c8 5b       	rjmp	8000bc1a <__avr32_f64_sub_longnormalize_done>
8000bd12:	d7 03       	nop

8000bd14 <__avr32_f64_add_from_sub>:
8000bd14:	ee 19 80 00 	eorh	r9,0x8000

8000bd18 <__avr32_f64_add>:
8000bd18:	f7 e9 20 0c 	eor	r12,r11,r9
8000bd1c:	fe 96 ff 2e 	brmi	8000bb78 <__avr32_f64_sub_from_add>
8000bd20:	eb cd 40 e0 	pushm	r5-r7,lr
8000bd24:	16 9c       	mov	r12,r11
8000bd26:	e6 1c 80 00 	andh	r12,0x8000,COH
8000bd2a:	bf db       	cbr	r11,0x1f
8000bd2c:	bf d9       	cbr	r9,0x1f
8000bd2e:	12 3b       	cp.w	r11,r9
8000bd30:	c0 72       	brcc	8000bd3e <__avr32_f64_add+0x26>
8000bd32:	16 97       	mov	r7,r11
8000bd34:	12 9b       	mov	r11,r9
8000bd36:	0e 99       	mov	r9,r7
8000bd38:	14 97       	mov	r7,r10
8000bd3a:	10 9a       	mov	r10,r8
8000bd3c:	0e 98       	mov	r8,r7
8000bd3e:	30 0e       	mov	lr,0
8000bd40:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bd44:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000bd48:	b5 ab       	sbr	r11,0x14
8000bd4a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bd4e:	c6 20       	breq	8000be12 <__avr32_f64_add_op2_subnormal>
8000bd50:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000bd54:	b5 a9       	sbr	r9,0x14
8000bd56:	e0 47 07 ff 	cp.w	r7,2047
8000bd5a:	c2 80       	breq	8000bdaa <__avr32_f64_add_opH_nan_or_inf>
8000bd5c:	0e 26       	rsub	r6,r7
8000bd5e:	c1 20       	breq	8000bd82 <__avr32_f64_add_shift_done>
8000bd60:	e0 46 00 36 	cp.w	r6,54
8000bd64:	c1 52       	brcc	8000bd8e <__avr32_f64_add_res_of_done>
8000bd66:	ec 05 11 20 	rsub	r5,r6,32
8000bd6a:	e0 46 00 20 	cp.w	r6,32
8000bd6e:	c3 52       	brcc	8000bdd8 <__avr32_f64_add_longshift>
8000bd70:	f0 05 09 4e 	lsl	lr,r8,r5
8000bd74:	f2 05 09 45 	lsl	r5,r9,r5
8000bd78:	f0 06 0a 48 	lsr	r8,r8,r6
8000bd7c:	f2 06 0a 49 	lsr	r9,r9,r6
8000bd80:	0a 48       	or	r8,r5

8000bd82 <__avr32_f64_add_shift_done>:
8000bd82:	10 0a       	add	r10,r8
8000bd84:	f6 09 00 4b 	adc	r11,r11,r9
8000bd88:	ed bb 00 15 	bld	r11,0x15
8000bd8c:	c3 40       	breq	8000bdf4 <__avr32_f64_add_res_of>

8000bd8e <__avr32_f64_add_res_of_done>:
8000bd8e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bd92:	18 4b       	or	r11,r12

8000bd94 <__avr32_f64_add_round>:
8000bd94:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000bd98:	18 4e       	or	lr,r12
8000bd9a:	ee 1e 80 00 	eorh	lr,0x8000
8000bd9e:	f1 be 04 20 	satu	lr,0x1
8000bda2:	1c 0a       	add	r10,lr
8000bda4:	5c 0b       	acr	r11
8000bda6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bdaa <__avr32_f64_add_opH_nan_or_inf>:
8000bdaa:	b5 cb       	cbr	r11,0x14
8000bdac:	f7 ea 10 0e 	or	lr,r11,r10
8000bdb0:	c1 01       	brne	8000bdd0 <__avr32_f64_add_return_nan>
8000bdb2:	e0 46 07 ff 	cp.w	r6,2047
8000bdb6:	c0 30       	breq	8000bdbc <__avr32_f64_add_opL_nan_or_inf>
8000bdb8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bdbc <__avr32_f64_add_opL_nan_or_inf>:
8000bdbc:	b5 c9       	cbr	r9,0x14
8000bdbe:	f3 e8 10 0e 	or	lr,r9,r8
8000bdc2:	c0 71       	brne	8000bdd0 <__avr32_f64_add_return_nan>
8000bdc4:	30 0a       	mov	r10,0
8000bdc6:	fc 1b 7f f0 	movh	r11,0x7ff0
8000bdca:	18 4b       	or	r11,r12
8000bdcc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bdd0 <__avr32_f64_add_return_nan>:
8000bdd0:	3f fa       	mov	r10,-1
8000bdd2:	3f fb       	mov	r11,-1
8000bdd4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bdd8 <__avr32_f64_add_longshift>:
8000bdd8:	f1 b6 04 c0 	satu	r6,0x6
8000bddc:	f0 0e 17 00 	moveq	lr,r8
8000bde0:	c0 60       	breq	8000bdec <__avr32_f64_add_longshift+0x14>
8000bde2:	f2 05 09 4e 	lsl	lr,r9,r5
8000bde6:	58 08       	cp.w	r8,0
8000bde8:	5f 18       	srne	r8
8000bdea:	10 4e       	or	lr,r8
8000bdec:	f2 06 0a 48 	lsr	r8,r9,r6
8000bdf0:	30 09       	mov	r9,0
8000bdf2:	cc 8b       	rjmp	8000bd82 <__avr32_f64_add_shift_done>

8000bdf4 <__avr32_f64_add_res_of>:
8000bdf4:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000bdf8:	a1 9b       	lsr	r11,0x1
8000bdfa:	5d 0a       	ror	r10
8000bdfc:	5d 0e       	ror	lr
8000bdfe:	2f f7       	sub	r7,-1
8000be00:	e0 47 07 ff 	cp.w	r7,2047
8000be04:	f9 ba 00 00 	moveq	r10,0
8000be08:	f9 bb 00 00 	moveq	r11,0
8000be0c:	f9 be 00 00 	moveq	lr,0
8000be10:	cb fb       	rjmp	8000bd8e <__avr32_f64_add_res_of_done>

8000be12 <__avr32_f64_add_op2_subnormal>:
8000be12:	30 16       	mov	r6,1
8000be14:	58 07       	cp.w	r7,0
8000be16:	ca 01       	brne	8000bd56 <__avr32_f64_add+0x3e>
8000be18:	b5 cb       	cbr	r11,0x14
8000be1a:	10 0a       	add	r10,r8
8000be1c:	f6 09 00 4b 	adc	r11,r11,r9
8000be20:	18 4b       	or	r11,r12
8000be22:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000be26:	d7 03       	nop

8000be28 <__avr32_f64_to_u32>:
8000be28:	58 0b       	cp.w	r11,0
8000be2a:	5e 6d       	retmi	0

8000be2c <__avr32_f64_to_s32>:
8000be2c:	f6 0c 15 01 	lsl	r12,r11,0x1
8000be30:	b5 9c       	lsr	r12,0x15
8000be32:	e0 2c 03 ff 	sub	r12,1023
8000be36:	5e 3d       	retlo	0
8000be38:	f8 0c 11 1f 	rsub	r12,r12,31
8000be3c:	16 99       	mov	r9,r11
8000be3e:	ab 7b       	lsl	r11,0xb
8000be40:	bf bb       	sbr	r11,0x1f
8000be42:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000be46:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000be4a:	a1 79       	lsl	r9,0x1
8000be4c:	5e 2b       	reths	r11
8000be4e:	5c 3b       	neg	r11
8000be50:	5e fb       	retal	r11

8000be52 <__avr32_u32_to_f64>:
8000be52:	f8 cb 00 00 	sub	r11,r12,0
8000be56:	30 0c       	mov	r12,0
8000be58:	c0 38       	rjmp	8000be5e <__avr32_s32_to_f64+0x4>

8000be5a <__avr32_s32_to_f64>:
8000be5a:	18 9b       	mov	r11,r12
8000be5c:	5c 4b       	abs	r11
8000be5e:	30 0a       	mov	r10,0
8000be60:	5e 0b       	reteq	r11
8000be62:	d4 01       	pushm	lr
8000be64:	e0 69 04 1e 	mov	r9,1054
8000be68:	f6 08 12 00 	clz	r8,r11
8000be6c:	c1 70       	breq	8000be9a <__avr32_s32_to_f64+0x40>
8000be6e:	c0 c3       	brcs	8000be86 <__avr32_s32_to_f64+0x2c>
8000be70:	f0 0e 11 20 	rsub	lr,r8,32
8000be74:	f6 08 09 4b 	lsl	r11,r11,r8
8000be78:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000be7c:	1c 4b       	or	r11,lr
8000be7e:	f4 08 09 4a 	lsl	r10,r10,r8
8000be82:	10 19       	sub	r9,r8
8000be84:	c0 b8       	rjmp	8000be9a <__avr32_s32_to_f64+0x40>
8000be86:	f4 08 12 00 	clz	r8,r10
8000be8a:	f9 b8 03 00 	movlo	r8,0
8000be8e:	f7 b8 02 e0 	subhs	r8,-32
8000be92:	f4 08 09 4b 	lsl	r11,r10,r8
8000be96:	30 0a       	mov	r10,0
8000be98:	10 19       	sub	r9,r8
8000be9a:	58 09       	cp.w	r9,0
8000be9c:	e0 89 00 30 	brgt	8000befc <__avr32_s32_to_f64+0xa2>
8000bea0:	5c 39       	neg	r9
8000bea2:	2f f9       	sub	r9,-1
8000bea4:	e0 49 00 36 	cp.w	r9,54
8000bea8:	c0 43       	brcs	8000beb0 <__avr32_s32_to_f64+0x56>
8000beaa:	30 0b       	mov	r11,0
8000beac:	30 0a       	mov	r10,0
8000beae:	c2 68       	rjmp	8000befa <__avr32_s32_to_f64+0xa0>
8000beb0:	2f 69       	sub	r9,-10
8000beb2:	f2 08 11 20 	rsub	r8,r9,32
8000beb6:	e0 49 00 20 	cp.w	r9,32
8000beba:	c0 b2       	brcc	8000bed0 <__avr32_s32_to_f64+0x76>
8000bebc:	f4 08 09 4e 	lsl	lr,r10,r8
8000bec0:	f6 08 09 48 	lsl	r8,r11,r8
8000bec4:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bec8:	f6 09 0a 4b 	lsr	r11,r11,r9
8000becc:	10 4b       	or	r11,r8
8000bece:	c0 88       	rjmp	8000bede <__avr32_s32_to_f64+0x84>
8000bed0:	f6 08 09 4e 	lsl	lr,r11,r8
8000bed4:	14 4e       	or	lr,r10
8000bed6:	16 9a       	mov	r10,r11
8000bed8:	30 0b       	mov	r11,0
8000beda:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bede:	ed ba 00 00 	bld	r10,0x0
8000bee2:	c0 92       	brcc	8000bef4 <__avr32_s32_to_f64+0x9a>
8000bee4:	1c 7e       	tst	lr,lr
8000bee6:	c0 41       	brne	8000beee <__avr32_s32_to_f64+0x94>
8000bee8:	ed ba 00 01 	bld	r10,0x1
8000beec:	c0 42       	brcc	8000bef4 <__avr32_s32_to_f64+0x9a>
8000beee:	2f fa       	sub	r10,-1
8000bef0:	f7 bb 02 ff 	subhs	r11,-1
8000bef4:	5c fc       	rol	r12
8000bef6:	5d 0b       	ror	r11
8000bef8:	5d 0a       	ror	r10
8000befa:	d8 02       	popm	pc
8000befc:	e0 68 03 ff 	mov	r8,1023
8000bf00:	ed ba 00 0b 	bld	r10,0xb
8000bf04:	f7 b8 00 ff 	subeq	r8,-1
8000bf08:	10 0a       	add	r10,r8
8000bf0a:	5c 0b       	acr	r11
8000bf0c:	f7 b9 03 fe 	sublo	r9,-2
8000bf10:	e0 49 07 ff 	cp.w	r9,2047
8000bf14:	c0 55       	brlt	8000bf1e <__avr32_s32_to_f64+0xc4>
8000bf16:	30 0a       	mov	r10,0
8000bf18:	fc 1b ff e0 	movh	r11,0xffe0
8000bf1c:	c0 c8       	rjmp	8000bf34 <__floatsidf_return_op1>
8000bf1e:	ed bb 00 1f 	bld	r11,0x1f
8000bf22:	f7 b9 01 01 	subne	r9,1
8000bf26:	ab 9a       	lsr	r10,0xb
8000bf28:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bf2c:	a1 7b       	lsl	r11,0x1
8000bf2e:	ab 9b       	lsr	r11,0xb
8000bf30:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000bf34 <__floatsidf_return_op1>:
8000bf34:	a1 7c       	lsl	r12,0x1
8000bf36:	5d 0b       	ror	r11
8000bf38:	d8 02       	popm	pc

8000bf3a <__avr32_udiv64>:
8000bf3a:	d4 31       	pushm	r0-r7,lr
8000bf3c:	1a 97       	mov	r7,sp
8000bf3e:	20 3d       	sub	sp,12
8000bf40:	10 9c       	mov	r12,r8
8000bf42:	12 9e       	mov	lr,r9
8000bf44:	14 93       	mov	r3,r10
8000bf46:	58 09       	cp.w	r9,0
8000bf48:	e0 81 00 bd 	brne	8000c0c2 <__avr32_udiv64+0x188>
8000bf4c:	16 38       	cp.w	r8,r11
8000bf4e:	e0 88 00 40 	brls	8000bfce <__avr32_udiv64+0x94>
8000bf52:	f0 08 12 00 	clz	r8,r8
8000bf56:	c0 d0       	breq	8000bf70 <__avr32_udiv64+0x36>
8000bf58:	f6 08 09 4b 	lsl	r11,r11,r8
8000bf5c:	f0 09 11 20 	rsub	r9,r8,32
8000bf60:	f8 08 09 4c 	lsl	r12,r12,r8
8000bf64:	f4 09 0a 49 	lsr	r9,r10,r9
8000bf68:	f4 08 09 43 	lsl	r3,r10,r8
8000bf6c:	f3 eb 10 0b 	or	r11,r9,r11
8000bf70:	f8 0e 16 10 	lsr	lr,r12,0x10
8000bf74:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000bf78:	f6 0e 0d 00 	divu	r0,r11,lr
8000bf7c:	e6 0b 16 10 	lsr	r11,r3,0x10
8000bf80:	00 99       	mov	r9,r0
8000bf82:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bf86:	e0 0a 02 48 	mul	r8,r0,r10
8000bf8a:	10 3b       	cp.w	r11,r8
8000bf8c:	c0 a2       	brcc	8000bfa0 <__avr32_udiv64+0x66>
8000bf8e:	20 19       	sub	r9,1
8000bf90:	18 0b       	add	r11,r12
8000bf92:	18 3b       	cp.w	r11,r12
8000bf94:	c0 63       	brcs	8000bfa0 <__avr32_udiv64+0x66>
8000bf96:	10 3b       	cp.w	r11,r8
8000bf98:	f7 b9 03 01 	sublo	r9,1
8000bf9c:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bfa0:	f6 08 01 01 	sub	r1,r11,r8
8000bfa4:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000bfa8:	e2 0e 0d 00 	divu	r0,r1,lr
8000bfac:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000bfb0:	00 98       	mov	r8,r0
8000bfb2:	e0 0a 02 4a 	mul	r10,r0,r10
8000bfb6:	14 33       	cp.w	r3,r10
8000bfb8:	c0 82       	brcc	8000bfc8 <__avr32_udiv64+0x8e>
8000bfba:	20 18       	sub	r8,1
8000bfbc:	18 03       	add	r3,r12
8000bfbe:	18 33       	cp.w	r3,r12
8000bfc0:	c0 43       	brcs	8000bfc8 <__avr32_udiv64+0x8e>
8000bfc2:	14 33       	cp.w	r3,r10
8000bfc4:	f7 b8 03 01 	sublo	r8,1
8000bfc8:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000bfcc:	cd f8       	rjmp	8000c18a <__avr32_udiv64+0x250>
8000bfce:	58 08       	cp.w	r8,0
8000bfd0:	c0 51       	brne	8000bfda <__avr32_udiv64+0xa0>
8000bfd2:	30 19       	mov	r9,1
8000bfd4:	f2 08 0d 08 	divu	r8,r9,r8
8000bfd8:	10 9c       	mov	r12,r8
8000bfda:	f8 06 12 00 	clz	r6,r12
8000bfde:	c0 41       	brne	8000bfe6 <__avr32_udiv64+0xac>
8000bfe0:	18 1b       	sub	r11,r12
8000bfe2:	30 19       	mov	r9,1
8000bfe4:	c4 08       	rjmp	8000c064 <__avr32_udiv64+0x12a>
8000bfe6:	ec 01 11 20 	rsub	r1,r6,32
8000bfea:	f4 01 0a 49 	lsr	r9,r10,r1
8000bfee:	f8 06 09 4c 	lsl	r12,r12,r6
8000bff2:	f6 06 09 48 	lsl	r8,r11,r6
8000bff6:	f6 01 0a 41 	lsr	r1,r11,r1
8000bffa:	f3 e8 10 08 	or	r8,r9,r8
8000bffe:	f8 03 16 10 	lsr	r3,r12,0x10
8000c002:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c006:	e2 03 0d 00 	divu	r0,r1,r3
8000c00a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c00e:	00 9e       	mov	lr,r0
8000c010:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c014:	e0 05 02 49 	mul	r9,r0,r5
8000c018:	12 3b       	cp.w	r11,r9
8000c01a:	c0 a2       	brcc	8000c02e <__avr32_udiv64+0xf4>
8000c01c:	20 1e       	sub	lr,1
8000c01e:	18 0b       	add	r11,r12
8000c020:	18 3b       	cp.w	r11,r12
8000c022:	c0 63       	brcs	8000c02e <__avr32_udiv64+0xf4>
8000c024:	12 3b       	cp.w	r11,r9
8000c026:	f7 be 03 01 	sublo	lr,1
8000c02a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c02e:	12 1b       	sub	r11,r9
8000c030:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c034:	f6 03 0d 02 	divu	r2,r11,r3
8000c038:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c03c:	04 99       	mov	r9,r2
8000c03e:	e4 05 02 4b 	mul	r11,r2,r5
8000c042:	16 38       	cp.w	r8,r11
8000c044:	c0 a2       	brcc	8000c058 <__avr32_udiv64+0x11e>
8000c046:	20 19       	sub	r9,1
8000c048:	18 08       	add	r8,r12
8000c04a:	18 38       	cp.w	r8,r12
8000c04c:	c0 63       	brcs	8000c058 <__avr32_udiv64+0x11e>
8000c04e:	16 38       	cp.w	r8,r11
8000c050:	f7 b9 03 01 	sublo	r9,1
8000c054:	f1 dc e3 08 	addcs	r8,r8,r12
8000c058:	f4 06 09 43 	lsl	r3,r10,r6
8000c05c:	f0 0b 01 0b 	sub	r11,r8,r11
8000c060:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c064:	f8 06 16 10 	lsr	r6,r12,0x10
8000c068:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c06c:	f6 06 0d 00 	divu	r0,r11,r6
8000c070:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c074:	00 9a       	mov	r10,r0
8000c076:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c07a:	e0 0e 02 48 	mul	r8,r0,lr
8000c07e:	10 3b       	cp.w	r11,r8
8000c080:	c0 a2       	brcc	8000c094 <__avr32_udiv64+0x15a>
8000c082:	20 1a       	sub	r10,1
8000c084:	18 0b       	add	r11,r12
8000c086:	18 3b       	cp.w	r11,r12
8000c088:	c0 63       	brcs	8000c094 <__avr32_udiv64+0x15a>
8000c08a:	10 3b       	cp.w	r11,r8
8000c08c:	f7 ba 03 01 	sublo	r10,1
8000c090:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c094:	f6 08 01 01 	sub	r1,r11,r8
8000c098:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c09c:	e2 06 0d 00 	divu	r0,r1,r6
8000c0a0:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c0a4:	00 98       	mov	r8,r0
8000c0a6:	e0 0e 02 4b 	mul	r11,r0,lr
8000c0aa:	16 33       	cp.w	r3,r11
8000c0ac:	c0 82       	brcc	8000c0bc <__avr32_udiv64+0x182>
8000c0ae:	20 18       	sub	r8,1
8000c0b0:	18 03       	add	r3,r12
8000c0b2:	18 33       	cp.w	r3,r12
8000c0b4:	c0 43       	brcs	8000c0bc <__avr32_udiv64+0x182>
8000c0b6:	16 33       	cp.w	r3,r11
8000c0b8:	f7 b8 03 01 	sublo	r8,1
8000c0bc:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c0c0:	c6 98       	rjmp	8000c192 <__avr32_udiv64+0x258>
8000c0c2:	16 39       	cp.w	r9,r11
8000c0c4:	e0 8b 00 65 	brhi	8000c18e <__avr32_udiv64+0x254>
8000c0c8:	f2 09 12 00 	clz	r9,r9
8000c0cc:	c0 b1       	brne	8000c0e2 <__avr32_udiv64+0x1a8>
8000c0ce:	10 3a       	cp.w	r10,r8
8000c0d0:	5f 2a       	srhs	r10
8000c0d2:	1c 3b       	cp.w	r11,lr
8000c0d4:	5f b8       	srhi	r8
8000c0d6:	10 4a       	or	r10,r8
8000c0d8:	f2 0a 18 00 	cp.b	r10,r9
8000c0dc:	c5 90       	breq	8000c18e <__avr32_udiv64+0x254>
8000c0de:	30 18       	mov	r8,1
8000c0e0:	c5 98       	rjmp	8000c192 <__avr32_udiv64+0x258>
8000c0e2:	f0 09 09 46 	lsl	r6,r8,r9
8000c0e6:	f2 03 11 20 	rsub	r3,r9,32
8000c0ea:	fc 09 09 4e 	lsl	lr,lr,r9
8000c0ee:	f0 03 0a 48 	lsr	r8,r8,r3
8000c0f2:	f6 09 09 4c 	lsl	r12,r11,r9
8000c0f6:	f4 03 0a 42 	lsr	r2,r10,r3
8000c0fa:	ef 46 ff f4 	st.w	r7[-12],r6
8000c0fe:	f6 03 0a 43 	lsr	r3,r11,r3
8000c102:	18 42       	or	r2,r12
8000c104:	f1 ee 10 0c 	or	r12,r8,lr
8000c108:	f8 01 16 10 	lsr	r1,r12,0x10
8000c10c:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c110:	e6 01 0d 04 	divu	r4,r3,r1
8000c114:	e4 03 16 10 	lsr	r3,r2,0x10
8000c118:	08 9e       	mov	lr,r4
8000c11a:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c11e:	e8 06 02 48 	mul	r8,r4,r6
8000c122:	10 33       	cp.w	r3,r8
8000c124:	c0 a2       	brcc	8000c138 <__avr32_udiv64+0x1fe>
8000c126:	20 1e       	sub	lr,1
8000c128:	18 03       	add	r3,r12
8000c12a:	18 33       	cp.w	r3,r12
8000c12c:	c0 63       	brcs	8000c138 <__avr32_udiv64+0x1fe>
8000c12e:	10 33       	cp.w	r3,r8
8000c130:	f7 be 03 01 	sublo	lr,1
8000c134:	e7 dc e3 03 	addcs	r3,r3,r12
8000c138:	10 13       	sub	r3,r8
8000c13a:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c13e:	e6 01 0d 00 	divu	r0,r3,r1
8000c142:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c146:	00 98       	mov	r8,r0
8000c148:	e0 06 02 46 	mul	r6,r0,r6
8000c14c:	0c 3b       	cp.w	r11,r6
8000c14e:	c0 a2       	brcc	8000c162 <__avr32_udiv64+0x228>
8000c150:	20 18       	sub	r8,1
8000c152:	18 0b       	add	r11,r12
8000c154:	18 3b       	cp.w	r11,r12
8000c156:	c0 63       	brcs	8000c162 <__avr32_udiv64+0x228>
8000c158:	0c 3b       	cp.w	r11,r6
8000c15a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c15e:	f7 b8 03 01 	sublo	r8,1
8000c162:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c166:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c16a:	0c 1b       	sub	r11,r6
8000c16c:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c170:	06 95       	mov	r5,r3
8000c172:	16 35       	cp.w	r5,r11
8000c174:	e0 8b 00 0a 	brhi	8000c188 <__avr32_udiv64+0x24e>
8000c178:	5f 0b       	sreq	r11
8000c17a:	f4 09 09 49 	lsl	r9,r10,r9
8000c17e:	12 32       	cp.w	r2,r9
8000c180:	5f b9       	srhi	r9
8000c182:	f7 e9 00 09 	and	r9,r11,r9
8000c186:	c0 60       	breq	8000c192 <__avr32_udiv64+0x258>
8000c188:	20 18       	sub	r8,1
8000c18a:	30 09       	mov	r9,0
8000c18c:	c0 38       	rjmp	8000c192 <__avr32_udiv64+0x258>
8000c18e:	30 09       	mov	r9,0
8000c190:	12 98       	mov	r8,r9
8000c192:	10 9a       	mov	r10,r8
8000c194:	12 93       	mov	r3,r9
8000c196:	10 92       	mov	r2,r8
8000c198:	12 9b       	mov	r11,r9
8000c19a:	2f dd       	sub	sp,-12
8000c19c:	d8 32       	popm	r0-r7,pc
8000c19e:	d7 03       	nop

8000c1a0 <__assert_func>:
8000c1a0:	d4 01       	pushm	lr
8000c1a2:	58 0a       	cp.w	r10,0
8000c1a4:	c0 30       	breq	8000c1aa <__assert_func+0xa>
8000c1a6:	48 a8       	lddpc	r8,8000c1cc <__assert_func+0x2c>
8000c1a8:	c0 48       	rjmp	8000c1b0 <__assert_func+0x10>
8000c1aa:	fe ca 8d 26 	sub	r10,pc,-29402
8000c1ae:	14 98       	mov	r8,r10
8000c1b0:	1a da       	st.w	--sp,r10
8000c1b2:	1a d8       	st.w	--sp,r8
8000c1b4:	e0 68 02 2c 	mov	r8,556
8000c1b8:	1a db       	st.w	--sp,r11
8000c1ba:	1a dc       	st.w	--sp,r12
8000c1bc:	1a d9       	st.w	--sp,r9
8000c1be:	70 08       	ld.w	r8,r8[0x0]
8000c1c0:	48 4b       	lddpc	r11,8000c1d0 <__assert_func+0x30>
8000c1c2:	70 2c       	ld.w	r12,r8[0x8]
8000c1c4:	c0 8c       	rcall	8000c1d4 <fiprintf>
8000c1c6:	e0 a0 22 3f 	rcall	80010644 <abort>
8000c1ca:	d7 03       	nop
8000c1cc:	80 01       	ld.sh	r1,r0[0x0]
8000c1ce:	67 48       	ld.w	r8,r3[0x50]
8000c1d0:	80 01       	ld.sh	r1,r0[0x0]
8000c1d2:	67 58       	ld.w	r8,r3[0x54]

8000c1d4 <fiprintf>:
8000c1d4:	d4 01       	pushm	lr
8000c1d6:	e0 68 02 2c 	mov	r8,556
8000c1da:	16 9a       	mov	r10,r11
8000c1dc:	fa c9 ff fc 	sub	r9,sp,-4
8000c1e0:	18 9b       	mov	r11,r12
8000c1e2:	70 0c       	ld.w	r12,r8[0x0]
8000c1e4:	e0 a0 05 40 	rcall	8000cc64 <_vfiprintf_r>
8000c1e8:	d8 02       	popm	pc
8000c1ea:	d7 03       	nop

8000c1ec <free>:
8000c1ec:	d4 01       	pushm	lr
8000c1ee:	e0 68 02 2c 	mov	r8,556
8000c1f2:	18 9b       	mov	r11,r12
8000c1f4:	70 0c       	ld.w	r12,r8[0x0]
8000c1f6:	e0 a0 2a 25 	rcall	80011640 <_free_r>
8000c1fa:	d8 02       	popm	pc

8000c1fc <malloc>:
8000c1fc:	d4 01       	pushm	lr
8000c1fe:	e0 68 02 2c 	mov	r8,556
8000c202:	18 9b       	mov	r11,r12
8000c204:	70 0c       	ld.w	r12,r8[0x0]
8000c206:	c0 3c       	rcall	8000c20c <_malloc_r>
8000c208:	d8 02       	popm	pc
8000c20a:	d7 03       	nop

8000c20c <_malloc_r>:
8000c20c:	d4 31       	pushm	r0-r7,lr
8000c20e:	f6 c8 ff f5 	sub	r8,r11,-11
8000c212:	18 95       	mov	r5,r12
8000c214:	10 97       	mov	r7,r8
8000c216:	e0 17 ff f8 	andl	r7,0xfff8
8000c21a:	59 68       	cp.w	r8,22
8000c21c:	f9 b7 08 10 	movls	r7,16
8000c220:	16 37       	cp.w	r7,r11
8000c222:	5f 38       	srlo	r8
8000c224:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
8000c228:	c0 50       	breq	8000c232 <_malloc_r+0x26>
8000c22a:	30 c8       	mov	r8,12
8000c22c:	99 38       	st.w	r12[0xc],r8
8000c22e:	e0 8f 01 f5 	bral	8000c618 <_malloc_r+0x40c>
8000c232:	e0 a0 02 ae 	rcall	8000c78e <__malloc_lock>
8000c236:	e0 47 01 f7 	cp.w	r7,503
8000c23a:	e0 8b 00 1d 	brhi	8000c274 <_malloc_r+0x68>
8000c23e:	ee 03 16 03 	lsr	r3,r7,0x3
8000c242:	e0 68 02 30 	mov	r8,560
8000c246:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000c24a:	70 36       	ld.w	r6,r8[0xc]
8000c24c:	10 36       	cp.w	r6,r8
8000c24e:	c0 61       	brne	8000c25a <_malloc_r+0x4e>
8000c250:	ec c8 ff f8 	sub	r8,r6,-8
8000c254:	70 36       	ld.w	r6,r8[0xc]
8000c256:	10 36       	cp.w	r6,r8
8000c258:	c0 c0       	breq	8000c270 <_malloc_r+0x64>
8000c25a:	6c 18       	ld.w	r8,r6[0x4]
8000c25c:	e0 18 ff fc 	andl	r8,0xfffc
8000c260:	6c 3a       	ld.w	r10,r6[0xc]
8000c262:	ec 08 00 09 	add	r9,r6,r8
8000c266:	0a 9c       	mov	r12,r5
8000c268:	6c 28       	ld.w	r8,r6[0x8]
8000c26a:	95 28       	st.w	r10[0x8],r8
8000c26c:	91 3a       	st.w	r8[0xc],r10
8000c26e:	c4 78       	rjmp	8000c2fc <_malloc_r+0xf0>
8000c270:	2f e3       	sub	r3,-2
8000c272:	c4 d8       	rjmp	8000c30c <_malloc_r+0x100>
8000c274:	ee 03 16 09 	lsr	r3,r7,0x9
8000c278:	c0 41       	brne	8000c280 <_malloc_r+0x74>
8000c27a:	ee 03 16 03 	lsr	r3,r7,0x3
8000c27e:	c2 68       	rjmp	8000c2ca <_malloc_r+0xbe>
8000c280:	58 43       	cp.w	r3,4
8000c282:	e0 8b 00 06 	brhi	8000c28e <_malloc_r+0x82>
8000c286:	ee 03 16 06 	lsr	r3,r7,0x6
8000c28a:	2c 83       	sub	r3,-56
8000c28c:	c1 f8       	rjmp	8000c2ca <_malloc_r+0xbe>
8000c28e:	59 43       	cp.w	r3,20
8000c290:	e0 8b 00 04 	brhi	8000c298 <_malloc_r+0x8c>
8000c294:	2a 53       	sub	r3,-91
8000c296:	c1 a8       	rjmp	8000c2ca <_malloc_r+0xbe>
8000c298:	e0 43 00 54 	cp.w	r3,84
8000c29c:	e0 8b 00 06 	brhi	8000c2a8 <_malloc_r+0x9c>
8000c2a0:	ee 03 16 0c 	lsr	r3,r7,0xc
8000c2a4:	29 23       	sub	r3,-110
8000c2a6:	c1 28       	rjmp	8000c2ca <_malloc_r+0xbe>
8000c2a8:	e0 43 01 54 	cp.w	r3,340
8000c2ac:	e0 8b 00 06 	brhi	8000c2b8 <_malloc_r+0xac>
8000c2b0:	ee 03 16 0f 	lsr	r3,r7,0xf
8000c2b4:	28 93       	sub	r3,-119
8000c2b6:	c0 a8       	rjmp	8000c2ca <_malloc_r+0xbe>
8000c2b8:	e0 43 05 54 	cp.w	r3,1364
8000c2bc:	e0 88 00 04 	brls	8000c2c4 <_malloc_r+0xb8>
8000c2c0:	37 e3       	mov	r3,126
8000c2c2:	c0 48       	rjmp	8000c2ca <_malloc_r+0xbe>
8000c2c4:	ee 03 16 12 	lsr	r3,r7,0x12
8000c2c8:	28 43       	sub	r3,-124
8000c2ca:	e0 6a 02 30 	mov	r10,560
8000c2ce:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000c2d2:	74 36       	ld.w	r6,r10[0xc]
8000c2d4:	c1 98       	rjmp	8000c306 <_malloc_r+0xfa>
8000c2d6:	6c 19       	ld.w	r9,r6[0x4]
8000c2d8:	e0 19 ff fc 	andl	r9,0xfffc
8000c2dc:	f2 07 01 0b 	sub	r11,r9,r7
8000c2e0:	58 fb       	cp.w	r11,15
8000c2e2:	e0 8a 00 04 	brle	8000c2ea <_malloc_r+0xde>
8000c2e6:	20 13       	sub	r3,1
8000c2e8:	c1 18       	rjmp	8000c30a <_malloc_r+0xfe>
8000c2ea:	6c 38       	ld.w	r8,r6[0xc]
8000c2ec:	58 0b       	cp.w	r11,0
8000c2ee:	c0 b5       	brlt	8000c304 <_malloc_r+0xf8>
8000c2f0:	6c 2a       	ld.w	r10,r6[0x8]
8000c2f2:	ec 09 00 09 	add	r9,r6,r9
8000c2f6:	0a 9c       	mov	r12,r5
8000c2f8:	91 2a       	st.w	r8[0x8],r10
8000c2fa:	95 38       	st.w	r10[0xc],r8
8000c2fc:	72 18       	ld.w	r8,r9[0x4]
8000c2fe:	a1 a8       	sbr	r8,0x0
8000c300:	93 18       	st.w	r9[0x4],r8
8000c302:	cb c8       	rjmp	8000c47a <_malloc_r+0x26e>
8000c304:	10 96       	mov	r6,r8
8000c306:	14 36       	cp.w	r6,r10
8000c308:	ce 71       	brne	8000c2d6 <_malloc_r+0xca>
8000c30a:	2f f3       	sub	r3,-1
8000c30c:	e0 6a 02 30 	mov	r10,560
8000c310:	f4 cc ff f8 	sub	r12,r10,-8
8000c314:	78 26       	ld.w	r6,r12[0x8]
8000c316:	18 36       	cp.w	r6,r12
8000c318:	c6 c0       	breq	8000c3f0 <_malloc_r+0x1e4>
8000c31a:	6c 19       	ld.w	r9,r6[0x4]
8000c31c:	e0 19 ff fc 	andl	r9,0xfffc
8000c320:	f2 07 01 08 	sub	r8,r9,r7
8000c324:	58 f8       	cp.w	r8,15
8000c326:	e0 89 00 8f 	brgt	8000c444 <_malloc_r+0x238>
8000c32a:	99 3c       	st.w	r12[0xc],r12
8000c32c:	99 2c       	st.w	r12[0x8],r12
8000c32e:	58 08       	cp.w	r8,0
8000c330:	c0 55       	brlt	8000c33a <_malloc_r+0x12e>
8000c332:	ec 09 00 09 	add	r9,r6,r9
8000c336:	0a 9c       	mov	r12,r5
8000c338:	ce 2b       	rjmp	8000c2fc <_malloc_r+0xf0>
8000c33a:	e0 49 01 ff 	cp.w	r9,511
8000c33e:	e0 8b 00 13 	brhi	8000c364 <_malloc_r+0x158>
8000c342:	a3 99       	lsr	r9,0x3
8000c344:	f4 09 00 38 	add	r8,r10,r9<<0x3
8000c348:	70 2b       	ld.w	r11,r8[0x8]
8000c34a:	8d 38       	st.w	r6[0xc],r8
8000c34c:	8d 2b       	st.w	r6[0x8],r11
8000c34e:	97 36       	st.w	r11[0xc],r6
8000c350:	91 26       	st.w	r8[0x8],r6
8000c352:	a3 49       	asr	r9,0x2
8000c354:	74 18       	ld.w	r8,r10[0x4]
8000c356:	30 1b       	mov	r11,1
8000c358:	f6 09 09 49 	lsl	r9,r11,r9
8000c35c:	f1 e9 10 09 	or	r9,r8,r9
8000c360:	95 19       	st.w	r10[0x4],r9
8000c362:	c4 78       	rjmp	8000c3f0 <_malloc_r+0x1e4>
8000c364:	f2 0a 16 09 	lsr	r10,r9,0x9
8000c368:	58 4a       	cp.w	r10,4
8000c36a:	e0 8b 00 07 	brhi	8000c378 <_malloc_r+0x16c>
8000c36e:	f2 0a 16 06 	lsr	r10,r9,0x6
8000c372:	2c 8a       	sub	r10,-56
8000c374:	c2 08       	rjmp	8000c3b4 <_malloc_r+0x1a8>
8000c376:	d7 03       	nop
8000c378:	59 4a       	cp.w	r10,20
8000c37a:	e0 8b 00 04 	brhi	8000c382 <_malloc_r+0x176>
8000c37e:	2a 5a       	sub	r10,-91
8000c380:	c1 a8       	rjmp	8000c3b4 <_malloc_r+0x1a8>
8000c382:	e0 4a 00 54 	cp.w	r10,84
8000c386:	e0 8b 00 06 	brhi	8000c392 <_malloc_r+0x186>
8000c38a:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000c38e:	29 2a       	sub	r10,-110
8000c390:	c1 28       	rjmp	8000c3b4 <_malloc_r+0x1a8>
8000c392:	e0 4a 01 54 	cp.w	r10,340
8000c396:	e0 8b 00 06 	brhi	8000c3a2 <_malloc_r+0x196>
8000c39a:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000c39e:	28 9a       	sub	r10,-119
8000c3a0:	c0 a8       	rjmp	8000c3b4 <_malloc_r+0x1a8>
8000c3a2:	e0 4a 05 54 	cp.w	r10,1364
8000c3a6:	e0 88 00 04 	brls	8000c3ae <_malloc_r+0x1a2>
8000c3aa:	37 ea       	mov	r10,126
8000c3ac:	c0 48       	rjmp	8000c3b4 <_malloc_r+0x1a8>
8000c3ae:	f2 0a 16 12 	lsr	r10,r9,0x12
8000c3b2:	28 4a       	sub	r10,-124
8000c3b4:	e0 6b 02 30 	mov	r11,560
8000c3b8:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000c3bc:	68 28       	ld.w	r8,r4[0x8]
8000c3be:	08 38       	cp.w	r8,r4
8000c3c0:	c0 e1       	brne	8000c3dc <_malloc_r+0x1d0>
8000c3c2:	76 19       	ld.w	r9,r11[0x4]
8000c3c4:	a3 4a       	asr	r10,0x2
8000c3c6:	30 1e       	mov	lr,1
8000c3c8:	fc 0a 09 4a 	lsl	r10,lr,r10
8000c3cc:	f3 ea 10 0a 	or	r10,r9,r10
8000c3d0:	10 99       	mov	r9,r8
8000c3d2:	97 1a       	st.w	r11[0x4],r10
8000c3d4:	c0 a8       	rjmp	8000c3e8 <_malloc_r+0x1dc>
8000c3d6:	70 28       	ld.w	r8,r8[0x8]
8000c3d8:	08 38       	cp.w	r8,r4
8000c3da:	c0 60       	breq	8000c3e6 <_malloc_r+0x1da>
8000c3dc:	70 1a       	ld.w	r10,r8[0x4]
8000c3de:	e0 1a ff fc 	andl	r10,0xfffc
8000c3e2:	14 39       	cp.w	r9,r10
8000c3e4:	cf 93       	brcs	8000c3d6 <_malloc_r+0x1ca>
8000c3e6:	70 39       	ld.w	r9,r8[0xc]
8000c3e8:	8d 39       	st.w	r6[0xc],r9
8000c3ea:	8d 28       	st.w	r6[0x8],r8
8000c3ec:	91 36       	st.w	r8[0xc],r6
8000c3ee:	93 26       	st.w	r9[0x8],r6
8000c3f0:	e6 08 14 02 	asr	r8,r3,0x2
8000c3f4:	30 1b       	mov	r11,1
8000c3f6:	e0 64 02 30 	mov	r4,560
8000c3fa:	f6 08 09 4b 	lsl	r11,r11,r8
8000c3fe:	68 18       	ld.w	r8,r4[0x4]
8000c400:	10 3b       	cp.w	r11,r8
8000c402:	e0 8b 00 69 	brhi	8000c4d4 <_malloc_r+0x2c8>
8000c406:	f7 e8 00 09 	and	r9,r11,r8
8000c40a:	c0 b1       	brne	8000c420 <_malloc_r+0x214>
8000c40c:	e0 13 ff fc 	andl	r3,0xfffc
8000c410:	a1 7b       	lsl	r11,0x1
8000c412:	2f c3       	sub	r3,-4
8000c414:	c0 38       	rjmp	8000c41a <_malloc_r+0x20e>
8000c416:	2f c3       	sub	r3,-4
8000c418:	a1 7b       	lsl	r11,0x1
8000c41a:	f7 e8 00 09 	and	r9,r11,r8
8000c41e:	cf c0       	breq	8000c416 <_malloc_r+0x20a>
8000c420:	e8 03 00 3e 	add	lr,r4,r3<<0x3
8000c424:	06 92       	mov	r2,r3
8000c426:	1c 91       	mov	r1,lr
8000c428:	62 36       	ld.w	r6,r1[0xc]
8000c42a:	c2 d8       	rjmp	8000c484 <_malloc_r+0x278>
8000c42c:	6c 1a       	ld.w	r10,r6[0x4]
8000c42e:	e0 1a ff fc 	andl	r10,0xfffc
8000c432:	f4 07 01 08 	sub	r8,r10,r7
8000c436:	58 f8       	cp.w	r8,15
8000c438:	e0 8a 00 15 	brle	8000c462 <_malloc_r+0x256>
8000c43c:	6c 3a       	ld.w	r10,r6[0xc]
8000c43e:	6c 29       	ld.w	r9,r6[0x8]
8000c440:	95 29       	st.w	r10[0x8],r9
8000c442:	93 3a       	st.w	r9[0xc],r10
8000c444:	0e 99       	mov	r9,r7
8000c446:	ec 07 00 07 	add	r7,r6,r7
8000c44a:	a1 a9       	sbr	r9,0x0
8000c44c:	99 37       	st.w	r12[0xc],r7
8000c44e:	99 27       	st.w	r12[0x8],r7
8000c450:	8d 19       	st.w	r6[0x4],r9
8000c452:	ee 08 09 08 	st.w	r7[r8],r8
8000c456:	8f 2c       	st.w	r7[0x8],r12
8000c458:	8f 3c       	st.w	r7[0xc],r12
8000c45a:	a1 a8       	sbr	r8,0x0
8000c45c:	0a 9c       	mov	r12,r5
8000c45e:	8f 18       	st.w	r7[0x4],r8
8000c460:	c0 d8       	rjmp	8000c47a <_malloc_r+0x26e>
8000c462:	6c 39       	ld.w	r9,r6[0xc]
8000c464:	58 08       	cp.w	r8,0
8000c466:	c0 e5       	brlt	8000c482 <_malloc_r+0x276>
8000c468:	ec 0a 00 0a 	add	r10,r6,r10
8000c46c:	74 18       	ld.w	r8,r10[0x4]
8000c46e:	a1 a8       	sbr	r8,0x0
8000c470:	0a 9c       	mov	r12,r5
8000c472:	95 18       	st.w	r10[0x4],r8
8000c474:	6c 28       	ld.w	r8,r6[0x8]
8000c476:	93 28       	st.w	r9[0x8],r8
8000c478:	91 39       	st.w	r8[0xc],r9
8000c47a:	c8 bd       	rcall	8000c790 <__malloc_unlock>
8000c47c:	ec cc ff f8 	sub	r12,r6,-8
8000c480:	d8 32       	popm	r0-r7,pc
8000c482:	12 96       	mov	r6,r9
8000c484:	02 36       	cp.w	r6,r1
8000c486:	cd 31       	brne	8000c42c <_malloc_r+0x220>
8000c488:	2f f2       	sub	r2,-1
8000c48a:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
8000c48e:	c0 30       	breq	8000c494 <_malloc_r+0x288>
8000c490:	2f 81       	sub	r1,-8
8000c492:	cc bb       	rjmp	8000c428 <_malloc_r+0x21c>
8000c494:	1c 98       	mov	r8,lr
8000c496:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
8000c49a:	c0 81       	brne	8000c4aa <_malloc_r+0x29e>
8000c49c:	68 19       	ld.w	r9,r4[0x4]
8000c49e:	f6 08 11 ff 	rsub	r8,r11,-1
8000c4a2:	f3 e8 00 08 	and	r8,r9,r8
8000c4a6:	89 18       	st.w	r4[0x4],r8
8000c4a8:	c0 78       	rjmp	8000c4b6 <_malloc_r+0x2aa>
8000c4aa:	f0 c9 00 08 	sub	r9,r8,8
8000c4ae:	20 13       	sub	r3,1
8000c4b0:	70 08       	ld.w	r8,r8[0x0]
8000c4b2:	12 38       	cp.w	r8,r9
8000c4b4:	cf 10       	breq	8000c496 <_malloc_r+0x28a>
8000c4b6:	a1 7b       	lsl	r11,0x1
8000c4b8:	68 18       	ld.w	r8,r4[0x4]
8000c4ba:	10 3b       	cp.w	r11,r8
8000c4bc:	e0 8b 00 0c 	brhi	8000c4d4 <_malloc_r+0x2c8>
8000c4c0:	58 0b       	cp.w	r11,0
8000c4c2:	c0 90       	breq	8000c4d4 <_malloc_r+0x2c8>
8000c4c4:	04 93       	mov	r3,r2
8000c4c6:	c0 38       	rjmp	8000c4cc <_malloc_r+0x2c0>
8000c4c8:	2f c3       	sub	r3,-4
8000c4ca:	a1 7b       	lsl	r11,0x1
8000c4cc:	f7 e8 00 09 	and	r9,r11,r8
8000c4d0:	ca 81       	brne	8000c420 <_malloc_r+0x214>
8000c4d2:	cf bb       	rjmp	8000c4c8 <_malloc_r+0x2bc>
8000c4d4:	68 23       	ld.w	r3,r4[0x8]
8000c4d6:	66 12       	ld.w	r2,r3[0x4]
8000c4d8:	e0 12 ff fc 	andl	r2,0xfffc
8000c4dc:	0e 32       	cp.w	r2,r7
8000c4de:	5f 39       	srlo	r9
8000c4e0:	e4 07 01 08 	sub	r8,r2,r7
8000c4e4:	58 f8       	cp.w	r8,15
8000c4e6:	5f aa       	srle	r10
8000c4e8:	f5 e9 10 09 	or	r9,r10,r9
8000c4ec:	e0 80 00 98 	breq	8000c61c <_malloc_r+0x410>
8000c4f0:	e0 68 07 78 	mov	r8,1912
8000c4f4:	70 01       	ld.w	r1,r8[0x0]
8000c4f6:	e0 68 06 3c 	mov	r8,1596
8000c4fa:	2f 01       	sub	r1,-16
8000c4fc:	70 08       	ld.w	r8,r8[0x0]
8000c4fe:	0e 01       	add	r1,r7
8000c500:	5b f8       	cp.w	r8,-1
8000c502:	c0 40       	breq	8000c50a <_malloc_r+0x2fe>
8000c504:	28 11       	sub	r1,-127
8000c506:	e0 11 ff 80 	andl	r1,0xff80
8000c50a:	02 9b       	mov	r11,r1
8000c50c:	0a 9c       	mov	r12,r5
8000c50e:	c5 9d       	rcall	8000c7c0 <_sbrk_r>
8000c510:	18 96       	mov	r6,r12
8000c512:	5b fc       	cp.w	r12,-1
8000c514:	c7 40       	breq	8000c5fc <_malloc_r+0x3f0>
8000c516:	e6 02 00 08 	add	r8,r3,r2
8000c51a:	10 3c       	cp.w	r12,r8
8000c51c:	c0 32       	brcc	8000c522 <_malloc_r+0x316>
8000c51e:	08 33       	cp.w	r3,r4
8000c520:	c6 e1       	brne	8000c5fc <_malloc_r+0x3f0>
8000c522:	e0 6a 07 7c 	mov	r10,1916
8000c526:	74 09       	ld.w	r9,r10[0x0]
8000c528:	e2 09 00 09 	add	r9,r1,r9
8000c52c:	95 09       	st.w	r10[0x0],r9
8000c52e:	10 36       	cp.w	r6,r8
8000c530:	c0 a1       	brne	8000c544 <_malloc_r+0x338>
8000c532:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000c536:	c0 71       	brne	8000c544 <_malloc_r+0x338>
8000c538:	e2 02 00 02 	add	r2,r1,r2
8000c53c:	68 28       	ld.w	r8,r4[0x8]
8000c53e:	a1 a2       	sbr	r2,0x0
8000c540:	91 12       	st.w	r8[0x4],r2
8000c542:	c4 e8       	rjmp	8000c5de <_malloc_r+0x3d2>
8000c544:	e0 6a 06 3c 	mov	r10,1596
8000c548:	74 0b       	ld.w	r11,r10[0x0]
8000c54a:	5b fb       	cp.w	r11,-1
8000c54c:	c0 31       	brne	8000c552 <_malloc_r+0x346>
8000c54e:	95 06       	st.w	r10[0x0],r6
8000c550:	c0 78       	rjmp	8000c55e <_malloc_r+0x352>
8000c552:	ec 09 00 09 	add	r9,r6,r9
8000c556:	e0 6a 07 7c 	mov	r10,1916
8000c55a:	10 19       	sub	r9,r8
8000c55c:	95 09       	st.w	r10[0x0],r9
8000c55e:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000c562:	f0 09 11 08 	rsub	r9,r8,8
8000c566:	58 08       	cp.w	r8,0
8000c568:	f2 08 17 10 	movne	r8,r9
8000c56c:	ed d8 e1 06 	addne	r6,r6,r8
8000c570:	28 08       	sub	r8,-128
8000c572:	ec 01 00 01 	add	r1,r6,r1
8000c576:	0a 9c       	mov	r12,r5
8000c578:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000c57c:	f0 01 01 01 	sub	r1,r8,r1
8000c580:	02 9b       	mov	r11,r1
8000c582:	c1 fd       	rcall	8000c7c0 <_sbrk_r>
8000c584:	e0 68 07 7c 	mov	r8,1916
8000c588:	5b fc       	cp.w	r12,-1
8000c58a:	ec 0c 17 00 	moveq	r12,r6
8000c58e:	f9 b1 00 00 	moveq	r1,0
8000c592:	70 09       	ld.w	r9,r8[0x0]
8000c594:	0c 1c       	sub	r12,r6
8000c596:	89 26       	st.w	r4[0x8],r6
8000c598:	02 0c       	add	r12,r1
8000c59a:	12 01       	add	r1,r9
8000c59c:	a1 ac       	sbr	r12,0x0
8000c59e:	91 01       	st.w	r8[0x0],r1
8000c5a0:	8d 1c       	st.w	r6[0x4],r12
8000c5a2:	08 33       	cp.w	r3,r4
8000c5a4:	c1 d0       	breq	8000c5de <_malloc_r+0x3d2>
8000c5a6:	58 f2       	cp.w	r2,15
8000c5a8:	e0 8b 00 05 	brhi	8000c5b2 <_malloc_r+0x3a6>
8000c5ac:	30 18       	mov	r8,1
8000c5ae:	8d 18       	st.w	r6[0x4],r8
8000c5b0:	c2 68       	rjmp	8000c5fc <_malloc_r+0x3f0>
8000c5b2:	30 59       	mov	r9,5
8000c5b4:	20 c2       	sub	r2,12
8000c5b6:	e0 12 ff f8 	andl	r2,0xfff8
8000c5ba:	e6 02 00 08 	add	r8,r3,r2
8000c5be:	91 29       	st.w	r8[0x8],r9
8000c5c0:	91 19       	st.w	r8[0x4],r9
8000c5c2:	66 18       	ld.w	r8,r3[0x4]
8000c5c4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000c5c8:	e5 e8 10 08 	or	r8,r2,r8
8000c5cc:	87 18       	st.w	r3[0x4],r8
8000c5ce:	58 f2       	cp.w	r2,15
8000c5d0:	e0 88 00 07 	brls	8000c5de <_malloc_r+0x3d2>
8000c5d4:	e6 cb ff f8 	sub	r11,r3,-8
8000c5d8:	0a 9c       	mov	r12,r5
8000c5da:	e0 a0 28 33 	rcall	80011640 <_free_r>
8000c5de:	e0 69 07 74 	mov	r9,1908
8000c5e2:	72 0a       	ld.w	r10,r9[0x0]
8000c5e4:	e0 68 07 7c 	mov	r8,1916
8000c5e8:	70 08       	ld.w	r8,r8[0x0]
8000c5ea:	14 38       	cp.w	r8,r10
8000c5ec:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000c5f0:	e0 69 07 70 	mov	r9,1904
8000c5f4:	72 0a       	ld.w	r10,r9[0x0]
8000c5f6:	14 38       	cp.w	r8,r10
8000c5f8:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000c5fc:	68 28       	ld.w	r8,r4[0x8]
8000c5fe:	70 18       	ld.w	r8,r8[0x4]
8000c600:	e0 18 ff fc 	andl	r8,0xfffc
8000c604:	0e 38       	cp.w	r8,r7
8000c606:	5f 39       	srlo	r9
8000c608:	0e 18       	sub	r8,r7
8000c60a:	58 f8       	cp.w	r8,15
8000c60c:	5f aa       	srle	r10
8000c60e:	f5 e9 10 09 	or	r9,r10,r9
8000c612:	c0 50       	breq	8000c61c <_malloc_r+0x410>
8000c614:	0a 9c       	mov	r12,r5
8000c616:	cb dc       	rcall	8000c790 <__malloc_unlock>
8000c618:	d8 3a       	popm	r0-r7,pc,r12=0
8000c61a:	d7 03       	nop
8000c61c:	68 26       	ld.w	r6,r4[0x8]
8000c61e:	a1 a8       	sbr	r8,0x0
8000c620:	0e 99       	mov	r9,r7
8000c622:	a1 a9       	sbr	r9,0x0
8000c624:	8d 19       	st.w	r6[0x4],r9
8000c626:	ec 07 00 07 	add	r7,r6,r7
8000c62a:	0a 9c       	mov	r12,r5
8000c62c:	89 27       	st.w	r4[0x8],r7
8000c62e:	8f 18       	st.w	r7[0x4],r8
8000c630:	cb 0c       	rcall	8000c790 <__malloc_unlock>
8000c632:	ec cc ff f8 	sub	r12,r6,-8
8000c636:	d8 32       	popm	r0-r7,pc

8000c638 <memcpy>:
8000c638:	58 8a       	cp.w	r10,8
8000c63a:	c2 f5       	brlt	8000c698 <memcpy+0x60>
8000c63c:	f9 eb 10 09 	or	r9,r12,r11
8000c640:	e2 19 00 03 	andl	r9,0x3,COH
8000c644:	e0 81 00 97 	brne	8000c772 <memcpy+0x13a>
8000c648:	e0 4a 00 20 	cp.w	r10,32
8000c64c:	c3 b4       	brge	8000c6c2 <memcpy+0x8a>
8000c64e:	f4 08 14 02 	asr	r8,r10,0x2
8000c652:	f0 09 11 08 	rsub	r9,r8,8
8000c656:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000c65a:	76 69       	ld.w	r9,r11[0x18]
8000c65c:	99 69       	st.w	r12[0x18],r9
8000c65e:	76 59       	ld.w	r9,r11[0x14]
8000c660:	99 59       	st.w	r12[0x14],r9
8000c662:	76 49       	ld.w	r9,r11[0x10]
8000c664:	99 49       	st.w	r12[0x10],r9
8000c666:	76 39       	ld.w	r9,r11[0xc]
8000c668:	99 39       	st.w	r12[0xc],r9
8000c66a:	76 29       	ld.w	r9,r11[0x8]
8000c66c:	99 29       	st.w	r12[0x8],r9
8000c66e:	76 19       	ld.w	r9,r11[0x4]
8000c670:	99 19       	st.w	r12[0x4],r9
8000c672:	76 09       	ld.w	r9,r11[0x0]
8000c674:	99 09       	st.w	r12[0x0],r9
8000c676:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000c67a:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000c67e:	e0 1a 00 03 	andl	r10,0x3
8000c682:	f4 0a 11 04 	rsub	r10,r10,4
8000c686:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000c68a:	17 a9       	ld.ub	r9,r11[0x2]
8000c68c:	b0 a9       	st.b	r8[0x2],r9
8000c68e:	17 99       	ld.ub	r9,r11[0x1]
8000c690:	b0 99       	st.b	r8[0x1],r9
8000c692:	17 89       	ld.ub	r9,r11[0x0]
8000c694:	b0 89       	st.b	r8[0x0],r9
8000c696:	5e fc       	retal	r12
8000c698:	f4 0a 11 09 	rsub	r10,r10,9
8000c69c:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000c6a0:	17 f9       	ld.ub	r9,r11[0x7]
8000c6a2:	b8 f9       	st.b	r12[0x7],r9
8000c6a4:	17 e9       	ld.ub	r9,r11[0x6]
8000c6a6:	b8 e9       	st.b	r12[0x6],r9
8000c6a8:	17 d9       	ld.ub	r9,r11[0x5]
8000c6aa:	b8 d9       	st.b	r12[0x5],r9
8000c6ac:	17 c9       	ld.ub	r9,r11[0x4]
8000c6ae:	b8 c9       	st.b	r12[0x4],r9
8000c6b0:	17 b9       	ld.ub	r9,r11[0x3]
8000c6b2:	b8 b9       	st.b	r12[0x3],r9
8000c6b4:	17 a9       	ld.ub	r9,r11[0x2]
8000c6b6:	b8 a9       	st.b	r12[0x2],r9
8000c6b8:	17 99       	ld.ub	r9,r11[0x1]
8000c6ba:	b8 99       	st.b	r12[0x1],r9
8000c6bc:	17 89       	ld.ub	r9,r11[0x0]
8000c6be:	b8 89       	st.b	r12[0x0],r9
8000c6c0:	5e fc       	retal	r12
8000c6c2:	eb cd 40 c0 	pushm	r6-r7,lr
8000c6c6:	18 99       	mov	r9,r12
8000c6c8:	22 0a       	sub	r10,32
8000c6ca:	b7 07       	ld.d	r6,r11++
8000c6cc:	b3 26       	st.d	r9++,r6
8000c6ce:	b7 07       	ld.d	r6,r11++
8000c6d0:	b3 26       	st.d	r9++,r6
8000c6d2:	b7 07       	ld.d	r6,r11++
8000c6d4:	b3 26       	st.d	r9++,r6
8000c6d6:	b7 07       	ld.d	r6,r11++
8000c6d8:	b3 26       	st.d	r9++,r6
8000c6da:	22 0a       	sub	r10,32
8000c6dc:	cf 74       	brge	8000c6ca <memcpy+0x92>
8000c6de:	2f 0a       	sub	r10,-16
8000c6e0:	c0 65       	brlt	8000c6ec <memcpy+0xb4>
8000c6e2:	b7 07       	ld.d	r6,r11++
8000c6e4:	b3 26       	st.d	r9++,r6
8000c6e6:	b7 07       	ld.d	r6,r11++
8000c6e8:	b3 26       	st.d	r9++,r6
8000c6ea:	21 0a       	sub	r10,16
8000c6ec:	5c 3a       	neg	r10
8000c6ee:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000c6f2:	d7 03       	nop
8000c6f4:	d7 03       	nop
8000c6f6:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000c6fa:	f3 66 00 0e 	st.b	r9[14],r6
8000c6fe:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000c702:	f3 66 00 0d 	st.b	r9[13],r6
8000c706:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000c70a:	f3 66 00 0c 	st.b	r9[12],r6
8000c70e:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000c712:	f3 66 00 0b 	st.b	r9[11],r6
8000c716:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000c71a:	f3 66 00 0a 	st.b	r9[10],r6
8000c71e:	f7 36 00 09 	ld.ub	r6,r11[9]
8000c722:	f3 66 00 09 	st.b	r9[9],r6
8000c726:	f7 36 00 08 	ld.ub	r6,r11[8]
8000c72a:	f3 66 00 08 	st.b	r9[8],r6
8000c72e:	f7 36 00 07 	ld.ub	r6,r11[7]
8000c732:	f3 66 00 07 	st.b	r9[7],r6
8000c736:	f7 36 00 06 	ld.ub	r6,r11[6]
8000c73a:	f3 66 00 06 	st.b	r9[6],r6
8000c73e:	f7 36 00 05 	ld.ub	r6,r11[5]
8000c742:	f3 66 00 05 	st.b	r9[5],r6
8000c746:	f7 36 00 04 	ld.ub	r6,r11[4]
8000c74a:	f3 66 00 04 	st.b	r9[4],r6
8000c74e:	f7 36 00 03 	ld.ub	r6,r11[3]
8000c752:	f3 66 00 03 	st.b	r9[3],r6
8000c756:	f7 36 00 02 	ld.ub	r6,r11[2]
8000c75a:	f3 66 00 02 	st.b	r9[2],r6
8000c75e:	f7 36 00 01 	ld.ub	r6,r11[1]
8000c762:	f3 66 00 01 	st.b	r9[1],r6
8000c766:	f7 36 00 00 	ld.ub	r6,r11[0]
8000c76a:	f3 66 00 00 	st.b	r9[0],r6
8000c76e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000c772:	20 1a       	sub	r10,1
8000c774:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8000c778:	f8 0a 0b 09 	st.b	r12[r10],r9
8000c77c:	cf b1       	brne	8000c772 <memcpy+0x13a>
8000c77e:	5e fc       	retal	r12

8000c780 <memset>:
8000c780:	18 98       	mov	r8,r12
8000c782:	c0 38       	rjmp	8000c788 <memset+0x8>
8000c784:	10 cb       	st.b	r8++,r11
8000c786:	20 1a       	sub	r10,1
8000c788:	58 0a       	cp.w	r10,0
8000c78a:	cf d1       	brne	8000c784 <memset+0x4>
8000c78c:	5e fc       	retal	r12

8000c78e <__malloc_lock>:
8000c78e:	5e fc       	retal	r12

8000c790 <__malloc_unlock>:
8000c790:	5e fc       	retal	r12
8000c792:	d7 03       	nop

8000c794 <printf>:
8000c794:	d4 21       	pushm	r4-r7,lr
8000c796:	e0 68 02 2c 	mov	r8,556
8000c79a:	fa c4 ff ec 	sub	r4,sp,-20
8000c79e:	18 96       	mov	r6,r12
8000c7a0:	70 07       	ld.w	r7,r8[0x0]
8000c7a2:	58 07       	cp.w	r7,0
8000c7a4:	c0 70       	breq	8000c7b2 <printf+0x1e>
8000c7a6:	6e 68       	ld.w	r8,r7[0x18]
8000c7a8:	58 08       	cp.w	r8,0
8000c7aa:	c0 41       	brne	8000c7b2 <printf+0x1e>
8000c7ac:	0e 9c       	mov	r12,r7
8000c7ae:	e0 a0 26 af 	rcall	8001150c <__sinit>
8000c7b2:	08 99       	mov	r9,r4
8000c7b4:	0c 9a       	mov	r10,r6
8000c7b6:	0e 9c       	mov	r12,r7
8000c7b8:	6e 1b       	ld.w	r11,r7[0x4]
8000c7ba:	e0 a0 0f 47 	rcall	8000e648 <_vfprintf_r>
8000c7be:	d8 22       	popm	r4-r7,pc

8000c7c0 <_sbrk_r>:
8000c7c0:	d4 21       	pushm	r4-r7,lr
8000c7c2:	30 08       	mov	r8,0
8000c7c4:	18 97       	mov	r7,r12
8000c7c6:	e0 66 0e fc 	mov	r6,3836
8000c7ca:	16 9c       	mov	r12,r11
8000c7cc:	8d 08       	st.w	r6[0x0],r8
8000c7ce:	c9 1c       	rcall	8000c8f0 <_sbrk>
8000c7d0:	5b fc       	cp.w	r12,-1
8000c7d2:	c0 51       	brne	8000c7dc <_sbrk_r+0x1c>
8000c7d4:	6c 08       	ld.w	r8,r6[0x0]
8000c7d6:	58 08       	cp.w	r8,0
8000c7d8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c7dc:	d8 22       	popm	r4-r7,pc
8000c7de:	d7 03       	nop

8000c7e0 <sprintf>:
8000c7e0:	d4 01       	pushm	lr
8000c7e2:	21 7d       	sub	sp,92
8000c7e4:	e0 68 ff ff 	mov	r8,65535
8000c7e8:	ea 18 7f ff 	orh	r8,0x7fff
8000c7ec:	50 58       	stdsp	sp[0x14],r8
8000c7ee:	50 28       	stdsp	sp[0x8],r8
8000c7f0:	e0 68 02 08 	mov	r8,520
8000c7f4:	ba 68       	st.h	sp[0xc],r8
8000c7f6:	3f f8       	mov	r8,-1
8000c7f8:	ba 78       	st.h	sp[0xe],r8
8000c7fa:	e0 68 02 2c 	mov	r8,556
8000c7fe:	50 4c       	stdsp	sp[0x10],r12
8000c800:	16 9a       	mov	r10,r11
8000c802:	50 0c       	stdsp	sp[0x0],r12
8000c804:	fa c9 ff a0 	sub	r9,sp,-96
8000c808:	70 0c       	ld.w	r12,r8[0x0]
8000c80a:	1a 9b       	mov	r11,sp
8000c80c:	e0 a0 0f 1e 	rcall	8000e648 <_vfprintf_r>
8000c810:	30 09       	mov	r9,0
8000c812:	40 08       	lddsp	r8,sp[0x0]
8000c814:	b0 89       	st.b	r8[0x0],r9
8000c816:	2e 9d       	sub	sp,-92
8000c818:	d8 02       	popm	pc
8000c81a:	d7 03       	nop

8000c81c <_exit>:
8000c81c:	30 d8       	mov	r8,13
8000c81e:	d6 73       	breakpoint
8000c820:	3f fc       	mov	r12,-1
8000c822:	35 8b       	mov	r11,88
8000c824:	c0 08       	rjmp	8000c824 <_exit+0x8>
8000c826:	d7 03       	nop

8000c828 <_close>:
8000c828:	30 28       	mov	r8,2
8000c82a:	d6 73       	breakpoint
8000c82c:	3f fc       	mov	r12,-1
8000c82e:	35 8b       	mov	r11,88
8000c830:	58 0c       	cp.w	r12,0
8000c832:	5e 4c       	retge	r12
8000c834:	e0 6a 0e fc 	mov	r10,3836
8000c838:	95 0b       	st.w	r10[0x0],r11
8000c83a:	5e fc       	retal	r12

8000c83c <_lseek>:
8000c83c:	30 58       	mov	r8,5
8000c83e:	d6 73       	breakpoint
8000c840:	3f fc       	mov	r12,-1
8000c842:	35 8b       	mov	r11,88
8000c844:	58 0c       	cp.w	r12,0
8000c846:	5e 4c       	retge	r12
8000c848:	e0 6a 0e fc 	mov	r10,3836
8000c84c:	95 0b       	st.w	r10[0x0],r11
8000c84e:	5e fc       	retal	r12

8000c850 <_read>:
8000c850:	30 38       	mov	r8,3
8000c852:	d6 73       	breakpoint
8000c854:	3f fc       	mov	r12,-1
8000c856:	35 8b       	mov	r11,88
8000c858:	58 0c       	cp.w	r12,0
8000c85a:	5e 4c       	retge	r12
8000c85c:	e0 6a 0e fc 	mov	r10,3836
8000c860:	95 0b       	st.w	r10[0x0],r11
8000c862:	5e fc       	retal	r12

8000c864 <_write>:
8000c864:	30 48       	mov	r8,4
8000c866:	d6 73       	breakpoint
8000c868:	3f fc       	mov	r12,-1
8000c86a:	35 8b       	mov	r11,88
8000c86c:	58 0c       	cp.w	r12,0
8000c86e:	5e 4c       	retge	r12
8000c870:	e0 6a 0e fc 	mov	r10,3836
8000c874:	95 0b       	st.w	r10[0x0],r11
8000c876:	5e fc       	retal	r12

8000c878 <isatty>:
8000c878:	30 b8       	mov	r8,11
8000c87a:	d6 73       	breakpoint
8000c87c:	3f fc       	mov	r12,-1
8000c87e:	35 8b       	mov	r11,88
8000c880:	58 0c       	cp.w	r12,0
8000c882:	5e 4c       	retge	r12
8000c884:	e0 6a 0e fc 	mov	r10,3836
8000c888:	95 0b       	st.w	r10[0x0],r11
8000c88a:	5e fc       	retal	r12

8000c88c <_fstat_host>:
8000c88c:	30 98       	mov	r8,9
8000c88e:	d6 73       	breakpoint
8000c890:	3f fc       	mov	r12,-1
8000c892:	35 8b       	mov	r11,88
8000c894:	58 0c       	cp.w	r12,0
8000c896:	5e 4c       	retge	r12
8000c898:	e0 6a 0e fc 	mov	r10,3836
8000c89c:	95 0b       	st.w	r10[0x0],r11
8000c89e:	5e fc       	retal	r12

8000c8a0 <_fstat>:
8000c8a0:	d4 21       	pushm	r4-r7,lr
8000c8a2:	21 0d       	sub	sp,64
8000c8a4:	16 97       	mov	r7,r11
8000c8a6:	1a 9b       	mov	r11,sp
8000c8a8:	cf 2f       	rcall	8000c88c <_fstat_host>
8000c8aa:	c0 34       	brge	8000c8b0 <_fstat+0x10>
8000c8ac:	3f fc       	mov	r12,-1
8000c8ae:	c1 c8       	rjmp	8000c8e6 <_fstat+0x46>
8000c8b0:	40 08       	lddsp	r8,sp[0x0]
8000c8b2:	ae 08       	st.h	r7[0x0],r8
8000c8b4:	40 18       	lddsp	r8,sp[0x4]
8000c8b6:	ae 18       	st.h	r7[0x2],r8
8000c8b8:	40 28       	lddsp	r8,sp[0x8]
8000c8ba:	8f 18       	st.w	r7[0x4],r8
8000c8bc:	40 38       	lddsp	r8,sp[0xc]
8000c8be:	ae 48       	st.h	r7[0x8],r8
8000c8c0:	40 48       	lddsp	r8,sp[0x10]
8000c8c2:	ae 58       	st.h	r7[0xa],r8
8000c8c4:	40 58       	lddsp	r8,sp[0x14]
8000c8c6:	ae 68       	st.h	r7[0xc],r8
8000c8c8:	40 68       	lddsp	r8,sp[0x18]
8000c8ca:	ae 78       	st.h	r7[0xe],r8
8000c8cc:	40 88       	lddsp	r8,sp[0x20]
8000c8ce:	8f 48       	st.w	r7[0x10],r8
8000c8d0:	40 a8       	lddsp	r8,sp[0x28]
8000c8d2:	8f b8       	st.w	r7[0x2c],r8
8000c8d4:	40 c8       	lddsp	r8,sp[0x30]
8000c8d6:	8f c8       	st.w	r7[0x30],r8
8000c8d8:	40 d8       	lddsp	r8,sp[0x34]
8000c8da:	8f 58       	st.w	r7[0x14],r8
8000c8dc:	40 e8       	lddsp	r8,sp[0x38]
8000c8de:	30 0c       	mov	r12,0
8000c8e0:	8f 78       	st.w	r7[0x1c],r8
8000c8e2:	40 f8       	lddsp	r8,sp[0x3c]
8000c8e4:	8f 98       	st.w	r7[0x24],r8
8000c8e6:	2f 0d       	sub	sp,-64
8000c8e8:	d8 22       	popm	r4-r7,pc
8000c8ea:	d7 03       	nop

8000c8ec <_kill>:
8000c8ec:	5e fe       	retal	-1

8000c8ee <_getpid>:
8000c8ee:	5e fe       	retal	-1

8000c8f0 <_sbrk>:
8000c8f0:	d4 01       	pushm	lr
8000c8f2:	e0 68 07 a4 	mov	r8,1956
8000c8f6:	70 09       	ld.w	r9,r8[0x0]
8000c8f8:	58 09       	cp.w	r9,0
8000c8fa:	c0 31       	brne	8000c900 <_sbrk+0x10>
8000c8fc:	48 a9       	lddpc	r9,8000c924 <_sbrk+0x34>
8000c8fe:	91 09       	st.w	r8[0x0],r9
8000c900:	e0 69 07 a4 	mov	r9,1956
8000c904:	48 9a       	lddpc	r10,8000c928 <_sbrk+0x38>
8000c906:	72 08       	ld.w	r8,r9[0x0]
8000c908:	f0 0c 00 0c 	add	r12,r8,r12
8000c90c:	14 3c       	cp.w	r12,r10
8000c90e:	e0 8b 00 04 	brhi	8000c916 <_sbrk+0x26>
8000c912:	93 0c       	st.w	r9[0x0],r12
8000c914:	c0 68       	rjmp	8000c920 <_sbrk+0x30>
8000c916:	e0 a0 25 1d 	rcall	80011350 <__errno>
8000c91a:	30 c8       	mov	r8,12
8000c91c:	99 08       	st.w	r12[0x0],r8
8000c91e:	3f f8       	mov	r8,-1
8000c920:	10 9c       	mov	r12,r8
8000c922:	d8 02       	popm	pc
8000c924:	d0 00       	acall	0x0
8000c926:	00 04       	add	r4,r0
8000c928:	d2 00       	acall	0x20
	...

8000c92c <get_arg>:
8000c92c:	d4 31       	pushm	r0-r7,lr
8000c92e:	20 8d       	sub	sp,32
8000c930:	fa c4 ff bc 	sub	r4,sp,-68
8000c934:	50 4b       	stdsp	sp[0x10],r11
8000c936:	68 2e       	ld.w	lr,r4[0x8]
8000c938:	50 58       	stdsp	sp[0x14],r8
8000c93a:	12 96       	mov	r6,r9
8000c93c:	7c 0b       	ld.w	r11,lr[0x0]
8000c93e:	70 05       	ld.w	r5,r8[0x0]
8000c940:	50 6e       	stdsp	sp[0x18],lr
8000c942:	58 0b       	cp.w	r11,0
8000c944:	f4 0b 17 00 	moveq	r11,r10
8000c948:	68 03       	ld.w	r3,r4[0x0]
8000c94a:	68 11       	ld.w	r1,r4[0x4]
8000c94c:	40 49       	lddsp	r9,sp[0x10]
8000c94e:	30 08       	mov	r8,0
8000c950:	c2 c9       	rjmp	8000cba8 <get_arg+0x27c>
8000c952:	2f fb       	sub	r11,-1
8000c954:	32 5c       	mov	r12,37
8000c956:	17 8a       	ld.ub	r10,r11[0x0]
8000c958:	f8 0a 18 00 	cp.b	r10,r12
8000c95c:	5f 1e       	srne	lr
8000c95e:	f0 0a 18 00 	cp.b	r10,r8
8000c962:	5f 1c       	srne	r12
8000c964:	fd ec 00 0c 	and	r12,lr,r12
8000c968:	f0 0c 18 00 	cp.b	r12,r8
8000c96c:	cf 31       	brne	8000c952 <get_arg+0x26>
8000c96e:	58 0a       	cp.w	r10,0
8000c970:	e0 80 01 29 	breq	8000cbc2 <get_arg+0x296>
8000c974:	30 0c       	mov	r12,0
8000c976:	3f fa       	mov	r10,-1
8000c978:	18 90       	mov	r0,r12
8000c97a:	50 3a       	stdsp	sp[0xc],r10
8000c97c:	18 94       	mov	r4,r12
8000c97e:	18 92       	mov	r2,r12
8000c980:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
8000c984:	16 97       	mov	r7,r11
8000c986:	50 7c       	stdsp	sp[0x1c],r12
8000c988:	4c ec       	lddpc	r12,8000cac0 <get_arg+0x194>
8000c98a:	0f 3a       	ld.ub	r10,r7++
8000c98c:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
8000c990:	40 7c       	lddsp	r12,sp[0x1c]
8000c992:	1c 0c       	add	r12,lr
8000c994:	4c ce       	lddpc	lr,8000cac4 <get_arg+0x198>
8000c996:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
8000c99a:	20 1e       	sub	lr,1
8000c99c:	50 0e       	stdsp	sp[0x0],lr
8000c99e:	4c be       	lddpc	lr,8000cac8 <get_arg+0x19c>
8000c9a0:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8000c9a4:	50 7c       	stdsp	sp[0x1c],r12
8000c9a6:	40 0c       	lddsp	r12,sp[0x0]
8000c9a8:	58 7c       	cp.w	r12,7
8000c9aa:	e0 8b 00 f8 	brhi	8000cb9a <get_arg+0x26e>
8000c9ae:	4c 8e       	lddpc	lr,8000cacc <get_arg+0x1a0>
8000c9b0:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
8000c9b4:	36 8b       	mov	r11,104
8000c9b6:	f6 0a 18 00 	cp.b	r10,r11
8000c9ba:	e0 80 00 f0 	breq	8000cb9a <get_arg+0x26e>
8000c9be:	37 1b       	mov	r11,113
8000c9c0:	f6 0a 18 00 	cp.b	r10,r11
8000c9c4:	c0 70       	breq	8000c9d2 <get_arg+0xa6>
8000c9c6:	34 cb       	mov	r11,76
8000c9c8:	f6 0a 18 00 	cp.b	r10,r11
8000c9cc:	c0 51       	brne	8000c9d6 <get_arg+0xaa>
8000c9ce:	a3 b4       	sbr	r4,0x3
8000c9d0:	ce 58       	rjmp	8000cb9a <get_arg+0x26e>
8000c9d2:	a5 b4       	sbr	r4,0x5
8000c9d4:	ce 38       	rjmp	8000cb9a <get_arg+0x26e>
8000c9d6:	08 9a       	mov	r10,r4
8000c9d8:	0e 9b       	mov	r11,r7
8000c9da:	a5 aa       	sbr	r10,0x4
8000c9dc:	17 3c       	ld.ub	r12,r11++
8000c9de:	a5 b4       	sbr	r4,0x5
8000c9e0:	36 ce       	mov	lr,108
8000c9e2:	fc 0c 18 00 	cp.b	r12,lr
8000c9e6:	e0 80 00 db 	breq	8000cb9c <get_arg+0x270>
8000c9ea:	14 94       	mov	r4,r10
8000c9ec:	cd 78       	rjmp	8000cb9a <get_arg+0x26e>
8000c9ee:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000c9f2:	36 7c       	mov	r12,103
8000c9f4:	f8 0a 18 00 	cp.b	r10,r12
8000c9f8:	e0 8b 00 27 	brhi	8000ca46 <get_arg+0x11a>
8000c9fc:	36 5b       	mov	r11,101
8000c9fe:	f6 0a 18 00 	cp.b	r10,r11
8000ca02:	c4 82       	brcc	8000ca92 <get_arg+0x166>
8000ca04:	34 fb       	mov	r11,79
8000ca06:	f6 0a 18 00 	cp.b	r10,r11
8000ca0a:	c4 80       	breq	8000ca9a <get_arg+0x16e>
8000ca0c:	e0 8b 00 0c 	brhi	8000ca24 <get_arg+0xf8>
8000ca10:	34 5b       	mov	r11,69
8000ca12:	f6 0a 18 00 	cp.b	r10,r11
8000ca16:	c3 e0       	breq	8000ca92 <get_arg+0x166>
8000ca18:	34 7b       	mov	r11,71
8000ca1a:	f6 0a 18 00 	cp.b	r10,r11
8000ca1e:	c3 a0       	breq	8000ca92 <get_arg+0x166>
8000ca20:	34 4b       	mov	r11,68
8000ca22:	c0 88       	rjmp	8000ca32 <get_arg+0x106>
8000ca24:	35 8b       	mov	r11,88
8000ca26:	f6 0a 18 00 	cp.b	r10,r11
8000ca2a:	c2 c0       	breq	8000ca82 <get_arg+0x156>
8000ca2c:	e0 8b 00 07 	brhi	8000ca3a <get_arg+0x10e>
8000ca30:	35 5b       	mov	r11,85
8000ca32:	f6 0a 18 00 	cp.b	r10,r11
8000ca36:	c3 51       	brne	8000caa0 <get_arg+0x174>
8000ca38:	c3 18       	rjmp	8000ca9a <get_arg+0x16e>
8000ca3a:	36 3b       	mov	r11,99
8000ca3c:	f6 0a 18 00 	cp.b	r10,r11
8000ca40:	c2 f0       	breq	8000ca9e <get_arg+0x172>
8000ca42:	36 4b       	mov	r11,100
8000ca44:	c0 e8       	rjmp	8000ca60 <get_arg+0x134>
8000ca46:	37 0b       	mov	r11,112
8000ca48:	f6 0a 18 00 	cp.b	r10,r11
8000ca4c:	c2 50       	breq	8000ca96 <get_arg+0x16a>
8000ca4e:	e0 8b 00 0d 	brhi	8000ca68 <get_arg+0x13c>
8000ca52:	36 eb       	mov	r11,110
8000ca54:	f6 0a 18 00 	cp.b	r10,r11
8000ca58:	c1 f0       	breq	8000ca96 <get_arg+0x16a>
8000ca5a:	e0 8b 00 14 	brhi	8000ca82 <get_arg+0x156>
8000ca5e:	36 9b       	mov	r11,105
8000ca60:	f6 0a 18 00 	cp.b	r10,r11
8000ca64:	c1 e1       	brne	8000caa0 <get_arg+0x174>
8000ca66:	c0 e8       	rjmp	8000ca82 <get_arg+0x156>
8000ca68:	37 5b       	mov	r11,117
8000ca6a:	f6 0a 18 00 	cp.b	r10,r11
8000ca6e:	c0 a0       	breq	8000ca82 <get_arg+0x156>
8000ca70:	37 8b       	mov	r11,120
8000ca72:	f6 0a 18 00 	cp.b	r10,r11
8000ca76:	c0 60       	breq	8000ca82 <get_arg+0x156>
8000ca78:	37 3b       	mov	r11,115
8000ca7a:	f6 0a 18 00 	cp.b	r10,r11
8000ca7e:	c1 11       	brne	8000caa0 <get_arg+0x174>
8000ca80:	c0 b8       	rjmp	8000ca96 <get_arg+0x16a>
8000ca82:	ed b4 00 04 	bld	r4,0x4
8000ca86:	c0 a0       	breq	8000ca9a <get_arg+0x16e>
8000ca88:	ed b4 00 05 	bld	r4,0x5
8000ca8c:	c0 91       	brne	8000ca9e <get_arg+0x172>
8000ca8e:	30 20       	mov	r0,2
8000ca90:	c0 88       	rjmp	8000caa0 <get_arg+0x174>
8000ca92:	30 40       	mov	r0,4
8000ca94:	c0 68       	rjmp	8000caa0 <get_arg+0x174>
8000ca96:	30 30       	mov	r0,3
8000ca98:	c0 48       	rjmp	8000caa0 <get_arg+0x174>
8000ca9a:	30 10       	mov	r0,1
8000ca9c:	c0 28       	rjmp	8000caa0 <get_arg+0x174>
8000ca9e:	30 00       	mov	r0,0
8000caa0:	40 3b       	lddsp	r11,sp[0xc]
8000caa2:	5b fb       	cp.w	r11,-1
8000caa4:	c0 40       	breq	8000caac <get_arg+0x180>
8000caa6:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000caaa:	c7 88       	rjmp	8000cb9a <get_arg+0x26e>
8000caac:	58 60       	cp.w	r0,6
8000caae:	e0 8b 00 76 	brhi	8000cb9a <get_arg+0x26e>
8000cab2:	6c 0a       	ld.w	r10,r6[0x0]
8000cab4:	ea cc ff ff 	sub	r12,r5,-1
8000cab8:	48 6e       	lddpc	lr,8000cad0 <get_arg+0x1a4>
8000caba:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
8000cabe:	d7 03       	nop
8000cac0:	80 01       	ld.sh	r1,r0[0x0]
8000cac2:	68 ec       	ld.w	r12,r4[0x38]
8000cac4:	80 01       	ld.sh	r1,r0[0x0]
8000cac6:	68 48       	ld.w	r8,r4[0x10]
8000cac8:	80 01       	ld.sh	r1,r0[0x0]
8000caca:	67 dc       	ld.w	r12,r3[0x74]
8000cacc:	80 01       	ld.sh	r1,r0[0x0]
8000cace:	67 90       	ld.w	r0,r3[0x64]
8000cad0:	80 01       	ld.sh	r1,r0[0x0]
8000cad2:	67 b0       	ld.w	r0,r3[0x6c]
8000cad4:	f4 cb ff f8 	sub	r11,r10,-8
8000cad8:	8d 0b       	st.w	r6[0x0],r11
8000cada:	f4 ea 00 00 	ld.d	r10,r10[0]
8000cade:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000cae2:	c0 f8       	rjmp	8000cb00 <get_arg+0x1d4>
8000cae4:	f4 cb ff fc 	sub	r11,r10,-4
8000cae8:	8d 0b       	st.w	r6[0x0],r11
8000caea:	74 0a       	ld.w	r10,r10[0x0]
8000caec:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000caf0:	c0 88       	rjmp	8000cb00 <get_arg+0x1d4>
8000caf2:	f4 cb ff f8 	sub	r11,r10,-8
8000caf6:	8d 0b       	st.w	r6[0x0],r11
8000caf8:	f4 ea 00 00 	ld.d	r10,r10[0]
8000cafc:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000cb00:	0e 9b       	mov	r11,r7
8000cb02:	18 95       	mov	r5,r12
8000cb04:	c4 c8       	rjmp	8000cb9c <get_arg+0x270>
8000cb06:	62 0a       	ld.w	r10,r1[0x0]
8000cb08:	5b fa       	cp.w	r10,-1
8000cb0a:	c0 a1       	brne	8000cb1e <get_arg+0x1f2>
8000cb0c:	50 19       	stdsp	sp[0x4],r9
8000cb0e:	50 28       	stdsp	sp[0x8],r8
8000cb10:	e0 6a 00 80 	mov	r10,128
8000cb14:	30 0b       	mov	r11,0
8000cb16:	02 9c       	mov	r12,r1
8000cb18:	c3 4e       	rcall	8000c780 <memset>
8000cb1a:	40 28       	lddsp	r8,sp[0x8]
8000cb1c:	40 19       	lddsp	r9,sp[0x4]
8000cb1e:	e4 cc 00 01 	sub	r12,r2,1
8000cb22:	0e 9b       	mov	r11,r7
8000cb24:	50 3c       	stdsp	sp[0xc],r12
8000cb26:	f2 0c 0c 49 	max	r9,r9,r12
8000cb2a:	c3 98       	rjmp	8000cb9c <get_arg+0x270>
8000cb2c:	62 0a       	ld.w	r10,r1[0x0]
8000cb2e:	5b fa       	cp.w	r10,-1
8000cb30:	c0 a1       	brne	8000cb44 <get_arg+0x218>
8000cb32:	50 19       	stdsp	sp[0x4],r9
8000cb34:	50 28       	stdsp	sp[0x8],r8
8000cb36:	e0 6a 00 80 	mov	r10,128
8000cb3a:	30 0b       	mov	r11,0
8000cb3c:	02 9c       	mov	r12,r1
8000cb3e:	c2 1e       	rcall	8000c780 <memset>
8000cb40:	40 28       	lddsp	r8,sp[0x8]
8000cb42:	40 19       	lddsp	r9,sp[0x4]
8000cb44:	20 12       	sub	r2,1
8000cb46:	30 0a       	mov	r10,0
8000cb48:	0e 9b       	mov	r11,r7
8000cb4a:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
8000cb4e:	f2 02 0c 49 	max	r9,r9,r2
8000cb52:	c2 58       	rjmp	8000cb9c <get_arg+0x270>
8000cb54:	16 97       	mov	r7,r11
8000cb56:	6c 0a       	ld.w	r10,r6[0x0]
8000cb58:	f4 cb ff fc 	sub	r11,r10,-4
8000cb5c:	8d 0b       	st.w	r6[0x0],r11
8000cb5e:	74 0a       	ld.w	r10,r10[0x0]
8000cb60:	0e 9b       	mov	r11,r7
8000cb62:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000cb66:	2f f5       	sub	r5,-1
8000cb68:	c1 a8       	rjmp	8000cb9c <get_arg+0x270>
8000cb6a:	f4 c2 00 30 	sub	r2,r10,48
8000cb6e:	c0 68       	rjmp	8000cb7a <get_arg+0x24e>
8000cb70:	e4 02 00 22 	add	r2,r2,r2<<0x2
8000cb74:	2f f7       	sub	r7,-1
8000cb76:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000cb7a:	0f 8a       	ld.ub	r10,r7[0x0]
8000cb7c:	58 0a       	cp.w	r10,0
8000cb7e:	c0 e0       	breq	8000cb9a <get_arg+0x26e>
8000cb80:	23 0a       	sub	r10,48
8000cb82:	58 9a       	cp.w	r10,9
8000cb84:	fe 98 ff f6 	brls	8000cb70 <get_arg+0x244>
8000cb88:	c0 98       	rjmp	8000cb9a <get_arg+0x26e>
8000cb8a:	2f f7       	sub	r7,-1
8000cb8c:	0f 8a       	ld.ub	r10,r7[0x0]
8000cb8e:	58 0a       	cp.w	r10,0
8000cb90:	c0 50       	breq	8000cb9a <get_arg+0x26e>
8000cb92:	23 0a       	sub	r10,48
8000cb94:	58 9a       	cp.w	r10,9
8000cb96:	fe 98 ff fa 	brls	8000cb8a <get_arg+0x25e>
8000cb9a:	0e 9b       	mov	r11,r7
8000cb9c:	40 7c       	lddsp	r12,sp[0x1c]
8000cb9e:	30 ba       	mov	r10,11
8000cba0:	f4 0c 18 00 	cp.b	r12,r10
8000cba4:	fe 91 fe ee 	brne	8000c980 <get_arg+0x54>
8000cba8:	40 42       	lddsp	r2,sp[0x10]
8000cbaa:	17 8c       	ld.ub	r12,r11[0x0]
8000cbac:	0a 32       	cp.w	r2,r5
8000cbae:	5f 4a       	srge	r10
8000cbb0:	f0 0c 18 00 	cp.b	r12,r8
8000cbb4:	5f 1c       	srne	r12
8000cbb6:	f9 ea 00 0a 	and	r10,r12,r10
8000cbba:	f0 0a 18 00 	cp.b	r10,r8
8000cbbe:	fe 91 fe cb 	brne	8000c954 <get_arg+0x28>
8000cbc2:	30 08       	mov	r8,0
8000cbc4:	40 4e       	lddsp	lr,sp[0x10]
8000cbc6:	17 8a       	ld.ub	r10,r11[0x0]
8000cbc8:	e2 05 00 21 	add	r1,r1,r5<<0x2
8000cbcc:	f0 0a 18 00 	cp.b	r10,r8
8000cbd0:	fc 09 17 10 	movne	r9,lr
8000cbd4:	e6 05 00 38 	add	r8,r3,r5<<0x3
8000cbd8:	06 9e       	mov	lr,r3
8000cbda:	c2 a8       	rjmp	8000cc2e <get_arg+0x302>
8000cbdc:	62 0a       	ld.w	r10,r1[0x0]
8000cbde:	58 3a       	cp.w	r10,3
8000cbe0:	c1 e0       	breq	8000cc1c <get_arg+0x2f0>
8000cbe2:	e0 89 00 07 	brgt	8000cbf0 <get_arg+0x2c4>
8000cbe6:	58 1a       	cp.w	r10,1
8000cbe8:	c1 a0       	breq	8000cc1c <get_arg+0x2f0>
8000cbea:	58 2a       	cp.w	r10,2
8000cbec:	c1 81       	brne	8000cc1c <get_arg+0x2f0>
8000cbee:	c0 58       	rjmp	8000cbf8 <get_arg+0x2cc>
8000cbf0:	58 5a       	cp.w	r10,5
8000cbf2:	c0 c0       	breq	8000cc0a <get_arg+0x2de>
8000cbf4:	c0 b5       	brlt	8000cc0a <get_arg+0x2de>
8000cbf6:	c1 38       	rjmp	8000cc1c <get_arg+0x2f0>
8000cbf8:	6c 0a       	ld.w	r10,r6[0x0]
8000cbfa:	f4 cc ff f8 	sub	r12,r10,-8
8000cbfe:	8d 0c       	st.w	r6[0x0],r12
8000cc00:	f4 e2 00 00 	ld.d	r2,r10[0]
8000cc04:	f0 e3 00 00 	st.d	r8[0],r2
8000cc08:	c1 08       	rjmp	8000cc28 <get_arg+0x2fc>
8000cc0a:	6c 0a       	ld.w	r10,r6[0x0]
8000cc0c:	f4 cc ff f8 	sub	r12,r10,-8
8000cc10:	8d 0c       	st.w	r6[0x0],r12
8000cc12:	f4 e2 00 00 	ld.d	r2,r10[0]
8000cc16:	f0 e3 00 00 	st.d	r8[0],r2
8000cc1a:	c0 78       	rjmp	8000cc28 <get_arg+0x2fc>
8000cc1c:	6c 0a       	ld.w	r10,r6[0x0]
8000cc1e:	f4 cc ff fc 	sub	r12,r10,-4
8000cc22:	8d 0c       	st.w	r6[0x0],r12
8000cc24:	74 0a       	ld.w	r10,r10[0x0]
8000cc26:	91 0a       	st.w	r8[0x0],r10
8000cc28:	2f f5       	sub	r5,-1
8000cc2a:	2f 88       	sub	r8,-8
8000cc2c:	2f c1       	sub	r1,-4
8000cc2e:	12 35       	cp.w	r5,r9
8000cc30:	fe 9a ff d6 	brle	8000cbdc <get_arg+0x2b0>
8000cc34:	1c 93       	mov	r3,lr
8000cc36:	40 52       	lddsp	r2,sp[0x14]
8000cc38:	40 6e       	lddsp	lr,sp[0x18]
8000cc3a:	85 05       	st.w	r2[0x0],r5
8000cc3c:	9d 0b       	st.w	lr[0x0],r11
8000cc3e:	40 4b       	lddsp	r11,sp[0x10]
8000cc40:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000cc44:	2f 8d       	sub	sp,-32
8000cc46:	d8 32       	popm	r0-r7,pc

8000cc48 <__sprint_r>:
8000cc48:	d4 21       	pushm	r4-r7,lr
8000cc4a:	14 97       	mov	r7,r10
8000cc4c:	74 28       	ld.w	r8,r10[0x8]
8000cc4e:	58 08       	cp.w	r8,0
8000cc50:	c0 41       	brne	8000cc58 <__sprint_r+0x10>
8000cc52:	95 18       	st.w	r10[0x4],r8
8000cc54:	10 9c       	mov	r12,r8
8000cc56:	d8 22       	popm	r4-r7,pc
8000cc58:	e0 a0 25 ba 	rcall	800117cc <__sfvwrite_r>
8000cc5c:	30 08       	mov	r8,0
8000cc5e:	8f 18       	st.w	r7[0x4],r8
8000cc60:	8f 28       	st.w	r7[0x8],r8
8000cc62:	d8 22       	popm	r4-r7,pc

8000cc64 <_vfiprintf_r>:
8000cc64:	d4 31       	pushm	r0-r7,lr
8000cc66:	fa cd 06 88 	sub	sp,sp,1672
8000cc6a:	50 a9       	stdsp	sp[0x28],r9
8000cc6c:	16 90       	mov	r0,r11
8000cc6e:	14 97       	mov	r7,r10
8000cc70:	18 92       	mov	r2,r12
8000cc72:	58 0c       	cp.w	r12,0
8000cc74:	c0 60       	breq	8000cc80 <_vfiprintf_r+0x1c>
8000cc76:	78 68       	ld.w	r8,r12[0x18]
8000cc78:	58 08       	cp.w	r8,0
8000cc7a:	c0 31       	brne	8000cc80 <_vfiprintf_r+0x1c>
8000cc7c:	e0 a0 24 48 	rcall	8001150c <__sinit>
8000cc80:	4c c8       	lddpc	r8,8000cdb0 <_vfiprintf_r+0x14c>
8000cc82:	10 30       	cp.w	r0,r8
8000cc84:	c0 31       	brne	8000cc8a <_vfiprintf_r+0x26>
8000cc86:	64 00       	ld.w	r0,r2[0x0]
8000cc88:	c0 a8       	rjmp	8000cc9c <_vfiprintf_r+0x38>
8000cc8a:	4c b8       	lddpc	r8,8000cdb4 <_vfiprintf_r+0x150>
8000cc8c:	10 30       	cp.w	r0,r8
8000cc8e:	c0 31       	brne	8000cc94 <_vfiprintf_r+0x30>
8000cc90:	64 10       	ld.w	r0,r2[0x4]
8000cc92:	c0 58       	rjmp	8000cc9c <_vfiprintf_r+0x38>
8000cc94:	4c 98       	lddpc	r8,8000cdb8 <_vfiprintf_r+0x154>
8000cc96:	10 30       	cp.w	r0,r8
8000cc98:	e5 f0 00 02 	ld.weq	r0,r2[0x8]
8000cc9c:	80 68       	ld.sh	r8,r0[0xc]
8000cc9e:	ed b8 00 03 	bld	r8,0x3
8000cca2:	c0 41       	brne	8000ccaa <_vfiprintf_r+0x46>
8000cca4:	60 48       	ld.w	r8,r0[0x10]
8000cca6:	58 08       	cp.w	r8,0
8000cca8:	c0 71       	brne	8000ccb6 <_vfiprintf_r+0x52>
8000ccaa:	00 9b       	mov	r11,r0
8000ccac:	04 9c       	mov	r12,r2
8000ccae:	e0 a0 1c 5d 	rcall	80010568 <__swsetup_r>
8000ccb2:	e0 81 0b 24 	brne	8000e2fa <_vfiprintf_r+0x1696>
8000ccb6:	80 68       	ld.sh	r8,r0[0xc]
8000ccb8:	10 99       	mov	r9,r8
8000ccba:	e2 19 00 1a 	andl	r9,0x1a,COH
8000ccbe:	58 a9       	cp.w	r9,10
8000ccc0:	c3 c1       	brne	8000cd38 <_vfiprintf_r+0xd4>
8000ccc2:	80 79       	ld.sh	r9,r0[0xe]
8000ccc4:	30 0a       	mov	r10,0
8000ccc6:	f4 09 19 00 	cp.h	r9,r10
8000ccca:	c3 75       	brlt	8000cd38 <_vfiprintf_r+0xd4>
8000cccc:	a1 d8       	cbr	r8,0x1
8000ccce:	fb 58 05 b8 	st.h	sp[1464],r8
8000ccd2:	60 88       	ld.w	r8,r0[0x20]
8000ccd4:	fb 48 05 cc 	st.w	sp[1484],r8
8000ccd8:	60 a8       	ld.w	r8,r0[0x28]
8000ccda:	fb 48 05 d4 	st.w	sp[1492],r8
8000ccde:	fa c8 ff d4 	sub	r8,sp,-44
8000cce2:	fb 48 05 bc 	st.w	sp[1468],r8
8000cce6:	fb 48 05 ac 	st.w	sp[1452],r8
8000ccea:	e0 68 04 00 	mov	r8,1024
8000ccee:	fb 48 05 c0 	st.w	sp[1472],r8
8000ccf2:	fb 48 05 b4 	st.w	sp[1460],r8
8000ccf6:	30 08       	mov	r8,0
8000ccf8:	fb 59 05 ba 	st.h	sp[1466],r9
8000ccfc:	0e 9a       	mov	r10,r7
8000ccfe:	40 a9       	lddsp	r9,sp[0x28]
8000cd00:	fa c7 fa 54 	sub	r7,sp,-1452
8000cd04:	fb 48 05 c4 	st.w	sp[1476],r8
8000cd08:	04 9c       	mov	r12,r2
8000cd0a:	0e 9b       	mov	r11,r7
8000cd0c:	ca cf       	rcall	8000cc64 <_vfiprintf_r>
8000cd0e:	50 6c       	stdsp	sp[0x18],r12
8000cd10:	c0 95       	brlt	8000cd22 <_vfiprintf_r+0xbe>
8000cd12:	0e 9b       	mov	r11,r7
8000cd14:	04 9c       	mov	r12,r2
8000cd16:	e0 a0 23 23 	rcall	8001135c <_fflush_r>
8000cd1a:	40 6e       	lddsp	lr,sp[0x18]
8000cd1c:	f9 be 01 ff 	movne	lr,-1
8000cd20:	50 6e       	stdsp	sp[0x18],lr
8000cd22:	fb 08 05 b8 	ld.sh	r8,sp[1464]
8000cd26:	ed b8 00 06 	bld	r8,0x6
8000cd2a:	e0 81 0a ea 	brne	8000e2fe <_vfiprintf_r+0x169a>
8000cd2e:	80 68       	ld.sh	r8,r0[0xc]
8000cd30:	a7 a8       	sbr	r8,0x6
8000cd32:	a0 68       	st.h	r0[0xc],r8
8000cd34:	e0 8f 0a e5 	bral	8000e2fe <_vfiprintf_r+0x169a>
8000cd38:	30 08       	mov	r8,0
8000cd3a:	fa c4 f9 f8 	sub	r4,sp,-1544
8000cd3e:	50 98       	stdsp	sp[0x24],r8
8000cd40:	fb 48 06 78 	st.w	sp[1656],r8
8000cd44:	40 9c       	lddsp	r12,sp[0x24]
8000cd46:	fb 48 06 74 	st.w	sp[1652],r8
8000cd4a:	fb 48 06 7c 	st.w	sp[1660],r8
8000cd4e:	fb 48 06 80 	st.w	sp[1664],r8
8000cd52:	50 57       	stdsp	sp[0x14],r7
8000cd54:	3f f8       	mov	r8,-1
8000cd56:	fb 44 06 70 	st.w	sp[1648],r4
8000cd5a:	fb 48 05 2c 	st.w	sp[1324],r8
8000cd5e:	50 6c       	stdsp	sp[0x18],r12
8000cd60:	18 96       	mov	r6,r12
8000cd62:	04 91       	mov	r1,r2
8000cd64:	50 20       	stdsp	sp[0x8],r0
8000cd66:	40 55       	lddsp	r5,sp[0x14]
8000cd68:	c0 28       	rjmp	8000cd6c <_vfiprintf_r+0x108>
8000cd6a:	2f f5       	sub	r5,-1
8000cd6c:	0b 88       	ld.ub	r8,r5[0x0]
8000cd6e:	30 0b       	mov	r11,0
8000cd70:	32 5a       	mov	r10,37
8000cd72:	f6 08 18 00 	cp.b	r8,r11
8000cd76:	5f 19       	srne	r9
8000cd78:	f4 08 18 00 	cp.b	r8,r10
8000cd7c:	5f 18       	srne	r8
8000cd7e:	12 68       	and	r8,r9
8000cd80:	f6 08 18 00 	cp.b	r8,r11
8000cd84:	cf 31       	brne	8000cd6a <_vfiprintf_r+0x106>
8000cd86:	40 59       	lddsp	r9,sp[0x14]
8000cd88:	ea 09 01 07 	sub	r7,r5,r9
8000cd8c:	c2 40       	breq	8000cdd4 <_vfiprintf_r+0x170>
8000cd8e:	fa f8 06 78 	ld.w	r8,sp[1656]
8000cd92:	0e 08       	add	r8,r7
8000cd94:	89 09       	st.w	r4[0x0],r9
8000cd96:	fb 48 06 78 	st.w	sp[1656],r8
8000cd9a:	89 17       	st.w	r4[0x4],r7
8000cd9c:	fa f8 06 74 	ld.w	r8,sp[1652]
8000cda0:	2f f8       	sub	r8,-1
8000cda2:	fb 48 06 74 	st.w	sp[1652],r8
8000cda6:	58 78       	cp.w	r8,7
8000cda8:	e0 89 00 0a 	brgt	8000cdbc <_vfiprintf_r+0x158>
8000cdac:	2f 84       	sub	r4,-8
8000cdae:	c1 08       	rjmp	8000cdce <_vfiprintf_r+0x16a>
8000cdb0:	80 01       	ld.sh	r1,r0[0x0]
8000cdb2:	6d a4       	ld.w	r4,r6[0x68]
8000cdb4:	80 01       	ld.sh	r1,r0[0x0]
8000cdb6:	6d c4       	ld.w	r4,r6[0x70]
8000cdb8:	80 01       	ld.sh	r1,r0[0x0]
8000cdba:	6d e4       	ld.w	r4,r6[0x78]
8000cdbc:	fa ca f9 90 	sub	r10,sp,-1648
8000cdc0:	40 2b       	lddsp	r11,sp[0x8]
8000cdc2:	02 9c       	mov	r12,r1
8000cdc4:	c4 2f       	rcall	8000cc48 <__sprint_r>
8000cdc6:	e0 81 0a 95 	brne	8000e2f0 <_vfiprintf_r+0x168c>
8000cdca:	fa c4 f9 f8 	sub	r4,sp,-1544
8000cdce:	40 68       	lddsp	r8,sp[0x18]
8000cdd0:	0e 08       	add	r8,r7
8000cdd2:	50 68       	stdsp	sp[0x18],r8
8000cdd4:	0b 88       	ld.ub	r8,r5[0x0]
8000cdd6:	30 07       	mov	r7,0
8000cdd8:	ee 08 18 00 	cp.b	r8,r7
8000cddc:	e0 80 0a 79 	breq	8000e2ce <_vfiprintf_r+0x166a>
8000cde0:	ea c2 ff ff 	sub	r2,r5,-1
8000cde4:	30 03       	mov	r3,0
8000cde6:	50 52       	stdsp	sp[0x14],r2
8000cde8:	fb 67 06 87 	st.b	sp[1671],r7
8000cdec:	3f fe       	mov	lr,-1
8000cdee:	50 74       	stdsp	sp[0x1c],r4
8000cdf0:	50 43       	stdsp	sp[0x10],r3
8000cdf2:	50 3e       	stdsp	sp[0xc],lr
8000cdf4:	06 90       	mov	r0,r3
8000cdf6:	50 85       	stdsp	sp[0x20],r5
8000cdf8:	06 92       	mov	r2,r3
8000cdfa:	0c 94       	mov	r4,r6
8000cdfc:	40 57       	lddsp	r7,sp[0x14]
8000cdfe:	c0 68       	rjmp	8000ce0a <_vfiprintf_r+0x1a6>
8000ce00:	3f fc       	mov	r12,-1
8000ce02:	0a 97       	mov	r7,r5
8000ce04:	50 3c       	stdsp	sp[0xc],r12
8000ce06:	c0 28       	rjmp	8000ce0a <_vfiprintf_r+0x1a6>
8000ce08:	30 00       	mov	r0,0
8000ce0a:	0f 38       	ld.ub	r8,r7++
8000ce0c:	c0 28       	rjmp	8000ce10 <_vfiprintf_r+0x1ac>
8000ce0e:	12 92       	mov	r2,r9
8000ce10:	e0 48 00 63 	cp.w	r8,99
8000ce14:	e0 80 01 c8 	breq	8000d1a4 <_vfiprintf_r+0x540>
8000ce18:	e0 89 00 45 	brgt	8000cea2 <_vfiprintf_r+0x23e>
8000ce1c:	e0 48 00 39 	cp.w	r8,57
8000ce20:	e0 89 00 26 	brgt	8000ce6c <_vfiprintf_r+0x208>
8000ce24:	e0 48 00 31 	cp.w	r8,49
8000ce28:	e0 84 01 93 	brge	8000d14e <_vfiprintf_r+0x4ea>
8000ce2c:	e0 48 00 2b 	cp.w	r8,43
8000ce30:	e0 80 01 01 	breq	8000d032 <_vfiprintf_r+0x3ce>
8000ce34:	e0 89 00 0f 	brgt	8000ce52 <_vfiprintf_r+0x1ee>
8000ce38:	e0 48 00 23 	cp.w	r8,35
8000ce3c:	e0 80 00 8e 	breq	8000cf58 <_vfiprintf_r+0x2f4>
8000ce40:	e0 48 00 2a 	cp.w	r8,42
8000ce44:	e0 80 00 8c 	breq	8000cf5c <_vfiprintf_r+0x2f8>
8000ce48:	e0 48 00 20 	cp.w	r8,32
8000ce4c:	e0 81 08 90 	brne	8000df6c <_vfiprintf_r+0x1308>
8000ce50:	c7 b8       	rjmp	8000cf46 <_vfiprintf_r+0x2e2>
8000ce52:	e0 48 00 2e 	cp.w	r8,46
8000ce56:	e0 80 00 f1 	breq	8000d038 <_vfiprintf_r+0x3d4>
8000ce5a:	e0 48 00 30 	cp.w	r8,48
8000ce5e:	e0 80 01 76 	breq	8000d14a <_vfiprintf_r+0x4e6>
8000ce62:	e0 48 00 2d 	cp.w	r8,45
8000ce66:	e0 81 08 83 	brne	8000df6c <_vfiprintf_r+0x1308>
8000ce6a:	ce 28       	rjmp	8000d02e <_vfiprintf_r+0x3ca>
8000ce6c:	50 57       	stdsp	sp[0x14],r7
8000ce6e:	50 42       	stdsp	sp[0x10],r2
8000ce70:	08 97       	mov	r7,r4
8000ce72:	40 85       	lddsp	r5,sp[0x20]
8000ce74:	40 74       	lddsp	r4,sp[0x1c]
8000ce76:	10 92       	mov	r2,r8
8000ce78:	e0 48 00 4f 	cp.w	r8,79
8000ce7c:	e0 80 04 35 	breq	8000d6e6 <_vfiprintf_r+0xa82>
8000ce80:	e0 89 00 08 	brgt	8000ce90 <_vfiprintf_r+0x22c>
8000ce84:	e0 48 00 44 	cp.w	r8,68
8000ce88:	e0 81 08 76 	brne	8000df74 <_vfiprintf_r+0x1310>
8000ce8c:	e0 8f 01 da 	bral	8000d240 <_vfiprintf_r+0x5dc>
8000ce90:	e0 48 00 55 	cp.w	r8,85
8000ce94:	e0 80 05 db 	breq	8000da4a <_vfiprintf_r+0xde6>
8000ce98:	e0 48 00 58 	cp.w	r8,88
8000ce9c:	e0 81 08 6c 	brne	8000df74 <_vfiprintf_r+0x1310>
8000cea0:	c4 28       	rjmp	8000cf24 <_vfiprintf_r+0x2c0>
8000cea2:	e0 48 00 6f 	cp.w	r8,111
8000cea6:	c4 30       	breq	8000cf2c <_vfiprintf_r+0x2c8>
8000cea8:	e0 89 00 1f 	brgt	8000cee6 <_vfiprintf_r+0x282>
8000ceac:	e0 48 00 69 	cp.w	r8,105
8000ceb0:	c4 50       	breq	8000cf3a <_vfiprintf_r+0x2d6>
8000ceb2:	e0 89 00 0a 	brgt	8000cec6 <_vfiprintf_r+0x262>
8000ceb6:	e0 48 00 64 	cp.w	r8,100
8000ceba:	c4 00       	breq	8000cf3a <_vfiprintf_r+0x2d6>
8000cebc:	e0 48 00 68 	cp.w	r8,104
8000cec0:	e0 81 08 56 	brne	8000df6c <_vfiprintf_r+0x1308>
8000cec4:	c5 e9       	rjmp	8000d180 <_vfiprintf_r+0x51c>
8000cec6:	e0 48 00 6c 	cp.w	r8,108
8000ceca:	e0 80 01 5e 	breq	8000d186 <_vfiprintf_r+0x522>
8000cece:	50 57       	stdsp	sp[0x14],r7
8000ced0:	50 42       	stdsp	sp[0x10],r2
8000ced2:	08 97       	mov	r7,r4
8000ced4:	40 85       	lddsp	r5,sp[0x20]
8000ced6:	40 74       	lddsp	r4,sp[0x1c]
8000ced8:	10 92       	mov	r2,r8
8000ceda:	e0 48 00 6e 	cp.w	r8,110
8000cede:	e0 81 08 4b 	brne	8000df74 <_vfiprintf_r+0x1310>
8000cee2:	e0 8f 02 e9 	bral	8000d4b4 <_vfiprintf_r+0x850>
8000cee6:	e0 48 00 73 	cp.w	r8,115
8000ceea:	e0 80 05 4f 	breq	8000d988 <_vfiprintf_r+0xd24>
8000ceee:	e0 89 00 0b 	brgt	8000cf04 <_vfiprintf_r+0x2a0>
8000cef2:	e0 48 00 70 	cp.w	r8,112
8000cef6:	e0 80 04 f5 	breq	8000d8e0 <_vfiprintf_r+0xc7c>
8000cefa:	e0 48 00 71 	cp.w	r8,113
8000cefe:	e0 81 08 37 	brne	8000df6c <_vfiprintf_r+0x1308>
8000cf02:	c4 e9       	rjmp	8000d19e <_vfiprintf_r+0x53a>
8000cf04:	50 57       	stdsp	sp[0x14],r7
8000cf06:	50 42       	stdsp	sp[0x10],r2
8000cf08:	08 97       	mov	r7,r4
8000cf0a:	40 85       	lddsp	r5,sp[0x20]
8000cf0c:	40 74       	lddsp	r4,sp[0x1c]
8000cf0e:	10 92       	mov	r2,r8
8000cf10:	e0 48 00 75 	cp.w	r8,117
8000cf14:	e0 80 05 9c 	breq	8000da4c <_vfiprintf_r+0xde8>
8000cf18:	e0 48 00 78 	cp.w	r8,120
8000cf1c:	e0 81 08 2c 	brne	8000df74 <_vfiprintf_r+0x1310>
8000cf20:	e0 8f 06 8d 	bral	8000dc3a <_vfiprintf_r+0xfd6>
8000cf24:	4c 8b       	lddpc	r11,8000d044 <_vfiprintf_r+0x3e0>
8000cf26:	50 9b       	stdsp	sp[0x24],r11
8000cf28:	e0 8f 06 8b 	bral	8000dc3e <_vfiprintf_r+0xfda>
8000cf2c:	50 57       	stdsp	sp[0x14],r7
8000cf2e:	40 85       	lddsp	r5,sp[0x20]
8000cf30:	08 97       	mov	r7,r4
8000cf32:	50 42       	stdsp	sp[0x10],r2
8000cf34:	40 74       	lddsp	r4,sp[0x1c]
8000cf36:	e0 8f 03 d9 	bral	8000d6e8 <_vfiprintf_r+0xa84>
8000cf3a:	50 57       	stdsp	sp[0x14],r7
8000cf3c:	40 85       	lddsp	r5,sp[0x20]
8000cf3e:	08 97       	mov	r7,r4
8000cf40:	50 42       	stdsp	sp[0x10],r2
8000cf42:	40 74       	lddsp	r4,sp[0x1c]
8000cf44:	c7 f9       	rjmp	8000d242 <_vfiprintf_r+0x5de>
8000cf46:	fb 38 06 87 	ld.ub	r8,sp[1671]
8000cf4a:	30 0a       	mov	r10,0
8000cf4c:	f4 08 18 00 	cp.b	r8,r10
8000cf50:	fe 91 ff 5d 	brne	8000ce0a <_vfiprintf_r+0x1a6>
8000cf54:	32 08       	mov	r8,32
8000cf56:	c6 e8       	rjmp	8000d032 <_vfiprintf_r+0x3ce>
8000cf58:	a1 a3       	sbr	r3,0x0
8000cf5a:	c5 8b       	rjmp	8000ce0a <_vfiprintf_r+0x1a6>
8000cf5c:	0f 89       	ld.ub	r9,r7[0x0]
8000cf5e:	f2 c8 00 30 	sub	r8,r9,48
8000cf62:	58 98       	cp.w	r8,9
8000cf64:	e0 8b 00 1e 	brhi	8000cfa0 <_vfiprintf_r+0x33c>
8000cf68:	ee c8 ff ff 	sub	r8,r7,-1
8000cf6c:	30 0b       	mov	r11,0
8000cf6e:	23 09       	sub	r9,48
8000cf70:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000cf74:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000cf78:	11 39       	ld.ub	r9,r8++
8000cf7a:	f2 ca 00 30 	sub	r10,r9,48
8000cf7e:	58 9a       	cp.w	r10,9
8000cf80:	fe 98 ff f7 	brls	8000cf6e <_vfiprintf_r+0x30a>
8000cf84:	e0 49 00 24 	cp.w	r9,36
8000cf88:	fe 91 ff 40 	brne	8000ce08 <_vfiprintf_r+0x1a4>
8000cf8c:	e0 4b 00 20 	cp.w	r11,32
8000cf90:	e0 89 09 b0 	brgt	8000e2f0 <_vfiprintf_r+0x168c>
8000cf94:	20 1b       	sub	r11,1
8000cf96:	fa f9 06 80 	ld.w	r9,sp[1664]
8000cf9a:	12 3b       	cp.w	r11,r9
8000cf9c:	c0 95       	brlt	8000cfae <_vfiprintf_r+0x34a>
8000cf9e:	c1 08       	rjmp	8000cfbe <_vfiprintf_r+0x35a>
8000cfa0:	fa f9 06 80 	ld.w	r9,sp[1664]
8000cfa4:	ec ca ff ff 	sub	r10,r6,-1
8000cfa8:	12 36       	cp.w	r6,r9
8000cfaa:	c1 f5       	brlt	8000cfe8 <_vfiprintf_r+0x384>
8000cfac:	c2 68       	rjmp	8000cff8 <_vfiprintf_r+0x394>
8000cfae:	fa c9 f9 78 	sub	r9,sp,-1672
8000cfb2:	10 97       	mov	r7,r8
8000cfb4:	f2 0b 00 3b 	add	r11,r9,r11<<0x3
8000cfb8:	f6 f2 fd a4 	ld.w	r2,r11[-604]
8000cfbc:	c3 58       	rjmp	8000d026 <_vfiprintf_r+0x3c2>
8000cfbe:	fa c7 f9 84 	sub	r7,sp,-1660
8000cfc2:	1a d7       	st.w	--sp,r7
8000cfc4:	10 97       	mov	r7,r8
8000cfc6:	fa c2 fa d0 	sub	r2,sp,-1328
8000cfca:	1a d2       	st.w	--sp,r2
8000cfcc:	fa c8 fb cc 	sub	r8,sp,-1076
8000cfd0:	02 9c       	mov	r12,r1
8000cfd2:	1a d8       	st.w	--sp,r8
8000cfd4:	fa c8 f9 74 	sub	r8,sp,-1676
8000cfd8:	fa c9 ff cc 	sub	r9,sp,-52
8000cfdc:	40 ba       	lddsp	r10,sp[0x2c]
8000cfde:	fe b0 fc a7 	rcall	8000c92c <get_arg>
8000cfe2:	2f dd       	sub	sp,-12
8000cfe4:	78 02       	ld.w	r2,r12[0x0]
8000cfe6:	c2 08       	rjmp	8000d026 <_vfiprintf_r+0x3c2>
8000cfe8:	fa ce f9 78 	sub	lr,sp,-1672
8000cfec:	14 96       	mov	r6,r10
8000cfee:	fc 04 00 38 	add	r8,lr,r4<<0x3
8000cff2:	f0 f2 fd a4 	ld.w	r2,r8[-604]
8000cff6:	c1 88       	rjmp	8000d026 <_vfiprintf_r+0x3c2>
8000cff8:	40 a8       	lddsp	r8,sp[0x28]
8000cffa:	59 f9       	cp.w	r9,31
8000cffc:	e0 89 00 11 	brgt	8000d01e <_vfiprintf_r+0x3ba>
8000d000:	f0 cb ff fc 	sub	r11,r8,-4
8000d004:	50 ab       	stdsp	sp[0x28],r11
8000d006:	70 02       	ld.w	r2,r8[0x0]
8000d008:	fa cc f9 78 	sub	r12,sp,-1672
8000d00c:	f8 09 00 38 	add	r8,r12,r9<<0x3
8000d010:	f1 42 fd a4 	st.w	r8[-604],r2
8000d014:	2f f9       	sub	r9,-1
8000d016:	14 96       	mov	r6,r10
8000d018:	fb 49 06 80 	st.w	sp[1664],r9
8000d01c:	c0 58       	rjmp	8000d026 <_vfiprintf_r+0x3c2>
8000d01e:	70 02       	ld.w	r2,r8[0x0]
8000d020:	14 96       	mov	r6,r10
8000d022:	2f c8       	sub	r8,-4
8000d024:	50 a8       	stdsp	sp[0x28],r8
8000d026:	58 02       	cp.w	r2,0
8000d028:	fe 94 fe f1 	brge	8000ce0a <_vfiprintf_r+0x1a6>
8000d02c:	5c 32       	neg	r2
8000d02e:	a3 a3       	sbr	r3,0x2
8000d030:	ce da       	rjmp	8000ce0a <_vfiprintf_r+0x1a6>
8000d032:	fb 68 06 87 	st.b	sp[1671],r8
8000d036:	ce aa       	rjmp	8000ce0a <_vfiprintf_r+0x1a6>
8000d038:	0f 38       	ld.ub	r8,r7++
8000d03a:	e0 48 00 2a 	cp.w	r8,42
8000d03e:	c0 50       	breq	8000d048 <_vfiprintf_r+0x3e4>
8000d040:	30 09       	mov	r9,0
8000d042:	c7 88       	rjmp	8000d132 <_vfiprintf_r+0x4ce>
8000d044:	80 01       	ld.sh	r1,r0[0x0]
8000d046:	68 b4       	ld.w	r4,r4[0x2c]
8000d048:	0f 88       	ld.ub	r8,r7[0x0]
8000d04a:	f0 c9 00 30 	sub	r9,r8,48
8000d04e:	58 99       	cp.w	r9,9
8000d050:	e0 8b 00 1e 	brhi	8000d08c <_vfiprintf_r+0x428>
8000d054:	ee c5 ff ff 	sub	r5,r7,-1
8000d058:	30 0b       	mov	r11,0
8000d05a:	23 08       	sub	r8,48
8000d05c:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000d060:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000d064:	0b 38       	ld.ub	r8,r5++
8000d066:	f0 c9 00 30 	sub	r9,r8,48
8000d06a:	58 99       	cp.w	r9,9
8000d06c:	fe 98 ff f7 	brls	8000d05a <_vfiprintf_r+0x3f6>
8000d070:	e0 48 00 24 	cp.w	r8,36
8000d074:	fe 91 fe ca 	brne	8000ce08 <_vfiprintf_r+0x1a4>
8000d078:	e0 4b 00 20 	cp.w	r11,32
8000d07c:	e0 89 09 3a 	brgt	8000e2f0 <_vfiprintf_r+0x168c>
8000d080:	20 1b       	sub	r11,1
8000d082:	fa f8 06 80 	ld.w	r8,sp[1664]
8000d086:	10 3b       	cp.w	r11,r8
8000d088:	c0 95       	brlt	8000d09a <_vfiprintf_r+0x436>
8000d08a:	c1 08       	rjmp	8000d0aa <_vfiprintf_r+0x446>
8000d08c:	fa f9 06 80 	ld.w	r9,sp[1664]
8000d090:	ec ca ff ff 	sub	r10,r6,-1
8000d094:	12 36       	cp.w	r6,r9
8000d096:	c1 f5       	brlt	8000d0d4 <_vfiprintf_r+0x470>
8000d098:	c2 88       	rjmp	8000d0e8 <_vfiprintf_r+0x484>
8000d09a:	fa ca f9 78 	sub	r10,sp,-1672
8000d09e:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000d0a2:	f6 fb fd a4 	ld.w	r11,r11[-604]
8000d0a6:	50 3b       	stdsp	sp[0xc],r11
8000d0a8:	c3 c8       	rjmp	8000d120 <_vfiprintf_r+0x4bc>
8000d0aa:	fa c9 f9 84 	sub	r9,sp,-1660
8000d0ae:	1a d9       	st.w	--sp,r9
8000d0b0:	fa c8 fa d0 	sub	r8,sp,-1328
8000d0b4:	1a d8       	st.w	--sp,r8
8000d0b6:	fa c8 fb cc 	sub	r8,sp,-1076
8000d0ba:	02 9c       	mov	r12,r1
8000d0bc:	1a d8       	st.w	--sp,r8
8000d0be:	fa c8 f9 74 	sub	r8,sp,-1676
8000d0c2:	fa c9 ff cc 	sub	r9,sp,-52
8000d0c6:	40 ba       	lddsp	r10,sp[0x2c]
8000d0c8:	fe b0 fc 32 	rcall	8000c92c <get_arg>
8000d0cc:	2f dd       	sub	sp,-12
8000d0ce:	78 0c       	ld.w	r12,r12[0x0]
8000d0d0:	50 3c       	stdsp	sp[0xc],r12
8000d0d2:	c2 78       	rjmp	8000d120 <_vfiprintf_r+0x4bc>
8000d0d4:	fa ce f9 78 	sub	lr,sp,-1672
8000d0d8:	0e 95       	mov	r5,r7
8000d0da:	fc 04 00 38 	add	r8,lr,r4<<0x3
8000d0de:	14 96       	mov	r6,r10
8000d0e0:	f0 f8 fd a4 	ld.w	r8,r8[-604]
8000d0e4:	50 38       	stdsp	sp[0xc],r8
8000d0e6:	c1 d8       	rjmp	8000d120 <_vfiprintf_r+0x4bc>
8000d0e8:	40 a8       	lddsp	r8,sp[0x28]
8000d0ea:	59 f9       	cp.w	r9,31
8000d0ec:	e0 89 00 14 	brgt	8000d114 <_vfiprintf_r+0x4b0>
8000d0f0:	f0 cb ff fc 	sub	r11,r8,-4
8000d0f4:	70 08       	ld.w	r8,r8[0x0]
8000d0f6:	50 ab       	stdsp	sp[0x28],r11
8000d0f8:	50 38       	stdsp	sp[0xc],r8
8000d0fa:	fa cc f9 78 	sub	r12,sp,-1672
8000d0fe:	40 3b       	lddsp	r11,sp[0xc]
8000d100:	f8 09 00 38 	add	r8,r12,r9<<0x3
8000d104:	f1 4b fd a4 	st.w	r8[-604],r11
8000d108:	2f f9       	sub	r9,-1
8000d10a:	0e 95       	mov	r5,r7
8000d10c:	fb 49 06 80 	st.w	sp[1664],r9
8000d110:	14 96       	mov	r6,r10
8000d112:	c0 78       	rjmp	8000d120 <_vfiprintf_r+0x4bc>
8000d114:	70 09       	ld.w	r9,r8[0x0]
8000d116:	0e 95       	mov	r5,r7
8000d118:	2f c8       	sub	r8,-4
8000d11a:	50 39       	stdsp	sp[0xc],r9
8000d11c:	14 96       	mov	r6,r10
8000d11e:	50 a8       	stdsp	sp[0x28],r8
8000d120:	40 38       	lddsp	r8,sp[0xc]
8000d122:	58 08       	cp.w	r8,0
8000d124:	fe 95 fe 6e 	brlt	8000ce00 <_vfiprintf_r+0x19c>
8000d128:	0a 97       	mov	r7,r5
8000d12a:	c7 0a       	rjmp	8000ce0a <_vfiprintf_r+0x1a6>
8000d12c:	f4 0b 00 19 	add	r9,r10,r11<<0x1
8000d130:	0f 38       	ld.ub	r8,r7++
8000d132:	f2 09 00 2b 	add	r11,r9,r9<<0x2
8000d136:	f0 ca 00 30 	sub	r10,r8,48
8000d13a:	58 9a       	cp.w	r10,9
8000d13c:	fe 98 ff f8 	brls	8000d12c <_vfiprintf_r+0x4c8>
8000d140:	3f fe       	mov	lr,-1
8000d142:	f2 0e 0c 49 	max	r9,r9,lr
8000d146:	50 39       	stdsp	sp[0xc],r9
8000d148:	c6 4a       	rjmp	8000ce10 <_vfiprintf_r+0x1ac>
8000d14a:	a7 b3       	sbr	r3,0x7
8000d14c:	c5 fa       	rjmp	8000ce0a <_vfiprintf_r+0x1a6>
8000d14e:	30 09       	mov	r9,0
8000d150:	23 08       	sub	r8,48
8000d152:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000d156:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000d15a:	0f 38       	ld.ub	r8,r7++
8000d15c:	f0 ca 00 30 	sub	r10,r8,48
8000d160:	58 9a       	cp.w	r10,9
8000d162:	fe 98 ff f7 	brls	8000d150 <_vfiprintf_r+0x4ec>
8000d166:	e0 48 00 24 	cp.w	r8,36
8000d16a:	fe 91 fe 52 	brne	8000ce0e <_vfiprintf_r+0x1aa>
8000d16e:	e0 49 00 20 	cp.w	r9,32
8000d172:	e0 89 08 bf 	brgt	8000e2f0 <_vfiprintf_r+0x168c>
8000d176:	f2 c4 00 01 	sub	r4,r9,1
8000d17a:	30 10       	mov	r0,1
8000d17c:	fe 9f fe 47 	bral	8000ce0a <_vfiprintf_r+0x1a6>
8000d180:	a7 a3       	sbr	r3,0x6
8000d182:	fe 9f fe 44 	bral	8000ce0a <_vfiprintf_r+0x1a6>
8000d186:	06 99       	mov	r9,r3
8000d188:	a5 b3       	sbr	r3,0x5
8000d18a:	a5 a9       	sbr	r9,0x4
8000d18c:	0f 8a       	ld.ub	r10,r7[0x0]
8000d18e:	f0 0a 18 00 	cp.b	r10,r8
8000d192:	f7 b7 00 ff 	subeq	r7,-1
8000d196:	f2 03 17 10 	movne	r3,r9
8000d19a:	fe 9f fe 38 	bral	8000ce0a <_vfiprintf_r+0x1a6>
8000d19e:	a5 b3       	sbr	r3,0x5
8000d1a0:	fe 9f fe 35 	bral	8000ce0a <_vfiprintf_r+0x1a6>
8000d1a4:	50 57       	stdsp	sp[0x14],r7
8000d1a6:	50 42       	stdsp	sp[0x10],r2
8000d1a8:	08 97       	mov	r7,r4
8000d1aa:	40 85       	lddsp	r5,sp[0x20]
8000d1ac:	40 74       	lddsp	r4,sp[0x1c]
8000d1ae:	0c 99       	mov	r9,r6
8000d1b0:	fa f8 06 80 	ld.w	r8,sp[1664]
8000d1b4:	58 00       	cp.w	r0,0
8000d1b6:	c1 d0       	breq	8000d1f0 <_vfiprintf_r+0x58c>
8000d1b8:	10 37       	cp.w	r7,r8
8000d1ba:	c0 64       	brge	8000d1c6 <_vfiprintf_r+0x562>
8000d1bc:	fa cc f9 78 	sub	r12,sp,-1672
8000d1c0:	f8 07 00 37 	add	r7,r12,r7<<0x3
8000d1c4:	c1 d8       	rjmp	8000d1fe <_vfiprintf_r+0x59a>
8000d1c6:	fa c8 f9 84 	sub	r8,sp,-1660
8000d1ca:	1a d8       	st.w	--sp,r8
8000d1cc:	fa c8 fa d0 	sub	r8,sp,-1328
8000d1d0:	1a d8       	st.w	--sp,r8
8000d1d2:	fa c8 fb cc 	sub	r8,sp,-1076
8000d1d6:	1a d8       	st.w	--sp,r8
8000d1d8:	fa c8 f9 74 	sub	r8,sp,-1676
8000d1dc:	fa c9 ff cc 	sub	r9,sp,-52
8000d1e0:	0a 9a       	mov	r10,r5
8000d1e2:	0e 9b       	mov	r11,r7
8000d1e4:	02 9c       	mov	r12,r1
8000d1e6:	fe b0 fb a3 	rcall	8000c92c <get_arg>
8000d1ea:	2f dd       	sub	sp,-12
8000d1ec:	19 b8       	ld.ub	r8,r12[0x3]
8000d1ee:	c2 28       	rjmp	8000d232 <_vfiprintf_r+0x5ce>
8000d1f0:	2f f6       	sub	r6,-1
8000d1f2:	10 39       	cp.w	r9,r8
8000d1f4:	c0 84       	brge	8000d204 <_vfiprintf_r+0x5a0>
8000d1f6:	fa cb f9 78 	sub	r11,sp,-1672
8000d1fa:	f6 07 00 37 	add	r7,r11,r7<<0x3
8000d1fe:	ef 38 fd a7 	ld.ub	r8,r7[-601]
8000d202:	c1 88       	rjmp	8000d232 <_vfiprintf_r+0x5ce>
8000d204:	40 a9       	lddsp	r9,sp[0x28]
8000d206:	59 f8       	cp.w	r8,31
8000d208:	e0 89 00 12 	brgt	8000d22c <_vfiprintf_r+0x5c8>
8000d20c:	f2 ca ff fc 	sub	r10,r9,-4
8000d210:	50 aa       	stdsp	sp[0x28],r10
8000d212:	72 09       	ld.w	r9,r9[0x0]
8000d214:	fa c2 f9 78 	sub	r2,sp,-1672
8000d218:	e4 08 00 3a 	add	r10,r2,r8<<0x3
8000d21c:	2f f8       	sub	r8,-1
8000d21e:	f5 49 fd a4 	st.w	r10[-604],r9
8000d222:	fb 48 06 80 	st.w	sp[1664],r8
8000d226:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000d22a:	c0 48       	rjmp	8000d232 <_vfiprintf_r+0x5ce>
8000d22c:	13 b8       	ld.ub	r8,r9[0x3]
8000d22e:	2f c9       	sub	r9,-4
8000d230:	50 a9       	stdsp	sp[0x28],r9
8000d232:	30 0e       	mov	lr,0
8000d234:	fb 68 06 48 	st.b	sp[1608],r8
8000d238:	fb 6e 06 87 	st.b	sp[1671],lr
8000d23c:	e0 8f 06 a4 	bral	8000df84 <_vfiprintf_r+0x1320>
8000d240:	a5 a3       	sbr	r3,0x4
8000d242:	0c 92       	mov	r2,r6
8000d244:	ed b3 00 05 	bld	r3,0x5
8000d248:	c4 d1       	brne	8000d2e2 <_vfiprintf_r+0x67e>
8000d24a:	fa f8 06 80 	ld.w	r8,sp[1664]
8000d24e:	58 00       	cp.w	r0,0
8000d250:	c1 e0       	breq	8000d28c <_vfiprintf_r+0x628>
8000d252:	10 37       	cp.w	r7,r8
8000d254:	c0 64       	brge	8000d260 <_vfiprintf_r+0x5fc>
8000d256:	fa cc f9 78 	sub	r12,sp,-1672
8000d25a:	f8 07 00 37 	add	r7,r12,r7<<0x3
8000d25e:	c1 f8       	rjmp	8000d29c <_vfiprintf_r+0x638>
8000d260:	fa c8 f9 84 	sub	r8,sp,-1660
8000d264:	1a d8       	st.w	--sp,r8
8000d266:	fa c8 fa d0 	sub	r8,sp,-1328
8000d26a:	0a 9a       	mov	r10,r5
8000d26c:	1a d8       	st.w	--sp,r8
8000d26e:	fa c8 fb cc 	sub	r8,sp,-1076
8000d272:	1a d8       	st.w	--sp,r8
8000d274:	fa c9 ff cc 	sub	r9,sp,-52
8000d278:	fa c8 f9 74 	sub	r8,sp,-1676
8000d27c:	0e 9b       	mov	r11,r7
8000d27e:	02 9c       	mov	r12,r1
8000d280:	fe b0 fb 56 	rcall	8000c92c <get_arg>
8000d284:	2f dd       	sub	sp,-12
8000d286:	78 1a       	ld.w	r10,r12[0x4]
8000d288:	78 09       	ld.w	r9,r12[0x0]
8000d28a:	c2 88       	rjmp	8000d2da <_vfiprintf_r+0x676>
8000d28c:	ec c2 ff ff 	sub	r2,r6,-1
8000d290:	10 36       	cp.w	r6,r8
8000d292:	c0 a4       	brge	8000d2a6 <_vfiprintf_r+0x642>
8000d294:	fa cb f9 78 	sub	r11,sp,-1672
8000d298:	f6 07 00 37 	add	r7,r11,r7<<0x3
8000d29c:	ee fa fd a8 	ld.w	r10,r7[-600]
8000d2a0:	ee f9 fd a4 	ld.w	r9,r7[-604]
8000d2a4:	c1 b8       	rjmp	8000d2da <_vfiprintf_r+0x676>
8000d2a6:	40 a9       	lddsp	r9,sp[0x28]
8000d2a8:	59 f8       	cp.w	r8,31
8000d2aa:	e0 89 00 13 	brgt	8000d2d0 <_vfiprintf_r+0x66c>
8000d2ae:	f2 ca ff f8 	sub	r10,r9,-8
8000d2b2:	50 aa       	stdsp	sp[0x28],r10
8000d2b4:	fa c6 f9 78 	sub	r6,sp,-1672
8000d2b8:	72 1a       	ld.w	r10,r9[0x4]
8000d2ba:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000d2be:	72 09       	ld.w	r9,r9[0x0]
8000d2c0:	f7 4a fd a8 	st.w	r11[-600],r10
8000d2c4:	f7 49 fd a4 	st.w	r11[-604],r9
8000d2c8:	2f f8       	sub	r8,-1
8000d2ca:	fb 48 06 80 	st.w	sp[1664],r8
8000d2ce:	c0 68       	rjmp	8000d2da <_vfiprintf_r+0x676>
8000d2d0:	f2 c8 ff f8 	sub	r8,r9,-8
8000d2d4:	72 1a       	ld.w	r10,r9[0x4]
8000d2d6:	50 a8       	stdsp	sp[0x28],r8
8000d2d8:	72 09       	ld.w	r9,r9[0x0]
8000d2da:	04 96       	mov	r6,r2
8000d2dc:	50 09       	stdsp	sp[0x0],r9
8000d2de:	50 1a       	stdsp	sp[0x4],r10
8000d2e0:	cd 58       	rjmp	8000d48a <_vfiprintf_r+0x826>
8000d2e2:	ed b3 00 04 	bld	r3,0x4
8000d2e6:	c4 41       	brne	8000d36e <_vfiprintf_r+0x70a>
8000d2e8:	fa f8 06 80 	ld.w	r8,sp[1664]
8000d2ec:	58 00       	cp.w	r0,0
8000d2ee:	c1 d0       	breq	8000d328 <_vfiprintf_r+0x6c4>
8000d2f0:	10 37       	cp.w	r7,r8
8000d2f2:	c0 64       	brge	8000d2fe <_vfiprintf_r+0x69a>
8000d2f4:	fa ce f9 78 	sub	lr,sp,-1672
8000d2f8:	fc 07 00 37 	add	r7,lr,r7<<0x3
8000d2fc:	c1 e8       	rjmp	8000d338 <_vfiprintf_r+0x6d4>
8000d2fe:	fa c8 f9 84 	sub	r8,sp,-1660
8000d302:	1a d8       	st.w	--sp,r8
8000d304:	fa c8 fa d0 	sub	r8,sp,-1328
8000d308:	0a 9a       	mov	r10,r5
8000d30a:	1a d8       	st.w	--sp,r8
8000d30c:	fa c8 fb cc 	sub	r8,sp,-1076
8000d310:	0e 9b       	mov	r11,r7
8000d312:	1a d8       	st.w	--sp,r8
8000d314:	02 9c       	mov	r12,r1
8000d316:	fa c8 f9 74 	sub	r8,sp,-1676
8000d31a:	fa c9 ff cc 	sub	r9,sp,-52
8000d31e:	fe b0 fb 07 	rcall	8000c92c <get_arg>
8000d322:	2f dd       	sub	sp,-12
8000d324:	78 0a       	ld.w	r10,r12[0x0]
8000d326:	c2 18       	rjmp	8000d368 <_vfiprintf_r+0x704>
8000d328:	ec c2 ff ff 	sub	r2,r6,-1
8000d32c:	10 36       	cp.w	r6,r8
8000d32e:	c0 84       	brge	8000d33e <_vfiprintf_r+0x6da>
8000d330:	fa cc f9 78 	sub	r12,sp,-1672
8000d334:	f8 07 00 37 	add	r7,r12,r7<<0x3
8000d338:	ee fa fd a4 	ld.w	r10,r7[-604]
8000d33c:	c1 68       	rjmp	8000d368 <_vfiprintf_r+0x704>
8000d33e:	40 a9       	lddsp	r9,sp[0x28]
8000d340:	59 f8       	cp.w	r8,31
8000d342:	e0 89 00 10 	brgt	8000d362 <_vfiprintf_r+0x6fe>
8000d346:	f2 ca ff fc 	sub	r10,r9,-4
8000d34a:	50 aa       	stdsp	sp[0x28],r10
8000d34c:	fa cb f9 78 	sub	r11,sp,-1672
8000d350:	72 0a       	ld.w	r10,r9[0x0]
8000d352:	f6 08 00 39 	add	r9,r11,r8<<0x3
8000d356:	f3 4a fd a4 	st.w	r9[-604],r10
8000d35a:	2f f8       	sub	r8,-1
8000d35c:	fb 48 06 80 	st.w	sp[1664],r8
8000d360:	c0 48       	rjmp	8000d368 <_vfiprintf_r+0x704>
8000d362:	72 0a       	ld.w	r10,r9[0x0]
8000d364:	2f c9       	sub	r9,-4
8000d366:	50 a9       	stdsp	sp[0x28],r9
8000d368:	04 96       	mov	r6,r2
8000d36a:	50 1a       	stdsp	sp[0x4],r10
8000d36c:	c8 d8       	rjmp	8000d486 <_vfiprintf_r+0x822>
8000d36e:	ed b3 00 06 	bld	r3,0x6
8000d372:	c4 81       	brne	8000d402 <_vfiprintf_r+0x79e>
8000d374:	fa f8 06 80 	ld.w	r8,sp[1664]
8000d378:	58 00       	cp.w	r0,0
8000d37a:	c1 d0       	breq	8000d3b4 <_vfiprintf_r+0x750>
8000d37c:	10 37       	cp.w	r7,r8
8000d37e:	c0 64       	brge	8000d38a <_vfiprintf_r+0x726>
8000d380:	fa c8 f9 78 	sub	r8,sp,-1672
8000d384:	f0 07 00 37 	add	r7,r8,r7<<0x3
8000d388:	c1 e8       	rjmp	8000d3c4 <_vfiprintf_r+0x760>
8000d38a:	fa c8 f9 84 	sub	r8,sp,-1660
8000d38e:	1a d8       	st.w	--sp,r8
8000d390:	fa c8 fa d0 	sub	r8,sp,-1328
8000d394:	1a d8       	st.w	--sp,r8
8000d396:	fa c8 fb cc 	sub	r8,sp,-1076
8000d39a:	1a d8       	st.w	--sp,r8
8000d39c:	fa c8 f9 74 	sub	r8,sp,-1676
8000d3a0:	fa c9 ff cc 	sub	r9,sp,-52
8000d3a4:	0a 9a       	mov	r10,r5
8000d3a6:	0e 9b       	mov	r11,r7
8000d3a8:	02 9c       	mov	r12,r1
8000d3aa:	fe b0 fa c1 	rcall	8000c92c <get_arg>
8000d3ae:	2f dd       	sub	sp,-12
8000d3b0:	98 18       	ld.sh	r8,r12[0x2]
8000d3b2:	c2 38       	rjmp	8000d3f8 <_vfiprintf_r+0x794>
8000d3b4:	ec c2 ff ff 	sub	r2,r6,-1
8000d3b8:	10 36       	cp.w	r6,r8
8000d3ba:	c0 84       	brge	8000d3ca <_vfiprintf_r+0x766>
8000d3bc:	fa c6 f9 78 	sub	r6,sp,-1672
8000d3c0:	ec 07 00 37 	add	r7,r6,r7<<0x3
8000d3c4:	ef 08 fd a6 	ld.sh	r8,r7[-602]
8000d3c8:	c1 88       	rjmp	8000d3f8 <_vfiprintf_r+0x794>
8000d3ca:	40 a9       	lddsp	r9,sp[0x28]
8000d3cc:	59 f8       	cp.w	r8,31
8000d3ce:	e0 89 00 12 	brgt	8000d3f2 <_vfiprintf_r+0x78e>
8000d3d2:	f2 ca ff fc 	sub	r10,r9,-4
8000d3d6:	50 aa       	stdsp	sp[0x28],r10
8000d3d8:	72 09       	ld.w	r9,r9[0x0]
8000d3da:	fa ce f9 78 	sub	lr,sp,-1672
8000d3de:	fc 08 00 3a 	add	r10,lr,r8<<0x3
8000d3e2:	2f f8       	sub	r8,-1
8000d3e4:	f5 49 fd a4 	st.w	r10[-604],r9
8000d3e8:	fb 48 06 80 	st.w	sp[1664],r8
8000d3ec:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000d3f0:	c0 48       	rjmp	8000d3f8 <_vfiprintf_r+0x794>
8000d3f2:	92 18       	ld.sh	r8,r9[0x2]
8000d3f4:	2f c9       	sub	r9,-4
8000d3f6:	50 a9       	stdsp	sp[0x28],r9
8000d3f8:	50 18       	stdsp	sp[0x4],r8
8000d3fa:	04 96       	mov	r6,r2
8000d3fc:	bf 58       	asr	r8,0x1f
8000d3fe:	50 08       	stdsp	sp[0x0],r8
8000d400:	c4 58       	rjmp	8000d48a <_vfiprintf_r+0x826>
8000d402:	fa f8 06 80 	ld.w	r8,sp[1664]
8000d406:	58 00       	cp.w	r0,0
8000d408:	c1 d0       	breq	8000d442 <_vfiprintf_r+0x7de>
8000d40a:	10 37       	cp.w	r7,r8
8000d40c:	c0 64       	brge	8000d418 <_vfiprintf_r+0x7b4>
8000d40e:	fa cb f9 78 	sub	r11,sp,-1672
8000d412:	f6 07 00 37 	add	r7,r11,r7<<0x3
8000d416:	c1 e8       	rjmp	8000d452 <_vfiprintf_r+0x7ee>
8000d418:	fa c8 f9 84 	sub	r8,sp,-1660
8000d41c:	1a d8       	st.w	--sp,r8
8000d41e:	fa c8 fa d0 	sub	r8,sp,-1328
8000d422:	0a 9a       	mov	r10,r5
8000d424:	1a d8       	st.w	--sp,r8
8000d426:	fa c8 fb cc 	sub	r8,sp,-1076
8000d42a:	0e 9b       	mov	r11,r7
8000d42c:	1a d8       	st.w	--sp,r8
8000d42e:	02 9c       	mov	r12,r1
8000d430:	fa c8 f9 74 	sub	r8,sp,-1676
8000d434:	fa c9 ff cc 	sub	r9,sp,-52
8000d438:	fe b0 fa 7a 	rcall	8000c92c <get_arg>
8000d43c:	2f dd       	sub	sp,-12
8000d43e:	78 0a       	ld.w	r10,r12[0x0]
8000d440:	c2 18       	rjmp	8000d482 <_vfiprintf_r+0x81e>
8000d442:	ec c2 ff ff 	sub	r2,r6,-1
8000d446:	10 36       	cp.w	r6,r8
8000d448:	c0 84       	brge	8000d458 <_vfiprintf_r+0x7f4>
8000d44a:	fa ca f9 78 	sub	r10,sp,-1672
8000d44e:	f4 07 00 37 	add	r7,r10,r7<<0x3
8000d452:	ee fa fd a4 	ld.w	r10,r7[-604]
8000d456:	c1 68       	rjmp	8000d482 <_vfiprintf_r+0x81e>
8000d458:	40 a9       	lddsp	r9,sp[0x28]
8000d45a:	59 f8       	cp.w	r8,31
8000d45c:	e0 89 00 10 	brgt	8000d47c <_vfiprintf_r+0x818>
8000d460:	f2 ca ff fc 	sub	r10,r9,-4
8000d464:	50 aa       	stdsp	sp[0x28],r10
8000d466:	fa c6 f9 78 	sub	r6,sp,-1672
8000d46a:	72 0a       	ld.w	r10,r9[0x0]
8000d46c:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000d470:	f3 4a fd a4 	st.w	r9[-604],r10
8000d474:	2f f8       	sub	r8,-1
8000d476:	fb 48 06 80 	st.w	sp[1664],r8
8000d47a:	c0 48       	rjmp	8000d482 <_vfiprintf_r+0x81e>
8000d47c:	72 0a       	ld.w	r10,r9[0x0]
8000d47e:	2f c9       	sub	r9,-4
8000d480:	50 a9       	stdsp	sp[0x28],r9
8000d482:	04 96       	mov	r6,r2
8000d484:	50 1a       	stdsp	sp[0x4],r10
8000d486:	bf 5a       	asr	r10,0x1f
8000d488:	50 0a       	stdsp	sp[0x0],r10
8000d48a:	fa ea 00 00 	ld.d	r10,sp[0]
8000d48e:	58 0a       	cp.w	r10,0
8000d490:	5c 2b       	cpc	r11
8000d492:	c0 e4       	brge	8000d4ae <_vfiprintf_r+0x84a>
8000d494:	30 08       	mov	r8,0
8000d496:	fa ea 00 00 	ld.d	r10,sp[0]
8000d49a:	30 09       	mov	r9,0
8000d49c:	f0 0a 01 0a 	sub	r10,r8,r10
8000d4a0:	f2 0b 01 4b 	sbc	r11,r9,r11
8000d4a4:	32 d8       	mov	r8,45
8000d4a6:	fa eb 00 00 	st.d	sp[0],r10
8000d4aa:	fb 68 06 87 	st.b	sp[1671],r8
8000d4ae:	30 10       	mov	r0,1
8000d4b0:	e0 8f 04 de 	bral	8000de6c <_vfiprintf_r+0x1208>
8000d4b4:	0c 99       	mov	r9,r6
8000d4b6:	ed b3 00 05 	bld	r3,0x5
8000d4ba:	c4 71       	brne	8000d548 <_vfiprintf_r+0x8e4>
8000d4bc:	fa f8 06 80 	ld.w	r8,sp[1664]
8000d4c0:	58 00       	cp.w	r0,0
8000d4c2:	c1 d0       	breq	8000d4fc <_vfiprintf_r+0x898>
8000d4c4:	10 37       	cp.w	r7,r8
8000d4c6:	c0 64       	brge	8000d4d2 <_vfiprintf_r+0x86e>
8000d4c8:	fa ca f9 78 	sub	r10,sp,-1672
8000d4cc:	f4 07 00 37 	add	r7,r10,r7<<0x3
8000d4d0:	c1 d8       	rjmp	8000d50a <_vfiprintf_r+0x8a6>
8000d4d2:	fa c8 f9 84 	sub	r8,sp,-1660
8000d4d6:	1a d8       	st.w	--sp,r8
8000d4d8:	fa c8 fa d0 	sub	r8,sp,-1328
8000d4dc:	0a 9a       	mov	r10,r5
8000d4de:	1a d8       	st.w	--sp,r8
8000d4e0:	fa c8 fb cc 	sub	r8,sp,-1076
8000d4e4:	0e 9b       	mov	r11,r7
8000d4e6:	1a d8       	st.w	--sp,r8
8000d4e8:	02 9c       	mov	r12,r1
8000d4ea:	fa c8 f9 74 	sub	r8,sp,-1676
8000d4ee:	fa c9 ff cc 	sub	r9,sp,-52
8000d4f2:	fe b0 fa 1d 	rcall	8000c92c <get_arg>
8000d4f6:	2f dd       	sub	sp,-12
8000d4f8:	78 0a       	ld.w	r10,r12[0x0]
8000d4fa:	c2 08       	rjmp	8000d53a <_vfiprintf_r+0x8d6>
8000d4fc:	2f f6       	sub	r6,-1
8000d4fe:	10 39       	cp.w	r9,r8
8000d500:	c0 84       	brge	8000d510 <_vfiprintf_r+0x8ac>
8000d502:	fa c9 f9 78 	sub	r9,sp,-1672
8000d506:	f2 07 00 37 	add	r7,r9,r7<<0x3
8000d50a:	ee fa fd a4 	ld.w	r10,r7[-604]
8000d50e:	c1 68       	rjmp	8000d53a <_vfiprintf_r+0x8d6>
8000d510:	40 a9       	lddsp	r9,sp[0x28]
8000d512:	59 f8       	cp.w	r8,31
8000d514:	e0 89 00 10 	brgt	8000d534 <_vfiprintf_r+0x8d0>
8000d518:	f2 ca ff fc 	sub	r10,r9,-4
8000d51c:	50 aa       	stdsp	sp[0x28],r10
8000d51e:	fa c3 f9 78 	sub	r3,sp,-1672
8000d522:	72 0a       	ld.w	r10,r9[0x0]
8000d524:	e6 08 00 39 	add	r9,r3,r8<<0x3
8000d528:	f3 4a fd a4 	st.w	r9[-604],r10
8000d52c:	2f f8       	sub	r8,-1
8000d52e:	fb 48 06 80 	st.w	sp[1664],r8
8000d532:	c0 48       	rjmp	8000d53a <_vfiprintf_r+0x8d6>
8000d534:	72 0a       	ld.w	r10,r9[0x0]
8000d536:	2f c9       	sub	r9,-4
8000d538:	50 a9       	stdsp	sp[0x28],r9
8000d53a:	40 62       	lddsp	r2,sp[0x18]
8000d53c:	04 98       	mov	r8,r2
8000d53e:	95 12       	st.w	r10[0x4],r2
8000d540:	bf 58       	asr	r8,0x1f
8000d542:	95 08       	st.w	r10[0x0],r8
8000d544:	fe 9f fc 11 	bral	8000cd66 <_vfiprintf_r+0x102>
8000d548:	ed b3 00 04 	bld	r3,0x4
8000d54c:	c4 41       	brne	8000d5d4 <_vfiprintf_r+0x970>
8000d54e:	fa f8 06 80 	ld.w	r8,sp[1664]
8000d552:	58 00       	cp.w	r0,0
8000d554:	c1 d0       	breq	8000d58e <_vfiprintf_r+0x92a>
8000d556:	10 37       	cp.w	r7,r8
8000d558:	c0 64       	brge	8000d564 <_vfiprintf_r+0x900>
8000d55a:	fa ce f9 78 	sub	lr,sp,-1672
8000d55e:	fc 07 00 37 	add	r7,lr,r7<<0x3
8000d562:	c1 d8       	rjmp	8000d59c <_vfiprintf_r+0x938>
8000d564:	fa c8 f9 84 	sub	r8,sp,-1660
8000d568:	1a d8       	st.w	--sp,r8
8000d56a:	fa c8 fa d0 	sub	r8,sp,-1328
8000d56e:	0a 9a       	mov	r10,r5
8000d570:	1a d8       	st.w	--sp,r8
8000d572:	fa c8 fb cc 	sub	r8,sp,-1076
8000d576:	0e 9b       	mov	r11,r7
8000d578:	1a d8       	st.w	--sp,r8
8000d57a:	02 9c       	mov	r12,r1
8000d57c:	fa c8 f9 74 	sub	r8,sp,-1676
8000d580:	fa c9 ff cc 	sub	r9,sp,-52
8000d584:	fe b0 f9 d4 	rcall	8000c92c <get_arg>
8000d588:	2f dd       	sub	sp,-12
8000d58a:	78 0a       	ld.w	r10,r12[0x0]
8000d58c:	c2 08       	rjmp	8000d5cc <_vfiprintf_r+0x968>
8000d58e:	2f f6       	sub	r6,-1
8000d590:	10 39       	cp.w	r9,r8
8000d592:	c0 84       	brge	8000d5a2 <_vfiprintf_r+0x93e>
8000d594:	fa cc f9 78 	sub	r12,sp,-1672
8000d598:	f8 07 00 37 	add	r7,r12,r7<<0x3
8000d59c:	ee fa fd a4 	ld.w	r10,r7[-604]
8000d5a0:	c1 68       	rjmp	8000d5cc <_vfiprintf_r+0x968>
8000d5a2:	40 a9       	lddsp	r9,sp[0x28]
8000d5a4:	59 f8       	cp.w	r8,31
8000d5a6:	e0 89 00 10 	brgt	8000d5c6 <_vfiprintf_r+0x962>
8000d5aa:	f2 ca ff fc 	sub	r10,r9,-4
8000d5ae:	50 aa       	stdsp	sp[0x28],r10
8000d5b0:	fa cb f9 78 	sub	r11,sp,-1672
8000d5b4:	72 0a       	ld.w	r10,r9[0x0]
8000d5b6:	f6 08 00 39 	add	r9,r11,r8<<0x3
8000d5ba:	f3 4a fd a4 	st.w	r9[-604],r10
8000d5be:	2f f8       	sub	r8,-1
8000d5c0:	fb 48 06 80 	st.w	sp[1664],r8
8000d5c4:	c0 48       	rjmp	8000d5cc <_vfiprintf_r+0x968>
8000d5c6:	72 0a       	ld.w	r10,r9[0x0]
8000d5c8:	2f c9       	sub	r9,-4
8000d5ca:	50 a9       	stdsp	sp[0x28],r9
8000d5cc:	40 69       	lddsp	r9,sp[0x18]
8000d5ce:	95 09       	st.w	r10[0x0],r9
8000d5d0:	fe 9f fb cb 	bral	8000cd66 <_vfiprintf_r+0x102>
8000d5d4:	e2 13 00 40 	andl	r3,0x40,COH
8000d5d8:	c4 40       	breq	8000d660 <_vfiprintf_r+0x9fc>
8000d5da:	fa f8 06 80 	ld.w	r8,sp[1664]
8000d5de:	58 00       	cp.w	r0,0
8000d5e0:	c1 d0       	breq	8000d61a <_vfiprintf_r+0x9b6>
8000d5e2:	10 37       	cp.w	r7,r8
8000d5e4:	c0 64       	brge	8000d5f0 <_vfiprintf_r+0x98c>
8000d5e6:	fa c8 f9 78 	sub	r8,sp,-1672
8000d5ea:	f0 07 00 37 	add	r7,r8,r7<<0x3
8000d5ee:	c1 d8       	rjmp	8000d628 <_vfiprintf_r+0x9c4>
8000d5f0:	fa c8 f9 84 	sub	r8,sp,-1660
8000d5f4:	1a d8       	st.w	--sp,r8
8000d5f6:	fa c8 fa d0 	sub	r8,sp,-1328
8000d5fa:	0a 9a       	mov	r10,r5
8000d5fc:	1a d8       	st.w	--sp,r8
8000d5fe:	fa c8 fb cc 	sub	r8,sp,-1076
8000d602:	0e 9b       	mov	r11,r7
8000d604:	1a d8       	st.w	--sp,r8
8000d606:	02 9c       	mov	r12,r1
8000d608:	fa c8 f9 74 	sub	r8,sp,-1676
8000d60c:	fa c9 ff cc 	sub	r9,sp,-52
8000d610:	fe b0 f9 8e 	rcall	8000c92c <get_arg>
8000d614:	2f dd       	sub	sp,-12
8000d616:	78 0a       	ld.w	r10,r12[0x0]
8000d618:	c2 08       	rjmp	8000d658 <_vfiprintf_r+0x9f4>
8000d61a:	2f f6       	sub	r6,-1
8000d61c:	10 39       	cp.w	r9,r8
8000d61e:	c0 84       	brge	8000d62e <_vfiprintf_r+0x9ca>
8000d620:	fa c3 f9 78 	sub	r3,sp,-1672
8000d624:	e6 07 00 37 	add	r7,r3,r7<<0x3
8000d628:	ee fa fd a4 	ld.w	r10,r7[-604]
8000d62c:	c1 68       	rjmp	8000d658 <_vfiprintf_r+0x9f4>
8000d62e:	40 a9       	lddsp	r9,sp[0x28]
8000d630:	59 f8       	cp.w	r8,31
8000d632:	e0 89 00 10 	brgt	8000d652 <_vfiprintf_r+0x9ee>
8000d636:	f2 ca ff fc 	sub	r10,r9,-4
8000d63a:	50 aa       	stdsp	sp[0x28],r10
8000d63c:	fa c2 f9 78 	sub	r2,sp,-1672
8000d640:	72 0a       	ld.w	r10,r9[0x0]
8000d642:	e4 08 00 39 	add	r9,r2,r8<<0x3
8000d646:	f3 4a fd a4 	st.w	r9[-604],r10
8000d64a:	2f f8       	sub	r8,-1
8000d64c:	fb 48 06 80 	st.w	sp[1664],r8
8000d650:	c0 48       	rjmp	8000d658 <_vfiprintf_r+0x9f4>
8000d652:	72 0a       	ld.w	r10,r9[0x0]
8000d654:	2f c9       	sub	r9,-4
8000d656:	50 a9       	stdsp	sp[0x28],r9
8000d658:	40 6e       	lddsp	lr,sp[0x18]
8000d65a:	b4 0e       	st.h	r10[0x0],lr
8000d65c:	fe 9f fb 85 	bral	8000cd66 <_vfiprintf_r+0x102>
8000d660:	fa f8 06 80 	ld.w	r8,sp[1664]
8000d664:	58 00       	cp.w	r0,0
8000d666:	c1 d0       	breq	8000d6a0 <_vfiprintf_r+0xa3c>
8000d668:	10 37       	cp.w	r7,r8
8000d66a:	c0 64       	brge	8000d676 <_vfiprintf_r+0xa12>
8000d66c:	fa cc f9 78 	sub	r12,sp,-1672
8000d670:	f8 07 00 37 	add	r7,r12,r7<<0x3
8000d674:	c1 d8       	rjmp	8000d6ae <_vfiprintf_r+0xa4a>
8000d676:	fa c8 f9 84 	sub	r8,sp,-1660
8000d67a:	1a d8       	st.w	--sp,r8
8000d67c:	fa c8 fa d0 	sub	r8,sp,-1328
8000d680:	0a 9a       	mov	r10,r5
8000d682:	1a d8       	st.w	--sp,r8
8000d684:	fa c8 fb cc 	sub	r8,sp,-1076
8000d688:	0e 9b       	mov	r11,r7
8000d68a:	1a d8       	st.w	--sp,r8
8000d68c:	02 9c       	mov	r12,r1
8000d68e:	fa c8 f9 74 	sub	r8,sp,-1676
8000d692:	fa c9 ff cc 	sub	r9,sp,-52
8000d696:	fe b0 f9 4b 	rcall	8000c92c <get_arg>
8000d69a:	2f dd       	sub	sp,-12
8000d69c:	78 0a       	ld.w	r10,r12[0x0]
8000d69e:	c2 08       	rjmp	8000d6de <_vfiprintf_r+0xa7a>
8000d6a0:	2f f6       	sub	r6,-1
8000d6a2:	10 39       	cp.w	r9,r8
8000d6a4:	c0 84       	brge	8000d6b4 <_vfiprintf_r+0xa50>
8000d6a6:	fa cb f9 78 	sub	r11,sp,-1672
8000d6aa:	f6 07 00 37 	add	r7,r11,r7<<0x3
8000d6ae:	ee fa fd a4 	ld.w	r10,r7[-604]
8000d6b2:	c1 68       	rjmp	8000d6de <_vfiprintf_r+0xa7a>
8000d6b4:	40 a9       	lddsp	r9,sp[0x28]
8000d6b6:	59 f8       	cp.w	r8,31
8000d6b8:	e0 89 00 10 	brgt	8000d6d8 <_vfiprintf_r+0xa74>
8000d6bc:	f2 ca ff fc 	sub	r10,r9,-4
8000d6c0:	50 aa       	stdsp	sp[0x28],r10
8000d6c2:	fa c3 f9 78 	sub	r3,sp,-1672
8000d6c6:	72 0a       	ld.w	r10,r9[0x0]
8000d6c8:	e6 08 00 39 	add	r9,r3,r8<<0x3
8000d6cc:	f3 4a fd a4 	st.w	r9[-604],r10
8000d6d0:	2f f8       	sub	r8,-1
8000d6d2:	fb 48 06 80 	st.w	sp[1664],r8
8000d6d6:	c0 48       	rjmp	8000d6de <_vfiprintf_r+0xa7a>
8000d6d8:	72 0a       	ld.w	r10,r9[0x0]
8000d6da:	2f c9       	sub	r9,-4
8000d6dc:	50 a9       	stdsp	sp[0x28],r9
8000d6de:	40 62       	lddsp	r2,sp[0x18]
8000d6e0:	95 02       	st.w	r10[0x0],r2
8000d6e2:	fe 9f fb 42 	bral	8000cd66 <_vfiprintf_r+0x102>
8000d6e6:	a5 a3       	sbr	r3,0x4
8000d6e8:	0c 99       	mov	r9,r6
8000d6ea:	ed b3 00 05 	bld	r3,0x5
8000d6ee:	c5 71       	brne	8000d79c <_vfiprintf_r+0xb38>
8000d6f0:	fa f8 06 80 	ld.w	r8,sp[1664]
8000d6f4:	58 00       	cp.w	r0,0
8000d6f6:	c2 60       	breq	8000d742 <_vfiprintf_r+0xade>
8000d6f8:	10 37       	cp.w	r7,r8
8000d6fa:	c0 a4       	brge	8000d70e <_vfiprintf_r+0xaaa>
8000d6fc:	fa ce f9 78 	sub	lr,sp,-1672
8000d700:	fc 07 00 37 	add	r7,lr,r7<<0x3
8000d704:	ee ea fd a4 	ld.d	r10,r7[-604]
8000d708:	fa eb 00 00 	st.d	sp[0],r10
8000d70c:	c1 88       	rjmp	8000d73c <_vfiprintf_r+0xad8>
8000d70e:	fa c8 f9 84 	sub	r8,sp,-1660
8000d712:	1a d8       	st.w	--sp,r8
8000d714:	fa c8 fa d0 	sub	r8,sp,-1328
8000d718:	1a d8       	st.w	--sp,r8
8000d71a:	fa c8 fb cc 	sub	r8,sp,-1076
8000d71e:	1a d8       	st.w	--sp,r8
8000d720:	fa c8 f9 74 	sub	r8,sp,-1676
8000d724:	fa c9 ff cc 	sub	r9,sp,-52
8000d728:	0a 9a       	mov	r10,r5
8000d72a:	0e 9b       	mov	r11,r7
8000d72c:	02 9c       	mov	r12,r1
8000d72e:	fe b0 f8 ff 	rcall	8000c92c <get_arg>
8000d732:	2f dd       	sub	sp,-12
8000d734:	f8 e8 00 00 	ld.d	r8,r12[0]
8000d738:	fa e9 00 00 	st.d	sp[0],r8
8000d73c:	30 00       	mov	r0,0
8000d73e:	e0 8f 03 94 	bral	8000de66 <_vfiprintf_r+0x1202>
8000d742:	2f f6       	sub	r6,-1
8000d744:	10 39       	cp.w	r9,r8
8000d746:	c0 b4       	brge	8000d75c <_vfiprintf_r+0xaf8>
8000d748:	fa c8 f9 78 	sub	r8,sp,-1672
8000d74c:	f0 07 00 37 	add	r7,r8,r7<<0x3
8000d750:	ee ea fd a4 	ld.d	r10,r7[-604]
8000d754:	fa eb 00 00 	st.d	sp[0],r10
8000d758:	e0 8f 03 87 	bral	8000de66 <_vfiprintf_r+0x1202>
8000d75c:	40 a9       	lddsp	r9,sp[0x28]
8000d75e:	59 f8       	cp.w	r8,31
8000d760:	e0 89 00 16 	brgt	8000d78c <_vfiprintf_r+0xb28>
8000d764:	f2 ca ff f8 	sub	r10,r9,-8
8000d768:	50 aa       	stdsp	sp[0x28],r10
8000d76a:	f2 ea 00 00 	ld.d	r10,r9[0]
8000d76e:	fa eb 00 00 	st.d	sp[0],r10
8000d772:	fa ca f9 78 	sub	r10,sp,-1672
8000d776:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000d77a:	fa ea 00 00 	ld.d	r10,sp[0]
8000d77e:	f2 eb fd a4 	st.d	r9[-604],r10
8000d782:	2f f8       	sub	r8,-1
8000d784:	fb 48 06 80 	st.w	sp[1664],r8
8000d788:	e0 8f 03 6f 	bral	8000de66 <_vfiprintf_r+0x1202>
8000d78c:	f2 ea 00 00 	ld.d	r10,r9[0]
8000d790:	2f 89       	sub	r9,-8
8000d792:	fa eb 00 00 	st.d	sp[0],r10
8000d796:	50 a9       	stdsp	sp[0x28],r9
8000d798:	e0 8f 03 67 	bral	8000de66 <_vfiprintf_r+0x1202>
8000d79c:	ed b3 00 04 	bld	r3,0x4
8000d7a0:	c1 41       	brne	8000d7c8 <_vfiprintf_r+0xb64>
8000d7a2:	fa f8 06 80 	ld.w	r8,sp[1664]
8000d7a6:	58 00       	cp.w	r0,0
8000d7a8:	c0 80       	breq	8000d7b8 <_vfiprintf_r+0xb54>
8000d7aa:	10 37       	cp.w	r7,r8
8000d7ac:	c6 04       	brge	8000d86c <_vfiprintf_r+0xc08>
8000d7ae:	fa ca f9 78 	sub	r10,sp,-1672
8000d7b2:	f4 07 00 37 	add	r7,r10,r7<<0x3
8000d7b6:	c7 78       	rjmp	8000d8a4 <_vfiprintf_r+0xc40>
8000d7b8:	2f f6       	sub	r6,-1
8000d7ba:	10 39       	cp.w	r9,r8
8000d7bc:	c7 74       	brge	8000d8aa <_vfiprintf_r+0xc46>
8000d7be:	fa c9 f9 78 	sub	r9,sp,-1672
8000d7c2:	f2 07 00 37 	add	r7,r9,r7<<0x3
8000d7c6:	c6 f8       	rjmp	8000d8a4 <_vfiprintf_r+0xc40>
8000d7c8:	ed b3 00 06 	bld	r3,0x6
8000d7cc:	c4 51       	brne	8000d856 <_vfiprintf_r+0xbf2>
8000d7ce:	fa f8 06 80 	ld.w	r8,sp[1664]
8000d7d2:	58 00       	cp.w	r0,0
8000d7d4:	c1 d0       	breq	8000d80e <_vfiprintf_r+0xbaa>
8000d7d6:	10 37       	cp.w	r7,r8
8000d7d8:	c0 64       	brge	8000d7e4 <_vfiprintf_r+0xb80>
8000d7da:	fa cc f9 78 	sub	r12,sp,-1672
8000d7de:	f8 07 00 37 	add	r7,r12,r7<<0x3
8000d7e2:	c1 d8       	rjmp	8000d81c <_vfiprintf_r+0xbb8>
8000d7e4:	fa c8 f9 84 	sub	r8,sp,-1660
8000d7e8:	1a d8       	st.w	--sp,r8
8000d7ea:	fa c8 fa d0 	sub	r8,sp,-1328
8000d7ee:	1a d8       	st.w	--sp,r8
8000d7f0:	fa c8 fb cc 	sub	r8,sp,-1076
8000d7f4:	1a d8       	st.w	--sp,r8
8000d7f6:	fa c8 f9 74 	sub	r8,sp,-1676
8000d7fa:	fa c9 ff cc 	sub	r9,sp,-52
8000d7fe:	0a 9a       	mov	r10,r5
8000d800:	0e 9b       	mov	r11,r7
8000d802:	02 9c       	mov	r12,r1
8000d804:	fe b0 f8 94 	rcall	8000c92c <get_arg>
8000d808:	2f dd       	sub	sp,-12
8000d80a:	98 18       	ld.sh	r8,r12[0x2]
8000d80c:	c2 28       	rjmp	8000d850 <_vfiprintf_r+0xbec>
8000d80e:	2f f6       	sub	r6,-1
8000d810:	10 39       	cp.w	r9,r8
8000d812:	c0 84       	brge	8000d822 <_vfiprintf_r+0xbbe>
8000d814:	fa cb f9 78 	sub	r11,sp,-1672
8000d818:	f6 07 00 37 	add	r7,r11,r7<<0x3
8000d81c:	ef 08 fd a6 	ld.sh	r8,r7[-602]
8000d820:	c1 88       	rjmp	8000d850 <_vfiprintf_r+0xbec>
8000d822:	40 a9       	lddsp	r9,sp[0x28]
8000d824:	59 f8       	cp.w	r8,31
8000d826:	e0 89 00 12 	brgt	8000d84a <_vfiprintf_r+0xbe6>
8000d82a:	f2 ca ff fc 	sub	r10,r9,-4
8000d82e:	50 aa       	stdsp	sp[0x28],r10
8000d830:	72 09       	ld.w	r9,r9[0x0]
8000d832:	fa c2 f9 78 	sub	r2,sp,-1672
8000d836:	e4 08 00 3a 	add	r10,r2,r8<<0x3
8000d83a:	2f f8       	sub	r8,-1
8000d83c:	f5 49 fd a4 	st.w	r10[-604],r9
8000d840:	fb 48 06 80 	st.w	sp[1664],r8
8000d844:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000d848:	c0 48       	rjmp	8000d850 <_vfiprintf_r+0xbec>
8000d84a:	92 18       	ld.sh	r8,r9[0x2]
8000d84c:	2f c9       	sub	r9,-4
8000d84e:	50 a9       	stdsp	sp[0x28],r9
8000d850:	5c 78       	castu.h	r8
8000d852:	50 18       	stdsp	sp[0x4],r8
8000d854:	c4 18       	rjmp	8000d8d6 <_vfiprintf_r+0xc72>
8000d856:	fa f8 06 80 	ld.w	r8,sp[1664]
8000d85a:	58 00       	cp.w	r0,0
8000d85c:	c1 d0       	breq	8000d896 <_vfiprintf_r+0xc32>
8000d85e:	10 37       	cp.w	r7,r8
8000d860:	c0 64       	brge	8000d86c <_vfiprintf_r+0xc08>
8000d862:	fa cc f9 78 	sub	r12,sp,-1672
8000d866:	f8 07 00 37 	add	r7,r12,r7<<0x3
8000d86a:	c1 d8       	rjmp	8000d8a4 <_vfiprintf_r+0xc40>
8000d86c:	fa c8 f9 84 	sub	r8,sp,-1660
8000d870:	1a d8       	st.w	--sp,r8
8000d872:	fa c8 fa d0 	sub	r8,sp,-1328
8000d876:	0a 9a       	mov	r10,r5
8000d878:	1a d8       	st.w	--sp,r8
8000d87a:	fa c8 fb cc 	sub	r8,sp,-1076
8000d87e:	0e 9b       	mov	r11,r7
8000d880:	1a d8       	st.w	--sp,r8
8000d882:	02 9c       	mov	r12,r1
8000d884:	fa c8 f9 74 	sub	r8,sp,-1676
8000d888:	fa c9 ff cc 	sub	r9,sp,-52
8000d88c:	fe b0 f8 50 	rcall	8000c92c <get_arg>
8000d890:	2f dd       	sub	sp,-12
8000d892:	78 0a       	ld.w	r10,r12[0x0]
8000d894:	c2 08       	rjmp	8000d8d4 <_vfiprintf_r+0xc70>
8000d896:	2f f6       	sub	r6,-1
8000d898:	10 39       	cp.w	r9,r8
8000d89a:	c0 84       	brge	8000d8aa <_vfiprintf_r+0xc46>
8000d89c:	fa cb f9 78 	sub	r11,sp,-1672
8000d8a0:	f6 07 00 37 	add	r7,r11,r7<<0x3
8000d8a4:	ee fa fd a4 	ld.w	r10,r7[-604]
8000d8a8:	c1 68       	rjmp	8000d8d4 <_vfiprintf_r+0xc70>
8000d8aa:	40 a9       	lddsp	r9,sp[0x28]
8000d8ac:	59 f8       	cp.w	r8,31
8000d8ae:	e0 89 00 10 	brgt	8000d8ce <_vfiprintf_r+0xc6a>
8000d8b2:	f2 ca ff fc 	sub	r10,r9,-4
8000d8b6:	50 aa       	stdsp	sp[0x28],r10
8000d8b8:	fa c2 f9 78 	sub	r2,sp,-1672
8000d8bc:	72 0a       	ld.w	r10,r9[0x0]
8000d8be:	e4 08 00 39 	add	r9,r2,r8<<0x3
8000d8c2:	f3 4a fd a4 	st.w	r9[-604],r10
8000d8c6:	2f f8       	sub	r8,-1
8000d8c8:	fb 48 06 80 	st.w	sp[1664],r8
8000d8cc:	c0 48       	rjmp	8000d8d4 <_vfiprintf_r+0xc70>
8000d8ce:	72 0a       	ld.w	r10,r9[0x0]
8000d8d0:	2f c9       	sub	r9,-4
8000d8d2:	50 a9       	stdsp	sp[0x28],r9
8000d8d4:	50 1a       	stdsp	sp[0x4],r10
8000d8d6:	30 0e       	mov	lr,0
8000d8d8:	50 0e       	stdsp	sp[0x0],lr
8000d8da:	1c 90       	mov	r0,lr
8000d8dc:	e0 8f 02 c5 	bral	8000de66 <_vfiprintf_r+0x1202>
8000d8e0:	50 57       	stdsp	sp[0x14],r7
8000d8e2:	50 42       	stdsp	sp[0x10],r2
8000d8e4:	08 97       	mov	r7,r4
8000d8e6:	40 85       	lddsp	r5,sp[0x20]
8000d8e8:	40 74       	lddsp	r4,sp[0x1c]
8000d8ea:	0c 99       	mov	r9,r6
8000d8ec:	fa f8 06 80 	ld.w	r8,sp[1664]
8000d8f0:	58 00       	cp.w	r0,0
8000d8f2:	c1 d0       	breq	8000d92c <_vfiprintf_r+0xcc8>
8000d8f4:	10 37       	cp.w	r7,r8
8000d8f6:	c0 64       	brge	8000d902 <_vfiprintf_r+0xc9e>
8000d8f8:	fa cc f9 78 	sub	r12,sp,-1672
8000d8fc:	f8 07 00 37 	add	r7,r12,r7<<0x3
8000d900:	c1 d8       	rjmp	8000d93a <_vfiprintf_r+0xcd6>
8000d902:	fa c8 f9 84 	sub	r8,sp,-1660
8000d906:	1a d8       	st.w	--sp,r8
8000d908:	fa c8 fa d0 	sub	r8,sp,-1328
8000d90c:	1a d8       	st.w	--sp,r8
8000d90e:	fa c8 fb cc 	sub	r8,sp,-1076
8000d912:	1a d8       	st.w	--sp,r8
8000d914:	fa c9 ff cc 	sub	r9,sp,-52
8000d918:	fa c8 f9 74 	sub	r8,sp,-1676
8000d91c:	0a 9a       	mov	r10,r5
8000d91e:	0e 9b       	mov	r11,r7
8000d920:	02 9c       	mov	r12,r1
8000d922:	fe b0 f8 05 	rcall	8000c92c <get_arg>
8000d926:	2f dd       	sub	sp,-12
8000d928:	78 09       	ld.w	r9,r12[0x0]
8000d92a:	c2 18       	rjmp	8000d96c <_vfiprintf_r+0xd08>
8000d92c:	2f f6       	sub	r6,-1
8000d92e:	10 39       	cp.w	r9,r8
8000d930:	c0 84       	brge	8000d940 <_vfiprintf_r+0xcdc>
8000d932:	fa cb f9 78 	sub	r11,sp,-1672
8000d936:	f6 07 00 37 	add	r7,r11,r7<<0x3
8000d93a:	ee f9 fd a4 	ld.w	r9,r7[-604]
8000d93e:	c1 78       	rjmp	8000d96c <_vfiprintf_r+0xd08>
8000d940:	40 a9       	lddsp	r9,sp[0x28]
8000d942:	59 f8       	cp.w	r8,31
8000d944:	e0 89 00 10 	brgt	8000d964 <_vfiprintf_r+0xd00>
8000d948:	f2 ca ff fc 	sub	r10,r9,-4
8000d94c:	50 aa       	stdsp	sp[0x28],r10
8000d94e:	fa c2 f9 78 	sub	r2,sp,-1672
8000d952:	72 09       	ld.w	r9,r9[0x0]
8000d954:	e4 08 00 3a 	add	r10,r2,r8<<0x3
8000d958:	f5 49 fd a4 	st.w	r10[-604],r9
8000d95c:	2f f8       	sub	r8,-1
8000d95e:	fb 48 06 80 	st.w	sp[1664],r8
8000d962:	c0 58       	rjmp	8000d96c <_vfiprintf_r+0xd08>
8000d964:	f2 c8 ff fc 	sub	r8,r9,-4
8000d968:	50 a8       	stdsp	sp[0x28],r8
8000d96a:	72 09       	ld.w	r9,r9[0x0]
8000d96c:	33 08       	mov	r8,48
8000d96e:	30 0e       	mov	lr,0
8000d970:	fb 68 06 84 	st.b	sp[1668],r8
8000d974:	4d 0c       	lddpc	r12,8000dab4 <_vfiprintf_r+0xe50>
8000d976:	37 88       	mov	r8,120
8000d978:	50 19       	stdsp	sp[0x4],r9
8000d97a:	a1 b3       	sbr	r3,0x1
8000d97c:	fb 68 06 85 	st.b	sp[1669],r8
8000d980:	50 0e       	stdsp	sp[0x0],lr
8000d982:	50 9c       	stdsp	sp[0x24],r12
8000d984:	e0 8f 02 70 	bral	8000de64 <_vfiprintf_r+0x1200>
8000d988:	50 57       	stdsp	sp[0x14],r7
8000d98a:	30 0b       	mov	r11,0
8000d98c:	50 42       	stdsp	sp[0x10],r2
8000d98e:	fb 6b 06 87 	st.b	sp[1671],r11
8000d992:	08 97       	mov	r7,r4
8000d994:	40 85       	lddsp	r5,sp[0x20]
8000d996:	40 74       	lddsp	r4,sp[0x1c]
8000d998:	0c 99       	mov	r9,r6
8000d99a:	fa f8 06 80 	ld.w	r8,sp[1664]
8000d99e:	58 00       	cp.w	r0,0
8000d9a0:	c1 d0       	breq	8000d9da <_vfiprintf_r+0xd76>
8000d9a2:	10 37       	cp.w	r7,r8
8000d9a4:	c0 64       	brge	8000d9b0 <_vfiprintf_r+0xd4c>
8000d9a6:	fa ca f9 78 	sub	r10,sp,-1672
8000d9aa:	f4 07 00 37 	add	r7,r10,r7<<0x3
8000d9ae:	c1 d8       	rjmp	8000d9e8 <_vfiprintf_r+0xd84>
8000d9b0:	fa c8 f9 84 	sub	r8,sp,-1660
8000d9b4:	1a d8       	st.w	--sp,r8
8000d9b6:	fa c8 fa d0 	sub	r8,sp,-1328
8000d9ba:	1a d8       	st.w	--sp,r8
8000d9bc:	fa c8 fb cc 	sub	r8,sp,-1076
8000d9c0:	0e 9b       	mov	r11,r7
8000d9c2:	1a d8       	st.w	--sp,r8
8000d9c4:	0a 9a       	mov	r10,r5
8000d9c6:	fa c8 f9 74 	sub	r8,sp,-1676
8000d9ca:	fa c9 ff cc 	sub	r9,sp,-52
8000d9ce:	02 9c       	mov	r12,r1
8000d9d0:	fe b0 f7 ae 	rcall	8000c92c <get_arg>
8000d9d4:	2f dd       	sub	sp,-12
8000d9d6:	78 07       	ld.w	r7,r12[0x0]
8000d9d8:	c2 08       	rjmp	8000da18 <_vfiprintf_r+0xdb4>
8000d9da:	2f f6       	sub	r6,-1
8000d9dc:	10 39       	cp.w	r9,r8
8000d9de:	c0 84       	brge	8000d9ee <_vfiprintf_r+0xd8a>
8000d9e0:	fa c9 f9 78 	sub	r9,sp,-1672
8000d9e4:	f2 07 00 37 	add	r7,r9,r7<<0x3
8000d9e8:	ee f7 fd a4 	ld.w	r7,r7[-604]
8000d9ec:	c1 68       	rjmp	8000da18 <_vfiprintf_r+0xdb4>
8000d9ee:	40 a9       	lddsp	r9,sp[0x28]
8000d9f0:	59 f8       	cp.w	r8,31
8000d9f2:	e0 89 00 10 	brgt	8000da12 <_vfiprintf_r+0xdae>
8000d9f6:	f2 ca ff fc 	sub	r10,r9,-4
8000d9fa:	50 aa       	stdsp	sp[0x28],r10
8000d9fc:	72 07       	ld.w	r7,r9[0x0]
8000d9fe:	fa c2 f9 78 	sub	r2,sp,-1672
8000da02:	e4 08 00 39 	add	r9,r2,r8<<0x3
8000da06:	f3 47 fd a4 	st.w	r9[-604],r7
8000da0a:	2f f8       	sub	r8,-1
8000da0c:	fb 48 06 80 	st.w	sp[1664],r8
8000da10:	c0 48       	rjmp	8000da18 <_vfiprintf_r+0xdb4>
8000da12:	72 07       	ld.w	r7,r9[0x0]
8000da14:	2f c9       	sub	r9,-4
8000da16:	50 a9       	stdsp	sp[0x28],r9
8000da18:	40 3e       	lddsp	lr,sp[0xc]
8000da1a:	58 0e       	cp.w	lr,0
8000da1c:	c1 05       	brlt	8000da3c <_vfiprintf_r+0xdd8>
8000da1e:	1c 9a       	mov	r10,lr
8000da20:	30 0b       	mov	r11,0
8000da22:	0e 9c       	mov	r12,r7
8000da24:	e0 a0 20 a6 	rcall	80011b70 <memchr>
8000da28:	e0 80 02 b3 	breq	8000df8e <_vfiprintf_r+0x132a>
8000da2c:	f8 07 01 05 	sub	r5,r12,r7
8000da30:	40 3c       	lddsp	r12,sp[0xc]
8000da32:	18 35       	cp.w	r5,r12
8000da34:	e0 89 02 ad 	brgt	8000df8e <_vfiprintf_r+0x132a>
8000da38:	e0 8f 02 ac 	bral	8000df90 <_vfiprintf_r+0x132c>
8000da3c:	0e 9c       	mov	r12,r7
8000da3e:	30 00       	mov	r0,0
8000da40:	e0 a0 25 ac 	rcall	80012598 <strlen>
8000da44:	18 95       	mov	r5,r12
8000da46:	e0 8f 02 a6 	bral	8000df92 <_vfiprintf_r+0x132e>
8000da4a:	a5 a3       	sbr	r3,0x4
8000da4c:	0c 99       	mov	r9,r6
8000da4e:	ed b3 00 05 	bld	r3,0x5
8000da52:	c5 31       	brne	8000daf8 <_vfiprintf_r+0xe94>
8000da54:	fa f8 06 80 	ld.w	r8,sp[1664]
8000da58:	58 00       	cp.w	r0,0
8000da5a:	c2 00       	breq	8000da9a <_vfiprintf_r+0xe36>
8000da5c:	10 37       	cp.w	r7,r8
8000da5e:	c0 64       	brge	8000da6a <_vfiprintf_r+0xe06>
8000da60:	fa cb f9 78 	sub	r11,sp,-1672
8000da64:	f6 07 00 37 	add	r7,r11,r7<<0x3
8000da68:	c2 08       	rjmp	8000daa8 <_vfiprintf_r+0xe44>
8000da6a:	fa c8 f9 84 	sub	r8,sp,-1660
8000da6e:	1a d8       	st.w	--sp,r8
8000da70:	fa c8 fa d0 	sub	r8,sp,-1328
8000da74:	0a 9a       	mov	r10,r5
8000da76:	1a d8       	st.w	--sp,r8
8000da78:	0e 9b       	mov	r11,r7
8000da7a:	fa c8 fb cc 	sub	r8,sp,-1076
8000da7e:	02 9c       	mov	r12,r1
8000da80:	1a d8       	st.w	--sp,r8
8000da82:	fa c8 f9 74 	sub	r8,sp,-1676
8000da86:	fa c9 ff cc 	sub	r9,sp,-52
8000da8a:	fe b0 f7 51 	rcall	8000c92c <get_arg>
8000da8e:	2f dd       	sub	sp,-12
8000da90:	f8 ea 00 00 	ld.d	r10,r12[0]
8000da94:	fa eb 00 00 	st.d	sp[0],r10
8000da98:	c2 d8       	rjmp	8000daf2 <_vfiprintf_r+0xe8e>
8000da9a:	2f f6       	sub	r6,-1
8000da9c:	10 39       	cp.w	r9,r8
8000da9e:	c0 d4       	brge	8000dab8 <_vfiprintf_r+0xe54>
8000daa0:	fa ca f9 78 	sub	r10,sp,-1672
8000daa4:	f4 07 00 37 	add	r7,r10,r7<<0x3
8000daa8:	ee e8 fd a4 	ld.d	r8,r7[-604]
8000daac:	fa e9 00 00 	st.d	sp[0],r8
8000dab0:	c2 18       	rjmp	8000daf2 <_vfiprintf_r+0xe8e>
8000dab2:	d7 03       	nop
8000dab4:	80 01       	ld.sh	r1,r0[0x0]
8000dab6:	68 c8       	ld.w	r8,r4[0x30]
8000dab8:	40 a9       	lddsp	r9,sp[0x28]
8000daba:	59 f8       	cp.w	r8,31
8000dabc:	e0 89 00 15 	brgt	8000dae6 <_vfiprintf_r+0xe82>
8000dac0:	f2 ca ff f8 	sub	r10,r9,-8
8000dac4:	50 aa       	stdsp	sp[0x28],r10
8000dac6:	f2 ea 00 00 	ld.d	r10,r9[0]
8000daca:	fa eb 00 00 	st.d	sp[0],r10
8000dace:	fa ca f9 78 	sub	r10,sp,-1672
8000dad2:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000dad6:	fa ea 00 00 	ld.d	r10,sp[0]
8000dada:	f2 eb fd a4 	st.d	r9[-604],r10
8000dade:	2f f8       	sub	r8,-1
8000dae0:	fb 48 06 80 	st.w	sp[1664],r8
8000dae4:	c0 78       	rjmp	8000daf2 <_vfiprintf_r+0xe8e>
8000dae6:	f2 ea 00 00 	ld.d	r10,r9[0]
8000daea:	2f 89       	sub	r9,-8
8000daec:	fa eb 00 00 	st.d	sp[0],r10
8000daf0:	50 a9       	stdsp	sp[0x28],r9
8000daf2:	30 10       	mov	r0,1
8000daf4:	e0 8f 01 b9 	bral	8000de66 <_vfiprintf_r+0x1202>
8000daf8:	ed b3 00 04 	bld	r3,0x4
8000dafc:	c1 41       	brne	8000db24 <_vfiprintf_r+0xec0>
8000dafe:	fa f8 06 80 	ld.w	r8,sp[1664]
8000db02:	58 00       	cp.w	r0,0
8000db04:	c0 80       	breq	8000db14 <_vfiprintf_r+0xeb0>
8000db06:	10 37       	cp.w	r7,r8
8000db08:	c6 04       	brge	8000dbc8 <_vfiprintf_r+0xf64>
8000db0a:	fa ca f9 78 	sub	r10,sp,-1672
8000db0e:	f4 07 00 37 	add	r7,r10,r7<<0x3
8000db12:	c7 78       	rjmp	8000dc00 <_vfiprintf_r+0xf9c>
8000db14:	2f f6       	sub	r6,-1
8000db16:	10 39       	cp.w	r9,r8
8000db18:	c7 74       	brge	8000dc06 <_vfiprintf_r+0xfa2>
8000db1a:	fa c9 f9 78 	sub	r9,sp,-1672
8000db1e:	f2 07 00 37 	add	r7,r9,r7<<0x3
8000db22:	c6 f8       	rjmp	8000dc00 <_vfiprintf_r+0xf9c>
8000db24:	ed b3 00 06 	bld	r3,0x6
8000db28:	c4 51       	brne	8000dbb2 <_vfiprintf_r+0xf4e>
8000db2a:	fa f8 06 80 	ld.w	r8,sp[1664]
8000db2e:	58 00       	cp.w	r0,0
8000db30:	c1 d0       	breq	8000db6a <_vfiprintf_r+0xf06>
8000db32:	10 37       	cp.w	r7,r8
8000db34:	c0 64       	brge	8000db40 <_vfiprintf_r+0xedc>
8000db36:	fa cc f9 78 	sub	r12,sp,-1672
8000db3a:	f8 07 00 37 	add	r7,r12,r7<<0x3
8000db3e:	c1 d8       	rjmp	8000db78 <_vfiprintf_r+0xf14>
8000db40:	fa c8 f9 84 	sub	r8,sp,-1660
8000db44:	1a d8       	st.w	--sp,r8
8000db46:	fa c8 fa d0 	sub	r8,sp,-1328
8000db4a:	1a d8       	st.w	--sp,r8
8000db4c:	fa c8 fb cc 	sub	r8,sp,-1076
8000db50:	1a d8       	st.w	--sp,r8
8000db52:	fa c8 f9 74 	sub	r8,sp,-1676
8000db56:	fa c9 ff cc 	sub	r9,sp,-52
8000db5a:	0a 9a       	mov	r10,r5
8000db5c:	0e 9b       	mov	r11,r7
8000db5e:	02 9c       	mov	r12,r1
8000db60:	fe b0 f6 e6 	rcall	8000c92c <get_arg>
8000db64:	2f dd       	sub	sp,-12
8000db66:	98 18       	ld.sh	r8,r12[0x2]
8000db68:	c2 28       	rjmp	8000dbac <_vfiprintf_r+0xf48>
8000db6a:	2f f6       	sub	r6,-1
8000db6c:	10 39       	cp.w	r9,r8
8000db6e:	c0 84       	brge	8000db7e <_vfiprintf_r+0xf1a>
8000db70:	fa cb f9 78 	sub	r11,sp,-1672
8000db74:	f6 07 00 37 	add	r7,r11,r7<<0x3
8000db78:	ef 08 fd a6 	ld.sh	r8,r7[-602]
8000db7c:	c1 88       	rjmp	8000dbac <_vfiprintf_r+0xf48>
8000db7e:	40 a9       	lddsp	r9,sp[0x28]
8000db80:	59 f8       	cp.w	r8,31
8000db82:	e0 89 00 12 	brgt	8000dba6 <_vfiprintf_r+0xf42>
8000db86:	f2 ca ff fc 	sub	r10,r9,-4
8000db8a:	50 aa       	stdsp	sp[0x28],r10
8000db8c:	72 09       	ld.w	r9,r9[0x0]
8000db8e:	fa c2 f9 78 	sub	r2,sp,-1672
8000db92:	e4 08 00 3a 	add	r10,r2,r8<<0x3
8000db96:	2f f8       	sub	r8,-1
8000db98:	f5 49 fd a4 	st.w	r10[-604],r9
8000db9c:	fb 48 06 80 	st.w	sp[1664],r8
8000dba0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000dba4:	c0 48       	rjmp	8000dbac <_vfiprintf_r+0xf48>
8000dba6:	92 18       	ld.sh	r8,r9[0x2]
8000dba8:	2f c9       	sub	r9,-4
8000dbaa:	50 a9       	stdsp	sp[0x28],r9
8000dbac:	5c 78       	castu.h	r8
8000dbae:	50 18       	stdsp	sp[0x4],r8
8000dbb0:	c4 18       	rjmp	8000dc32 <_vfiprintf_r+0xfce>
8000dbb2:	fa f8 06 80 	ld.w	r8,sp[1664]
8000dbb6:	58 00       	cp.w	r0,0
8000dbb8:	c1 d0       	breq	8000dbf2 <_vfiprintf_r+0xf8e>
8000dbba:	10 37       	cp.w	r7,r8
8000dbbc:	c0 64       	brge	8000dbc8 <_vfiprintf_r+0xf64>
8000dbbe:	fa cc f9 78 	sub	r12,sp,-1672
8000dbc2:	f8 07 00 37 	add	r7,r12,r7<<0x3
8000dbc6:	c1 d8       	rjmp	8000dc00 <_vfiprintf_r+0xf9c>
8000dbc8:	fa c8 f9 84 	sub	r8,sp,-1660
8000dbcc:	1a d8       	st.w	--sp,r8
8000dbce:	fa c8 fa d0 	sub	r8,sp,-1328
8000dbd2:	0a 9a       	mov	r10,r5
8000dbd4:	1a d8       	st.w	--sp,r8
8000dbd6:	fa c8 fb cc 	sub	r8,sp,-1076
8000dbda:	0e 9b       	mov	r11,r7
8000dbdc:	1a d8       	st.w	--sp,r8
8000dbde:	02 9c       	mov	r12,r1
8000dbe0:	fa c8 f9 74 	sub	r8,sp,-1676
8000dbe4:	fa c9 ff cc 	sub	r9,sp,-52
8000dbe8:	fe b0 f6 a2 	rcall	8000c92c <get_arg>
8000dbec:	2f dd       	sub	sp,-12
8000dbee:	78 0a       	ld.w	r10,r12[0x0]
8000dbf0:	c2 08       	rjmp	8000dc30 <_vfiprintf_r+0xfcc>
8000dbf2:	2f f6       	sub	r6,-1
8000dbf4:	10 39       	cp.w	r9,r8
8000dbf6:	c0 84       	brge	8000dc06 <_vfiprintf_r+0xfa2>
8000dbf8:	fa cb f9 78 	sub	r11,sp,-1672
8000dbfc:	f6 07 00 37 	add	r7,r11,r7<<0x3
8000dc00:	ee fa fd a4 	ld.w	r10,r7[-604]
8000dc04:	c1 68       	rjmp	8000dc30 <_vfiprintf_r+0xfcc>
8000dc06:	40 a9       	lddsp	r9,sp[0x28]
8000dc08:	59 f8       	cp.w	r8,31
8000dc0a:	e0 89 00 10 	brgt	8000dc2a <_vfiprintf_r+0xfc6>
8000dc0e:	f2 ca ff fc 	sub	r10,r9,-4
8000dc12:	50 aa       	stdsp	sp[0x28],r10
8000dc14:	fa c2 f9 78 	sub	r2,sp,-1672
8000dc18:	72 0a       	ld.w	r10,r9[0x0]
8000dc1a:	e4 08 00 39 	add	r9,r2,r8<<0x3
8000dc1e:	f3 4a fd a4 	st.w	r9[-604],r10
8000dc22:	2f f8       	sub	r8,-1
8000dc24:	fb 48 06 80 	st.w	sp[1664],r8
8000dc28:	c0 48       	rjmp	8000dc30 <_vfiprintf_r+0xfcc>
8000dc2a:	72 0a       	ld.w	r10,r9[0x0]
8000dc2c:	2f c9       	sub	r9,-4
8000dc2e:	50 a9       	stdsp	sp[0x28],r9
8000dc30:	50 1a       	stdsp	sp[0x4],r10
8000dc32:	30 0e       	mov	lr,0
8000dc34:	30 10       	mov	r0,1
8000dc36:	50 0e       	stdsp	sp[0x0],lr
8000dc38:	c1 79       	rjmp	8000de66 <_vfiprintf_r+0x1202>
8000dc3a:	4d 0c       	lddpc	r12,8000dd78 <_vfiprintf_r+0x1114>
8000dc3c:	50 9c       	stdsp	sp[0x24],r12
8000dc3e:	ed b3 00 05 	bld	r3,0x5
8000dc42:	c5 41       	brne	8000dcea <_vfiprintf_r+0x1086>
8000dc44:	fa f8 06 80 	ld.w	r8,sp[1664]
8000dc48:	58 00       	cp.w	r0,0
8000dc4a:	c2 20       	breq	8000dc8e <_vfiprintf_r+0x102a>
8000dc4c:	10 37       	cp.w	r7,r8
8000dc4e:	c0 a4       	brge	8000dc62 <_vfiprintf_r+0xffe>
8000dc50:	fa cb f9 78 	sub	r11,sp,-1672
8000dc54:	f6 07 00 37 	add	r7,r11,r7<<0x3
8000dc58:	ee e8 fd a4 	ld.d	r8,r7[-604]
8000dc5c:	fa e9 00 00 	st.d	sp[0],r8
8000dc60:	cf 08       	rjmp	8000de40 <_vfiprintf_r+0x11dc>
8000dc62:	fa c8 f9 84 	sub	r8,sp,-1660
8000dc66:	1a d8       	st.w	--sp,r8
8000dc68:	fa c8 fa d0 	sub	r8,sp,-1328
8000dc6c:	0a 9a       	mov	r10,r5
8000dc6e:	1a d8       	st.w	--sp,r8
8000dc70:	0e 9b       	mov	r11,r7
8000dc72:	fa c8 fb cc 	sub	r8,sp,-1076
8000dc76:	02 9c       	mov	r12,r1
8000dc78:	1a d8       	st.w	--sp,r8
8000dc7a:	fa c8 f9 74 	sub	r8,sp,-1676
8000dc7e:	fa c9 ff cc 	sub	r9,sp,-52
8000dc82:	fe b0 f6 55 	rcall	8000c92c <get_arg>
8000dc86:	2f dd       	sub	sp,-12
8000dc88:	f8 ea 00 00 	ld.d	r10,r12[0]
8000dc8c:	c0 c8       	rjmp	8000dca4 <_vfiprintf_r+0x1040>
8000dc8e:	ec ca ff ff 	sub	r10,r6,-1
8000dc92:	10 36       	cp.w	r6,r8
8000dc94:	c0 b4       	brge	8000dcaa <_vfiprintf_r+0x1046>
8000dc96:	fa c9 f9 78 	sub	r9,sp,-1672
8000dc9a:	14 96       	mov	r6,r10
8000dc9c:	f2 07 00 37 	add	r7,r9,r7<<0x3
8000dca0:	ee ea fd a4 	ld.d	r10,r7[-604]
8000dca4:	fa eb 00 00 	st.d	sp[0],r10
8000dca8:	cc c8       	rjmp	8000de40 <_vfiprintf_r+0x11dc>
8000dcaa:	40 a9       	lddsp	r9,sp[0x28]
8000dcac:	59 f8       	cp.w	r8,31
8000dcae:	e0 89 00 16 	brgt	8000dcda <_vfiprintf_r+0x1076>
8000dcb2:	f2 e6 00 00 	ld.d	r6,r9[0]
8000dcb6:	f2 cb ff f8 	sub	r11,r9,-8
8000dcba:	fa e7 00 00 	st.d	sp[0],r6
8000dcbe:	50 ab       	stdsp	sp[0x28],r11
8000dcc0:	fa c6 f9 78 	sub	r6,sp,-1672
8000dcc4:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000dcc8:	fa e6 00 00 	ld.d	r6,sp[0]
8000dccc:	f2 e7 fd a4 	st.d	r9[-604],r6
8000dcd0:	2f f8       	sub	r8,-1
8000dcd2:	14 96       	mov	r6,r10
8000dcd4:	fb 48 06 80 	st.w	sp[1664],r8
8000dcd8:	cb 48       	rjmp	8000de40 <_vfiprintf_r+0x11dc>
8000dcda:	f2 e6 00 00 	ld.d	r6,r9[0]
8000dcde:	2f 89       	sub	r9,-8
8000dce0:	fa e7 00 00 	st.d	sp[0],r6
8000dce4:	50 a9       	stdsp	sp[0x28],r9
8000dce6:	14 96       	mov	r6,r10
8000dce8:	ca c8       	rjmp	8000de40 <_vfiprintf_r+0x11dc>
8000dcea:	ed b3 00 04 	bld	r3,0x4
8000dcee:	c1 61       	brne	8000dd1a <_vfiprintf_r+0x10b6>
8000dcf0:	fa f8 06 80 	ld.w	r8,sp[1664]
8000dcf4:	58 00       	cp.w	r0,0
8000dcf6:	c0 80       	breq	8000dd06 <_vfiprintf_r+0x10a2>
8000dcf8:	10 37       	cp.w	r7,r8
8000dcfa:	c6 84       	brge	8000ddca <_vfiprintf_r+0x1166>
8000dcfc:	fa ce f9 78 	sub	lr,sp,-1672
8000dd00:	fc 07 00 37 	add	r7,lr,r7<<0x3
8000dd04:	c8 18       	rjmp	8000de06 <_vfiprintf_r+0x11a2>
8000dd06:	ec ca ff ff 	sub	r10,r6,-1
8000dd0a:	10 36       	cp.w	r6,r8
8000dd0c:	e0 84 00 80 	brge	8000de0c <_vfiprintf_r+0x11a8>
8000dd10:	fa cc f9 78 	sub	r12,sp,-1672
8000dd14:	f8 07 00 37 	add	r7,r12,r7<<0x3
8000dd18:	c7 68       	rjmp	8000de04 <_vfiprintf_r+0x11a0>
8000dd1a:	ed b3 00 06 	bld	r3,0x6
8000dd1e:	c4 b1       	brne	8000ddb4 <_vfiprintf_r+0x1150>
8000dd20:	fa f8 06 80 	ld.w	r8,sp[1664]
8000dd24:	58 00       	cp.w	r0,0
8000dd26:	c1 d0       	breq	8000dd60 <_vfiprintf_r+0x10fc>
8000dd28:	10 37       	cp.w	r7,r8
8000dd2a:	c0 64       	brge	8000dd36 <_vfiprintf_r+0x10d2>
8000dd2c:	fa cc f9 78 	sub	r12,sp,-1672
8000dd30:	f8 07 00 37 	add	r7,r12,r7<<0x3
8000dd34:	c1 f8       	rjmp	8000dd72 <_vfiprintf_r+0x110e>
8000dd36:	fa c8 f9 84 	sub	r8,sp,-1660
8000dd3a:	1a d8       	st.w	--sp,r8
8000dd3c:	fa c8 fa d0 	sub	r8,sp,-1328
8000dd40:	1a d8       	st.w	--sp,r8
8000dd42:	fa c8 fb cc 	sub	r8,sp,-1076
8000dd46:	1a d8       	st.w	--sp,r8
8000dd48:	fa c8 f9 74 	sub	r8,sp,-1676
8000dd4c:	fa c9 ff cc 	sub	r9,sp,-52
8000dd50:	0a 9a       	mov	r10,r5
8000dd52:	0e 9b       	mov	r11,r7
8000dd54:	02 9c       	mov	r12,r1
8000dd56:	fe b0 f5 eb 	rcall	8000c92c <get_arg>
8000dd5a:	2f dd       	sub	sp,-12
8000dd5c:	98 18       	ld.sh	r8,r12[0x2]
8000dd5e:	c2 88       	rjmp	8000ddae <_vfiprintf_r+0x114a>
8000dd60:	ec ca ff ff 	sub	r10,r6,-1
8000dd64:	10 36       	cp.w	r6,r8
8000dd66:	c0 b4       	brge	8000dd7c <_vfiprintf_r+0x1118>
8000dd68:	fa cb f9 78 	sub	r11,sp,-1672
8000dd6c:	14 96       	mov	r6,r10
8000dd6e:	f6 07 00 37 	add	r7,r11,r7<<0x3
8000dd72:	ef 08 fd a6 	ld.sh	r8,r7[-602]
8000dd76:	c1 c8       	rjmp	8000ddae <_vfiprintf_r+0x114a>
8000dd78:	80 01       	ld.sh	r1,r0[0x0]
8000dd7a:	68 c8       	ld.w	r8,r4[0x30]
8000dd7c:	40 a9       	lddsp	r9,sp[0x28]
8000dd7e:	59 f8       	cp.w	r8,31
8000dd80:	e0 89 00 13 	brgt	8000dda6 <_vfiprintf_r+0x1142>
8000dd84:	f2 cb ff fc 	sub	r11,r9,-4
8000dd88:	50 ab       	stdsp	sp[0x28],r11
8000dd8a:	72 09       	ld.w	r9,r9[0x0]
8000dd8c:	fa c6 f9 78 	sub	r6,sp,-1672
8000dd90:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000dd94:	2f f8       	sub	r8,-1
8000dd96:	f7 49 fd a4 	st.w	r11[-604],r9
8000dd9a:	fb 48 06 80 	st.w	sp[1664],r8
8000dd9e:	14 96       	mov	r6,r10
8000dda0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000dda4:	c0 58       	rjmp	8000ddae <_vfiprintf_r+0x114a>
8000dda6:	92 18       	ld.sh	r8,r9[0x2]
8000dda8:	14 96       	mov	r6,r10
8000ddaa:	2f c9       	sub	r9,-4
8000ddac:	50 a9       	stdsp	sp[0x28],r9
8000ddae:	5c 78       	castu.h	r8
8000ddb0:	50 18       	stdsp	sp[0x4],r8
8000ddb2:	c4 58       	rjmp	8000de3c <_vfiprintf_r+0x11d8>
8000ddb4:	fa f8 06 80 	ld.w	r8,sp[1664]
8000ddb8:	58 00       	cp.w	r0,0
8000ddba:	c1 d0       	breq	8000ddf4 <_vfiprintf_r+0x1190>
8000ddbc:	10 37       	cp.w	r7,r8
8000ddbe:	c0 64       	brge	8000ddca <_vfiprintf_r+0x1166>
8000ddc0:	fa cc f9 78 	sub	r12,sp,-1672
8000ddc4:	f8 07 00 37 	add	r7,r12,r7<<0x3
8000ddc8:	c1 f8       	rjmp	8000de06 <_vfiprintf_r+0x11a2>
8000ddca:	fa c8 f9 84 	sub	r8,sp,-1660
8000ddce:	1a d8       	st.w	--sp,r8
8000ddd0:	fa c8 fa d0 	sub	r8,sp,-1328
8000ddd4:	0e 9b       	mov	r11,r7
8000ddd6:	1a d8       	st.w	--sp,r8
8000ddd8:	fa c8 fb cc 	sub	r8,sp,-1076
8000dddc:	0a 9a       	mov	r10,r5
8000ddde:	1a d8       	st.w	--sp,r8
8000dde0:	02 9c       	mov	r12,r1
8000dde2:	fa c8 f9 74 	sub	r8,sp,-1676
8000dde6:	fa c9 ff cc 	sub	r9,sp,-52
8000ddea:	fe b0 f5 a1 	rcall	8000c92c <get_arg>
8000ddee:	2f dd       	sub	sp,-12
8000ddf0:	78 0b       	ld.w	r11,r12[0x0]
8000ddf2:	c2 48       	rjmp	8000de3a <_vfiprintf_r+0x11d6>
8000ddf4:	ec ca ff ff 	sub	r10,r6,-1
8000ddf8:	10 36       	cp.w	r6,r8
8000ddfa:	c0 94       	brge	8000de0c <_vfiprintf_r+0x11a8>
8000ddfc:	fa cb f9 78 	sub	r11,sp,-1672
8000de00:	f6 07 00 37 	add	r7,r11,r7<<0x3
8000de04:	14 96       	mov	r6,r10
8000de06:	ee fb fd a4 	ld.w	r11,r7[-604]
8000de0a:	c1 88       	rjmp	8000de3a <_vfiprintf_r+0x11d6>
8000de0c:	40 a9       	lddsp	r9,sp[0x28]
8000de0e:	59 f8       	cp.w	r8,31
8000de10:	e0 89 00 11 	brgt	8000de32 <_vfiprintf_r+0x11ce>
8000de14:	f2 cb ff fc 	sub	r11,r9,-4
8000de18:	50 ab       	stdsp	sp[0x28],r11
8000de1a:	fa c6 f9 78 	sub	r6,sp,-1672
8000de1e:	72 0b       	ld.w	r11,r9[0x0]
8000de20:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000de24:	f3 4b fd a4 	st.w	r9[-604],r11
8000de28:	2f f8       	sub	r8,-1
8000de2a:	14 96       	mov	r6,r10
8000de2c:	fb 48 06 80 	st.w	sp[1664],r8
8000de30:	c0 58       	rjmp	8000de3a <_vfiprintf_r+0x11d6>
8000de32:	72 0b       	ld.w	r11,r9[0x0]
8000de34:	14 96       	mov	r6,r10
8000de36:	2f c9       	sub	r9,-4
8000de38:	50 a9       	stdsp	sp[0x28],r9
8000de3a:	50 1b       	stdsp	sp[0x4],r11
8000de3c:	30 0e       	mov	lr,0
8000de3e:	50 0e       	stdsp	sp[0x0],lr
8000de40:	40 08       	lddsp	r8,sp[0x0]
8000de42:	40 1c       	lddsp	r12,sp[0x4]
8000de44:	18 48       	or	r8,r12
8000de46:	30 0b       	mov	r11,0
8000de48:	5f 19       	srne	r9
8000de4a:	06 98       	mov	r8,r3
8000de4c:	e7 e9 00 09 	and	r9,r3,r9
8000de50:	a1 b8       	sbr	r8,0x1
8000de52:	f6 09 18 00 	cp.b	r9,r11
8000de56:	c0 70       	breq	8000de64 <_vfiprintf_r+0x1200>
8000de58:	10 93       	mov	r3,r8
8000de5a:	fb 62 06 85 	st.b	sp[1669],r2
8000de5e:	33 08       	mov	r8,48
8000de60:	fb 68 06 84 	st.b	sp[1668],r8
8000de64:	30 20       	mov	r0,2
8000de66:	30 0a       	mov	r10,0
8000de68:	fb 6a 06 87 	st.b	sp[1671],r10
8000de6c:	06 98       	mov	r8,r3
8000de6e:	a7 d8       	cbr	r8,0x7
8000de70:	40 39       	lddsp	r9,sp[0xc]
8000de72:	40 37       	lddsp	r7,sp[0xc]
8000de74:	58 09       	cp.w	r9,0
8000de76:	5f 19       	srne	r9
8000de78:	58 07       	cp.w	r7,0
8000de7a:	f0 03 17 40 	movge	r3,r8
8000de7e:	40 12       	lddsp	r2,sp[0x4]
8000de80:	40 08       	lddsp	r8,sp[0x0]
8000de82:	fa c5 f9 90 	sub	r5,sp,-1648
8000de86:	04 48       	or	r8,r2
8000de88:	30 0e       	mov	lr,0
8000de8a:	5f 18       	srne	r8
8000de8c:	f3 e8 10 08 	or	r8,r9,r8
8000de90:	fc 08 18 00 	cp.b	r8,lr
8000de94:	c5 e0       	breq	8000df50 <_vfiprintf_r+0x12ec>
8000de96:	30 18       	mov	r8,1
8000de98:	f0 00 18 00 	cp.b	r0,r8
8000de9c:	c0 60       	breq	8000dea8 <_vfiprintf_r+0x1244>
8000de9e:	30 28       	mov	r8,2
8000dea0:	f0 00 18 00 	cp.b	r0,r8
8000dea4:	c0 51       	brne	8000deae <_vfiprintf_r+0x124a>
8000dea6:	c3 e8       	rjmp	8000df22 <_vfiprintf_r+0x12be>
8000dea8:	0a 97       	mov	r7,r5
8000deaa:	06 90       	mov	r0,r3
8000deac:	c2 c8       	rjmp	8000df04 <_vfiprintf_r+0x12a0>
8000deae:	0a 97       	mov	r7,r5
8000deb0:	fa e8 00 00 	ld.d	r8,sp[0]
8000deb4:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000deb8:	2d 0a       	sub	r10,-48
8000deba:	0e fa       	st.b	--r7,r10
8000debc:	f0 0b 16 03 	lsr	r11,r8,0x3
8000dec0:	f2 0c 16 03 	lsr	r12,r9,0x3
8000dec4:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000dec8:	18 99       	mov	r9,r12
8000deca:	16 98       	mov	r8,r11
8000decc:	58 08       	cp.w	r8,0
8000dece:	5c 29       	cpc	r9
8000ded0:	cf 21       	brne	8000deb4 <_vfiprintf_r+0x1250>
8000ded2:	fa e9 00 00 	st.d	sp[0],r8
8000ded6:	ed b3 00 00 	bld	r3,0x0
8000deda:	c4 61       	brne	8000df66 <_vfiprintf_r+0x1302>
8000dedc:	33 09       	mov	r9,48
8000dede:	f2 0a 18 00 	cp.b	r10,r9
8000dee2:	c4 20       	breq	8000df66 <_vfiprintf_r+0x1302>
8000dee4:	0e f9       	st.b	--r7,r9
8000dee6:	c4 08       	rjmp	8000df66 <_vfiprintf_r+0x1302>
8000dee8:	e0 a0 26 5a 	rcall	80012b9c <__avr32_umod64>
8000deec:	30 a8       	mov	r8,10
8000deee:	2d 0a       	sub	r10,-48
8000def0:	30 09       	mov	r9,0
8000def2:	ae 8a       	st.b	r7[0x0],r10
8000def4:	fa ea 00 00 	ld.d	r10,sp[0]
8000def8:	fe b0 f0 21 	rcall	8000bf3a <__avr32_udiv64>
8000defc:	16 99       	mov	r9,r11
8000defe:	14 98       	mov	r8,r10
8000df00:	fa e9 00 00 	st.d	sp[0],r8
8000df04:	ee cc 00 01 	sub	r12,r7,1
8000df08:	30 a8       	mov	r8,10
8000df0a:	30 09       	mov	r9,0
8000df0c:	fa ea 00 00 	ld.d	r10,sp[0]
8000df10:	18 97       	mov	r7,r12
8000df12:	58 9a       	cp.w	r10,9
8000df14:	5c 2b       	cpc	r11
8000df16:	fe 9b ff e9 	brhi	8000dee8 <_vfiprintf_r+0x1284>
8000df1a:	1b f8       	ld.ub	r8,sp[0x7]
8000df1c:	00 93       	mov	r3,r0
8000df1e:	2d 08       	sub	r8,-48
8000df20:	c2 08       	rjmp	8000df60 <_vfiprintf_r+0x12fc>
8000df22:	0a 97       	mov	r7,r5
8000df24:	fa e8 00 00 	ld.d	r8,sp[0]
8000df28:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000df2c:	40 9c       	lddsp	r12,sp[0x24]
8000df2e:	f8 0a 07 0a 	ld.ub	r10,r12[r10]
8000df32:	0e fa       	st.b	--r7,r10
8000df34:	f2 0b 16 04 	lsr	r11,r9,0x4
8000df38:	f0 0a 16 04 	lsr	r10,r8,0x4
8000df3c:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8000df40:	16 99       	mov	r9,r11
8000df42:	14 98       	mov	r8,r10
8000df44:	58 08       	cp.w	r8,0
8000df46:	5c 29       	cpc	r9
8000df48:	cf 01       	brne	8000df28 <_vfiprintf_r+0x12c4>
8000df4a:	fa e9 00 00 	st.d	sp[0],r8
8000df4e:	c0 c8       	rjmp	8000df66 <_vfiprintf_r+0x1302>
8000df50:	58 00       	cp.w	r0,0
8000df52:	c0 91       	brne	8000df64 <_vfiprintf_r+0x1300>
8000df54:	ed b3 00 00 	bld	r3,0x0
8000df58:	c0 61       	brne	8000df64 <_vfiprintf_r+0x1300>
8000df5a:	fa c7 f9 91 	sub	r7,sp,-1647
8000df5e:	33 08       	mov	r8,48
8000df60:	ae 88       	st.b	r7[0x0],r8
8000df62:	c0 28       	rjmp	8000df66 <_vfiprintf_r+0x1302>
8000df64:	0a 97       	mov	r7,r5
8000df66:	0e 15       	sub	r5,r7
8000df68:	40 30       	lddsp	r0,sp[0xc]
8000df6a:	c1 48       	rjmp	8000df92 <_vfiprintf_r+0x132e>
8000df6c:	50 42       	stdsp	sp[0x10],r2
8000df6e:	50 57       	stdsp	sp[0x14],r7
8000df70:	40 74       	lddsp	r4,sp[0x1c]
8000df72:	10 92       	mov	r2,r8
8000df74:	58 02       	cp.w	r2,0
8000df76:	e0 80 01 ac 	breq	8000e2ce <_vfiprintf_r+0x166a>
8000df7a:	30 0b       	mov	r11,0
8000df7c:	fb 62 06 48 	st.b	sp[1608],r2
8000df80:	fb 6b 06 87 	st.b	sp[1671],r11
8000df84:	30 15       	mov	r5,1
8000df86:	30 00       	mov	r0,0
8000df88:	fa c7 f9 b8 	sub	r7,sp,-1608
8000df8c:	c0 38       	rjmp	8000df92 <_vfiprintf_r+0x132e>
8000df8e:	40 35       	lddsp	r5,sp[0xc]
8000df90:	30 00       	mov	r0,0
8000df92:	fb 38 06 87 	ld.ub	r8,sp[1671]
8000df96:	ea 00 0c 42 	max	r2,r5,r0
8000df9a:	30 0a       	mov	r10,0
8000df9c:	06 99       	mov	r9,r3
8000df9e:	f4 08 18 00 	cp.b	r8,r10
8000dfa2:	f7 b2 01 ff 	subne	r2,-1
8000dfa6:	e2 19 00 02 	andl	r9,0x2,COH
8000dfaa:	06 98       	mov	r8,r3
8000dfac:	50 89       	stdsp	sp[0x20],r9
8000dfae:	e2 18 00 84 	andl	r8,0x84,COH
8000dfb2:	50 78       	stdsp	sp[0x1c],r8
8000dfb4:	58 09       	cp.w	r9,0
8000dfb6:	f7 b2 01 fe 	subne	r2,-2
8000dfba:	58 08       	cp.w	r8,0
8000dfbc:	c4 51       	brne	8000e046 <_vfiprintf_r+0x13e2>
8000dfbe:	40 4e       	lddsp	lr,sp[0x10]
8000dfc0:	04 1e       	sub	lr,r2
8000dfc2:	50 3e       	stdsp	sp[0xc],lr
8000dfc4:	58 0e       	cp.w	lr,0
8000dfc6:	e0 89 00 1d 	brgt	8000e000 <_vfiprintf_r+0x139c>
8000dfca:	c3 e8       	rjmp	8000e046 <_vfiprintf_r+0x13e2>
8000dfcc:	fb 4c 06 78 	st.w	sp[1656],r12
8000dfd0:	31 0a       	mov	r10,16
8000dfd2:	4c cc       	lddpc	r12,8000e100 <_vfiprintf_r+0x149c>
8000dfd4:	89 1a       	st.w	r4[0x4],r10
8000dfd6:	89 0c       	st.w	r4[0x0],r12
8000dfd8:	fb 4b 06 74 	st.w	sp[1652],r11
8000dfdc:	58 7b       	cp.w	r11,7
8000dfde:	e0 89 00 04 	brgt	8000dfe6 <_vfiprintf_r+0x1382>
8000dfe2:	2f 84       	sub	r4,-8
8000dfe4:	c0 b8       	rjmp	8000dffa <_vfiprintf_r+0x1396>
8000dfe6:	fa ca f9 90 	sub	r10,sp,-1648
8000dfea:	40 2b       	lddsp	r11,sp[0x8]
8000dfec:	02 9c       	mov	r12,r1
8000dfee:	fe b0 f6 2d 	rcall	8000cc48 <__sprint_r>
8000dff2:	e0 81 01 7f 	brne	8000e2f0 <_vfiprintf_r+0x168c>
8000dff6:	fa c4 f9 f8 	sub	r4,sp,-1544
8000dffa:	40 39       	lddsp	r9,sp[0xc]
8000dffc:	21 09       	sub	r9,16
8000dffe:	50 39       	stdsp	sp[0xc],r9
8000e000:	fa f9 06 78 	ld.w	r9,sp[1656]
8000e004:	fa f8 06 74 	ld.w	r8,sp[1652]
8000e008:	f2 cc ff f0 	sub	r12,r9,-16
8000e00c:	f0 cb ff ff 	sub	r11,r8,-1
8000e010:	4b ca       	lddpc	r10,8000e100 <_vfiprintf_r+0x149c>
8000e012:	40 3e       	lddsp	lr,sp[0xc]
8000e014:	59 0e       	cp.w	lr,16
8000e016:	fe 99 ff db 	brgt	8000dfcc <_vfiprintf_r+0x1368>
8000e01a:	1c 09       	add	r9,lr
8000e01c:	89 0a       	st.w	r4[0x0],r10
8000e01e:	fb 49 06 78 	st.w	sp[1656],r9
8000e022:	89 1e       	st.w	r4[0x4],lr
8000e024:	fb 4b 06 74 	st.w	sp[1652],r11
8000e028:	58 7b       	cp.w	r11,7
8000e02a:	e0 89 00 04 	brgt	8000e032 <_vfiprintf_r+0x13ce>
8000e02e:	2f 84       	sub	r4,-8
8000e030:	c0 b8       	rjmp	8000e046 <_vfiprintf_r+0x13e2>
8000e032:	fa ca f9 90 	sub	r10,sp,-1648
8000e036:	40 2b       	lddsp	r11,sp[0x8]
8000e038:	02 9c       	mov	r12,r1
8000e03a:	fe b0 f6 07 	rcall	8000cc48 <__sprint_r>
8000e03e:	e0 81 01 59 	brne	8000e2f0 <_vfiprintf_r+0x168c>
8000e042:	fa c4 f9 f8 	sub	r4,sp,-1544
8000e046:	fb 38 06 87 	ld.ub	r8,sp[1671]
8000e04a:	30 0c       	mov	r12,0
8000e04c:	f8 08 18 00 	cp.b	r8,r12
8000e050:	c1 f0       	breq	8000e08e <_vfiprintf_r+0x142a>
8000e052:	fa f8 06 78 	ld.w	r8,sp[1656]
8000e056:	fa c9 f9 79 	sub	r9,sp,-1671
8000e05a:	2f f8       	sub	r8,-1
8000e05c:	89 09       	st.w	r4[0x0],r9
8000e05e:	fb 48 06 78 	st.w	sp[1656],r8
8000e062:	30 19       	mov	r9,1
8000e064:	fa f8 06 74 	ld.w	r8,sp[1652]
8000e068:	89 19       	st.w	r4[0x4],r9
8000e06a:	2f f8       	sub	r8,-1
8000e06c:	fb 48 06 74 	st.w	sp[1652],r8
8000e070:	58 78       	cp.w	r8,7
8000e072:	e0 89 00 04 	brgt	8000e07a <_vfiprintf_r+0x1416>
8000e076:	2f 84       	sub	r4,-8
8000e078:	c0 b8       	rjmp	8000e08e <_vfiprintf_r+0x142a>
8000e07a:	fa ca f9 90 	sub	r10,sp,-1648
8000e07e:	40 2b       	lddsp	r11,sp[0x8]
8000e080:	02 9c       	mov	r12,r1
8000e082:	fe b0 f5 e3 	rcall	8000cc48 <__sprint_r>
8000e086:	e0 81 01 35 	brne	8000e2f0 <_vfiprintf_r+0x168c>
8000e08a:	fa c4 f9 f8 	sub	r4,sp,-1544
8000e08e:	40 8b       	lddsp	r11,sp[0x20]
8000e090:	58 0b       	cp.w	r11,0
8000e092:	c1 f0       	breq	8000e0d0 <_vfiprintf_r+0x146c>
8000e094:	fa f8 06 78 	ld.w	r8,sp[1656]
8000e098:	fa c9 f9 7c 	sub	r9,sp,-1668
8000e09c:	2f e8       	sub	r8,-2
8000e09e:	89 09       	st.w	r4[0x0],r9
8000e0a0:	fb 48 06 78 	st.w	sp[1656],r8
8000e0a4:	30 29       	mov	r9,2
8000e0a6:	fa f8 06 74 	ld.w	r8,sp[1652]
8000e0aa:	89 19       	st.w	r4[0x4],r9
8000e0ac:	2f f8       	sub	r8,-1
8000e0ae:	fb 48 06 74 	st.w	sp[1652],r8
8000e0b2:	58 78       	cp.w	r8,7
8000e0b4:	e0 89 00 04 	brgt	8000e0bc <_vfiprintf_r+0x1458>
8000e0b8:	2f 84       	sub	r4,-8
8000e0ba:	c0 b8       	rjmp	8000e0d0 <_vfiprintf_r+0x146c>
8000e0bc:	fa ca f9 90 	sub	r10,sp,-1648
8000e0c0:	40 2b       	lddsp	r11,sp[0x8]
8000e0c2:	02 9c       	mov	r12,r1
8000e0c4:	fe b0 f5 c2 	rcall	8000cc48 <__sprint_r>
8000e0c8:	e0 81 01 14 	brne	8000e2f0 <_vfiprintf_r+0x168c>
8000e0cc:	fa c4 f9 f8 	sub	r4,sp,-1544
8000e0d0:	40 7a       	lddsp	r10,sp[0x1c]
8000e0d2:	e0 4a 00 80 	cp.w	r10,128
8000e0d6:	c4 91       	brne	8000e168 <_vfiprintf_r+0x1504>
8000e0d8:	40 49       	lddsp	r9,sp[0x10]
8000e0da:	04 19       	sub	r9,r2
8000e0dc:	50 39       	stdsp	sp[0xc],r9
8000e0de:	58 09       	cp.w	r9,0
8000e0e0:	e0 89 00 21 	brgt	8000e122 <_vfiprintf_r+0x14be>
8000e0e4:	c4 28       	rjmp	8000e168 <_vfiprintf_r+0x1504>
8000e0e6:	48 88       	lddpc	r8,8000e104 <_vfiprintf_r+0x14a0>
8000e0e8:	31 0e       	mov	lr,16
8000e0ea:	fb 4c 06 78 	st.w	sp[1656],r12
8000e0ee:	89 08       	st.w	r4[0x0],r8
8000e0f0:	89 1e       	st.w	r4[0x4],lr
8000e0f2:	fb 4b 06 74 	st.w	sp[1652],r11
8000e0f6:	58 7b       	cp.w	r11,7
8000e0f8:	e0 89 00 08 	brgt	8000e108 <_vfiprintf_r+0x14a4>
8000e0fc:	2f 84       	sub	r4,-8
8000e0fe:	c0 f8       	rjmp	8000e11c <_vfiprintf_r+0x14b8>
8000e100:	80 01       	ld.sh	r1,r0[0x0]
8000e102:	68 dc       	ld.w	r12,r4[0x34]
8000e104:	80 01       	ld.sh	r1,r0[0x0]
8000e106:	67 cc       	ld.w	r12,r3[0x70]
8000e108:	fa ca f9 90 	sub	r10,sp,-1648
8000e10c:	40 2b       	lddsp	r11,sp[0x8]
8000e10e:	02 9c       	mov	r12,r1
8000e110:	fe b0 f5 9c 	rcall	8000cc48 <__sprint_r>
8000e114:	e0 81 00 ee 	brne	8000e2f0 <_vfiprintf_r+0x168c>
8000e118:	fa c4 f9 f8 	sub	r4,sp,-1544
8000e11c:	40 3c       	lddsp	r12,sp[0xc]
8000e11e:	21 0c       	sub	r12,16
8000e120:	50 3c       	stdsp	sp[0xc],r12
8000e122:	fa f9 06 78 	ld.w	r9,sp[1656]
8000e126:	fa f8 06 74 	ld.w	r8,sp[1652]
8000e12a:	f2 cc ff f0 	sub	r12,r9,-16
8000e12e:	f0 cb ff ff 	sub	r11,r8,-1
8000e132:	4c aa       	lddpc	r10,8000e258 <_vfiprintf_r+0x15f4>
8000e134:	40 3e       	lddsp	lr,sp[0xc]
8000e136:	59 0e       	cp.w	lr,16
8000e138:	fe 99 ff d7 	brgt	8000e0e6 <_vfiprintf_r+0x1482>
8000e13c:	1c 09       	add	r9,lr
8000e13e:	89 0a       	st.w	r4[0x0],r10
8000e140:	fb 49 06 78 	st.w	sp[1656],r9
8000e144:	89 1e       	st.w	r4[0x4],lr
8000e146:	fb 4b 06 74 	st.w	sp[1652],r11
8000e14a:	58 7b       	cp.w	r11,7
8000e14c:	e0 89 00 04 	brgt	8000e154 <_vfiprintf_r+0x14f0>
8000e150:	2f 84       	sub	r4,-8
8000e152:	c0 b8       	rjmp	8000e168 <_vfiprintf_r+0x1504>
8000e154:	fa ca f9 90 	sub	r10,sp,-1648
8000e158:	40 2b       	lddsp	r11,sp[0x8]
8000e15a:	02 9c       	mov	r12,r1
8000e15c:	fe b0 f5 76 	rcall	8000cc48 <__sprint_r>
8000e160:	e0 81 00 c8 	brne	8000e2f0 <_vfiprintf_r+0x168c>
8000e164:	fa c4 f9 f8 	sub	r4,sp,-1544
8000e168:	0a 10       	sub	r0,r5
8000e16a:	58 00       	cp.w	r0,0
8000e16c:	e0 89 00 1b 	brgt	8000e1a2 <_vfiprintf_r+0x153e>
8000e170:	c3 b8       	rjmp	8000e1e6 <_vfiprintf_r+0x1582>
8000e172:	fb 4c 06 78 	st.w	sp[1656],r12
8000e176:	31 0a       	mov	r10,16
8000e178:	4b 8c       	lddpc	r12,8000e258 <_vfiprintf_r+0x15f4>
8000e17a:	89 1a       	st.w	r4[0x4],r10
8000e17c:	89 0c       	st.w	r4[0x0],r12
8000e17e:	fb 4b 06 74 	st.w	sp[1652],r11
8000e182:	58 7b       	cp.w	r11,7
8000e184:	e0 89 00 04 	brgt	8000e18c <_vfiprintf_r+0x1528>
8000e188:	2f 84       	sub	r4,-8
8000e18a:	c0 b8       	rjmp	8000e1a0 <_vfiprintf_r+0x153c>
8000e18c:	fa ca f9 90 	sub	r10,sp,-1648
8000e190:	40 2b       	lddsp	r11,sp[0x8]
8000e192:	02 9c       	mov	r12,r1
8000e194:	fe b0 f5 5a 	rcall	8000cc48 <__sprint_r>
8000e198:	e0 81 00 ac 	brne	8000e2f0 <_vfiprintf_r+0x168c>
8000e19c:	fa c4 f9 f8 	sub	r4,sp,-1544
8000e1a0:	21 00       	sub	r0,16
8000e1a2:	fa f9 06 78 	ld.w	r9,sp[1656]
8000e1a6:	fa f8 06 74 	ld.w	r8,sp[1652]
8000e1aa:	f2 cc ff f0 	sub	r12,r9,-16
8000e1ae:	f0 cb ff ff 	sub	r11,r8,-1
8000e1b2:	4a aa       	lddpc	r10,8000e258 <_vfiprintf_r+0x15f4>
8000e1b4:	59 00       	cp.w	r0,16
8000e1b6:	fe 99 ff de 	brgt	8000e172 <_vfiprintf_r+0x150e>
8000e1ba:	00 09       	add	r9,r0
8000e1bc:	89 0a       	st.w	r4[0x0],r10
8000e1be:	fb 49 06 78 	st.w	sp[1656],r9
8000e1c2:	89 10       	st.w	r4[0x4],r0
8000e1c4:	fb 4b 06 74 	st.w	sp[1652],r11
8000e1c8:	58 7b       	cp.w	r11,7
8000e1ca:	e0 89 00 04 	brgt	8000e1d2 <_vfiprintf_r+0x156e>
8000e1ce:	2f 84       	sub	r4,-8
8000e1d0:	c0 b8       	rjmp	8000e1e6 <_vfiprintf_r+0x1582>
8000e1d2:	fa ca f9 90 	sub	r10,sp,-1648
8000e1d6:	40 2b       	lddsp	r11,sp[0x8]
8000e1d8:	02 9c       	mov	r12,r1
8000e1da:	fe b0 f5 37 	rcall	8000cc48 <__sprint_r>
8000e1de:	e0 81 00 89 	brne	8000e2f0 <_vfiprintf_r+0x168c>
8000e1e2:	fa c4 f9 f8 	sub	r4,sp,-1544
8000e1e6:	fa f8 06 78 	ld.w	r8,sp[1656]
8000e1ea:	89 15       	st.w	r4[0x4],r5
8000e1ec:	89 07       	st.w	r4[0x0],r7
8000e1ee:	f0 05 00 05 	add	r5,r8,r5
8000e1f2:	fa f8 06 74 	ld.w	r8,sp[1652]
8000e1f6:	fb 45 06 78 	st.w	sp[1656],r5
8000e1fa:	2f f8       	sub	r8,-1
8000e1fc:	fb 48 06 74 	st.w	sp[1652],r8
8000e200:	58 78       	cp.w	r8,7
8000e202:	e0 89 00 04 	brgt	8000e20a <_vfiprintf_r+0x15a6>
8000e206:	2f 84       	sub	r4,-8
8000e208:	c0 a8       	rjmp	8000e21c <_vfiprintf_r+0x15b8>
8000e20a:	fa ca f9 90 	sub	r10,sp,-1648
8000e20e:	40 2b       	lddsp	r11,sp[0x8]
8000e210:	02 9c       	mov	r12,r1
8000e212:	fe b0 f5 1b 	rcall	8000cc48 <__sprint_r>
8000e216:	c6 d1       	brne	8000e2f0 <_vfiprintf_r+0x168c>
8000e218:	fa c4 f9 f8 	sub	r4,sp,-1544
8000e21c:	e2 13 00 04 	andl	r3,0x4,COH
8000e220:	c3 f0       	breq	8000e29e <_vfiprintf_r+0x163a>
8000e222:	40 47       	lddsp	r7,sp[0x10]
8000e224:	04 17       	sub	r7,r2
8000e226:	58 07       	cp.w	r7,0
8000e228:	e0 89 00 1a 	brgt	8000e25c <_vfiprintf_r+0x15f8>
8000e22c:	c3 98       	rjmp	8000e29e <_vfiprintf_r+0x163a>
8000e22e:	fb 4c 06 78 	st.w	sp[1656],r12
8000e232:	89 05       	st.w	r4[0x0],r5
8000e234:	89 13       	st.w	r4[0x4],r3
8000e236:	fb 4b 06 74 	st.w	sp[1652],r11
8000e23a:	58 7b       	cp.w	r11,7
8000e23c:	e0 89 00 04 	brgt	8000e244 <_vfiprintf_r+0x15e0>
8000e240:	2f 84       	sub	r4,-8
8000e242:	c0 98       	rjmp	8000e254 <_vfiprintf_r+0x15f0>
8000e244:	00 9a       	mov	r10,r0
8000e246:	40 2b       	lddsp	r11,sp[0x8]
8000e248:	02 9c       	mov	r12,r1
8000e24a:	fe b0 f4 ff 	rcall	8000cc48 <__sprint_r>
8000e24e:	c5 11       	brne	8000e2f0 <_vfiprintf_r+0x168c>
8000e250:	fa c4 f9 f8 	sub	r4,sp,-1544
8000e254:	21 07       	sub	r7,16
8000e256:	c0 78       	rjmp	8000e264 <_vfiprintf_r+0x1600>
8000e258:	80 01       	ld.sh	r1,r0[0x0]
8000e25a:	67 cc       	ld.w	r12,r3[0x70]
8000e25c:	4a b5       	lddpc	r5,8000e308 <_vfiprintf_r+0x16a4>
8000e25e:	31 03       	mov	r3,16
8000e260:	fa c0 f9 90 	sub	r0,sp,-1648
8000e264:	fa f9 06 78 	ld.w	r9,sp[1656]
8000e268:	fa f8 06 74 	ld.w	r8,sp[1652]
8000e26c:	f2 cc ff f0 	sub	r12,r9,-16
8000e270:	f0 cb ff ff 	sub	r11,r8,-1
8000e274:	4a 5a       	lddpc	r10,8000e308 <_vfiprintf_r+0x16a4>
8000e276:	59 07       	cp.w	r7,16
8000e278:	fe 99 ff db 	brgt	8000e22e <_vfiprintf_r+0x15ca>
8000e27c:	0e 09       	add	r9,r7
8000e27e:	89 0a       	st.w	r4[0x0],r10
8000e280:	89 17       	st.w	r4[0x4],r7
8000e282:	fb 49 06 78 	st.w	sp[1656],r9
8000e286:	fb 4b 06 74 	st.w	sp[1652],r11
8000e28a:	58 7b       	cp.w	r11,7
8000e28c:	e0 8a 00 09 	brle	8000e29e <_vfiprintf_r+0x163a>
8000e290:	fa ca f9 90 	sub	r10,sp,-1648
8000e294:	40 2b       	lddsp	r11,sp[0x8]
8000e296:	02 9c       	mov	r12,r1
8000e298:	fe b0 f4 d8 	rcall	8000cc48 <__sprint_r>
8000e29c:	c2 a1       	brne	8000e2f0 <_vfiprintf_r+0x168c>
8000e29e:	40 68       	lddsp	r8,sp[0x18]
8000e2a0:	40 49       	lddsp	r9,sp[0x10]
8000e2a2:	e4 09 0c 42 	max	r2,r2,r9
8000e2a6:	04 08       	add	r8,r2
8000e2a8:	50 68       	stdsp	sp[0x18],r8
8000e2aa:	fa f8 06 78 	ld.w	r8,sp[1656]
8000e2ae:	58 08       	cp.w	r8,0
8000e2b0:	c0 80       	breq	8000e2c0 <_vfiprintf_r+0x165c>
8000e2b2:	fa ca f9 90 	sub	r10,sp,-1648
8000e2b6:	40 2b       	lddsp	r11,sp[0x8]
8000e2b8:	02 9c       	mov	r12,r1
8000e2ba:	fe b0 f4 c7 	rcall	8000cc48 <__sprint_r>
8000e2be:	c1 91       	brne	8000e2f0 <_vfiprintf_r+0x168c>
8000e2c0:	30 03       	mov	r3,0
8000e2c2:	fa c4 f9 f8 	sub	r4,sp,-1544
8000e2c6:	fb 43 06 74 	st.w	sp[1652],r3
8000e2ca:	fe 9f f5 4e 	bral	8000cd66 <_vfiprintf_r+0x102>
8000e2ce:	02 92       	mov	r2,r1
8000e2d0:	40 20       	lddsp	r0,sp[0x8]
8000e2d2:	fa f8 06 78 	ld.w	r8,sp[1656]
8000e2d6:	58 08       	cp.w	r8,0
8000e2d8:	c0 80       	breq	8000e2e8 <_vfiprintf_r+0x1684>
8000e2da:	02 9c       	mov	r12,r1
8000e2dc:	fa ca f9 90 	sub	r10,sp,-1648
8000e2e0:	00 9b       	mov	r11,r0
8000e2e2:	fe b0 f4 b3 	rcall	8000cc48 <__sprint_r>
8000e2e6:	c0 61       	brne	8000e2f2 <_vfiprintf_r+0x168e>
8000e2e8:	30 08       	mov	r8,0
8000e2ea:	fb 48 06 74 	st.w	sp[1652],r8
8000e2ee:	c0 28       	rjmp	8000e2f2 <_vfiprintf_r+0x168e>
8000e2f0:	40 20       	lddsp	r0,sp[0x8]
8000e2f2:	80 68       	ld.sh	r8,r0[0xc]
8000e2f4:	ed b8 00 06 	bld	r8,0x6
8000e2f8:	c0 31       	brne	8000e2fe <_vfiprintf_r+0x169a>
8000e2fa:	3f f2       	mov	r2,-1
8000e2fc:	50 62       	stdsp	sp[0x18],r2
8000e2fe:	40 6c       	lddsp	r12,sp[0x18]
8000e300:	fe 3d f9 78 	sub	sp,-1672
8000e304:	d8 32       	popm	r0-r7,pc
8000e306:	d7 03       	nop
8000e308:	80 01       	ld.sh	r1,r0[0x0]
8000e30a:	68 dc       	ld.w	r12,r4[0x34]

8000e30c <get_arg>:
8000e30c:	d4 31       	pushm	r0-r7,lr
8000e30e:	20 8d       	sub	sp,32
8000e310:	fa c4 ff bc 	sub	r4,sp,-68
8000e314:	50 4b       	stdsp	sp[0x10],r11
8000e316:	68 2e       	ld.w	lr,r4[0x8]
8000e318:	50 58       	stdsp	sp[0x14],r8
8000e31a:	12 96       	mov	r6,r9
8000e31c:	7c 0b       	ld.w	r11,lr[0x0]
8000e31e:	70 05       	ld.w	r5,r8[0x0]
8000e320:	50 6e       	stdsp	sp[0x18],lr
8000e322:	58 0b       	cp.w	r11,0
8000e324:	f4 0b 17 00 	moveq	r11,r10
8000e328:	68 03       	ld.w	r3,r4[0x0]
8000e32a:	68 11       	ld.w	r1,r4[0x4]
8000e32c:	40 49       	lddsp	r9,sp[0x10]
8000e32e:	30 08       	mov	r8,0
8000e330:	c2 e9       	rjmp	8000e58c <get_arg+0x280>
8000e332:	2f fb       	sub	r11,-1
8000e334:	32 5c       	mov	r12,37
8000e336:	17 8a       	ld.ub	r10,r11[0x0]
8000e338:	f8 0a 18 00 	cp.b	r10,r12
8000e33c:	5f 1e       	srne	lr
8000e33e:	f0 0a 18 00 	cp.b	r10,r8
8000e342:	5f 1c       	srne	r12
8000e344:	fd ec 00 0c 	and	r12,lr,r12
8000e348:	f0 0c 18 00 	cp.b	r12,r8
8000e34c:	cf 31       	brne	8000e332 <get_arg+0x26>
8000e34e:	58 0a       	cp.w	r10,0
8000e350:	e0 80 01 2b 	breq	8000e5a6 <get_arg+0x29a>
8000e354:	30 0c       	mov	r12,0
8000e356:	3f fa       	mov	r10,-1
8000e358:	18 90       	mov	r0,r12
8000e35a:	50 3a       	stdsp	sp[0xc],r10
8000e35c:	18 94       	mov	r4,r12
8000e35e:	18 92       	mov	r2,r12
8000e360:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
8000e364:	16 97       	mov	r7,r11
8000e366:	50 7c       	stdsp	sp[0x1c],r12
8000e368:	4c ec       	lddpc	r12,8000e4a0 <get_arg+0x194>
8000e36a:	0f 3a       	ld.ub	r10,r7++
8000e36c:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
8000e370:	40 7c       	lddsp	r12,sp[0x1c]
8000e372:	1c 0c       	add	r12,lr
8000e374:	4c ce       	lddpc	lr,8000e4a4 <get_arg+0x198>
8000e376:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
8000e37a:	20 1e       	sub	lr,1
8000e37c:	50 0e       	stdsp	sp[0x0],lr
8000e37e:	4c be       	lddpc	lr,8000e4a8 <get_arg+0x19c>
8000e380:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8000e384:	50 7c       	stdsp	sp[0x1c],r12
8000e386:	40 0c       	lddsp	r12,sp[0x0]
8000e388:	58 7c       	cp.w	r12,7
8000e38a:	e0 8b 00 fa 	brhi	8000e57e <get_arg+0x272>
8000e38e:	4c 8e       	lddpc	lr,8000e4ac <get_arg+0x1a0>
8000e390:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
8000e394:	36 8b       	mov	r11,104
8000e396:	f6 0a 18 00 	cp.b	r10,r11
8000e39a:	e0 80 00 f2 	breq	8000e57e <get_arg+0x272>
8000e39e:	37 1b       	mov	r11,113
8000e3a0:	f6 0a 18 00 	cp.b	r10,r11
8000e3a4:	c0 70       	breq	8000e3b2 <get_arg+0xa6>
8000e3a6:	34 cb       	mov	r11,76
8000e3a8:	f6 0a 18 00 	cp.b	r10,r11
8000e3ac:	c0 51       	brne	8000e3b6 <get_arg+0xaa>
8000e3ae:	a3 b4       	sbr	r4,0x3
8000e3b0:	ce 78       	rjmp	8000e57e <get_arg+0x272>
8000e3b2:	a5 b4       	sbr	r4,0x5
8000e3b4:	ce 58       	rjmp	8000e57e <get_arg+0x272>
8000e3b6:	08 9a       	mov	r10,r4
8000e3b8:	0e 9b       	mov	r11,r7
8000e3ba:	a5 aa       	sbr	r10,0x4
8000e3bc:	17 3c       	ld.ub	r12,r11++
8000e3be:	a5 b4       	sbr	r4,0x5
8000e3c0:	36 ce       	mov	lr,108
8000e3c2:	fc 0c 18 00 	cp.b	r12,lr
8000e3c6:	e0 80 00 dd 	breq	8000e580 <get_arg+0x274>
8000e3ca:	14 94       	mov	r4,r10
8000e3cc:	cd 98       	rjmp	8000e57e <get_arg+0x272>
8000e3ce:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000e3d2:	36 7c       	mov	r12,103
8000e3d4:	f8 0a 18 00 	cp.b	r10,r12
8000e3d8:	e0 8b 00 27 	brhi	8000e426 <get_arg+0x11a>
8000e3dc:	36 5b       	mov	r11,101
8000e3de:	f6 0a 18 00 	cp.b	r10,r11
8000e3e2:	c4 82       	brcc	8000e472 <get_arg+0x166>
8000e3e4:	34 fb       	mov	r11,79
8000e3e6:	f6 0a 18 00 	cp.b	r10,r11
8000e3ea:	c4 80       	breq	8000e47a <get_arg+0x16e>
8000e3ec:	e0 8b 00 0c 	brhi	8000e404 <get_arg+0xf8>
8000e3f0:	34 5b       	mov	r11,69
8000e3f2:	f6 0a 18 00 	cp.b	r10,r11
8000e3f6:	c3 e0       	breq	8000e472 <get_arg+0x166>
8000e3f8:	34 7b       	mov	r11,71
8000e3fa:	f6 0a 18 00 	cp.b	r10,r11
8000e3fe:	c3 a0       	breq	8000e472 <get_arg+0x166>
8000e400:	34 4b       	mov	r11,68
8000e402:	c0 88       	rjmp	8000e412 <get_arg+0x106>
8000e404:	35 8b       	mov	r11,88
8000e406:	f6 0a 18 00 	cp.b	r10,r11
8000e40a:	c2 c0       	breq	8000e462 <get_arg+0x156>
8000e40c:	e0 8b 00 07 	brhi	8000e41a <get_arg+0x10e>
8000e410:	35 5b       	mov	r11,85
8000e412:	f6 0a 18 00 	cp.b	r10,r11
8000e416:	c3 51       	brne	8000e480 <get_arg+0x174>
8000e418:	c3 18       	rjmp	8000e47a <get_arg+0x16e>
8000e41a:	36 3b       	mov	r11,99
8000e41c:	f6 0a 18 00 	cp.b	r10,r11
8000e420:	c2 f0       	breq	8000e47e <get_arg+0x172>
8000e422:	36 4b       	mov	r11,100
8000e424:	c0 e8       	rjmp	8000e440 <get_arg+0x134>
8000e426:	37 0b       	mov	r11,112
8000e428:	f6 0a 18 00 	cp.b	r10,r11
8000e42c:	c2 50       	breq	8000e476 <get_arg+0x16a>
8000e42e:	e0 8b 00 0d 	brhi	8000e448 <get_arg+0x13c>
8000e432:	36 eb       	mov	r11,110
8000e434:	f6 0a 18 00 	cp.b	r10,r11
8000e438:	c1 f0       	breq	8000e476 <get_arg+0x16a>
8000e43a:	e0 8b 00 14 	brhi	8000e462 <get_arg+0x156>
8000e43e:	36 9b       	mov	r11,105
8000e440:	f6 0a 18 00 	cp.b	r10,r11
8000e444:	c1 e1       	brne	8000e480 <get_arg+0x174>
8000e446:	c0 e8       	rjmp	8000e462 <get_arg+0x156>
8000e448:	37 5b       	mov	r11,117
8000e44a:	f6 0a 18 00 	cp.b	r10,r11
8000e44e:	c0 a0       	breq	8000e462 <get_arg+0x156>
8000e450:	37 8b       	mov	r11,120
8000e452:	f6 0a 18 00 	cp.b	r10,r11
8000e456:	c0 60       	breq	8000e462 <get_arg+0x156>
8000e458:	37 3b       	mov	r11,115
8000e45a:	f6 0a 18 00 	cp.b	r10,r11
8000e45e:	c1 11       	brne	8000e480 <get_arg+0x174>
8000e460:	c0 b8       	rjmp	8000e476 <get_arg+0x16a>
8000e462:	ed b4 00 04 	bld	r4,0x4
8000e466:	c0 a0       	breq	8000e47a <get_arg+0x16e>
8000e468:	ed b4 00 05 	bld	r4,0x5
8000e46c:	c0 91       	brne	8000e47e <get_arg+0x172>
8000e46e:	30 20       	mov	r0,2
8000e470:	c0 88       	rjmp	8000e480 <get_arg+0x174>
8000e472:	30 40       	mov	r0,4
8000e474:	c0 68       	rjmp	8000e480 <get_arg+0x174>
8000e476:	30 30       	mov	r0,3
8000e478:	c0 48       	rjmp	8000e480 <get_arg+0x174>
8000e47a:	30 10       	mov	r0,1
8000e47c:	c0 28       	rjmp	8000e480 <get_arg+0x174>
8000e47e:	30 00       	mov	r0,0
8000e480:	40 3b       	lddsp	r11,sp[0xc]
8000e482:	5b fb       	cp.w	r11,-1
8000e484:	c0 40       	breq	8000e48c <get_arg+0x180>
8000e486:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000e48a:	c7 a8       	rjmp	8000e57e <get_arg+0x272>
8000e48c:	58 60       	cp.w	r0,6
8000e48e:	e0 8b 00 78 	brhi	8000e57e <get_arg+0x272>
8000e492:	6c 0a       	ld.w	r10,r6[0x0]
8000e494:	ea cc ff ff 	sub	r12,r5,-1
8000e498:	48 6e       	lddpc	lr,8000e4b0 <get_arg+0x1a4>
8000e49a:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
8000e49e:	d7 03       	nop
8000e4a0:	80 01       	ld.sh	r1,r0[0x0]
8000e4a2:	6c 94       	ld.w	r4,r6[0x24]
8000e4a4:	80 01       	ld.sh	r1,r0[0x0]
8000e4a6:	6b f8       	ld.w	r8,r5[0x7c]
8000e4a8:	80 01       	ld.sh	r1,r0[0x0]
8000e4aa:	6b 8c       	ld.w	r12,r5[0x60]
8000e4ac:	80 01       	ld.sh	r1,r0[0x0]
8000e4ae:	69 ec       	ld.w	r12,r4[0x78]
8000e4b0:	80 01       	ld.sh	r1,r0[0x0]
8000e4b2:	6a 0c       	ld.w	r12,r5[0x0]
8000e4b4:	f4 cb ff f8 	sub	r11,r10,-8
8000e4b8:	8d 0b       	st.w	r6[0x0],r11
8000e4ba:	f4 ea 00 00 	ld.d	r10,r10[0]
8000e4be:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000e4c2:	c0 f8       	rjmp	8000e4e0 <get_arg+0x1d4>
8000e4c4:	f4 cb ff fc 	sub	r11,r10,-4
8000e4c8:	8d 0b       	st.w	r6[0x0],r11
8000e4ca:	74 0a       	ld.w	r10,r10[0x0]
8000e4cc:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000e4d0:	c0 88       	rjmp	8000e4e0 <get_arg+0x1d4>
8000e4d2:	f4 cb ff f8 	sub	r11,r10,-8
8000e4d6:	8d 0b       	st.w	r6[0x0],r11
8000e4d8:	f4 ea 00 00 	ld.d	r10,r10[0]
8000e4dc:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000e4e0:	0e 9b       	mov	r11,r7
8000e4e2:	18 95       	mov	r5,r12
8000e4e4:	c4 e8       	rjmp	8000e580 <get_arg+0x274>
8000e4e6:	62 0a       	ld.w	r10,r1[0x0]
8000e4e8:	5b fa       	cp.w	r10,-1
8000e4ea:	c0 b1       	brne	8000e500 <get_arg+0x1f4>
8000e4ec:	50 19       	stdsp	sp[0x4],r9
8000e4ee:	50 28       	stdsp	sp[0x8],r8
8000e4f0:	e0 6a 00 80 	mov	r10,128
8000e4f4:	30 0b       	mov	r11,0
8000e4f6:	02 9c       	mov	r12,r1
8000e4f8:	fe b0 f1 44 	rcall	8000c780 <memset>
8000e4fc:	40 28       	lddsp	r8,sp[0x8]
8000e4fe:	40 19       	lddsp	r9,sp[0x4]
8000e500:	e4 cc 00 01 	sub	r12,r2,1
8000e504:	0e 9b       	mov	r11,r7
8000e506:	50 3c       	stdsp	sp[0xc],r12
8000e508:	f2 0c 0c 49 	max	r9,r9,r12
8000e50c:	c3 a8       	rjmp	8000e580 <get_arg+0x274>
8000e50e:	62 0a       	ld.w	r10,r1[0x0]
8000e510:	5b fa       	cp.w	r10,-1
8000e512:	c0 b1       	brne	8000e528 <get_arg+0x21c>
8000e514:	50 19       	stdsp	sp[0x4],r9
8000e516:	50 28       	stdsp	sp[0x8],r8
8000e518:	e0 6a 00 80 	mov	r10,128
8000e51c:	30 0b       	mov	r11,0
8000e51e:	02 9c       	mov	r12,r1
8000e520:	fe b0 f1 30 	rcall	8000c780 <memset>
8000e524:	40 28       	lddsp	r8,sp[0x8]
8000e526:	40 19       	lddsp	r9,sp[0x4]
8000e528:	20 12       	sub	r2,1
8000e52a:	30 0a       	mov	r10,0
8000e52c:	0e 9b       	mov	r11,r7
8000e52e:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
8000e532:	f2 02 0c 49 	max	r9,r9,r2
8000e536:	c2 58       	rjmp	8000e580 <get_arg+0x274>
8000e538:	16 97       	mov	r7,r11
8000e53a:	6c 0a       	ld.w	r10,r6[0x0]
8000e53c:	f4 cb ff fc 	sub	r11,r10,-4
8000e540:	8d 0b       	st.w	r6[0x0],r11
8000e542:	74 0a       	ld.w	r10,r10[0x0]
8000e544:	0e 9b       	mov	r11,r7
8000e546:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000e54a:	2f f5       	sub	r5,-1
8000e54c:	c1 a8       	rjmp	8000e580 <get_arg+0x274>
8000e54e:	f4 c2 00 30 	sub	r2,r10,48
8000e552:	c0 68       	rjmp	8000e55e <get_arg+0x252>
8000e554:	e4 02 00 22 	add	r2,r2,r2<<0x2
8000e558:	2f f7       	sub	r7,-1
8000e55a:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000e55e:	0f 8a       	ld.ub	r10,r7[0x0]
8000e560:	58 0a       	cp.w	r10,0
8000e562:	c0 e0       	breq	8000e57e <get_arg+0x272>
8000e564:	23 0a       	sub	r10,48
8000e566:	58 9a       	cp.w	r10,9
8000e568:	fe 98 ff f6 	brls	8000e554 <get_arg+0x248>
8000e56c:	c0 98       	rjmp	8000e57e <get_arg+0x272>
8000e56e:	2f f7       	sub	r7,-1
8000e570:	0f 8a       	ld.ub	r10,r7[0x0]
8000e572:	58 0a       	cp.w	r10,0
8000e574:	c0 50       	breq	8000e57e <get_arg+0x272>
8000e576:	23 0a       	sub	r10,48
8000e578:	58 9a       	cp.w	r10,9
8000e57a:	fe 98 ff fa 	brls	8000e56e <get_arg+0x262>
8000e57e:	0e 9b       	mov	r11,r7
8000e580:	40 7c       	lddsp	r12,sp[0x1c]
8000e582:	30 ba       	mov	r10,11
8000e584:	f4 0c 18 00 	cp.b	r12,r10
8000e588:	fe 91 fe ec 	brne	8000e360 <get_arg+0x54>
8000e58c:	40 42       	lddsp	r2,sp[0x10]
8000e58e:	17 8c       	ld.ub	r12,r11[0x0]
8000e590:	0a 32       	cp.w	r2,r5
8000e592:	5f 4a       	srge	r10
8000e594:	f0 0c 18 00 	cp.b	r12,r8
8000e598:	5f 1c       	srne	r12
8000e59a:	f9 ea 00 0a 	and	r10,r12,r10
8000e59e:	f0 0a 18 00 	cp.b	r10,r8
8000e5a2:	fe 91 fe c9 	brne	8000e334 <get_arg+0x28>
8000e5a6:	30 08       	mov	r8,0
8000e5a8:	40 4e       	lddsp	lr,sp[0x10]
8000e5aa:	17 8a       	ld.ub	r10,r11[0x0]
8000e5ac:	e2 05 00 21 	add	r1,r1,r5<<0x2
8000e5b0:	f0 0a 18 00 	cp.b	r10,r8
8000e5b4:	fc 09 17 10 	movne	r9,lr
8000e5b8:	e6 05 00 38 	add	r8,r3,r5<<0x3
8000e5bc:	06 9e       	mov	lr,r3
8000e5be:	c2 a8       	rjmp	8000e612 <get_arg+0x306>
8000e5c0:	62 0a       	ld.w	r10,r1[0x0]
8000e5c2:	58 3a       	cp.w	r10,3
8000e5c4:	c1 e0       	breq	8000e600 <get_arg+0x2f4>
8000e5c6:	e0 89 00 07 	brgt	8000e5d4 <get_arg+0x2c8>
8000e5ca:	58 1a       	cp.w	r10,1
8000e5cc:	c1 a0       	breq	8000e600 <get_arg+0x2f4>
8000e5ce:	58 2a       	cp.w	r10,2
8000e5d0:	c1 81       	brne	8000e600 <get_arg+0x2f4>
8000e5d2:	c0 58       	rjmp	8000e5dc <get_arg+0x2d0>
8000e5d4:	58 5a       	cp.w	r10,5
8000e5d6:	c0 c0       	breq	8000e5ee <get_arg+0x2e2>
8000e5d8:	c0 b5       	brlt	8000e5ee <get_arg+0x2e2>
8000e5da:	c1 38       	rjmp	8000e600 <get_arg+0x2f4>
8000e5dc:	6c 0a       	ld.w	r10,r6[0x0]
8000e5de:	f4 cc ff f8 	sub	r12,r10,-8
8000e5e2:	8d 0c       	st.w	r6[0x0],r12
8000e5e4:	f4 e2 00 00 	ld.d	r2,r10[0]
8000e5e8:	f0 e3 00 00 	st.d	r8[0],r2
8000e5ec:	c1 08       	rjmp	8000e60c <get_arg+0x300>
8000e5ee:	6c 0a       	ld.w	r10,r6[0x0]
8000e5f0:	f4 cc ff f8 	sub	r12,r10,-8
8000e5f4:	8d 0c       	st.w	r6[0x0],r12
8000e5f6:	f4 e2 00 00 	ld.d	r2,r10[0]
8000e5fa:	f0 e3 00 00 	st.d	r8[0],r2
8000e5fe:	c0 78       	rjmp	8000e60c <get_arg+0x300>
8000e600:	6c 0a       	ld.w	r10,r6[0x0]
8000e602:	f4 cc ff fc 	sub	r12,r10,-4
8000e606:	8d 0c       	st.w	r6[0x0],r12
8000e608:	74 0a       	ld.w	r10,r10[0x0]
8000e60a:	91 0a       	st.w	r8[0x0],r10
8000e60c:	2f f5       	sub	r5,-1
8000e60e:	2f 88       	sub	r8,-8
8000e610:	2f c1       	sub	r1,-4
8000e612:	12 35       	cp.w	r5,r9
8000e614:	fe 9a ff d6 	brle	8000e5c0 <get_arg+0x2b4>
8000e618:	1c 93       	mov	r3,lr
8000e61a:	40 52       	lddsp	r2,sp[0x14]
8000e61c:	40 6e       	lddsp	lr,sp[0x18]
8000e61e:	85 05       	st.w	r2[0x0],r5
8000e620:	9d 0b       	st.w	lr[0x0],r11
8000e622:	40 4b       	lddsp	r11,sp[0x10]
8000e624:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000e628:	2f 8d       	sub	sp,-32
8000e62a:	d8 32       	popm	r0-r7,pc

8000e62c <__sprint_r>:
8000e62c:	d4 21       	pushm	r4-r7,lr
8000e62e:	14 97       	mov	r7,r10
8000e630:	74 28       	ld.w	r8,r10[0x8]
8000e632:	58 08       	cp.w	r8,0
8000e634:	c0 41       	brne	8000e63c <__sprint_r+0x10>
8000e636:	95 18       	st.w	r10[0x4],r8
8000e638:	10 9c       	mov	r12,r8
8000e63a:	d8 22       	popm	r4-r7,pc
8000e63c:	e0 a0 18 c8 	rcall	800117cc <__sfvwrite_r>
8000e640:	30 08       	mov	r8,0
8000e642:	8f 18       	st.w	r7[0x4],r8
8000e644:	8f 28       	st.w	r7[0x8],r8
8000e646:	d8 22       	popm	r4-r7,pc

8000e648 <_vfprintf_r>:
8000e648:	d4 31       	pushm	r0-r7,lr
8000e64a:	fa cd 06 bc 	sub	sp,sp,1724
8000e64e:	51 09       	stdsp	sp[0x40],r9
8000e650:	16 91       	mov	r1,r11
8000e652:	14 97       	mov	r7,r10
8000e654:	18 95       	mov	r5,r12
8000e656:	e0 a0 1a 2b 	rcall	80011aac <_localeconv_r>
8000e65a:	78 0c       	ld.w	r12,r12[0x0]
8000e65c:	50 cc       	stdsp	sp[0x30],r12
8000e65e:	58 05       	cp.w	r5,0
8000e660:	c0 70       	breq	8000e66e <_vfprintf_r+0x26>
8000e662:	6a 68       	ld.w	r8,r5[0x18]
8000e664:	58 08       	cp.w	r8,0
8000e666:	c0 41       	brne	8000e66e <_vfprintf_r+0x26>
8000e668:	0a 9c       	mov	r12,r5
8000e66a:	e0 a0 17 51 	rcall	8001150c <__sinit>
8000e66e:	4d 08       	lddpc	r8,8000e7ac <_vfprintf_r+0x164>
8000e670:	10 31       	cp.w	r1,r8
8000e672:	c0 31       	brne	8000e678 <_vfprintf_r+0x30>
8000e674:	6a 01       	ld.w	r1,r5[0x0]
8000e676:	c0 a8       	rjmp	8000e68a <_vfprintf_r+0x42>
8000e678:	4c e8       	lddpc	r8,8000e7b0 <_vfprintf_r+0x168>
8000e67a:	10 31       	cp.w	r1,r8
8000e67c:	c0 31       	brne	8000e682 <_vfprintf_r+0x3a>
8000e67e:	6a 11       	ld.w	r1,r5[0x4]
8000e680:	c0 58       	rjmp	8000e68a <_vfprintf_r+0x42>
8000e682:	4c d8       	lddpc	r8,8000e7b4 <_vfprintf_r+0x16c>
8000e684:	10 31       	cp.w	r1,r8
8000e686:	eb f1 00 02 	ld.weq	r1,r5[0x8]
8000e68a:	82 68       	ld.sh	r8,r1[0xc]
8000e68c:	ed b8 00 03 	bld	r8,0x3
8000e690:	c0 41       	brne	8000e698 <_vfprintf_r+0x50>
8000e692:	62 48       	ld.w	r8,r1[0x10]
8000e694:	58 08       	cp.w	r8,0
8000e696:	c0 71       	brne	8000e6a4 <_vfprintf_r+0x5c>
8000e698:	02 9b       	mov	r11,r1
8000e69a:	0a 9c       	mov	r12,r5
8000e69c:	e0 a0 0f 66 	rcall	80010568 <__swsetup_r>
8000e6a0:	e0 81 0f 5d 	brne	8001055a <_vfprintf_r+0x1f12>
8000e6a4:	82 68       	ld.sh	r8,r1[0xc]
8000e6a6:	10 99       	mov	r9,r8
8000e6a8:	e2 19 00 1a 	andl	r9,0x1a,COH
8000e6ac:	58 a9       	cp.w	r9,10
8000e6ae:	c3 c1       	brne	8000e726 <_vfprintf_r+0xde>
8000e6b0:	82 79       	ld.sh	r9,r1[0xe]
8000e6b2:	30 0a       	mov	r10,0
8000e6b4:	f4 09 19 00 	cp.h	r9,r10
8000e6b8:	c3 75       	brlt	8000e726 <_vfprintf_r+0xde>
8000e6ba:	a1 d8       	cbr	r8,0x1
8000e6bc:	fb 58 05 d0 	st.h	sp[1488],r8
8000e6c0:	62 88       	ld.w	r8,r1[0x20]
8000e6c2:	fb 48 05 e4 	st.w	sp[1508],r8
8000e6c6:	62 a8       	ld.w	r8,r1[0x28]
8000e6c8:	fb 48 05 ec 	st.w	sp[1516],r8
8000e6cc:	fa c8 ff bc 	sub	r8,sp,-68
8000e6d0:	fb 48 05 d4 	st.w	sp[1492],r8
8000e6d4:	fb 48 05 c4 	st.w	sp[1476],r8
8000e6d8:	e0 68 04 00 	mov	r8,1024
8000e6dc:	fb 48 05 d8 	st.w	sp[1496],r8
8000e6e0:	fb 48 05 cc 	st.w	sp[1484],r8
8000e6e4:	30 08       	mov	r8,0
8000e6e6:	fb 59 05 d2 	st.h	sp[1490],r9
8000e6ea:	0e 9a       	mov	r10,r7
8000e6ec:	41 09       	lddsp	r9,sp[0x40]
8000e6ee:	fa c7 fa 3c 	sub	r7,sp,-1476
8000e6f2:	fb 48 05 dc 	st.w	sp[1500],r8
8000e6f6:	0a 9c       	mov	r12,r5
8000e6f8:	0e 9b       	mov	r11,r7
8000e6fa:	ca 7f       	rcall	8000e648 <_vfprintf_r>
8000e6fc:	50 bc       	stdsp	sp[0x2c],r12
8000e6fe:	c0 95       	brlt	8000e710 <_vfprintf_r+0xc8>
8000e700:	0e 9b       	mov	r11,r7
8000e702:	0a 9c       	mov	r12,r5
8000e704:	e0 a0 16 2c 	rcall	8001135c <_fflush_r>
8000e708:	40 be       	lddsp	lr,sp[0x2c]
8000e70a:	f9 be 01 ff 	movne	lr,-1
8000e70e:	50 be       	stdsp	sp[0x2c],lr
8000e710:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000e714:	ed b8 00 06 	bld	r8,0x6
8000e718:	e0 81 0f 23 	brne	8001055e <_vfprintf_r+0x1f16>
8000e71c:	82 68       	ld.sh	r8,r1[0xc]
8000e71e:	a7 a8       	sbr	r8,0x6
8000e720:	a2 68       	st.h	r1[0xc],r8
8000e722:	e0 8f 0f 1e 	bral	8001055e <_vfprintf_r+0x1f16>
8000e726:	30 08       	mov	r8,0
8000e728:	fb 48 06 b4 	st.w	sp[1716],r8
8000e72c:	fb 48 06 90 	st.w	sp[1680],r8
8000e730:	fb 48 06 8c 	st.w	sp[1676],r8
8000e734:	fb 48 06 b0 	st.w	sp[1712],r8
8000e738:	30 08       	mov	r8,0
8000e73a:	30 09       	mov	r9,0
8000e73c:	50 a7       	stdsp	sp[0x28],r7
8000e73e:	50 78       	stdsp	sp[0x1c],r8
8000e740:	fa c3 f9 e0 	sub	r3,sp,-1568
8000e744:	3f f8       	mov	r8,-1
8000e746:	50 59       	stdsp	sp[0x14],r9
8000e748:	fb 43 06 88 	st.w	sp[1672],r3
8000e74c:	fb 48 05 44 	st.w	sp[1348],r8
8000e750:	12 9c       	mov	r12,r9
8000e752:	50 69       	stdsp	sp[0x18],r9
8000e754:	50 d9       	stdsp	sp[0x34],r9
8000e756:	50 e9       	stdsp	sp[0x38],r9
8000e758:	50 b9       	stdsp	sp[0x2c],r9
8000e75a:	12 97       	mov	r7,r9
8000e75c:	0a 94       	mov	r4,r5
8000e75e:	40 a2       	lddsp	r2,sp[0x28]
8000e760:	32 5a       	mov	r10,37
8000e762:	30 08       	mov	r8,0
8000e764:	c0 28       	rjmp	8000e768 <_vfprintf_r+0x120>
8000e766:	2f f2       	sub	r2,-1
8000e768:	05 89       	ld.ub	r9,r2[0x0]
8000e76a:	f0 09 18 00 	cp.b	r9,r8
8000e76e:	5f 1b       	srne	r11
8000e770:	f4 09 18 00 	cp.b	r9,r10
8000e774:	5f 19       	srne	r9
8000e776:	f3 eb 00 0b 	and	r11,r9,r11
8000e77a:	f0 0b 18 00 	cp.b	r11,r8
8000e77e:	cf 41       	brne	8000e766 <_vfprintf_r+0x11e>
8000e780:	40 ab       	lddsp	r11,sp[0x28]
8000e782:	e4 0b 01 06 	sub	r6,r2,r11
8000e786:	c2 50       	breq	8000e7d0 <_vfprintf_r+0x188>
8000e788:	fa f8 06 90 	ld.w	r8,sp[1680]
8000e78c:	0c 08       	add	r8,r6
8000e78e:	87 0b       	st.w	r3[0x0],r11
8000e790:	fb 48 06 90 	st.w	sp[1680],r8
8000e794:	87 16       	st.w	r3[0x4],r6
8000e796:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000e79a:	2f f8       	sub	r8,-1
8000e79c:	fb 48 06 8c 	st.w	sp[1676],r8
8000e7a0:	58 78       	cp.w	r8,7
8000e7a2:	e0 89 00 0b 	brgt	8000e7b8 <_vfprintf_r+0x170>
8000e7a6:	2f 83       	sub	r3,-8
8000e7a8:	c1 18       	rjmp	8000e7ca <_vfprintf_r+0x182>
8000e7aa:	d7 03       	nop
8000e7ac:	80 01       	ld.sh	r1,r0[0x0]
8000e7ae:	6d a4       	ld.w	r4,r6[0x68]
8000e7b0:	80 01       	ld.sh	r1,r0[0x0]
8000e7b2:	6d c4       	ld.w	r4,r6[0x70]
8000e7b4:	80 01       	ld.sh	r1,r0[0x0]
8000e7b6:	6d e4       	ld.w	r4,r6[0x78]
8000e7b8:	fa ca f9 78 	sub	r10,sp,-1672
8000e7bc:	02 9b       	mov	r11,r1
8000e7be:	08 9c       	mov	r12,r4
8000e7c0:	c3 6f       	rcall	8000e62c <__sprint_r>
8000e7c2:	e0 81 0e c8 	brne	80010552 <_vfprintf_r+0x1f0a>
8000e7c6:	fa c3 f9 e0 	sub	r3,sp,-1568
8000e7ca:	40 ba       	lddsp	r10,sp[0x2c]
8000e7cc:	0c 0a       	add	r10,r6
8000e7ce:	50 ba       	stdsp	sp[0x2c],r10
8000e7d0:	05 89       	ld.ub	r9,r2[0x0]
8000e7d2:	30 08       	mov	r8,0
8000e7d4:	f0 09 18 00 	cp.b	r9,r8
8000e7d8:	e0 80 0e ac 	breq	80010530 <_vfprintf_r+0x1ee8>
8000e7dc:	30 09       	mov	r9,0
8000e7de:	fb 68 06 bb 	st.b	sp[1723],r8
8000e7e2:	0e 96       	mov	r6,r7
8000e7e4:	e4 c8 ff ff 	sub	r8,r2,-1
8000e7e8:	3f fe       	mov	lr,-1
8000e7ea:	50 93       	stdsp	sp[0x24],r3
8000e7ec:	50 41       	stdsp	sp[0x10],r1
8000e7ee:	0e 93       	mov	r3,r7
8000e7f0:	04 91       	mov	r1,r2
8000e7f2:	50 89       	stdsp	sp[0x20],r9
8000e7f4:	50 a8       	stdsp	sp[0x28],r8
8000e7f6:	50 2e       	stdsp	sp[0x8],lr
8000e7f8:	50 39       	stdsp	sp[0xc],r9
8000e7fa:	12 95       	mov	r5,r9
8000e7fc:	12 90       	mov	r0,r9
8000e7fe:	10 97       	mov	r7,r8
8000e800:	08 92       	mov	r2,r4
8000e802:	c0 78       	rjmp	8000e810 <_vfprintf_r+0x1c8>
8000e804:	3f fc       	mov	r12,-1
8000e806:	08 97       	mov	r7,r4
8000e808:	50 2c       	stdsp	sp[0x8],r12
8000e80a:	c0 38       	rjmp	8000e810 <_vfprintf_r+0x1c8>
8000e80c:	30 0b       	mov	r11,0
8000e80e:	50 3b       	stdsp	sp[0xc],r11
8000e810:	0f 38       	ld.ub	r8,r7++
8000e812:	c0 28       	rjmp	8000e816 <_vfprintf_r+0x1ce>
8000e814:	12 90       	mov	r0,r9
8000e816:	f0 c9 00 20 	sub	r9,r8,32
8000e81a:	e0 49 00 58 	cp.w	r9,88
8000e81e:	e0 8b 0a 32 	brhi	8000fc82 <_vfprintf_r+0x163a>
8000e822:	4d 9a       	lddpc	r10,8000e984 <_vfprintf_r+0x33c>
8000e824:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000e828:	50 a7       	stdsp	sp[0x28],r7
8000e82a:	50 80       	stdsp	sp[0x20],r0
8000e82c:	0c 97       	mov	r7,r6
8000e82e:	04 94       	mov	r4,r2
8000e830:	06 96       	mov	r6,r3
8000e832:	02 92       	mov	r2,r1
8000e834:	4d 59       	lddpc	r9,8000e988 <_vfprintf_r+0x340>
8000e836:	40 93       	lddsp	r3,sp[0x24]
8000e838:	10 90       	mov	r0,r8
8000e83a:	40 41       	lddsp	r1,sp[0x10]
8000e83c:	50 d9       	stdsp	sp[0x34],r9
8000e83e:	e0 8f 08 92 	bral	8000f962 <_vfprintf_r+0x131a>
8000e842:	30 08       	mov	r8,0
8000e844:	fb 39 06 bb 	ld.ub	r9,sp[1723]
8000e848:	f0 09 18 00 	cp.b	r9,r8
8000e84c:	ce 21       	brne	8000e810 <_vfprintf_r+0x1c8>
8000e84e:	32 08       	mov	r8,32
8000e850:	c6 e8       	rjmp	8000e92c <_vfprintf_r+0x2e4>
8000e852:	a1 a5       	sbr	r5,0x0
8000e854:	cd eb       	rjmp	8000e810 <_vfprintf_r+0x1c8>
8000e856:	0f 89       	ld.ub	r9,r7[0x0]
8000e858:	f2 c8 00 30 	sub	r8,r9,48
8000e85c:	58 98       	cp.w	r8,9
8000e85e:	e0 8b 00 1d 	brhi	8000e898 <_vfprintf_r+0x250>
8000e862:	ee c8 ff ff 	sub	r8,r7,-1
8000e866:	30 0b       	mov	r11,0
8000e868:	23 09       	sub	r9,48
8000e86a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000e86e:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000e872:	11 39       	ld.ub	r9,r8++
8000e874:	f2 ca 00 30 	sub	r10,r9,48
8000e878:	58 9a       	cp.w	r10,9
8000e87a:	fe 98 ff f7 	brls	8000e868 <_vfprintf_r+0x220>
8000e87e:	e0 49 00 24 	cp.w	r9,36
8000e882:	cc 51       	brne	8000e80c <_vfprintf_r+0x1c4>
8000e884:	e0 4b 00 20 	cp.w	r11,32
8000e888:	e0 89 0e 64 	brgt	80010550 <_vfprintf_r+0x1f08>
8000e88c:	20 1b       	sub	r11,1
8000e88e:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000e892:	12 3b       	cp.w	r11,r9
8000e894:	c0 95       	brlt	8000e8a6 <_vfprintf_r+0x25e>
8000e896:	c1 08       	rjmp	8000e8b6 <_vfprintf_r+0x26e>
8000e898:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000e89c:	ec ca ff ff 	sub	r10,r6,-1
8000e8a0:	12 36       	cp.w	r6,r9
8000e8a2:	c1 f5       	brlt	8000e8e0 <_vfprintf_r+0x298>
8000e8a4:	c2 68       	rjmp	8000e8f0 <_vfprintf_r+0x2a8>
8000e8a6:	fa ce f9 44 	sub	lr,sp,-1724
8000e8aa:	10 97       	mov	r7,r8
8000e8ac:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
8000e8b0:	f6 f0 fd 88 	ld.w	r0,r11[-632]
8000e8b4:	c3 58       	rjmp	8000e91e <_vfprintf_r+0x2d6>
8000e8b6:	10 97       	mov	r7,r8
8000e8b8:	fa c8 f9 50 	sub	r8,sp,-1712
8000e8bc:	1a d8       	st.w	--sp,r8
8000e8be:	fa c8 fa b8 	sub	r8,sp,-1352
8000e8c2:	1a d8       	st.w	--sp,r8
8000e8c4:	fa c8 fb b4 	sub	r8,sp,-1100
8000e8c8:	02 9a       	mov	r10,r1
8000e8ca:	1a d8       	st.w	--sp,r8
8000e8cc:	04 9c       	mov	r12,r2
8000e8ce:	fa c8 f9 40 	sub	r8,sp,-1728
8000e8d2:	fa c9 ff b4 	sub	r9,sp,-76
8000e8d6:	fe b0 fd 1b 	rcall	8000e30c <get_arg>
8000e8da:	2f dd       	sub	sp,-12
8000e8dc:	78 00       	ld.w	r0,r12[0x0]
8000e8de:	c2 08       	rjmp	8000e91e <_vfprintf_r+0x2d6>
8000e8e0:	fa cc f9 44 	sub	r12,sp,-1724
8000e8e4:	14 96       	mov	r6,r10
8000e8e6:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000e8ea:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000e8ee:	c1 88       	rjmp	8000e91e <_vfprintf_r+0x2d6>
8000e8f0:	41 08       	lddsp	r8,sp[0x40]
8000e8f2:	59 f9       	cp.w	r9,31
8000e8f4:	e0 89 00 11 	brgt	8000e916 <_vfprintf_r+0x2ce>
8000e8f8:	f0 cb ff fc 	sub	r11,r8,-4
8000e8fc:	51 0b       	stdsp	sp[0x40],r11
8000e8fe:	70 00       	ld.w	r0,r8[0x0]
8000e900:	fa cb f9 44 	sub	r11,sp,-1724
8000e904:	f6 09 00 38 	add	r8,r11,r9<<0x3
8000e908:	f1 40 fd 88 	st.w	r8[-632],r0
8000e90c:	2f f9       	sub	r9,-1
8000e90e:	14 96       	mov	r6,r10
8000e910:	fb 49 06 b4 	st.w	sp[1716],r9
8000e914:	c0 58       	rjmp	8000e91e <_vfprintf_r+0x2d6>
8000e916:	70 00       	ld.w	r0,r8[0x0]
8000e918:	14 96       	mov	r6,r10
8000e91a:	2f c8       	sub	r8,-4
8000e91c:	51 08       	stdsp	sp[0x40],r8
8000e91e:	58 00       	cp.w	r0,0
8000e920:	fe 94 ff 78 	brge	8000e810 <_vfprintf_r+0x1c8>
8000e924:	5c 30       	neg	r0
8000e926:	a3 a5       	sbr	r5,0x2
8000e928:	c7 4b       	rjmp	8000e810 <_vfprintf_r+0x1c8>
8000e92a:	32 b8       	mov	r8,43
8000e92c:	fb 68 06 bb 	st.b	sp[1723],r8
8000e930:	c7 0b       	rjmp	8000e810 <_vfprintf_r+0x1c8>
8000e932:	0f 38       	ld.ub	r8,r7++
8000e934:	e0 48 00 2a 	cp.w	r8,42
8000e938:	c0 30       	breq	8000e93e <_vfprintf_r+0x2f6>
8000e93a:	30 09       	mov	r9,0
8000e93c:	c7 d8       	rjmp	8000ea36 <_vfprintf_r+0x3ee>
8000e93e:	0f 88       	ld.ub	r8,r7[0x0]
8000e940:	f0 c9 00 30 	sub	r9,r8,48
8000e944:	58 99       	cp.w	r9,9
8000e946:	e0 8b 00 23 	brhi	8000e98c <_vfprintf_r+0x344>
8000e94a:	ee c4 ff ff 	sub	r4,r7,-1
8000e94e:	30 0b       	mov	r11,0
8000e950:	23 08       	sub	r8,48
8000e952:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000e956:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000e95a:	09 38       	ld.ub	r8,r4++
8000e95c:	f0 c9 00 30 	sub	r9,r8,48
8000e960:	58 99       	cp.w	r9,9
8000e962:	fe 98 ff f7 	brls	8000e950 <_vfprintf_r+0x308>
8000e966:	e0 48 00 24 	cp.w	r8,36
8000e96a:	fe 91 ff 51 	brne	8000e80c <_vfprintf_r+0x1c4>
8000e96e:	e0 4b 00 20 	cp.w	r11,32
8000e972:	e0 89 0d ef 	brgt	80010550 <_vfprintf_r+0x1f08>
8000e976:	20 1b       	sub	r11,1
8000e978:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000e97c:	10 3b       	cp.w	r11,r8
8000e97e:	c0 e5       	brlt	8000e99a <_vfprintf_r+0x352>
8000e980:	c1 58       	rjmp	8000e9aa <_vfprintf_r+0x362>
8000e982:	d7 03       	nop
8000e984:	80 01       	ld.sh	r1,r0[0x0]
8000e986:	6a 28       	ld.w	r8,r5[0x8]
8000e988:	80 01       	ld.sh	r1,r0[0x0]
8000e98a:	68 b4       	ld.w	r4,r4[0x2c]
8000e98c:	fa fa 06 b4 	ld.w	r10,sp[1716]
8000e990:	ec c9 ff ff 	sub	r9,r6,-1
8000e994:	14 36       	cp.w	r6,r10
8000e996:	c1 f5       	brlt	8000e9d4 <_vfprintf_r+0x38c>
8000e998:	c2 88       	rjmp	8000e9e8 <_vfprintf_r+0x3a0>
8000e99a:	fa ca f9 44 	sub	r10,sp,-1724
8000e99e:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000e9a2:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000e9a6:	50 2b       	stdsp	sp[0x8],r11
8000e9a8:	c3 c8       	rjmp	8000ea20 <_vfprintf_r+0x3d8>
8000e9aa:	fa c8 f9 50 	sub	r8,sp,-1712
8000e9ae:	1a d8       	st.w	--sp,r8
8000e9b0:	fa c8 fa b8 	sub	r8,sp,-1352
8000e9b4:	1a d8       	st.w	--sp,r8
8000e9b6:	fa c8 fb b4 	sub	r8,sp,-1100
8000e9ba:	02 9a       	mov	r10,r1
8000e9bc:	1a d8       	st.w	--sp,r8
8000e9be:	04 9c       	mov	r12,r2
8000e9c0:	fa c8 f9 40 	sub	r8,sp,-1728
8000e9c4:	fa c9 ff b4 	sub	r9,sp,-76
8000e9c8:	fe b0 fc a2 	rcall	8000e30c <get_arg>
8000e9cc:	2f dd       	sub	sp,-12
8000e9ce:	78 0c       	ld.w	r12,r12[0x0]
8000e9d0:	50 2c       	stdsp	sp[0x8],r12
8000e9d2:	c2 78       	rjmp	8000ea20 <_vfprintf_r+0x3d8>
8000e9d4:	12 96       	mov	r6,r9
8000e9d6:	0e 94       	mov	r4,r7
8000e9d8:	fa c9 f9 44 	sub	r9,sp,-1724
8000e9dc:	f2 03 00 38 	add	r8,r9,r3<<0x3
8000e9e0:	f0 f8 fd 88 	ld.w	r8,r8[-632]
8000e9e4:	50 28       	stdsp	sp[0x8],r8
8000e9e6:	c1 d8       	rjmp	8000ea20 <_vfprintf_r+0x3d8>
8000e9e8:	41 08       	lddsp	r8,sp[0x40]
8000e9ea:	59 fa       	cp.w	r10,31
8000e9ec:	e0 89 00 14 	brgt	8000ea14 <_vfprintf_r+0x3cc>
8000e9f0:	f0 cb ff fc 	sub	r11,r8,-4
8000e9f4:	70 08       	ld.w	r8,r8[0x0]
8000e9f6:	51 0b       	stdsp	sp[0x40],r11
8000e9f8:	50 28       	stdsp	sp[0x8],r8
8000e9fa:	fa c6 f9 44 	sub	r6,sp,-1724
8000e9fe:	40 2e       	lddsp	lr,sp[0x8]
8000ea00:	ec 0a 00 38 	add	r8,r6,r10<<0x3
8000ea04:	f1 4e fd 88 	st.w	r8[-632],lr
8000ea08:	2f fa       	sub	r10,-1
8000ea0a:	0e 94       	mov	r4,r7
8000ea0c:	fb 4a 06 b4 	st.w	sp[1716],r10
8000ea10:	12 96       	mov	r6,r9
8000ea12:	c0 78       	rjmp	8000ea20 <_vfprintf_r+0x3d8>
8000ea14:	70 0c       	ld.w	r12,r8[0x0]
8000ea16:	0e 94       	mov	r4,r7
8000ea18:	2f c8       	sub	r8,-4
8000ea1a:	50 2c       	stdsp	sp[0x8],r12
8000ea1c:	12 96       	mov	r6,r9
8000ea1e:	51 08       	stdsp	sp[0x40],r8
8000ea20:	40 2b       	lddsp	r11,sp[0x8]
8000ea22:	58 0b       	cp.w	r11,0
8000ea24:	fe 95 fe f0 	brlt	8000e804 <_vfprintf_r+0x1bc>
8000ea28:	08 97       	mov	r7,r4
8000ea2a:	cf 3a       	rjmp	8000e810 <_vfprintf_r+0x1c8>
8000ea2c:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000ea30:	0f 38       	ld.ub	r8,r7++
8000ea32:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000ea36:	f0 ca 00 30 	sub	r10,r8,48
8000ea3a:	58 9a       	cp.w	r10,9
8000ea3c:	fe 98 ff f8 	brls	8000ea2c <_vfprintf_r+0x3e4>
8000ea40:	3f fa       	mov	r10,-1
8000ea42:	f2 0a 0c 49 	max	r9,r9,r10
8000ea46:	50 29       	stdsp	sp[0x8],r9
8000ea48:	ce 7a       	rjmp	8000e816 <_vfprintf_r+0x1ce>
8000ea4a:	a7 b5       	sbr	r5,0x7
8000ea4c:	ce 2a       	rjmp	8000e810 <_vfprintf_r+0x1c8>
8000ea4e:	30 09       	mov	r9,0
8000ea50:	23 08       	sub	r8,48
8000ea52:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000ea56:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000ea5a:	0f 38       	ld.ub	r8,r7++
8000ea5c:	f0 ca 00 30 	sub	r10,r8,48
8000ea60:	58 9a       	cp.w	r10,9
8000ea62:	fe 98 ff f7 	brls	8000ea50 <_vfprintf_r+0x408>
8000ea66:	e0 48 00 24 	cp.w	r8,36
8000ea6a:	fe 91 fe d5 	brne	8000e814 <_vfprintf_r+0x1cc>
8000ea6e:	e0 49 00 20 	cp.w	r9,32
8000ea72:	e0 89 0d 6f 	brgt	80010550 <_vfprintf_r+0x1f08>
8000ea76:	f2 c3 00 01 	sub	r3,r9,1
8000ea7a:	30 19       	mov	r9,1
8000ea7c:	50 39       	stdsp	sp[0xc],r9
8000ea7e:	cc 9a       	rjmp	8000e810 <_vfprintf_r+0x1c8>
8000ea80:	a3 b5       	sbr	r5,0x3
8000ea82:	cc 7a       	rjmp	8000e810 <_vfprintf_r+0x1c8>
8000ea84:	a7 a5       	sbr	r5,0x6
8000ea86:	cc 5a       	rjmp	8000e810 <_vfprintf_r+0x1c8>
8000ea88:	0a 98       	mov	r8,r5
8000ea8a:	a5 b5       	sbr	r5,0x5
8000ea8c:	a5 a8       	sbr	r8,0x4
8000ea8e:	0f 89       	ld.ub	r9,r7[0x0]
8000ea90:	36 ce       	mov	lr,108
8000ea92:	fc 09 18 00 	cp.b	r9,lr
8000ea96:	f7 b7 00 ff 	subeq	r7,-1
8000ea9a:	f0 05 17 10 	movne	r5,r8
8000ea9e:	cb 9a       	rjmp	8000e810 <_vfprintf_r+0x1c8>
8000eaa0:	a5 b5       	sbr	r5,0x5
8000eaa2:	cb 7a       	rjmp	8000e810 <_vfprintf_r+0x1c8>
8000eaa4:	50 a7       	stdsp	sp[0x28],r7
8000eaa6:	50 80       	stdsp	sp[0x20],r0
8000eaa8:	0c 97       	mov	r7,r6
8000eaaa:	10 90       	mov	r0,r8
8000eaac:	06 96       	mov	r6,r3
8000eaae:	04 94       	mov	r4,r2
8000eab0:	40 93       	lddsp	r3,sp[0x24]
8000eab2:	02 92       	mov	r2,r1
8000eab4:	0e 99       	mov	r9,r7
8000eab6:	40 41       	lddsp	r1,sp[0x10]
8000eab8:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000eabc:	40 3c       	lddsp	r12,sp[0xc]
8000eabe:	58 0c       	cp.w	r12,0
8000eac0:	c1 d0       	breq	8000eafa <_vfprintf_r+0x4b2>
8000eac2:	10 36       	cp.w	r6,r8
8000eac4:	c0 64       	brge	8000ead0 <_vfprintf_r+0x488>
8000eac6:	fa cb f9 44 	sub	r11,sp,-1724
8000eaca:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000eace:	c1 d8       	rjmp	8000eb08 <_vfprintf_r+0x4c0>
8000ead0:	fa c8 f9 50 	sub	r8,sp,-1712
8000ead4:	1a d8       	st.w	--sp,r8
8000ead6:	fa c8 fa b8 	sub	r8,sp,-1352
8000eada:	1a d8       	st.w	--sp,r8
8000eadc:	fa c8 fb b4 	sub	r8,sp,-1100
8000eae0:	1a d8       	st.w	--sp,r8
8000eae2:	fa c8 f9 40 	sub	r8,sp,-1728
8000eae6:	fa c9 ff b4 	sub	r9,sp,-76
8000eaea:	04 9a       	mov	r10,r2
8000eaec:	0c 9b       	mov	r11,r6
8000eaee:	08 9c       	mov	r12,r4
8000eaf0:	fe b0 fc 0e 	rcall	8000e30c <get_arg>
8000eaf4:	2f dd       	sub	sp,-12
8000eaf6:	19 b8       	ld.ub	r8,r12[0x3]
8000eaf8:	c2 28       	rjmp	8000eb3c <_vfprintf_r+0x4f4>
8000eafa:	2f f7       	sub	r7,-1
8000eafc:	10 39       	cp.w	r9,r8
8000eafe:	c0 84       	brge	8000eb0e <_vfprintf_r+0x4c6>
8000eb00:	fa ca f9 44 	sub	r10,sp,-1724
8000eb04:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000eb08:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8000eb0c:	c1 88       	rjmp	8000eb3c <_vfprintf_r+0x4f4>
8000eb0e:	41 09       	lddsp	r9,sp[0x40]
8000eb10:	59 f8       	cp.w	r8,31
8000eb12:	e0 89 00 12 	brgt	8000eb36 <_vfprintf_r+0x4ee>
8000eb16:	f2 ca ff fc 	sub	r10,r9,-4
8000eb1a:	51 0a       	stdsp	sp[0x40],r10
8000eb1c:	72 09       	ld.w	r9,r9[0x0]
8000eb1e:	fa c6 f9 44 	sub	r6,sp,-1724
8000eb22:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000eb26:	2f f8       	sub	r8,-1
8000eb28:	f5 49 fd 88 	st.w	r10[-632],r9
8000eb2c:	fb 48 06 b4 	st.w	sp[1716],r8
8000eb30:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000eb34:	c0 48       	rjmp	8000eb3c <_vfprintf_r+0x4f4>
8000eb36:	13 b8       	ld.ub	r8,r9[0x3]
8000eb38:	2f c9       	sub	r9,-4
8000eb3a:	51 09       	stdsp	sp[0x40],r9
8000eb3c:	fb 68 06 60 	st.b	sp[1632],r8
8000eb40:	30 0e       	mov	lr,0
8000eb42:	30 08       	mov	r8,0
8000eb44:	30 12       	mov	r2,1
8000eb46:	fb 68 06 bb 	st.b	sp[1723],r8
8000eb4a:	50 2e       	stdsp	sp[0x8],lr
8000eb4c:	e0 8f 08 ad 	bral	8000fca6 <_vfprintf_r+0x165e>
8000eb50:	50 a7       	stdsp	sp[0x28],r7
8000eb52:	50 80       	stdsp	sp[0x20],r0
8000eb54:	0c 97       	mov	r7,r6
8000eb56:	04 94       	mov	r4,r2
8000eb58:	06 96       	mov	r6,r3
8000eb5a:	02 92       	mov	r2,r1
8000eb5c:	40 93       	lddsp	r3,sp[0x24]
8000eb5e:	10 90       	mov	r0,r8
8000eb60:	40 41       	lddsp	r1,sp[0x10]
8000eb62:	a5 a5       	sbr	r5,0x4
8000eb64:	c0 a8       	rjmp	8000eb78 <_vfprintf_r+0x530>
8000eb66:	50 a7       	stdsp	sp[0x28],r7
8000eb68:	50 80       	stdsp	sp[0x20],r0
8000eb6a:	0c 97       	mov	r7,r6
8000eb6c:	04 94       	mov	r4,r2
8000eb6e:	06 96       	mov	r6,r3
8000eb70:	02 92       	mov	r2,r1
8000eb72:	40 93       	lddsp	r3,sp[0x24]
8000eb74:	10 90       	mov	r0,r8
8000eb76:	40 41       	lddsp	r1,sp[0x10]
8000eb78:	ed b5 00 05 	bld	r5,0x5
8000eb7c:	c5 11       	brne	8000ec1e <_vfprintf_r+0x5d6>
8000eb7e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000eb82:	40 3c       	lddsp	r12,sp[0xc]
8000eb84:	58 0c       	cp.w	r12,0
8000eb86:	c1 e0       	breq	8000ebc2 <_vfprintf_r+0x57a>
8000eb88:	10 36       	cp.w	r6,r8
8000eb8a:	c0 64       	brge	8000eb96 <_vfprintf_r+0x54e>
8000eb8c:	fa cb f9 44 	sub	r11,sp,-1724
8000eb90:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000eb94:	c2 08       	rjmp	8000ebd4 <_vfprintf_r+0x58c>
8000eb96:	fa c8 f9 50 	sub	r8,sp,-1712
8000eb9a:	1a d8       	st.w	--sp,r8
8000eb9c:	fa c8 fa b8 	sub	r8,sp,-1352
8000eba0:	0c 9b       	mov	r11,r6
8000eba2:	1a d8       	st.w	--sp,r8
8000eba4:	fa c8 fb b4 	sub	r8,sp,-1100
8000eba8:	1a d8       	st.w	--sp,r8
8000ebaa:	fa c9 ff b4 	sub	r9,sp,-76
8000ebae:	fa c8 f9 40 	sub	r8,sp,-1728
8000ebb2:	04 9a       	mov	r10,r2
8000ebb4:	08 9c       	mov	r12,r4
8000ebb6:	fe b0 fb ab 	rcall	8000e30c <get_arg>
8000ebba:	2f dd       	sub	sp,-12
8000ebbc:	78 1b       	ld.w	r11,r12[0x4]
8000ebbe:	78 09       	ld.w	r9,r12[0x0]
8000ebc0:	c2 b8       	rjmp	8000ec16 <_vfprintf_r+0x5ce>
8000ebc2:	ee ca ff ff 	sub	r10,r7,-1
8000ebc6:	10 37       	cp.w	r7,r8
8000ebc8:	c0 b4       	brge	8000ebde <_vfprintf_r+0x596>
8000ebca:	fa c9 f9 44 	sub	r9,sp,-1724
8000ebce:	14 97       	mov	r7,r10
8000ebd0:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000ebd4:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000ebd8:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000ebdc:	c1 d8       	rjmp	8000ec16 <_vfprintf_r+0x5ce>
8000ebde:	41 09       	lddsp	r9,sp[0x40]
8000ebe0:	59 f8       	cp.w	r8,31
8000ebe2:	e0 89 00 14 	brgt	8000ec0a <_vfprintf_r+0x5c2>
8000ebe6:	f2 cb ff f8 	sub	r11,r9,-8
8000ebea:	51 0b       	stdsp	sp[0x40],r11
8000ebec:	fa c6 f9 44 	sub	r6,sp,-1724
8000ebf0:	72 1b       	ld.w	r11,r9[0x4]
8000ebf2:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000ebf6:	72 09       	ld.w	r9,r9[0x0]
8000ebf8:	f9 4b fd 8c 	st.w	r12[-628],r11
8000ebfc:	f9 49 fd 88 	st.w	r12[-632],r9
8000ec00:	2f f8       	sub	r8,-1
8000ec02:	14 97       	mov	r7,r10
8000ec04:	fb 48 06 b4 	st.w	sp[1716],r8
8000ec08:	c0 78       	rjmp	8000ec16 <_vfprintf_r+0x5ce>
8000ec0a:	f2 c8 ff f8 	sub	r8,r9,-8
8000ec0e:	72 1b       	ld.w	r11,r9[0x4]
8000ec10:	14 97       	mov	r7,r10
8000ec12:	51 08       	stdsp	sp[0x40],r8
8000ec14:	72 09       	ld.w	r9,r9[0x0]
8000ec16:	16 98       	mov	r8,r11
8000ec18:	fa e9 00 00 	st.d	sp[0],r8
8000ec1c:	ca e8       	rjmp	8000ed78 <_vfprintf_r+0x730>
8000ec1e:	ed b5 00 04 	bld	r5,0x4
8000ec22:	c1 71       	brne	8000ec50 <_vfprintf_r+0x608>
8000ec24:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000ec28:	40 3e       	lddsp	lr,sp[0xc]
8000ec2a:	58 0e       	cp.w	lr,0
8000ec2c:	c0 80       	breq	8000ec3c <_vfprintf_r+0x5f4>
8000ec2e:	10 36       	cp.w	r6,r8
8000ec30:	c6 94       	brge	8000ed02 <_vfprintf_r+0x6ba>
8000ec32:	fa cc f9 44 	sub	r12,sp,-1724
8000ec36:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000ec3a:	c8 28       	rjmp	8000ed3e <_vfprintf_r+0x6f6>
8000ec3c:	ee ca ff ff 	sub	r10,r7,-1
8000ec40:	10 37       	cp.w	r7,r8
8000ec42:	e0 84 00 81 	brge	8000ed44 <_vfprintf_r+0x6fc>
8000ec46:	fa cb f9 44 	sub	r11,sp,-1724
8000ec4a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000ec4e:	c7 78       	rjmp	8000ed3c <_vfprintf_r+0x6f4>
8000ec50:	ed b5 00 06 	bld	r5,0x6
8000ec54:	c4 b1       	brne	8000ecea <_vfprintf_r+0x6a2>
8000ec56:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000ec5a:	40 3c       	lddsp	r12,sp[0xc]
8000ec5c:	58 0c       	cp.w	r12,0
8000ec5e:	c1 d0       	breq	8000ec98 <_vfprintf_r+0x650>
8000ec60:	10 36       	cp.w	r6,r8
8000ec62:	c0 64       	brge	8000ec6e <_vfprintf_r+0x626>
8000ec64:	fa cb f9 44 	sub	r11,sp,-1724
8000ec68:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000ec6c:	c1 f8       	rjmp	8000ecaa <_vfprintf_r+0x662>
8000ec6e:	fa c8 f9 50 	sub	r8,sp,-1712
8000ec72:	1a d8       	st.w	--sp,r8
8000ec74:	fa c8 fa b8 	sub	r8,sp,-1352
8000ec78:	1a d8       	st.w	--sp,r8
8000ec7a:	fa c8 fb b4 	sub	r8,sp,-1100
8000ec7e:	1a d8       	st.w	--sp,r8
8000ec80:	fa c8 f9 40 	sub	r8,sp,-1728
8000ec84:	fa c9 ff b4 	sub	r9,sp,-76
8000ec88:	04 9a       	mov	r10,r2
8000ec8a:	0c 9b       	mov	r11,r6
8000ec8c:	08 9c       	mov	r12,r4
8000ec8e:	fe b0 fb 3f 	rcall	8000e30c <get_arg>
8000ec92:	2f dd       	sub	sp,-12
8000ec94:	98 18       	ld.sh	r8,r12[0x2]
8000ec96:	c2 68       	rjmp	8000ece2 <_vfprintf_r+0x69a>
8000ec98:	ee ca ff ff 	sub	r10,r7,-1
8000ec9c:	10 37       	cp.w	r7,r8
8000ec9e:	c0 94       	brge	8000ecb0 <_vfprintf_r+0x668>
8000eca0:	fa c9 f9 44 	sub	r9,sp,-1724
8000eca4:	14 97       	mov	r7,r10
8000eca6:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000ecaa:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000ecae:	c1 a8       	rjmp	8000ece2 <_vfprintf_r+0x69a>
8000ecb0:	41 09       	lddsp	r9,sp[0x40]
8000ecb2:	59 f8       	cp.w	r8,31
8000ecb4:	e0 89 00 13 	brgt	8000ecda <_vfprintf_r+0x692>
8000ecb8:	f2 cb ff fc 	sub	r11,r9,-4
8000ecbc:	51 0b       	stdsp	sp[0x40],r11
8000ecbe:	72 09       	ld.w	r9,r9[0x0]
8000ecc0:	fa c6 f9 44 	sub	r6,sp,-1724
8000ecc4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000ecc8:	2f f8       	sub	r8,-1
8000ecca:	f7 49 fd 88 	st.w	r11[-632],r9
8000ecce:	fb 48 06 b4 	st.w	sp[1716],r8
8000ecd2:	14 97       	mov	r7,r10
8000ecd4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000ecd8:	c0 58       	rjmp	8000ece2 <_vfprintf_r+0x69a>
8000ecda:	92 18       	ld.sh	r8,r9[0x2]
8000ecdc:	14 97       	mov	r7,r10
8000ecde:	2f c9       	sub	r9,-4
8000ece0:	51 09       	stdsp	sp[0x40],r9
8000ece2:	50 18       	stdsp	sp[0x4],r8
8000ece4:	bf 58       	asr	r8,0x1f
8000ece6:	50 08       	stdsp	sp[0x0],r8
8000ece8:	c4 88       	rjmp	8000ed78 <_vfprintf_r+0x730>
8000ecea:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000ecee:	40 3c       	lddsp	r12,sp[0xc]
8000ecf0:	58 0c       	cp.w	r12,0
8000ecf2:	c1 d0       	breq	8000ed2c <_vfprintf_r+0x6e4>
8000ecf4:	10 36       	cp.w	r6,r8
8000ecf6:	c0 64       	brge	8000ed02 <_vfprintf_r+0x6ba>
8000ecf8:	fa cb f9 44 	sub	r11,sp,-1724
8000ecfc:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000ed00:	c1 f8       	rjmp	8000ed3e <_vfprintf_r+0x6f6>
8000ed02:	fa c8 f9 50 	sub	r8,sp,-1712
8000ed06:	1a d8       	st.w	--sp,r8
8000ed08:	fa c8 fa b8 	sub	r8,sp,-1352
8000ed0c:	0c 9b       	mov	r11,r6
8000ed0e:	1a d8       	st.w	--sp,r8
8000ed10:	fa c8 fb b4 	sub	r8,sp,-1100
8000ed14:	04 9a       	mov	r10,r2
8000ed16:	1a d8       	st.w	--sp,r8
8000ed18:	08 9c       	mov	r12,r4
8000ed1a:	fa c8 f9 40 	sub	r8,sp,-1728
8000ed1e:	fa c9 ff b4 	sub	r9,sp,-76
8000ed22:	fe b0 fa f5 	rcall	8000e30c <get_arg>
8000ed26:	2f dd       	sub	sp,-12
8000ed28:	78 0b       	ld.w	r11,r12[0x0]
8000ed2a:	c2 48       	rjmp	8000ed72 <_vfprintf_r+0x72a>
8000ed2c:	ee ca ff ff 	sub	r10,r7,-1
8000ed30:	10 37       	cp.w	r7,r8
8000ed32:	c0 94       	brge	8000ed44 <_vfprintf_r+0x6fc>
8000ed34:	fa c9 f9 44 	sub	r9,sp,-1724
8000ed38:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000ed3c:	14 97       	mov	r7,r10
8000ed3e:	ec fb fd 88 	ld.w	r11,r6[-632]
8000ed42:	c1 88       	rjmp	8000ed72 <_vfprintf_r+0x72a>
8000ed44:	41 09       	lddsp	r9,sp[0x40]
8000ed46:	59 f8       	cp.w	r8,31
8000ed48:	e0 89 00 11 	brgt	8000ed6a <_vfprintf_r+0x722>
8000ed4c:	f2 cb ff fc 	sub	r11,r9,-4
8000ed50:	51 0b       	stdsp	sp[0x40],r11
8000ed52:	fa c6 f9 44 	sub	r6,sp,-1724
8000ed56:	72 0b       	ld.w	r11,r9[0x0]
8000ed58:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000ed5c:	f3 4b fd 88 	st.w	r9[-632],r11
8000ed60:	2f f8       	sub	r8,-1
8000ed62:	14 97       	mov	r7,r10
8000ed64:	fb 48 06 b4 	st.w	sp[1716],r8
8000ed68:	c0 58       	rjmp	8000ed72 <_vfprintf_r+0x72a>
8000ed6a:	72 0b       	ld.w	r11,r9[0x0]
8000ed6c:	14 97       	mov	r7,r10
8000ed6e:	2f c9       	sub	r9,-4
8000ed70:	51 09       	stdsp	sp[0x40],r9
8000ed72:	50 1b       	stdsp	sp[0x4],r11
8000ed74:	bf 5b       	asr	r11,0x1f
8000ed76:	50 0b       	stdsp	sp[0x0],r11
8000ed78:	fa ea 00 00 	ld.d	r10,sp[0]
8000ed7c:	58 0a       	cp.w	r10,0
8000ed7e:	5c 2b       	cpc	r11
8000ed80:	c0 e4       	brge	8000ed9c <_vfprintf_r+0x754>
8000ed82:	30 08       	mov	r8,0
8000ed84:	fa ea 00 00 	ld.d	r10,sp[0]
8000ed88:	30 09       	mov	r9,0
8000ed8a:	f0 0a 01 0a 	sub	r10,r8,r10
8000ed8e:	f2 0b 01 4b 	sbc	r11,r9,r11
8000ed92:	32 d8       	mov	r8,45
8000ed94:	fa eb 00 00 	st.d	sp[0],r10
8000ed98:	fb 68 06 bb 	st.b	sp[1723],r8
8000ed9c:	30 18       	mov	r8,1
8000ed9e:	e0 8f 06 fa 	bral	8000fb92 <_vfprintf_r+0x154a>
8000eda2:	50 a7       	stdsp	sp[0x28],r7
8000eda4:	50 80       	stdsp	sp[0x20],r0
8000eda6:	0c 97       	mov	r7,r6
8000eda8:	04 94       	mov	r4,r2
8000edaa:	06 96       	mov	r6,r3
8000edac:	02 92       	mov	r2,r1
8000edae:	40 93       	lddsp	r3,sp[0x24]
8000edb0:	10 90       	mov	r0,r8
8000edb2:	40 41       	lddsp	r1,sp[0x10]
8000edb4:	0e 99       	mov	r9,r7
8000edb6:	ed b5 00 03 	bld	r5,0x3
8000edba:	c4 11       	brne	8000ee3c <_vfprintf_r+0x7f4>
8000edbc:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000edc0:	40 3a       	lddsp	r10,sp[0xc]
8000edc2:	58 0a       	cp.w	r10,0
8000edc4:	c1 90       	breq	8000edf6 <_vfprintf_r+0x7ae>
8000edc6:	10 36       	cp.w	r6,r8
8000edc8:	c6 45       	brlt	8000ee90 <_vfprintf_r+0x848>
8000edca:	fa c8 f9 50 	sub	r8,sp,-1712
8000edce:	1a d8       	st.w	--sp,r8
8000edd0:	fa c8 fa b8 	sub	r8,sp,-1352
8000edd4:	1a d8       	st.w	--sp,r8
8000edd6:	fa c8 fb b4 	sub	r8,sp,-1100
8000edda:	0c 9b       	mov	r11,r6
8000eddc:	1a d8       	st.w	--sp,r8
8000edde:	04 9a       	mov	r10,r2
8000ede0:	fa c8 f9 40 	sub	r8,sp,-1728
8000ede4:	fa c9 ff b4 	sub	r9,sp,-76
8000ede8:	08 9c       	mov	r12,r4
8000edea:	fe b0 fa 91 	rcall	8000e30c <get_arg>
8000edee:	2f dd       	sub	sp,-12
8000edf0:	78 16       	ld.w	r6,r12[0x4]
8000edf2:	50 76       	stdsp	sp[0x1c],r6
8000edf4:	c4 88       	rjmp	8000ee84 <_vfprintf_r+0x83c>
8000edf6:	2f f7       	sub	r7,-1
8000edf8:	10 39       	cp.w	r9,r8
8000edfa:	c0 c4       	brge	8000ee12 <_vfprintf_r+0x7ca>
8000edfc:	fa ce f9 44 	sub	lr,sp,-1724
8000ee00:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000ee04:	ec fc fd 8c 	ld.w	r12,r6[-628]
8000ee08:	50 7c       	stdsp	sp[0x1c],r12
8000ee0a:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000ee0e:	50 56       	stdsp	sp[0x14],r6
8000ee10:	c6 68       	rjmp	8000eedc <_vfprintf_r+0x894>
8000ee12:	41 09       	lddsp	r9,sp[0x40]
8000ee14:	59 f8       	cp.w	r8,31
8000ee16:	e0 89 00 10 	brgt	8000ee36 <_vfprintf_r+0x7ee>
8000ee1a:	f2 ca ff f8 	sub	r10,r9,-8
8000ee1e:	72 1b       	ld.w	r11,r9[0x4]
8000ee20:	51 0a       	stdsp	sp[0x40],r10
8000ee22:	72 09       	ld.w	r9,r9[0x0]
8000ee24:	fa ca f9 44 	sub	r10,sp,-1724
8000ee28:	50 7b       	stdsp	sp[0x1c],r11
8000ee2a:	50 59       	stdsp	sp[0x14],r9
8000ee2c:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000ee30:	40 5b       	lddsp	r11,sp[0x14]
8000ee32:	40 7a       	lddsp	r10,sp[0x1c]
8000ee34:	c4 78       	rjmp	8000eec2 <_vfprintf_r+0x87a>
8000ee36:	72 18       	ld.w	r8,r9[0x4]
8000ee38:	50 78       	stdsp	sp[0x1c],r8
8000ee3a:	c4 c8       	rjmp	8000eed2 <_vfprintf_r+0x88a>
8000ee3c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000ee40:	40 3e       	lddsp	lr,sp[0xc]
8000ee42:	58 0e       	cp.w	lr,0
8000ee44:	c2 30       	breq	8000ee8a <_vfprintf_r+0x842>
8000ee46:	10 36       	cp.w	r6,r8
8000ee48:	c0 94       	brge	8000ee5a <_vfprintf_r+0x812>
8000ee4a:	fa cc f9 44 	sub	r12,sp,-1724
8000ee4e:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000ee52:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000ee56:	50 7b       	stdsp	sp[0x1c],r11
8000ee58:	cd 9b       	rjmp	8000ee0a <_vfprintf_r+0x7c2>
8000ee5a:	fa c8 f9 50 	sub	r8,sp,-1712
8000ee5e:	1a d8       	st.w	--sp,r8
8000ee60:	fa c8 fa b8 	sub	r8,sp,-1352
8000ee64:	04 9a       	mov	r10,r2
8000ee66:	1a d8       	st.w	--sp,r8
8000ee68:	fa c8 fb b4 	sub	r8,sp,-1100
8000ee6c:	0c 9b       	mov	r11,r6
8000ee6e:	1a d8       	st.w	--sp,r8
8000ee70:	08 9c       	mov	r12,r4
8000ee72:	fa c8 f9 40 	sub	r8,sp,-1728
8000ee76:	fa c9 ff b4 	sub	r9,sp,-76
8000ee7a:	fe b0 fa 49 	rcall	8000e30c <get_arg>
8000ee7e:	2f dd       	sub	sp,-12
8000ee80:	78 1a       	ld.w	r10,r12[0x4]
8000ee82:	50 7a       	stdsp	sp[0x1c],r10
8000ee84:	78 0c       	ld.w	r12,r12[0x0]
8000ee86:	50 5c       	stdsp	sp[0x14],r12
8000ee88:	c2 a8       	rjmp	8000eedc <_vfprintf_r+0x894>
8000ee8a:	2f f7       	sub	r7,-1
8000ee8c:	10 39       	cp.w	r9,r8
8000ee8e:	c0 94       	brge	8000eea0 <_vfprintf_r+0x858>
8000ee90:	fa c9 f9 44 	sub	r9,sp,-1724
8000ee94:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000ee98:	ec f8 fd 8c 	ld.w	r8,r6[-628]
8000ee9c:	50 78       	stdsp	sp[0x1c],r8
8000ee9e:	cb 6b       	rjmp	8000ee0a <_vfprintf_r+0x7c2>
8000eea0:	41 09       	lddsp	r9,sp[0x40]
8000eea2:	59 f8       	cp.w	r8,31
8000eea4:	e0 89 00 15 	brgt	8000eece <_vfprintf_r+0x886>
8000eea8:	f2 ca ff f8 	sub	r10,r9,-8
8000eeac:	72 16       	ld.w	r6,r9[0x4]
8000eeae:	72 09       	ld.w	r9,r9[0x0]
8000eeb0:	51 0a       	stdsp	sp[0x40],r10
8000eeb2:	50 59       	stdsp	sp[0x14],r9
8000eeb4:	fa ce f9 44 	sub	lr,sp,-1724
8000eeb8:	50 76       	stdsp	sp[0x1c],r6
8000eeba:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000eebe:	40 5b       	lddsp	r11,sp[0x14]
8000eec0:	0c 9a       	mov	r10,r6
8000eec2:	f2 eb fd 88 	st.d	r9[-632],r10
8000eec6:	2f f8       	sub	r8,-1
8000eec8:	fb 48 06 b4 	st.w	sp[1716],r8
8000eecc:	c0 88       	rjmp	8000eedc <_vfprintf_r+0x894>
8000eece:	72 1c       	ld.w	r12,r9[0x4]
8000eed0:	50 7c       	stdsp	sp[0x1c],r12
8000eed2:	f2 c8 ff f8 	sub	r8,r9,-8
8000eed6:	51 08       	stdsp	sp[0x40],r8
8000eed8:	72 09       	ld.w	r9,r9[0x0]
8000eeda:	50 59       	stdsp	sp[0x14],r9
8000eedc:	40 5b       	lddsp	r11,sp[0x14]
8000eede:	40 7a       	lddsp	r10,sp[0x1c]
8000eee0:	e0 a0 1a bc 	rcall	80012458 <__isinfd>
8000eee4:	18 96       	mov	r6,r12
8000eee6:	c1 70       	breq	8000ef14 <_vfprintf_r+0x8cc>
8000eee8:	30 08       	mov	r8,0
8000eeea:	30 09       	mov	r9,0
8000eeec:	40 5b       	lddsp	r11,sp[0x14]
8000eeee:	40 7a       	lddsp	r10,sp[0x1c]
8000eef0:	e0 a0 1c 95 	rcall	8001281a <__avr32_f64_cmp_lt>
8000eef4:	c0 40       	breq	8000eefc <_vfprintf_r+0x8b4>
8000eef6:	32 d8       	mov	r8,45
8000eef8:	fb 68 06 bb 	st.b	sp[1723],r8
8000eefc:	fe c8 82 98 	sub	r8,pc,-32104
8000ef00:	fe c6 82 98 	sub	r6,pc,-32104
8000ef04:	a7 d5       	cbr	r5,0x7
8000ef06:	e0 40 00 47 	cp.w	r0,71
8000ef0a:	f0 06 17 a0 	movle	r6,r8
8000ef0e:	30 32       	mov	r2,3
8000ef10:	e0 8f 06 ce 	bral	8000fcac <_vfprintf_r+0x1664>
8000ef14:	40 5b       	lddsp	r11,sp[0x14]
8000ef16:	40 7a       	lddsp	r10,sp[0x1c]
8000ef18:	e0 a0 1a b5 	rcall	80012482 <__isnand>
8000ef1c:	c0 e0       	breq	8000ef38 <_vfprintf_r+0x8f0>
8000ef1e:	50 26       	stdsp	sp[0x8],r6
8000ef20:	fe c8 82 b4 	sub	r8,pc,-32076
8000ef24:	fe c6 82 b4 	sub	r6,pc,-32076
8000ef28:	a7 d5       	cbr	r5,0x7
8000ef2a:	e0 40 00 47 	cp.w	r0,71
8000ef2e:	f0 06 17 a0 	movle	r6,r8
8000ef32:	30 32       	mov	r2,3
8000ef34:	e0 8f 06 c2 	bral	8000fcb8 <_vfprintf_r+0x1670>
8000ef38:	40 2a       	lddsp	r10,sp[0x8]
8000ef3a:	5b fa       	cp.w	r10,-1
8000ef3c:	c0 41       	brne	8000ef44 <_vfprintf_r+0x8fc>
8000ef3e:	30 69       	mov	r9,6
8000ef40:	50 29       	stdsp	sp[0x8],r9
8000ef42:	c1 18       	rjmp	8000ef64 <_vfprintf_r+0x91c>
8000ef44:	e0 40 00 47 	cp.w	r0,71
8000ef48:	5f 09       	sreq	r9
8000ef4a:	e0 40 00 67 	cp.w	r0,103
8000ef4e:	5f 08       	sreq	r8
8000ef50:	f3 e8 10 08 	or	r8,r9,r8
8000ef54:	f8 08 18 00 	cp.b	r8,r12
8000ef58:	c0 60       	breq	8000ef64 <_vfprintf_r+0x91c>
8000ef5a:	40 28       	lddsp	r8,sp[0x8]
8000ef5c:	58 08       	cp.w	r8,0
8000ef5e:	f9 b8 00 01 	moveq	r8,1
8000ef62:	50 28       	stdsp	sp[0x8],r8
8000ef64:	40 78       	lddsp	r8,sp[0x1c]
8000ef66:	40 59       	lddsp	r9,sp[0x14]
8000ef68:	fa e9 06 94 	st.d	sp[1684],r8
8000ef6c:	a9 a5       	sbr	r5,0x8
8000ef6e:	fa f8 06 94 	ld.w	r8,sp[1684]
8000ef72:	58 08       	cp.w	r8,0
8000ef74:	c0 65       	brlt	8000ef80 <_vfprintf_r+0x938>
8000ef76:	40 5e       	lddsp	lr,sp[0x14]
8000ef78:	30 0c       	mov	r12,0
8000ef7a:	50 6e       	stdsp	sp[0x18],lr
8000ef7c:	50 9c       	stdsp	sp[0x24],r12
8000ef7e:	c0 78       	rjmp	8000ef8c <_vfprintf_r+0x944>
8000ef80:	40 5b       	lddsp	r11,sp[0x14]
8000ef82:	32 da       	mov	r10,45
8000ef84:	ee 1b 80 00 	eorh	r11,0x8000
8000ef88:	50 9a       	stdsp	sp[0x24],r10
8000ef8a:	50 6b       	stdsp	sp[0x18],r11
8000ef8c:	e0 40 00 46 	cp.w	r0,70
8000ef90:	5f 09       	sreq	r9
8000ef92:	e0 40 00 66 	cp.w	r0,102
8000ef96:	5f 08       	sreq	r8
8000ef98:	f3 e8 10 08 	or	r8,r9,r8
8000ef9c:	50 48       	stdsp	sp[0x10],r8
8000ef9e:	c0 40       	breq	8000efa6 <_vfprintf_r+0x95e>
8000efa0:	40 22       	lddsp	r2,sp[0x8]
8000efa2:	30 39       	mov	r9,3
8000efa4:	c1 08       	rjmp	8000efc4 <_vfprintf_r+0x97c>
8000efa6:	e0 40 00 45 	cp.w	r0,69
8000efaa:	5f 09       	sreq	r9
8000efac:	e0 40 00 65 	cp.w	r0,101
8000efb0:	5f 08       	sreq	r8
8000efb2:	40 22       	lddsp	r2,sp[0x8]
8000efb4:	10 49       	or	r9,r8
8000efb6:	2f f2       	sub	r2,-1
8000efb8:	40 46       	lddsp	r6,sp[0x10]
8000efba:	ec 09 18 00 	cp.b	r9,r6
8000efbe:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000efc2:	30 29       	mov	r9,2
8000efc4:	fa c8 f9 5c 	sub	r8,sp,-1700
8000efc8:	1a d8       	st.w	--sp,r8
8000efca:	fa c8 f9 54 	sub	r8,sp,-1708
8000efce:	1a d8       	st.w	--sp,r8
8000efd0:	fa c8 f9 4c 	sub	r8,sp,-1716
8000efd4:	08 9c       	mov	r12,r4
8000efd6:	1a d8       	st.w	--sp,r8
8000efd8:	04 98       	mov	r8,r2
8000efda:	40 9b       	lddsp	r11,sp[0x24]
8000efdc:	40 aa       	lddsp	r10,sp[0x28]
8000efde:	e0 a0 0b cb 	rcall	80010774 <_dtoa_r>
8000efe2:	e0 40 00 47 	cp.w	r0,71
8000efe6:	5f 19       	srne	r9
8000efe8:	e0 40 00 67 	cp.w	r0,103
8000efec:	5f 18       	srne	r8
8000efee:	18 96       	mov	r6,r12
8000eff0:	2f dd       	sub	sp,-12
8000eff2:	f3 e8 00 08 	and	r8,r9,r8
8000eff6:	c0 41       	brne	8000effe <_vfprintf_r+0x9b6>
8000eff8:	ed b5 00 00 	bld	r5,0x0
8000effc:	c3 01       	brne	8000f05c <_vfprintf_r+0xa14>
8000effe:	ec 02 00 0e 	add	lr,r6,r2
8000f002:	50 3e       	stdsp	sp[0xc],lr
8000f004:	40 4c       	lddsp	r12,sp[0x10]
8000f006:	58 0c       	cp.w	r12,0
8000f008:	c1 50       	breq	8000f032 <_vfprintf_r+0x9ea>
8000f00a:	0d 89       	ld.ub	r9,r6[0x0]
8000f00c:	33 08       	mov	r8,48
8000f00e:	f0 09 18 00 	cp.b	r9,r8
8000f012:	c0 b1       	brne	8000f028 <_vfprintf_r+0x9e0>
8000f014:	30 08       	mov	r8,0
8000f016:	30 09       	mov	r9,0
8000f018:	40 6b       	lddsp	r11,sp[0x18]
8000f01a:	40 7a       	lddsp	r10,sp[0x1c]
8000f01c:	e0 a0 1b b8 	rcall	8001278c <__avr32_f64_cmp_eq>
8000f020:	fb b2 00 01 	rsubeq	r2,1
8000f024:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
8000f028:	40 3b       	lddsp	r11,sp[0xc]
8000f02a:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000f02e:	10 0b       	add	r11,r8
8000f030:	50 3b       	stdsp	sp[0xc],r11
8000f032:	40 6b       	lddsp	r11,sp[0x18]
8000f034:	30 08       	mov	r8,0
8000f036:	30 09       	mov	r9,0
8000f038:	40 7a       	lddsp	r10,sp[0x1c]
8000f03a:	e0 a0 1b a9 	rcall	8001278c <__avr32_f64_cmp_eq>
8000f03e:	c0 90       	breq	8000f050 <_vfprintf_r+0xa08>
8000f040:	40 3a       	lddsp	r10,sp[0xc]
8000f042:	fb 4a 06 a4 	st.w	sp[1700],r10
8000f046:	c0 58       	rjmp	8000f050 <_vfprintf_r+0xa08>
8000f048:	10 c9       	st.b	r8++,r9
8000f04a:	fb 48 06 a4 	st.w	sp[1700],r8
8000f04e:	c0 28       	rjmp	8000f052 <_vfprintf_r+0xa0a>
8000f050:	33 09       	mov	r9,48
8000f052:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000f056:	40 3e       	lddsp	lr,sp[0xc]
8000f058:	1c 38       	cp.w	r8,lr
8000f05a:	cf 73       	brcs	8000f048 <_vfprintf_r+0xa00>
8000f05c:	e0 40 00 47 	cp.w	r0,71
8000f060:	5f 09       	sreq	r9
8000f062:	e0 40 00 67 	cp.w	r0,103
8000f066:	5f 08       	sreq	r8
8000f068:	f3 e8 10 08 	or	r8,r9,r8
8000f06c:	fa f9 06 a4 	ld.w	r9,sp[1700]
8000f070:	0c 19       	sub	r9,r6
8000f072:	50 69       	stdsp	sp[0x18],r9
8000f074:	58 08       	cp.w	r8,0
8000f076:	c0 b0       	breq	8000f08c <_vfprintf_r+0xa44>
8000f078:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000f07c:	5b d8       	cp.w	r8,-3
8000f07e:	c0 55       	brlt	8000f088 <_vfprintf_r+0xa40>
8000f080:	40 2c       	lddsp	r12,sp[0x8]
8000f082:	18 38       	cp.w	r8,r12
8000f084:	e0 8a 00 6a 	brle	8000f158 <_vfprintf_r+0xb10>
8000f088:	20 20       	sub	r0,2
8000f08a:	c0 58       	rjmp	8000f094 <_vfprintf_r+0xa4c>
8000f08c:	e0 40 00 65 	cp.w	r0,101
8000f090:	e0 89 00 46 	brgt	8000f11c <_vfprintf_r+0xad4>
8000f094:	fa fb 06 ac 	ld.w	r11,sp[1708]
8000f098:	fb 60 06 9c 	st.b	sp[1692],r0
8000f09c:	20 1b       	sub	r11,1
8000f09e:	fb 4b 06 ac 	st.w	sp[1708],r11
8000f0a2:	c0 47       	brpl	8000f0aa <_vfprintf_r+0xa62>
8000f0a4:	5c 3b       	neg	r11
8000f0a6:	32 d8       	mov	r8,45
8000f0a8:	c0 28       	rjmp	8000f0ac <_vfprintf_r+0xa64>
8000f0aa:	32 b8       	mov	r8,43
8000f0ac:	fb 68 06 9d 	st.b	sp[1693],r8
8000f0b0:	58 9b       	cp.w	r11,9
8000f0b2:	e0 8a 00 1d 	brle	8000f0ec <_vfprintf_r+0xaa4>
8000f0b6:	fa c9 fa 35 	sub	r9,sp,-1483
8000f0ba:	30 aa       	mov	r10,10
8000f0bc:	12 98       	mov	r8,r9
8000f0be:	0e 9c       	mov	r12,r7
8000f0c0:	0c 92       	mov	r2,r6
8000f0c2:	f6 0a 0c 06 	divs	r6,r11,r10
8000f0c6:	0e 9b       	mov	r11,r7
8000f0c8:	2d 0b       	sub	r11,-48
8000f0ca:	10 fb       	st.b	--r8,r11
8000f0cc:	0c 9b       	mov	r11,r6
8000f0ce:	58 96       	cp.w	r6,9
8000f0d0:	fe 99 ff f9 	brgt	8000f0c2 <_vfprintf_r+0xa7a>
8000f0d4:	2d 0b       	sub	r11,-48
8000f0d6:	18 97       	mov	r7,r12
8000f0d8:	04 96       	mov	r6,r2
8000f0da:	10 fb       	st.b	--r8,r11
8000f0dc:	fa ca f9 62 	sub	r10,sp,-1694
8000f0e0:	c0 38       	rjmp	8000f0e6 <_vfprintf_r+0xa9e>
8000f0e2:	11 3b       	ld.ub	r11,r8++
8000f0e4:	14 cb       	st.b	r10++,r11
8000f0e6:	12 38       	cp.w	r8,r9
8000f0e8:	cf d3       	brcs	8000f0e2 <_vfprintf_r+0xa9a>
8000f0ea:	c0 98       	rjmp	8000f0fc <_vfprintf_r+0xab4>
8000f0ec:	2d 0b       	sub	r11,-48
8000f0ee:	33 08       	mov	r8,48
8000f0f0:	fb 6b 06 9f 	st.b	sp[1695],r11
8000f0f4:	fb 68 06 9e 	st.b	sp[1694],r8
8000f0f8:	fa ca f9 60 	sub	r10,sp,-1696
8000f0fc:	fa c8 f9 64 	sub	r8,sp,-1692
8000f100:	f4 08 01 08 	sub	r8,r10,r8
8000f104:	50 e8       	stdsp	sp[0x38],r8
8000f106:	10 92       	mov	r2,r8
8000f108:	40 6b       	lddsp	r11,sp[0x18]
8000f10a:	16 02       	add	r2,r11
8000f10c:	58 1b       	cp.w	r11,1
8000f10e:	e0 89 00 05 	brgt	8000f118 <_vfprintf_r+0xad0>
8000f112:	ed b5 00 00 	bld	r5,0x0
8000f116:	c3 51       	brne	8000f180 <_vfprintf_r+0xb38>
8000f118:	2f f2       	sub	r2,-1
8000f11a:	c3 38       	rjmp	8000f180 <_vfprintf_r+0xb38>
8000f11c:	e0 40 00 66 	cp.w	r0,102
8000f120:	c1 c1       	brne	8000f158 <_vfprintf_r+0xb10>
8000f122:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000f126:	58 02       	cp.w	r2,0
8000f128:	e0 8a 00 0c 	brle	8000f140 <_vfprintf_r+0xaf8>
8000f12c:	40 2a       	lddsp	r10,sp[0x8]
8000f12e:	58 0a       	cp.w	r10,0
8000f130:	c0 41       	brne	8000f138 <_vfprintf_r+0xaf0>
8000f132:	ed b5 00 00 	bld	r5,0x0
8000f136:	c2 51       	brne	8000f180 <_vfprintf_r+0xb38>
8000f138:	2f f2       	sub	r2,-1
8000f13a:	40 29       	lddsp	r9,sp[0x8]
8000f13c:	12 02       	add	r2,r9
8000f13e:	c0 b8       	rjmp	8000f154 <_vfprintf_r+0xb0c>
8000f140:	40 28       	lddsp	r8,sp[0x8]
8000f142:	58 08       	cp.w	r8,0
8000f144:	c0 61       	brne	8000f150 <_vfprintf_r+0xb08>
8000f146:	ed b5 00 00 	bld	r5,0x0
8000f14a:	c0 30       	breq	8000f150 <_vfprintf_r+0xb08>
8000f14c:	30 12       	mov	r2,1
8000f14e:	c1 98       	rjmp	8000f180 <_vfprintf_r+0xb38>
8000f150:	40 22       	lddsp	r2,sp[0x8]
8000f152:	2f e2       	sub	r2,-2
8000f154:	36 60       	mov	r0,102
8000f156:	c1 58       	rjmp	8000f180 <_vfprintf_r+0xb38>
8000f158:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000f15c:	40 6e       	lddsp	lr,sp[0x18]
8000f15e:	1c 32       	cp.w	r2,lr
8000f160:	c0 65       	brlt	8000f16c <_vfprintf_r+0xb24>
8000f162:	ed b5 00 00 	bld	r5,0x0
8000f166:	f7 b2 00 ff 	subeq	r2,-1
8000f16a:	c0 a8       	rjmp	8000f17e <_vfprintf_r+0xb36>
8000f16c:	e4 08 11 02 	rsub	r8,r2,2
8000f170:	40 6c       	lddsp	r12,sp[0x18]
8000f172:	58 02       	cp.w	r2,0
8000f174:	f0 02 17 a0 	movle	r2,r8
8000f178:	f9 b2 09 01 	movgt	r2,1
8000f17c:	18 02       	add	r2,r12
8000f17e:	36 70       	mov	r0,103
8000f180:	40 9b       	lddsp	r11,sp[0x24]
8000f182:	58 0b       	cp.w	r11,0
8000f184:	e0 80 05 94 	breq	8000fcac <_vfprintf_r+0x1664>
8000f188:	32 d8       	mov	r8,45
8000f18a:	fb 68 06 bb 	st.b	sp[1723],r8
8000f18e:	e0 8f 05 93 	bral	8000fcb4 <_vfprintf_r+0x166c>
8000f192:	50 a7       	stdsp	sp[0x28],r7
8000f194:	04 94       	mov	r4,r2
8000f196:	0c 97       	mov	r7,r6
8000f198:	02 92       	mov	r2,r1
8000f19a:	06 96       	mov	r6,r3
8000f19c:	40 41       	lddsp	r1,sp[0x10]
8000f19e:	40 93       	lddsp	r3,sp[0x24]
8000f1a0:	0e 99       	mov	r9,r7
8000f1a2:	ed b5 00 05 	bld	r5,0x5
8000f1a6:	c4 81       	brne	8000f236 <_vfprintf_r+0xbee>
8000f1a8:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000f1ac:	40 3e       	lddsp	lr,sp[0xc]
8000f1ae:	58 0e       	cp.w	lr,0
8000f1b0:	c1 d0       	breq	8000f1ea <_vfprintf_r+0xba2>
8000f1b2:	10 36       	cp.w	r6,r8
8000f1b4:	c0 64       	brge	8000f1c0 <_vfprintf_r+0xb78>
8000f1b6:	fa cc f9 44 	sub	r12,sp,-1724
8000f1ba:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000f1be:	c1 d8       	rjmp	8000f1f8 <_vfprintf_r+0xbb0>
8000f1c0:	fa c8 f9 50 	sub	r8,sp,-1712
8000f1c4:	1a d8       	st.w	--sp,r8
8000f1c6:	fa c8 fa b8 	sub	r8,sp,-1352
8000f1ca:	04 9a       	mov	r10,r2
8000f1cc:	1a d8       	st.w	--sp,r8
8000f1ce:	fa c8 fb b4 	sub	r8,sp,-1100
8000f1d2:	0c 9b       	mov	r11,r6
8000f1d4:	1a d8       	st.w	--sp,r8
8000f1d6:	08 9c       	mov	r12,r4
8000f1d8:	fa c8 f9 40 	sub	r8,sp,-1728
8000f1dc:	fa c9 ff b4 	sub	r9,sp,-76
8000f1e0:	fe b0 f8 96 	rcall	8000e30c <get_arg>
8000f1e4:	2f dd       	sub	sp,-12
8000f1e6:	78 0a       	ld.w	r10,r12[0x0]
8000f1e8:	c2 08       	rjmp	8000f228 <_vfprintf_r+0xbe0>
8000f1ea:	2f f7       	sub	r7,-1
8000f1ec:	10 39       	cp.w	r9,r8
8000f1ee:	c0 84       	brge	8000f1fe <_vfprintf_r+0xbb6>
8000f1f0:	fa cb f9 44 	sub	r11,sp,-1724
8000f1f4:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000f1f8:	ec fa fd 88 	ld.w	r10,r6[-632]
8000f1fc:	c1 68       	rjmp	8000f228 <_vfprintf_r+0xbe0>
8000f1fe:	41 09       	lddsp	r9,sp[0x40]
8000f200:	59 f8       	cp.w	r8,31
8000f202:	e0 89 00 10 	brgt	8000f222 <_vfprintf_r+0xbda>
8000f206:	f2 ca ff fc 	sub	r10,r9,-4
8000f20a:	51 0a       	stdsp	sp[0x40],r10
8000f20c:	fa c6 f9 44 	sub	r6,sp,-1724
8000f210:	72 0a       	ld.w	r10,r9[0x0]
8000f212:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000f216:	f3 4a fd 88 	st.w	r9[-632],r10
8000f21a:	2f f8       	sub	r8,-1
8000f21c:	fb 48 06 b4 	st.w	sp[1716],r8
8000f220:	c0 48       	rjmp	8000f228 <_vfprintf_r+0xbe0>
8000f222:	72 0a       	ld.w	r10,r9[0x0]
8000f224:	2f c9       	sub	r9,-4
8000f226:	51 09       	stdsp	sp[0x40],r9
8000f228:	40 be       	lddsp	lr,sp[0x2c]
8000f22a:	1c 98       	mov	r8,lr
8000f22c:	95 1e       	st.w	r10[0x4],lr
8000f22e:	bf 58       	asr	r8,0x1f
8000f230:	95 08       	st.w	r10[0x0],r8
8000f232:	fe 9f fa 96 	bral	8000e75e <_vfprintf_r+0x116>
8000f236:	ed b5 00 04 	bld	r5,0x4
8000f23a:	c4 80       	breq	8000f2ca <_vfprintf_r+0xc82>
8000f23c:	e2 15 00 40 	andl	r5,0x40,COH
8000f240:	c4 50       	breq	8000f2ca <_vfprintf_r+0xc82>
8000f242:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000f246:	40 3c       	lddsp	r12,sp[0xc]
8000f248:	58 0c       	cp.w	r12,0
8000f24a:	c1 d0       	breq	8000f284 <_vfprintf_r+0xc3c>
8000f24c:	10 36       	cp.w	r6,r8
8000f24e:	c0 64       	brge	8000f25a <_vfprintf_r+0xc12>
8000f250:	fa cb f9 44 	sub	r11,sp,-1724
8000f254:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000f258:	c1 d8       	rjmp	8000f292 <_vfprintf_r+0xc4a>
8000f25a:	fa c8 f9 50 	sub	r8,sp,-1712
8000f25e:	1a d8       	st.w	--sp,r8
8000f260:	fa c8 fa b8 	sub	r8,sp,-1352
8000f264:	04 9a       	mov	r10,r2
8000f266:	1a d8       	st.w	--sp,r8
8000f268:	fa c8 fb b4 	sub	r8,sp,-1100
8000f26c:	0c 9b       	mov	r11,r6
8000f26e:	1a d8       	st.w	--sp,r8
8000f270:	08 9c       	mov	r12,r4
8000f272:	fa c8 f9 40 	sub	r8,sp,-1728
8000f276:	fa c9 ff b4 	sub	r9,sp,-76
8000f27a:	fe b0 f8 49 	rcall	8000e30c <get_arg>
8000f27e:	2f dd       	sub	sp,-12
8000f280:	78 0a       	ld.w	r10,r12[0x0]
8000f282:	c2 08       	rjmp	8000f2c2 <_vfprintf_r+0xc7a>
8000f284:	2f f7       	sub	r7,-1
8000f286:	10 39       	cp.w	r9,r8
8000f288:	c0 84       	brge	8000f298 <_vfprintf_r+0xc50>
8000f28a:	fa ca f9 44 	sub	r10,sp,-1724
8000f28e:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000f292:	ec fa fd 88 	ld.w	r10,r6[-632]
8000f296:	c1 68       	rjmp	8000f2c2 <_vfprintf_r+0xc7a>
8000f298:	41 09       	lddsp	r9,sp[0x40]
8000f29a:	59 f8       	cp.w	r8,31
8000f29c:	e0 89 00 10 	brgt	8000f2bc <_vfprintf_r+0xc74>
8000f2a0:	f2 ca ff fc 	sub	r10,r9,-4
8000f2a4:	51 0a       	stdsp	sp[0x40],r10
8000f2a6:	fa c6 f9 44 	sub	r6,sp,-1724
8000f2aa:	72 0a       	ld.w	r10,r9[0x0]
8000f2ac:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000f2b0:	f3 4a fd 88 	st.w	r9[-632],r10
8000f2b4:	2f f8       	sub	r8,-1
8000f2b6:	fb 48 06 b4 	st.w	sp[1716],r8
8000f2ba:	c0 48       	rjmp	8000f2c2 <_vfprintf_r+0xc7a>
8000f2bc:	72 0a       	ld.w	r10,r9[0x0]
8000f2be:	2f c9       	sub	r9,-4
8000f2c0:	51 09       	stdsp	sp[0x40],r9
8000f2c2:	40 be       	lddsp	lr,sp[0x2c]
8000f2c4:	b4 0e       	st.h	r10[0x0],lr
8000f2c6:	fe 9f fa 4c 	bral	8000e75e <_vfprintf_r+0x116>
8000f2ca:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000f2ce:	40 3c       	lddsp	r12,sp[0xc]
8000f2d0:	58 0c       	cp.w	r12,0
8000f2d2:	c1 d0       	breq	8000f30c <_vfprintf_r+0xcc4>
8000f2d4:	10 36       	cp.w	r6,r8
8000f2d6:	c0 64       	brge	8000f2e2 <_vfprintf_r+0xc9a>
8000f2d8:	fa cb f9 44 	sub	r11,sp,-1724
8000f2dc:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000f2e0:	c1 d8       	rjmp	8000f31a <_vfprintf_r+0xcd2>
8000f2e2:	fa c8 f9 50 	sub	r8,sp,-1712
8000f2e6:	1a d8       	st.w	--sp,r8
8000f2e8:	fa c8 fa b8 	sub	r8,sp,-1352
8000f2ec:	04 9a       	mov	r10,r2
8000f2ee:	1a d8       	st.w	--sp,r8
8000f2f0:	fa c8 fb b4 	sub	r8,sp,-1100
8000f2f4:	0c 9b       	mov	r11,r6
8000f2f6:	1a d8       	st.w	--sp,r8
8000f2f8:	08 9c       	mov	r12,r4
8000f2fa:	fa c8 f9 40 	sub	r8,sp,-1728
8000f2fe:	fa c9 ff b4 	sub	r9,sp,-76
8000f302:	fe b0 f8 05 	rcall	8000e30c <get_arg>
8000f306:	2f dd       	sub	sp,-12
8000f308:	78 0a       	ld.w	r10,r12[0x0]
8000f30a:	c2 08       	rjmp	8000f34a <_vfprintf_r+0xd02>
8000f30c:	2f f7       	sub	r7,-1
8000f30e:	10 39       	cp.w	r9,r8
8000f310:	c0 84       	brge	8000f320 <_vfprintf_r+0xcd8>
8000f312:	fa ca f9 44 	sub	r10,sp,-1724
8000f316:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000f31a:	ec fa fd 88 	ld.w	r10,r6[-632]
8000f31e:	c1 68       	rjmp	8000f34a <_vfprintf_r+0xd02>
8000f320:	41 09       	lddsp	r9,sp[0x40]
8000f322:	59 f8       	cp.w	r8,31
8000f324:	e0 89 00 10 	brgt	8000f344 <_vfprintf_r+0xcfc>
8000f328:	f2 ca ff fc 	sub	r10,r9,-4
8000f32c:	51 0a       	stdsp	sp[0x40],r10
8000f32e:	fa c6 f9 44 	sub	r6,sp,-1724
8000f332:	72 0a       	ld.w	r10,r9[0x0]
8000f334:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000f338:	f3 4a fd 88 	st.w	r9[-632],r10
8000f33c:	2f f8       	sub	r8,-1
8000f33e:	fb 48 06 b4 	st.w	sp[1716],r8
8000f342:	c0 48       	rjmp	8000f34a <_vfprintf_r+0xd02>
8000f344:	72 0a       	ld.w	r10,r9[0x0]
8000f346:	2f c9       	sub	r9,-4
8000f348:	51 09       	stdsp	sp[0x40],r9
8000f34a:	40 be       	lddsp	lr,sp[0x2c]
8000f34c:	95 0e       	st.w	r10[0x0],lr
8000f34e:	fe 9f fa 08 	bral	8000e75e <_vfprintf_r+0x116>
8000f352:	50 a7       	stdsp	sp[0x28],r7
8000f354:	50 80       	stdsp	sp[0x20],r0
8000f356:	0c 97       	mov	r7,r6
8000f358:	04 94       	mov	r4,r2
8000f35a:	06 96       	mov	r6,r3
8000f35c:	02 92       	mov	r2,r1
8000f35e:	40 93       	lddsp	r3,sp[0x24]
8000f360:	10 90       	mov	r0,r8
8000f362:	40 41       	lddsp	r1,sp[0x10]
8000f364:	a5 a5       	sbr	r5,0x4
8000f366:	c0 a8       	rjmp	8000f37a <_vfprintf_r+0xd32>
8000f368:	50 a7       	stdsp	sp[0x28],r7
8000f36a:	50 80       	stdsp	sp[0x20],r0
8000f36c:	0c 97       	mov	r7,r6
8000f36e:	04 94       	mov	r4,r2
8000f370:	06 96       	mov	r6,r3
8000f372:	02 92       	mov	r2,r1
8000f374:	40 93       	lddsp	r3,sp[0x24]
8000f376:	10 90       	mov	r0,r8
8000f378:	40 41       	lddsp	r1,sp[0x10]
8000f37a:	ed b5 00 05 	bld	r5,0x5
8000f37e:	c5 d1       	brne	8000f438 <_vfprintf_r+0xdf0>
8000f380:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000f384:	40 3c       	lddsp	r12,sp[0xc]
8000f386:	58 0c       	cp.w	r12,0
8000f388:	c2 60       	breq	8000f3d4 <_vfprintf_r+0xd8c>
8000f38a:	10 36       	cp.w	r6,r8
8000f38c:	c0 a4       	brge	8000f3a0 <_vfprintf_r+0xd58>
8000f38e:	fa cb f9 44 	sub	r11,sp,-1724
8000f392:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000f396:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000f39a:	fa e9 00 00 	st.d	sp[0],r8
8000f39e:	c1 88       	rjmp	8000f3ce <_vfprintf_r+0xd86>
8000f3a0:	fa c8 f9 50 	sub	r8,sp,-1712
8000f3a4:	1a d8       	st.w	--sp,r8
8000f3a6:	fa c8 fa b8 	sub	r8,sp,-1352
8000f3aa:	04 9a       	mov	r10,r2
8000f3ac:	1a d8       	st.w	--sp,r8
8000f3ae:	0c 9b       	mov	r11,r6
8000f3b0:	fa c8 fb b4 	sub	r8,sp,-1100
8000f3b4:	08 9c       	mov	r12,r4
8000f3b6:	1a d8       	st.w	--sp,r8
8000f3b8:	fa c8 f9 40 	sub	r8,sp,-1728
8000f3bc:	fa c9 ff b4 	sub	r9,sp,-76
8000f3c0:	fe b0 f7 a6 	rcall	8000e30c <get_arg>
8000f3c4:	2f dd       	sub	sp,-12
8000f3c6:	f8 ea 00 00 	ld.d	r10,r12[0]
8000f3ca:	fa eb 00 00 	st.d	sp[0],r10
8000f3ce:	30 08       	mov	r8,0
8000f3d0:	e0 8f 03 de 	bral	8000fb8c <_vfprintf_r+0x1544>
8000f3d4:	ee ca ff ff 	sub	r10,r7,-1
8000f3d8:	10 37       	cp.w	r7,r8
8000f3da:	c0 b4       	brge	8000f3f0 <_vfprintf_r+0xda8>
8000f3dc:	fa c9 f9 44 	sub	r9,sp,-1724
8000f3e0:	14 97       	mov	r7,r10
8000f3e2:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000f3e6:	ec ea fd 88 	ld.d	r10,r6[-632]
8000f3ea:	fa eb 00 00 	st.d	sp[0],r10
8000f3ee:	c1 88       	rjmp	8000f41e <_vfprintf_r+0xdd6>
8000f3f0:	41 09       	lddsp	r9,sp[0x40]
8000f3f2:	59 f8       	cp.w	r8,31
8000f3f4:	e0 89 00 18 	brgt	8000f424 <_vfprintf_r+0xddc>
8000f3f8:	f2 e6 00 00 	ld.d	r6,r9[0]
8000f3fc:	f2 cb ff f8 	sub	r11,r9,-8
8000f400:	fa e7 00 00 	st.d	sp[0],r6
8000f404:	51 0b       	stdsp	sp[0x40],r11
8000f406:	fa c6 f9 44 	sub	r6,sp,-1724
8000f40a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000f40e:	fa e6 00 00 	ld.d	r6,sp[0]
8000f412:	f2 e7 fd 88 	st.d	r9[-632],r6
8000f416:	2f f8       	sub	r8,-1
8000f418:	14 97       	mov	r7,r10
8000f41a:	fb 48 06 b4 	st.w	sp[1716],r8
8000f41e:	40 38       	lddsp	r8,sp[0xc]
8000f420:	e0 8f 03 b6 	bral	8000fb8c <_vfprintf_r+0x1544>
8000f424:	f2 e6 00 00 	ld.d	r6,r9[0]
8000f428:	40 38       	lddsp	r8,sp[0xc]
8000f42a:	fa e7 00 00 	st.d	sp[0],r6
8000f42e:	2f 89       	sub	r9,-8
8000f430:	14 97       	mov	r7,r10
8000f432:	51 09       	stdsp	sp[0x40],r9
8000f434:	e0 8f 03 ac 	bral	8000fb8c <_vfprintf_r+0x1544>
8000f438:	ed b5 00 04 	bld	r5,0x4
8000f43c:	c1 61       	brne	8000f468 <_vfprintf_r+0xe20>
8000f43e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000f442:	40 3e       	lddsp	lr,sp[0xc]
8000f444:	58 0e       	cp.w	lr,0
8000f446:	c0 80       	breq	8000f456 <_vfprintf_r+0xe0e>
8000f448:	10 36       	cp.w	r6,r8
8000f44a:	c6 74       	brge	8000f518 <_vfprintf_r+0xed0>
8000f44c:	fa cc f9 44 	sub	r12,sp,-1724
8000f450:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000f454:	c8 08       	rjmp	8000f554 <_vfprintf_r+0xf0c>
8000f456:	ee ca ff ff 	sub	r10,r7,-1
8000f45a:	10 37       	cp.w	r7,r8
8000f45c:	c7 f4       	brge	8000f55a <_vfprintf_r+0xf12>
8000f45e:	fa cb f9 44 	sub	r11,sp,-1724
8000f462:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000f466:	c7 68       	rjmp	8000f552 <_vfprintf_r+0xf0a>
8000f468:	ed b5 00 06 	bld	r5,0x6
8000f46c:	c4 a1       	brne	8000f500 <_vfprintf_r+0xeb8>
8000f46e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000f472:	40 3c       	lddsp	r12,sp[0xc]
8000f474:	58 0c       	cp.w	r12,0
8000f476:	c1 d0       	breq	8000f4b0 <_vfprintf_r+0xe68>
8000f478:	10 36       	cp.w	r6,r8
8000f47a:	c0 64       	brge	8000f486 <_vfprintf_r+0xe3e>
8000f47c:	fa cb f9 44 	sub	r11,sp,-1724
8000f480:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000f484:	c1 f8       	rjmp	8000f4c2 <_vfprintf_r+0xe7a>
8000f486:	fa c8 f9 50 	sub	r8,sp,-1712
8000f48a:	1a d8       	st.w	--sp,r8
8000f48c:	fa c8 fa b8 	sub	r8,sp,-1352
8000f490:	1a d8       	st.w	--sp,r8
8000f492:	fa c8 fb b4 	sub	r8,sp,-1100
8000f496:	1a d8       	st.w	--sp,r8
8000f498:	fa c8 f9 40 	sub	r8,sp,-1728
8000f49c:	fa c9 ff b4 	sub	r9,sp,-76
8000f4a0:	04 9a       	mov	r10,r2
8000f4a2:	0c 9b       	mov	r11,r6
8000f4a4:	08 9c       	mov	r12,r4
8000f4a6:	fe b0 f7 33 	rcall	8000e30c <get_arg>
8000f4aa:	2f dd       	sub	sp,-12
8000f4ac:	98 18       	ld.sh	r8,r12[0x2]
8000f4ae:	c2 68       	rjmp	8000f4fa <_vfprintf_r+0xeb2>
8000f4b0:	ee ca ff ff 	sub	r10,r7,-1
8000f4b4:	10 37       	cp.w	r7,r8
8000f4b6:	c0 94       	brge	8000f4c8 <_vfprintf_r+0xe80>
8000f4b8:	fa c9 f9 44 	sub	r9,sp,-1724
8000f4bc:	14 97       	mov	r7,r10
8000f4be:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000f4c2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000f4c6:	c1 a8       	rjmp	8000f4fa <_vfprintf_r+0xeb2>
8000f4c8:	41 09       	lddsp	r9,sp[0x40]
8000f4ca:	59 f8       	cp.w	r8,31
8000f4cc:	e0 89 00 13 	brgt	8000f4f2 <_vfprintf_r+0xeaa>
8000f4d0:	f2 cb ff fc 	sub	r11,r9,-4
8000f4d4:	51 0b       	stdsp	sp[0x40],r11
8000f4d6:	72 09       	ld.w	r9,r9[0x0]
8000f4d8:	fa c6 f9 44 	sub	r6,sp,-1724
8000f4dc:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000f4e0:	2f f8       	sub	r8,-1
8000f4e2:	f7 49 fd 88 	st.w	r11[-632],r9
8000f4e6:	fb 48 06 b4 	st.w	sp[1716],r8
8000f4ea:	14 97       	mov	r7,r10
8000f4ec:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000f4f0:	c0 58       	rjmp	8000f4fa <_vfprintf_r+0xeb2>
8000f4f2:	92 18       	ld.sh	r8,r9[0x2]
8000f4f4:	14 97       	mov	r7,r10
8000f4f6:	2f c9       	sub	r9,-4
8000f4f8:	51 09       	stdsp	sp[0x40],r9
8000f4fa:	5c 78       	castu.h	r8
8000f4fc:	50 18       	stdsp	sp[0x4],r8
8000f4fe:	c4 68       	rjmp	8000f58a <_vfprintf_r+0xf42>
8000f500:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000f504:	40 3c       	lddsp	r12,sp[0xc]
8000f506:	58 0c       	cp.w	r12,0
8000f508:	c1 d0       	breq	8000f542 <_vfprintf_r+0xefa>
8000f50a:	10 36       	cp.w	r6,r8
8000f50c:	c0 64       	brge	8000f518 <_vfprintf_r+0xed0>
8000f50e:	fa cb f9 44 	sub	r11,sp,-1724
8000f512:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000f516:	c1 f8       	rjmp	8000f554 <_vfprintf_r+0xf0c>
8000f518:	fa c8 f9 50 	sub	r8,sp,-1712
8000f51c:	1a d8       	st.w	--sp,r8
8000f51e:	fa c8 fa b8 	sub	r8,sp,-1352
8000f522:	0c 9b       	mov	r11,r6
8000f524:	1a d8       	st.w	--sp,r8
8000f526:	fa c8 fb b4 	sub	r8,sp,-1100
8000f52a:	04 9a       	mov	r10,r2
8000f52c:	1a d8       	st.w	--sp,r8
8000f52e:	08 9c       	mov	r12,r4
8000f530:	fa c8 f9 40 	sub	r8,sp,-1728
8000f534:	fa c9 ff b4 	sub	r9,sp,-76
8000f538:	fe b0 f6 ea 	rcall	8000e30c <get_arg>
8000f53c:	2f dd       	sub	sp,-12
8000f53e:	78 0b       	ld.w	r11,r12[0x0]
8000f540:	c2 48       	rjmp	8000f588 <_vfprintf_r+0xf40>
8000f542:	ee ca ff ff 	sub	r10,r7,-1
8000f546:	10 37       	cp.w	r7,r8
8000f548:	c0 94       	brge	8000f55a <_vfprintf_r+0xf12>
8000f54a:	fa c9 f9 44 	sub	r9,sp,-1724
8000f54e:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000f552:	14 97       	mov	r7,r10
8000f554:	ec fb fd 88 	ld.w	r11,r6[-632]
8000f558:	c1 88       	rjmp	8000f588 <_vfprintf_r+0xf40>
8000f55a:	41 09       	lddsp	r9,sp[0x40]
8000f55c:	59 f8       	cp.w	r8,31
8000f55e:	e0 89 00 11 	brgt	8000f580 <_vfprintf_r+0xf38>
8000f562:	f2 cb ff fc 	sub	r11,r9,-4
8000f566:	51 0b       	stdsp	sp[0x40],r11
8000f568:	fa c6 f9 44 	sub	r6,sp,-1724
8000f56c:	72 0b       	ld.w	r11,r9[0x0]
8000f56e:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000f572:	f3 4b fd 88 	st.w	r9[-632],r11
8000f576:	2f f8       	sub	r8,-1
8000f578:	14 97       	mov	r7,r10
8000f57a:	fb 48 06 b4 	st.w	sp[1716],r8
8000f57e:	c0 58       	rjmp	8000f588 <_vfprintf_r+0xf40>
8000f580:	72 0b       	ld.w	r11,r9[0x0]
8000f582:	14 97       	mov	r7,r10
8000f584:	2f c9       	sub	r9,-4
8000f586:	51 09       	stdsp	sp[0x40],r9
8000f588:	50 1b       	stdsp	sp[0x4],r11
8000f58a:	30 0e       	mov	lr,0
8000f58c:	50 0e       	stdsp	sp[0x0],lr
8000f58e:	1c 98       	mov	r8,lr
8000f590:	e0 8f 02 fe 	bral	8000fb8c <_vfprintf_r+0x1544>
8000f594:	50 a7       	stdsp	sp[0x28],r7
8000f596:	50 80       	stdsp	sp[0x20],r0
8000f598:	0c 97       	mov	r7,r6
8000f59a:	04 94       	mov	r4,r2
8000f59c:	06 96       	mov	r6,r3
8000f59e:	02 92       	mov	r2,r1
8000f5a0:	40 93       	lddsp	r3,sp[0x24]
8000f5a2:	40 41       	lddsp	r1,sp[0x10]
8000f5a4:	0e 99       	mov	r9,r7
8000f5a6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000f5aa:	40 3c       	lddsp	r12,sp[0xc]
8000f5ac:	58 0c       	cp.w	r12,0
8000f5ae:	c1 d0       	breq	8000f5e8 <_vfprintf_r+0xfa0>
8000f5b0:	10 36       	cp.w	r6,r8
8000f5b2:	c0 64       	brge	8000f5be <_vfprintf_r+0xf76>
8000f5b4:	fa cb f9 44 	sub	r11,sp,-1724
8000f5b8:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000f5bc:	c1 d8       	rjmp	8000f5f6 <_vfprintf_r+0xfae>
8000f5be:	fa c8 f9 50 	sub	r8,sp,-1712
8000f5c2:	1a d8       	st.w	--sp,r8
8000f5c4:	fa c8 fa b8 	sub	r8,sp,-1352
8000f5c8:	1a d8       	st.w	--sp,r8
8000f5ca:	fa c8 fb b4 	sub	r8,sp,-1100
8000f5ce:	1a d8       	st.w	--sp,r8
8000f5d0:	fa c9 ff b4 	sub	r9,sp,-76
8000f5d4:	fa c8 f9 40 	sub	r8,sp,-1728
8000f5d8:	04 9a       	mov	r10,r2
8000f5da:	0c 9b       	mov	r11,r6
8000f5dc:	08 9c       	mov	r12,r4
8000f5de:	fe b0 f6 97 	rcall	8000e30c <get_arg>
8000f5e2:	2f dd       	sub	sp,-12
8000f5e4:	78 09       	ld.w	r9,r12[0x0]
8000f5e6:	c2 18       	rjmp	8000f628 <_vfprintf_r+0xfe0>
8000f5e8:	2f f7       	sub	r7,-1
8000f5ea:	10 39       	cp.w	r9,r8
8000f5ec:	c0 84       	brge	8000f5fc <_vfprintf_r+0xfb4>
8000f5ee:	fa ca f9 44 	sub	r10,sp,-1724
8000f5f2:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000f5f6:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000f5fa:	c1 78       	rjmp	8000f628 <_vfprintf_r+0xfe0>
8000f5fc:	41 09       	lddsp	r9,sp[0x40]
8000f5fe:	59 f8       	cp.w	r8,31
8000f600:	e0 89 00 10 	brgt	8000f620 <_vfprintf_r+0xfd8>
8000f604:	f2 ca ff fc 	sub	r10,r9,-4
8000f608:	51 0a       	stdsp	sp[0x40],r10
8000f60a:	fa c6 f9 44 	sub	r6,sp,-1724
8000f60e:	72 09       	ld.w	r9,r9[0x0]
8000f610:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000f614:	f5 49 fd 88 	st.w	r10[-632],r9
8000f618:	2f f8       	sub	r8,-1
8000f61a:	fb 48 06 b4 	st.w	sp[1716],r8
8000f61e:	c0 58       	rjmp	8000f628 <_vfprintf_r+0xfe0>
8000f620:	f2 c8 ff fc 	sub	r8,r9,-4
8000f624:	51 08       	stdsp	sp[0x40],r8
8000f626:	72 09       	ld.w	r9,r9[0x0]
8000f628:	33 08       	mov	r8,48
8000f62a:	fb 68 06 b8 	st.b	sp[1720],r8
8000f62e:	37 88       	mov	r8,120
8000f630:	30 0e       	mov	lr,0
8000f632:	fb 68 06 b9 	st.b	sp[1721],r8
8000f636:	fe cc 8d 6e 	sub	r12,pc,-29330
8000f63a:	50 19       	stdsp	sp[0x4],r9
8000f63c:	a1 b5       	sbr	r5,0x1
8000f63e:	50 0e       	stdsp	sp[0x0],lr
8000f640:	50 dc       	stdsp	sp[0x34],r12
8000f642:	30 28       	mov	r8,2
8000f644:	37 80       	mov	r0,120
8000f646:	e0 8f 02 a3 	bral	8000fb8c <_vfprintf_r+0x1544>
8000f64a:	50 a7       	stdsp	sp[0x28],r7
8000f64c:	50 80       	stdsp	sp[0x20],r0
8000f64e:	10 90       	mov	r0,r8
8000f650:	30 08       	mov	r8,0
8000f652:	fb 68 06 bb 	st.b	sp[1723],r8
8000f656:	0c 97       	mov	r7,r6
8000f658:	04 94       	mov	r4,r2
8000f65a:	06 96       	mov	r6,r3
8000f65c:	02 92       	mov	r2,r1
8000f65e:	40 93       	lddsp	r3,sp[0x24]
8000f660:	40 41       	lddsp	r1,sp[0x10]
8000f662:	0e 99       	mov	r9,r7
8000f664:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000f668:	40 3b       	lddsp	r11,sp[0xc]
8000f66a:	58 0b       	cp.w	r11,0
8000f66c:	c1 d0       	breq	8000f6a6 <_vfprintf_r+0x105e>
8000f66e:	10 36       	cp.w	r6,r8
8000f670:	c0 64       	brge	8000f67c <_vfprintf_r+0x1034>
8000f672:	fa ca f9 44 	sub	r10,sp,-1724
8000f676:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000f67a:	c1 d8       	rjmp	8000f6b4 <_vfprintf_r+0x106c>
8000f67c:	fa c8 f9 50 	sub	r8,sp,-1712
8000f680:	1a d8       	st.w	--sp,r8
8000f682:	fa c8 fa b8 	sub	r8,sp,-1352
8000f686:	1a d8       	st.w	--sp,r8
8000f688:	fa c8 fb b4 	sub	r8,sp,-1100
8000f68c:	0c 9b       	mov	r11,r6
8000f68e:	1a d8       	st.w	--sp,r8
8000f690:	04 9a       	mov	r10,r2
8000f692:	fa c8 f9 40 	sub	r8,sp,-1728
8000f696:	fa c9 ff b4 	sub	r9,sp,-76
8000f69a:	08 9c       	mov	r12,r4
8000f69c:	fe b0 f6 38 	rcall	8000e30c <get_arg>
8000f6a0:	2f dd       	sub	sp,-12
8000f6a2:	78 06       	ld.w	r6,r12[0x0]
8000f6a4:	c2 08       	rjmp	8000f6e4 <_vfprintf_r+0x109c>
8000f6a6:	2f f7       	sub	r7,-1
8000f6a8:	10 39       	cp.w	r9,r8
8000f6aa:	c0 84       	brge	8000f6ba <_vfprintf_r+0x1072>
8000f6ac:	fa c9 f9 44 	sub	r9,sp,-1724
8000f6b0:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000f6b4:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000f6b8:	c1 68       	rjmp	8000f6e4 <_vfprintf_r+0x109c>
8000f6ba:	41 09       	lddsp	r9,sp[0x40]
8000f6bc:	59 f8       	cp.w	r8,31
8000f6be:	e0 89 00 10 	brgt	8000f6de <_vfprintf_r+0x1096>
8000f6c2:	f2 ca ff fc 	sub	r10,r9,-4
8000f6c6:	51 0a       	stdsp	sp[0x40],r10
8000f6c8:	72 06       	ld.w	r6,r9[0x0]
8000f6ca:	fa ce f9 44 	sub	lr,sp,-1724
8000f6ce:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000f6d2:	f3 46 fd 88 	st.w	r9[-632],r6
8000f6d6:	2f f8       	sub	r8,-1
8000f6d8:	fb 48 06 b4 	st.w	sp[1716],r8
8000f6dc:	c0 48       	rjmp	8000f6e4 <_vfprintf_r+0x109c>
8000f6de:	72 06       	ld.w	r6,r9[0x0]
8000f6e0:	2f c9       	sub	r9,-4
8000f6e2:	51 09       	stdsp	sp[0x40],r9
8000f6e4:	40 2c       	lddsp	r12,sp[0x8]
8000f6e6:	58 0c       	cp.w	r12,0
8000f6e8:	c1 05       	brlt	8000f708 <_vfprintf_r+0x10c0>
8000f6ea:	18 9a       	mov	r10,r12
8000f6ec:	30 0b       	mov	r11,0
8000f6ee:	0c 9c       	mov	r12,r6
8000f6f0:	e0 a0 12 40 	rcall	80011b70 <memchr>
8000f6f4:	e0 80 02 df 	breq	8000fcb2 <_vfprintf_r+0x166a>
8000f6f8:	f8 06 01 02 	sub	r2,r12,r6
8000f6fc:	40 2b       	lddsp	r11,sp[0x8]
8000f6fe:	16 32       	cp.w	r2,r11
8000f700:	e0 89 02 d9 	brgt	8000fcb2 <_vfprintf_r+0x166a>
8000f704:	e0 8f 02 d4 	bral	8000fcac <_vfprintf_r+0x1664>
8000f708:	30 0a       	mov	r10,0
8000f70a:	0c 9c       	mov	r12,r6
8000f70c:	50 2a       	stdsp	sp[0x8],r10
8000f70e:	e0 a0 17 45 	rcall	80012598 <strlen>
8000f712:	18 92       	mov	r2,r12
8000f714:	e0 8f 02 d2 	bral	8000fcb8 <_vfprintf_r+0x1670>
8000f718:	50 a7       	stdsp	sp[0x28],r7
8000f71a:	50 80       	stdsp	sp[0x20],r0
8000f71c:	0c 97       	mov	r7,r6
8000f71e:	04 94       	mov	r4,r2
8000f720:	06 96       	mov	r6,r3
8000f722:	02 92       	mov	r2,r1
8000f724:	40 93       	lddsp	r3,sp[0x24]
8000f726:	10 90       	mov	r0,r8
8000f728:	40 41       	lddsp	r1,sp[0x10]
8000f72a:	a5 a5       	sbr	r5,0x4
8000f72c:	c0 a8       	rjmp	8000f740 <_vfprintf_r+0x10f8>
8000f72e:	50 a7       	stdsp	sp[0x28],r7
8000f730:	50 80       	stdsp	sp[0x20],r0
8000f732:	0c 97       	mov	r7,r6
8000f734:	04 94       	mov	r4,r2
8000f736:	06 96       	mov	r6,r3
8000f738:	02 92       	mov	r2,r1
8000f73a:	40 93       	lddsp	r3,sp[0x24]
8000f73c:	10 90       	mov	r0,r8
8000f73e:	40 41       	lddsp	r1,sp[0x10]
8000f740:	ed b5 00 05 	bld	r5,0x5
8000f744:	c5 61       	brne	8000f7f0 <_vfprintf_r+0x11a8>
8000f746:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000f74a:	40 39       	lddsp	r9,sp[0xc]
8000f74c:	58 09       	cp.w	r9,0
8000f74e:	c2 10       	breq	8000f790 <_vfprintf_r+0x1148>
8000f750:	10 36       	cp.w	r6,r8
8000f752:	c0 74       	brge	8000f760 <_vfprintf_r+0x1118>
8000f754:	fa c8 f9 44 	sub	r8,sp,-1724
8000f758:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000f75c:	c2 38       	rjmp	8000f7a2 <_vfprintf_r+0x115a>
8000f75e:	d7 03       	nop
8000f760:	fa c8 f9 50 	sub	r8,sp,-1712
8000f764:	1a d8       	st.w	--sp,r8
8000f766:	fa c8 fa b8 	sub	r8,sp,-1352
8000f76a:	1a d8       	st.w	--sp,r8
8000f76c:	fa c8 fb b4 	sub	r8,sp,-1100
8000f770:	1a d8       	st.w	--sp,r8
8000f772:	fa c8 f9 40 	sub	r8,sp,-1728
8000f776:	fa c9 ff b4 	sub	r9,sp,-76
8000f77a:	04 9a       	mov	r10,r2
8000f77c:	0c 9b       	mov	r11,r6
8000f77e:	08 9c       	mov	r12,r4
8000f780:	fe b0 f5 c6 	rcall	8000e30c <get_arg>
8000f784:	2f dd       	sub	sp,-12
8000f786:	f8 e8 00 00 	ld.d	r8,r12[0]
8000f78a:	fa e9 00 00 	st.d	sp[0],r8
8000f78e:	c2 e8       	rjmp	8000f7ea <_vfprintf_r+0x11a2>
8000f790:	ee ca ff ff 	sub	r10,r7,-1
8000f794:	10 37       	cp.w	r7,r8
8000f796:	c0 b4       	brge	8000f7ac <_vfprintf_r+0x1164>
8000f798:	fa c8 f9 44 	sub	r8,sp,-1724
8000f79c:	14 97       	mov	r7,r10
8000f79e:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000f7a2:	ec ea fd 88 	ld.d	r10,r6[-632]
8000f7a6:	fa eb 00 00 	st.d	sp[0],r10
8000f7aa:	c2 08       	rjmp	8000f7ea <_vfprintf_r+0x11a2>
8000f7ac:	41 09       	lddsp	r9,sp[0x40]
8000f7ae:	59 f8       	cp.w	r8,31
8000f7b0:	e0 89 00 16 	brgt	8000f7dc <_vfprintf_r+0x1194>
8000f7b4:	f2 e6 00 00 	ld.d	r6,r9[0]
8000f7b8:	f2 cb ff f8 	sub	r11,r9,-8
8000f7bc:	fa e7 00 00 	st.d	sp[0],r6
8000f7c0:	51 0b       	stdsp	sp[0x40],r11
8000f7c2:	fa c6 f9 44 	sub	r6,sp,-1724
8000f7c6:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000f7ca:	fa e6 00 00 	ld.d	r6,sp[0]
8000f7ce:	f2 e7 fd 88 	st.d	r9[-632],r6
8000f7d2:	2f f8       	sub	r8,-1
8000f7d4:	14 97       	mov	r7,r10
8000f7d6:	fb 48 06 b4 	st.w	sp[1716],r8
8000f7da:	c0 88       	rjmp	8000f7ea <_vfprintf_r+0x11a2>
8000f7dc:	f2 e6 00 00 	ld.d	r6,r9[0]
8000f7e0:	2f 89       	sub	r9,-8
8000f7e2:	fa e7 00 00 	st.d	sp[0],r6
8000f7e6:	51 09       	stdsp	sp[0x40],r9
8000f7e8:	14 97       	mov	r7,r10
8000f7ea:	30 18       	mov	r8,1
8000f7ec:	e0 8f 01 d0 	bral	8000fb8c <_vfprintf_r+0x1544>
8000f7f0:	ed b5 00 04 	bld	r5,0x4
8000f7f4:	c1 61       	brne	8000f820 <_vfprintf_r+0x11d8>
8000f7f6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000f7fa:	40 3e       	lddsp	lr,sp[0xc]
8000f7fc:	58 0e       	cp.w	lr,0
8000f7fe:	c0 80       	breq	8000f80e <_vfprintf_r+0x11c6>
8000f800:	10 36       	cp.w	r6,r8
8000f802:	c6 74       	brge	8000f8d0 <_vfprintf_r+0x1288>
8000f804:	fa cc f9 44 	sub	r12,sp,-1724
8000f808:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000f80c:	c8 08       	rjmp	8000f90c <_vfprintf_r+0x12c4>
8000f80e:	ee ca ff ff 	sub	r10,r7,-1
8000f812:	10 37       	cp.w	r7,r8
8000f814:	c7 f4       	brge	8000f912 <_vfprintf_r+0x12ca>
8000f816:	fa cb f9 44 	sub	r11,sp,-1724
8000f81a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000f81e:	c7 68       	rjmp	8000f90a <_vfprintf_r+0x12c2>
8000f820:	ed b5 00 06 	bld	r5,0x6
8000f824:	c4 a1       	brne	8000f8b8 <_vfprintf_r+0x1270>
8000f826:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000f82a:	40 3c       	lddsp	r12,sp[0xc]
8000f82c:	58 0c       	cp.w	r12,0
8000f82e:	c1 d0       	breq	8000f868 <_vfprintf_r+0x1220>
8000f830:	10 36       	cp.w	r6,r8
8000f832:	c0 64       	brge	8000f83e <_vfprintf_r+0x11f6>
8000f834:	fa cb f9 44 	sub	r11,sp,-1724
8000f838:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000f83c:	c1 f8       	rjmp	8000f87a <_vfprintf_r+0x1232>
8000f83e:	fa c8 f9 50 	sub	r8,sp,-1712
8000f842:	1a d8       	st.w	--sp,r8
8000f844:	fa c8 fa b8 	sub	r8,sp,-1352
8000f848:	1a d8       	st.w	--sp,r8
8000f84a:	fa c8 fb b4 	sub	r8,sp,-1100
8000f84e:	1a d8       	st.w	--sp,r8
8000f850:	fa c8 f9 40 	sub	r8,sp,-1728
8000f854:	fa c9 ff b4 	sub	r9,sp,-76
8000f858:	04 9a       	mov	r10,r2
8000f85a:	0c 9b       	mov	r11,r6
8000f85c:	08 9c       	mov	r12,r4
8000f85e:	fe b0 f5 57 	rcall	8000e30c <get_arg>
8000f862:	2f dd       	sub	sp,-12
8000f864:	98 18       	ld.sh	r8,r12[0x2]
8000f866:	c2 68       	rjmp	8000f8b2 <_vfprintf_r+0x126a>
8000f868:	ee ca ff ff 	sub	r10,r7,-1
8000f86c:	10 37       	cp.w	r7,r8
8000f86e:	c0 94       	brge	8000f880 <_vfprintf_r+0x1238>
8000f870:	fa c9 f9 44 	sub	r9,sp,-1724
8000f874:	14 97       	mov	r7,r10
8000f876:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000f87a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000f87e:	c1 a8       	rjmp	8000f8b2 <_vfprintf_r+0x126a>
8000f880:	41 09       	lddsp	r9,sp[0x40]
8000f882:	59 f8       	cp.w	r8,31
8000f884:	e0 89 00 13 	brgt	8000f8aa <_vfprintf_r+0x1262>
8000f888:	f2 cb ff fc 	sub	r11,r9,-4
8000f88c:	51 0b       	stdsp	sp[0x40],r11
8000f88e:	72 09       	ld.w	r9,r9[0x0]
8000f890:	fa c6 f9 44 	sub	r6,sp,-1724
8000f894:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000f898:	2f f8       	sub	r8,-1
8000f89a:	f7 49 fd 88 	st.w	r11[-632],r9
8000f89e:	fb 48 06 b4 	st.w	sp[1716],r8
8000f8a2:	14 97       	mov	r7,r10
8000f8a4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000f8a8:	c0 58       	rjmp	8000f8b2 <_vfprintf_r+0x126a>
8000f8aa:	92 18       	ld.sh	r8,r9[0x2]
8000f8ac:	14 97       	mov	r7,r10
8000f8ae:	2f c9       	sub	r9,-4
8000f8b0:	51 09       	stdsp	sp[0x40],r9
8000f8b2:	5c 78       	castu.h	r8
8000f8b4:	50 18       	stdsp	sp[0x4],r8
8000f8b6:	c4 68       	rjmp	8000f942 <_vfprintf_r+0x12fa>
8000f8b8:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000f8bc:	40 3c       	lddsp	r12,sp[0xc]
8000f8be:	58 0c       	cp.w	r12,0
8000f8c0:	c1 d0       	breq	8000f8fa <_vfprintf_r+0x12b2>
8000f8c2:	10 36       	cp.w	r6,r8
8000f8c4:	c0 64       	brge	8000f8d0 <_vfprintf_r+0x1288>
8000f8c6:	fa cb f9 44 	sub	r11,sp,-1724
8000f8ca:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000f8ce:	c1 f8       	rjmp	8000f90c <_vfprintf_r+0x12c4>
8000f8d0:	fa c8 f9 50 	sub	r8,sp,-1712
8000f8d4:	1a d8       	st.w	--sp,r8
8000f8d6:	fa c8 fa b8 	sub	r8,sp,-1352
8000f8da:	0c 9b       	mov	r11,r6
8000f8dc:	1a d8       	st.w	--sp,r8
8000f8de:	fa c8 fb b4 	sub	r8,sp,-1100
8000f8e2:	04 9a       	mov	r10,r2
8000f8e4:	1a d8       	st.w	--sp,r8
8000f8e6:	08 9c       	mov	r12,r4
8000f8e8:	fa c8 f9 40 	sub	r8,sp,-1728
8000f8ec:	fa c9 ff b4 	sub	r9,sp,-76
8000f8f0:	fe b0 f5 0e 	rcall	8000e30c <get_arg>
8000f8f4:	2f dd       	sub	sp,-12
8000f8f6:	78 0b       	ld.w	r11,r12[0x0]
8000f8f8:	c2 48       	rjmp	8000f940 <_vfprintf_r+0x12f8>
8000f8fa:	ee ca ff ff 	sub	r10,r7,-1
8000f8fe:	10 37       	cp.w	r7,r8
8000f900:	c0 94       	brge	8000f912 <_vfprintf_r+0x12ca>
8000f902:	fa c9 f9 44 	sub	r9,sp,-1724
8000f906:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000f90a:	14 97       	mov	r7,r10
8000f90c:	ec fb fd 88 	ld.w	r11,r6[-632]
8000f910:	c1 88       	rjmp	8000f940 <_vfprintf_r+0x12f8>
8000f912:	41 09       	lddsp	r9,sp[0x40]
8000f914:	59 f8       	cp.w	r8,31
8000f916:	e0 89 00 11 	brgt	8000f938 <_vfprintf_r+0x12f0>
8000f91a:	f2 cb ff fc 	sub	r11,r9,-4
8000f91e:	51 0b       	stdsp	sp[0x40],r11
8000f920:	fa c6 f9 44 	sub	r6,sp,-1724
8000f924:	72 0b       	ld.w	r11,r9[0x0]
8000f926:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000f92a:	f3 4b fd 88 	st.w	r9[-632],r11
8000f92e:	2f f8       	sub	r8,-1
8000f930:	14 97       	mov	r7,r10
8000f932:	fb 48 06 b4 	st.w	sp[1716],r8
8000f936:	c0 58       	rjmp	8000f940 <_vfprintf_r+0x12f8>
8000f938:	72 0b       	ld.w	r11,r9[0x0]
8000f93a:	14 97       	mov	r7,r10
8000f93c:	2f c9       	sub	r9,-4
8000f93e:	51 09       	stdsp	sp[0x40],r9
8000f940:	50 1b       	stdsp	sp[0x4],r11
8000f942:	30 0e       	mov	lr,0
8000f944:	30 18       	mov	r8,1
8000f946:	50 0e       	stdsp	sp[0x0],lr
8000f948:	c2 29       	rjmp	8000fb8c <_vfprintf_r+0x1544>
8000f94a:	50 a7       	stdsp	sp[0x28],r7
8000f94c:	50 80       	stdsp	sp[0x20],r0
8000f94e:	0c 97       	mov	r7,r6
8000f950:	04 94       	mov	r4,r2
8000f952:	06 96       	mov	r6,r3
8000f954:	02 92       	mov	r2,r1
8000f956:	fe cc 90 8e 	sub	r12,pc,-28530
8000f95a:	40 93       	lddsp	r3,sp[0x24]
8000f95c:	10 90       	mov	r0,r8
8000f95e:	40 41       	lddsp	r1,sp[0x10]
8000f960:	50 dc       	stdsp	sp[0x34],r12
8000f962:	ed b5 00 05 	bld	r5,0x5
8000f966:	c5 51       	brne	8000fa10 <_vfprintf_r+0x13c8>
8000f968:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000f96c:	40 3b       	lddsp	r11,sp[0xc]
8000f96e:	58 0b       	cp.w	r11,0
8000f970:	c2 20       	breq	8000f9b4 <_vfprintf_r+0x136c>
8000f972:	10 36       	cp.w	r6,r8
8000f974:	c0 a4       	brge	8000f988 <_vfprintf_r+0x1340>
8000f976:	fa ca f9 44 	sub	r10,sp,-1724
8000f97a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000f97e:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000f982:	fa e9 00 00 	st.d	sp[0],r8
8000f986:	cf 28       	rjmp	8000fb6a <_vfprintf_r+0x1522>
8000f988:	fa c8 f9 50 	sub	r8,sp,-1712
8000f98c:	1a d8       	st.w	--sp,r8
8000f98e:	fa c8 fa b8 	sub	r8,sp,-1352
8000f992:	04 9a       	mov	r10,r2
8000f994:	1a d8       	st.w	--sp,r8
8000f996:	0c 9b       	mov	r11,r6
8000f998:	fa c8 fb b4 	sub	r8,sp,-1100
8000f99c:	08 9c       	mov	r12,r4
8000f99e:	1a d8       	st.w	--sp,r8
8000f9a0:	fa c8 f9 40 	sub	r8,sp,-1728
8000f9a4:	fa c9 ff b4 	sub	r9,sp,-76
8000f9a8:	fe b0 f4 b2 	rcall	8000e30c <get_arg>
8000f9ac:	2f dd       	sub	sp,-12
8000f9ae:	f8 ea 00 00 	ld.d	r10,r12[0]
8000f9b2:	c0 c8       	rjmp	8000f9ca <_vfprintf_r+0x1382>
8000f9b4:	ee ca ff ff 	sub	r10,r7,-1
8000f9b8:	10 37       	cp.w	r7,r8
8000f9ba:	c0 b4       	brge	8000f9d0 <_vfprintf_r+0x1388>
8000f9bc:	fa c9 f9 44 	sub	r9,sp,-1724
8000f9c0:	14 97       	mov	r7,r10
8000f9c2:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000f9c6:	ec ea fd 88 	ld.d	r10,r6[-632]
8000f9ca:	fa eb 00 00 	st.d	sp[0],r10
8000f9ce:	cc e8       	rjmp	8000fb6a <_vfprintf_r+0x1522>
8000f9d0:	41 09       	lddsp	r9,sp[0x40]
8000f9d2:	59 f8       	cp.w	r8,31
8000f9d4:	e0 89 00 16 	brgt	8000fa00 <_vfprintf_r+0x13b8>
8000f9d8:	f2 e6 00 00 	ld.d	r6,r9[0]
8000f9dc:	f2 cb ff f8 	sub	r11,r9,-8
8000f9e0:	fa e7 00 00 	st.d	sp[0],r6
8000f9e4:	51 0b       	stdsp	sp[0x40],r11
8000f9e6:	fa c6 f9 44 	sub	r6,sp,-1724
8000f9ea:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000f9ee:	fa e6 00 00 	ld.d	r6,sp[0]
8000f9f2:	f2 e7 fd 88 	st.d	r9[-632],r6
8000f9f6:	2f f8       	sub	r8,-1
8000f9f8:	14 97       	mov	r7,r10
8000f9fa:	fb 48 06 b4 	st.w	sp[1716],r8
8000f9fe:	cb 68       	rjmp	8000fb6a <_vfprintf_r+0x1522>
8000fa00:	f2 e6 00 00 	ld.d	r6,r9[0]
8000fa04:	2f 89       	sub	r9,-8
8000fa06:	fa e7 00 00 	st.d	sp[0],r6
8000fa0a:	51 09       	stdsp	sp[0x40],r9
8000fa0c:	14 97       	mov	r7,r10
8000fa0e:	ca e8       	rjmp	8000fb6a <_vfprintf_r+0x1522>
8000fa10:	ed b5 00 04 	bld	r5,0x4
8000fa14:	c1 71       	brne	8000fa42 <_vfprintf_r+0x13fa>
8000fa16:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000fa1a:	40 3e       	lddsp	lr,sp[0xc]
8000fa1c:	58 0e       	cp.w	lr,0
8000fa1e:	c0 80       	breq	8000fa2e <_vfprintf_r+0x13e6>
8000fa20:	10 36       	cp.w	r6,r8
8000fa22:	c6 94       	brge	8000faf4 <_vfprintf_r+0x14ac>
8000fa24:	fa cc f9 44 	sub	r12,sp,-1724
8000fa28:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000fa2c:	c8 28       	rjmp	8000fb30 <_vfprintf_r+0x14e8>
8000fa2e:	ee ca ff ff 	sub	r10,r7,-1
8000fa32:	10 37       	cp.w	r7,r8
8000fa34:	e0 84 00 81 	brge	8000fb36 <_vfprintf_r+0x14ee>
8000fa38:	fa cb f9 44 	sub	r11,sp,-1724
8000fa3c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000fa40:	c7 78       	rjmp	8000fb2e <_vfprintf_r+0x14e6>
8000fa42:	ed b5 00 06 	bld	r5,0x6
8000fa46:	c4 b1       	brne	8000fadc <_vfprintf_r+0x1494>
8000fa48:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000fa4c:	40 3c       	lddsp	r12,sp[0xc]
8000fa4e:	58 0c       	cp.w	r12,0
8000fa50:	c1 d0       	breq	8000fa8a <_vfprintf_r+0x1442>
8000fa52:	10 36       	cp.w	r6,r8
8000fa54:	c0 64       	brge	8000fa60 <_vfprintf_r+0x1418>
8000fa56:	fa cb f9 44 	sub	r11,sp,-1724
8000fa5a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000fa5e:	c1 f8       	rjmp	8000fa9c <_vfprintf_r+0x1454>
8000fa60:	fa c8 f9 50 	sub	r8,sp,-1712
8000fa64:	1a d8       	st.w	--sp,r8
8000fa66:	fa c8 fa b8 	sub	r8,sp,-1352
8000fa6a:	1a d8       	st.w	--sp,r8
8000fa6c:	fa c8 fb b4 	sub	r8,sp,-1100
8000fa70:	1a d8       	st.w	--sp,r8
8000fa72:	fa c8 f9 40 	sub	r8,sp,-1728
8000fa76:	fa c9 ff b4 	sub	r9,sp,-76
8000fa7a:	04 9a       	mov	r10,r2
8000fa7c:	0c 9b       	mov	r11,r6
8000fa7e:	08 9c       	mov	r12,r4
8000fa80:	fe b0 f4 46 	rcall	8000e30c <get_arg>
8000fa84:	2f dd       	sub	sp,-12
8000fa86:	98 18       	ld.sh	r8,r12[0x2]
8000fa88:	c2 78       	rjmp	8000fad6 <_vfprintf_r+0x148e>
8000fa8a:	ee ca ff ff 	sub	r10,r7,-1
8000fa8e:	10 37       	cp.w	r7,r8
8000fa90:	c0 a4       	brge	8000faa4 <_vfprintf_r+0x145c>
8000fa92:	fa c9 f9 44 	sub	r9,sp,-1724
8000fa96:	14 97       	mov	r7,r10
8000fa98:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000fa9c:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000faa0:	c1 b8       	rjmp	8000fad6 <_vfprintf_r+0x148e>
8000faa2:	d7 03       	nop
8000faa4:	41 09       	lddsp	r9,sp[0x40]
8000faa6:	59 f8       	cp.w	r8,31
8000faa8:	e0 89 00 13 	brgt	8000face <_vfprintf_r+0x1486>
8000faac:	f2 cb ff fc 	sub	r11,r9,-4
8000fab0:	51 0b       	stdsp	sp[0x40],r11
8000fab2:	72 09       	ld.w	r9,r9[0x0]
8000fab4:	fa c6 f9 44 	sub	r6,sp,-1724
8000fab8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000fabc:	2f f8       	sub	r8,-1
8000fabe:	f7 49 fd 88 	st.w	r11[-632],r9
8000fac2:	fb 48 06 b4 	st.w	sp[1716],r8
8000fac6:	14 97       	mov	r7,r10
8000fac8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000facc:	c0 58       	rjmp	8000fad6 <_vfprintf_r+0x148e>
8000face:	92 18       	ld.sh	r8,r9[0x2]
8000fad0:	14 97       	mov	r7,r10
8000fad2:	2f c9       	sub	r9,-4
8000fad4:	51 09       	stdsp	sp[0x40],r9
8000fad6:	5c 78       	castu.h	r8
8000fad8:	50 18       	stdsp	sp[0x4],r8
8000fada:	c4 68       	rjmp	8000fb66 <_vfprintf_r+0x151e>
8000fadc:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000fae0:	40 3c       	lddsp	r12,sp[0xc]
8000fae2:	58 0c       	cp.w	r12,0
8000fae4:	c1 d0       	breq	8000fb1e <_vfprintf_r+0x14d6>
8000fae6:	10 36       	cp.w	r6,r8
8000fae8:	c0 64       	brge	8000faf4 <_vfprintf_r+0x14ac>
8000faea:	fa cb f9 44 	sub	r11,sp,-1724
8000faee:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000faf2:	c1 f8       	rjmp	8000fb30 <_vfprintf_r+0x14e8>
8000faf4:	fa c8 f9 50 	sub	r8,sp,-1712
8000faf8:	1a d8       	st.w	--sp,r8
8000fafa:	fa c8 fa b8 	sub	r8,sp,-1352
8000fafe:	0c 9b       	mov	r11,r6
8000fb00:	1a d8       	st.w	--sp,r8
8000fb02:	fa c8 fb b4 	sub	r8,sp,-1100
8000fb06:	04 9a       	mov	r10,r2
8000fb08:	1a d8       	st.w	--sp,r8
8000fb0a:	08 9c       	mov	r12,r4
8000fb0c:	fa c8 f9 40 	sub	r8,sp,-1728
8000fb10:	fa c9 ff b4 	sub	r9,sp,-76
8000fb14:	fe b0 f3 fc 	rcall	8000e30c <get_arg>
8000fb18:	2f dd       	sub	sp,-12
8000fb1a:	78 0b       	ld.w	r11,r12[0x0]
8000fb1c:	c2 48       	rjmp	8000fb64 <_vfprintf_r+0x151c>
8000fb1e:	ee ca ff ff 	sub	r10,r7,-1
8000fb22:	10 37       	cp.w	r7,r8
8000fb24:	c0 94       	brge	8000fb36 <_vfprintf_r+0x14ee>
8000fb26:	fa c9 f9 44 	sub	r9,sp,-1724
8000fb2a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000fb2e:	14 97       	mov	r7,r10
8000fb30:	ec fb fd 88 	ld.w	r11,r6[-632]
8000fb34:	c1 88       	rjmp	8000fb64 <_vfprintf_r+0x151c>
8000fb36:	41 09       	lddsp	r9,sp[0x40]
8000fb38:	59 f8       	cp.w	r8,31
8000fb3a:	e0 89 00 11 	brgt	8000fb5c <_vfprintf_r+0x1514>
8000fb3e:	f2 cb ff fc 	sub	r11,r9,-4
8000fb42:	51 0b       	stdsp	sp[0x40],r11
8000fb44:	fa c6 f9 44 	sub	r6,sp,-1724
8000fb48:	72 0b       	ld.w	r11,r9[0x0]
8000fb4a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000fb4e:	f3 4b fd 88 	st.w	r9[-632],r11
8000fb52:	2f f8       	sub	r8,-1
8000fb54:	14 97       	mov	r7,r10
8000fb56:	fb 48 06 b4 	st.w	sp[1716],r8
8000fb5a:	c0 58       	rjmp	8000fb64 <_vfprintf_r+0x151c>
8000fb5c:	72 0b       	ld.w	r11,r9[0x0]
8000fb5e:	14 97       	mov	r7,r10
8000fb60:	2f c9       	sub	r9,-4
8000fb62:	51 09       	stdsp	sp[0x40],r9
8000fb64:	50 1b       	stdsp	sp[0x4],r11
8000fb66:	30 0e       	mov	lr,0
8000fb68:	50 0e       	stdsp	sp[0x0],lr
8000fb6a:	40 08       	lddsp	r8,sp[0x0]
8000fb6c:	40 1c       	lddsp	r12,sp[0x4]
8000fb6e:	18 48       	or	r8,r12
8000fb70:	5f 19       	srne	r9
8000fb72:	0a 98       	mov	r8,r5
8000fb74:	eb e9 00 09 	and	r9,r5,r9
8000fb78:	a1 b8       	sbr	r8,0x1
8000fb7a:	58 09       	cp.w	r9,0
8000fb7c:	c0 70       	breq	8000fb8a <_vfprintf_r+0x1542>
8000fb7e:	10 95       	mov	r5,r8
8000fb80:	fb 60 06 b9 	st.b	sp[1721],r0
8000fb84:	33 08       	mov	r8,48
8000fb86:	fb 68 06 b8 	st.b	sp[1720],r8
8000fb8a:	30 28       	mov	r8,2
8000fb8c:	30 09       	mov	r9,0
8000fb8e:	fb 69 06 bb 	st.b	sp[1723],r9
8000fb92:	0a 99       	mov	r9,r5
8000fb94:	a7 d9       	cbr	r9,0x7
8000fb96:	40 2b       	lddsp	r11,sp[0x8]
8000fb98:	40 16       	lddsp	r6,sp[0x4]
8000fb9a:	58 0b       	cp.w	r11,0
8000fb9c:	5f 1a       	srne	r10
8000fb9e:	f2 05 17 40 	movge	r5,r9
8000fba2:	fa c2 f9 78 	sub	r2,sp,-1672
8000fba6:	40 09       	lddsp	r9,sp[0x0]
8000fba8:	0c 49       	or	r9,r6
8000fbaa:	5f 19       	srne	r9
8000fbac:	f5 e9 10 09 	or	r9,r10,r9
8000fbb0:	c5 c0       	breq	8000fc68 <_vfprintf_r+0x1620>
8000fbb2:	30 19       	mov	r9,1
8000fbb4:	f2 08 18 00 	cp.b	r8,r9
8000fbb8:	c0 60       	breq	8000fbc4 <_vfprintf_r+0x157c>
8000fbba:	30 29       	mov	r9,2
8000fbbc:	f2 08 18 00 	cp.b	r8,r9
8000fbc0:	c0 41       	brne	8000fbc8 <_vfprintf_r+0x1580>
8000fbc2:	c3 c8       	rjmp	8000fc3a <_vfprintf_r+0x15f2>
8000fbc4:	04 96       	mov	r6,r2
8000fbc6:	c3 08       	rjmp	8000fc26 <_vfprintf_r+0x15de>
8000fbc8:	04 96       	mov	r6,r2
8000fbca:	fa e8 00 00 	ld.d	r8,sp[0]
8000fbce:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000fbd2:	2d 0a       	sub	r10,-48
8000fbd4:	0c fa       	st.b	--r6,r10
8000fbd6:	f0 0b 16 03 	lsr	r11,r8,0x3
8000fbda:	f2 0c 16 03 	lsr	r12,r9,0x3
8000fbde:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000fbe2:	18 99       	mov	r9,r12
8000fbe4:	16 98       	mov	r8,r11
8000fbe6:	58 08       	cp.w	r8,0
8000fbe8:	5c 29       	cpc	r9
8000fbea:	cf 21       	brne	8000fbce <_vfprintf_r+0x1586>
8000fbec:	fa e9 00 00 	st.d	sp[0],r8
8000fbf0:	ed b5 00 00 	bld	r5,0x0
8000fbf4:	c4 51       	brne	8000fc7e <_vfprintf_r+0x1636>
8000fbf6:	33 09       	mov	r9,48
8000fbf8:	f2 0a 18 00 	cp.b	r10,r9
8000fbfc:	c4 10       	breq	8000fc7e <_vfprintf_r+0x1636>
8000fbfe:	0c f9       	st.b	--r6,r9
8000fc00:	c3 f8       	rjmp	8000fc7e <_vfprintf_r+0x1636>
8000fc02:	fa ea 00 00 	ld.d	r10,sp[0]
8000fc06:	30 a8       	mov	r8,10
8000fc08:	30 09       	mov	r9,0
8000fc0a:	e0 a0 17 c9 	rcall	80012b9c <__avr32_umod64>
8000fc0e:	30 a8       	mov	r8,10
8000fc10:	2d 0a       	sub	r10,-48
8000fc12:	30 09       	mov	r9,0
8000fc14:	ac 8a       	st.b	r6[0x0],r10
8000fc16:	fa ea 00 00 	ld.d	r10,sp[0]
8000fc1a:	fe b0 e1 90 	rcall	8000bf3a <__avr32_udiv64>
8000fc1e:	16 99       	mov	r9,r11
8000fc20:	14 98       	mov	r8,r10
8000fc22:	fa e9 00 00 	st.d	sp[0],r8
8000fc26:	20 16       	sub	r6,1
8000fc28:	fa ea 00 00 	ld.d	r10,sp[0]
8000fc2c:	58 9a       	cp.w	r10,9
8000fc2e:	5c 2b       	cpc	r11
8000fc30:	fe 9b ff e9 	brhi	8000fc02 <_vfprintf_r+0x15ba>
8000fc34:	1b f8       	ld.ub	r8,sp[0x7]
8000fc36:	2d 08       	sub	r8,-48
8000fc38:	c2 08       	rjmp	8000fc78 <_vfprintf_r+0x1630>
8000fc3a:	04 96       	mov	r6,r2
8000fc3c:	fa e8 00 00 	ld.d	r8,sp[0]
8000fc40:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000fc44:	40 de       	lddsp	lr,sp[0x34]
8000fc46:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000fc4a:	0c fa       	st.b	--r6,r10
8000fc4c:	f2 0b 16 04 	lsr	r11,r9,0x4
8000fc50:	f0 0a 16 04 	lsr	r10,r8,0x4
8000fc54:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8000fc58:	16 99       	mov	r9,r11
8000fc5a:	14 98       	mov	r8,r10
8000fc5c:	58 08       	cp.w	r8,0
8000fc5e:	5c 29       	cpc	r9
8000fc60:	cf 01       	brne	8000fc40 <_vfprintf_r+0x15f8>
8000fc62:	fa e9 00 00 	st.d	sp[0],r8
8000fc66:	c0 c8       	rjmp	8000fc7e <_vfprintf_r+0x1636>
8000fc68:	58 08       	cp.w	r8,0
8000fc6a:	c0 91       	brne	8000fc7c <_vfprintf_r+0x1634>
8000fc6c:	ed b5 00 00 	bld	r5,0x0
8000fc70:	c0 61       	brne	8000fc7c <_vfprintf_r+0x1634>
8000fc72:	fa c6 f9 79 	sub	r6,sp,-1671
8000fc76:	33 08       	mov	r8,48
8000fc78:	ac 88       	st.b	r6[0x0],r8
8000fc7a:	c0 28       	rjmp	8000fc7e <_vfprintf_r+0x1636>
8000fc7c:	04 96       	mov	r6,r2
8000fc7e:	0c 12       	sub	r2,r6
8000fc80:	c1 c8       	rjmp	8000fcb8 <_vfprintf_r+0x1670>
8000fc82:	50 a7       	stdsp	sp[0x28],r7
8000fc84:	50 80       	stdsp	sp[0x20],r0
8000fc86:	40 93       	lddsp	r3,sp[0x24]
8000fc88:	0c 97       	mov	r7,r6
8000fc8a:	10 90       	mov	r0,r8
8000fc8c:	04 94       	mov	r4,r2
8000fc8e:	40 41       	lddsp	r1,sp[0x10]
8000fc90:	58 08       	cp.w	r8,0
8000fc92:	e0 80 04 4f 	breq	80010530 <_vfprintf_r+0x1ee8>
8000fc96:	fb 68 06 60 	st.b	sp[1632],r8
8000fc9a:	30 0c       	mov	r12,0
8000fc9c:	30 08       	mov	r8,0
8000fc9e:	30 12       	mov	r2,1
8000fca0:	fb 68 06 bb 	st.b	sp[1723],r8
8000fca4:	50 2c       	stdsp	sp[0x8],r12
8000fca6:	fa c6 f9 a0 	sub	r6,sp,-1632
8000fcaa:	c0 78       	rjmp	8000fcb8 <_vfprintf_r+0x1670>
8000fcac:	30 0b       	mov	r11,0
8000fcae:	50 2b       	stdsp	sp[0x8],r11
8000fcb0:	c0 48       	rjmp	8000fcb8 <_vfprintf_r+0x1670>
8000fcb2:	40 22       	lddsp	r2,sp[0x8]
8000fcb4:	30 0a       	mov	r10,0
8000fcb6:	50 2a       	stdsp	sp[0x8],r10
8000fcb8:	40 29       	lddsp	r9,sp[0x8]
8000fcba:	e4 09 0c 49 	max	r9,r2,r9
8000fcbe:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000fcc2:	50 39       	stdsp	sp[0xc],r9
8000fcc4:	0a 9e       	mov	lr,r5
8000fcc6:	30 09       	mov	r9,0
8000fcc8:	e2 1e 00 02 	andl	lr,0x2,COH
8000fccc:	f2 08 18 00 	cp.b	r8,r9
8000fcd0:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000fcd4:	f7 b8 01 ff 	subne	r8,-1
8000fcd8:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000fcdc:	0a 9b       	mov	r11,r5
8000fcde:	58 0e       	cp.w	lr,0
8000fce0:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000fce4:	f7 bc 01 fe 	subne	r12,-2
8000fce8:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000fcec:	e2 1b 00 84 	andl	r11,0x84,COH
8000fcf0:	50 fe       	stdsp	sp[0x3c],lr
8000fcf2:	50 9b       	stdsp	sp[0x24],r11
8000fcf4:	c4 71       	brne	8000fd82 <_vfprintf_r+0x173a>
8000fcf6:	40 8a       	lddsp	r10,sp[0x20]
8000fcf8:	40 39       	lddsp	r9,sp[0xc]
8000fcfa:	12 1a       	sub	r10,r9
8000fcfc:	50 4a       	stdsp	sp[0x10],r10
8000fcfe:	58 0a       	cp.w	r10,0
8000fd00:	e0 89 00 20 	brgt	8000fd40 <_vfprintf_r+0x16f8>
8000fd04:	c3 f8       	rjmp	8000fd82 <_vfprintf_r+0x173a>
8000fd06:	2f 09       	sub	r9,-16
8000fd08:	2f f8       	sub	r8,-1
8000fd0a:	fe ce 90 96 	sub	lr,pc,-28522
8000fd0e:	31 0c       	mov	r12,16
8000fd10:	fb 49 06 90 	st.w	sp[1680],r9
8000fd14:	87 0e       	st.w	r3[0x0],lr
8000fd16:	87 1c       	st.w	r3[0x4],r12
8000fd18:	fb 48 06 8c 	st.w	sp[1676],r8
8000fd1c:	58 78       	cp.w	r8,7
8000fd1e:	e0 89 00 04 	brgt	8000fd26 <_vfprintf_r+0x16de>
8000fd22:	2f 83       	sub	r3,-8
8000fd24:	c0 b8       	rjmp	8000fd3a <_vfprintf_r+0x16f2>
8000fd26:	fa ca f9 78 	sub	r10,sp,-1672
8000fd2a:	02 9b       	mov	r11,r1
8000fd2c:	08 9c       	mov	r12,r4
8000fd2e:	fe b0 f4 7f 	rcall	8000e62c <__sprint_r>
8000fd32:	e0 81 04 10 	brne	80010552 <_vfprintf_r+0x1f0a>
8000fd36:	fa c3 f9 e0 	sub	r3,sp,-1568
8000fd3a:	40 4b       	lddsp	r11,sp[0x10]
8000fd3c:	21 0b       	sub	r11,16
8000fd3e:	50 4b       	stdsp	sp[0x10],r11
8000fd40:	fa f9 06 90 	ld.w	r9,sp[1680]
8000fd44:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000fd48:	fe ca 90 d4 	sub	r10,pc,-28460
8000fd4c:	40 4e       	lddsp	lr,sp[0x10]
8000fd4e:	59 0e       	cp.w	lr,16
8000fd50:	fe 99 ff db 	brgt	8000fd06 <_vfprintf_r+0x16be>
8000fd54:	1c 09       	add	r9,lr
8000fd56:	2f f8       	sub	r8,-1
8000fd58:	87 0a       	st.w	r3[0x0],r10
8000fd5a:	fb 49 06 90 	st.w	sp[1680],r9
8000fd5e:	87 1e       	st.w	r3[0x4],lr
8000fd60:	fb 48 06 8c 	st.w	sp[1676],r8
8000fd64:	58 78       	cp.w	r8,7
8000fd66:	e0 89 00 04 	brgt	8000fd6e <_vfprintf_r+0x1726>
8000fd6a:	2f 83       	sub	r3,-8
8000fd6c:	c0 b8       	rjmp	8000fd82 <_vfprintf_r+0x173a>
8000fd6e:	fa ca f9 78 	sub	r10,sp,-1672
8000fd72:	02 9b       	mov	r11,r1
8000fd74:	08 9c       	mov	r12,r4
8000fd76:	fe b0 f4 5b 	rcall	8000e62c <__sprint_r>
8000fd7a:	e0 81 03 ec 	brne	80010552 <_vfprintf_r+0x1f0a>
8000fd7e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000fd82:	30 09       	mov	r9,0
8000fd84:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000fd88:	f2 08 18 00 	cp.b	r8,r9
8000fd8c:	c1 f0       	breq	8000fdca <_vfprintf_r+0x1782>
8000fd8e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000fd92:	fa c9 f9 45 	sub	r9,sp,-1723
8000fd96:	2f f8       	sub	r8,-1
8000fd98:	87 09       	st.w	r3[0x0],r9
8000fd9a:	fb 48 06 90 	st.w	sp[1680],r8
8000fd9e:	30 19       	mov	r9,1
8000fda0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000fda4:	87 19       	st.w	r3[0x4],r9
8000fda6:	2f f8       	sub	r8,-1
8000fda8:	fb 48 06 8c 	st.w	sp[1676],r8
8000fdac:	58 78       	cp.w	r8,7
8000fdae:	e0 89 00 04 	brgt	8000fdb6 <_vfprintf_r+0x176e>
8000fdb2:	2f 83       	sub	r3,-8
8000fdb4:	c0 b8       	rjmp	8000fdca <_vfprintf_r+0x1782>
8000fdb6:	fa ca f9 78 	sub	r10,sp,-1672
8000fdba:	02 9b       	mov	r11,r1
8000fdbc:	08 9c       	mov	r12,r4
8000fdbe:	fe b0 f4 37 	rcall	8000e62c <__sprint_r>
8000fdc2:	e0 81 03 c8 	brne	80010552 <_vfprintf_r+0x1f0a>
8000fdc6:	fa c3 f9 e0 	sub	r3,sp,-1568
8000fdca:	40 fc       	lddsp	r12,sp[0x3c]
8000fdcc:	58 0c       	cp.w	r12,0
8000fdce:	c1 f0       	breq	8000fe0c <_vfprintf_r+0x17c4>
8000fdd0:	fa f8 06 90 	ld.w	r8,sp[1680]
8000fdd4:	fa c9 f9 48 	sub	r9,sp,-1720
8000fdd8:	2f e8       	sub	r8,-2
8000fdda:	87 09       	st.w	r3[0x0],r9
8000fddc:	fb 48 06 90 	st.w	sp[1680],r8
8000fde0:	30 29       	mov	r9,2
8000fde2:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000fde6:	87 19       	st.w	r3[0x4],r9
8000fde8:	2f f8       	sub	r8,-1
8000fdea:	fb 48 06 8c 	st.w	sp[1676],r8
8000fdee:	58 78       	cp.w	r8,7
8000fdf0:	e0 89 00 04 	brgt	8000fdf8 <_vfprintf_r+0x17b0>
8000fdf4:	2f 83       	sub	r3,-8
8000fdf6:	c0 b8       	rjmp	8000fe0c <_vfprintf_r+0x17c4>
8000fdf8:	fa ca f9 78 	sub	r10,sp,-1672
8000fdfc:	02 9b       	mov	r11,r1
8000fdfe:	08 9c       	mov	r12,r4
8000fe00:	fe b0 f4 16 	rcall	8000e62c <__sprint_r>
8000fe04:	e0 81 03 a7 	brne	80010552 <_vfprintf_r+0x1f0a>
8000fe08:	fa c3 f9 e0 	sub	r3,sp,-1568
8000fe0c:	40 9b       	lddsp	r11,sp[0x24]
8000fe0e:	e0 4b 00 80 	cp.w	r11,128
8000fe12:	c4 71       	brne	8000fea0 <_vfprintf_r+0x1858>
8000fe14:	40 8a       	lddsp	r10,sp[0x20]
8000fe16:	40 39       	lddsp	r9,sp[0xc]
8000fe18:	12 1a       	sub	r10,r9
8000fe1a:	50 4a       	stdsp	sp[0x10],r10
8000fe1c:	58 0a       	cp.w	r10,0
8000fe1e:	e0 89 00 20 	brgt	8000fe5e <_vfprintf_r+0x1816>
8000fe22:	c3 f8       	rjmp	8000fea0 <_vfprintf_r+0x1858>
8000fe24:	2f 09       	sub	r9,-16
8000fe26:	2f f8       	sub	r8,-1
8000fe28:	fe ce 91 a4 	sub	lr,pc,-28252
8000fe2c:	31 0c       	mov	r12,16
8000fe2e:	fb 49 06 90 	st.w	sp[1680],r9
8000fe32:	87 0e       	st.w	r3[0x0],lr
8000fe34:	87 1c       	st.w	r3[0x4],r12
8000fe36:	fb 48 06 8c 	st.w	sp[1676],r8
8000fe3a:	58 78       	cp.w	r8,7
8000fe3c:	e0 89 00 04 	brgt	8000fe44 <_vfprintf_r+0x17fc>
8000fe40:	2f 83       	sub	r3,-8
8000fe42:	c0 b8       	rjmp	8000fe58 <_vfprintf_r+0x1810>
8000fe44:	fa ca f9 78 	sub	r10,sp,-1672
8000fe48:	02 9b       	mov	r11,r1
8000fe4a:	08 9c       	mov	r12,r4
8000fe4c:	fe b0 f3 f0 	rcall	8000e62c <__sprint_r>
8000fe50:	e0 81 03 81 	brne	80010552 <_vfprintf_r+0x1f0a>
8000fe54:	fa c3 f9 e0 	sub	r3,sp,-1568
8000fe58:	40 4b       	lddsp	r11,sp[0x10]
8000fe5a:	21 0b       	sub	r11,16
8000fe5c:	50 4b       	stdsp	sp[0x10],r11
8000fe5e:	fa f9 06 90 	ld.w	r9,sp[1680]
8000fe62:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000fe66:	fe ca 91 e2 	sub	r10,pc,-28190
8000fe6a:	40 4e       	lddsp	lr,sp[0x10]
8000fe6c:	59 0e       	cp.w	lr,16
8000fe6e:	fe 99 ff db 	brgt	8000fe24 <_vfprintf_r+0x17dc>
8000fe72:	1c 09       	add	r9,lr
8000fe74:	2f f8       	sub	r8,-1
8000fe76:	87 0a       	st.w	r3[0x0],r10
8000fe78:	fb 49 06 90 	st.w	sp[1680],r9
8000fe7c:	87 1e       	st.w	r3[0x4],lr
8000fe7e:	fb 48 06 8c 	st.w	sp[1676],r8
8000fe82:	58 78       	cp.w	r8,7
8000fe84:	e0 89 00 04 	brgt	8000fe8c <_vfprintf_r+0x1844>
8000fe88:	2f 83       	sub	r3,-8
8000fe8a:	c0 b8       	rjmp	8000fea0 <_vfprintf_r+0x1858>
8000fe8c:	fa ca f9 78 	sub	r10,sp,-1672
8000fe90:	02 9b       	mov	r11,r1
8000fe92:	08 9c       	mov	r12,r4
8000fe94:	fe b0 f3 cc 	rcall	8000e62c <__sprint_r>
8000fe98:	e0 81 03 5d 	brne	80010552 <_vfprintf_r+0x1f0a>
8000fe9c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000fea0:	40 2c       	lddsp	r12,sp[0x8]
8000fea2:	04 1c       	sub	r12,r2
8000fea4:	50 2c       	stdsp	sp[0x8],r12
8000fea6:	58 0c       	cp.w	r12,0
8000fea8:	e0 89 00 20 	brgt	8000fee8 <_vfprintf_r+0x18a0>
8000feac:	c3 f8       	rjmp	8000ff2a <_vfprintf_r+0x18e2>
8000feae:	2f 09       	sub	r9,-16
8000feb0:	2f f8       	sub	r8,-1
8000feb2:	fe cb 92 2e 	sub	r11,pc,-28114
8000feb6:	31 0a       	mov	r10,16
8000feb8:	fb 49 06 90 	st.w	sp[1680],r9
8000febc:	87 0b       	st.w	r3[0x0],r11
8000febe:	87 1a       	st.w	r3[0x4],r10
8000fec0:	fb 48 06 8c 	st.w	sp[1676],r8
8000fec4:	58 78       	cp.w	r8,7
8000fec6:	e0 89 00 04 	brgt	8000fece <_vfprintf_r+0x1886>
8000feca:	2f 83       	sub	r3,-8
8000fecc:	c0 b8       	rjmp	8000fee2 <_vfprintf_r+0x189a>
8000fece:	fa ca f9 78 	sub	r10,sp,-1672
8000fed2:	02 9b       	mov	r11,r1
8000fed4:	08 9c       	mov	r12,r4
8000fed6:	fe b0 f3 ab 	rcall	8000e62c <__sprint_r>
8000feda:	e0 81 03 3c 	brne	80010552 <_vfprintf_r+0x1f0a>
8000fede:	fa c3 f9 e0 	sub	r3,sp,-1568
8000fee2:	40 29       	lddsp	r9,sp[0x8]
8000fee4:	21 09       	sub	r9,16
8000fee6:	50 29       	stdsp	sp[0x8],r9
8000fee8:	fa f9 06 90 	ld.w	r9,sp[1680]
8000feec:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000fef0:	fe ca 92 6c 	sub	r10,pc,-28052
8000fef4:	40 2e       	lddsp	lr,sp[0x8]
8000fef6:	59 0e       	cp.w	lr,16
8000fef8:	fe 99 ff db 	brgt	8000feae <_vfprintf_r+0x1866>
8000fefc:	1c 09       	add	r9,lr
8000fefe:	2f f8       	sub	r8,-1
8000ff00:	87 0a       	st.w	r3[0x0],r10
8000ff02:	fb 49 06 90 	st.w	sp[1680],r9
8000ff06:	87 1e       	st.w	r3[0x4],lr
8000ff08:	fb 48 06 8c 	st.w	sp[1676],r8
8000ff0c:	58 78       	cp.w	r8,7
8000ff0e:	e0 89 00 04 	brgt	8000ff16 <_vfprintf_r+0x18ce>
8000ff12:	2f 83       	sub	r3,-8
8000ff14:	c0 b8       	rjmp	8000ff2a <_vfprintf_r+0x18e2>
8000ff16:	fa ca f9 78 	sub	r10,sp,-1672
8000ff1a:	02 9b       	mov	r11,r1
8000ff1c:	08 9c       	mov	r12,r4
8000ff1e:	fe b0 f3 87 	rcall	8000e62c <__sprint_r>
8000ff22:	e0 81 03 18 	brne	80010552 <_vfprintf_r+0x1f0a>
8000ff26:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ff2a:	ed b5 00 08 	bld	r5,0x8
8000ff2e:	c0 b0       	breq	8000ff44 <_vfprintf_r+0x18fc>
8000ff30:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ff34:	87 12       	st.w	r3[0x4],r2
8000ff36:	87 06       	st.w	r3[0x0],r6
8000ff38:	f0 02 00 02 	add	r2,r8,r2
8000ff3c:	fb 42 06 90 	st.w	sp[1680],r2
8000ff40:	e0 8f 01 d4 	bral	800102e8 <_vfprintf_r+0x1ca0>
8000ff44:	e0 40 00 65 	cp.w	r0,101
8000ff48:	e0 8a 01 d6 	brle	800102f4 <_vfprintf_r+0x1cac>
8000ff4c:	30 08       	mov	r8,0
8000ff4e:	30 09       	mov	r9,0
8000ff50:	40 5b       	lddsp	r11,sp[0x14]
8000ff52:	40 7a       	lddsp	r10,sp[0x1c]
8000ff54:	e0 a0 14 1c 	rcall	8001278c <__avr32_f64_cmp_eq>
8000ff58:	c7 90       	breq	8001004a <_vfprintf_r+0x1a02>
8000ff5a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ff5e:	fe c9 ad 9a 	sub	r9,pc,-21094
8000ff62:	2f f8       	sub	r8,-1
8000ff64:	87 09       	st.w	r3[0x0],r9
8000ff66:	fb 48 06 90 	st.w	sp[1680],r8
8000ff6a:	30 19       	mov	r9,1
8000ff6c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ff70:	87 19       	st.w	r3[0x4],r9
8000ff72:	2f f8       	sub	r8,-1
8000ff74:	fb 48 06 8c 	st.w	sp[1676],r8
8000ff78:	58 78       	cp.w	r8,7
8000ff7a:	e0 89 00 05 	brgt	8000ff84 <_vfprintf_r+0x193c>
8000ff7e:	2f 83       	sub	r3,-8
8000ff80:	c0 c8       	rjmp	8000ff98 <_vfprintf_r+0x1950>
8000ff82:	d7 03       	nop
8000ff84:	fa ca f9 78 	sub	r10,sp,-1672
8000ff88:	02 9b       	mov	r11,r1
8000ff8a:	08 9c       	mov	r12,r4
8000ff8c:	fe b0 f3 50 	rcall	8000e62c <__sprint_r>
8000ff90:	e0 81 02 e1 	brne	80010552 <_vfprintf_r+0x1f0a>
8000ff94:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ff98:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000ff9c:	40 6c       	lddsp	r12,sp[0x18]
8000ff9e:	18 38       	cp.w	r8,r12
8000ffa0:	c0 55       	brlt	8000ffaa <_vfprintf_r+0x1962>
8000ffa2:	ed b5 00 00 	bld	r5,0x0
8000ffa6:	e0 81 02 6b 	brne	8001047c <_vfprintf_r+0x1e34>
8000ffaa:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ffae:	2f f8       	sub	r8,-1
8000ffb0:	40 cb       	lddsp	r11,sp[0x30]
8000ffb2:	fb 48 06 90 	st.w	sp[1680],r8
8000ffb6:	30 19       	mov	r9,1
8000ffb8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ffbc:	87 0b       	st.w	r3[0x0],r11
8000ffbe:	2f f8       	sub	r8,-1
8000ffc0:	87 19       	st.w	r3[0x4],r9
8000ffc2:	fb 48 06 8c 	st.w	sp[1676],r8
8000ffc6:	58 78       	cp.w	r8,7
8000ffc8:	e0 89 00 04 	brgt	8000ffd0 <_vfprintf_r+0x1988>
8000ffcc:	2f 83       	sub	r3,-8
8000ffce:	c0 b8       	rjmp	8000ffe4 <_vfprintf_r+0x199c>
8000ffd0:	fa ca f9 78 	sub	r10,sp,-1672
8000ffd4:	02 9b       	mov	r11,r1
8000ffd6:	08 9c       	mov	r12,r4
8000ffd8:	fe b0 f3 2a 	rcall	8000e62c <__sprint_r>
8000ffdc:	e0 81 02 bb 	brne	80010552 <_vfprintf_r+0x1f0a>
8000ffe0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ffe4:	40 66       	lddsp	r6,sp[0x18]
8000ffe6:	20 16       	sub	r6,1
8000ffe8:	58 06       	cp.w	r6,0
8000ffea:	e0 89 00 1d 	brgt	80010024 <_vfprintf_r+0x19dc>
8000ffee:	e0 8f 02 47 	bral	8001047c <_vfprintf_r+0x1e34>
8000fff2:	2f 09       	sub	r9,-16
8000fff4:	2f f8       	sub	r8,-1
8000fff6:	fb 49 06 90 	st.w	sp[1680],r9
8000fffa:	87 02       	st.w	r3[0x0],r2
8000fffc:	87 10       	st.w	r3[0x4],r0
8000fffe:	fb 48 06 8c 	st.w	sp[1676],r8
80010002:	58 78       	cp.w	r8,7
80010004:	e0 89 00 04 	brgt	8001000c <_vfprintf_r+0x19c4>
80010008:	2f 83       	sub	r3,-8
8001000a:	c0 b8       	rjmp	80010020 <_vfprintf_r+0x19d8>
8001000c:	fa ca f9 78 	sub	r10,sp,-1672
80010010:	02 9b       	mov	r11,r1
80010012:	08 9c       	mov	r12,r4
80010014:	fe b0 f3 0c 	rcall	8000e62c <__sprint_r>
80010018:	e0 81 02 9d 	brne	80010552 <_vfprintf_r+0x1f0a>
8001001c:	fa c3 f9 e0 	sub	r3,sp,-1568
80010020:	21 06       	sub	r6,16
80010022:	c0 48       	rjmp	8001002a <_vfprintf_r+0x19e2>
80010024:	fe c2 93 a0 	sub	r2,pc,-27744
80010028:	31 00       	mov	r0,16
8001002a:	fa f9 06 90 	ld.w	r9,sp[1680]
8001002e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80010032:	fe ca 93 ae 	sub	r10,pc,-27730
80010036:	59 06       	cp.w	r6,16
80010038:	fe 99 ff dd 	brgt	8000fff2 <_vfprintf_r+0x19aa>
8001003c:	0c 09       	add	r9,r6
8001003e:	87 0a       	st.w	r3[0x0],r10
80010040:	fb 49 06 90 	st.w	sp[1680],r9
80010044:	2f f8       	sub	r8,-1
80010046:	87 16       	st.w	r3[0x4],r6
80010048:	c5 39       	rjmp	800102ee <_vfprintf_r+0x1ca6>
8001004a:	fa fa 06 ac 	ld.w	r10,sp[1708]
8001004e:	58 0a       	cp.w	r10,0
80010050:	e0 89 00 92 	brgt	80010174 <_vfprintf_r+0x1b2c>
80010054:	fa f8 06 90 	ld.w	r8,sp[1680]
80010058:	fe c9 ae 94 	sub	r9,pc,-20844
8001005c:	2f f8       	sub	r8,-1
8001005e:	87 09       	st.w	r3[0x0],r9
80010060:	fb 48 06 90 	st.w	sp[1680],r8
80010064:	30 19       	mov	r9,1
80010066:	fa f8 06 8c 	ld.w	r8,sp[1676]
8001006a:	87 19       	st.w	r3[0x4],r9
8001006c:	2f f8       	sub	r8,-1
8001006e:	fb 48 06 8c 	st.w	sp[1676],r8
80010072:	58 78       	cp.w	r8,7
80010074:	e0 89 00 04 	brgt	8001007c <_vfprintf_r+0x1a34>
80010078:	2f 83       	sub	r3,-8
8001007a:	c0 b8       	rjmp	80010090 <_vfprintf_r+0x1a48>
8001007c:	fa ca f9 78 	sub	r10,sp,-1672
80010080:	02 9b       	mov	r11,r1
80010082:	08 9c       	mov	r12,r4
80010084:	fe b0 f2 d4 	rcall	8000e62c <__sprint_r>
80010088:	e0 81 02 65 	brne	80010552 <_vfprintf_r+0x1f0a>
8001008c:	fa c3 f9 e0 	sub	r3,sp,-1568
80010090:	fa f8 06 ac 	ld.w	r8,sp[1708]
80010094:	58 08       	cp.w	r8,0
80010096:	c0 81       	brne	800100a6 <_vfprintf_r+0x1a5e>
80010098:	40 6a       	lddsp	r10,sp[0x18]
8001009a:	58 0a       	cp.w	r10,0
8001009c:	c0 51       	brne	800100a6 <_vfprintf_r+0x1a5e>
8001009e:	ed b5 00 00 	bld	r5,0x0
800100a2:	e0 81 01 ed 	brne	8001047c <_vfprintf_r+0x1e34>
800100a6:	40 c9       	lddsp	r9,sp[0x30]
800100a8:	fa f8 06 90 	ld.w	r8,sp[1680]
800100ac:	2f f8       	sub	r8,-1
800100ae:	87 09       	st.w	r3[0x0],r9
800100b0:	fb 48 06 90 	st.w	sp[1680],r8
800100b4:	30 19       	mov	r9,1
800100b6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800100ba:	87 19       	st.w	r3[0x4],r9
800100bc:	2f f8       	sub	r8,-1
800100be:	fb 48 06 8c 	st.w	sp[1676],r8
800100c2:	58 78       	cp.w	r8,7
800100c4:	e0 89 00 04 	brgt	800100cc <_vfprintf_r+0x1a84>
800100c8:	2f 83       	sub	r3,-8
800100ca:	c0 b8       	rjmp	800100e0 <_vfprintf_r+0x1a98>
800100cc:	fa ca f9 78 	sub	r10,sp,-1672
800100d0:	02 9b       	mov	r11,r1
800100d2:	08 9c       	mov	r12,r4
800100d4:	fe b0 f2 ac 	rcall	8000e62c <__sprint_r>
800100d8:	e0 81 02 3d 	brne	80010552 <_vfprintf_r+0x1f0a>
800100dc:	fa c3 f9 e0 	sub	r3,sp,-1568
800100e0:	fa f2 06 ac 	ld.w	r2,sp[1708]
800100e4:	5c 32       	neg	r2
800100e6:	58 02       	cp.w	r2,0
800100e8:	e0 89 00 1d 	brgt	80010122 <_vfprintf_r+0x1ada>
800100ec:	c3 d8       	rjmp	80010166 <_vfprintf_r+0x1b1e>
800100ee:	2f 09       	sub	r9,-16
800100f0:	2f f8       	sub	r8,-1
800100f2:	31 0e       	mov	lr,16
800100f4:	fb 49 06 90 	st.w	sp[1680],r9
800100f8:	87 00       	st.w	r3[0x0],r0
800100fa:	87 1e       	st.w	r3[0x4],lr
800100fc:	fb 48 06 8c 	st.w	sp[1676],r8
80010100:	58 78       	cp.w	r8,7
80010102:	e0 89 00 04 	brgt	8001010a <_vfprintf_r+0x1ac2>
80010106:	2f 83       	sub	r3,-8
80010108:	c0 b8       	rjmp	8001011e <_vfprintf_r+0x1ad6>
8001010a:	fa ca f9 78 	sub	r10,sp,-1672
8001010e:	02 9b       	mov	r11,r1
80010110:	08 9c       	mov	r12,r4
80010112:	fe b0 f2 8d 	rcall	8000e62c <__sprint_r>
80010116:	e0 81 02 1e 	brne	80010552 <_vfprintf_r+0x1f0a>
8001011a:	fa c3 f9 e0 	sub	r3,sp,-1568
8001011e:	21 02       	sub	r2,16
80010120:	c0 38       	rjmp	80010126 <_vfprintf_r+0x1ade>
80010122:	fe c0 94 9e 	sub	r0,pc,-27490
80010126:	fa f9 06 90 	ld.w	r9,sp[1680]
8001012a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8001012e:	fe ca 94 aa 	sub	r10,pc,-27478
80010132:	59 02       	cp.w	r2,16
80010134:	fe 99 ff dd 	brgt	800100ee <_vfprintf_r+0x1aa6>
80010138:	04 09       	add	r9,r2
8001013a:	2f f8       	sub	r8,-1
8001013c:	87 0a       	st.w	r3[0x0],r10
8001013e:	fb 49 06 90 	st.w	sp[1680],r9
80010142:	87 12       	st.w	r3[0x4],r2
80010144:	fb 48 06 8c 	st.w	sp[1676],r8
80010148:	58 78       	cp.w	r8,7
8001014a:	e0 89 00 04 	brgt	80010152 <_vfprintf_r+0x1b0a>
8001014e:	2f 83       	sub	r3,-8
80010150:	c0 b8       	rjmp	80010166 <_vfprintf_r+0x1b1e>
80010152:	fa ca f9 78 	sub	r10,sp,-1672
80010156:	02 9b       	mov	r11,r1
80010158:	08 9c       	mov	r12,r4
8001015a:	fe b0 f2 69 	rcall	8000e62c <__sprint_r>
8001015e:	e0 81 01 fa 	brne	80010552 <_vfprintf_r+0x1f0a>
80010162:	fa c3 f9 e0 	sub	r3,sp,-1568
80010166:	40 6c       	lddsp	r12,sp[0x18]
80010168:	fa f8 06 90 	ld.w	r8,sp[1680]
8001016c:	87 06       	st.w	r3[0x0],r6
8001016e:	87 1c       	st.w	r3[0x4],r12
80010170:	18 08       	add	r8,r12
80010172:	cb 98       	rjmp	800102e4 <_vfprintf_r+0x1c9c>
80010174:	fa f9 06 90 	ld.w	r9,sp[1680]
80010178:	fa f8 06 8c 	ld.w	r8,sp[1676]
8001017c:	40 6b       	lddsp	r11,sp[0x18]
8001017e:	16 3a       	cp.w	r10,r11
80010180:	c6 f5       	brlt	8001025e <_vfprintf_r+0x1c16>
80010182:	16 09       	add	r9,r11
80010184:	2f f8       	sub	r8,-1
80010186:	87 06       	st.w	r3[0x0],r6
80010188:	fb 49 06 90 	st.w	sp[1680],r9
8001018c:	87 1b       	st.w	r3[0x4],r11
8001018e:	fb 48 06 8c 	st.w	sp[1676],r8
80010192:	58 78       	cp.w	r8,7
80010194:	e0 89 00 04 	brgt	8001019c <_vfprintf_r+0x1b54>
80010198:	2f 83       	sub	r3,-8
8001019a:	c0 b8       	rjmp	800101b0 <_vfprintf_r+0x1b68>
8001019c:	fa ca f9 78 	sub	r10,sp,-1672
800101a0:	02 9b       	mov	r11,r1
800101a2:	08 9c       	mov	r12,r4
800101a4:	fe b0 f2 44 	rcall	8000e62c <__sprint_r>
800101a8:	e0 81 01 d5 	brne	80010552 <_vfprintf_r+0x1f0a>
800101ac:	fa c3 f9 e0 	sub	r3,sp,-1568
800101b0:	fa f6 06 ac 	ld.w	r6,sp[1708]
800101b4:	40 6a       	lddsp	r10,sp[0x18]
800101b6:	14 16       	sub	r6,r10
800101b8:	58 06       	cp.w	r6,0
800101ba:	e0 89 00 1c 	brgt	800101f2 <_vfprintf_r+0x1baa>
800101be:	c3 d8       	rjmp	80010238 <_vfprintf_r+0x1bf0>
800101c0:	2f 09       	sub	r9,-16
800101c2:	2f f8       	sub	r8,-1
800101c4:	fb 49 06 90 	st.w	sp[1680],r9
800101c8:	87 02       	st.w	r3[0x0],r2
800101ca:	87 10       	st.w	r3[0x4],r0
800101cc:	fb 48 06 8c 	st.w	sp[1676],r8
800101d0:	58 78       	cp.w	r8,7
800101d2:	e0 89 00 04 	brgt	800101da <_vfprintf_r+0x1b92>
800101d6:	2f 83       	sub	r3,-8
800101d8:	c0 b8       	rjmp	800101ee <_vfprintf_r+0x1ba6>
800101da:	fa ca f9 78 	sub	r10,sp,-1672
800101de:	02 9b       	mov	r11,r1
800101e0:	08 9c       	mov	r12,r4
800101e2:	fe b0 f2 25 	rcall	8000e62c <__sprint_r>
800101e6:	e0 81 01 b6 	brne	80010552 <_vfprintf_r+0x1f0a>
800101ea:	fa c3 f9 e0 	sub	r3,sp,-1568
800101ee:	21 06       	sub	r6,16
800101f0:	c0 48       	rjmp	800101f8 <_vfprintf_r+0x1bb0>
800101f2:	fe c2 95 6e 	sub	r2,pc,-27282
800101f6:	31 00       	mov	r0,16
800101f8:	fa f9 06 90 	ld.w	r9,sp[1680]
800101fc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80010200:	fe ca 95 7c 	sub	r10,pc,-27268
80010204:	59 06       	cp.w	r6,16
80010206:	fe 99 ff dd 	brgt	800101c0 <_vfprintf_r+0x1b78>
8001020a:	0c 09       	add	r9,r6
8001020c:	2f f8       	sub	r8,-1
8001020e:	87 0a       	st.w	r3[0x0],r10
80010210:	fb 49 06 90 	st.w	sp[1680],r9
80010214:	87 16       	st.w	r3[0x4],r6
80010216:	fb 48 06 8c 	st.w	sp[1676],r8
8001021a:	58 78       	cp.w	r8,7
8001021c:	e0 89 00 04 	brgt	80010224 <_vfprintf_r+0x1bdc>
80010220:	2f 83       	sub	r3,-8
80010222:	c0 b8       	rjmp	80010238 <_vfprintf_r+0x1bf0>
80010224:	fa ca f9 78 	sub	r10,sp,-1672
80010228:	02 9b       	mov	r11,r1
8001022a:	08 9c       	mov	r12,r4
8001022c:	fe b0 f2 00 	rcall	8000e62c <__sprint_r>
80010230:	e0 81 01 91 	brne	80010552 <_vfprintf_r+0x1f0a>
80010234:	fa c3 f9 e0 	sub	r3,sp,-1568
80010238:	ed b5 00 00 	bld	r5,0x0
8001023c:	e0 81 01 20 	brne	8001047c <_vfprintf_r+0x1e34>
80010240:	40 c9       	lddsp	r9,sp[0x30]
80010242:	fa f8 06 90 	ld.w	r8,sp[1680]
80010246:	2f f8       	sub	r8,-1
80010248:	87 09       	st.w	r3[0x0],r9
8001024a:	fb 48 06 90 	st.w	sp[1680],r8
8001024e:	30 19       	mov	r9,1
80010250:	fa f8 06 8c 	ld.w	r8,sp[1676]
80010254:	87 19       	st.w	r3[0x4],r9
80010256:	2f f8       	sub	r8,-1
80010258:	fb 48 06 8c 	st.w	sp[1676],r8
8001025c:	c0 29       	rjmp	80010460 <_vfprintf_r+0x1e18>
8001025e:	14 09       	add	r9,r10
80010260:	2f f8       	sub	r8,-1
80010262:	fb 49 06 90 	st.w	sp[1680],r9
80010266:	87 06       	st.w	r3[0x0],r6
80010268:	87 1a       	st.w	r3[0x4],r10
8001026a:	fb 48 06 8c 	st.w	sp[1676],r8
8001026e:	58 78       	cp.w	r8,7
80010270:	e0 89 00 04 	brgt	80010278 <_vfprintf_r+0x1c30>
80010274:	2f 83       	sub	r3,-8
80010276:	c0 b8       	rjmp	8001028c <_vfprintf_r+0x1c44>
80010278:	fa ca f9 78 	sub	r10,sp,-1672
8001027c:	02 9b       	mov	r11,r1
8001027e:	08 9c       	mov	r12,r4
80010280:	fe b0 f1 d6 	rcall	8000e62c <__sprint_r>
80010284:	e0 81 01 67 	brne	80010552 <_vfprintf_r+0x1f0a>
80010288:	fa c3 f9 e0 	sub	r3,sp,-1568
8001028c:	40 c8       	lddsp	r8,sp[0x30]
8001028e:	87 08       	st.w	r3[0x0],r8
80010290:	fa f8 06 90 	ld.w	r8,sp[1680]
80010294:	2f f8       	sub	r8,-1
80010296:	30 19       	mov	r9,1
80010298:	fb 48 06 90 	st.w	sp[1680],r8
8001029c:	87 19       	st.w	r3[0x4],r9
8001029e:	fa f8 06 8c 	ld.w	r8,sp[1676]
800102a2:	2f f8       	sub	r8,-1
800102a4:	fb 48 06 8c 	st.w	sp[1676],r8
800102a8:	fa f2 06 ac 	ld.w	r2,sp[1708]
800102ac:	58 78       	cp.w	r8,7
800102ae:	e0 89 00 04 	brgt	800102b6 <_vfprintf_r+0x1c6e>
800102b2:	2f 83       	sub	r3,-8
800102b4:	c0 b8       	rjmp	800102ca <_vfprintf_r+0x1c82>
800102b6:	fa ca f9 78 	sub	r10,sp,-1672
800102ba:	02 9b       	mov	r11,r1
800102bc:	08 9c       	mov	r12,r4
800102be:	fe b0 f1 b7 	rcall	8000e62c <__sprint_r>
800102c2:	e0 81 01 48 	brne	80010552 <_vfprintf_r+0x1f0a>
800102c6:	fa c3 f9 e0 	sub	r3,sp,-1568
800102ca:	04 06       	add	r6,r2
800102cc:	fa f8 06 ac 	ld.w	r8,sp[1708]
800102d0:	87 06       	st.w	r3[0x0],r6
800102d2:	fa f9 06 90 	ld.w	r9,sp[1680]
800102d6:	40 66       	lddsp	r6,sp[0x18]
800102d8:	40 6e       	lddsp	lr,sp[0x18]
800102da:	10 16       	sub	r6,r8
800102dc:	f2 08 01 08 	sub	r8,r9,r8
800102e0:	87 16       	st.w	r3[0x4],r6
800102e2:	1c 08       	add	r8,lr
800102e4:	fb 48 06 90 	st.w	sp[1680],r8
800102e8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800102ec:	2f f8       	sub	r8,-1
800102ee:	fb 48 06 8c 	st.w	sp[1676],r8
800102f2:	cb 78       	rjmp	80010460 <_vfprintf_r+0x1e18>
800102f4:	40 6c       	lddsp	r12,sp[0x18]
800102f6:	58 1c       	cp.w	r12,1
800102f8:	e0 89 00 06 	brgt	80010304 <_vfprintf_r+0x1cbc>
800102fc:	ed b5 00 00 	bld	r5,0x0
80010300:	e0 81 00 85 	brne	8001040a <_vfprintf_r+0x1dc2>
80010304:	fa f8 06 90 	ld.w	r8,sp[1680]
80010308:	2f f8       	sub	r8,-1
8001030a:	30 19       	mov	r9,1
8001030c:	fb 48 06 90 	st.w	sp[1680],r8
80010310:	87 06       	st.w	r3[0x0],r6
80010312:	fa f8 06 8c 	ld.w	r8,sp[1676]
80010316:	87 19       	st.w	r3[0x4],r9
80010318:	2f f8       	sub	r8,-1
8001031a:	fb 48 06 8c 	st.w	sp[1676],r8
8001031e:	58 78       	cp.w	r8,7
80010320:	e0 89 00 04 	brgt	80010328 <_vfprintf_r+0x1ce0>
80010324:	2f 83       	sub	r3,-8
80010326:	c0 b8       	rjmp	8001033c <_vfprintf_r+0x1cf4>
80010328:	fa ca f9 78 	sub	r10,sp,-1672
8001032c:	02 9b       	mov	r11,r1
8001032e:	08 9c       	mov	r12,r4
80010330:	fe b0 f1 7e 	rcall	8000e62c <__sprint_r>
80010334:	e0 81 01 0f 	brne	80010552 <_vfprintf_r+0x1f0a>
80010338:	fa c3 f9 e0 	sub	r3,sp,-1568
8001033c:	fa f8 06 90 	ld.w	r8,sp[1680]
80010340:	2f f8       	sub	r8,-1
80010342:	40 cb       	lddsp	r11,sp[0x30]
80010344:	fb 48 06 90 	st.w	sp[1680],r8
80010348:	30 19       	mov	r9,1
8001034a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8001034e:	87 0b       	st.w	r3[0x0],r11
80010350:	2f f8       	sub	r8,-1
80010352:	87 19       	st.w	r3[0x4],r9
80010354:	fb 48 06 8c 	st.w	sp[1676],r8
80010358:	58 78       	cp.w	r8,7
8001035a:	e0 89 00 05 	brgt	80010364 <_vfprintf_r+0x1d1c>
8001035e:	2f 83       	sub	r3,-8
80010360:	c0 c8       	rjmp	80010378 <_vfprintf_r+0x1d30>
80010362:	d7 03       	nop
80010364:	fa ca f9 78 	sub	r10,sp,-1672
80010368:	02 9b       	mov	r11,r1
8001036a:	08 9c       	mov	r12,r4
8001036c:	fe b0 f1 60 	rcall	8000e62c <__sprint_r>
80010370:	e0 81 00 f1 	brne	80010552 <_vfprintf_r+0x1f0a>
80010374:	fa c3 f9 e0 	sub	r3,sp,-1568
80010378:	30 08       	mov	r8,0
8001037a:	30 09       	mov	r9,0
8001037c:	40 5b       	lddsp	r11,sp[0x14]
8001037e:	40 7a       	lddsp	r10,sp[0x1c]
80010380:	e0 a0 12 06 	rcall	8001278c <__avr32_f64_cmp_eq>
80010384:	40 68       	lddsp	r8,sp[0x18]
80010386:	20 18       	sub	r8,1
80010388:	58 0c       	cp.w	r12,0
8001038a:	c0 d1       	brne	800103a4 <_vfprintf_r+0x1d5c>
8001038c:	2f f6       	sub	r6,-1
8001038e:	87 18       	st.w	r3[0x4],r8
80010390:	87 06       	st.w	r3[0x0],r6
80010392:	fa f6 06 90 	ld.w	r6,sp[1680]
80010396:	10 06       	add	r6,r8
80010398:	fa f8 06 8c 	ld.w	r8,sp[1676]
8001039c:	fb 46 06 90 	st.w	sp[1680],r6
800103a0:	2f f8       	sub	r8,-1
800103a2:	c3 18       	rjmp	80010404 <_vfprintf_r+0x1dbc>
800103a4:	10 96       	mov	r6,r8
800103a6:	58 08       	cp.w	r8,0
800103a8:	e0 89 00 1c 	brgt	800103e0 <_vfprintf_r+0x1d98>
800103ac:	c4 b8       	rjmp	80010442 <_vfprintf_r+0x1dfa>
800103ae:	2f 09       	sub	r9,-16
800103b0:	2f f8       	sub	r8,-1
800103b2:	fb 49 06 90 	st.w	sp[1680],r9
800103b6:	87 02       	st.w	r3[0x0],r2
800103b8:	87 10       	st.w	r3[0x4],r0
800103ba:	fb 48 06 8c 	st.w	sp[1676],r8
800103be:	58 78       	cp.w	r8,7
800103c0:	e0 89 00 04 	brgt	800103c8 <_vfprintf_r+0x1d80>
800103c4:	2f 83       	sub	r3,-8
800103c6:	c0 b8       	rjmp	800103dc <_vfprintf_r+0x1d94>
800103c8:	fa ca f9 78 	sub	r10,sp,-1672
800103cc:	02 9b       	mov	r11,r1
800103ce:	08 9c       	mov	r12,r4
800103d0:	fe b0 f1 2e 	rcall	8000e62c <__sprint_r>
800103d4:	e0 81 00 bf 	brne	80010552 <_vfprintf_r+0x1f0a>
800103d8:	fa c3 f9 e0 	sub	r3,sp,-1568
800103dc:	21 06       	sub	r6,16
800103de:	c0 48       	rjmp	800103e6 <_vfprintf_r+0x1d9e>
800103e0:	fe c2 97 5c 	sub	r2,pc,-26788
800103e4:	31 00       	mov	r0,16
800103e6:	fa f9 06 90 	ld.w	r9,sp[1680]
800103ea:	fa f8 06 8c 	ld.w	r8,sp[1676]
800103ee:	fe ca 97 6a 	sub	r10,pc,-26774
800103f2:	59 06       	cp.w	r6,16
800103f4:	fe 99 ff dd 	brgt	800103ae <_vfprintf_r+0x1d66>
800103f8:	0c 09       	add	r9,r6
800103fa:	87 0a       	st.w	r3[0x0],r10
800103fc:	fb 49 06 90 	st.w	sp[1680],r9
80010400:	2f f8       	sub	r8,-1
80010402:	87 16       	st.w	r3[0x4],r6
80010404:	fb 48 06 8c 	st.w	sp[1676],r8
80010408:	c0 e8       	rjmp	80010424 <_vfprintf_r+0x1ddc>
8001040a:	fa f8 06 90 	ld.w	r8,sp[1680]
8001040e:	2f f8       	sub	r8,-1
80010410:	30 19       	mov	r9,1
80010412:	fb 48 06 90 	st.w	sp[1680],r8
80010416:	87 06       	st.w	r3[0x0],r6
80010418:	fa f8 06 8c 	ld.w	r8,sp[1676]
8001041c:	87 19       	st.w	r3[0x4],r9
8001041e:	2f f8       	sub	r8,-1
80010420:	fb 48 06 8c 	st.w	sp[1676],r8
80010424:	58 78       	cp.w	r8,7
80010426:	e0 89 00 04 	brgt	8001042e <_vfprintf_r+0x1de6>
8001042a:	2f 83       	sub	r3,-8
8001042c:	c0 b8       	rjmp	80010442 <_vfprintf_r+0x1dfa>
8001042e:	fa ca f9 78 	sub	r10,sp,-1672
80010432:	02 9b       	mov	r11,r1
80010434:	08 9c       	mov	r12,r4
80010436:	fe b0 f0 fb 	rcall	8000e62c <__sprint_r>
8001043a:	e0 81 00 8c 	brne	80010552 <_vfprintf_r+0x1f0a>
8001043e:	fa c3 f9 e0 	sub	r3,sp,-1568
80010442:	40 ea       	lddsp	r10,sp[0x38]
80010444:	fa f8 06 90 	ld.w	r8,sp[1680]
80010448:	14 08       	add	r8,r10
8001044a:	fa c9 f9 64 	sub	r9,sp,-1692
8001044e:	fb 48 06 90 	st.w	sp[1680],r8
80010452:	87 1a       	st.w	r3[0x4],r10
80010454:	fa f8 06 8c 	ld.w	r8,sp[1676]
80010458:	87 09       	st.w	r3[0x0],r9
8001045a:	2f f8       	sub	r8,-1
8001045c:	fb 48 06 8c 	st.w	sp[1676],r8
80010460:	58 78       	cp.w	r8,7
80010462:	e0 89 00 04 	brgt	8001046a <_vfprintf_r+0x1e22>
80010466:	2f 83       	sub	r3,-8
80010468:	c0 a8       	rjmp	8001047c <_vfprintf_r+0x1e34>
8001046a:	fa ca f9 78 	sub	r10,sp,-1672
8001046e:	02 9b       	mov	r11,r1
80010470:	08 9c       	mov	r12,r4
80010472:	fe b0 f0 dd 	rcall	8000e62c <__sprint_r>
80010476:	c6 e1       	brne	80010552 <_vfprintf_r+0x1f0a>
80010478:	fa c3 f9 e0 	sub	r3,sp,-1568
8001047c:	e2 15 00 04 	andl	r5,0x4,COH
80010480:	c3 f0       	breq	800104fe <_vfprintf_r+0x1eb6>
80010482:	40 86       	lddsp	r6,sp[0x20]
80010484:	40 39       	lddsp	r9,sp[0xc]
80010486:	12 16       	sub	r6,r9
80010488:	58 06       	cp.w	r6,0
8001048a:	e0 89 00 1a 	brgt	800104be <_vfprintf_r+0x1e76>
8001048e:	c3 88       	rjmp	800104fe <_vfprintf_r+0x1eb6>
80010490:	2f 09       	sub	r9,-16
80010492:	2f f8       	sub	r8,-1
80010494:	fb 49 06 90 	st.w	sp[1680],r9
80010498:	87 05       	st.w	r3[0x0],r5
8001049a:	87 12       	st.w	r3[0x4],r2
8001049c:	fb 48 06 8c 	st.w	sp[1676],r8
800104a0:	58 78       	cp.w	r8,7
800104a2:	e0 89 00 04 	brgt	800104aa <_vfprintf_r+0x1e62>
800104a6:	2f 83       	sub	r3,-8
800104a8:	c0 98       	rjmp	800104ba <_vfprintf_r+0x1e72>
800104aa:	00 9a       	mov	r10,r0
800104ac:	02 9b       	mov	r11,r1
800104ae:	08 9c       	mov	r12,r4
800104b0:	fe b0 f0 be 	rcall	8000e62c <__sprint_r>
800104b4:	c4 f1       	brne	80010552 <_vfprintf_r+0x1f0a>
800104b6:	fa c3 f9 e0 	sub	r3,sp,-1568
800104ba:	21 06       	sub	r6,16
800104bc:	c0 68       	rjmp	800104c8 <_vfprintf_r+0x1e80>
800104be:	fe c5 98 4a 	sub	r5,pc,-26550
800104c2:	31 02       	mov	r2,16
800104c4:	fa c0 f9 78 	sub	r0,sp,-1672
800104c8:	fa f9 06 90 	ld.w	r9,sp[1680]
800104cc:	fa f8 06 8c 	ld.w	r8,sp[1676]
800104d0:	fe ca 98 5c 	sub	r10,pc,-26532
800104d4:	59 06       	cp.w	r6,16
800104d6:	fe 99 ff dd 	brgt	80010490 <_vfprintf_r+0x1e48>
800104da:	0c 09       	add	r9,r6
800104dc:	2f f8       	sub	r8,-1
800104de:	87 0a       	st.w	r3[0x0],r10
800104e0:	87 16       	st.w	r3[0x4],r6
800104e2:	fb 49 06 90 	st.w	sp[1680],r9
800104e6:	fb 48 06 8c 	st.w	sp[1676],r8
800104ea:	58 78       	cp.w	r8,7
800104ec:	e0 8a 00 09 	brle	800104fe <_vfprintf_r+0x1eb6>
800104f0:	fa ca f9 78 	sub	r10,sp,-1672
800104f4:	02 9b       	mov	r11,r1
800104f6:	08 9c       	mov	r12,r4
800104f8:	fe b0 f0 9a 	rcall	8000e62c <__sprint_r>
800104fc:	c2 b1       	brne	80010552 <_vfprintf_r+0x1f0a>
800104fe:	40 bc       	lddsp	r12,sp[0x2c]
80010500:	40 36       	lddsp	r6,sp[0xc]
80010502:	40 8e       	lddsp	lr,sp[0x20]
80010504:	ec 0e 0c 48 	max	r8,r6,lr
80010508:	10 0c       	add	r12,r8
8001050a:	50 bc       	stdsp	sp[0x2c],r12
8001050c:	fa f8 06 90 	ld.w	r8,sp[1680]
80010510:	58 08       	cp.w	r8,0
80010512:	c0 80       	breq	80010522 <_vfprintf_r+0x1eda>
80010514:	fa ca f9 78 	sub	r10,sp,-1672
80010518:	02 9b       	mov	r11,r1
8001051a:	08 9c       	mov	r12,r4
8001051c:	fe b0 f0 88 	rcall	8000e62c <__sprint_r>
80010520:	c1 91       	brne	80010552 <_vfprintf_r+0x1f0a>
80010522:	30 0b       	mov	r11,0
80010524:	fa c3 f9 e0 	sub	r3,sp,-1568
80010528:	fb 4b 06 8c 	st.w	sp[1676],r11
8001052c:	fe 9f f1 19 	bral	8000e75e <_vfprintf_r+0x116>
80010530:	08 95       	mov	r5,r4
80010532:	fa f8 06 90 	ld.w	r8,sp[1680]
80010536:	58 08       	cp.w	r8,0
80010538:	c0 80       	breq	80010548 <_vfprintf_r+0x1f00>
8001053a:	08 9c       	mov	r12,r4
8001053c:	fa ca f9 78 	sub	r10,sp,-1672
80010540:	02 9b       	mov	r11,r1
80010542:	fe b0 f0 75 	rcall	8000e62c <__sprint_r>
80010546:	c0 61       	brne	80010552 <_vfprintf_r+0x1f0a>
80010548:	30 08       	mov	r8,0
8001054a:	fb 48 06 8c 	st.w	sp[1676],r8
8001054e:	c0 28       	rjmp	80010552 <_vfprintf_r+0x1f0a>
80010550:	40 41       	lddsp	r1,sp[0x10]
80010552:	82 68       	ld.sh	r8,r1[0xc]
80010554:	ed b8 00 06 	bld	r8,0x6
80010558:	c0 31       	brne	8001055e <_vfprintf_r+0x1f16>
8001055a:	3f fa       	mov	r10,-1
8001055c:	50 ba       	stdsp	sp[0x2c],r10
8001055e:	40 bc       	lddsp	r12,sp[0x2c]
80010560:	fe 3d f9 44 	sub	sp,-1724
80010564:	d8 32       	popm	r0-r7,pc
80010566:	d7 03       	nop

80010568 <__swsetup_r>:
80010568:	d4 21       	pushm	r4-r7,lr
8001056a:	e0 68 02 2c 	mov	r8,556
8001056e:	18 96       	mov	r6,r12
80010570:	16 97       	mov	r7,r11
80010572:	70 0c       	ld.w	r12,r8[0x0]
80010574:	58 0c       	cp.w	r12,0
80010576:	c0 60       	breq	80010582 <__swsetup_r+0x1a>
80010578:	78 68       	ld.w	r8,r12[0x18]
8001057a:	58 08       	cp.w	r8,0
8001057c:	c0 31       	brne	80010582 <__swsetup_r+0x1a>
8001057e:	e0 a0 07 c7 	rcall	8001150c <__sinit>
80010582:	fe c8 97 de 	sub	r8,pc,-26658
80010586:	10 37       	cp.w	r7,r8
80010588:	c0 61       	brne	80010594 <__swsetup_r+0x2c>
8001058a:	e0 68 02 2c 	mov	r8,556
8001058e:	70 08       	ld.w	r8,r8[0x0]
80010590:	70 07       	ld.w	r7,r8[0x0]
80010592:	c1 28       	rjmp	800105b6 <__swsetup_r+0x4e>
80010594:	fe c8 97 d0 	sub	r8,pc,-26672
80010598:	10 37       	cp.w	r7,r8
8001059a:	c0 61       	brne	800105a6 <__swsetup_r+0x3e>
8001059c:	e0 68 02 2c 	mov	r8,556
800105a0:	70 08       	ld.w	r8,r8[0x0]
800105a2:	70 17       	ld.w	r7,r8[0x4]
800105a4:	c0 98       	rjmp	800105b6 <__swsetup_r+0x4e>
800105a6:	fe c8 97 c2 	sub	r8,pc,-26686
800105aa:	10 37       	cp.w	r7,r8
800105ac:	c0 51       	brne	800105b6 <__swsetup_r+0x4e>
800105ae:	e0 68 02 2c 	mov	r8,556
800105b2:	70 08       	ld.w	r8,r8[0x0]
800105b4:	70 27       	ld.w	r7,r8[0x8]
800105b6:	8e 68       	ld.sh	r8,r7[0xc]
800105b8:	ed b8 00 03 	bld	r8,0x3
800105bc:	c1 e0       	breq	800105f8 <__swsetup_r+0x90>
800105be:	ed b8 00 04 	bld	r8,0x4
800105c2:	c3 e1       	brne	8001063e <__swsetup_r+0xd6>
800105c4:	ed b8 00 02 	bld	r8,0x2
800105c8:	c1 51       	brne	800105f2 <__swsetup_r+0x8a>
800105ca:	6e db       	ld.w	r11,r7[0x34]
800105cc:	58 0b       	cp.w	r11,0
800105ce:	c0 a0       	breq	800105e2 <__swsetup_r+0x7a>
800105d0:	ee c8 ff bc 	sub	r8,r7,-68
800105d4:	10 3b       	cp.w	r11,r8
800105d6:	c0 40       	breq	800105de <__swsetup_r+0x76>
800105d8:	0c 9c       	mov	r12,r6
800105da:	e0 a0 08 33 	rcall	80011640 <_free_r>
800105de:	30 08       	mov	r8,0
800105e0:	8f d8       	st.w	r7[0x34],r8
800105e2:	8e 68       	ld.sh	r8,r7[0xc]
800105e4:	e0 18 ff db 	andl	r8,0xffdb
800105e8:	ae 68       	st.h	r7[0xc],r8
800105ea:	30 08       	mov	r8,0
800105ec:	8f 18       	st.w	r7[0x4],r8
800105ee:	6e 48       	ld.w	r8,r7[0x10]
800105f0:	8f 08       	st.w	r7[0x0],r8
800105f2:	8e 68       	ld.sh	r8,r7[0xc]
800105f4:	a3 b8       	sbr	r8,0x3
800105f6:	ae 68       	st.h	r7[0xc],r8
800105f8:	6e 48       	ld.w	r8,r7[0x10]
800105fa:	58 08       	cp.w	r8,0
800105fc:	c0 b1       	brne	80010612 <__swsetup_r+0xaa>
800105fe:	8e 68       	ld.sh	r8,r7[0xc]
80010600:	e2 18 02 80 	andl	r8,0x280,COH
80010604:	e0 48 02 00 	cp.w	r8,512
80010608:	c0 50       	breq	80010612 <__swsetup_r+0xaa>
8001060a:	0c 9c       	mov	r12,r6
8001060c:	0e 9b       	mov	r11,r7
8001060e:	e0 a0 0a 53 	rcall	80011ab4 <__smakebuf_r>
80010612:	8e 69       	ld.sh	r9,r7[0xc]
80010614:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80010618:	c0 70       	breq	80010626 <__swsetup_r+0xbe>
8001061a:	30 08       	mov	r8,0
8001061c:	8f 28       	st.w	r7[0x8],r8
8001061e:	6e 58       	ld.w	r8,r7[0x14]
80010620:	5c 38       	neg	r8
80010622:	8f 68       	st.w	r7[0x18],r8
80010624:	c0 68       	rjmp	80010630 <__swsetup_r+0xc8>
80010626:	ed b9 00 01 	bld	r9,0x1
8001062a:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8001062e:	8f 28       	st.w	r7[0x8],r8
80010630:	6e 48       	ld.w	r8,r7[0x10]
80010632:	58 08       	cp.w	r8,0
80010634:	c0 61       	brne	80010640 <__swsetup_r+0xd8>
80010636:	8e 68       	ld.sh	r8,r7[0xc]
80010638:	ed b8 00 07 	bld	r8,0x7
8001063c:	c0 21       	brne	80010640 <__swsetup_r+0xd8>
8001063e:	dc 2a       	popm	r4-r7,pc,r12=-1
80010640:	d8 2a       	popm	r4-r7,pc,r12=0
80010642:	d7 03       	nop

80010644 <abort>:
80010644:	d4 01       	pushm	lr
80010646:	30 6c       	mov	r12,6
80010648:	e0 a0 0f 52 	rcall	800124ec <raise>
8001064c:	30 1c       	mov	r12,1
8001064e:	fe b0 e0 e7 	rcall	8000c81c <_exit>
80010652:	d7 03       	nop

80010654 <quorem>:
80010654:	d4 31       	pushm	r0-r7,lr
80010656:	20 2d       	sub	sp,8
80010658:	18 97       	mov	r7,r12
8001065a:	78 48       	ld.w	r8,r12[0x10]
8001065c:	76 46       	ld.w	r6,r11[0x10]
8001065e:	0c 38       	cp.w	r8,r6
80010660:	c0 34       	brge	80010666 <quorem+0x12>
80010662:	30 0c       	mov	r12,0
80010664:	c8 58       	rjmp	8001076e <quorem+0x11a>
80010666:	ec c2 ff fc 	sub	r2,r6,-4
8001066a:	f6 c3 ff ec 	sub	r3,r11,-20
8001066e:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80010672:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80010676:	2f f9       	sub	r9,-1
80010678:	20 16       	sub	r6,1
8001067a:	f8 09 0d 08 	divu	r8,r12,r9
8001067e:	f6 02 00 22 	add	r2,r11,r2<<0x2
80010682:	ee c4 ff ec 	sub	r4,r7,-20
80010686:	10 95       	mov	r5,r8
80010688:	58 08       	cp.w	r8,0
8001068a:	c4 10       	breq	8001070c <quorem+0xb8>
8001068c:	30 09       	mov	r9,0
8001068e:	06 9a       	mov	r10,r3
80010690:	08 98       	mov	r8,r4
80010692:	12 91       	mov	r1,r9
80010694:	50 0b       	stdsp	sp[0x0],r11
80010696:	70 0e       	ld.w	lr,r8[0x0]
80010698:	b1 8e       	lsr	lr,0x10
8001069a:	50 1e       	stdsp	sp[0x4],lr
8001069c:	15 0e       	ld.w	lr,r10++
8001069e:	fc 00 16 10 	lsr	r0,lr,0x10
800106a2:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
800106a6:	ea 0e 03 41 	mac	r1,r5,lr
800106aa:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
800106ae:	b1 81       	lsr	r1,0x10
800106b0:	40 1b       	lddsp	r11,sp[0x4]
800106b2:	ea 00 02 40 	mul	r0,r5,r0
800106b6:	e2 00 00 00 	add	r0,r1,r0
800106ba:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
800106be:	02 1b       	sub	r11,r1
800106c0:	50 1b       	stdsp	sp[0x4],r11
800106c2:	70 0b       	ld.w	r11,r8[0x0]
800106c4:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
800106c8:	02 09       	add	r9,r1
800106ca:	f2 0e 01 0e 	sub	lr,r9,lr
800106ce:	b0 1e       	st.h	r8[0x2],lr
800106d0:	fc 09 14 10 	asr	r9,lr,0x10
800106d4:	40 1e       	lddsp	lr,sp[0x4]
800106d6:	fc 09 00 09 	add	r9,lr,r9
800106da:	b0 09       	st.h	r8[0x0],r9
800106dc:	e0 01 16 10 	lsr	r1,r0,0x10
800106e0:	2f c8       	sub	r8,-4
800106e2:	b1 49       	asr	r9,0x10
800106e4:	04 3a       	cp.w	r10,r2
800106e6:	fe 98 ff d8 	brls	80010696 <quorem+0x42>
800106ea:	40 0b       	lddsp	r11,sp[0x0]
800106ec:	58 0c       	cp.w	r12,0
800106ee:	c0 f1       	brne	8001070c <quorem+0xb8>
800106f0:	ec c8 ff fb 	sub	r8,r6,-5
800106f4:	ee 08 00 28 	add	r8,r7,r8<<0x2
800106f8:	c0 28       	rjmp	800106fc <quorem+0xa8>
800106fa:	20 16       	sub	r6,1
800106fc:	20 48       	sub	r8,4
800106fe:	08 38       	cp.w	r8,r4
80010700:	e0 88 00 05 	brls	8001070a <quorem+0xb6>
80010704:	70 09       	ld.w	r9,r8[0x0]
80010706:	58 09       	cp.w	r9,0
80010708:	cf 90       	breq	800106fa <quorem+0xa6>
8001070a:	8f 46       	st.w	r7[0x10],r6
8001070c:	0e 9c       	mov	r12,r7
8001070e:	e0 a0 0a d2 	rcall	80011cb2 <__mcmp>
80010712:	c2 d5       	brlt	8001076c <quorem+0x118>
80010714:	2f f5       	sub	r5,-1
80010716:	08 98       	mov	r8,r4
80010718:	30 09       	mov	r9,0
8001071a:	07 0b       	ld.w	r11,r3++
8001071c:	f6 0a 16 10 	lsr	r10,r11,0x10
80010720:	70 0c       	ld.w	r12,r8[0x0]
80010722:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80010726:	f8 0e 16 10 	lsr	lr,r12,0x10
8001072a:	14 1e       	sub	lr,r10
8001072c:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80010730:	16 1a       	sub	r10,r11
80010732:	12 0a       	add	r10,r9
80010734:	b0 1a       	st.h	r8[0x2],r10
80010736:	b1 4a       	asr	r10,0x10
80010738:	fc 0a 00 09 	add	r9,lr,r10
8001073c:	b0 09       	st.h	r8[0x0],r9
8001073e:	2f c8       	sub	r8,-4
80010740:	b1 49       	asr	r9,0x10
80010742:	04 33       	cp.w	r3,r2
80010744:	fe 98 ff eb 	brls	8001071a <quorem+0xc6>
80010748:	ec c8 ff fb 	sub	r8,r6,-5
8001074c:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80010750:	58 09       	cp.w	r9,0
80010752:	c0 d1       	brne	8001076c <quorem+0x118>
80010754:	ee 08 00 28 	add	r8,r7,r8<<0x2
80010758:	c0 28       	rjmp	8001075c <quorem+0x108>
8001075a:	20 16       	sub	r6,1
8001075c:	20 48       	sub	r8,4
8001075e:	08 38       	cp.w	r8,r4
80010760:	e0 88 00 05 	brls	8001076a <quorem+0x116>
80010764:	70 09       	ld.w	r9,r8[0x0]
80010766:	58 09       	cp.w	r9,0
80010768:	cf 90       	breq	8001075a <quorem+0x106>
8001076a:	8f 46       	st.w	r7[0x10],r6
8001076c:	0a 9c       	mov	r12,r5
8001076e:	2f ed       	sub	sp,-8
80010770:	d8 32       	popm	r0-r7,pc
80010772:	d7 03       	nop

80010774 <_dtoa_r>:
80010774:	d4 31       	pushm	r0-r7,lr
80010776:	21 ad       	sub	sp,104
80010778:	fa c4 ff 74 	sub	r4,sp,-140
8001077c:	18 97       	mov	r7,r12
8001077e:	16 95       	mov	r5,r11
80010780:	68 2c       	ld.w	r12,r4[0x8]
80010782:	50 c9       	stdsp	sp[0x30],r9
80010784:	68 16       	ld.w	r6,r4[0x4]
80010786:	68 09       	ld.w	r9,r4[0x0]
80010788:	50 e8       	stdsp	sp[0x38],r8
8001078a:	14 94       	mov	r4,r10
8001078c:	51 2c       	stdsp	sp[0x48],r12
8001078e:	fa e5 00 08 	st.d	sp[8],r4
80010792:	51 59       	stdsp	sp[0x54],r9
80010794:	6e 95       	ld.w	r5,r7[0x24]
80010796:	58 05       	cp.w	r5,0
80010798:	c0 91       	brne	800107aa <_dtoa_r+0x36>
8001079a:	31 0c       	mov	r12,16
8001079c:	fe b0 dd 30 	rcall	8000c1fc <malloc>
800107a0:	99 35       	st.w	r12[0xc],r5
800107a2:	8f 9c       	st.w	r7[0x24],r12
800107a4:	99 15       	st.w	r12[0x4],r5
800107a6:	99 25       	st.w	r12[0x8],r5
800107a8:	99 05       	st.w	r12[0x0],r5
800107aa:	6e 99       	ld.w	r9,r7[0x24]
800107ac:	72 08       	ld.w	r8,r9[0x0]
800107ae:	58 08       	cp.w	r8,0
800107b0:	c0 f0       	breq	800107ce <_dtoa_r+0x5a>
800107b2:	72 1a       	ld.w	r10,r9[0x4]
800107b4:	91 1a       	st.w	r8[0x4],r10
800107b6:	30 1a       	mov	r10,1
800107b8:	72 19       	ld.w	r9,r9[0x4]
800107ba:	f4 09 09 49 	lsl	r9,r10,r9
800107be:	10 9b       	mov	r11,r8
800107c0:	91 29       	st.w	r8[0x8],r9
800107c2:	0e 9c       	mov	r12,r7
800107c4:	e0 a0 0a 90 	rcall	80011ce4 <_Bfree>
800107c8:	6e 98       	ld.w	r8,r7[0x24]
800107ca:	30 09       	mov	r9,0
800107cc:	91 09       	st.w	r8[0x0],r9
800107ce:	40 28       	lddsp	r8,sp[0x8]
800107d0:	10 94       	mov	r4,r8
800107d2:	58 08       	cp.w	r8,0
800107d4:	c0 64       	brge	800107e0 <_dtoa_r+0x6c>
800107d6:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
800107da:	50 28       	stdsp	sp[0x8],r8
800107dc:	30 18       	mov	r8,1
800107de:	c0 28       	rjmp	800107e2 <_dtoa_r+0x6e>
800107e0:	30 08       	mov	r8,0
800107e2:	8d 08       	st.w	r6[0x0],r8
800107e4:	fc 1c 7f f0 	movh	r12,0x7ff0
800107e8:	40 26       	lddsp	r6,sp[0x8]
800107ea:	0c 98       	mov	r8,r6
800107ec:	e6 18 7f f0 	andh	r8,0x7ff0,COH
800107f0:	18 38       	cp.w	r8,r12
800107f2:	c2 01       	brne	80010832 <_dtoa_r+0xbe>
800107f4:	e0 68 27 0f 	mov	r8,9999
800107f8:	41 5b       	lddsp	r11,sp[0x54]
800107fa:	97 08       	st.w	r11[0x0],r8
800107fc:	40 3a       	lddsp	r10,sp[0xc]
800107fe:	58 0a       	cp.w	r10,0
80010800:	c0 71       	brne	8001080e <_dtoa_r+0x9a>
80010802:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80010806:	c0 41       	brne	8001080e <_dtoa_r+0x9a>
80010808:	fe cc 9a 74 	sub	r12,pc,-25996
8001080c:	c0 38       	rjmp	80010812 <_dtoa_r+0x9e>
8001080e:	fe cc 9a 6e 	sub	r12,pc,-26002
80010812:	41 29       	lddsp	r9,sp[0x48]
80010814:	58 09       	cp.w	r9,0
80010816:	e0 80 05 9a 	breq	8001134a <_dtoa_r+0xbd6>
8001081a:	f8 c8 ff fd 	sub	r8,r12,-3
8001081e:	f8 c9 ff f8 	sub	r9,r12,-8
80010822:	11 8b       	ld.ub	r11,r8[0x0]
80010824:	30 0a       	mov	r10,0
80010826:	41 25       	lddsp	r5,sp[0x48]
80010828:	f4 0b 18 00 	cp.b	r11,r10
8001082c:	f2 08 17 10 	movne	r8,r9
80010830:	c1 68       	rjmp	8001085c <_dtoa_r+0xe8>
80010832:	fa ea 00 08 	ld.d	r10,sp[8]
80010836:	30 08       	mov	r8,0
80010838:	fa eb 00 3c 	st.d	sp[60],r10
8001083c:	30 09       	mov	r9,0
8001083e:	e0 a0 0f a7 	rcall	8001278c <__avr32_f64_cmp_eq>
80010842:	c1 00       	breq	80010862 <_dtoa_r+0xee>
80010844:	30 18       	mov	r8,1
80010846:	41 5a       	lddsp	r10,sp[0x54]
80010848:	95 08       	st.w	r10[0x0],r8
8001084a:	fe cc b6 86 	sub	r12,pc,-18810
8001084e:	41 29       	lddsp	r9,sp[0x48]
80010850:	f8 08 00 08 	add	r8,r12,r8
80010854:	58 09       	cp.w	r9,0
80010856:	e0 80 05 7a 	breq	8001134a <_dtoa_r+0xbd6>
8001085a:	12 95       	mov	r5,r9
8001085c:	8b 08       	st.w	r5[0x0],r8
8001085e:	e0 8f 05 76 	bral	8001134a <_dtoa_r+0xbd6>
80010862:	fa c8 ff 9c 	sub	r8,sp,-100
80010866:	fa c9 ff a0 	sub	r9,sp,-96
8001086a:	fa ea 00 3c 	ld.d	r10,sp[60]
8001086e:	0e 9c       	mov	r12,r7
80010870:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80010874:	e0 a0 0a 8a 	rcall	80011d88 <__d2b>
80010878:	18 93       	mov	r3,r12
8001087a:	58 05       	cp.w	r5,0
8001087c:	c0 d0       	breq	80010896 <_dtoa_r+0x122>
8001087e:	fa ea 00 3c 	ld.d	r10,sp[60]
80010882:	30 04       	mov	r4,0
80010884:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80010888:	ea c5 03 ff 	sub	r5,r5,1023
8001088c:	10 9b       	mov	r11,r8
8001088e:	51 74       	stdsp	sp[0x5c],r4
80010890:	ea 1b 3f f0 	orh	r11,0x3ff0
80010894:	c2 58       	rjmp	800108de <_dtoa_r+0x16a>
80010896:	41 88       	lddsp	r8,sp[0x60]
80010898:	41 9c       	lddsp	r12,sp[0x64]
8001089a:	10 0c       	add	r12,r8
8001089c:	f8 c5 fb ce 	sub	r5,r12,-1074
800108a0:	e0 45 00 20 	cp.w	r5,32
800108a4:	e0 8a 00 0e 	brle	800108c0 <_dtoa_r+0x14c>
800108a8:	f8 cc fb ee 	sub	r12,r12,-1042
800108ac:	40 3b       	lddsp	r11,sp[0xc]
800108ae:	ea 08 11 40 	rsub	r8,r5,64
800108b2:	f6 0c 0a 4c 	lsr	r12,r11,r12
800108b6:	ec 08 09 46 	lsl	r6,r6,r8
800108ba:	0c 4c       	or	r12,r6
800108bc:	c0 78       	rjmp	800108ca <_dtoa_r+0x156>
800108be:	d7 03       	nop
800108c0:	ea 0c 11 20 	rsub	r12,r5,32
800108c4:	40 3a       	lddsp	r10,sp[0xc]
800108c6:	f4 0c 09 4c 	lsl	r12,r10,r12
800108ca:	fe b0 da c4 	rcall	8000be52 <__avr32_u32_to_f64>
800108ce:	fc 18 fe 10 	movh	r8,0xfe10
800108d2:	30 19       	mov	r9,1
800108d4:	ea c5 04 33 	sub	r5,r5,1075
800108d8:	f0 0b 00 0b 	add	r11,r8,r11
800108dc:	51 79       	stdsp	sp[0x5c],r9
800108de:	30 08       	mov	r8,0
800108e0:	fc 19 3f f8 	movh	r9,0x3ff8
800108e4:	fe b0 d9 4c 	rcall	8000bb7c <__avr32_f64_sub>
800108e8:	e0 68 43 61 	mov	r8,17249
800108ec:	ea 18 63 6f 	orh	r8,0x636f
800108f0:	e0 69 87 a7 	mov	r9,34727
800108f4:	ea 19 3f d2 	orh	r9,0x3fd2
800108f8:	fe b0 d8 56 	rcall	8000b9a4 <__avr32_f64_mul>
800108fc:	e0 68 c8 b3 	mov	r8,51379
80010900:	ea 18 8b 60 	orh	r8,0x8b60
80010904:	e0 69 8a 28 	mov	r9,35368
80010908:	ea 19 3f c6 	orh	r9,0x3fc6
8001090c:	fe b0 da 06 	rcall	8000bd18 <__avr32_f64_add>
80010910:	0a 9c       	mov	r12,r5
80010912:	14 90       	mov	r0,r10
80010914:	16 91       	mov	r1,r11
80010916:	fe b0 da a2 	rcall	8000be5a <__avr32_s32_to_f64>
8001091a:	e0 68 79 fb 	mov	r8,31227
8001091e:	ea 18 50 9f 	orh	r8,0x509f
80010922:	e0 69 44 13 	mov	r9,17427
80010926:	ea 19 3f d3 	orh	r9,0x3fd3
8001092a:	fe b0 d8 3d 	rcall	8000b9a4 <__avr32_f64_mul>
8001092e:	14 98       	mov	r8,r10
80010930:	16 99       	mov	r9,r11
80010932:	00 9a       	mov	r10,r0
80010934:	02 9b       	mov	r11,r1
80010936:	fe b0 d9 f1 	rcall	8000bd18 <__avr32_f64_add>
8001093a:	14 90       	mov	r0,r10
8001093c:	16 91       	mov	r1,r11
8001093e:	fe b0 da 77 	rcall	8000be2c <__avr32_f64_to_s32>
80010942:	30 08       	mov	r8,0
80010944:	18 96       	mov	r6,r12
80010946:	30 09       	mov	r9,0
80010948:	00 9a       	mov	r10,r0
8001094a:	02 9b       	mov	r11,r1
8001094c:	e0 a0 0f 67 	rcall	8001281a <__avr32_f64_cmp_lt>
80010950:	c0 c0       	breq	80010968 <_dtoa_r+0x1f4>
80010952:	0c 9c       	mov	r12,r6
80010954:	fe b0 da 83 	rcall	8000be5a <__avr32_s32_to_f64>
80010958:	14 98       	mov	r8,r10
8001095a:	16 99       	mov	r9,r11
8001095c:	00 9a       	mov	r10,r0
8001095e:	02 9b       	mov	r11,r1
80010960:	e0 a0 0f 16 	rcall	8001278c <__avr32_f64_cmp_eq>
80010964:	f7 b6 00 01 	subeq	r6,1
80010968:	59 66       	cp.w	r6,22
8001096a:	e0 88 00 05 	brls	80010974 <_dtoa_r+0x200>
8001096e:	30 18       	mov	r8,1
80010970:	51 48       	stdsp	sp[0x50],r8
80010972:	c1 38       	rjmp	80010998 <_dtoa_r+0x224>
80010974:	fe c8 9b 24 	sub	r8,pc,-25820
80010978:	fa ea 00 3c 	ld.d	r10,sp[60]
8001097c:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
80010980:	e0 a0 0f 4d 	rcall	8001281a <__avr32_f64_cmp_lt>
80010984:	f9 b4 00 00 	moveq	r4,0
80010988:	fb f4 0a 14 	st.weq	sp[0x50],r4
8001098c:	f7 b6 01 01 	subne	r6,1
80010990:	f9 bc 01 00 	movne	r12,0
80010994:	fb fc 1a 14 	st.wne	sp[0x50],r12
80010998:	41 90       	lddsp	r0,sp[0x64]
8001099a:	20 10       	sub	r0,1
8001099c:	0a 10       	sub	r0,r5
8001099e:	c0 46       	brmi	800109a6 <_dtoa_r+0x232>
800109a0:	50 40       	stdsp	sp[0x10],r0
800109a2:	30 00       	mov	r0,0
800109a4:	c0 48       	rjmp	800109ac <_dtoa_r+0x238>
800109a6:	30 0b       	mov	r11,0
800109a8:	5c 30       	neg	r0
800109aa:	50 4b       	stdsp	sp[0x10],r11
800109ac:	ec 02 11 00 	rsub	r2,r6,0
800109b0:	58 06       	cp.w	r6,0
800109b2:	fb fa 40 04 	ld.wge	r10,sp[0x10]
800109b6:	f5 d6 e4 0a 	addge	r10,r10,r6
800109ba:	fb fa 4a 04 	st.wge	sp[0x10],r10
800109be:	fb f6 4a 11 	st.wge	sp[0x44],r6
800109c2:	f9 b2 04 00 	movge	r2,0
800109c6:	e1 d6 e5 10 	sublt	r0,r0,r6
800109ca:	f9 b9 05 00 	movlt	r9,0
800109ce:	fb f9 5a 11 	st.wlt	sp[0x44],r9
800109d2:	40 c8       	lddsp	r8,sp[0x30]
800109d4:	58 98       	cp.w	r8,9
800109d6:	e0 8b 00 20 	brhi	80010a16 <_dtoa_r+0x2a2>
800109da:	58 58       	cp.w	r8,5
800109dc:	f9 b4 0a 01 	movle	r4,1
800109e0:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
800109e4:	f7 b5 09 04 	subgt	r5,4
800109e8:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
800109ec:	f9 b4 09 00 	movgt	r4,0
800109f0:	40 cc       	lddsp	r12,sp[0x30]
800109f2:	58 3c       	cp.w	r12,3
800109f4:	c2 d0       	breq	80010a4e <_dtoa_r+0x2da>
800109f6:	e0 89 00 05 	brgt	80010a00 <_dtoa_r+0x28c>
800109fa:	58 2c       	cp.w	r12,2
800109fc:	c1 01       	brne	80010a1c <_dtoa_r+0x2a8>
800109fe:	c1 88       	rjmp	80010a2e <_dtoa_r+0x2ba>
80010a00:	40 cb       	lddsp	r11,sp[0x30]
80010a02:	58 4b       	cp.w	r11,4
80010a04:	c0 60       	breq	80010a10 <_dtoa_r+0x29c>
80010a06:	58 5b       	cp.w	r11,5
80010a08:	c0 a1       	brne	80010a1c <_dtoa_r+0x2a8>
80010a0a:	30 1a       	mov	r10,1
80010a0c:	50 da       	stdsp	sp[0x34],r10
80010a0e:	c2 28       	rjmp	80010a52 <_dtoa_r+0x2de>
80010a10:	30 19       	mov	r9,1
80010a12:	50 d9       	stdsp	sp[0x34],r9
80010a14:	c0 f8       	rjmp	80010a32 <_dtoa_r+0x2be>
80010a16:	30 08       	mov	r8,0
80010a18:	30 14       	mov	r4,1
80010a1a:	50 c8       	stdsp	sp[0x30],r8
80010a1c:	3f f5       	mov	r5,-1
80010a1e:	30 1c       	mov	r12,1
80010a20:	30 0b       	mov	r11,0
80010a22:	50 95       	stdsp	sp[0x24],r5
80010a24:	50 dc       	stdsp	sp[0x34],r12
80010a26:	0a 91       	mov	r1,r5
80010a28:	31 28       	mov	r8,18
80010a2a:	50 eb       	stdsp	sp[0x38],r11
80010a2c:	c2 08       	rjmp	80010a6c <_dtoa_r+0x2f8>
80010a2e:	30 0a       	mov	r10,0
80010a30:	50 da       	stdsp	sp[0x34],r10
80010a32:	40 e9       	lddsp	r9,sp[0x38]
80010a34:	58 09       	cp.w	r9,0
80010a36:	e0 89 00 07 	brgt	80010a44 <_dtoa_r+0x2d0>
80010a3a:	30 18       	mov	r8,1
80010a3c:	50 98       	stdsp	sp[0x24],r8
80010a3e:	10 91       	mov	r1,r8
80010a40:	50 e8       	stdsp	sp[0x38],r8
80010a42:	c1 58       	rjmp	80010a6c <_dtoa_r+0x2f8>
80010a44:	40 e5       	lddsp	r5,sp[0x38]
80010a46:	50 95       	stdsp	sp[0x24],r5
80010a48:	0a 91       	mov	r1,r5
80010a4a:	0a 98       	mov	r8,r5
80010a4c:	c1 08       	rjmp	80010a6c <_dtoa_r+0x2f8>
80010a4e:	30 0c       	mov	r12,0
80010a50:	50 dc       	stdsp	sp[0x34],r12
80010a52:	40 eb       	lddsp	r11,sp[0x38]
80010a54:	ec 0b 00 0b 	add	r11,r6,r11
80010a58:	50 9b       	stdsp	sp[0x24],r11
80010a5a:	16 98       	mov	r8,r11
80010a5c:	2f f8       	sub	r8,-1
80010a5e:	58 08       	cp.w	r8,0
80010a60:	e0 89 00 05 	brgt	80010a6a <_dtoa_r+0x2f6>
80010a64:	10 91       	mov	r1,r8
80010a66:	30 18       	mov	r8,1
80010a68:	c0 28       	rjmp	80010a6c <_dtoa_r+0x2f8>
80010a6a:	10 91       	mov	r1,r8
80010a6c:	30 09       	mov	r9,0
80010a6e:	6e 9a       	ld.w	r10,r7[0x24]
80010a70:	95 19       	st.w	r10[0x4],r9
80010a72:	30 49       	mov	r9,4
80010a74:	c0 68       	rjmp	80010a80 <_dtoa_r+0x30c>
80010a76:	d7 03       	nop
80010a78:	6a 1a       	ld.w	r10,r5[0x4]
80010a7a:	a1 79       	lsl	r9,0x1
80010a7c:	2f fa       	sub	r10,-1
80010a7e:	8b 1a       	st.w	r5[0x4],r10
80010a80:	6e 95       	ld.w	r5,r7[0x24]
80010a82:	f2 ca ff ec 	sub	r10,r9,-20
80010a86:	10 3a       	cp.w	r10,r8
80010a88:	fe 98 ff f8 	brls	80010a78 <_dtoa_r+0x304>
80010a8c:	6a 1b       	ld.w	r11,r5[0x4]
80010a8e:	0e 9c       	mov	r12,r7
80010a90:	e0 a0 09 44 	rcall	80011d18 <_Balloc>
80010a94:	58 e1       	cp.w	r1,14
80010a96:	5f 88       	srls	r8
80010a98:	8b 0c       	st.w	r5[0x0],r12
80010a9a:	f1 e4 00 04 	and	r4,r8,r4
80010a9e:	6e 98       	ld.w	r8,r7[0x24]
80010aa0:	70 08       	ld.w	r8,r8[0x0]
80010aa2:	50 88       	stdsp	sp[0x20],r8
80010aa4:	e0 80 01 82 	breq	80010da8 <_dtoa_r+0x634>
80010aa8:	58 06       	cp.w	r6,0
80010aaa:	e0 8a 00 43 	brle	80010b30 <_dtoa_r+0x3bc>
80010aae:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
80010ab2:	fe c8 9c 62 	sub	r8,pc,-25502
80010ab6:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
80010aba:	fa e5 00 18 	st.d	sp[24],r4
80010abe:	ec 04 14 04 	asr	r4,r6,0x4
80010ac2:	ed b4 00 04 	bld	r4,0x4
80010ac6:	c0 30       	breq	80010acc <_dtoa_r+0x358>
80010ac8:	30 25       	mov	r5,2
80010aca:	c1 08       	rjmp	80010aea <_dtoa_r+0x376>
80010acc:	fe c8 9b b4 	sub	r8,pc,-25676
80010ad0:	f0 e8 00 20 	ld.d	r8,r8[32]
80010ad4:	fa ea 00 3c 	ld.d	r10,sp[60]
80010ad8:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80010adc:	e0 a0 0e d4 	rcall	80012884 <__avr32_f64_div>
80010ae0:	30 35       	mov	r5,3
80010ae2:	14 98       	mov	r8,r10
80010ae4:	16 99       	mov	r9,r11
80010ae6:	fa e9 00 08 	st.d	sp[8],r8
80010aea:	fe cc 9b d2 	sub	r12,pc,-25646
80010aee:	50 a3       	stdsp	sp[0x28],r3
80010af0:	0c 93       	mov	r3,r6
80010af2:	18 96       	mov	r6,r12
80010af4:	c0 f8       	rjmp	80010b12 <_dtoa_r+0x39e>
80010af6:	fa ea 00 18 	ld.d	r10,sp[24]
80010afa:	ed b4 00 00 	bld	r4,0x0
80010afe:	c0 81       	brne	80010b0e <_dtoa_r+0x39a>
80010b00:	ec e8 00 00 	ld.d	r8,r6[0]
80010b04:	2f f5       	sub	r5,-1
80010b06:	fe b0 d7 4f 	rcall	8000b9a4 <__avr32_f64_mul>
80010b0a:	fa eb 00 18 	st.d	sp[24],r10
80010b0e:	a1 54       	asr	r4,0x1
80010b10:	2f 86       	sub	r6,-8
80010b12:	58 04       	cp.w	r4,0
80010b14:	cf 11       	brne	80010af6 <_dtoa_r+0x382>
80010b16:	fa e8 00 18 	ld.d	r8,sp[24]
80010b1a:	fa ea 00 08 	ld.d	r10,sp[8]
80010b1e:	06 96       	mov	r6,r3
80010b20:	e0 a0 0e b2 	rcall	80012884 <__avr32_f64_div>
80010b24:	40 a3       	lddsp	r3,sp[0x28]
80010b26:	14 98       	mov	r8,r10
80010b28:	16 99       	mov	r9,r11
80010b2a:	fa e9 00 08 	st.d	sp[8],r8
80010b2e:	c2 f8       	rjmp	80010b8c <_dtoa_r+0x418>
80010b30:	ec 08 11 00 	rsub	r8,r6,0
80010b34:	c0 31       	brne	80010b3a <_dtoa_r+0x3c6>
80010b36:	30 25       	mov	r5,2
80010b38:	c2 a8       	rjmp	80010b8c <_dtoa_r+0x418>
80010b3a:	fe cc 9c 22 	sub	r12,pc,-25566
80010b3e:	f0 04 14 04 	asr	r4,r8,0x4
80010b42:	50 1c       	stdsp	sp[0x4],r12
80010b44:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80010b48:	fe c9 9c f8 	sub	r9,pc,-25352
80010b4c:	fa ea 00 3c 	ld.d	r10,sp[60]
80010b50:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80010b54:	fe b0 d7 28 	rcall	8000b9a4 <__avr32_f64_mul>
80010b58:	40 1c       	lddsp	r12,sp[0x4]
80010b5a:	50 63       	stdsp	sp[0x18],r3
80010b5c:	30 25       	mov	r5,2
80010b5e:	0c 93       	mov	r3,r6
80010b60:	fa eb 00 08 	st.d	sp[8],r10
80010b64:	18 96       	mov	r6,r12
80010b66:	c0 f8       	rjmp	80010b84 <_dtoa_r+0x410>
80010b68:	fa ea 00 08 	ld.d	r10,sp[8]
80010b6c:	ed b4 00 00 	bld	r4,0x0
80010b70:	c0 81       	brne	80010b80 <_dtoa_r+0x40c>
80010b72:	ec e8 00 00 	ld.d	r8,r6[0]
80010b76:	2f f5       	sub	r5,-1
80010b78:	fe b0 d7 16 	rcall	8000b9a4 <__avr32_f64_mul>
80010b7c:	fa eb 00 08 	st.d	sp[8],r10
80010b80:	a1 54       	asr	r4,0x1
80010b82:	2f 86       	sub	r6,-8
80010b84:	58 04       	cp.w	r4,0
80010b86:	cf 11       	brne	80010b68 <_dtoa_r+0x3f4>
80010b88:	06 96       	mov	r6,r3
80010b8a:	40 63       	lddsp	r3,sp[0x18]
80010b8c:	41 4a       	lddsp	r10,sp[0x50]
80010b8e:	58 0a       	cp.w	r10,0
80010b90:	c2 a0       	breq	80010be4 <_dtoa_r+0x470>
80010b92:	fa e8 00 08 	ld.d	r8,sp[8]
80010b96:	58 01       	cp.w	r1,0
80010b98:	5f 94       	srgt	r4
80010b9a:	fa e9 00 18 	st.d	sp[24],r8
80010b9e:	30 08       	mov	r8,0
80010ba0:	fc 19 3f f0 	movh	r9,0x3ff0
80010ba4:	fa ea 00 18 	ld.d	r10,sp[24]
80010ba8:	e0 a0 0e 39 	rcall	8001281a <__avr32_f64_cmp_lt>
80010bac:	f9 bc 00 00 	moveq	r12,0
80010bb0:	f9 bc 01 01 	movne	r12,1
80010bb4:	e9 ec 00 0c 	and	r12,r4,r12
80010bb8:	c1 60       	breq	80010be4 <_dtoa_r+0x470>
80010bba:	40 98       	lddsp	r8,sp[0x24]
80010bbc:	58 08       	cp.w	r8,0
80010bbe:	e0 8a 00 f1 	brle	80010da0 <_dtoa_r+0x62c>
80010bc2:	30 08       	mov	r8,0
80010bc4:	fc 19 40 24 	movh	r9,0x4024
80010bc8:	ec c4 00 01 	sub	r4,r6,1
80010bcc:	fa ea 00 18 	ld.d	r10,sp[24]
80010bd0:	2f f5       	sub	r5,-1
80010bd2:	50 64       	stdsp	sp[0x18],r4
80010bd4:	fe b0 d6 e8 	rcall	8000b9a4 <__avr32_f64_mul>
80010bd8:	40 94       	lddsp	r4,sp[0x24]
80010bda:	14 98       	mov	r8,r10
80010bdc:	16 99       	mov	r9,r11
80010bde:	fa e9 00 08 	st.d	sp[8],r8
80010be2:	c0 38       	rjmp	80010be8 <_dtoa_r+0x474>
80010be4:	50 66       	stdsp	sp[0x18],r6
80010be6:	02 94       	mov	r4,r1
80010be8:	0a 9c       	mov	r12,r5
80010bea:	fe b0 d9 38 	rcall	8000be5a <__avr32_s32_to_f64>
80010bee:	fa e8 00 08 	ld.d	r8,sp[8]
80010bf2:	fe b0 d6 d9 	rcall	8000b9a4 <__avr32_f64_mul>
80010bf6:	30 08       	mov	r8,0
80010bf8:	fc 19 40 1c 	movh	r9,0x401c
80010bfc:	fe b0 d8 8e 	rcall	8000bd18 <__avr32_f64_add>
80010c00:	14 98       	mov	r8,r10
80010c02:	16 99       	mov	r9,r11
80010c04:	fa e9 00 28 	st.d	sp[40],r8
80010c08:	fc 18 fc c0 	movh	r8,0xfcc0
80010c0c:	40 a5       	lddsp	r5,sp[0x28]
80010c0e:	10 05       	add	r5,r8
80010c10:	50 a5       	stdsp	sp[0x28],r5
80010c12:	58 04       	cp.w	r4,0
80010c14:	c2 11       	brne	80010c56 <_dtoa_r+0x4e2>
80010c16:	fa ea 00 08 	ld.d	r10,sp[8]
80010c1a:	30 08       	mov	r8,0
80010c1c:	fc 19 40 14 	movh	r9,0x4014
80010c20:	fe b0 d7 ae 	rcall	8000bb7c <__avr32_f64_sub>
80010c24:	40 bc       	lddsp	r12,sp[0x2c]
80010c26:	fa eb 00 08 	st.d	sp[8],r10
80010c2a:	14 98       	mov	r8,r10
80010c2c:	16 99       	mov	r9,r11
80010c2e:	18 9a       	mov	r10,r12
80010c30:	0a 9b       	mov	r11,r5
80010c32:	e0 a0 0d f4 	rcall	8001281a <__avr32_f64_cmp_lt>
80010c36:	e0 81 02 54 	brne	800110de <_dtoa_r+0x96a>
80010c3a:	0a 98       	mov	r8,r5
80010c3c:	40 b9       	lddsp	r9,sp[0x2c]
80010c3e:	ee 18 80 00 	eorh	r8,0x8000
80010c42:	fa ea 00 08 	ld.d	r10,sp[8]
80010c46:	10 95       	mov	r5,r8
80010c48:	12 98       	mov	r8,r9
80010c4a:	0a 99       	mov	r9,r5
80010c4c:	e0 a0 0d e7 	rcall	8001281a <__avr32_f64_cmp_lt>
80010c50:	e0 81 02 3e 	brne	800110cc <_dtoa_r+0x958>
80010c54:	ca 68       	rjmp	80010da0 <_dtoa_r+0x62c>
80010c56:	fe c9 9e 06 	sub	r9,pc,-25082
80010c5a:	e8 c8 00 01 	sub	r8,r4,1
80010c5e:	40 d5       	lddsp	r5,sp[0x34]
80010c60:	58 05       	cp.w	r5,0
80010c62:	c4 f0       	breq	80010d00 <_dtoa_r+0x58c>
80010c64:	30 0c       	mov	r12,0
80010c66:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80010c6a:	51 3c       	stdsp	sp[0x4c],r12
80010c6c:	30 0a       	mov	r10,0
80010c6e:	fc 1b 3f e0 	movh	r11,0x3fe0
80010c72:	e0 a0 0e 09 	rcall	80012884 <__avr32_f64_div>
80010c76:	fa e8 00 28 	ld.d	r8,sp[40]
80010c7a:	40 85       	lddsp	r5,sp[0x20]
80010c7c:	fe b0 d7 80 	rcall	8000bb7c <__avr32_f64_sub>
80010c80:	fa eb 00 28 	st.d	sp[40],r10
80010c84:	fa ea 00 08 	ld.d	r10,sp[8]
80010c88:	fe b0 d8 d2 	rcall	8000be2c <__avr32_f64_to_s32>
80010c8c:	51 6c       	stdsp	sp[0x58],r12
80010c8e:	fe b0 d8 e6 	rcall	8000be5a <__avr32_s32_to_f64>
80010c92:	14 98       	mov	r8,r10
80010c94:	16 99       	mov	r9,r11
80010c96:	fa ea 00 08 	ld.d	r10,sp[8]
80010c9a:	fe b0 d7 71 	rcall	8000bb7c <__avr32_f64_sub>
80010c9e:	fa eb 00 08 	st.d	sp[8],r10
80010ca2:	41 68       	lddsp	r8,sp[0x58]
80010ca4:	2d 08       	sub	r8,-48
80010ca6:	0a c8       	st.b	r5++,r8
80010ca8:	41 39       	lddsp	r9,sp[0x4c]
80010caa:	2f f9       	sub	r9,-1
80010cac:	51 39       	stdsp	sp[0x4c],r9
80010cae:	fa e8 00 28 	ld.d	r8,sp[40]
80010cb2:	e0 a0 0d b4 	rcall	8001281a <__avr32_f64_cmp_lt>
80010cb6:	e0 81 03 39 	brne	80011328 <_dtoa_r+0xbb4>
80010cba:	fa e8 00 08 	ld.d	r8,sp[8]
80010cbe:	30 0a       	mov	r10,0
80010cc0:	fc 1b 3f f0 	movh	r11,0x3ff0
80010cc4:	fe b0 d7 5c 	rcall	8000bb7c <__avr32_f64_sub>
80010cc8:	fa e8 00 28 	ld.d	r8,sp[40]
80010ccc:	e0 a0 0d a7 	rcall	8001281a <__avr32_f64_cmp_lt>
80010cd0:	fa ea 00 28 	ld.d	r10,sp[40]
80010cd4:	30 08       	mov	r8,0
80010cd6:	fc 19 40 24 	movh	r9,0x4024
80010cda:	e0 81 00 da 	brne	80010e8e <_dtoa_r+0x71a>
80010cde:	41 3c       	lddsp	r12,sp[0x4c]
80010ce0:	08 3c       	cp.w	r12,r4
80010ce2:	c5 f4       	brge	80010da0 <_dtoa_r+0x62c>
80010ce4:	fe b0 d6 60 	rcall	8000b9a4 <__avr32_f64_mul>
80010ce8:	30 08       	mov	r8,0
80010cea:	fa eb 00 28 	st.d	sp[40],r10
80010cee:	fc 19 40 24 	movh	r9,0x4024
80010cf2:	fa ea 00 08 	ld.d	r10,sp[8]
80010cf6:	fe b0 d6 57 	rcall	8000b9a4 <__avr32_f64_mul>
80010cfa:	fa eb 00 08 	st.d	sp[8],r10
80010cfe:	cc 3b       	rjmp	80010c84 <_dtoa_r+0x510>
80010d00:	40 85       	lddsp	r5,sp[0x20]
80010d02:	08 05       	add	r5,r4
80010d04:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80010d08:	51 35       	stdsp	sp[0x4c],r5
80010d0a:	fa e8 00 28 	ld.d	r8,sp[40]
80010d0e:	40 85       	lddsp	r5,sp[0x20]
80010d10:	fe b0 d6 4a 	rcall	8000b9a4 <__avr32_f64_mul>
80010d14:	fa eb 00 28 	st.d	sp[40],r10
80010d18:	fa ea 00 08 	ld.d	r10,sp[8]
80010d1c:	fe b0 d8 88 	rcall	8000be2c <__avr32_f64_to_s32>
80010d20:	51 6c       	stdsp	sp[0x58],r12
80010d22:	fe b0 d8 9c 	rcall	8000be5a <__avr32_s32_to_f64>
80010d26:	14 98       	mov	r8,r10
80010d28:	16 99       	mov	r9,r11
80010d2a:	fa ea 00 08 	ld.d	r10,sp[8]
80010d2e:	fe b0 d7 27 	rcall	8000bb7c <__avr32_f64_sub>
80010d32:	fa eb 00 08 	st.d	sp[8],r10
80010d36:	41 68       	lddsp	r8,sp[0x58]
80010d38:	2d 08       	sub	r8,-48
80010d3a:	0a c8       	st.b	r5++,r8
80010d3c:	41 3c       	lddsp	r12,sp[0x4c]
80010d3e:	18 35       	cp.w	r5,r12
80010d40:	c2 81       	brne	80010d90 <_dtoa_r+0x61c>
80010d42:	30 08       	mov	r8,0
80010d44:	fc 19 3f e0 	movh	r9,0x3fe0
80010d48:	fa ea 00 28 	ld.d	r10,sp[40]
80010d4c:	fe b0 d7 e6 	rcall	8000bd18 <__avr32_f64_add>
80010d50:	40 85       	lddsp	r5,sp[0x20]
80010d52:	fa e8 00 08 	ld.d	r8,sp[8]
80010d56:	08 05       	add	r5,r4
80010d58:	e0 a0 0d 61 	rcall	8001281a <__avr32_f64_cmp_lt>
80010d5c:	e0 81 00 99 	brne	80010e8e <_dtoa_r+0x71a>
80010d60:	fa e8 00 28 	ld.d	r8,sp[40]
80010d64:	30 0a       	mov	r10,0
80010d66:	fc 1b 3f e0 	movh	r11,0x3fe0
80010d6a:	fe b0 d7 09 	rcall	8000bb7c <__avr32_f64_sub>
80010d6e:	14 98       	mov	r8,r10
80010d70:	16 99       	mov	r9,r11
80010d72:	fa ea 00 08 	ld.d	r10,sp[8]
80010d76:	e0 a0 0d 52 	rcall	8001281a <__avr32_f64_cmp_lt>
80010d7a:	c1 30       	breq	80010da0 <_dtoa_r+0x62c>
80010d7c:	33 09       	mov	r9,48
80010d7e:	0a 98       	mov	r8,r5
80010d80:	11 7a       	ld.ub	r10,--r8
80010d82:	f2 0a 18 00 	cp.b	r10,r9
80010d86:	e0 81 02 d1 	brne	80011328 <_dtoa_r+0xbb4>
80010d8a:	10 95       	mov	r5,r8
80010d8c:	cf 9b       	rjmp	80010d7e <_dtoa_r+0x60a>
80010d8e:	d7 03       	nop
80010d90:	30 08       	mov	r8,0
80010d92:	fc 19 40 24 	movh	r9,0x4024
80010d96:	fe b0 d6 07 	rcall	8000b9a4 <__avr32_f64_mul>
80010d9a:	fa eb 00 08 	st.d	sp[8],r10
80010d9e:	cb db       	rjmp	80010d18 <_dtoa_r+0x5a4>
80010da0:	fa ea 00 3c 	ld.d	r10,sp[60]
80010da4:	fa eb 00 08 	st.d	sp[8],r10
80010da8:	58 e6       	cp.w	r6,14
80010daa:	5f ab       	srle	r11
80010dac:	41 8a       	lddsp	r10,sp[0x60]
80010dae:	30 08       	mov	r8,0
80010db0:	f4 09 11 ff 	rsub	r9,r10,-1
80010db4:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
80010db8:	f0 09 18 00 	cp.b	r9,r8
80010dbc:	e0 80 00 82 	breq	80010ec0 <_dtoa_r+0x74c>
80010dc0:	40 ea       	lddsp	r10,sp[0x38]
80010dc2:	58 01       	cp.w	r1,0
80010dc4:	5f a9       	srle	r9
80010dc6:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
80010dca:	fe ca 9f 7a 	sub	r10,pc,-24710
80010dce:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
80010dd2:	fa e5 00 10 	st.d	sp[16],r4
80010dd6:	f0 09 18 00 	cp.b	r9,r8
80010dda:	c1 40       	breq	80010e02 <_dtoa_r+0x68e>
80010ddc:	58 01       	cp.w	r1,0
80010dde:	e0 81 01 77 	brne	800110cc <_dtoa_r+0x958>
80010de2:	30 08       	mov	r8,0
80010de4:	fc 19 40 14 	movh	r9,0x4014
80010de8:	08 9a       	mov	r10,r4
80010dea:	0a 9b       	mov	r11,r5
80010dec:	fe b0 d5 dc 	rcall	8000b9a4 <__avr32_f64_mul>
80010df0:	fa e8 00 08 	ld.d	r8,sp[8]
80010df4:	e0 a0 0c df 	rcall	800127b2 <__avr32_f64_cmp_ge>
80010df8:	e0 81 01 6a 	brne	800110cc <_dtoa_r+0x958>
80010dfc:	02 92       	mov	r2,r1
80010dfe:	e0 8f 01 72 	bral	800110e2 <_dtoa_r+0x96e>
80010e02:	40 85       	lddsp	r5,sp[0x20]
80010e04:	30 14       	mov	r4,1
80010e06:	fa e8 00 10 	ld.d	r8,sp[16]
80010e0a:	fa ea 00 08 	ld.d	r10,sp[8]
80010e0e:	e0 a0 0d 3b 	rcall	80012884 <__avr32_f64_div>
80010e12:	fe b0 d8 0d 	rcall	8000be2c <__avr32_f64_to_s32>
80010e16:	18 92       	mov	r2,r12
80010e18:	fe b0 d8 21 	rcall	8000be5a <__avr32_s32_to_f64>
80010e1c:	fa e8 00 10 	ld.d	r8,sp[16]
80010e20:	fe b0 d5 c2 	rcall	8000b9a4 <__avr32_f64_mul>
80010e24:	14 98       	mov	r8,r10
80010e26:	16 99       	mov	r9,r11
80010e28:	fa ea 00 08 	ld.d	r10,sp[8]
80010e2c:	fe b0 d6 a8 	rcall	8000bb7c <__avr32_f64_sub>
80010e30:	fa eb 00 08 	st.d	sp[8],r10
80010e34:	e4 c8 ff d0 	sub	r8,r2,-48
80010e38:	0a c8       	st.b	r5++,r8
80010e3a:	fc 19 40 24 	movh	r9,0x4024
80010e3e:	30 08       	mov	r8,0
80010e40:	02 34       	cp.w	r4,r1
80010e42:	c3 31       	brne	80010ea8 <_dtoa_r+0x734>
80010e44:	fa e8 00 08 	ld.d	r8,sp[8]
80010e48:	fe b0 d7 68 	rcall	8000bd18 <__avr32_f64_add>
80010e4c:	16 91       	mov	r1,r11
80010e4e:	14 90       	mov	r0,r10
80010e50:	14 98       	mov	r8,r10
80010e52:	02 99       	mov	r9,r1
80010e54:	fa ea 00 10 	ld.d	r10,sp[16]
80010e58:	e0 a0 0c e1 	rcall	8001281a <__avr32_f64_cmp_lt>
80010e5c:	c1 a1       	brne	80010e90 <_dtoa_r+0x71c>
80010e5e:	fa e8 00 10 	ld.d	r8,sp[16]
80010e62:	00 9a       	mov	r10,r0
80010e64:	02 9b       	mov	r11,r1
80010e66:	e0 a0 0c 93 	rcall	8001278c <__avr32_f64_cmp_eq>
80010e6a:	e0 80 02 5e 	breq	80011326 <_dtoa_r+0xbb2>
80010e6e:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
80010e72:	c0 f1       	brne	80010e90 <_dtoa_r+0x71c>
80010e74:	e0 8f 02 59 	bral	80011326 <_dtoa_r+0xbb2>
80010e78:	40 8a       	lddsp	r10,sp[0x20]
80010e7a:	14 38       	cp.w	r8,r10
80010e7c:	c0 30       	breq	80010e82 <_dtoa_r+0x70e>
80010e7e:	10 95       	mov	r5,r8
80010e80:	c0 98       	rjmp	80010e92 <_dtoa_r+0x71e>
80010e82:	33 08       	mov	r8,48
80010e84:	40 89       	lddsp	r9,sp[0x20]
80010e86:	2f f6       	sub	r6,-1
80010e88:	b2 88       	st.b	r9[0x0],r8
80010e8a:	40 88       	lddsp	r8,sp[0x20]
80010e8c:	c0 88       	rjmp	80010e9c <_dtoa_r+0x728>
80010e8e:	40 66       	lddsp	r6,sp[0x18]
80010e90:	33 99       	mov	r9,57
80010e92:	0a 98       	mov	r8,r5
80010e94:	11 7a       	ld.ub	r10,--r8
80010e96:	f2 0a 18 00 	cp.b	r10,r9
80010e9a:	ce f0       	breq	80010e78 <_dtoa_r+0x704>
80010e9c:	50 66       	stdsp	sp[0x18],r6
80010e9e:	11 89       	ld.ub	r9,r8[0x0]
80010ea0:	2f f9       	sub	r9,-1
80010ea2:	b0 89       	st.b	r8[0x0],r9
80010ea4:	e0 8f 02 42 	bral	80011328 <_dtoa_r+0xbb4>
80010ea8:	fe b0 d5 7e 	rcall	8000b9a4 <__avr32_f64_mul>
80010eac:	2f f4       	sub	r4,-1
80010eae:	fa eb 00 08 	st.d	sp[8],r10
80010eb2:	30 08       	mov	r8,0
80010eb4:	30 09       	mov	r9,0
80010eb6:	e0 a0 0c 6b 	rcall	8001278c <__avr32_f64_cmp_eq>
80010eba:	ca 60       	breq	80010e06 <_dtoa_r+0x692>
80010ebc:	e0 8f 02 35 	bral	80011326 <_dtoa_r+0xbb2>
80010ec0:	40 d8       	lddsp	r8,sp[0x34]
80010ec2:	58 08       	cp.w	r8,0
80010ec4:	c0 51       	brne	80010ece <_dtoa_r+0x75a>
80010ec6:	04 98       	mov	r8,r2
80010ec8:	00 95       	mov	r5,r0
80010eca:	40 d4       	lddsp	r4,sp[0x34]
80010ecc:	c3 78       	rjmp	80010f3a <_dtoa_r+0x7c6>
80010ece:	40 c5       	lddsp	r5,sp[0x30]
80010ed0:	58 15       	cp.w	r5,1
80010ed2:	e0 89 00 0f 	brgt	80010ef0 <_dtoa_r+0x77c>
80010ed6:	41 74       	lddsp	r4,sp[0x5c]
80010ed8:	58 04       	cp.w	r4,0
80010eda:	c0 40       	breq	80010ee2 <_dtoa_r+0x76e>
80010edc:	f4 c9 fb cd 	sub	r9,r10,-1075
80010ee0:	c0 48       	rjmp	80010ee8 <_dtoa_r+0x774>
80010ee2:	41 99       	lddsp	r9,sp[0x64]
80010ee4:	f2 09 11 36 	rsub	r9,r9,54
80010ee8:	04 98       	mov	r8,r2
80010eea:	00 95       	mov	r5,r0
80010eec:	c1 c8       	rjmp	80010f24 <_dtoa_r+0x7b0>
80010eee:	d7 03       	nop
80010ef0:	e2 c8 00 01 	sub	r8,r1,1
80010ef4:	58 01       	cp.w	r1,0
80010ef6:	e0 05 17 40 	movge	r5,r0
80010efa:	e2 09 17 40 	movge	r9,r1
80010efe:	e1 d1 e5 15 	sublt	r5,r0,r1
80010f02:	f9 b9 05 00 	movlt	r9,0
80010f06:	10 32       	cp.w	r2,r8
80010f08:	e5 d8 e4 18 	subge	r8,r2,r8
80010f0c:	f1 d2 e5 18 	sublt	r8,r8,r2
80010f10:	e5 d8 e5 02 	addlt	r2,r2,r8
80010f14:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
80010f18:	f9 d8 e5 0c 	addlt	r12,r12,r8
80010f1c:	fb fc 5a 11 	st.wlt	sp[0x44],r12
80010f20:	f9 b8 05 00 	movlt	r8,0
80010f24:	40 4b       	lddsp	r11,sp[0x10]
80010f26:	12 0b       	add	r11,r9
80010f28:	50 08       	stdsp	sp[0x0],r8
80010f2a:	50 4b       	stdsp	sp[0x10],r11
80010f2c:	12 00       	add	r0,r9
80010f2e:	30 1b       	mov	r11,1
80010f30:	0e 9c       	mov	r12,r7
80010f32:	e0 a0 08 a7 	rcall	80012080 <__i2b>
80010f36:	40 08       	lddsp	r8,sp[0x0]
80010f38:	18 94       	mov	r4,r12
80010f3a:	40 4a       	lddsp	r10,sp[0x10]
80010f3c:	58 05       	cp.w	r5,0
80010f3e:	5f 99       	srgt	r9
80010f40:	58 0a       	cp.w	r10,0
80010f42:	5f 9a       	srgt	r10
80010f44:	f5 e9 00 09 	and	r9,r10,r9
80010f48:	c0 80       	breq	80010f58 <_dtoa_r+0x7e4>
80010f4a:	40 4c       	lddsp	r12,sp[0x10]
80010f4c:	f8 05 0d 49 	min	r9,r12,r5
80010f50:	12 1c       	sub	r12,r9
80010f52:	12 10       	sub	r0,r9
80010f54:	50 4c       	stdsp	sp[0x10],r12
80010f56:	12 15       	sub	r5,r9
80010f58:	58 02       	cp.w	r2,0
80010f5a:	e0 8a 00 27 	brle	80010fa8 <_dtoa_r+0x834>
80010f5e:	40 db       	lddsp	r11,sp[0x34]
80010f60:	58 0b       	cp.w	r11,0
80010f62:	c1 d0       	breq	80010f9c <_dtoa_r+0x828>
80010f64:	58 08       	cp.w	r8,0
80010f66:	e0 8a 00 17 	brle	80010f94 <_dtoa_r+0x820>
80010f6a:	10 9a       	mov	r10,r8
80010f6c:	50 08       	stdsp	sp[0x0],r8
80010f6e:	08 9b       	mov	r11,r4
80010f70:	0e 9c       	mov	r12,r7
80010f72:	e0 a0 08 cd 	rcall	8001210c <__pow5mult>
80010f76:	06 9a       	mov	r10,r3
80010f78:	18 9b       	mov	r11,r12
80010f7a:	18 94       	mov	r4,r12
80010f7c:	0e 9c       	mov	r12,r7
80010f7e:	e0 a0 08 01 	rcall	80011f80 <__multiply>
80010f82:	18 99       	mov	r9,r12
80010f84:	06 9b       	mov	r11,r3
80010f86:	50 19       	stdsp	sp[0x4],r9
80010f88:	0e 9c       	mov	r12,r7
80010f8a:	e0 a0 06 ad 	rcall	80011ce4 <_Bfree>
80010f8e:	40 19       	lddsp	r9,sp[0x4]
80010f90:	40 08       	lddsp	r8,sp[0x0]
80010f92:	12 93       	mov	r3,r9
80010f94:	e4 08 01 0a 	sub	r10,r2,r8
80010f98:	c0 80       	breq	80010fa8 <_dtoa_r+0x834>
80010f9a:	c0 28       	rjmp	80010f9e <_dtoa_r+0x82a>
80010f9c:	04 9a       	mov	r10,r2
80010f9e:	06 9b       	mov	r11,r3
80010fa0:	0e 9c       	mov	r12,r7
80010fa2:	e0 a0 08 b5 	rcall	8001210c <__pow5mult>
80010fa6:	18 93       	mov	r3,r12
80010fa8:	30 1b       	mov	r11,1
80010faa:	0e 9c       	mov	r12,r7
80010fac:	e0 a0 08 6a 	rcall	80012080 <__i2b>
80010fb0:	41 1a       	lddsp	r10,sp[0x44]
80010fb2:	18 92       	mov	r2,r12
80010fb4:	58 0a       	cp.w	r10,0
80010fb6:	e0 8a 00 07 	brle	80010fc4 <_dtoa_r+0x850>
80010fba:	18 9b       	mov	r11,r12
80010fbc:	0e 9c       	mov	r12,r7
80010fbe:	e0 a0 08 a7 	rcall	8001210c <__pow5mult>
80010fc2:	18 92       	mov	r2,r12
80010fc4:	40 c9       	lddsp	r9,sp[0x30]
80010fc6:	58 19       	cp.w	r9,1
80010fc8:	e0 89 00 14 	brgt	80010ff0 <_dtoa_r+0x87c>
80010fcc:	40 38       	lddsp	r8,sp[0xc]
80010fce:	58 08       	cp.w	r8,0
80010fd0:	c1 01       	brne	80010ff0 <_dtoa_r+0x87c>
80010fd2:	40 29       	lddsp	r9,sp[0x8]
80010fd4:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
80010fd8:	c0 c1       	brne	80010ff0 <_dtoa_r+0x87c>
80010fda:	12 98       	mov	r8,r9
80010fdc:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80010fe0:	c0 80       	breq	80010ff0 <_dtoa_r+0x87c>
80010fe2:	40 4c       	lddsp	r12,sp[0x10]
80010fe4:	30 1b       	mov	r11,1
80010fe6:	2f fc       	sub	r12,-1
80010fe8:	2f f0       	sub	r0,-1
80010fea:	50 4c       	stdsp	sp[0x10],r12
80010fec:	50 6b       	stdsp	sp[0x18],r11
80010fee:	c0 38       	rjmp	80010ff4 <_dtoa_r+0x880>
80010ff0:	30 0a       	mov	r10,0
80010ff2:	50 6a       	stdsp	sp[0x18],r10
80010ff4:	41 19       	lddsp	r9,sp[0x44]
80010ff6:	58 09       	cp.w	r9,0
80010ff8:	c0 31       	brne	80010ffe <_dtoa_r+0x88a>
80010ffa:	30 1c       	mov	r12,1
80010ffc:	c0 98       	rjmp	8001100e <_dtoa_r+0x89a>
80010ffe:	64 48       	ld.w	r8,r2[0x10]
80011000:	2f c8       	sub	r8,-4
80011002:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
80011006:	e0 a0 05 df 	rcall	80011bc4 <__hi0bits>
8001100a:	f8 0c 11 20 	rsub	r12,r12,32
8001100e:	40 4b       	lddsp	r11,sp[0x10]
80011010:	f8 0b 00 08 	add	r8,r12,r11
80011014:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80011018:	c0 c0       	breq	80011030 <_dtoa_r+0x8bc>
8001101a:	f0 08 11 20 	rsub	r8,r8,32
8001101e:	58 48       	cp.w	r8,4
80011020:	e0 8a 00 06 	brle	8001102c <_dtoa_r+0x8b8>
80011024:	20 48       	sub	r8,4
80011026:	10 0b       	add	r11,r8
80011028:	50 4b       	stdsp	sp[0x10],r11
8001102a:	c0 78       	rjmp	80011038 <_dtoa_r+0x8c4>
8001102c:	58 48       	cp.w	r8,4
8001102e:	c0 70       	breq	8001103c <_dtoa_r+0x8c8>
80011030:	40 4a       	lddsp	r10,sp[0x10]
80011032:	2e 48       	sub	r8,-28
80011034:	10 0a       	add	r10,r8
80011036:	50 4a       	stdsp	sp[0x10],r10
80011038:	10 00       	add	r0,r8
8001103a:	10 05       	add	r5,r8
8001103c:	58 00       	cp.w	r0,0
8001103e:	e0 8a 00 08 	brle	8001104e <_dtoa_r+0x8da>
80011042:	06 9b       	mov	r11,r3
80011044:	00 9a       	mov	r10,r0
80011046:	0e 9c       	mov	r12,r7
80011048:	e0 a0 07 58 	rcall	80011ef8 <__lshift>
8001104c:	18 93       	mov	r3,r12
8001104e:	40 49       	lddsp	r9,sp[0x10]
80011050:	58 09       	cp.w	r9,0
80011052:	e0 8a 00 08 	brle	80011062 <_dtoa_r+0x8ee>
80011056:	04 9b       	mov	r11,r2
80011058:	12 9a       	mov	r10,r9
8001105a:	0e 9c       	mov	r12,r7
8001105c:	e0 a0 07 4e 	rcall	80011ef8 <__lshift>
80011060:	18 92       	mov	r2,r12
80011062:	41 48       	lddsp	r8,sp[0x50]
80011064:	58 08       	cp.w	r8,0
80011066:	c1 b0       	breq	8001109c <_dtoa_r+0x928>
80011068:	04 9b       	mov	r11,r2
8001106a:	06 9c       	mov	r12,r3
8001106c:	e0 a0 06 23 	rcall	80011cb2 <__mcmp>
80011070:	c1 64       	brge	8001109c <_dtoa_r+0x928>
80011072:	06 9b       	mov	r11,r3
80011074:	30 09       	mov	r9,0
80011076:	30 aa       	mov	r10,10
80011078:	0e 9c       	mov	r12,r7
8001107a:	e0 a0 08 0b 	rcall	80012090 <__multadd>
8001107e:	20 16       	sub	r6,1
80011080:	18 93       	mov	r3,r12
80011082:	40 dc       	lddsp	r12,sp[0x34]
80011084:	58 0c       	cp.w	r12,0
80011086:	c0 31       	brne	8001108c <_dtoa_r+0x918>
80011088:	40 91       	lddsp	r1,sp[0x24]
8001108a:	c0 98       	rjmp	8001109c <_dtoa_r+0x928>
8001108c:	08 9b       	mov	r11,r4
8001108e:	40 91       	lddsp	r1,sp[0x24]
80011090:	30 09       	mov	r9,0
80011092:	30 aa       	mov	r10,10
80011094:	0e 9c       	mov	r12,r7
80011096:	e0 a0 07 fd 	rcall	80012090 <__multadd>
8001109a:	18 94       	mov	r4,r12
8001109c:	58 01       	cp.w	r1,0
8001109e:	5f a9       	srle	r9
800110a0:	40 cb       	lddsp	r11,sp[0x30]
800110a2:	58 2b       	cp.w	r11,2
800110a4:	5f 98       	srgt	r8
800110a6:	f3 e8 00 08 	and	r8,r9,r8
800110aa:	c2 50       	breq	800110f4 <_dtoa_r+0x980>
800110ac:	58 01       	cp.w	r1,0
800110ae:	c1 11       	brne	800110d0 <_dtoa_r+0x95c>
800110b0:	04 9b       	mov	r11,r2
800110b2:	02 99       	mov	r9,r1
800110b4:	30 5a       	mov	r10,5
800110b6:	0e 9c       	mov	r12,r7
800110b8:	e0 a0 07 ec 	rcall	80012090 <__multadd>
800110bc:	18 92       	mov	r2,r12
800110be:	18 9b       	mov	r11,r12
800110c0:	06 9c       	mov	r12,r3
800110c2:	e0 a0 05 f8 	rcall	80011cb2 <__mcmp>
800110c6:	e0 89 00 0f 	brgt	800110e4 <_dtoa_r+0x970>
800110ca:	c0 38       	rjmp	800110d0 <_dtoa_r+0x95c>
800110cc:	30 02       	mov	r2,0
800110ce:	04 94       	mov	r4,r2
800110d0:	40 ea       	lddsp	r10,sp[0x38]
800110d2:	30 09       	mov	r9,0
800110d4:	5c da       	com	r10
800110d6:	40 85       	lddsp	r5,sp[0x20]
800110d8:	50 6a       	stdsp	sp[0x18],r10
800110da:	50 49       	stdsp	sp[0x10],r9
800110dc:	c0 f9       	rjmp	800112fa <_dtoa_r+0xb86>
800110de:	08 92       	mov	r2,r4
800110e0:	40 66       	lddsp	r6,sp[0x18]
800110e2:	04 94       	mov	r4,r2
800110e4:	2f f6       	sub	r6,-1
800110e6:	50 66       	stdsp	sp[0x18],r6
800110e8:	33 18       	mov	r8,49
800110ea:	40 85       	lddsp	r5,sp[0x20]
800110ec:	0a c8       	st.b	r5++,r8
800110ee:	30 08       	mov	r8,0
800110f0:	50 48       	stdsp	sp[0x10],r8
800110f2:	c0 49       	rjmp	800112fa <_dtoa_r+0xb86>
800110f4:	40 dc       	lddsp	r12,sp[0x34]
800110f6:	58 0c       	cp.w	r12,0
800110f8:	e0 80 00 b5 	breq	80011262 <_dtoa_r+0xaee>
800110fc:	58 05       	cp.w	r5,0
800110fe:	e0 8a 00 08 	brle	8001110e <_dtoa_r+0x99a>
80011102:	08 9b       	mov	r11,r4
80011104:	0a 9a       	mov	r10,r5
80011106:	0e 9c       	mov	r12,r7
80011108:	e0 a0 06 f8 	rcall	80011ef8 <__lshift>
8001110c:	18 94       	mov	r4,r12
8001110e:	40 6b       	lddsp	r11,sp[0x18]
80011110:	58 0b       	cp.w	r11,0
80011112:	c0 31       	brne	80011118 <_dtoa_r+0x9a4>
80011114:	08 9c       	mov	r12,r4
80011116:	c1 38       	rjmp	8001113c <_dtoa_r+0x9c8>
80011118:	68 1b       	ld.w	r11,r4[0x4]
8001111a:	0e 9c       	mov	r12,r7
8001111c:	e0 a0 05 fe 	rcall	80011d18 <_Balloc>
80011120:	68 4a       	ld.w	r10,r4[0x10]
80011122:	18 95       	mov	r5,r12
80011124:	e8 cb ff f4 	sub	r11,r4,-12
80011128:	2f ea       	sub	r10,-2
8001112a:	2f 4c       	sub	r12,-12
8001112c:	a3 6a       	lsl	r10,0x2
8001112e:	fe b0 da 85 	rcall	8000c638 <memcpy>
80011132:	0a 9b       	mov	r11,r5
80011134:	30 1a       	mov	r10,1
80011136:	0e 9c       	mov	r12,r7
80011138:	e0 a0 06 e0 	rcall	80011ef8 <__lshift>
8001113c:	50 44       	stdsp	sp[0x10],r4
8001113e:	40 3a       	lddsp	r10,sp[0xc]
80011140:	30 19       	mov	r9,1
80011142:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80011146:	18 94       	mov	r4,r12
80011148:	50 da       	stdsp	sp[0x34],r10
8001114a:	40 85       	lddsp	r5,sp[0x20]
8001114c:	50 99       	stdsp	sp[0x24],r9
8001114e:	50 26       	stdsp	sp[0x8],r6
80011150:	50 e1       	stdsp	sp[0x38],r1
80011152:	04 9b       	mov	r11,r2
80011154:	06 9c       	mov	r12,r3
80011156:	fe b0 fa 7f 	rcall	80010654 <quorem>
8001115a:	40 4b       	lddsp	r11,sp[0x10]
8001115c:	f8 c0 ff d0 	sub	r0,r12,-48
80011160:	06 9c       	mov	r12,r3
80011162:	e0 a0 05 a8 	rcall	80011cb2 <__mcmp>
80011166:	08 9a       	mov	r10,r4
80011168:	50 6c       	stdsp	sp[0x18],r12
8001116a:	04 9b       	mov	r11,r2
8001116c:	0e 9c       	mov	r12,r7
8001116e:	e0 a0 06 5d 	rcall	80011e28 <__mdiff>
80011172:	18 91       	mov	r1,r12
80011174:	78 38       	ld.w	r8,r12[0xc]
80011176:	58 08       	cp.w	r8,0
80011178:	c0 30       	breq	8001117e <_dtoa_r+0xa0a>
8001117a:	30 16       	mov	r6,1
8001117c:	c0 68       	rjmp	80011188 <_dtoa_r+0xa14>
8001117e:	18 9b       	mov	r11,r12
80011180:	06 9c       	mov	r12,r3
80011182:	e0 a0 05 98 	rcall	80011cb2 <__mcmp>
80011186:	18 96       	mov	r6,r12
80011188:	0e 9c       	mov	r12,r7
8001118a:	02 9b       	mov	r11,r1
8001118c:	e0 a0 05 ac 	rcall	80011ce4 <_Bfree>
80011190:	40 cc       	lddsp	r12,sp[0x30]
80011192:	ed ec 10 08 	or	r8,r6,r12
80011196:	c0 d1       	brne	800111b0 <_dtoa_r+0xa3c>
80011198:	40 db       	lddsp	r11,sp[0x34]
8001119a:	58 0b       	cp.w	r11,0
8001119c:	c0 a1       	brne	800111b0 <_dtoa_r+0xa3c>
8001119e:	40 26       	lddsp	r6,sp[0x8]
800111a0:	e0 40 00 39 	cp.w	r0,57
800111a4:	c3 00       	breq	80011204 <_dtoa_r+0xa90>
800111a6:	40 6a       	lddsp	r10,sp[0x18]
800111a8:	58 0a       	cp.w	r10,0
800111aa:	e0 89 00 24 	brgt	800111f2 <_dtoa_r+0xa7e>
800111ae:	c2 f8       	rjmp	8001120c <_dtoa_r+0xa98>
800111b0:	40 69       	lddsp	r9,sp[0x18]
800111b2:	58 09       	cp.w	r9,0
800111b4:	c0 85       	brlt	800111c4 <_dtoa_r+0xa50>
800111b6:	12 98       	mov	r8,r9
800111b8:	40 cc       	lddsp	r12,sp[0x30]
800111ba:	18 48       	or	r8,r12
800111bc:	c1 d1       	brne	800111f6 <_dtoa_r+0xa82>
800111be:	40 db       	lddsp	r11,sp[0x34]
800111c0:	58 0b       	cp.w	r11,0
800111c2:	c1 a1       	brne	800111f6 <_dtoa_r+0xa82>
800111c4:	0c 99       	mov	r9,r6
800111c6:	40 26       	lddsp	r6,sp[0x8]
800111c8:	58 09       	cp.w	r9,0
800111ca:	e0 8a 00 21 	brle	8001120c <_dtoa_r+0xa98>
800111ce:	06 9b       	mov	r11,r3
800111d0:	30 1a       	mov	r10,1
800111d2:	0e 9c       	mov	r12,r7
800111d4:	e0 a0 06 92 	rcall	80011ef8 <__lshift>
800111d8:	04 9b       	mov	r11,r2
800111da:	18 93       	mov	r3,r12
800111dc:	e0 a0 05 6b 	rcall	80011cb2 <__mcmp>
800111e0:	e0 89 00 06 	brgt	800111ec <_dtoa_r+0xa78>
800111e4:	c1 41       	brne	8001120c <_dtoa_r+0xa98>
800111e6:	ed b0 00 00 	bld	r0,0x0
800111ea:	c1 11       	brne	8001120c <_dtoa_r+0xa98>
800111ec:	e0 40 00 39 	cp.w	r0,57
800111f0:	c0 a0       	breq	80011204 <_dtoa_r+0xa90>
800111f2:	2f f0       	sub	r0,-1
800111f4:	c0 c8       	rjmp	8001120c <_dtoa_r+0xa98>
800111f6:	58 06       	cp.w	r6,0
800111f8:	e0 8a 00 0c 	brle	80011210 <_dtoa_r+0xa9c>
800111fc:	40 26       	lddsp	r6,sp[0x8]
800111fe:	e0 40 00 39 	cp.w	r0,57
80011202:	c0 41       	brne	8001120a <_dtoa_r+0xa96>
80011204:	33 98       	mov	r8,57
80011206:	0a c8       	st.b	r5++,r8
80011208:	c6 78       	rjmp	800112d6 <_dtoa_r+0xb62>
8001120a:	2f f0       	sub	r0,-1
8001120c:	0a c0       	st.b	r5++,r0
8001120e:	c7 58       	rjmp	800112f8 <_dtoa_r+0xb84>
80011210:	0a c0       	st.b	r5++,r0
80011212:	40 9a       	lddsp	r10,sp[0x24]
80011214:	40 e9       	lddsp	r9,sp[0x38]
80011216:	12 3a       	cp.w	r10,r9
80011218:	c4 30       	breq	8001129e <_dtoa_r+0xb2a>
8001121a:	06 9b       	mov	r11,r3
8001121c:	30 09       	mov	r9,0
8001121e:	30 aa       	mov	r10,10
80011220:	0e 9c       	mov	r12,r7
80011222:	e0 a0 07 37 	rcall	80012090 <__multadd>
80011226:	40 48       	lddsp	r8,sp[0x10]
80011228:	18 93       	mov	r3,r12
8001122a:	08 38       	cp.w	r8,r4
8001122c:	c0 91       	brne	8001123e <_dtoa_r+0xaca>
8001122e:	10 9b       	mov	r11,r8
80011230:	30 09       	mov	r9,0
80011232:	30 aa       	mov	r10,10
80011234:	0e 9c       	mov	r12,r7
80011236:	e0 a0 07 2d 	rcall	80012090 <__multadd>
8001123a:	50 4c       	stdsp	sp[0x10],r12
8001123c:	c0 e8       	rjmp	80011258 <_dtoa_r+0xae4>
8001123e:	40 4b       	lddsp	r11,sp[0x10]
80011240:	30 09       	mov	r9,0
80011242:	30 aa       	mov	r10,10
80011244:	0e 9c       	mov	r12,r7
80011246:	e0 a0 07 25 	rcall	80012090 <__multadd>
8001124a:	08 9b       	mov	r11,r4
8001124c:	50 4c       	stdsp	sp[0x10],r12
8001124e:	30 09       	mov	r9,0
80011250:	30 aa       	mov	r10,10
80011252:	0e 9c       	mov	r12,r7
80011254:	e0 a0 07 1e 	rcall	80012090 <__multadd>
80011258:	18 94       	mov	r4,r12
8001125a:	40 9c       	lddsp	r12,sp[0x24]
8001125c:	2f fc       	sub	r12,-1
8001125e:	50 9c       	stdsp	sp[0x24],r12
80011260:	c7 9b       	rjmp	80011152 <_dtoa_r+0x9de>
80011262:	30 18       	mov	r8,1
80011264:	06 90       	mov	r0,r3
80011266:	40 85       	lddsp	r5,sp[0x20]
80011268:	08 93       	mov	r3,r4
8001126a:	0c 94       	mov	r4,r6
8001126c:	10 96       	mov	r6,r8
8001126e:	04 9b       	mov	r11,r2
80011270:	00 9c       	mov	r12,r0
80011272:	fe b0 f9 f1 	rcall	80010654 <quorem>
80011276:	2d 0c       	sub	r12,-48
80011278:	0a cc       	st.b	r5++,r12
8001127a:	02 36       	cp.w	r6,r1
8001127c:	c0 a4       	brge	80011290 <_dtoa_r+0xb1c>
8001127e:	00 9b       	mov	r11,r0
80011280:	30 09       	mov	r9,0
80011282:	30 aa       	mov	r10,10
80011284:	0e 9c       	mov	r12,r7
80011286:	2f f6       	sub	r6,-1
80011288:	e0 a0 07 04 	rcall	80012090 <__multadd>
8001128c:	18 90       	mov	r0,r12
8001128e:	cf 0b       	rjmp	8001126e <_dtoa_r+0xafa>
80011290:	08 96       	mov	r6,r4
80011292:	30 0b       	mov	r11,0
80011294:	06 94       	mov	r4,r3
80011296:	50 4b       	stdsp	sp[0x10],r11
80011298:	00 93       	mov	r3,r0
8001129a:	18 90       	mov	r0,r12
8001129c:	c0 28       	rjmp	800112a0 <_dtoa_r+0xb2c>
8001129e:	40 26       	lddsp	r6,sp[0x8]
800112a0:	06 9b       	mov	r11,r3
800112a2:	30 1a       	mov	r10,1
800112a4:	0e 9c       	mov	r12,r7
800112a6:	e0 a0 06 29 	rcall	80011ef8 <__lshift>
800112aa:	04 9b       	mov	r11,r2
800112ac:	18 93       	mov	r3,r12
800112ae:	e0 a0 05 02 	rcall	80011cb2 <__mcmp>
800112b2:	e0 89 00 12 	brgt	800112d6 <_dtoa_r+0xb62>
800112b6:	c1 b1       	brne	800112ec <_dtoa_r+0xb78>
800112b8:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
800112bc:	c0 d1       	brne	800112d6 <_dtoa_r+0xb62>
800112be:	c1 78       	rjmp	800112ec <_dtoa_r+0xb78>
800112c0:	40 89       	lddsp	r9,sp[0x20]
800112c2:	12 38       	cp.w	r8,r9
800112c4:	c0 30       	breq	800112ca <_dtoa_r+0xb56>
800112c6:	10 95       	mov	r5,r8
800112c8:	c0 88       	rjmp	800112d8 <_dtoa_r+0xb64>
800112ca:	2f f6       	sub	r6,-1
800112cc:	50 66       	stdsp	sp[0x18],r6
800112ce:	33 18       	mov	r8,49
800112d0:	40 8c       	lddsp	r12,sp[0x20]
800112d2:	b8 88       	st.b	r12[0x0],r8
800112d4:	c1 38       	rjmp	800112fa <_dtoa_r+0xb86>
800112d6:	33 9a       	mov	r10,57
800112d8:	0a 98       	mov	r8,r5
800112da:	11 79       	ld.ub	r9,--r8
800112dc:	f4 09 18 00 	cp.b	r9,r10
800112e0:	cf 00       	breq	800112c0 <_dtoa_r+0xb4c>
800112e2:	2f f9       	sub	r9,-1
800112e4:	b0 89       	st.b	r8[0x0],r9
800112e6:	c0 98       	rjmp	800112f8 <_dtoa_r+0xb84>
800112e8:	10 95       	mov	r5,r8
800112ea:	c0 28       	rjmp	800112ee <_dtoa_r+0xb7a>
800112ec:	33 09       	mov	r9,48
800112ee:	0a 98       	mov	r8,r5
800112f0:	11 7a       	ld.ub	r10,--r8
800112f2:	f2 0a 18 00 	cp.b	r10,r9
800112f6:	cf 90       	breq	800112e8 <_dtoa_r+0xb74>
800112f8:	50 66       	stdsp	sp[0x18],r6
800112fa:	04 9b       	mov	r11,r2
800112fc:	0e 9c       	mov	r12,r7
800112fe:	e0 a0 04 f3 	rcall	80011ce4 <_Bfree>
80011302:	58 04       	cp.w	r4,0
80011304:	c1 20       	breq	80011328 <_dtoa_r+0xbb4>
80011306:	40 4b       	lddsp	r11,sp[0x10]
80011308:	08 3b       	cp.w	r11,r4
8001130a:	5f 19       	srne	r9
8001130c:	58 0b       	cp.w	r11,0
8001130e:	5f 18       	srne	r8
80011310:	f3 e8 00 08 	and	r8,r9,r8
80011314:	c0 40       	breq	8001131c <_dtoa_r+0xba8>
80011316:	0e 9c       	mov	r12,r7
80011318:	e0 a0 04 e6 	rcall	80011ce4 <_Bfree>
8001131c:	08 9b       	mov	r11,r4
8001131e:	0e 9c       	mov	r12,r7
80011320:	e0 a0 04 e2 	rcall	80011ce4 <_Bfree>
80011324:	c0 28       	rjmp	80011328 <_dtoa_r+0xbb4>
80011326:	50 66       	stdsp	sp[0x18],r6
80011328:	0e 9c       	mov	r12,r7
8001132a:	06 9b       	mov	r11,r3
8001132c:	e0 a0 04 dc 	rcall	80011ce4 <_Bfree>
80011330:	30 08       	mov	r8,0
80011332:	aa 88       	st.b	r5[0x0],r8
80011334:	40 68       	lddsp	r8,sp[0x18]
80011336:	41 5a       	lddsp	r10,sp[0x54]
80011338:	2f f8       	sub	r8,-1
8001133a:	41 29       	lddsp	r9,sp[0x48]
8001133c:	95 08       	st.w	r10[0x0],r8
8001133e:	40 8c       	lddsp	r12,sp[0x20]
80011340:	58 09       	cp.w	r9,0
80011342:	fb f8 10 12 	ld.wne	r8,sp[0x48]
80011346:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8001134a:	2e 6d       	sub	sp,-104
8001134c:	d8 32       	popm	r0-r7,pc
8001134e:	d7 03       	nop

80011350 <__errno>:
80011350:	e0 68 02 2c 	mov	r8,556
80011354:	70 0c       	ld.w	r12,r8[0x0]
80011356:	2f 4c       	sub	r12,-12
80011358:	5e fc       	retal	r12
8001135a:	d7 03       	nop

8001135c <_fflush_r>:
8001135c:	d4 21       	pushm	r4-r7,lr
8001135e:	16 97       	mov	r7,r11
80011360:	18 96       	mov	r6,r12
80011362:	76 48       	ld.w	r8,r11[0x10]
80011364:	58 08       	cp.w	r8,0
80011366:	c7 f0       	breq	80011464 <_fflush_r+0x108>
80011368:	58 0c       	cp.w	r12,0
8001136a:	c0 50       	breq	80011374 <_fflush_r+0x18>
8001136c:	78 68       	ld.w	r8,r12[0x18]
8001136e:	58 08       	cp.w	r8,0
80011370:	c0 21       	brne	80011374 <_fflush_r+0x18>
80011372:	cc dc       	rcall	8001150c <__sinit>
80011374:	fe c8 a5 d0 	sub	r8,pc,-23088
80011378:	10 37       	cp.w	r7,r8
8001137a:	c0 31       	brne	80011380 <_fflush_r+0x24>
8001137c:	6c 07       	ld.w	r7,r6[0x0]
8001137e:	c0 c8       	rjmp	80011396 <_fflush_r+0x3a>
80011380:	fe c8 a5 bc 	sub	r8,pc,-23108
80011384:	10 37       	cp.w	r7,r8
80011386:	c0 31       	brne	8001138c <_fflush_r+0x30>
80011388:	6c 17       	ld.w	r7,r6[0x4]
8001138a:	c0 68       	rjmp	80011396 <_fflush_r+0x3a>
8001138c:	fe c8 a5 a8 	sub	r8,pc,-23128
80011390:	10 37       	cp.w	r7,r8
80011392:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80011396:	8e 6a       	ld.sh	r10,r7[0xc]
80011398:	14 98       	mov	r8,r10
8001139a:	ed ba 00 03 	bld	r10,0x3
8001139e:	c4 20       	breq	80011422 <_fflush_r+0xc6>
800113a0:	ab ba       	sbr	r10,0xb
800113a2:	ae 6a       	st.h	r7[0xc],r10
800113a4:	6e 18       	ld.w	r8,r7[0x4]
800113a6:	58 08       	cp.w	r8,0
800113a8:	e0 89 00 06 	brgt	800113b4 <_fflush_r+0x58>
800113ac:	6f 08       	ld.w	r8,r7[0x40]
800113ae:	58 08       	cp.w	r8,0
800113b0:	e0 8a 00 5a 	brle	80011464 <_fflush_r+0x108>
800113b4:	6e b8       	ld.w	r8,r7[0x2c]
800113b6:	58 08       	cp.w	r8,0
800113b8:	c5 60       	breq	80011464 <_fflush_r+0x108>
800113ba:	e2 1a 10 00 	andl	r10,0x1000,COH
800113be:	c0 30       	breq	800113c4 <_fflush_r+0x68>
800113c0:	6f 55       	ld.w	r5,r7[0x54]
800113c2:	c0 f8       	rjmp	800113e0 <_fflush_r+0x84>
800113c4:	30 19       	mov	r9,1
800113c6:	6e 8b       	ld.w	r11,r7[0x20]
800113c8:	0c 9c       	mov	r12,r6
800113ca:	5d 18       	icall	r8
800113cc:	18 95       	mov	r5,r12
800113ce:	5b fc       	cp.w	r12,-1
800113d0:	c0 81       	brne	800113e0 <_fflush_r+0x84>
800113d2:	6c 38       	ld.w	r8,r6[0xc]
800113d4:	59 d8       	cp.w	r8,29
800113d6:	c4 70       	breq	80011464 <_fflush_r+0x108>
800113d8:	8e 68       	ld.sh	r8,r7[0xc]
800113da:	a7 a8       	sbr	r8,0x6
800113dc:	ae 68       	st.h	r7[0xc],r8
800113de:	d8 22       	popm	r4-r7,pc
800113e0:	8e 68       	ld.sh	r8,r7[0xc]
800113e2:	ed b8 00 02 	bld	r8,0x2
800113e6:	c0 91       	brne	800113f8 <_fflush_r+0x9c>
800113e8:	6e 18       	ld.w	r8,r7[0x4]
800113ea:	10 15       	sub	r5,r8
800113ec:	6e d8       	ld.w	r8,r7[0x34]
800113ee:	58 08       	cp.w	r8,0
800113f0:	ef f8 10 10 	ld.wne	r8,r7[0x40]
800113f4:	eb d8 e1 15 	subne	r5,r5,r8
800113f8:	6e b8       	ld.w	r8,r7[0x2c]
800113fa:	0c 9c       	mov	r12,r6
800113fc:	30 09       	mov	r9,0
800113fe:	0a 9a       	mov	r10,r5
80011400:	6e 8b       	ld.w	r11,r7[0x20]
80011402:	5d 18       	icall	r8
80011404:	8e 68       	ld.sh	r8,r7[0xc]
80011406:	0a 3c       	cp.w	r12,r5
80011408:	c2 61       	brne	80011454 <_fflush_r+0xf8>
8001140a:	ab d8       	cbr	r8,0xb
8001140c:	30 0c       	mov	r12,0
8001140e:	6e 49       	ld.w	r9,r7[0x10]
80011410:	ae 68       	st.h	r7[0xc],r8
80011412:	8f 1c       	st.w	r7[0x4],r12
80011414:	8f 09       	st.w	r7[0x0],r9
80011416:	ed b8 00 0c 	bld	r8,0xc
8001141a:	c2 51       	brne	80011464 <_fflush_r+0x108>
8001141c:	ef 45 00 54 	st.w	r7[84],r5
80011420:	d8 22       	popm	r4-r7,pc
80011422:	6e 45       	ld.w	r5,r7[0x10]
80011424:	58 05       	cp.w	r5,0
80011426:	c1 f0       	breq	80011464 <_fflush_r+0x108>
80011428:	6e 04       	ld.w	r4,r7[0x0]
8001142a:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8001142e:	8f 05       	st.w	r7[0x0],r5
80011430:	f9 b8 01 00 	movne	r8,0
80011434:	ef f8 00 05 	ld.weq	r8,r7[0x14]
80011438:	0a 14       	sub	r4,r5
8001143a:	8f 28       	st.w	r7[0x8],r8
8001143c:	c1 18       	rjmp	8001145e <_fflush_r+0x102>
8001143e:	08 99       	mov	r9,r4
80011440:	0a 9a       	mov	r10,r5
80011442:	6e a8       	ld.w	r8,r7[0x28]
80011444:	6e 8b       	ld.w	r11,r7[0x20]
80011446:	0c 9c       	mov	r12,r6
80011448:	5d 18       	icall	r8
8001144a:	18 14       	sub	r4,r12
8001144c:	58 0c       	cp.w	r12,0
8001144e:	e0 89 00 07 	brgt	8001145c <_fflush_r+0x100>
80011452:	8e 68       	ld.sh	r8,r7[0xc]
80011454:	a7 a8       	sbr	r8,0x6
80011456:	3f fc       	mov	r12,-1
80011458:	ae 68       	st.h	r7[0xc],r8
8001145a:	d8 22       	popm	r4-r7,pc
8001145c:	18 05       	add	r5,r12
8001145e:	58 04       	cp.w	r4,0
80011460:	fe 99 ff ef 	brgt	8001143e <_fflush_r+0xe2>
80011464:	d8 2a       	popm	r4-r7,pc,r12=0
80011466:	d7 03       	nop

80011468 <__sfp_lock_acquire>:
80011468:	5e fc       	retal	r12

8001146a <__sfp_lock_release>:
8001146a:	5e fc       	retal	r12

8001146c <_cleanup_r>:
8001146c:	d4 01       	pushm	lr
8001146e:	fe cb ed 66 	sub	r11,pc,-4762
80011472:	e0 a0 02 f7 	rcall	80011a60 <_fwalk>
80011476:	d8 02       	popm	pc

80011478 <__sfmoreglue>:
80011478:	d4 21       	pushm	r4-r7,lr
8001147a:	16 95       	mov	r5,r11
8001147c:	f6 06 10 5c 	mul	r6,r11,92
80011480:	ec cb ff f4 	sub	r11,r6,-12
80011484:	fe b0 d6 c4 	rcall	8000c20c <_malloc_r>
80011488:	18 97       	mov	r7,r12
8001148a:	c0 90       	breq	8001149c <__sfmoreglue+0x24>
8001148c:	99 15       	st.w	r12[0x4],r5
8001148e:	30 0b       	mov	r11,0
80011490:	2f 4c       	sub	r12,-12
80011492:	0c 9a       	mov	r10,r6
80011494:	8f 2c       	st.w	r7[0x8],r12
80011496:	8f 0b       	st.w	r7[0x0],r11
80011498:	fe b0 d9 74 	rcall	8000c780 <memset>
8001149c:	0e 9c       	mov	r12,r7
8001149e:	d8 22       	popm	r4-r7,pc

800114a0 <__sfp>:
800114a0:	d4 21       	pushm	r4-r7,lr
800114a2:	fe c8 ad 16 	sub	r8,pc,-21226
800114a6:	18 96       	mov	r6,r12
800114a8:	70 07       	ld.w	r7,r8[0x0]
800114aa:	6e 68       	ld.w	r8,r7[0x18]
800114ac:	58 08       	cp.w	r8,0
800114ae:	c0 31       	brne	800114b4 <__sfp+0x14>
800114b0:	0e 9c       	mov	r12,r7
800114b2:	c2 dc       	rcall	8001150c <__sinit>
800114b4:	ee c7 ff 28 	sub	r7,r7,-216
800114b8:	30 05       	mov	r5,0
800114ba:	6e 2c       	ld.w	r12,r7[0x8]
800114bc:	6e 18       	ld.w	r8,r7[0x4]
800114be:	c0 68       	rjmp	800114ca <__sfp+0x2a>
800114c0:	98 69       	ld.sh	r9,r12[0xc]
800114c2:	ea 09 19 00 	cp.h	r9,r5
800114c6:	c1 10       	breq	800114e8 <__sfp+0x48>
800114c8:	2a 4c       	sub	r12,-92
800114ca:	20 18       	sub	r8,1
800114cc:	cf a7       	brpl	800114c0 <__sfp+0x20>
800114ce:	6e 08       	ld.w	r8,r7[0x0]
800114d0:	58 08       	cp.w	r8,0
800114d2:	c0 61       	brne	800114de <__sfp+0x3e>
800114d4:	30 4b       	mov	r11,4
800114d6:	0c 9c       	mov	r12,r6
800114d8:	cd 0f       	rcall	80011478 <__sfmoreglue>
800114da:	8f 0c       	st.w	r7[0x0],r12
800114dc:	c0 30       	breq	800114e2 <__sfp+0x42>
800114de:	6e 07       	ld.w	r7,r7[0x0]
800114e0:	ce db       	rjmp	800114ba <__sfp+0x1a>
800114e2:	30 c8       	mov	r8,12
800114e4:	8d 38       	st.w	r6[0xc],r8
800114e6:	d8 22       	popm	r4-r7,pc
800114e8:	30 08       	mov	r8,0
800114ea:	f9 48 00 4c 	st.w	r12[76],r8
800114ee:	99 08       	st.w	r12[0x0],r8
800114f0:	99 28       	st.w	r12[0x8],r8
800114f2:	99 18       	st.w	r12[0x4],r8
800114f4:	99 48       	st.w	r12[0x10],r8
800114f6:	99 58       	st.w	r12[0x14],r8
800114f8:	99 68       	st.w	r12[0x18],r8
800114fa:	99 d8       	st.w	r12[0x34],r8
800114fc:	99 e8       	st.w	r12[0x38],r8
800114fe:	f9 48 00 48 	st.w	r12[72],r8
80011502:	3f f8       	mov	r8,-1
80011504:	b8 78       	st.h	r12[0xe],r8
80011506:	30 18       	mov	r8,1
80011508:	b8 68       	st.h	r12[0xc],r8
8001150a:	d8 22       	popm	r4-r7,pc

8001150c <__sinit>:
8001150c:	d4 21       	pushm	r4-r7,lr
8001150e:	18 96       	mov	r6,r12
80011510:	78 67       	ld.w	r7,r12[0x18]
80011512:	58 07       	cp.w	r7,0
80011514:	c4 91       	brne	800115a6 <__sinit+0x9a>
80011516:	fe c8 00 aa 	sub	r8,pc,170
8001151a:	30 15       	mov	r5,1
8001151c:	99 a8       	st.w	r12[0x28],r8
8001151e:	f9 47 00 d8 	st.w	r12[216],r7
80011522:	f9 47 00 dc 	st.w	r12[220],r7
80011526:	f9 47 00 e0 	st.w	r12[224],r7
8001152a:	99 65       	st.w	r12[0x18],r5
8001152c:	cb af       	rcall	800114a0 <__sfp>
8001152e:	8d 0c       	st.w	r6[0x0],r12
80011530:	0c 9c       	mov	r12,r6
80011532:	cb 7f       	rcall	800114a0 <__sfp>
80011534:	8d 1c       	st.w	r6[0x4],r12
80011536:	0c 9c       	mov	r12,r6
80011538:	cb 4f       	rcall	800114a0 <__sfp>
8001153a:	6c 09       	ld.w	r9,r6[0x0]
8001153c:	30 48       	mov	r8,4
8001153e:	93 07       	st.w	r9[0x0],r7
80011540:	b2 68       	st.h	r9[0xc],r8
80011542:	93 17       	st.w	r9[0x4],r7
80011544:	93 27       	st.w	r9[0x8],r7
80011546:	6c 18       	ld.w	r8,r6[0x4]
80011548:	b2 77       	st.h	r9[0xe],r7
8001154a:	93 47       	st.w	r9[0x10],r7
8001154c:	93 57       	st.w	r9[0x14],r7
8001154e:	93 67       	st.w	r9[0x18],r7
80011550:	93 89       	st.w	r9[0x20],r9
80011552:	91 07       	st.w	r8[0x0],r7
80011554:	91 17       	st.w	r8[0x4],r7
80011556:	91 27       	st.w	r8[0x8],r7
80011558:	fe ce ef dc 	sub	lr,pc,-4132
8001155c:	fe cb f0 0c 	sub	r11,pc,-4084
80011560:	93 9e       	st.w	r9[0x24],lr
80011562:	93 ab       	st.w	r9[0x28],r11
80011564:	fe ca f0 34 	sub	r10,pc,-4044
80011568:	fe c4 f0 40 	sub	r4,pc,-4032
8001156c:	93 ba       	st.w	r9[0x2c],r10
8001156e:	93 c4       	st.w	r9[0x30],r4
80011570:	30 99       	mov	r9,9
80011572:	b0 69       	st.h	r8[0xc],r9
80011574:	b0 75       	st.h	r8[0xe],r5
80011576:	91 c4       	st.w	r8[0x30],r4
80011578:	91 47       	st.w	r8[0x10],r7
8001157a:	91 57       	st.w	r8[0x14],r7
8001157c:	91 67       	st.w	r8[0x18],r7
8001157e:	91 88       	st.w	r8[0x20],r8
80011580:	91 9e       	st.w	r8[0x24],lr
80011582:	91 ab       	st.w	r8[0x28],r11
80011584:	91 ba       	st.w	r8[0x2c],r10
80011586:	8d 2c       	st.w	r6[0x8],r12
80011588:	31 28       	mov	r8,18
8001158a:	99 07       	st.w	r12[0x0],r7
8001158c:	b8 68       	st.h	r12[0xc],r8
8001158e:	99 17       	st.w	r12[0x4],r7
80011590:	99 27       	st.w	r12[0x8],r7
80011592:	30 28       	mov	r8,2
80011594:	b8 78       	st.h	r12[0xe],r8
80011596:	99 c4       	st.w	r12[0x30],r4
80011598:	99 67       	st.w	r12[0x18],r7
8001159a:	99 9e       	st.w	r12[0x24],lr
8001159c:	99 ab       	st.w	r12[0x28],r11
8001159e:	99 ba       	st.w	r12[0x2c],r10
800115a0:	99 47       	st.w	r12[0x10],r7
800115a2:	99 57       	st.w	r12[0x14],r7
800115a4:	99 8c       	st.w	r12[0x20],r12
800115a6:	d8 22       	popm	r4-r7,pc

800115a8 <_malloc_trim_r>:
800115a8:	d4 21       	pushm	r4-r7,lr
800115aa:	16 95       	mov	r5,r11
800115ac:	18 97       	mov	r7,r12
800115ae:	fe b0 d8 f0 	rcall	8000c78e <__malloc_lock>
800115b2:	e0 64 02 30 	mov	r4,560
800115b6:	68 28       	ld.w	r8,r4[0x8]
800115b8:	70 16       	ld.w	r6,r8[0x4]
800115ba:	e0 16 ff fc 	andl	r6,0xfffc
800115be:	ec c8 ff 91 	sub	r8,r6,-111
800115c2:	f0 05 01 05 	sub	r5,r8,r5
800115c6:	e0 15 ff 80 	andl	r5,0xff80
800115ca:	ea c5 00 80 	sub	r5,r5,128
800115ce:	e0 45 00 7f 	cp.w	r5,127
800115d2:	e0 8a 00 25 	brle	8001161c <_malloc_trim_r+0x74>
800115d6:	30 0b       	mov	r11,0
800115d8:	0e 9c       	mov	r12,r7
800115da:	fe b0 d8 f3 	rcall	8000c7c0 <_sbrk_r>
800115de:	68 28       	ld.w	r8,r4[0x8]
800115e0:	0c 08       	add	r8,r6
800115e2:	10 3c       	cp.w	r12,r8
800115e4:	c1 c1       	brne	8001161c <_malloc_trim_r+0x74>
800115e6:	ea 0b 11 00 	rsub	r11,r5,0
800115ea:	0e 9c       	mov	r12,r7
800115ec:	fe b0 d8 ea 	rcall	8000c7c0 <_sbrk_r>
800115f0:	5b fc       	cp.w	r12,-1
800115f2:	c1 91       	brne	80011624 <_malloc_trim_r+0x7c>
800115f4:	30 0b       	mov	r11,0
800115f6:	0e 9c       	mov	r12,r7
800115f8:	fe b0 d8 e4 	rcall	8000c7c0 <_sbrk_r>
800115fc:	68 28       	ld.w	r8,r4[0x8]
800115fe:	f8 08 01 09 	sub	r9,r12,r8
80011602:	58 f9       	cp.w	r9,15
80011604:	e0 8a 00 0c 	brle	8001161c <_malloc_trim_r+0x74>
80011608:	a1 a9       	sbr	r9,0x0
8001160a:	91 19       	st.w	r8[0x4],r9
8001160c:	e0 68 06 3c 	mov	r8,1596
80011610:	70 09       	ld.w	r9,r8[0x0]
80011612:	e0 68 07 7c 	mov	r8,1916
80011616:	f8 09 01 09 	sub	r9,r12,r9
8001161a:	91 09       	st.w	r8[0x0],r9
8001161c:	0e 9c       	mov	r12,r7
8001161e:	fe b0 d8 b9 	rcall	8000c790 <__malloc_unlock>
80011622:	d8 2a       	popm	r4-r7,pc,r12=0
80011624:	68 28       	ld.w	r8,r4[0x8]
80011626:	0a 16       	sub	r6,r5
80011628:	a1 a6       	sbr	r6,0x0
8001162a:	91 16       	st.w	r8[0x4],r6
8001162c:	e0 68 07 7c 	mov	r8,1916
80011630:	70 09       	ld.w	r9,r8[0x0]
80011632:	0a 19       	sub	r9,r5
80011634:	0e 9c       	mov	r12,r7
80011636:	91 09       	st.w	r8[0x0],r9
80011638:	fe b0 d8 ac 	rcall	8000c790 <__malloc_unlock>
8001163c:	da 2a       	popm	r4-r7,pc,r12=1
8001163e:	d7 03       	nop

80011640 <_free_r>:
80011640:	d4 21       	pushm	r4-r7,lr
80011642:	16 96       	mov	r6,r11
80011644:	18 97       	mov	r7,r12
80011646:	58 0b       	cp.w	r11,0
80011648:	e0 80 00 c0 	breq	800117c8 <_free_r+0x188>
8001164c:	fe b0 d8 a1 	rcall	8000c78e <__malloc_lock>
80011650:	20 86       	sub	r6,8
80011652:	e0 6a 02 30 	mov	r10,560
80011656:	6c 18       	ld.w	r8,r6[0x4]
80011658:	74 2e       	ld.w	lr,r10[0x8]
8001165a:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8001165e:	a1 c8       	cbr	r8,0x0
80011660:	ec 08 00 09 	add	r9,r6,r8
80011664:	72 1b       	ld.w	r11,r9[0x4]
80011666:	e0 1b ff fc 	andl	r11,0xfffc
8001166a:	1c 39       	cp.w	r9,lr
8001166c:	c1 e1       	brne	800116a8 <_free_r+0x68>
8001166e:	f6 08 00 08 	add	r8,r11,r8
80011672:	58 0c       	cp.w	r12,0
80011674:	c0 81       	brne	80011684 <_free_r+0x44>
80011676:	6c 09       	ld.w	r9,r6[0x0]
80011678:	12 16       	sub	r6,r9
8001167a:	12 08       	add	r8,r9
8001167c:	6c 3b       	ld.w	r11,r6[0xc]
8001167e:	6c 29       	ld.w	r9,r6[0x8]
80011680:	97 29       	st.w	r11[0x8],r9
80011682:	93 3b       	st.w	r9[0xc],r11
80011684:	10 99       	mov	r9,r8
80011686:	95 26       	st.w	r10[0x8],r6
80011688:	a1 a9       	sbr	r9,0x0
8001168a:	8d 19       	st.w	r6[0x4],r9
8001168c:	e0 69 06 38 	mov	r9,1592
80011690:	72 09       	ld.w	r9,r9[0x0]
80011692:	12 38       	cp.w	r8,r9
80011694:	c0 63       	brcs	800116a0 <_free_r+0x60>
80011696:	e0 68 07 78 	mov	r8,1912
8001169a:	0e 9c       	mov	r12,r7
8001169c:	70 0b       	ld.w	r11,r8[0x0]
8001169e:	c8 5f       	rcall	800115a8 <_malloc_trim_r>
800116a0:	0e 9c       	mov	r12,r7
800116a2:	fe b0 d8 77 	rcall	8000c790 <__malloc_unlock>
800116a6:	d8 22       	popm	r4-r7,pc
800116a8:	93 1b       	st.w	r9[0x4],r11
800116aa:	58 0c       	cp.w	r12,0
800116ac:	c0 30       	breq	800116b2 <_free_r+0x72>
800116ae:	30 0c       	mov	r12,0
800116b0:	c1 08       	rjmp	800116d0 <_free_r+0x90>
800116b2:	6c 0e       	ld.w	lr,r6[0x0]
800116b4:	f4 c5 ff f8 	sub	r5,r10,-8
800116b8:	1c 16       	sub	r6,lr
800116ba:	1c 08       	add	r8,lr
800116bc:	6c 2e       	ld.w	lr,r6[0x8]
800116be:	0a 3e       	cp.w	lr,r5
800116c0:	f9 bc 00 01 	moveq	r12,1
800116c4:	ed f5 10 03 	ld.wne	r5,r6[0xc]
800116c8:	eb fe 1a 02 	st.wne	r5[0x8],lr
800116cc:	fd f5 1a 03 	st.wne	lr[0xc],r5
800116d0:	f2 0b 00 0e 	add	lr,r9,r11
800116d4:	7c 1e       	ld.w	lr,lr[0x4]
800116d6:	ed be 00 00 	bld	lr,0x0
800116da:	c1 40       	breq	80011702 <_free_r+0xc2>
800116dc:	16 08       	add	r8,r11
800116de:	58 0c       	cp.w	r12,0
800116e0:	c0 d1       	brne	800116fa <_free_r+0xba>
800116e2:	e0 6e 02 30 	mov	lr,560
800116e6:	72 2b       	ld.w	r11,r9[0x8]
800116e8:	2f 8e       	sub	lr,-8
800116ea:	1c 3b       	cp.w	r11,lr
800116ec:	c0 71       	brne	800116fa <_free_r+0xba>
800116ee:	97 36       	st.w	r11[0xc],r6
800116f0:	97 26       	st.w	r11[0x8],r6
800116f2:	8d 2b       	st.w	r6[0x8],r11
800116f4:	8d 3b       	st.w	r6[0xc],r11
800116f6:	30 1c       	mov	r12,1
800116f8:	c0 58       	rjmp	80011702 <_free_r+0xc2>
800116fa:	72 2b       	ld.w	r11,r9[0x8]
800116fc:	72 39       	ld.w	r9,r9[0xc]
800116fe:	93 2b       	st.w	r9[0x8],r11
80011700:	97 39       	st.w	r11[0xc],r9
80011702:	10 99       	mov	r9,r8
80011704:	ec 08 09 08 	st.w	r6[r8],r8
80011708:	a1 a9       	sbr	r9,0x0
8001170a:	8d 19       	st.w	r6[0x4],r9
8001170c:	58 0c       	cp.w	r12,0
8001170e:	c5 a1       	brne	800117c2 <_free_r+0x182>
80011710:	e0 48 01 ff 	cp.w	r8,511
80011714:	e0 8b 00 13 	brhi	8001173a <_free_r+0xfa>
80011718:	a3 98       	lsr	r8,0x3
8001171a:	f4 08 00 39 	add	r9,r10,r8<<0x3
8001171e:	72 2b       	ld.w	r11,r9[0x8]
80011720:	8d 39       	st.w	r6[0xc],r9
80011722:	8d 2b       	st.w	r6[0x8],r11
80011724:	97 36       	st.w	r11[0xc],r6
80011726:	93 26       	st.w	r9[0x8],r6
80011728:	a3 48       	asr	r8,0x2
8001172a:	74 19       	ld.w	r9,r10[0x4]
8001172c:	30 1b       	mov	r11,1
8001172e:	f6 08 09 48 	lsl	r8,r11,r8
80011732:	f3 e8 10 08 	or	r8,r9,r8
80011736:	95 18       	st.w	r10[0x4],r8
80011738:	c4 58       	rjmp	800117c2 <_free_r+0x182>
8001173a:	f0 0b 16 09 	lsr	r11,r8,0x9
8001173e:	58 4b       	cp.w	r11,4
80011740:	e0 8b 00 06 	brhi	8001174c <_free_r+0x10c>
80011744:	f0 0b 16 06 	lsr	r11,r8,0x6
80011748:	2c 8b       	sub	r11,-56
8001174a:	c2 08       	rjmp	8001178a <_free_r+0x14a>
8001174c:	59 4b       	cp.w	r11,20
8001174e:	e0 8b 00 04 	brhi	80011756 <_free_r+0x116>
80011752:	2a 5b       	sub	r11,-91
80011754:	c1 b8       	rjmp	8001178a <_free_r+0x14a>
80011756:	e0 4b 00 54 	cp.w	r11,84
8001175a:	e0 8b 00 06 	brhi	80011766 <_free_r+0x126>
8001175e:	f0 0b 16 0c 	lsr	r11,r8,0xc
80011762:	29 2b       	sub	r11,-110
80011764:	c1 38       	rjmp	8001178a <_free_r+0x14a>
80011766:	e0 4b 01 54 	cp.w	r11,340
8001176a:	e0 8b 00 06 	brhi	80011776 <_free_r+0x136>
8001176e:	f0 0b 16 0f 	lsr	r11,r8,0xf
80011772:	28 9b       	sub	r11,-119
80011774:	c0 b8       	rjmp	8001178a <_free_r+0x14a>
80011776:	e0 4b 05 54 	cp.w	r11,1364
8001177a:	e0 88 00 05 	brls	80011784 <_free_r+0x144>
8001177e:	37 eb       	mov	r11,126
80011780:	c0 58       	rjmp	8001178a <_free_r+0x14a>
80011782:	d7 03       	nop
80011784:	f0 0b 16 12 	lsr	r11,r8,0x12
80011788:	28 4b       	sub	r11,-124
8001178a:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8001178e:	78 29       	ld.w	r9,r12[0x8]
80011790:	18 39       	cp.w	r9,r12
80011792:	c0 e1       	brne	800117ae <_free_r+0x16e>
80011794:	74 18       	ld.w	r8,r10[0x4]
80011796:	a3 4b       	asr	r11,0x2
80011798:	30 1c       	mov	r12,1
8001179a:	f8 0b 09 4b 	lsl	r11,r12,r11
8001179e:	f1 eb 10 0b 	or	r11,r8,r11
800117a2:	12 98       	mov	r8,r9
800117a4:	95 1b       	st.w	r10[0x4],r11
800117a6:	c0 a8       	rjmp	800117ba <_free_r+0x17a>
800117a8:	72 29       	ld.w	r9,r9[0x8]
800117aa:	18 39       	cp.w	r9,r12
800117ac:	c0 60       	breq	800117b8 <_free_r+0x178>
800117ae:	72 1a       	ld.w	r10,r9[0x4]
800117b0:	e0 1a ff fc 	andl	r10,0xfffc
800117b4:	14 38       	cp.w	r8,r10
800117b6:	cf 93       	brcs	800117a8 <_free_r+0x168>
800117b8:	72 38       	ld.w	r8,r9[0xc]
800117ba:	8d 38       	st.w	r6[0xc],r8
800117bc:	8d 29       	st.w	r6[0x8],r9
800117be:	93 36       	st.w	r9[0xc],r6
800117c0:	91 26       	st.w	r8[0x8],r6
800117c2:	0e 9c       	mov	r12,r7
800117c4:	fe b0 d7 e6 	rcall	8000c790 <__malloc_unlock>
800117c8:	d8 22       	popm	r4-r7,pc
800117ca:	d7 03       	nop

800117cc <__sfvwrite_r>:
800117cc:	d4 31       	pushm	r0-r7,lr
800117ce:	20 3d       	sub	sp,12
800117d0:	14 94       	mov	r4,r10
800117d2:	18 95       	mov	r5,r12
800117d4:	16 97       	mov	r7,r11
800117d6:	74 28       	ld.w	r8,r10[0x8]
800117d8:	58 08       	cp.w	r8,0
800117da:	e0 80 01 40 	breq	80011a5a <__sfvwrite_r+0x28e>
800117de:	96 68       	ld.sh	r8,r11[0xc]
800117e0:	ed b8 00 03 	bld	r8,0x3
800117e4:	c0 41       	brne	800117ec <__sfvwrite_r+0x20>
800117e6:	76 48       	ld.w	r8,r11[0x10]
800117e8:	58 08       	cp.w	r8,0
800117ea:	c0 c1       	brne	80011802 <__sfvwrite_r+0x36>
800117ec:	0e 9b       	mov	r11,r7
800117ee:	0a 9c       	mov	r12,r5
800117f0:	fe b0 f6 bc 	rcall	80010568 <__swsetup_r>
800117f4:	c0 70       	breq	80011802 <__sfvwrite_r+0x36>
800117f6:	8e 68       	ld.sh	r8,r7[0xc]
800117f8:	a7 a8       	sbr	r8,0x6
800117fa:	ae 68       	st.h	r7[0xc],r8
800117fc:	30 98       	mov	r8,9
800117fe:	8b 38       	st.w	r5[0xc],r8
80011800:	c2 b9       	rjmp	80011a56 <__sfvwrite_r+0x28a>
80011802:	8e 63       	ld.sh	r3,r7[0xc]
80011804:	68 00       	ld.w	r0,r4[0x0]
80011806:	06 96       	mov	r6,r3
80011808:	e2 16 00 02 	andl	r6,0x2,COH
8001180c:	c2 10       	breq	8001184e <__sfvwrite_r+0x82>
8001180e:	30 03       	mov	r3,0
80011810:	e0 62 04 00 	mov	r2,1024
80011814:	06 96       	mov	r6,r3
80011816:	c0 48       	rjmp	8001181e <__sfvwrite_r+0x52>
80011818:	60 03       	ld.w	r3,r0[0x0]
8001181a:	60 16       	ld.w	r6,r0[0x4]
8001181c:	2f 80       	sub	r0,-8
8001181e:	58 06       	cp.w	r6,0
80011820:	cf c0       	breq	80011818 <__sfvwrite_r+0x4c>
80011822:	e0 46 04 00 	cp.w	r6,1024
80011826:	ec 09 17 80 	movls	r9,r6
8001182a:	e4 09 17 b0 	movhi	r9,r2
8001182e:	06 9a       	mov	r10,r3
80011830:	6e a8       	ld.w	r8,r7[0x28]
80011832:	6e 8b       	ld.w	r11,r7[0x20]
80011834:	0a 9c       	mov	r12,r5
80011836:	5d 18       	icall	r8
80011838:	18 16       	sub	r6,r12
8001183a:	58 0c       	cp.w	r12,0
8001183c:	e0 8a 01 0a 	brle	80011a50 <__sfvwrite_r+0x284>
80011840:	68 28       	ld.w	r8,r4[0x8]
80011842:	18 18       	sub	r8,r12
80011844:	89 28       	st.w	r4[0x8],r8
80011846:	e0 80 01 0a 	breq	80011a5a <__sfvwrite_r+0x28e>
8001184a:	18 03       	add	r3,r12
8001184c:	ce 9b       	rjmp	8001181e <__sfvwrite_r+0x52>
8001184e:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
80011852:	c0 70       	breq	80011860 <__sfvwrite_r+0x94>
80011854:	50 06       	stdsp	sp[0x0],r6
80011856:	0c 93       	mov	r3,r6
80011858:	0c 91       	mov	r1,r6
8001185a:	50 15       	stdsp	sp[0x4],r5
8001185c:	08 92       	mov	r2,r4
8001185e:	c9 c8       	rjmp	80011996 <__sfvwrite_r+0x1ca>
80011860:	06 96       	mov	r6,r3
80011862:	08 91       	mov	r1,r4
80011864:	c0 48       	rjmp	8001186c <__sfvwrite_r+0xa0>
80011866:	60 03       	ld.w	r3,r0[0x0]
80011868:	60 16       	ld.w	r6,r0[0x4]
8001186a:	2f 80       	sub	r0,-8
8001186c:	58 06       	cp.w	r6,0
8001186e:	cf c0       	breq	80011866 <__sfvwrite_r+0x9a>
80011870:	8e 68       	ld.sh	r8,r7[0xc]
80011872:	6e 24       	ld.w	r4,r7[0x8]
80011874:	10 99       	mov	r9,r8
80011876:	e2 19 02 00 	andl	r9,0x200,COH
8001187a:	c5 50       	breq	80011924 <__sfvwrite_r+0x158>
8001187c:	08 36       	cp.w	r6,r4
8001187e:	c4 43       	brcs	80011906 <__sfvwrite_r+0x13a>
80011880:	10 99       	mov	r9,r8
80011882:	e2 19 04 80 	andl	r9,0x480,COH
80011886:	c4 00       	breq	80011906 <__sfvwrite_r+0x13a>
80011888:	6e 4b       	ld.w	r11,r7[0x10]
8001188a:	6e 09       	ld.w	r9,r7[0x0]
8001188c:	16 19       	sub	r9,r11
8001188e:	50 09       	stdsp	sp[0x0],r9
80011890:	6e 59       	ld.w	r9,r7[0x14]
80011892:	10 9c       	mov	r12,r8
80011894:	f2 09 00 1a 	add	r10,r9,r9<<0x1
80011898:	30 28       	mov	r8,2
8001189a:	f4 08 0c 08 	divs	r8,r10,r8
8001189e:	fa e9 00 04 	st.d	sp[4],r8
800118a2:	10 94       	mov	r4,r8
800118a4:	40 09       	lddsp	r9,sp[0x0]
800118a6:	e2 1c 04 00 	andl	r12,0x400,COH
800118aa:	2f f9       	sub	r9,-1
800118ac:	0c 09       	add	r9,r6
800118ae:	12 38       	cp.w	r8,r9
800118b0:	f2 04 17 30 	movlo	r4,r9
800118b4:	58 0c       	cp.w	r12,0
800118b6:	c1 10       	breq	800118d8 <__sfvwrite_r+0x10c>
800118b8:	08 9b       	mov	r11,r4
800118ba:	0a 9c       	mov	r12,r5
800118bc:	fe b0 d4 a8 	rcall	8000c20c <_malloc_r>
800118c0:	18 92       	mov	r2,r12
800118c2:	c1 40       	breq	800118ea <__sfvwrite_r+0x11e>
800118c4:	40 0a       	lddsp	r10,sp[0x0]
800118c6:	6e 4b       	ld.w	r11,r7[0x10]
800118c8:	fe b0 d6 b8 	rcall	8000c638 <memcpy>
800118cc:	8e 68       	ld.sh	r8,r7[0xc]
800118ce:	e0 18 fb 7f 	andl	r8,0xfb7f
800118d2:	a7 b8       	sbr	r8,0x7
800118d4:	ae 68       	st.h	r7[0xc],r8
800118d6:	c0 d8       	rjmp	800118f0 <__sfvwrite_r+0x124>
800118d8:	08 9a       	mov	r10,r4
800118da:	0a 9c       	mov	r12,r5
800118dc:	e0 a0 04 5e 	rcall	80012198 <_realloc_r>
800118e0:	18 92       	mov	r2,r12
800118e2:	c0 71       	brne	800118f0 <__sfvwrite_r+0x124>
800118e4:	6e 4b       	ld.w	r11,r7[0x10]
800118e6:	0a 9c       	mov	r12,r5
800118e8:	ca ce       	rcall	80011640 <_free_r>
800118ea:	30 c8       	mov	r8,12
800118ec:	8b 38       	st.w	r5[0xc],r8
800118ee:	cb 18       	rjmp	80011a50 <__sfvwrite_r+0x284>
800118f0:	40 0a       	lddsp	r10,sp[0x0]
800118f2:	40 09       	lddsp	r9,sp[0x0]
800118f4:	e8 0a 01 0a 	sub	r10,r4,r10
800118f8:	e4 09 00 08 	add	r8,r2,r9
800118fc:	8f 54       	st.w	r7[0x14],r4
800118fe:	8f 2a       	st.w	r7[0x8],r10
80011900:	8f 08       	st.w	r7[0x0],r8
80011902:	8f 42       	st.w	r7[0x10],r2
80011904:	0c 94       	mov	r4,r6
80011906:	08 36       	cp.w	r6,r4
80011908:	ec 04 17 30 	movlo	r4,r6
8001190c:	06 9b       	mov	r11,r3
8001190e:	08 9a       	mov	r10,r4
80011910:	6e 0c       	ld.w	r12,r7[0x0]
80011912:	c3 ad       	rcall	80011b86 <memmove>
80011914:	6e 08       	ld.w	r8,r7[0x0]
80011916:	08 08       	add	r8,r4
80011918:	8f 08       	st.w	r7[0x0],r8
8001191a:	6e 28       	ld.w	r8,r7[0x8]
8001191c:	08 18       	sub	r8,r4
8001191e:	0c 94       	mov	r4,r6
80011920:	8f 28       	st.w	r7[0x8],r8
80011922:	c2 e8       	rjmp	8001197e <__sfvwrite_r+0x1b2>
80011924:	08 36       	cp.w	r6,r4
80011926:	5f ba       	srhi	r10
80011928:	6e 0c       	ld.w	r12,r7[0x0]
8001192a:	6e 48       	ld.w	r8,r7[0x10]
8001192c:	10 3c       	cp.w	r12,r8
8001192e:	5f b8       	srhi	r8
80011930:	f5 e8 00 08 	and	r8,r10,r8
80011934:	f2 08 18 00 	cp.b	r8,r9
80011938:	c0 d0       	breq	80011952 <__sfvwrite_r+0x186>
8001193a:	06 9b       	mov	r11,r3
8001193c:	08 9a       	mov	r10,r4
8001193e:	c2 4d       	rcall	80011b86 <memmove>
80011940:	6e 08       	ld.w	r8,r7[0x0]
80011942:	08 08       	add	r8,r4
80011944:	0e 9b       	mov	r11,r7
80011946:	8f 08       	st.w	r7[0x0],r8
80011948:	0a 9c       	mov	r12,r5
8001194a:	fe b0 fd 09 	rcall	8001135c <_fflush_r>
8001194e:	c1 80       	breq	8001197e <__sfvwrite_r+0x1b2>
80011950:	c8 08       	rjmp	80011a50 <__sfvwrite_r+0x284>
80011952:	6e 59       	ld.w	r9,r7[0x14]
80011954:	12 36       	cp.w	r6,r9
80011956:	c0 a3       	brcs	8001196a <__sfvwrite_r+0x19e>
80011958:	6e a8       	ld.w	r8,r7[0x28]
8001195a:	06 9a       	mov	r10,r3
8001195c:	6e 8b       	ld.w	r11,r7[0x20]
8001195e:	0a 9c       	mov	r12,r5
80011960:	5d 18       	icall	r8
80011962:	18 94       	mov	r4,r12
80011964:	e0 89 00 0d 	brgt	8001197e <__sfvwrite_r+0x1b2>
80011968:	c7 48       	rjmp	80011a50 <__sfvwrite_r+0x284>
8001196a:	0c 9a       	mov	r10,r6
8001196c:	06 9b       	mov	r11,r3
8001196e:	c0 cd       	rcall	80011b86 <memmove>
80011970:	6e 08       	ld.w	r8,r7[0x0]
80011972:	0c 08       	add	r8,r6
80011974:	0c 94       	mov	r4,r6
80011976:	8f 08       	st.w	r7[0x0],r8
80011978:	6e 28       	ld.w	r8,r7[0x8]
8001197a:	0c 18       	sub	r8,r6
8001197c:	8f 28       	st.w	r7[0x8],r8
8001197e:	62 28       	ld.w	r8,r1[0x8]
80011980:	08 18       	sub	r8,r4
80011982:	83 28       	st.w	r1[0x8],r8
80011984:	c6 b0       	breq	80011a5a <__sfvwrite_r+0x28e>
80011986:	08 16       	sub	r6,r4
80011988:	08 03       	add	r3,r4
8001198a:	c7 1b       	rjmp	8001186c <__sfvwrite_r+0xa0>
8001198c:	60 03       	ld.w	r3,r0[0x0]
8001198e:	60 11       	ld.w	r1,r0[0x4]
80011990:	30 08       	mov	r8,0
80011992:	2f 80       	sub	r0,-8
80011994:	50 08       	stdsp	sp[0x0],r8
80011996:	58 01       	cp.w	r1,0
80011998:	cf a0       	breq	8001198c <__sfvwrite_r+0x1c0>
8001199a:	40 0a       	lddsp	r10,sp[0x0]
8001199c:	58 0a       	cp.w	r10,0
8001199e:	c1 41       	brne	800119c6 <__sfvwrite_r+0x1fa>
800119a0:	e2 c6 ff ff 	sub	r6,r1,-1
800119a4:	02 9a       	mov	r10,r1
800119a6:	30 ab       	mov	r11,10
800119a8:	06 9c       	mov	r12,r3
800119aa:	ce 3c       	rcall	80011b70 <memchr>
800119ac:	f8 c8 ff ff 	sub	r8,r12,-1
800119b0:	58 0c       	cp.w	r12,0
800119b2:	f1 d3 e1 16 	subne	r6,r8,r3
800119b6:	f9 b9 01 01 	movne	r9,1
800119ba:	fb f9 1a 00 	st.wne	sp[0x0],r9
800119be:	f9 b8 00 01 	moveq	r8,1
800119c2:	fb f8 0a 00 	st.weq	sp[0x0],r8
800119c6:	02 36       	cp.w	r6,r1
800119c8:	ec 04 17 80 	movls	r4,r6
800119cc:	e2 04 17 b0 	movhi	r4,r1
800119d0:	6e 59       	ld.w	r9,r7[0x14]
800119d2:	6e 25       	ld.w	r5,r7[0x8]
800119d4:	f2 05 00 05 	add	r5,r9,r5
800119d8:	0a 34       	cp.w	r4,r5
800119da:	5f 9a       	srgt	r10
800119dc:	6e 0c       	ld.w	r12,r7[0x0]
800119de:	6e 48       	ld.w	r8,r7[0x10]
800119e0:	10 3c       	cp.w	r12,r8
800119e2:	5f b8       	srhi	r8
800119e4:	f5 e8 00 08 	and	r8,r10,r8
800119e8:	30 0a       	mov	r10,0
800119ea:	f4 08 18 00 	cp.b	r8,r10
800119ee:	c0 d0       	breq	80011a08 <__sfvwrite_r+0x23c>
800119f0:	06 9b       	mov	r11,r3
800119f2:	0a 9a       	mov	r10,r5
800119f4:	cc 9c       	rcall	80011b86 <memmove>
800119f6:	6e 08       	ld.w	r8,r7[0x0]
800119f8:	0a 08       	add	r8,r5
800119fa:	0e 9b       	mov	r11,r7
800119fc:	8f 08       	st.w	r7[0x0],r8
800119fe:	40 1c       	lddsp	r12,sp[0x4]
80011a00:	fe b0 fc ae 	rcall	8001135c <_fflush_r>
80011a04:	c1 70       	breq	80011a32 <__sfvwrite_r+0x266>
80011a06:	c2 58       	rjmp	80011a50 <__sfvwrite_r+0x284>
80011a08:	12 34       	cp.w	r4,r9
80011a0a:	c0 a5       	brlt	80011a1e <__sfvwrite_r+0x252>
80011a0c:	6e a8       	ld.w	r8,r7[0x28]
80011a0e:	06 9a       	mov	r10,r3
80011a10:	6e 8b       	ld.w	r11,r7[0x20]
80011a12:	40 1c       	lddsp	r12,sp[0x4]
80011a14:	5d 18       	icall	r8
80011a16:	18 95       	mov	r5,r12
80011a18:	e0 89 00 0d 	brgt	80011a32 <__sfvwrite_r+0x266>
80011a1c:	c1 a8       	rjmp	80011a50 <__sfvwrite_r+0x284>
80011a1e:	08 9a       	mov	r10,r4
80011a20:	06 9b       	mov	r11,r3
80011a22:	cb 2c       	rcall	80011b86 <memmove>
80011a24:	6e 08       	ld.w	r8,r7[0x0]
80011a26:	08 08       	add	r8,r4
80011a28:	08 95       	mov	r5,r4
80011a2a:	8f 08       	st.w	r7[0x0],r8
80011a2c:	6e 28       	ld.w	r8,r7[0x8]
80011a2e:	08 18       	sub	r8,r4
80011a30:	8f 28       	st.w	r7[0x8],r8
80011a32:	0a 16       	sub	r6,r5
80011a34:	c0 71       	brne	80011a42 <__sfvwrite_r+0x276>
80011a36:	0e 9b       	mov	r11,r7
80011a38:	40 1c       	lddsp	r12,sp[0x4]
80011a3a:	fe b0 fc 91 	rcall	8001135c <_fflush_r>
80011a3e:	c0 91       	brne	80011a50 <__sfvwrite_r+0x284>
80011a40:	50 06       	stdsp	sp[0x0],r6
80011a42:	64 28       	ld.w	r8,r2[0x8]
80011a44:	0a 18       	sub	r8,r5
80011a46:	85 28       	st.w	r2[0x8],r8
80011a48:	c0 90       	breq	80011a5a <__sfvwrite_r+0x28e>
80011a4a:	0a 11       	sub	r1,r5
80011a4c:	0a 03       	add	r3,r5
80011a4e:	ca 4b       	rjmp	80011996 <__sfvwrite_r+0x1ca>
80011a50:	8e 68       	ld.sh	r8,r7[0xc]
80011a52:	a7 a8       	sbr	r8,0x6
80011a54:	ae 68       	st.h	r7[0xc],r8
80011a56:	3f fc       	mov	r12,-1
80011a58:	c0 28       	rjmp	80011a5c <__sfvwrite_r+0x290>
80011a5a:	30 0c       	mov	r12,0
80011a5c:	2f dd       	sub	sp,-12
80011a5e:	d8 32       	popm	r0-r7,pc

80011a60 <_fwalk>:
80011a60:	d4 31       	pushm	r0-r7,lr
80011a62:	30 05       	mov	r5,0
80011a64:	16 91       	mov	r1,r11
80011a66:	f8 c7 ff 28 	sub	r7,r12,-216
80011a6a:	0a 92       	mov	r2,r5
80011a6c:	fe b0 fc fe 	rcall	80011468 <__sfp_lock_acquire>
80011a70:	3f f3       	mov	r3,-1
80011a72:	c1 68       	rjmp	80011a9e <_fwalk+0x3e>
80011a74:	6e 26       	ld.w	r6,r7[0x8]
80011a76:	6e 14       	ld.w	r4,r7[0x4]
80011a78:	2f 46       	sub	r6,-12
80011a7a:	c0 c8       	rjmp	80011a92 <_fwalk+0x32>
80011a7c:	8c 08       	ld.sh	r8,r6[0x0]
80011a7e:	e4 08 19 00 	cp.h	r8,r2
80011a82:	c0 70       	breq	80011a90 <_fwalk+0x30>
80011a84:	8c 18       	ld.sh	r8,r6[0x2]
80011a86:	e6 08 19 00 	cp.h	r8,r3
80011a8a:	c0 30       	breq	80011a90 <_fwalk+0x30>
80011a8c:	5d 11       	icall	r1
80011a8e:	18 45       	or	r5,r12
80011a90:	2a 46       	sub	r6,-92
80011a92:	20 14       	sub	r4,1
80011a94:	ec cc 00 0c 	sub	r12,r6,12
80011a98:	58 04       	cp.w	r4,0
80011a9a:	cf 14       	brge	80011a7c <_fwalk+0x1c>
80011a9c:	6e 07       	ld.w	r7,r7[0x0]
80011a9e:	58 07       	cp.w	r7,0
80011aa0:	ce a1       	brne	80011a74 <_fwalk+0x14>
80011aa2:	fe b0 fc e4 	rcall	8001146a <__sfp_lock_release>
80011aa6:	0a 9c       	mov	r12,r5
80011aa8:	d8 32       	popm	r0-r7,pc
80011aaa:	d7 03       	nop

80011aac <_localeconv_r>:
80011aac:	fe cc ac a8 	sub	r12,pc,-21336
80011ab0:	5e fc       	retal	r12
80011ab2:	d7 03       	nop

80011ab4 <__smakebuf_r>:
80011ab4:	d4 21       	pushm	r4-r7,lr
80011ab6:	20 fd       	sub	sp,60
80011ab8:	96 68       	ld.sh	r8,r11[0xc]
80011aba:	16 97       	mov	r7,r11
80011abc:	18 96       	mov	r6,r12
80011abe:	e2 18 00 02 	andl	r8,0x2,COH
80011ac2:	c3 d1       	brne	80011b3c <__smakebuf_r+0x88>
80011ac4:	96 7b       	ld.sh	r11,r11[0xe]
80011ac6:	f0 0b 19 00 	cp.h	r11,r8
80011aca:	c0 55       	brlt	80011ad4 <__smakebuf_r+0x20>
80011acc:	1a 9a       	mov	r10,sp
80011ace:	e0 a0 06 25 	rcall	80012718 <_fstat_r>
80011ad2:	c0 f4       	brge	80011af0 <__smakebuf_r+0x3c>
80011ad4:	8e 65       	ld.sh	r5,r7[0xc]
80011ad6:	0a 98       	mov	r8,r5
80011ad8:	ab b8       	sbr	r8,0xb
80011ada:	e2 15 00 80 	andl	r5,0x80,COH
80011ade:	ae 68       	st.h	r7[0xc],r8
80011ae0:	30 04       	mov	r4,0
80011ae2:	e0 68 04 00 	mov	r8,1024
80011ae6:	f9 b5 01 40 	movne	r5,64
80011aea:	f0 05 17 00 	moveq	r5,r8
80011aee:	c1 c8       	rjmp	80011b26 <__smakebuf_r+0x72>
80011af0:	40 18       	lddsp	r8,sp[0x4]
80011af2:	e2 18 f0 00 	andl	r8,0xf000,COH
80011af6:	e0 48 20 00 	cp.w	r8,8192
80011afa:	5f 04       	sreq	r4
80011afc:	e0 48 80 00 	cp.w	r8,32768
80011b00:	c0 e1       	brne	80011b1c <__smakebuf_r+0x68>
80011b02:	6e b9       	ld.w	r9,r7[0x2c]
80011b04:	fe c8 f5 d4 	sub	r8,pc,-2604
80011b08:	10 39       	cp.w	r9,r8
80011b0a:	c0 91       	brne	80011b1c <__smakebuf_r+0x68>
80011b0c:	8e 68       	ld.sh	r8,r7[0xc]
80011b0e:	e0 65 04 00 	mov	r5,1024
80011b12:	ab a8       	sbr	r8,0xa
80011b14:	ef 45 00 50 	st.w	r7[80],r5
80011b18:	ae 68       	st.h	r7[0xc],r8
80011b1a:	c0 68       	rjmp	80011b26 <__smakebuf_r+0x72>
80011b1c:	8e 68       	ld.sh	r8,r7[0xc]
80011b1e:	e0 65 04 00 	mov	r5,1024
80011b22:	ab b8       	sbr	r8,0xb
80011b24:	ae 68       	st.h	r7[0xc],r8
80011b26:	0a 9b       	mov	r11,r5
80011b28:	0c 9c       	mov	r12,r6
80011b2a:	fe b0 d3 71 	rcall	8000c20c <_malloc_r>
80011b2e:	8e 68       	ld.sh	r8,r7[0xc]
80011b30:	c0 d1       	brne	80011b4a <__smakebuf_r+0x96>
80011b32:	ed b8 00 09 	bld	r8,0x9
80011b36:	c1 b0       	breq	80011b6c <__smakebuf_r+0xb8>
80011b38:	a1 b8       	sbr	r8,0x1
80011b3a:	ae 68       	st.h	r7[0xc],r8
80011b3c:	ee c8 ff b9 	sub	r8,r7,-71
80011b40:	8f 48       	st.w	r7[0x10],r8
80011b42:	8f 08       	st.w	r7[0x0],r8
80011b44:	30 18       	mov	r8,1
80011b46:	8f 58       	st.w	r7[0x14],r8
80011b48:	c1 28       	rjmp	80011b6c <__smakebuf_r+0xb8>
80011b4a:	a7 b8       	sbr	r8,0x7
80011b4c:	8f 4c       	st.w	r7[0x10],r12
80011b4e:	ae 68       	st.h	r7[0xc],r8
80011b50:	8f 55       	st.w	r7[0x14],r5
80011b52:	fe c8 06 e6 	sub	r8,pc,1766
80011b56:	8f 0c       	st.w	r7[0x0],r12
80011b58:	8d a8       	st.w	r6[0x28],r8
80011b5a:	58 04       	cp.w	r4,0
80011b5c:	c0 80       	breq	80011b6c <__smakebuf_r+0xb8>
80011b5e:	8e 7c       	ld.sh	r12,r7[0xe]
80011b60:	fe b0 d6 8c 	rcall	8000c878 <isatty>
80011b64:	c0 40       	breq	80011b6c <__smakebuf_r+0xb8>
80011b66:	8e 68       	ld.sh	r8,r7[0xc]
80011b68:	a1 a8       	sbr	r8,0x0
80011b6a:	ae 68       	st.h	r7[0xc],r8
80011b6c:	2f 1d       	sub	sp,-60
80011b6e:	d8 22       	popm	r4-r7,pc

80011b70 <memchr>:
80011b70:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
80011b74:	c0 68       	rjmp	80011b80 <memchr+0x10>
80011b76:	20 1a       	sub	r10,1
80011b78:	19 88       	ld.ub	r8,r12[0x0]
80011b7a:	16 38       	cp.w	r8,r11
80011b7c:	5e 0c       	reteq	r12
80011b7e:	2f fc       	sub	r12,-1
80011b80:	58 0a       	cp.w	r10,0
80011b82:	cf a1       	brne	80011b76 <memchr+0x6>
80011b84:	5e fa       	retal	r10

80011b86 <memmove>:
80011b86:	d4 01       	pushm	lr
80011b88:	18 3b       	cp.w	r11,r12
80011b8a:	c1 92       	brcc	80011bbc <memmove+0x36>
80011b8c:	f6 0a 00 09 	add	r9,r11,r10
80011b90:	12 3c       	cp.w	r12,r9
80011b92:	c1 52       	brcc	80011bbc <memmove+0x36>
80011b94:	f8 0a 00 0b 	add	r11,r12,r10
80011b98:	30 08       	mov	r8,0
80011b9a:	c0 68       	rjmp	80011ba6 <memmove+0x20>
80011b9c:	f2 08 07 0e 	ld.ub	lr,r9[r8]
80011ba0:	20 1a       	sub	r10,1
80011ba2:	f6 08 0b 0e 	st.b	r11[r8],lr
80011ba6:	20 18       	sub	r8,1
80011ba8:	58 0a       	cp.w	r10,0
80011baa:	cf 91       	brne	80011b9c <memmove+0x16>
80011bac:	d8 02       	popm	pc
80011bae:	f6 08 07 09 	ld.ub	r9,r11[r8]
80011bb2:	20 1a       	sub	r10,1
80011bb4:	f8 08 0b 09 	st.b	r12[r8],r9
80011bb8:	2f f8       	sub	r8,-1
80011bba:	c0 28       	rjmp	80011bbe <memmove+0x38>
80011bbc:	30 08       	mov	r8,0
80011bbe:	58 0a       	cp.w	r10,0
80011bc0:	cf 71       	brne	80011bae <memmove+0x28>
80011bc2:	d8 02       	popm	pc

80011bc4 <__hi0bits>:
80011bc4:	18 98       	mov	r8,r12
80011bc6:	e0 1c 00 00 	andl	r12,0x0
80011bca:	f0 09 15 10 	lsl	r9,r8,0x10
80011bce:	58 0c       	cp.w	r12,0
80011bd0:	f2 08 17 00 	moveq	r8,r9
80011bd4:	f9 bc 00 10 	moveq	r12,16
80011bd8:	f9 bc 01 00 	movne	r12,0
80011bdc:	10 9a       	mov	r10,r8
80011bde:	f0 09 15 08 	lsl	r9,r8,0x8
80011be2:	e6 1a ff 00 	andh	r10,0xff00,COH
80011be6:	f7 bc 00 f8 	subeq	r12,-8
80011bea:	f2 08 17 00 	moveq	r8,r9
80011bee:	10 9a       	mov	r10,r8
80011bf0:	f0 09 15 04 	lsl	r9,r8,0x4
80011bf4:	e6 1a f0 00 	andh	r10,0xf000,COH
80011bf8:	f7 bc 00 fc 	subeq	r12,-4
80011bfc:	f2 08 17 00 	moveq	r8,r9
80011c00:	10 9a       	mov	r10,r8
80011c02:	f0 09 15 02 	lsl	r9,r8,0x2
80011c06:	e6 1a c0 00 	andh	r10,0xc000,COH
80011c0a:	f7 bc 00 fe 	subeq	r12,-2
80011c0e:	f2 08 17 00 	moveq	r8,r9
80011c12:	58 08       	cp.w	r8,0
80011c14:	5e 5c       	retlt	r12
80011c16:	ed b8 00 1e 	bld	r8,0x1e
80011c1a:	f9 bc 01 20 	movne	r12,32
80011c1e:	f7 bc 00 ff 	subeq	r12,-1
80011c22:	5e fc       	retal	r12

80011c24 <__lo0bits>:
80011c24:	18 99       	mov	r9,r12
80011c26:	78 08       	ld.w	r8,r12[0x0]
80011c28:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
80011c2c:	c1 50       	breq	80011c56 <__lo0bits+0x32>
80011c2e:	ed b8 00 00 	bld	r8,0x0
80011c32:	c0 21       	brne	80011c36 <__lo0bits+0x12>
80011c34:	5e fd       	retal	0
80011c36:	10 9b       	mov	r11,r8
80011c38:	f0 0a 16 01 	lsr	r10,r8,0x1
80011c3c:	e2 1b 00 02 	andl	r11,0x2,COH
80011c40:	a3 88       	lsr	r8,0x2
80011c42:	58 0b       	cp.w	r11,0
80011c44:	f3 fa 1a 00 	st.wne	r9[0x0],r10
80011c48:	f9 bc 01 01 	movne	r12,1
80011c4c:	f3 f8 0a 00 	st.weq	r9[0x0],r8
80011c50:	f9 bc 00 02 	moveq	r12,2
80011c54:	5e fc       	retal	r12
80011c56:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80011c5a:	f0 0b 16 10 	lsr	r11,r8,0x10
80011c5e:	58 0a       	cp.w	r10,0
80011c60:	f6 08 17 00 	moveq	r8,r11
80011c64:	f9 bc 00 10 	moveq	r12,16
80011c68:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
80011c6c:	f0 0a 16 08 	lsr	r10,r8,0x8
80011c70:	58 0b       	cp.w	r11,0
80011c72:	f7 bc 00 f8 	subeq	r12,-8
80011c76:	f4 08 17 00 	moveq	r8,r10
80011c7a:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
80011c7e:	f0 0a 16 04 	lsr	r10,r8,0x4
80011c82:	58 0b       	cp.w	r11,0
80011c84:	f7 bc 00 fc 	subeq	r12,-4
80011c88:	f4 08 17 00 	moveq	r8,r10
80011c8c:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
80011c90:	f0 0a 16 02 	lsr	r10,r8,0x2
80011c94:	58 0b       	cp.w	r11,0
80011c96:	f7 bc 00 fe 	subeq	r12,-2
80011c9a:	f4 08 17 00 	moveq	r8,r10
80011c9e:	ed b8 00 00 	bld	r8,0x0
80011ca2:	c0 60       	breq	80011cae <__lo0bits+0x8a>
80011ca4:	a1 98       	lsr	r8,0x1
80011ca6:	c0 31       	brne	80011cac <__lo0bits+0x88>
80011ca8:	32 0c       	mov	r12,32
80011caa:	5e fc       	retal	r12
80011cac:	2f fc       	sub	r12,-1
80011cae:	93 08       	st.w	r9[0x0],r8
80011cb0:	5e fc       	retal	r12

80011cb2 <__mcmp>:
80011cb2:	d4 01       	pushm	lr
80011cb4:	18 98       	mov	r8,r12
80011cb6:	76 49       	ld.w	r9,r11[0x10]
80011cb8:	78 4c       	ld.w	r12,r12[0x10]
80011cba:	12 1c       	sub	r12,r9
80011cbc:	c1 31       	brne	80011ce2 <__mcmp+0x30>
80011cbe:	2f b9       	sub	r9,-5
80011cc0:	a3 69       	lsl	r9,0x2
80011cc2:	12 0b       	add	r11,r9
80011cc4:	f0 09 00 09 	add	r9,r8,r9
80011cc8:	2e c8       	sub	r8,-20
80011cca:	13 4e       	ld.w	lr,--r9
80011ccc:	17 4a       	ld.w	r10,--r11
80011cce:	14 3e       	cp.w	lr,r10
80011cd0:	c0 60       	breq	80011cdc <__mcmp+0x2a>
80011cd2:	f9 bc 03 ff 	movlo	r12,-1
80011cd6:	f9 bc 02 01 	movhs	r12,1
80011cda:	d8 02       	popm	pc
80011cdc:	10 39       	cp.w	r9,r8
80011cde:	fe 9b ff f6 	brhi	80011cca <__mcmp+0x18>
80011ce2:	d8 02       	popm	pc

80011ce4 <_Bfree>:
80011ce4:	d4 21       	pushm	r4-r7,lr
80011ce6:	18 97       	mov	r7,r12
80011ce8:	16 95       	mov	r5,r11
80011cea:	78 96       	ld.w	r6,r12[0x24]
80011cec:	58 06       	cp.w	r6,0
80011cee:	c0 91       	brne	80011d00 <_Bfree+0x1c>
80011cf0:	31 0c       	mov	r12,16
80011cf2:	fe b0 d2 85 	rcall	8000c1fc <malloc>
80011cf6:	99 36       	st.w	r12[0xc],r6
80011cf8:	8f 9c       	st.w	r7[0x24],r12
80011cfa:	99 16       	st.w	r12[0x4],r6
80011cfc:	99 26       	st.w	r12[0x8],r6
80011cfe:	99 06       	st.w	r12[0x0],r6
80011d00:	58 05       	cp.w	r5,0
80011d02:	c0 90       	breq	80011d14 <_Bfree+0x30>
80011d04:	6a 19       	ld.w	r9,r5[0x4]
80011d06:	6e 98       	ld.w	r8,r7[0x24]
80011d08:	70 38       	ld.w	r8,r8[0xc]
80011d0a:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
80011d0e:	8b 0a       	st.w	r5[0x0],r10
80011d10:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
80011d14:	d8 22       	popm	r4-r7,pc
80011d16:	d7 03       	nop

80011d18 <_Balloc>:
80011d18:	d4 21       	pushm	r4-r7,lr
80011d1a:	18 97       	mov	r7,r12
80011d1c:	16 96       	mov	r6,r11
80011d1e:	78 95       	ld.w	r5,r12[0x24]
80011d20:	58 05       	cp.w	r5,0
80011d22:	c0 91       	brne	80011d34 <_Balloc+0x1c>
80011d24:	31 0c       	mov	r12,16
80011d26:	fe b0 d2 6b 	rcall	8000c1fc <malloc>
80011d2a:	99 35       	st.w	r12[0xc],r5
80011d2c:	8f 9c       	st.w	r7[0x24],r12
80011d2e:	99 15       	st.w	r12[0x4],r5
80011d30:	99 25       	st.w	r12[0x8],r5
80011d32:	99 05       	st.w	r12[0x0],r5
80011d34:	6e 95       	ld.w	r5,r7[0x24]
80011d36:	6a 38       	ld.w	r8,r5[0xc]
80011d38:	58 08       	cp.w	r8,0
80011d3a:	c0 b1       	brne	80011d50 <_Balloc+0x38>
80011d3c:	31 0a       	mov	r10,16
80011d3e:	30 4b       	mov	r11,4
80011d40:	0e 9c       	mov	r12,r7
80011d42:	e0 a0 04 4b 	rcall	800125d8 <_calloc_r>
80011d46:	8b 3c       	st.w	r5[0xc],r12
80011d48:	6e 98       	ld.w	r8,r7[0x24]
80011d4a:	70 3c       	ld.w	r12,r8[0xc]
80011d4c:	58 0c       	cp.w	r12,0
80011d4e:	c1 b0       	breq	80011d84 <_Balloc+0x6c>
80011d50:	6e 98       	ld.w	r8,r7[0x24]
80011d52:	70 38       	ld.w	r8,r8[0xc]
80011d54:	f0 06 00 28 	add	r8,r8,r6<<0x2
80011d58:	70 0c       	ld.w	r12,r8[0x0]
80011d5a:	58 0c       	cp.w	r12,0
80011d5c:	c0 40       	breq	80011d64 <_Balloc+0x4c>
80011d5e:	78 09       	ld.w	r9,r12[0x0]
80011d60:	91 09       	st.w	r8[0x0],r9
80011d62:	c0 e8       	rjmp	80011d7e <_Balloc+0x66>
80011d64:	0e 9c       	mov	r12,r7
80011d66:	30 17       	mov	r7,1
80011d68:	0e 9b       	mov	r11,r7
80011d6a:	ee 06 09 47 	lsl	r7,r7,r6
80011d6e:	ee ca ff fb 	sub	r10,r7,-5
80011d72:	a3 6a       	lsl	r10,0x2
80011d74:	e0 a0 04 32 	rcall	800125d8 <_calloc_r>
80011d78:	c0 60       	breq	80011d84 <_Balloc+0x6c>
80011d7a:	99 16       	st.w	r12[0x4],r6
80011d7c:	99 27       	st.w	r12[0x8],r7
80011d7e:	30 08       	mov	r8,0
80011d80:	99 38       	st.w	r12[0xc],r8
80011d82:	99 48       	st.w	r12[0x10],r8
80011d84:	d8 22       	popm	r4-r7,pc
80011d86:	d7 03       	nop

80011d88 <__d2b>:
80011d88:	d4 31       	pushm	r0-r7,lr
80011d8a:	20 2d       	sub	sp,8
80011d8c:	16 93       	mov	r3,r11
80011d8e:	12 96       	mov	r6,r9
80011d90:	10 95       	mov	r5,r8
80011d92:	14 92       	mov	r2,r10
80011d94:	30 1b       	mov	r11,1
80011d96:	cc 1f       	rcall	80011d18 <_Balloc>
80011d98:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
80011d9c:	50 09       	stdsp	sp[0x0],r9
80011d9e:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
80011da2:	b5 a9       	sbr	r9,0x14
80011da4:	f0 01 16 14 	lsr	r1,r8,0x14
80011da8:	fb f9 1a 00 	st.wne	sp[0x0],r9
80011dac:	18 94       	mov	r4,r12
80011dae:	58 02       	cp.w	r2,0
80011db0:	c1 d0       	breq	80011dea <__d2b+0x62>
80011db2:	fa cc ff f8 	sub	r12,sp,-8
80011db6:	18 d2       	st.w	--r12,r2
80011db8:	c3 6f       	rcall	80011c24 <__lo0bits>
80011dba:	40 18       	lddsp	r8,sp[0x4]
80011dbc:	c0 d0       	breq	80011dd6 <__d2b+0x4e>
80011dbe:	40 09       	lddsp	r9,sp[0x0]
80011dc0:	f8 0a 11 20 	rsub	r10,r12,32
80011dc4:	f2 0a 09 4a 	lsl	r10,r9,r10
80011dc8:	f5 e8 10 08 	or	r8,r10,r8
80011dcc:	89 58       	st.w	r4[0x14],r8
80011dce:	f2 0c 0a 49 	lsr	r9,r9,r12
80011dd2:	50 09       	stdsp	sp[0x0],r9
80011dd4:	c0 28       	rjmp	80011dd8 <__d2b+0x50>
80011dd6:	89 58       	st.w	r4[0x14],r8
80011dd8:	40 08       	lddsp	r8,sp[0x0]
80011dda:	58 08       	cp.w	r8,0
80011ddc:	f9 b3 01 02 	movne	r3,2
80011de0:	f9 b3 00 01 	moveq	r3,1
80011de4:	89 68       	st.w	r4[0x18],r8
80011de6:	89 43       	st.w	r4[0x10],r3
80011de8:	c0 88       	rjmp	80011df8 <__d2b+0x70>
80011dea:	1a 9c       	mov	r12,sp
80011dec:	c1 cf       	rcall	80011c24 <__lo0bits>
80011dee:	30 13       	mov	r3,1
80011df0:	40 08       	lddsp	r8,sp[0x0]
80011df2:	2e 0c       	sub	r12,-32
80011df4:	89 43       	st.w	r4[0x10],r3
80011df6:	89 58       	st.w	r4[0x14],r8
80011df8:	58 01       	cp.w	r1,0
80011dfa:	c0 90       	breq	80011e0c <__d2b+0x84>
80011dfc:	e2 c1 04 33 	sub	r1,r1,1075
80011e00:	18 01       	add	r1,r12
80011e02:	8d 01       	st.w	r6[0x0],r1
80011e04:	f8 0c 11 35 	rsub	r12,r12,53
80011e08:	8b 0c       	st.w	r5[0x0],r12
80011e0a:	c0 c8       	rjmp	80011e22 <__d2b+0x9a>
80011e0c:	e6 c8 ff fc 	sub	r8,r3,-4
80011e10:	f8 cc 04 32 	sub	r12,r12,1074
80011e14:	a5 73       	lsl	r3,0x5
80011e16:	8d 0c       	st.w	r6[0x0],r12
80011e18:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
80011e1c:	cd 4e       	rcall	80011bc4 <__hi0bits>
80011e1e:	18 13       	sub	r3,r12
80011e20:	8b 03       	st.w	r5[0x0],r3
80011e22:	08 9c       	mov	r12,r4
80011e24:	2f ed       	sub	sp,-8
80011e26:	d8 32       	popm	r0-r7,pc

80011e28 <__mdiff>:
80011e28:	d4 31       	pushm	r0-r7,lr
80011e2a:	74 48       	ld.w	r8,r10[0x10]
80011e2c:	76 45       	ld.w	r5,r11[0x10]
80011e2e:	16 97       	mov	r7,r11
80011e30:	14 96       	mov	r6,r10
80011e32:	10 15       	sub	r5,r8
80011e34:	c1 31       	brne	80011e5a <__mdiff+0x32>
80011e36:	2f b8       	sub	r8,-5
80011e38:	ee ce ff ec 	sub	lr,r7,-20
80011e3c:	a3 68       	lsl	r8,0x2
80011e3e:	f4 08 00 0b 	add	r11,r10,r8
80011e42:	ee 08 00 08 	add	r8,r7,r8
80011e46:	11 4a       	ld.w	r10,--r8
80011e48:	17 49       	ld.w	r9,--r11
80011e4a:	12 3a       	cp.w	r10,r9
80011e4c:	c0 30       	breq	80011e52 <__mdiff+0x2a>
80011e4e:	c0 e2       	brcc	80011e6a <__mdiff+0x42>
80011e50:	c0 78       	rjmp	80011e5e <__mdiff+0x36>
80011e52:	1c 38       	cp.w	r8,lr
80011e54:	fe 9b ff f9 	brhi	80011e46 <__mdiff+0x1e>
80011e58:	c4 98       	rjmp	80011eea <__mdiff+0xc2>
80011e5a:	58 05       	cp.w	r5,0
80011e5c:	c0 64       	brge	80011e68 <__mdiff+0x40>
80011e5e:	0e 98       	mov	r8,r7
80011e60:	30 15       	mov	r5,1
80011e62:	0c 97       	mov	r7,r6
80011e64:	10 96       	mov	r6,r8
80011e66:	c0 28       	rjmp	80011e6a <__mdiff+0x42>
80011e68:	30 05       	mov	r5,0
80011e6a:	6e 1b       	ld.w	r11,r7[0x4]
80011e6c:	c5 6f       	rcall	80011d18 <_Balloc>
80011e6e:	6e 49       	ld.w	r9,r7[0x10]
80011e70:	6c 44       	ld.w	r4,r6[0x10]
80011e72:	99 35       	st.w	r12[0xc],r5
80011e74:	2f b4       	sub	r4,-5
80011e76:	f2 c5 ff fb 	sub	r5,r9,-5
80011e7a:	ec 04 00 24 	add	r4,r6,r4<<0x2
80011e7e:	ee 05 00 25 	add	r5,r7,r5<<0x2
80011e82:	2e c6       	sub	r6,-20
80011e84:	2e c7       	sub	r7,-20
80011e86:	f8 c8 ff ec 	sub	r8,r12,-20
80011e8a:	30 0a       	mov	r10,0
80011e8c:	0f 0e       	ld.w	lr,r7++
80011e8e:	0d 0b       	ld.w	r11,r6++
80011e90:	fc 02 16 10 	lsr	r2,lr,0x10
80011e94:	f6 03 16 10 	lsr	r3,r11,0x10
80011e98:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80011e9c:	e4 03 01 03 	sub	r3,r2,r3
80011ea0:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80011ea4:	fc 0b 01 0b 	sub	r11,lr,r11
80011ea8:	f6 0a 00 0a 	add	r10,r11,r10
80011eac:	b0 1a       	st.h	r8[0x2],r10
80011eae:	b1 4a       	asr	r10,0x10
80011eb0:	e6 0a 00 0a 	add	r10,r3,r10
80011eb4:	b0 0a       	st.h	r8[0x0],r10
80011eb6:	2f c8       	sub	r8,-4
80011eb8:	b1 4a       	asr	r10,0x10
80011eba:	08 36       	cp.w	r6,r4
80011ebc:	ce 83       	brcs	80011e8c <__mdiff+0x64>
80011ebe:	c0 d8       	rjmp	80011ed8 <__mdiff+0xb0>
80011ec0:	0f 0b       	ld.w	r11,r7++
80011ec2:	f6 0e 16 10 	lsr	lr,r11,0x10
80011ec6:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80011eca:	16 0a       	add	r10,r11
80011ecc:	b0 1a       	st.h	r8[0x2],r10
80011ece:	b1 4a       	asr	r10,0x10
80011ed0:	1c 0a       	add	r10,lr
80011ed2:	b0 0a       	st.h	r8[0x0],r10
80011ed4:	2f c8       	sub	r8,-4
80011ed6:	b1 4a       	asr	r10,0x10
80011ed8:	0a 37       	cp.w	r7,r5
80011eda:	cf 33       	brcs	80011ec0 <__mdiff+0x98>
80011edc:	c0 28       	rjmp	80011ee0 <__mdiff+0xb8>
80011ede:	20 19       	sub	r9,1
80011ee0:	11 4a       	ld.w	r10,--r8
80011ee2:	58 0a       	cp.w	r10,0
80011ee4:	cf d0       	breq	80011ede <__mdiff+0xb6>
80011ee6:	99 49       	st.w	r12[0x10],r9
80011ee8:	d8 32       	popm	r0-r7,pc
80011eea:	30 0b       	mov	r11,0
80011eec:	c1 6f       	rcall	80011d18 <_Balloc>
80011eee:	30 18       	mov	r8,1
80011ef0:	99 48       	st.w	r12[0x10],r8
80011ef2:	30 08       	mov	r8,0
80011ef4:	99 58       	st.w	r12[0x14],r8
80011ef6:	d8 32       	popm	r0-r7,pc

80011ef8 <__lshift>:
80011ef8:	d4 31       	pushm	r0-r7,lr
80011efa:	16 97       	mov	r7,r11
80011efc:	76 46       	ld.w	r6,r11[0x10]
80011efe:	f4 02 14 05 	asr	r2,r10,0x5
80011f02:	2f f6       	sub	r6,-1
80011f04:	14 93       	mov	r3,r10
80011f06:	18 94       	mov	r4,r12
80011f08:	04 06       	add	r6,r2
80011f0a:	76 1b       	ld.w	r11,r11[0x4]
80011f0c:	6e 28       	ld.w	r8,r7[0x8]
80011f0e:	c0 38       	rjmp	80011f14 <__lshift+0x1c>
80011f10:	2f fb       	sub	r11,-1
80011f12:	a1 78       	lsl	r8,0x1
80011f14:	10 36       	cp.w	r6,r8
80011f16:	fe 99 ff fd 	brgt	80011f10 <__lshift+0x18>
80011f1a:	08 9c       	mov	r12,r4
80011f1c:	cf ee       	rcall	80011d18 <_Balloc>
80011f1e:	30 09       	mov	r9,0
80011f20:	18 95       	mov	r5,r12
80011f22:	f8 c8 ff ec 	sub	r8,r12,-20
80011f26:	12 9a       	mov	r10,r9
80011f28:	c0 38       	rjmp	80011f2e <__lshift+0x36>
80011f2a:	10 aa       	st.w	r8++,r10
80011f2c:	2f f9       	sub	r9,-1
80011f2e:	04 39       	cp.w	r9,r2
80011f30:	cf d5       	brlt	80011f2a <__lshift+0x32>
80011f32:	6e 4b       	ld.w	r11,r7[0x10]
80011f34:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
80011f38:	2f bb       	sub	r11,-5
80011f3a:	ee c9 ff ec 	sub	r9,r7,-20
80011f3e:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
80011f42:	58 03       	cp.w	r3,0
80011f44:	c1 30       	breq	80011f6a <__lshift+0x72>
80011f46:	e6 0c 11 20 	rsub	r12,r3,32
80011f4a:	30 0a       	mov	r10,0
80011f4c:	72 02       	ld.w	r2,r9[0x0]
80011f4e:	e4 03 09 42 	lsl	r2,r2,r3
80011f52:	04 4a       	or	r10,r2
80011f54:	10 aa       	st.w	r8++,r10
80011f56:	13 0a       	ld.w	r10,r9++
80011f58:	f4 0c 0a 4a 	lsr	r10,r10,r12
80011f5c:	16 39       	cp.w	r9,r11
80011f5e:	cf 73       	brcs	80011f4c <__lshift+0x54>
80011f60:	91 0a       	st.w	r8[0x0],r10
80011f62:	58 0a       	cp.w	r10,0
80011f64:	c0 70       	breq	80011f72 <__lshift+0x7a>
80011f66:	2f f6       	sub	r6,-1
80011f68:	c0 58       	rjmp	80011f72 <__lshift+0x7a>
80011f6a:	13 0a       	ld.w	r10,r9++
80011f6c:	10 aa       	st.w	r8++,r10
80011f6e:	16 39       	cp.w	r9,r11
80011f70:	cf d3       	brcs	80011f6a <__lshift+0x72>
80011f72:	08 9c       	mov	r12,r4
80011f74:	20 16       	sub	r6,1
80011f76:	0e 9b       	mov	r11,r7
80011f78:	8b 46       	st.w	r5[0x10],r6
80011f7a:	cb 5e       	rcall	80011ce4 <_Bfree>
80011f7c:	0a 9c       	mov	r12,r5
80011f7e:	d8 32       	popm	r0-r7,pc

80011f80 <__multiply>:
80011f80:	d4 31       	pushm	r0-r7,lr
80011f82:	20 2d       	sub	sp,8
80011f84:	76 49       	ld.w	r9,r11[0x10]
80011f86:	74 48       	ld.w	r8,r10[0x10]
80011f88:	16 96       	mov	r6,r11
80011f8a:	14 95       	mov	r5,r10
80011f8c:	10 39       	cp.w	r9,r8
80011f8e:	ec 08 17 50 	movlt	r8,r6
80011f92:	ea 06 17 50 	movlt	r6,r5
80011f96:	f0 05 17 50 	movlt	r5,r8
80011f9a:	6c 28       	ld.w	r8,r6[0x8]
80011f9c:	76 43       	ld.w	r3,r11[0x10]
80011f9e:	74 42       	ld.w	r2,r10[0x10]
80011fa0:	76 1b       	ld.w	r11,r11[0x4]
80011fa2:	e4 03 00 07 	add	r7,r2,r3
80011fa6:	10 37       	cp.w	r7,r8
80011fa8:	f7 bb 09 ff 	subgt	r11,-1
80011fac:	cb 6e       	rcall	80011d18 <_Balloc>
80011fae:	ee c4 ff fb 	sub	r4,r7,-5
80011fb2:	f8 c9 ff ec 	sub	r9,r12,-20
80011fb6:	f8 04 00 24 	add	r4,r12,r4<<0x2
80011fba:	30 0a       	mov	r10,0
80011fbc:	12 98       	mov	r8,r9
80011fbe:	c0 28       	rjmp	80011fc2 <__multiply+0x42>
80011fc0:	10 aa       	st.w	r8++,r10
80011fc2:	08 38       	cp.w	r8,r4
80011fc4:	cf e3       	brcs	80011fc0 <__multiply+0x40>
80011fc6:	2f b3       	sub	r3,-5
80011fc8:	2f b2       	sub	r2,-5
80011fca:	ec 03 00 23 	add	r3,r6,r3<<0x2
80011fce:	ea 02 00 22 	add	r2,r5,r2<<0x2
80011fd2:	ec cb ff ec 	sub	r11,r6,-20
80011fd6:	50 12       	stdsp	sp[0x4],r2
80011fd8:	ea ca ff ec 	sub	r10,r5,-20
80011fdc:	c4 48       	rjmp	80012064 <__multiply+0xe4>
80011fde:	94 95       	ld.uh	r5,r10[0x2]
80011fe0:	58 05       	cp.w	r5,0
80011fe2:	c2 00       	breq	80012022 <__multiply+0xa2>
80011fe4:	12 98       	mov	r8,r9
80011fe6:	16 96       	mov	r6,r11
80011fe8:	30 0e       	mov	lr,0
80011fea:	50 09       	stdsp	sp[0x0],r9
80011fec:	0d 02       	ld.w	r2,r6++
80011fee:	e4 00 16 10 	lsr	r0,r2,0x10
80011ff2:	70 01       	ld.w	r1,r8[0x0]
80011ff4:	70 09       	ld.w	r9,r8[0x0]
80011ff6:	b1 81       	lsr	r1,0x10
80011ff8:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
80011ffc:	e0 05 03 41 	mac	r1,r0,r5
80012000:	ab 32       	mul	r2,r5
80012002:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
80012006:	00 02       	add	r2,r0
80012008:	e4 0e 00 0e 	add	lr,r2,lr
8001200c:	b0 1e       	st.h	r8[0x2],lr
8001200e:	b1 8e       	lsr	lr,0x10
80012010:	1c 01       	add	r1,lr
80012012:	b0 01       	st.h	r8[0x0],r1
80012014:	e2 0e 16 10 	lsr	lr,r1,0x10
80012018:	2f c8       	sub	r8,-4
8001201a:	06 36       	cp.w	r6,r3
8001201c:	ce 83       	brcs	80011fec <__multiply+0x6c>
8001201e:	40 09       	lddsp	r9,sp[0x0]
80012020:	91 0e       	st.w	r8[0x0],lr
80012022:	94 86       	ld.uh	r6,r10[0x0]
80012024:	58 06       	cp.w	r6,0
80012026:	c1 d0       	breq	80012060 <__multiply+0xe0>
80012028:	72 02       	ld.w	r2,r9[0x0]
8001202a:	12 98       	mov	r8,r9
8001202c:	16 9e       	mov	lr,r11
8001202e:	30 05       	mov	r5,0
80012030:	b0 12       	st.h	r8[0x2],r2
80012032:	1d 01       	ld.w	r1,lr++
80012034:	90 82       	ld.uh	r2,r8[0x0]
80012036:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8001203a:	ad 30       	mul	r0,r6
8001203c:	e0 02 00 02 	add	r2,r0,r2
80012040:	e4 05 00 05 	add	r5,r2,r5
80012044:	b0 05       	st.h	r8[0x0],r5
80012046:	b1 85       	lsr	r5,0x10
80012048:	b1 81       	lsr	r1,0x10
8001204a:	2f c8       	sub	r8,-4
8001204c:	ad 31       	mul	r1,r6
8001204e:	90 92       	ld.uh	r2,r8[0x2]
80012050:	e2 02 00 02 	add	r2,r1,r2
80012054:	0a 02       	add	r2,r5
80012056:	e4 05 16 10 	lsr	r5,r2,0x10
8001205a:	06 3e       	cp.w	lr,r3
8001205c:	ce a3       	brcs	80012030 <__multiply+0xb0>
8001205e:	91 02       	st.w	r8[0x0],r2
80012060:	2f ca       	sub	r10,-4
80012062:	2f c9       	sub	r9,-4
80012064:	40 18       	lddsp	r8,sp[0x4]
80012066:	10 3a       	cp.w	r10,r8
80012068:	cb b3       	brcs	80011fde <__multiply+0x5e>
8001206a:	c0 28       	rjmp	8001206e <__multiply+0xee>
8001206c:	20 17       	sub	r7,1
8001206e:	58 07       	cp.w	r7,0
80012070:	e0 8a 00 05 	brle	8001207a <__multiply+0xfa>
80012074:	09 48       	ld.w	r8,--r4
80012076:	58 08       	cp.w	r8,0
80012078:	cf a0       	breq	8001206c <__multiply+0xec>
8001207a:	99 47       	st.w	r12[0x10],r7
8001207c:	2f ed       	sub	sp,-8
8001207e:	d8 32       	popm	r0-r7,pc

80012080 <__i2b>:
80012080:	d4 21       	pushm	r4-r7,lr
80012082:	16 97       	mov	r7,r11
80012084:	30 1b       	mov	r11,1
80012086:	c4 9e       	rcall	80011d18 <_Balloc>
80012088:	30 19       	mov	r9,1
8001208a:	99 57       	st.w	r12[0x14],r7
8001208c:	99 49       	st.w	r12[0x10],r9
8001208e:	d8 22       	popm	r4-r7,pc

80012090 <__multadd>:
80012090:	d4 31       	pushm	r0-r7,lr
80012092:	30 08       	mov	r8,0
80012094:	12 95       	mov	r5,r9
80012096:	16 97       	mov	r7,r11
80012098:	18 96       	mov	r6,r12
8001209a:	76 44       	ld.w	r4,r11[0x10]
8001209c:	f6 c9 ff ec 	sub	r9,r11,-20
800120a0:	72 0b       	ld.w	r11,r9[0x0]
800120a2:	f6 0c 16 10 	lsr	r12,r11,0x10
800120a6:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
800120aa:	f4 0c 02 4c 	mul	r12,r10,r12
800120ae:	f4 0b 03 45 	mac	r5,r10,r11
800120b2:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
800120b6:	b1 85       	lsr	r5,0x10
800120b8:	18 05       	add	r5,r12
800120ba:	ea 0c 15 10 	lsl	r12,r5,0x10
800120be:	f8 0b 00 0b 	add	r11,r12,r11
800120c2:	12 ab       	st.w	r9++,r11
800120c4:	2f f8       	sub	r8,-1
800120c6:	b1 85       	lsr	r5,0x10
800120c8:	08 38       	cp.w	r8,r4
800120ca:	ce b5       	brlt	800120a0 <__multadd+0x10>
800120cc:	58 05       	cp.w	r5,0
800120ce:	c1 c0       	breq	80012106 <__multadd+0x76>
800120d0:	6e 28       	ld.w	r8,r7[0x8]
800120d2:	10 34       	cp.w	r4,r8
800120d4:	c1 35       	brlt	800120fa <__multadd+0x6a>
800120d6:	6e 1b       	ld.w	r11,r7[0x4]
800120d8:	0c 9c       	mov	r12,r6
800120da:	2f fb       	sub	r11,-1
800120dc:	c1 ee       	rcall	80011d18 <_Balloc>
800120de:	6e 4a       	ld.w	r10,r7[0x10]
800120e0:	ee cb ff f4 	sub	r11,r7,-12
800120e4:	18 93       	mov	r3,r12
800120e6:	2f ea       	sub	r10,-2
800120e8:	2f 4c       	sub	r12,-12
800120ea:	a3 6a       	lsl	r10,0x2
800120ec:	fe b0 d2 a6 	rcall	8000c638 <memcpy>
800120f0:	0e 9b       	mov	r11,r7
800120f2:	0c 9c       	mov	r12,r6
800120f4:	fe b0 fd f8 	rcall	80011ce4 <_Bfree>
800120f8:	06 97       	mov	r7,r3
800120fa:	e8 c8 ff ff 	sub	r8,r4,-1
800120fe:	2f b4       	sub	r4,-5
80012100:	8f 48       	st.w	r7[0x10],r8
80012102:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
80012106:	0e 9c       	mov	r12,r7
80012108:	d8 32       	popm	r0-r7,pc
8001210a:	d7 03       	nop

8001210c <__pow5mult>:
8001210c:	d4 31       	pushm	r0-r7,lr
8001210e:	14 96       	mov	r6,r10
80012110:	18 97       	mov	r7,r12
80012112:	16 94       	mov	r4,r11
80012114:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
80012118:	c0 90       	breq	8001212a <__pow5mult+0x1e>
8001211a:	20 18       	sub	r8,1
8001211c:	fe c9 b2 d8 	sub	r9,pc,-19752
80012120:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
80012124:	30 09       	mov	r9,0
80012126:	cb 5f       	rcall	80012090 <__multadd>
80012128:	18 94       	mov	r4,r12
8001212a:	a3 46       	asr	r6,0x2
8001212c:	c3 40       	breq	80012194 <__pow5mult+0x88>
8001212e:	6e 95       	ld.w	r5,r7[0x24]
80012130:	58 05       	cp.w	r5,0
80012132:	c0 91       	brne	80012144 <__pow5mult+0x38>
80012134:	31 0c       	mov	r12,16
80012136:	fe b0 d0 63 	rcall	8000c1fc <malloc>
8001213a:	99 35       	st.w	r12[0xc],r5
8001213c:	8f 9c       	st.w	r7[0x24],r12
8001213e:	99 15       	st.w	r12[0x4],r5
80012140:	99 25       	st.w	r12[0x8],r5
80012142:	99 05       	st.w	r12[0x0],r5
80012144:	6e 93       	ld.w	r3,r7[0x24]
80012146:	66 25       	ld.w	r5,r3[0x8]
80012148:	58 05       	cp.w	r5,0
8001214a:	c0 c1       	brne	80012162 <__pow5mult+0x56>
8001214c:	e0 6b 02 71 	mov	r11,625
80012150:	0e 9c       	mov	r12,r7
80012152:	c9 7f       	rcall	80012080 <__i2b>
80012154:	87 2c       	st.w	r3[0x8],r12
80012156:	30 08       	mov	r8,0
80012158:	18 95       	mov	r5,r12
8001215a:	99 08       	st.w	r12[0x0],r8
8001215c:	c0 38       	rjmp	80012162 <__pow5mult+0x56>
8001215e:	06 9c       	mov	r12,r3
80012160:	18 95       	mov	r5,r12
80012162:	ed b6 00 00 	bld	r6,0x0
80012166:	c0 b1       	brne	8001217c <__pow5mult+0x70>
80012168:	08 9b       	mov	r11,r4
8001216a:	0a 9a       	mov	r10,r5
8001216c:	0e 9c       	mov	r12,r7
8001216e:	c0 9f       	rcall	80011f80 <__multiply>
80012170:	08 9b       	mov	r11,r4
80012172:	18 93       	mov	r3,r12
80012174:	0e 9c       	mov	r12,r7
80012176:	06 94       	mov	r4,r3
80012178:	fe b0 fd b6 	rcall	80011ce4 <_Bfree>
8001217c:	a1 56       	asr	r6,0x1
8001217e:	c0 b0       	breq	80012194 <__pow5mult+0x88>
80012180:	6a 03       	ld.w	r3,r5[0x0]
80012182:	58 03       	cp.w	r3,0
80012184:	ce d1       	brne	8001215e <__pow5mult+0x52>
80012186:	0a 9a       	mov	r10,r5
80012188:	0a 9b       	mov	r11,r5
8001218a:	0e 9c       	mov	r12,r7
8001218c:	cf ae       	rcall	80011f80 <__multiply>
8001218e:	8b 0c       	st.w	r5[0x0],r12
80012190:	99 03       	st.w	r12[0x0],r3
80012192:	ce 7b       	rjmp	80012160 <__pow5mult+0x54>
80012194:	08 9c       	mov	r12,r4
80012196:	d8 32       	popm	r0-r7,pc

80012198 <_realloc_r>:
80012198:	d4 31       	pushm	r0-r7,lr
8001219a:	20 1d       	sub	sp,4
8001219c:	16 94       	mov	r4,r11
8001219e:	18 92       	mov	r2,r12
800121a0:	14 9b       	mov	r11,r10
800121a2:	58 04       	cp.w	r4,0
800121a4:	c0 51       	brne	800121ae <_realloc_r+0x16>
800121a6:	fe b0 d0 33 	rcall	8000c20c <_malloc_r>
800121aa:	18 95       	mov	r5,r12
800121ac:	c5 39       	rjmp	80012452 <_realloc_r+0x2ba>
800121ae:	50 0a       	stdsp	sp[0x0],r10
800121b0:	fe b0 d2 ef 	rcall	8000c78e <__malloc_lock>
800121b4:	40 0b       	lddsp	r11,sp[0x0]
800121b6:	f6 c8 ff f5 	sub	r8,r11,-11
800121ba:	e8 c1 00 08 	sub	r1,r4,8
800121be:	10 96       	mov	r6,r8
800121c0:	62 1c       	ld.w	r12,r1[0x4]
800121c2:	e0 16 ff f8 	andl	r6,0xfff8
800121c6:	59 68       	cp.w	r8,22
800121c8:	f9 b6 08 10 	movls	r6,16
800121cc:	16 36       	cp.w	r6,r11
800121ce:	5f 38       	srlo	r8
800121d0:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
800121d4:	c0 50       	breq	800121de <_realloc_r+0x46>
800121d6:	30 c8       	mov	r8,12
800121d8:	30 05       	mov	r5,0
800121da:	85 38       	st.w	r2[0xc],r8
800121dc:	c3 b9       	rjmp	80012452 <_realloc_r+0x2ba>
800121de:	18 90       	mov	r0,r12
800121e0:	e0 10 ff fc 	andl	r0,0xfffc
800121e4:	0c 30       	cp.w	r0,r6
800121e6:	e0 84 01 0b 	brge	800123fc <_realloc_r+0x264>
800121ea:	e0 68 02 30 	mov	r8,560
800121ee:	e2 00 00 09 	add	r9,r1,r0
800121f2:	70 25       	ld.w	r5,r8[0x8]
800121f4:	0a 39       	cp.w	r9,r5
800121f6:	c0 90       	breq	80012208 <_realloc_r+0x70>
800121f8:	72 1a       	ld.w	r10,r9[0x4]
800121fa:	a1 ca       	cbr	r10,0x0
800121fc:	f2 0a 00 0a 	add	r10,r9,r10
80012200:	74 1a       	ld.w	r10,r10[0x4]
80012202:	ed ba 00 00 	bld	r10,0x0
80012206:	c2 20       	breq	8001224a <_realloc_r+0xb2>
80012208:	72 1a       	ld.w	r10,r9[0x4]
8001220a:	e0 1a ff fc 	andl	r10,0xfffc
8001220e:	f4 00 00 03 	add	r3,r10,r0
80012212:	0a 39       	cp.w	r9,r5
80012214:	c1 31       	brne	8001223a <_realloc_r+0xa2>
80012216:	ec c7 ff f0 	sub	r7,r6,-16
8001221a:	0e 33       	cp.w	r3,r7
8001221c:	c1 95       	brlt	8001224e <_realloc_r+0xb6>
8001221e:	e2 06 00 09 	add	r9,r1,r6
80012222:	0c 13       	sub	r3,r6
80012224:	a1 a3       	sbr	r3,0x0
80012226:	93 13       	st.w	r9[0x4],r3
80012228:	91 29       	st.w	r8[0x8],r9
8001222a:	04 9c       	mov	r12,r2
8001222c:	62 18       	ld.w	r8,r1[0x4]
8001222e:	08 95       	mov	r5,r4
80012230:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80012234:	10 46       	or	r6,r8
80012236:	83 16       	st.w	r1[0x4],r6
80012238:	c0 b9       	rjmp	8001244e <_realloc_r+0x2b6>
8001223a:	0c 33       	cp.w	r3,r6
8001223c:	c0 95       	brlt	8001224e <_realloc_r+0xb6>
8001223e:	72 28       	ld.w	r8,r9[0x8]
80012240:	02 97       	mov	r7,r1
80012242:	72 39       	ld.w	r9,r9[0xc]
80012244:	93 28       	st.w	r9[0x8],r8
80012246:	91 39       	st.w	r8[0xc],r9
80012248:	cd c8       	rjmp	80012400 <_realloc_r+0x268>
8001224a:	30 0a       	mov	r10,0
8001224c:	14 99       	mov	r9,r10
8001224e:	ed bc 00 00 	bld	r12,0x0
80012252:	e0 80 00 95 	breq	8001237c <_realloc_r+0x1e4>
80012256:	62 07       	ld.w	r7,r1[0x0]
80012258:	e2 07 01 07 	sub	r7,r1,r7
8001225c:	6e 1c       	ld.w	r12,r7[0x4]
8001225e:	e0 1c ff fc 	andl	r12,0xfffc
80012262:	58 09       	cp.w	r9,0
80012264:	c5 60       	breq	80012310 <_realloc_r+0x178>
80012266:	f8 00 00 03 	add	r3,r12,r0
8001226a:	0a 39       	cp.w	r9,r5
8001226c:	c4 81       	brne	800122fc <_realloc_r+0x164>
8001226e:	14 03       	add	r3,r10
80012270:	ec c9 ff f0 	sub	r9,r6,-16
80012274:	12 33       	cp.w	r3,r9
80012276:	c4 d5       	brlt	80012310 <_realloc_r+0x178>
80012278:	6e 3a       	ld.w	r10,r7[0xc]
8001227a:	6e 29       	ld.w	r9,r7[0x8]
8001227c:	95 29       	st.w	r10[0x8],r9
8001227e:	93 3a       	st.w	r9[0xc],r10
80012280:	ee c5 ff f8 	sub	r5,r7,-8
80012284:	e0 ca 00 04 	sub	r10,r0,4
80012288:	e0 4a 00 24 	cp.w	r10,36
8001228c:	e0 8b 00 25 	brhi	800122d6 <_realloc_r+0x13e>
80012290:	0a 99       	mov	r9,r5
80012292:	59 3a       	cp.w	r10,19
80012294:	e0 88 00 1a 	brls	800122c8 <_realloc_r+0x130>
80012298:	09 09       	ld.w	r9,r4++
8001229a:	8b 09       	st.w	r5[0x0],r9
8001229c:	09 09       	ld.w	r9,r4++
8001229e:	8f 39       	st.w	r7[0xc],r9
800122a0:	ee c9 ff f0 	sub	r9,r7,-16
800122a4:	59 ba       	cp.w	r10,27
800122a6:	e0 88 00 11 	brls	800122c8 <_realloc_r+0x130>
800122aa:	09 0b       	ld.w	r11,r4++
800122ac:	93 0b       	st.w	r9[0x0],r11
800122ae:	09 09       	ld.w	r9,r4++
800122b0:	8f 59       	st.w	r7[0x14],r9
800122b2:	ee c9 ff e8 	sub	r9,r7,-24
800122b6:	e0 4a 00 24 	cp.w	r10,36
800122ba:	c0 71       	brne	800122c8 <_realloc_r+0x130>
800122bc:	09 0a       	ld.w	r10,r4++
800122be:	93 0a       	st.w	r9[0x0],r10
800122c0:	ee c9 ff e0 	sub	r9,r7,-32
800122c4:	09 0a       	ld.w	r10,r4++
800122c6:	8f 7a       	st.w	r7[0x1c],r10
800122c8:	09 0a       	ld.w	r10,r4++
800122ca:	12 aa       	st.w	r9++,r10
800122cc:	68 0a       	ld.w	r10,r4[0x0]
800122ce:	93 0a       	st.w	r9[0x0],r10
800122d0:	68 1a       	ld.w	r10,r4[0x4]
800122d2:	93 1a       	st.w	r9[0x4],r10
800122d4:	c0 78       	rjmp	800122e2 <_realloc_r+0x14a>
800122d6:	50 08       	stdsp	sp[0x0],r8
800122d8:	08 9b       	mov	r11,r4
800122da:	0a 9c       	mov	r12,r5
800122dc:	fe b0 fc 55 	rcall	80011b86 <memmove>
800122e0:	40 08       	lddsp	r8,sp[0x0]
800122e2:	ee 06 00 09 	add	r9,r7,r6
800122e6:	0c 13       	sub	r3,r6
800122e8:	a1 a3       	sbr	r3,0x0
800122ea:	93 13       	st.w	r9[0x4],r3
800122ec:	91 29       	st.w	r8[0x8],r9
800122ee:	04 9c       	mov	r12,r2
800122f0:	6e 18       	ld.w	r8,r7[0x4]
800122f2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800122f6:	10 46       	or	r6,r8
800122f8:	8f 16       	st.w	r7[0x4],r6
800122fa:	ca a8       	rjmp	8001244e <_realloc_r+0x2b6>
800122fc:	14 03       	add	r3,r10
800122fe:	0c 33       	cp.w	r3,r6
80012300:	c0 85       	brlt	80012310 <_realloc_r+0x178>
80012302:	72 28       	ld.w	r8,r9[0x8]
80012304:	72 39       	ld.w	r9,r9[0xc]
80012306:	93 28       	st.w	r9[0x8],r8
80012308:	91 39       	st.w	r8[0xc],r9
8001230a:	6e 28       	ld.w	r8,r7[0x8]
8001230c:	6e 39       	ld.w	r9,r7[0xc]
8001230e:	c0 78       	rjmp	8001231c <_realloc_r+0x184>
80012310:	f8 00 00 03 	add	r3,r12,r0
80012314:	0c 33       	cp.w	r3,r6
80012316:	c3 35       	brlt	8001237c <_realloc_r+0x1e4>
80012318:	6e 39       	ld.w	r9,r7[0xc]
8001231a:	6e 28       	ld.w	r8,r7[0x8]
8001231c:	93 28       	st.w	r9[0x8],r8
8001231e:	91 39       	st.w	r8[0xc],r9
80012320:	e0 ca 00 04 	sub	r10,r0,4
80012324:	ee cc ff f8 	sub	r12,r7,-8
80012328:	e0 4a 00 24 	cp.w	r10,36
8001232c:	e0 8b 00 24 	brhi	80012374 <_realloc_r+0x1dc>
80012330:	59 3a       	cp.w	r10,19
80012332:	e0 88 00 1a 	brls	80012366 <_realloc_r+0x1ce>
80012336:	09 08       	ld.w	r8,r4++
80012338:	99 08       	st.w	r12[0x0],r8
8001233a:	09 08       	ld.w	r8,r4++
8001233c:	8f 38       	st.w	r7[0xc],r8
8001233e:	ee cc ff f0 	sub	r12,r7,-16
80012342:	59 ba       	cp.w	r10,27
80012344:	e0 88 00 11 	brls	80012366 <_realloc_r+0x1ce>
80012348:	09 08       	ld.w	r8,r4++
8001234a:	99 08       	st.w	r12[0x0],r8
8001234c:	09 08       	ld.w	r8,r4++
8001234e:	8f 58       	st.w	r7[0x14],r8
80012350:	ee cc ff e8 	sub	r12,r7,-24
80012354:	e0 4a 00 24 	cp.w	r10,36
80012358:	c0 71       	brne	80012366 <_realloc_r+0x1ce>
8001235a:	09 08       	ld.w	r8,r4++
8001235c:	99 08       	st.w	r12[0x0],r8
8001235e:	ee cc ff e0 	sub	r12,r7,-32
80012362:	09 08       	ld.w	r8,r4++
80012364:	8f 78       	st.w	r7[0x1c],r8
80012366:	09 08       	ld.w	r8,r4++
80012368:	18 a8       	st.w	r12++,r8
8001236a:	68 08       	ld.w	r8,r4[0x0]
8001236c:	99 08       	st.w	r12[0x0],r8
8001236e:	68 18       	ld.w	r8,r4[0x4]
80012370:	99 18       	st.w	r12[0x4],r8
80012372:	c4 78       	rjmp	80012400 <_realloc_r+0x268>
80012374:	08 9b       	mov	r11,r4
80012376:	fe b0 fc 08 	rcall	80011b86 <memmove>
8001237a:	c4 38       	rjmp	80012400 <_realloc_r+0x268>
8001237c:	04 9c       	mov	r12,r2
8001237e:	fe b0 cf 47 	rcall	8000c20c <_malloc_r>
80012382:	18 95       	mov	r5,r12
80012384:	c3 a0       	breq	800123f8 <_realloc_r+0x260>
80012386:	62 18       	ld.w	r8,r1[0x4]
80012388:	f8 c9 00 08 	sub	r9,r12,8
8001238c:	a1 c8       	cbr	r8,0x0
8001238e:	e2 08 00 08 	add	r8,r1,r8
80012392:	10 39       	cp.w	r9,r8
80012394:	c0 71       	brne	800123a2 <_realloc_r+0x20a>
80012396:	72 13       	ld.w	r3,r9[0x4]
80012398:	02 97       	mov	r7,r1
8001239a:	e0 13 ff fc 	andl	r3,0xfffc
8001239e:	00 03       	add	r3,r0
800123a0:	c3 08       	rjmp	80012400 <_realloc_r+0x268>
800123a2:	e0 ca 00 04 	sub	r10,r0,4
800123a6:	e0 4a 00 24 	cp.w	r10,36
800123aa:	e0 8b 00 20 	brhi	800123ea <_realloc_r+0x252>
800123ae:	08 99       	mov	r9,r4
800123b0:	18 98       	mov	r8,r12
800123b2:	59 3a       	cp.w	r10,19
800123b4:	e0 88 00 14 	brls	800123dc <_realloc_r+0x244>
800123b8:	13 0b       	ld.w	r11,r9++
800123ba:	10 ab       	st.w	r8++,r11
800123bc:	13 0b       	ld.w	r11,r9++
800123be:	10 ab       	st.w	r8++,r11
800123c0:	59 ba       	cp.w	r10,27
800123c2:	e0 88 00 0d 	brls	800123dc <_realloc_r+0x244>
800123c6:	13 0b       	ld.w	r11,r9++
800123c8:	10 ab       	st.w	r8++,r11
800123ca:	13 0b       	ld.w	r11,r9++
800123cc:	10 ab       	st.w	r8++,r11
800123ce:	e0 4a 00 24 	cp.w	r10,36
800123d2:	c0 51       	brne	800123dc <_realloc_r+0x244>
800123d4:	13 0a       	ld.w	r10,r9++
800123d6:	10 aa       	st.w	r8++,r10
800123d8:	13 0a       	ld.w	r10,r9++
800123da:	10 aa       	st.w	r8++,r10
800123dc:	13 0a       	ld.w	r10,r9++
800123de:	10 aa       	st.w	r8++,r10
800123e0:	72 0a       	ld.w	r10,r9[0x0]
800123e2:	91 0a       	st.w	r8[0x0],r10
800123e4:	72 19       	ld.w	r9,r9[0x4]
800123e6:	91 19       	st.w	r8[0x4],r9
800123e8:	c0 48       	rjmp	800123f0 <_realloc_r+0x258>
800123ea:	08 9b       	mov	r11,r4
800123ec:	fe b0 fb cd 	rcall	80011b86 <memmove>
800123f0:	08 9b       	mov	r11,r4
800123f2:	04 9c       	mov	r12,r2
800123f4:	fe b0 f9 26 	rcall	80011640 <_free_r>
800123f8:	04 9c       	mov	r12,r2
800123fa:	c2 a8       	rjmp	8001244e <_realloc_r+0x2b6>
800123fc:	00 93       	mov	r3,r0
800123fe:	02 97       	mov	r7,r1
80012400:	e6 06 01 09 	sub	r9,r3,r6
80012404:	6e 18       	ld.w	r8,r7[0x4]
80012406:	58 f9       	cp.w	r9,15
80012408:	e0 88 00 16 	brls	80012434 <_realloc_r+0x29c>
8001240c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80012410:	ed e8 10 08 	or	r8,r6,r8
80012414:	8f 18       	st.w	r7[0x4],r8
80012416:	12 98       	mov	r8,r9
80012418:	a1 a8       	sbr	r8,0x0
8001241a:	ee 06 00 0b 	add	r11,r7,r6
8001241e:	f6 09 00 09 	add	r9,r11,r9
80012422:	97 18       	st.w	r11[0x4],r8
80012424:	72 18       	ld.w	r8,r9[0x4]
80012426:	a1 a8       	sbr	r8,0x0
80012428:	2f 8b       	sub	r11,-8
8001242a:	93 18       	st.w	r9[0x4],r8
8001242c:	04 9c       	mov	r12,r2
8001242e:	fe b0 f9 09 	rcall	80011640 <_free_r>
80012432:	c0 b8       	rjmp	80012448 <_realloc_r+0x2b0>
80012434:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80012438:	e7 e8 10 08 	or	r8,r3,r8
8001243c:	8f 18       	st.w	r7[0x4],r8
8001243e:	ee 03 00 03 	add	r3,r7,r3
80012442:	66 18       	ld.w	r8,r3[0x4]
80012444:	a1 a8       	sbr	r8,0x0
80012446:	87 18       	st.w	r3[0x4],r8
80012448:	04 9c       	mov	r12,r2
8001244a:	ee c5 ff f8 	sub	r5,r7,-8
8001244e:	fe b0 d1 a1 	rcall	8000c790 <__malloc_unlock>
80012452:	0a 9c       	mov	r12,r5
80012454:	2f fd       	sub	sp,-4
80012456:	d8 32       	popm	r0-r7,pc

80012458 <__isinfd>:
80012458:	14 98       	mov	r8,r10
8001245a:	fc 19 7f f0 	movh	r9,0x7ff0
8001245e:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
80012462:	f0 0b 11 00 	rsub	r11,r8,0
80012466:	f7 e8 10 08 	or	r8,r11,r8
8001246a:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8001246e:	f2 08 01 08 	sub	r8,r9,r8
80012472:	f0 0c 11 00 	rsub	r12,r8,0
80012476:	f9 e8 10 08 	or	r8,r12,r8
8001247a:	f0 0c 14 1f 	asr	r12,r8,0x1f
8001247e:	2f fc       	sub	r12,-1
80012480:	5e fc       	retal	r12

80012482 <__isnand>:
80012482:	14 98       	mov	r8,r10
80012484:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
80012488:	f0 0c 11 00 	rsub	r12,r8,0
8001248c:	10 4c       	or	r12,r8
8001248e:	fc 18 7f f0 	movh	r8,0x7ff0
80012492:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
80012496:	f0 0c 01 0c 	sub	r12,r8,r12
8001249a:	bf 9c       	lsr	r12,0x1f
8001249c:	5e fc       	retal	r12
8001249e:	d7 03       	nop

800124a0 <_raise_r>:
800124a0:	d4 21       	pushm	r4-r7,lr
800124a2:	18 97       	mov	r7,r12
800124a4:	16 96       	mov	r6,r11
800124a6:	59 fb       	cp.w	r11,31
800124a8:	e0 88 00 05 	brls	800124b2 <_raise_r+0x12>
800124ac:	31 68       	mov	r8,22
800124ae:	99 38       	st.w	r12[0xc],r8
800124b0:	dc 2a       	popm	r4-r7,pc,r12=-1
800124b2:	79 19       	ld.w	r9,r12[0x44]
800124b4:	58 09       	cp.w	r9,0
800124b6:	c0 60       	breq	800124c2 <_raise_r+0x22>
800124b8:	f2 0b 00 29 	add	r9,r9,r11<<0x2
800124bc:	72 08       	ld.w	r8,r9[0x0]
800124be:	58 08       	cp.w	r8,0
800124c0:	c0 81       	brne	800124d0 <_raise_r+0x30>
800124c2:	0e 9c       	mov	r12,r7
800124c4:	c1 cc       	rcall	800124fc <_getpid_r>
800124c6:	0c 9a       	mov	r10,r6
800124c8:	18 9b       	mov	r11,r12
800124ca:	0e 9c       	mov	r12,r7
800124cc:	c1 cc       	rcall	80012504 <_kill_r>
800124ce:	d8 22       	popm	r4-r7,pc
800124d0:	58 18       	cp.w	r8,1
800124d2:	c0 21       	brne	800124d6 <_raise_r+0x36>
800124d4:	d8 2a       	popm	r4-r7,pc,r12=0
800124d6:	5b f8       	cp.w	r8,-1
800124d8:	c0 41       	brne	800124e0 <_raise_r+0x40>
800124da:	31 68       	mov	r8,22
800124dc:	99 38       	st.w	r12[0xc],r8
800124de:	da 2a       	popm	r4-r7,pc,r12=1
800124e0:	30 07       	mov	r7,0
800124e2:	16 9c       	mov	r12,r11
800124e4:	93 07       	st.w	r9[0x0],r7
800124e6:	5d 18       	icall	r8
800124e8:	0e 9c       	mov	r12,r7
800124ea:	d8 22       	popm	r4-r7,pc

800124ec <raise>:
800124ec:	d4 01       	pushm	lr
800124ee:	e0 68 02 2c 	mov	r8,556
800124f2:	18 9b       	mov	r11,r12
800124f4:	70 0c       	ld.w	r12,r8[0x0]
800124f6:	cd 5f       	rcall	800124a0 <_raise_r>
800124f8:	d8 02       	popm	pc
800124fa:	d7 03       	nop

800124fc <_getpid_r>:
800124fc:	d4 01       	pushm	lr
800124fe:	fe b0 d1 f8 	rcall	8000c8ee <_getpid>
80012502:	d8 02       	popm	pc

80012504 <_kill_r>:
80012504:	d4 21       	pushm	r4-r7,lr
80012506:	16 98       	mov	r8,r11
80012508:	18 97       	mov	r7,r12
8001250a:	10 9c       	mov	r12,r8
8001250c:	30 08       	mov	r8,0
8001250e:	e0 66 0e fc 	mov	r6,3836
80012512:	14 9b       	mov	r11,r10
80012514:	8d 08       	st.w	r6[0x0],r8
80012516:	fe b0 d1 eb 	rcall	8000c8ec <_kill>
8001251a:	5b fc       	cp.w	r12,-1
8001251c:	c0 51       	brne	80012526 <_kill_r+0x22>
8001251e:	6c 08       	ld.w	r8,r6[0x0]
80012520:	58 08       	cp.w	r8,0
80012522:	ef f8 1a 03 	st.wne	r7[0xc],r8
80012526:	d8 22       	popm	r4-r7,pc

80012528 <__sclose>:
80012528:	d4 01       	pushm	lr
8001252a:	96 7b       	ld.sh	r11,r11[0xe]
8001252c:	c8 2c       	rcall	80012630 <_close_r>
8001252e:	d8 02       	popm	pc

80012530 <__sseek>:
80012530:	d4 21       	pushm	r4-r7,lr
80012532:	16 97       	mov	r7,r11
80012534:	96 7b       	ld.sh	r11,r11[0xe]
80012536:	c0 3d       	rcall	8001273c <_lseek_r>
80012538:	8e 68       	ld.sh	r8,r7[0xc]
8001253a:	10 99       	mov	r9,r8
8001253c:	ad c8       	cbr	r8,0xc
8001253e:	ad a9       	sbr	r9,0xc
80012540:	5b fc       	cp.w	r12,-1
80012542:	ef f8 0c 06 	st.heq	r7[0xc],r8
80012546:	ef f9 1c 06 	st.hne	r7[0xc],r9
8001254a:	ef fc 1a 15 	st.wne	r7[0x54],r12
8001254e:	d8 22       	popm	r4-r7,pc

80012550 <__swrite>:
80012550:	d4 21       	pushm	r4-r7,lr
80012552:	96 68       	ld.sh	r8,r11[0xc]
80012554:	16 97       	mov	r7,r11
80012556:	14 95       	mov	r5,r10
80012558:	12 94       	mov	r4,r9
8001255a:	e2 18 01 00 	andl	r8,0x100,COH
8001255e:	18 96       	mov	r6,r12
80012560:	c0 50       	breq	8001256a <__swrite+0x1a>
80012562:	30 29       	mov	r9,2
80012564:	30 0a       	mov	r10,0
80012566:	96 7b       	ld.sh	r11,r11[0xe]
80012568:	ce ac       	rcall	8001273c <_lseek_r>
8001256a:	8e 68       	ld.sh	r8,r7[0xc]
8001256c:	ad c8       	cbr	r8,0xc
8001256e:	08 99       	mov	r9,r4
80012570:	0a 9a       	mov	r10,r5
80012572:	8e 7b       	ld.sh	r11,r7[0xe]
80012574:	0c 9c       	mov	r12,r6
80012576:	ae 68       	st.h	r7[0xc],r8
80012578:	c1 cc       	rcall	800125b0 <_write_r>
8001257a:	d8 22       	popm	r4-r7,pc

8001257c <__sread>:
8001257c:	d4 21       	pushm	r4-r7,lr
8001257e:	16 97       	mov	r7,r11
80012580:	96 7b       	ld.sh	r11,r11[0xe]
80012582:	cf 1c       	rcall	80012764 <_read_r>
80012584:	c0 65       	brlt	80012590 <__sread+0x14>
80012586:	6f 58       	ld.w	r8,r7[0x54]
80012588:	18 08       	add	r8,r12
8001258a:	ef 48 00 54 	st.w	r7[84],r8
8001258e:	d8 22       	popm	r4-r7,pc
80012590:	8e 68       	ld.sh	r8,r7[0xc]
80012592:	ad c8       	cbr	r8,0xc
80012594:	ae 68       	st.h	r7[0xc],r8
80012596:	d8 22       	popm	r4-r7,pc

80012598 <strlen>:
80012598:	30 09       	mov	r9,0
8001259a:	18 98       	mov	r8,r12
8001259c:	c0 28       	rjmp	800125a0 <strlen+0x8>
8001259e:	2f f8       	sub	r8,-1
800125a0:	11 8a       	ld.ub	r10,r8[0x0]
800125a2:	f2 0a 18 00 	cp.b	r10,r9
800125a6:	cf c1       	brne	8001259e <strlen+0x6>
800125a8:	f0 0c 01 0c 	sub	r12,r8,r12
800125ac:	5e fc       	retal	r12
800125ae:	d7 03       	nop

800125b0 <_write_r>:
800125b0:	d4 21       	pushm	r4-r7,lr
800125b2:	16 98       	mov	r8,r11
800125b4:	18 97       	mov	r7,r12
800125b6:	10 9c       	mov	r12,r8
800125b8:	30 08       	mov	r8,0
800125ba:	14 9b       	mov	r11,r10
800125bc:	e0 66 0e fc 	mov	r6,3836
800125c0:	12 9a       	mov	r10,r9
800125c2:	8d 08       	st.w	r6[0x0],r8
800125c4:	fe b0 d1 50 	rcall	8000c864 <_write>
800125c8:	5b fc       	cp.w	r12,-1
800125ca:	c0 51       	brne	800125d4 <_write_r+0x24>
800125cc:	6c 08       	ld.w	r8,r6[0x0]
800125ce:	58 08       	cp.w	r8,0
800125d0:	ef f8 1a 03 	st.wne	r7[0xc],r8
800125d4:	d8 22       	popm	r4-r7,pc
800125d6:	d7 03       	nop

800125d8 <_calloc_r>:
800125d8:	d4 21       	pushm	r4-r7,lr
800125da:	f4 0b 02 4b 	mul	r11,r10,r11
800125de:	fe b0 ce 17 	rcall	8000c20c <_malloc_r>
800125e2:	18 97       	mov	r7,r12
800125e4:	c2 30       	breq	8001262a <_calloc_r+0x52>
800125e6:	f8 fa ff fc 	ld.w	r10,r12[-4]
800125ea:	e0 1a ff fc 	andl	r10,0xfffc
800125ee:	20 4a       	sub	r10,4
800125f0:	e0 4a 00 24 	cp.w	r10,36
800125f4:	e0 8b 00 18 	brhi	80012624 <_calloc_r+0x4c>
800125f8:	18 98       	mov	r8,r12
800125fa:	59 3a       	cp.w	r10,19
800125fc:	e0 88 00 0f 	brls	8001261a <_calloc_r+0x42>
80012600:	30 09       	mov	r9,0
80012602:	10 a9       	st.w	r8++,r9
80012604:	10 a9       	st.w	r8++,r9
80012606:	59 ba       	cp.w	r10,27
80012608:	e0 88 00 09 	brls	8001261a <_calloc_r+0x42>
8001260c:	10 a9       	st.w	r8++,r9
8001260e:	10 a9       	st.w	r8++,r9
80012610:	e0 4a 00 24 	cp.w	r10,36
80012614:	c0 31       	brne	8001261a <_calloc_r+0x42>
80012616:	10 a9       	st.w	r8++,r9
80012618:	10 a9       	st.w	r8++,r9
8001261a:	30 09       	mov	r9,0
8001261c:	10 a9       	st.w	r8++,r9
8001261e:	91 19       	st.w	r8[0x4],r9
80012620:	91 09       	st.w	r8[0x0],r9
80012622:	c0 48       	rjmp	8001262a <_calloc_r+0x52>
80012624:	30 0b       	mov	r11,0
80012626:	fe b0 d0 ad 	rcall	8000c780 <memset>
8001262a:	0e 9c       	mov	r12,r7
8001262c:	d8 22       	popm	r4-r7,pc
8001262e:	d7 03       	nop

80012630 <_close_r>:
80012630:	d4 21       	pushm	r4-r7,lr
80012632:	30 08       	mov	r8,0
80012634:	18 97       	mov	r7,r12
80012636:	e0 66 0e fc 	mov	r6,3836
8001263a:	16 9c       	mov	r12,r11
8001263c:	8d 08       	st.w	r6[0x0],r8
8001263e:	fe b0 d0 f5 	rcall	8000c828 <_close>
80012642:	5b fc       	cp.w	r12,-1
80012644:	c0 51       	brne	8001264e <_close_r+0x1e>
80012646:	6c 08       	ld.w	r8,r6[0x0]
80012648:	58 08       	cp.w	r8,0
8001264a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8001264e:	d8 22       	popm	r4-r7,pc

80012650 <_fclose_r>:
80012650:	d4 21       	pushm	r4-r7,lr
80012652:	18 96       	mov	r6,r12
80012654:	16 97       	mov	r7,r11
80012656:	58 0b       	cp.w	r11,0
80012658:	c0 31       	brne	8001265e <_fclose_r+0xe>
8001265a:	16 95       	mov	r5,r11
8001265c:	c5 38       	rjmp	80012702 <_fclose_r+0xb2>
8001265e:	fe b0 f7 05 	rcall	80011468 <__sfp_lock_acquire>
80012662:	58 06       	cp.w	r6,0
80012664:	c0 70       	breq	80012672 <_fclose_r+0x22>
80012666:	6c 68       	ld.w	r8,r6[0x18]
80012668:	58 08       	cp.w	r8,0
8001266a:	c0 41       	brne	80012672 <_fclose_r+0x22>
8001266c:	0c 9c       	mov	r12,r6
8001266e:	fe b0 f7 4f 	rcall	8001150c <__sinit>
80012672:	fe c8 b8 ce 	sub	r8,pc,-18226
80012676:	10 37       	cp.w	r7,r8
80012678:	c0 31       	brne	8001267e <_fclose_r+0x2e>
8001267a:	6c 07       	ld.w	r7,r6[0x0]
8001267c:	c0 c8       	rjmp	80012694 <_fclose_r+0x44>
8001267e:	fe c8 b8 ba 	sub	r8,pc,-18246
80012682:	10 37       	cp.w	r7,r8
80012684:	c0 31       	brne	8001268a <_fclose_r+0x3a>
80012686:	6c 17       	ld.w	r7,r6[0x4]
80012688:	c0 68       	rjmp	80012694 <_fclose_r+0x44>
8001268a:	fe c8 b8 a6 	sub	r8,pc,-18266
8001268e:	10 37       	cp.w	r7,r8
80012690:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80012694:	8e 69       	ld.sh	r9,r7[0xc]
80012696:	30 08       	mov	r8,0
80012698:	f0 09 19 00 	cp.h	r9,r8
8001269c:	c0 51       	brne	800126a6 <_fclose_r+0x56>
8001269e:	fe b0 f6 e6 	rcall	8001146a <__sfp_lock_release>
800126a2:	30 05       	mov	r5,0
800126a4:	c2 f8       	rjmp	80012702 <_fclose_r+0xb2>
800126a6:	0e 9b       	mov	r11,r7
800126a8:	0c 9c       	mov	r12,r6
800126aa:	fe b0 f6 59 	rcall	8001135c <_fflush_r>
800126ae:	6e c8       	ld.w	r8,r7[0x30]
800126b0:	18 95       	mov	r5,r12
800126b2:	58 08       	cp.w	r8,0
800126b4:	c0 60       	breq	800126c0 <_fclose_r+0x70>
800126b6:	6e 8b       	ld.w	r11,r7[0x20]
800126b8:	0c 9c       	mov	r12,r6
800126ba:	5d 18       	icall	r8
800126bc:	f9 b5 05 ff 	movlt	r5,-1
800126c0:	8e 68       	ld.sh	r8,r7[0xc]
800126c2:	ed b8 00 07 	bld	r8,0x7
800126c6:	c0 51       	brne	800126d0 <_fclose_r+0x80>
800126c8:	6e 4b       	ld.w	r11,r7[0x10]
800126ca:	0c 9c       	mov	r12,r6
800126cc:	fe b0 f7 ba 	rcall	80011640 <_free_r>
800126d0:	6e db       	ld.w	r11,r7[0x34]
800126d2:	58 0b       	cp.w	r11,0
800126d4:	c0 a0       	breq	800126e8 <_fclose_r+0x98>
800126d6:	ee c8 ff bc 	sub	r8,r7,-68
800126da:	10 3b       	cp.w	r11,r8
800126dc:	c0 40       	breq	800126e4 <_fclose_r+0x94>
800126de:	0c 9c       	mov	r12,r6
800126e0:	fe b0 f7 b0 	rcall	80011640 <_free_r>
800126e4:	30 08       	mov	r8,0
800126e6:	8f d8       	st.w	r7[0x34],r8
800126e8:	6f 2b       	ld.w	r11,r7[0x48]
800126ea:	58 0b       	cp.w	r11,0
800126ec:	c0 70       	breq	800126fa <_fclose_r+0xaa>
800126ee:	0c 9c       	mov	r12,r6
800126f0:	fe b0 f7 a8 	rcall	80011640 <_free_r>
800126f4:	30 08       	mov	r8,0
800126f6:	ef 48 00 48 	st.w	r7[72],r8
800126fa:	30 08       	mov	r8,0
800126fc:	ae 68       	st.h	r7[0xc],r8
800126fe:	fe b0 f6 b6 	rcall	8001146a <__sfp_lock_release>
80012702:	0a 9c       	mov	r12,r5
80012704:	d8 22       	popm	r4-r7,pc
80012706:	d7 03       	nop

80012708 <fclose>:
80012708:	d4 01       	pushm	lr
8001270a:	e0 68 02 2c 	mov	r8,556
8001270e:	18 9b       	mov	r11,r12
80012710:	70 0c       	ld.w	r12,r8[0x0]
80012712:	c9 ff       	rcall	80012650 <_fclose_r>
80012714:	d8 02       	popm	pc
80012716:	d7 03       	nop

80012718 <_fstat_r>:
80012718:	d4 21       	pushm	r4-r7,lr
8001271a:	16 98       	mov	r8,r11
8001271c:	18 97       	mov	r7,r12
8001271e:	10 9c       	mov	r12,r8
80012720:	30 08       	mov	r8,0
80012722:	e0 66 0e fc 	mov	r6,3836
80012726:	14 9b       	mov	r11,r10
80012728:	8d 08       	st.w	r6[0x0],r8
8001272a:	fe b0 d0 bb 	rcall	8000c8a0 <_fstat>
8001272e:	5b fc       	cp.w	r12,-1
80012730:	c0 51       	brne	8001273a <_fstat_r+0x22>
80012732:	6c 08       	ld.w	r8,r6[0x0]
80012734:	58 08       	cp.w	r8,0
80012736:	ef f8 1a 03 	st.wne	r7[0xc],r8
8001273a:	d8 22       	popm	r4-r7,pc

8001273c <_lseek_r>:
8001273c:	d4 21       	pushm	r4-r7,lr
8001273e:	16 98       	mov	r8,r11
80012740:	18 97       	mov	r7,r12
80012742:	10 9c       	mov	r12,r8
80012744:	30 08       	mov	r8,0
80012746:	14 9b       	mov	r11,r10
80012748:	e0 66 0e fc 	mov	r6,3836
8001274c:	12 9a       	mov	r10,r9
8001274e:	8d 08       	st.w	r6[0x0],r8
80012750:	fe b0 d0 76 	rcall	8000c83c <_lseek>
80012754:	5b fc       	cp.w	r12,-1
80012756:	c0 51       	brne	80012760 <_lseek_r+0x24>
80012758:	6c 08       	ld.w	r8,r6[0x0]
8001275a:	58 08       	cp.w	r8,0
8001275c:	ef f8 1a 03 	st.wne	r7[0xc],r8
80012760:	d8 22       	popm	r4-r7,pc
80012762:	d7 03       	nop

80012764 <_read_r>:
80012764:	d4 21       	pushm	r4-r7,lr
80012766:	16 98       	mov	r8,r11
80012768:	18 97       	mov	r7,r12
8001276a:	10 9c       	mov	r12,r8
8001276c:	30 08       	mov	r8,0
8001276e:	14 9b       	mov	r11,r10
80012770:	e0 66 0e fc 	mov	r6,3836
80012774:	12 9a       	mov	r10,r9
80012776:	8d 08       	st.w	r6[0x0],r8
80012778:	fe b0 d0 6c 	rcall	8000c850 <_read>
8001277c:	5b fc       	cp.w	r12,-1
8001277e:	c0 51       	brne	80012788 <_read_r+0x24>
80012780:	6c 08       	ld.w	r8,r6[0x0]
80012782:	58 08       	cp.w	r8,0
80012784:	ef f8 1a 03 	st.wne	r7[0xc],r8
80012788:	d8 22       	popm	r4-r7,pc
8001278a:	d7 03       	nop

8001278c <__avr32_f64_cmp_eq>:
8001278c:	10 3a       	cp.w	r10,r8
8001278e:	f2 0b 13 00 	cpc	r11,r9
80012792:	c0 80       	breq	800127a2 <__avr32_f64_cmp_eq+0x16>
80012794:	a1 7b       	lsl	r11,0x1
80012796:	a1 79       	lsl	r9,0x1
80012798:	14 4b       	or	r11,r10
8001279a:	12 4b       	or	r11,r9
8001279c:	10 4b       	or	r11,r8
8001279e:	5e 0f       	reteq	1
800127a0:	5e fd       	retal	0
800127a2:	a1 7b       	lsl	r11,0x1
800127a4:	fc 1c ff e0 	movh	r12,0xffe0
800127a8:	58 0a       	cp.w	r10,0
800127aa:	f8 0b 13 00 	cpc	r11,r12
800127ae:	5e 8f       	retls	1
800127b0:	5e fd       	retal	0

800127b2 <__avr32_f64_cmp_ge>:
800127b2:	1a de       	st.w	--sp,lr
800127b4:	1a d7       	st.w	--sp,r7
800127b6:	a1 7b       	lsl	r11,0x1
800127b8:	5f 3c       	srlo	r12
800127ba:	a1 79       	lsl	r9,0x1
800127bc:	5f 37       	srlo	r7
800127be:	5c fc       	rol	r12
800127c0:	fc 1e ff e0 	movh	lr,0xffe0
800127c4:	58 0a       	cp.w	r10,0
800127c6:	fc 0b 13 00 	cpc	r11,lr
800127ca:	e0 8b 00 1d 	brhi	80012804 <__avr32_f64_cmp_ge+0x52>
800127ce:	58 08       	cp.w	r8,0
800127d0:	fc 09 13 00 	cpc	r9,lr
800127d4:	e0 8b 00 18 	brhi	80012804 <__avr32_f64_cmp_ge+0x52>
800127d8:	58 0b       	cp.w	r11,0
800127da:	f5 ba 00 00 	subfeq	r10,0
800127de:	c1 50       	breq	80012808 <__avr32_f64_cmp_ge+0x56>
800127e0:	1b 07       	ld.w	r7,sp++
800127e2:	1b 0e       	ld.w	lr,sp++
800127e4:	58 3c       	cp.w	r12,3
800127e6:	c0 a0       	breq	800127fa <__avr32_f64_cmp_ge+0x48>
800127e8:	58 1c       	cp.w	r12,1
800127ea:	c0 33       	brcs	800127f0 <__avr32_f64_cmp_ge+0x3e>
800127ec:	5e 0f       	reteq	1
800127ee:	5e 1d       	retne	0
800127f0:	10 3a       	cp.w	r10,r8
800127f2:	f2 0b 13 00 	cpc	r11,r9
800127f6:	5e 2f       	reths	1
800127f8:	5e 3d       	retlo	0
800127fa:	14 38       	cp.w	r8,r10
800127fc:	f6 09 13 00 	cpc	r9,r11
80012800:	5e 2f       	reths	1
80012802:	5e 3d       	retlo	0
80012804:	1b 07       	ld.w	r7,sp++
80012806:	d8 0a       	popm	pc,r12=0
80012808:	58 17       	cp.w	r7,1
8001280a:	5f 0c       	sreq	r12
8001280c:	58 09       	cp.w	r9,0
8001280e:	f5 b8 00 00 	subfeq	r8,0
80012812:	1b 07       	ld.w	r7,sp++
80012814:	1b 0e       	ld.w	lr,sp++
80012816:	5e 0f       	reteq	1
80012818:	5e fc       	retal	r12

8001281a <__avr32_f64_cmp_lt>:
8001281a:	1a de       	st.w	--sp,lr
8001281c:	1a d7       	st.w	--sp,r7
8001281e:	a1 7b       	lsl	r11,0x1
80012820:	5f 3c       	srlo	r12
80012822:	a1 79       	lsl	r9,0x1
80012824:	5f 37       	srlo	r7
80012826:	5c fc       	rol	r12
80012828:	fc 1e ff e0 	movh	lr,0xffe0
8001282c:	58 0a       	cp.w	r10,0
8001282e:	fc 0b 13 00 	cpc	r11,lr
80012832:	e0 8b 00 1d 	brhi	8001286c <__avr32_f64_cmp_lt+0x52>
80012836:	58 08       	cp.w	r8,0
80012838:	fc 09 13 00 	cpc	r9,lr
8001283c:	e0 8b 00 18 	brhi	8001286c <__avr32_f64_cmp_lt+0x52>
80012840:	58 0b       	cp.w	r11,0
80012842:	f5 ba 00 00 	subfeq	r10,0
80012846:	c1 50       	breq	80012870 <__avr32_f64_cmp_lt+0x56>
80012848:	1b 07       	ld.w	r7,sp++
8001284a:	1b 0e       	ld.w	lr,sp++
8001284c:	58 3c       	cp.w	r12,3
8001284e:	c0 a0       	breq	80012862 <__avr32_f64_cmp_lt+0x48>
80012850:	58 1c       	cp.w	r12,1
80012852:	c0 33       	brcs	80012858 <__avr32_f64_cmp_lt+0x3e>
80012854:	5e 0d       	reteq	0
80012856:	5e 1f       	retne	1
80012858:	10 3a       	cp.w	r10,r8
8001285a:	f2 0b 13 00 	cpc	r11,r9
8001285e:	5e 2d       	reths	0
80012860:	5e 3f       	retlo	1
80012862:	14 38       	cp.w	r8,r10
80012864:	f6 09 13 00 	cpc	r9,r11
80012868:	5e 2d       	reths	0
8001286a:	5e 3f       	retlo	1
8001286c:	1b 07       	ld.w	r7,sp++
8001286e:	d8 0a       	popm	pc,r12=0
80012870:	58 17       	cp.w	r7,1
80012872:	5f 1c       	srne	r12
80012874:	58 09       	cp.w	r9,0
80012876:	f5 b8 00 00 	subfeq	r8,0
8001287a:	1b 07       	ld.w	r7,sp++
8001287c:	1b 0e       	ld.w	lr,sp++
8001287e:	5e 0d       	reteq	0
80012880:	5e fc       	retal	r12
80012882:	d7 03       	nop

80012884 <__avr32_f64_div>:
80012884:	eb cd 40 ff 	pushm	r0-r7,lr
80012888:	f7 e9 20 0e 	eor	lr,r11,r9
8001288c:	f6 07 16 14 	lsr	r7,r11,0x14
80012890:	a9 7b       	lsl	r11,0x9
80012892:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
80012896:	a9 7a       	lsl	r10,0x9
80012898:	bd bb       	sbr	r11,0x1d
8001289a:	e4 1b 3f ff 	andh	r11,0x3fff
8001289e:	ab d7       	cbr	r7,0xb
800128a0:	e0 80 00 cc 	breq	80012a38 <__avr32_f64_div_round_subnormal+0x54>
800128a4:	e0 47 07 ff 	cp.w	r7,2047
800128a8:	e0 84 00 b5 	brge	80012a12 <__avr32_f64_div_round_subnormal+0x2e>
800128ac:	f2 06 16 14 	lsr	r6,r9,0x14
800128b0:	a9 79       	lsl	r9,0x9
800128b2:	f3 e8 13 79 	or	r9,r9,r8>>0x17
800128b6:	a9 78       	lsl	r8,0x9
800128b8:	bd b9       	sbr	r9,0x1d
800128ba:	e4 19 3f ff 	andh	r9,0x3fff
800128be:	ab d6       	cbr	r6,0xb
800128c0:	e0 80 00 e2 	breq	80012a84 <__avr32_f64_div_round_subnormal+0xa0>
800128c4:	e0 46 07 ff 	cp.w	r6,2047
800128c8:	e0 84 00 b2 	brge	80012a2c <__avr32_f64_div_round_subnormal+0x48>
800128cc:	0c 17       	sub	r7,r6
800128ce:	fe 37 fc 01 	sub	r7,-1023
800128d2:	fc 1c 80 00 	movh	r12,0x8000
800128d6:	f8 03 16 01 	lsr	r3,r12,0x1
800128da:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
800128de:	5c d4       	com	r4
800128e0:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
800128e4:	e6 09 06 44 	mulu.d	r4,r3,r9
800128e8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
800128ec:	e6 05 06 44 	mulu.d	r4,r3,r5
800128f0:	ea 03 15 02 	lsl	r3,r5,0x2
800128f4:	e6 09 06 44 	mulu.d	r4,r3,r9
800128f8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
800128fc:	e6 05 06 44 	mulu.d	r4,r3,r5
80012900:	ea 03 15 02 	lsl	r3,r5,0x2
80012904:	e6 09 06 44 	mulu.d	r4,r3,r9
80012908:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8001290c:	e6 05 06 44 	mulu.d	r4,r3,r5
80012910:	ea 03 15 02 	lsl	r3,r5,0x2
80012914:	e6 08 06 40 	mulu.d	r0,r3,r8
80012918:	e4 09 07 40 	macu.d	r0,r2,r9
8001291c:	e6 09 06 44 	mulu.d	r4,r3,r9
80012920:	02 04       	add	r4,r1
80012922:	5c 05       	acr	r5
80012924:	a3 65       	lsl	r5,0x2
80012926:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8001292a:	a3 64       	lsl	r4,0x2
8001292c:	5c 34       	neg	r4
8001292e:	f8 05 01 45 	sbc	r5,r12,r5
80012932:	e6 04 06 40 	mulu.d	r0,r3,r4
80012936:	e4 05 07 40 	macu.d	r0,r2,r5
8001293a:	e6 05 06 44 	mulu.d	r4,r3,r5
8001293e:	02 04       	add	r4,r1
80012940:	5c 05       	acr	r5
80012942:	ea 03 15 02 	lsl	r3,r5,0x2
80012946:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8001294a:	e8 02 15 02 	lsl	r2,r4,0x2
8001294e:	e6 08 06 40 	mulu.d	r0,r3,r8
80012952:	e4 09 07 40 	macu.d	r0,r2,r9
80012956:	e6 09 06 44 	mulu.d	r4,r3,r9
8001295a:	02 04       	add	r4,r1
8001295c:	5c 05       	acr	r5
8001295e:	a3 65       	lsl	r5,0x2
80012960:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
80012964:	a3 64       	lsl	r4,0x2
80012966:	5c 34       	neg	r4
80012968:	f8 05 01 45 	sbc	r5,r12,r5
8001296c:	e6 04 06 40 	mulu.d	r0,r3,r4
80012970:	e4 05 07 40 	macu.d	r0,r2,r5
80012974:	e6 05 06 44 	mulu.d	r4,r3,r5
80012978:	02 04       	add	r4,r1
8001297a:	5c 05       	acr	r5
8001297c:	ea 03 15 02 	lsl	r3,r5,0x2
80012980:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
80012984:	e8 02 15 02 	lsl	r2,r4,0x2
80012988:	e6 0a 06 40 	mulu.d	r0,r3,r10
8001298c:	e4 0b 07 40 	macu.d	r0,r2,r11
80012990:	e6 0b 06 42 	mulu.d	r2,r3,r11
80012994:	02 02       	add	r2,r1
80012996:	5c 03       	acr	r3
80012998:	ed b3 00 1c 	bld	r3,0x1c
8001299c:	c0 90       	breq	800129ae <__avr32_f64_div+0x12a>
8001299e:	a1 72       	lsl	r2,0x1
800129a0:	5c f3       	rol	r3
800129a2:	20 17       	sub	r7,1
800129a4:	a3 9a       	lsr	r10,0x3
800129a6:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
800129aa:	a3 9b       	lsr	r11,0x3
800129ac:	c0 58       	rjmp	800129b6 <__avr32_f64_div+0x132>
800129ae:	a5 8a       	lsr	r10,0x4
800129b0:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
800129b4:	a5 8b       	lsr	r11,0x4
800129b6:	58 07       	cp.w	r7,0
800129b8:	e0 8a 00 8b 	brle	80012ace <__avr32_f64_div_res_subnormal>
800129bc:	e0 12 ff 00 	andl	r2,0xff00
800129c0:	e8 12 00 80 	orl	r2,0x80
800129c4:	e6 08 06 40 	mulu.d	r0,r3,r8
800129c8:	e4 09 07 40 	macu.d	r0,r2,r9
800129cc:	e4 08 06 44 	mulu.d	r4,r2,r8
800129d0:	e6 09 06 48 	mulu.d	r8,r3,r9
800129d4:	00 05       	add	r5,r0
800129d6:	f0 01 00 48 	adc	r8,r8,r1
800129da:	5c 09       	acr	r9
800129dc:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
800129e0:	58 04       	cp.w	r4,0
800129e2:	5c 25       	cpc	r5

800129e4 <__avr32_f64_div_round_subnormal>:
800129e4:	f4 08 13 00 	cpc	r8,r10
800129e8:	f6 09 13 00 	cpc	r9,r11
800129ec:	5f 36       	srlo	r6
800129ee:	f8 06 17 00 	moveq	r6,r12
800129f2:	e4 0a 16 08 	lsr	r10,r2,0x8
800129f6:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
800129fa:	e6 0b 16 08 	lsr	r11,r3,0x8
800129fe:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
80012a02:	ed be 00 1f 	bld	lr,0x1f
80012a06:	ef bb 00 1f 	bst	r11,0x1f
80012a0a:	0c 0a       	add	r10,r6
80012a0c:	5c 0b       	acr	r11
80012a0e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
80012a12:	e4 1b 00 0f 	andh	r11,0xf
80012a16:	14 4b       	or	r11,r10
80012a18:	e0 81 00 a7 	brne	80012b66 <__avr32_f64_div_res_subnormal+0x98>
80012a1c:	f2 06 16 14 	lsr	r6,r9,0x14
80012a20:	ab d6       	cbr	r6,0xb
80012a22:	e0 46 07 ff 	cp.w	r6,2047
80012a26:	e0 81 00 a4 	brne	80012b6e <__avr32_f64_div_res_subnormal+0xa0>
80012a2a:	c9 e8       	rjmp	80012b66 <__avr32_f64_div_res_subnormal+0x98>
80012a2c:	e4 19 00 0f 	andh	r9,0xf
80012a30:	10 49       	or	r9,r8
80012a32:	e0 81 00 9a 	brne	80012b66 <__avr32_f64_div_res_subnormal+0x98>
80012a36:	c9 28       	rjmp	80012b5a <__avr32_f64_div_res_subnormal+0x8c>
80012a38:	a3 7b       	lsl	r11,0x3
80012a3a:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
80012a3e:	a3 7a       	lsl	r10,0x3
80012a40:	f5 eb 10 04 	or	r4,r10,r11
80012a44:	e0 80 00 a0 	breq	80012b84 <__avr32_f64_div_op1_zero>
80012a48:	f6 04 12 00 	clz	r4,r11
80012a4c:	c1 70       	breq	80012a7a <__avr32_f64_div_round_subnormal+0x96>
80012a4e:	c0 c3       	brcs	80012a66 <__avr32_f64_div_round_subnormal+0x82>
80012a50:	e8 05 11 20 	rsub	r5,r4,32
80012a54:	f6 04 09 4b 	lsl	r11,r11,r4
80012a58:	f4 05 0a 45 	lsr	r5,r10,r5
80012a5c:	0a 4b       	or	r11,r5
80012a5e:	f4 04 09 4a 	lsl	r10,r10,r4
80012a62:	08 17       	sub	r7,r4
80012a64:	c0 b8       	rjmp	80012a7a <__avr32_f64_div_round_subnormal+0x96>
80012a66:	f4 04 12 00 	clz	r4,r10
80012a6a:	f9 b4 03 00 	movlo	r4,0
80012a6e:	f7 b4 02 e0 	subhs	r4,-32
80012a72:	f4 04 09 4b 	lsl	r11,r10,r4
80012a76:	30 0a       	mov	r10,0
80012a78:	08 17       	sub	r7,r4
80012a7a:	a3 8a       	lsr	r10,0x2
80012a7c:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
80012a80:	a3 8b       	lsr	r11,0x2
80012a82:	c1 1b       	rjmp	800128a4 <__avr32_f64_div+0x20>
80012a84:	a3 79       	lsl	r9,0x3
80012a86:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
80012a8a:	a3 78       	lsl	r8,0x3
80012a8c:	f3 e8 10 04 	or	r4,r9,r8
80012a90:	c6 f0       	breq	80012b6e <__avr32_f64_div_res_subnormal+0xa0>
80012a92:	f2 04 12 00 	clz	r4,r9
80012a96:	c1 70       	breq	80012ac4 <__avr32_f64_div_round_subnormal+0xe0>
80012a98:	c0 c3       	brcs	80012ab0 <__avr32_f64_div_round_subnormal+0xcc>
80012a9a:	e8 05 11 20 	rsub	r5,r4,32
80012a9e:	f2 04 09 49 	lsl	r9,r9,r4
80012aa2:	f0 05 0a 45 	lsr	r5,r8,r5
80012aa6:	0a 49       	or	r9,r5
80012aa8:	f0 04 09 48 	lsl	r8,r8,r4
80012aac:	08 16       	sub	r6,r4
80012aae:	c0 b8       	rjmp	80012ac4 <__avr32_f64_div_round_subnormal+0xe0>
80012ab0:	f0 04 12 00 	clz	r4,r8
80012ab4:	f9 b4 03 00 	movlo	r4,0
80012ab8:	f7 b4 02 e0 	subhs	r4,-32
80012abc:	f0 04 09 49 	lsl	r9,r8,r4
80012ac0:	30 08       	mov	r8,0
80012ac2:	08 16       	sub	r6,r4
80012ac4:	a3 88       	lsr	r8,0x2
80012ac6:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
80012aca:	a3 89       	lsr	r9,0x2
80012acc:	cf ca       	rjmp	800128c4 <__avr32_f64_div+0x40>

80012ace <__avr32_f64_div_res_subnormal>:
80012ace:	5c 37       	neg	r7
80012ad0:	2f f7       	sub	r7,-1
80012ad2:	f1 b7 04 c0 	satu	r7,0x6
80012ad6:	e0 47 00 20 	cp.w	r7,32
80012ada:	c1 54       	brge	80012b04 <__avr32_f64_div_res_subnormal+0x36>
80012adc:	ee 06 11 20 	rsub	r6,r7,32
80012ae0:	e4 07 0a 42 	lsr	r2,r2,r7
80012ae4:	e6 06 09 4c 	lsl	r12,r3,r6
80012ae8:	18 42       	or	r2,r12
80012aea:	e6 07 0a 43 	lsr	r3,r3,r7
80012aee:	f4 06 09 41 	lsl	r1,r10,r6
80012af2:	f4 07 0a 4a 	lsr	r10,r10,r7
80012af6:	f6 06 09 4c 	lsl	r12,r11,r6
80012afa:	18 4a       	or	r10,r12
80012afc:	f6 07 0a 4b 	lsr	r11,r11,r7
80012b00:	30 00       	mov	r0,0
80012b02:	c1 58       	rjmp	80012b2c <__avr32_f64_div_res_subnormal+0x5e>
80012b04:	ee 06 11 20 	rsub	r6,r7,32
80012b08:	f9 b0 00 00 	moveq	r0,0
80012b0c:	f9 bc 00 00 	moveq	r12,0
80012b10:	c0 50       	breq	80012b1a <__avr32_f64_div_res_subnormal+0x4c>
80012b12:	f4 06 09 40 	lsl	r0,r10,r6
80012b16:	f6 06 09 4c 	lsl	r12,r11,r6
80012b1a:	e6 07 0a 42 	lsr	r2,r3,r7
80012b1e:	30 03       	mov	r3,0
80012b20:	f4 07 0a 41 	lsr	r1,r10,r7
80012b24:	18 41       	or	r1,r12
80012b26:	f6 07 0a 4a 	lsr	r10,r11,r7
80012b2a:	30 0b       	mov	r11,0
80012b2c:	e0 12 ff 00 	andl	r2,0xff00
80012b30:	e8 12 00 80 	orl	r2,0x80
80012b34:	e6 08 06 46 	mulu.d	r6,r3,r8
80012b38:	e4 09 07 46 	macu.d	r6,r2,r9
80012b3c:	e4 08 06 44 	mulu.d	r4,r2,r8
80012b40:	e6 09 06 48 	mulu.d	r8,r3,r9
80012b44:	0c 05       	add	r5,r6
80012b46:	f0 07 00 48 	adc	r8,r8,r7
80012b4a:	5c 09       	acr	r9
80012b4c:	30 07       	mov	r7,0
80012b4e:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
80012b52:	00 34       	cp.w	r4,r0
80012b54:	e2 05 13 00 	cpc	r5,r1
80012b58:	c4 6b       	rjmp	800129e4 <__avr32_f64_div_round_subnormal>
80012b5a:	1c 9b       	mov	r11,lr
80012b5c:	e6 1b 80 00 	andh	r11,0x8000,COH
80012b60:	30 0a       	mov	r10,0
80012b62:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
80012b66:	3f fb       	mov	r11,-1
80012b68:	30 0a       	mov	r10,0
80012b6a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
80012b6e:	f5 eb 10 04 	or	r4,r10,r11
80012b72:	c0 90       	breq	80012b84 <__avr32_f64_div_op1_zero>
80012b74:	1c 9b       	mov	r11,lr
80012b76:	e6 1b 80 00 	andh	r11,0x8000,COH
80012b7a:	ea 1b 7f f0 	orh	r11,0x7ff0
80012b7e:	30 0a       	mov	r10,0
80012b80:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

80012b84 <__avr32_f64_div_op1_zero>:
80012b84:	f1 e9 10 15 	or	r5,r8,r9<<0x1
80012b88:	ce f0       	breq	80012b66 <__avr32_f64_div_res_subnormal+0x98>
80012b8a:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
80012b8e:	e0 44 07 ff 	cp.w	r4,2047
80012b92:	ce 41       	brne	80012b5a <__avr32_f64_div_res_subnormal+0x8c>
80012b94:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
80012b98:	ce 10       	breq	80012b5a <__avr32_f64_div_res_subnormal+0x8c>
80012b9a:	ce 6b       	rjmp	80012b66 <__avr32_f64_div_res_subnormal+0x98>

80012b9c <__avr32_umod64>:
80012b9c:	d4 31       	pushm	r0-r7,lr
80012b9e:	1a 97       	mov	r7,sp
80012ba0:	20 3d       	sub	sp,12
80012ba2:	10 9c       	mov	r12,r8
80012ba4:	12 95       	mov	r5,r9
80012ba6:	14 9e       	mov	lr,r10
80012ba8:	16 91       	mov	r1,r11
80012baa:	16 96       	mov	r6,r11
80012bac:	58 09       	cp.w	r9,0
80012bae:	e0 81 00 81 	brne	80012cb0 <__avr32_umod64+0x114>
80012bb2:	16 38       	cp.w	r8,r11
80012bb4:	e0 88 00 12 	brls	80012bd8 <__avr32_umod64+0x3c>
80012bb8:	f0 08 12 00 	clz	r8,r8
80012bbc:	c4 e0       	breq	80012c58 <__avr32_umod64+0xbc>
80012bbe:	f6 08 09 46 	lsl	r6,r11,r8
80012bc2:	f8 08 09 4c 	lsl	r12,r12,r8
80012bc6:	f0 0b 11 20 	rsub	r11,r8,32
80012bca:	f4 08 09 4e 	lsl	lr,r10,r8
80012bce:	f4 0b 0a 4b 	lsr	r11,r10,r11
80012bd2:	f7 e6 10 06 	or	r6,r11,r6
80012bd6:	c4 18       	rjmp	80012c58 <__avr32_umod64+0xbc>
80012bd8:	58 08       	cp.w	r8,0
80012bda:	c0 51       	brne	80012be4 <__avr32_umod64+0x48>
80012bdc:	30 19       	mov	r9,1
80012bde:	f2 08 0d 08 	divu	r8,r9,r8
80012be2:	10 9c       	mov	r12,r8
80012be4:	f8 08 12 00 	clz	r8,r12
80012be8:	c0 31       	brne	80012bee <__avr32_umod64+0x52>
80012bea:	18 16       	sub	r6,r12
80012bec:	c3 68       	rjmp	80012c58 <__avr32_umod64+0xbc>
80012bee:	f0 03 11 20 	rsub	r3,r8,32
80012bf2:	f4 03 0a 4b 	lsr	r11,r10,r3
80012bf6:	f8 08 09 4c 	lsl	r12,r12,r8
80012bfa:	ec 08 09 49 	lsl	r9,r6,r8
80012bfe:	ec 03 0a 43 	lsr	r3,r6,r3
80012c02:	f7 e9 10 09 	or	r9,r11,r9
80012c06:	f8 05 16 10 	lsr	r5,r12,0x10
80012c0a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
80012c0e:	e6 05 0d 02 	divu	r2,r3,r5
80012c12:	f2 0e 16 10 	lsr	lr,r9,0x10
80012c16:	ec 02 02 4b 	mul	r11,r6,r2
80012c1a:	fd e3 11 0e 	or	lr,lr,r3<<0x10
80012c1e:	16 3e       	cp.w	lr,r11
80012c20:	c0 72       	brcc	80012c2e <__avr32_umod64+0x92>
80012c22:	18 0e       	add	lr,r12
80012c24:	18 3e       	cp.w	lr,r12
80012c26:	c0 43       	brcs	80012c2e <__avr32_umod64+0x92>
80012c28:	16 3e       	cp.w	lr,r11
80012c2a:	fd dc e3 0e 	addcs	lr,lr,r12
80012c2e:	fc 0b 01 03 	sub	r3,lr,r11
80012c32:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
80012c36:	e6 05 0d 02 	divu	r2,r3,r5
80012c3a:	f3 e3 11 09 	or	r9,r9,r3<<0x10
80012c3e:	a5 36       	mul	r6,r2
80012c40:	0c 39       	cp.w	r9,r6
80012c42:	c0 72       	brcc	80012c50 <__avr32_umod64+0xb4>
80012c44:	18 09       	add	r9,r12
80012c46:	18 39       	cp.w	r9,r12
80012c48:	c0 43       	brcs	80012c50 <__avr32_umod64+0xb4>
80012c4a:	0c 39       	cp.w	r9,r6
80012c4c:	f3 dc e3 09 	addcs	r9,r9,r12
80012c50:	f2 06 01 06 	sub	r6,r9,r6
80012c54:	f4 08 09 4e 	lsl	lr,r10,r8
80012c58:	f8 0a 16 10 	lsr	r10,r12,0x10
80012c5c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
80012c60:	ec 0a 0d 02 	divu	r2,r6,r10
80012c64:	fc 09 16 10 	lsr	r9,lr,0x10
80012c68:	ea 02 02 4b 	mul	r11,r5,r2
80012c6c:	f3 e3 11 09 	or	r9,r9,r3<<0x10
80012c70:	16 39       	cp.w	r9,r11
80012c72:	c0 72       	brcc	80012c80 <__avr32_umod64+0xe4>
80012c74:	18 09       	add	r9,r12
80012c76:	18 39       	cp.w	r9,r12
80012c78:	c0 43       	brcs	80012c80 <__avr32_umod64+0xe4>
80012c7a:	16 39       	cp.w	r9,r11
80012c7c:	f3 dc e3 09 	addcs	r9,r9,r12
80012c80:	f2 0b 01 0b 	sub	r11,r9,r11
80012c84:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80012c88:	f6 0a 0d 0a 	divu	r10,r11,r10
80012c8c:	fd eb 11 0e 	or	lr,lr,r11<<0x10
80012c90:	ea 0a 02 4a 	mul	r10,r5,r10
80012c94:	14 3e       	cp.w	lr,r10
80012c96:	c0 72       	brcc	80012ca4 <__avr32_umod64+0x108>
80012c98:	18 0e       	add	lr,r12
80012c9a:	18 3e       	cp.w	lr,r12
80012c9c:	c0 43       	brcs	80012ca4 <__avr32_umod64+0x108>
80012c9e:	14 3e       	cp.w	lr,r10
80012ca0:	fd dc e3 0e 	addcs	lr,lr,r12
80012ca4:	fc 0a 01 0a 	sub	r10,lr,r10
80012ca8:	30 0b       	mov	r11,0
80012caa:	f4 08 0a 4a 	lsr	r10,r10,r8
80012cae:	c7 b8       	rjmp	80012da4 <__avr32_umod64+0x208>
80012cb0:	16 39       	cp.w	r9,r11
80012cb2:	e0 8b 00 79 	brhi	80012da4 <__avr32_umod64+0x208>
80012cb6:	f2 09 12 00 	clz	r9,r9
80012cba:	c1 21       	brne	80012cde <__avr32_umod64+0x142>
80012cbc:	10 3a       	cp.w	r10,r8
80012cbe:	5f 2b       	srhs	r11
80012cc0:	0a 31       	cp.w	r1,r5
80012cc2:	5f ba       	srhi	r10
80012cc4:	f7 ea 10 0a 	or	r10,r11,r10
80012cc8:	f2 0a 18 00 	cp.b	r10,r9
80012ccc:	c0 60       	breq	80012cd8 <__avr32_umod64+0x13c>
80012cce:	fc 08 01 0c 	sub	r12,lr,r8
80012cd2:	e2 05 01 46 	sbc	r6,r1,r5
80012cd6:	18 9e       	mov	lr,r12
80012cd8:	0c 9b       	mov	r11,r6
80012cda:	1c 9a       	mov	r10,lr
80012cdc:	c6 48       	rjmp	80012da4 <__avr32_umod64+0x208>
80012cde:	ea 09 09 4c 	lsl	r12,r5,r9
80012ce2:	f2 06 11 20 	rsub	r6,r9,32
80012ce6:	f6 09 09 4b 	lsl	r11,r11,r9
80012cea:	f0 09 09 42 	lsl	r2,r8,r9
80012cee:	ef 46 ff f4 	st.w	r7[-12],r6
80012cf2:	f0 06 0a 48 	lsr	r8,r8,r6
80012cf6:	18 48       	or	r8,r12
80012cf8:	e2 06 0a 4c 	lsr	r12,r1,r6
80012cfc:	f4 09 09 43 	lsl	r3,r10,r9
80012d00:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
80012d04:	f4 06 0a 4a 	lsr	r10,r10,r6
80012d08:	16 4a       	or	r10,r11
80012d0a:	f0 0b 16 10 	lsr	r11,r8,0x10
80012d0e:	f8 0b 0d 04 	divu	r4,r12,r11
80012d12:	f4 0c 16 10 	lsr	r12,r10,0x10
80012d16:	08 91       	mov	r1,r4
80012d18:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
80012d1c:	e8 0e 02 46 	mul	r6,r4,lr
80012d20:	0c 3c       	cp.w	r12,r6
80012d22:	c0 a2       	brcc	80012d36 <__avr32_umod64+0x19a>
80012d24:	20 11       	sub	r1,1
80012d26:	10 0c       	add	r12,r8
80012d28:	10 3c       	cp.w	r12,r8
80012d2a:	c0 63       	brcs	80012d36 <__avr32_umod64+0x19a>
80012d2c:	0c 3c       	cp.w	r12,r6
80012d2e:	f7 b1 03 01 	sublo	r1,1
80012d32:	f9 d8 e3 0c 	addcs	r12,r12,r8
80012d36:	0c 1c       	sub	r12,r6
80012d38:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
80012d3c:	f8 0b 0d 04 	divu	r4,r12,r11
80012d40:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
80012d44:	08 96       	mov	r6,r4
80012d46:	e8 0e 02 4e 	mul	lr,r4,lr
80012d4a:	1c 3b       	cp.w	r11,lr
80012d4c:	c0 a2       	brcc	80012d60 <__avr32_umod64+0x1c4>
80012d4e:	20 16       	sub	r6,1
80012d50:	10 0b       	add	r11,r8
80012d52:	10 3b       	cp.w	r11,r8
80012d54:	c0 63       	brcs	80012d60 <__avr32_umod64+0x1c4>
80012d56:	1c 3b       	cp.w	r11,lr
80012d58:	f7 b6 03 01 	sublo	r6,1
80012d5c:	f7 d8 e3 0b 	addcs	r11,r11,r8
80012d60:	ed e1 11 01 	or	r1,r6,r1<<0x10
80012d64:	1c 1b       	sub	r11,lr
80012d66:	e2 02 06 40 	mulu.d	r0,r1,r2
80012d6a:	00 9e       	mov	lr,r0
80012d6c:	02 9c       	mov	r12,r1
80012d6e:	16 3c       	cp.w	r12,r11
80012d70:	e0 8b 00 08 	brhi	80012d80 <__avr32_umod64+0x1e4>
80012d74:	5f 06       	sreq	r6
80012d76:	06 30       	cp.w	r0,r3
80012d78:	5f ba       	srhi	r10
80012d7a:	ed ea 00 0a 	and	r10,r6,r10
80012d7e:	c0 60       	breq	80012d8a <__avr32_umod64+0x1ee>
80012d80:	fc 02 01 04 	sub	r4,lr,r2
80012d84:	f8 08 01 4c 	sbc	r12,r12,r8
80012d88:	08 9e       	mov	lr,r4
80012d8a:	e6 0e 01 0a 	sub	r10,r3,lr
80012d8e:	f6 0c 01 4c 	sbc	r12,r11,r12
80012d92:	ee f1 ff f4 	ld.w	r1,r7[-12]
80012d96:	f8 09 0a 4b 	lsr	r11,r12,r9
80012d9a:	f4 09 0a 4a 	lsr	r10,r10,r9
80012d9e:	f8 01 09 4c 	lsl	r12,r12,r1
80012da2:	18 4a       	or	r10,r12
80012da4:	2f dd       	sub	sp,-12
80012da6:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

80012e00 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
80012e00:	c0 08       	rjmp	80012e00 <_evba>
	...

80012e04 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
80012e04:	c0 08       	rjmp	80012e04 <_handle_TLB_Multiple_Hit>
	...

80012e08 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
80012e08:	c0 08       	rjmp	80012e08 <_handle_Bus_Error_Data_Fetch>
	...

80012e0c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
80012e0c:	c0 08       	rjmp	80012e0c <_handle_Bus_Error_Instruction_Fetch>
	...

80012e10 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
80012e10:	c0 08       	rjmp	80012e10 <_handle_NMI>
	...

80012e14 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
80012e14:	c0 08       	rjmp	80012e14 <_handle_Instruction_Address>
	...

80012e18 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
80012e18:	c0 08       	rjmp	80012e18 <_handle_ITLB_Protection>
	...

80012e1c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
80012e1c:	c0 08       	rjmp	80012e1c <_handle_Breakpoint>
	...

80012e20 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
80012e20:	c0 08       	rjmp	80012e20 <_handle_Illegal_Opcode>
	...

80012e24 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
80012e24:	c0 08       	rjmp	80012e24 <_handle_Unimplemented_Instruction>
	...

80012e28 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
80012e28:	c0 08       	rjmp	80012e28 <_handle_Privilege_Violation>
	...

80012e2c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR32UC and AVR32AP.
_handle_Floating_Point:
	rjmp $
80012e2c:	c0 08       	rjmp	80012e2c <_handle_Floating_Point>
	...

80012e30 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
	rjmp $
80012e30:	c0 08       	rjmp	80012e30 <_handle_Coprocessor_Absent>
	...

80012e34 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
80012e34:	c0 08       	rjmp	80012e34 <_handle_Data_Address_Read>
	...

80012e38 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
80012e38:	c0 08       	rjmp	80012e38 <_handle_Data_Address_Write>
	...

80012e3c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
80012e3c:	c0 08       	rjmp	80012e3c <_handle_DTLB_Protection_Read>
	...

80012e40 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
80012e40:	c0 08       	rjmp	80012e40 <_handle_DTLB_Protection_Write>
	...

80012e44 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
80012e44:	c0 08       	rjmp	80012e44 <_handle_DTLB_Modified>
	...

80012e50 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
80012e50:	c0 08       	rjmp	80012e50 <_handle_ITLB_Miss>
	...

80012e60 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
80012e60:	c0 08       	rjmp	80012e60 <_handle_DTLB_Miss_Read>
	...

80012e70 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
80012e70:	c0 08       	rjmp	80012e70 <_handle_DTLB_Miss_Write>
	...

80012f00 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	rjmp $
80012f00:	c0 08       	rjmp	80012f00 <_handle_Supervisor_Call>
80012f02:	d7 03       	nop

80012f04 <_int0>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80012f04:	30 0c       	mov	r12,0
80012f06:	fe b0 ac 29 	rcall	80008758 <_get_interrupt_handler>
80012f0a:	58 0c       	cp.w	r12,0
80012f0c:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80012f10:	d6 03       	rete

80012f12 <_int1>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80012f12:	30 1c       	mov	r12,1
80012f14:	fe b0 ac 22 	rcall	80008758 <_get_interrupt_handler>
80012f18:	58 0c       	cp.w	r12,0
80012f1a:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80012f1e:	d6 03       	rete

80012f20 <_int2>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80012f20:	30 2c       	mov	r12,2
80012f22:	fe b0 ac 1b 	rcall	80008758 <_get_interrupt_handler>
80012f26:	58 0c       	cp.w	r12,0
80012f28:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80012f2c:	d6 03       	rete

80012f2e <_int3>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80012f2e:	30 3c       	mov	r12,3
80012f30:	fe b0 ac 14 	rcall	80008758 <_get_interrupt_handler>
80012f34:	58 0c       	cp.w	r12,0
80012f36:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80012f3a:	d6 03       	rete
80012f3c:	d7 03       	nop
80012f3e:	d7 03       	nop
80012f40:	d7 03       	nop
80012f42:	d7 03       	nop
80012f44:	d7 03       	nop
80012f46:	d7 03       	nop
80012f48:	d7 03       	nop
80012f4a:	d7 03       	nop
80012f4c:	d7 03       	nop
80012f4e:	d7 03       	nop
80012f50:	d7 03       	nop
80012f52:	d7 03       	nop
80012f54:	d7 03       	nop
80012f56:	d7 03       	nop
80012f58:	d7 03       	nop
80012f5a:	d7 03       	nop
80012f5c:	d7 03       	nop
80012f5e:	d7 03       	nop
80012f60:	d7 03       	nop
80012f62:	d7 03       	nop
80012f64:	d7 03       	nop
80012f66:	d7 03       	nop
80012f68:	d7 03       	nop
80012f6a:	d7 03       	nop
80012f6c:	d7 03       	nop
80012f6e:	d7 03       	nop
80012f70:	d7 03       	nop
80012f72:	d7 03       	nop
80012f74:	d7 03       	nop
80012f76:	d7 03       	nop
80012f78:	d7 03       	nop
80012f7a:	d7 03       	nop
80012f7c:	d7 03       	nop
80012f7e:	d7 03       	nop
80012f80:	d7 03       	nop
80012f82:	d7 03       	nop
80012f84:	d7 03       	nop
80012f86:	d7 03       	nop
80012f88:	d7 03       	nop
80012f8a:	d7 03       	nop
80012f8c:	d7 03       	nop
80012f8e:	d7 03       	nop
80012f90:	d7 03       	nop
80012f92:	d7 03       	nop
80012f94:	d7 03       	nop
80012f96:	d7 03       	nop
80012f98:	d7 03       	nop
80012f9a:	d7 03       	nop
80012f9c:	d7 03       	nop
80012f9e:	d7 03       	nop
80012fa0:	d7 03       	nop
80012fa2:	d7 03       	nop
80012fa4:	d7 03       	nop
80012fa6:	d7 03       	nop
80012fa8:	d7 03       	nop
80012faa:	d7 03       	nop
80012fac:	d7 03       	nop
80012fae:	d7 03       	nop
80012fb0:	d7 03       	nop
80012fb2:	d7 03       	nop
80012fb4:	d7 03       	nop
80012fb6:	d7 03       	nop
80012fb8:	d7 03       	nop
80012fba:	d7 03       	nop
80012fbc:	d7 03       	nop
80012fbe:	d7 03       	nop
80012fc0:	d7 03       	nop
80012fc2:	d7 03       	nop
80012fc4:	d7 03       	nop
80012fc6:	d7 03       	nop
80012fc8:	d7 03       	nop
80012fca:	d7 03       	nop
80012fcc:	d7 03       	nop
80012fce:	d7 03       	nop
80012fd0:	d7 03       	nop
80012fd2:	d7 03       	nop
80012fd4:	d7 03       	nop
80012fd6:	d7 03       	nop
80012fd8:	d7 03       	nop
80012fda:	d7 03       	nop
80012fdc:	d7 03       	nop
80012fde:	d7 03       	nop
80012fe0:	d7 03       	nop
80012fe2:	d7 03       	nop
80012fe4:	d7 03       	nop
80012fe6:	d7 03       	nop
80012fe8:	d7 03       	nop
80012fea:	d7 03       	nop
80012fec:	d7 03       	nop
80012fee:	d7 03       	nop
80012ff0:	d7 03       	nop
80012ff2:	d7 03       	nop
80012ff4:	d7 03       	nop
80012ff6:	d7 03       	nop
80012ff8:	d7 03       	nop
80012ffa:	d7 03       	nop
80012ffc:	d7 03       	nop
80012ffe:	d7 03       	nop
