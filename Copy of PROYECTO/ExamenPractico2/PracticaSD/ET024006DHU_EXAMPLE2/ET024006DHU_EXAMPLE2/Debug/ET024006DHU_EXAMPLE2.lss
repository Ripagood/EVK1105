
ET024006DHU_EXAMPLE2.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00014a64  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  80016c00  80016c00  00017000  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000021bc  80016e00  80016e00  00017200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .lalign       00000004  80018fbc  80018fbc  000193bc  2**0
                  ALLOC
  6 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  7 .data         00000558  00000008  80018fc0  00019408  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .bss          00000cb8  00000560  00000560  00000000  2**2
                  ALLOC
  9 .comment      00000030  00000000  00000000  00019960  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00002268  00000000  00000000  00019990  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_pubnames 0000535d  00000000  00000000  0001bbf8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   0004bfb7  00000000  00000000  00020f55  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 0000a163  00000000  00000000  0006cf0c  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   0003600f  00000000  00000000  0007706f  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00006364  00000000  00000000  000ad080  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    0000b267  00000000  00000000  000b33e4  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    000203a8  00000000  00000000  000be64b  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_macinfo 0207054e  00000000  00000000  000de9f3  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 20 .bss_sdram    0000000c  d0000000  d0000000  0214f000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 21 .heap         01ffffec  d000000c  d000000c  00000000  2**0
                  ALLOC
 22 .debug_ranges 0000e400  00000000  00000000  0214f010  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe ff 00 04 	ld.w	pc,pc[4]
80002004:	80 00       	ld.sh	r0,r0[0x0]
80002006:	ea a8       	*unknown*

Disassembly of section .text:

80002008 <sdramc_init>:
{
}
#endif

void sdramc_init(unsigned long hsb_hz)
{
80002008:	eb cd 40 fc 	pushm	r2-r7,lr
  unsigned long hsb_mhz_dn = hsb_hz / 1000000;
  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
8000200c:	ee 78 42 3f 	mov	r8,999999
80002010:	f8 08 00 09 	add	r9,r12,r8
80002014:	e0 68 de 83 	mov	r8,56963
80002018:	ea 18 43 1b 	orh	r8,0x431b
8000201c:	f2 08 06 48 	mulu.d	r8,r9,r8
{
}
#endif

void sdramc_init(unsigned long hsb_hz)
{
80002020:	18 96       	mov	r6,r12
  unsigned long hsb_mhz_dn = hsb_hz / 1000000;
  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
80002022:	f2 07 16 12 	lsr	r7,r9,0x12
    // Enable clock-related pins.
    {AVR32_EBI_SDCK_0_PIN,            AVR32_EBI_SDCK_0_FUNCTION           },
    {AVR32_EBI_SDCKE_0_PIN,           AVR32_EBI_SDCKE_0_FUNCTION          }
  };

  gpio_enable_module(SDRAMC_EBI_GPIO_MAP, sizeof(SDRAMC_EBI_GPIO_MAP) / sizeof(SDRAMC_EBI_GPIO_MAP[0]));
80002026:	32 7b       	mov	r11,39
80002028:	fe fc 01 f0 	ld.w	r12,pc[496]
8000202c:	e0 a0 4b 87 	rcall	8000b73a <gpio_enable_module>
  // Put the multiplexed MCU pins used for the SDRAM under control of the SDRAMC.
  sdramc_enable_muxed_pins();

  // Enable SDRAM mode for CS1.
#if (defined AVR32_HMATRIX)
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR] |= 1 << AVR32_EBI_SDRAM_CS;
80002030:	fe 68 10 00 	mov	r8,-126976
80002034:	f0 f9 01 24 	ld.w	r9,r8[292]
80002038:	a1 b9       	sbr	r9,0x1
8000203a:	f1 49 01 24 	st.w	r8[292],r9
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR];
8000203e:	f0 f8 01 24 	ld.w	r8,r8[292]
      ((( SDRAM_BANK_BITS                -    1) << AVR32_SDRAMC_CR_NB_OFFSET  ) & AVR32_SDRAMC_CR_NB_MASK  ) |
      ((  SDRAM_CAS                              << AVR32_SDRAMC_CR_CAS_OFFSET ) & AVR32_SDRAMC_CR_CAS_MASK ) |
      ((( SDRAM_DBW                      >>   4) << AVR32_SDRAMC_CR_DBW_OFFSET ) & AVR32_SDRAMC_CR_DBW_MASK ) |
      ((((SDRAM_TWR  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TWR_OFFSET ) & AVR32_SDRAMC_CR_TWR_MASK ) |
      ((((SDRAM_TRC  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRC_OFFSET ) & AVR32_SDRAMC_CR_TRC_MASK ) |
      ((((SDRAM_TRP  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRP_OFFSET ) & AVR32_SDRAMC_CR_TRP_MASK ) |
80002042:	e0 68 4d d3 	mov	r8,19923
80002046:	ea 18 10 62 	orh	r8,0x1062
#endif

  // Configure the SDRAM Controller with SDRAM setup and timing information.
  // All timings below are rounded up because they are minimal values.
  AVR32_SDRAMC.cr =
      ((( SDRAM_COL_BITS                 -    8) << AVR32_SDRAMC_CR_NC_OFFSET  ) & AVR32_SDRAMC_CR_NC_MASK  ) |
8000204a:	ee 05 15 03 	lsl	r5,r7,0x3
8000204e:	ea 07 00 03 	add	r3,r5,r7
80002052:	ee 03 00 23 	add	r3,r7,r3<<0x2
80002056:	e6 c3 fc 19 	sub	r3,r3,-999
8000205a:	e6 08 06 42 	mulu.d	r2,r3,r8
      ((( SDRAM_BANK_BITS                -    1) << AVR32_SDRAMC_CR_NB_OFFSET  ) & AVR32_SDRAMC_CR_NB_MASK  ) |
      ((  SDRAM_CAS                              << AVR32_SDRAMC_CR_CAS_OFFSET ) & AVR32_SDRAMC_CR_CAS_MASK ) |
      ((( SDRAM_DBW                      >>   4) << AVR32_SDRAMC_CR_DBW_OFFSET ) & AVR32_SDRAMC_CR_DBW_MASK ) |
      ((((SDRAM_TWR  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TWR_OFFSET ) & AVR32_SDRAMC_CR_TWR_MASK ) |
      ((((SDRAM_TRC  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRC_OFFSET ) & AVR32_SDRAMC_CR_TRC_MASK ) |
      ((((SDRAM_TRP  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRP_OFFSET ) & AVR32_SDRAMC_CR_TRP_MASK ) |
8000205e:	ee 09 15 04 	lsl	r9,r7,0x4
#endif

  // Configure the SDRAM Controller with SDRAM setup and timing information.
  // All timings below are rounded up because they are minimal values.
  AVR32_SDRAMC.cr =
      ((( SDRAM_COL_BITS                 -    8) << AVR32_SDRAMC_CR_NC_OFFSET  ) & AVR32_SDRAMC_CR_NC_MASK  ) |
80002062:	e6 0b 15 12 	lsl	r11,r3,0x12
80002066:	0e 19       	sub	r9,r7
80002068:	f2 03 15 02 	lsl	r3,r9,0x2
8000206c:	e6 c3 fc 19 	sub	r3,r3,-999
80002070:	e6 08 06 42 	mulu.d	r2,r3,r8
      ((( SDRAM_BANK_BITS                -    1) << AVR32_SDRAMC_CR_NB_OFFSET  ) & AVR32_SDRAMC_CR_NB_MASK  ) |
      ((  SDRAM_CAS                              << AVR32_SDRAMC_CR_CAS_OFFSET ) & AVR32_SDRAMC_CR_CAS_MASK ) |
      ((( SDRAM_DBW                      >>   4) << AVR32_SDRAMC_CR_DBW_OFFSET ) & AVR32_SDRAMC_CR_DBW_MASK ) |
      ((((SDRAM_TWR  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TWR_OFFSET ) & AVR32_SDRAMC_CR_TWR_MASK ) |
      ((((SDRAM_TRC  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRC_OFFSET ) & AVR32_SDRAMC_CR_TRC_MASK ) |
      ((((SDRAM_TRP  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRP_OFFSET ) & AVR32_SDRAMC_CR_TRP_MASK ) |
80002074:	f2 c9 fc 19 	sub	r9,r9,-999
#endif

  // Configure the SDRAM Controller with SDRAM setup and timing information.
  // All timings below are rounded up because they are minimal values.
  AVR32_SDRAMC.cr =
      ((( SDRAM_COL_BITS                 -    8) << AVR32_SDRAMC_CR_NC_OFFSET  ) & AVR32_SDRAMC_CR_NC_MASK  ) |
80002078:	e6 0e 15 06 	lsl	lr,r3,0x6
      ((( SDRAM_BANK_BITS                -    1) << AVR32_SDRAMC_CR_NB_OFFSET  ) & AVR32_SDRAMC_CR_NB_MASK  ) |
      ((  SDRAM_CAS                              << AVR32_SDRAMC_CR_CAS_OFFSET ) & AVR32_SDRAMC_CR_CAS_MASK ) |
      ((( SDRAM_DBW                      >>   4) << AVR32_SDRAMC_CR_DBW_OFFSET ) & AVR32_SDRAMC_CR_DBW_MASK ) |
      ((((SDRAM_TWR  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TWR_OFFSET ) & AVR32_SDRAMC_CR_TWR_MASK ) |
      ((((SDRAM_TRC  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRC_OFFSET ) & AVR32_SDRAMC_CR_TRC_MASK ) |
      ((((SDRAM_TRP  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRP_OFFSET ) & AVR32_SDRAMC_CR_TRP_MASK ) |
8000207c:	f2 08 06 42 	mulu.d	r2,r9,r8
#endif

  // Configure the SDRAM Controller with SDRAM setup and timing information.
  // All timings below are rounded up because they are minimal values.
  AVR32_SDRAMC.cr =
      ((( SDRAM_COL_BITS                 -    8) << AVR32_SDRAMC_CR_NC_OFFSET  ) & AVR32_SDRAMC_CR_NC_MASK  ) |
80002080:	ee 0c 15 05 	lsl	r12,r7,0x5
      ((( SDRAM_BANK_BITS                -    1) << AVR32_SDRAMC_CR_NB_OFFSET  ) & AVR32_SDRAMC_CR_NB_MASK  ) |
      ((  SDRAM_CAS                              << AVR32_SDRAMC_CR_CAS_OFFSET ) & AVR32_SDRAMC_CR_CAS_MASK ) |
      ((( SDRAM_DBW                      >>   4) << AVR32_SDRAMC_CR_DBW_OFFSET ) & AVR32_SDRAMC_CR_DBW_MASK ) |
      ((((SDRAM_TWR  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TWR_OFFSET ) & AVR32_SDRAMC_CR_TWR_MASK ) |
      ((((SDRAM_TRC  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRC_OFFSET ) & AVR32_SDRAMC_CR_TRC_MASK ) |
      ((((SDRAM_TRP  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRP_OFFSET ) & AVR32_SDRAMC_CR_TRP_MASK ) |
80002084:	e6 09 16 06 	lsr	r9,r3,0x6
#endif

  // Configure the SDRAM Controller with SDRAM setup and timing information.
  // All timings below are rounded up because they are minimal values.
  AVR32_SDRAMC.cr =
      ((( SDRAM_COL_BITS                 -    8) << AVR32_SDRAMC_CR_NC_OFFSET  ) & AVR32_SDRAMC_CR_NC_MASK  ) |
80002088:	0e 0c       	add	r12,r7
8000208a:	0e 15       	sub	r5,r7
8000208c:	ee 0c 00 13 	add	r3,r7,r12<<0x1
80002090:	a1 75       	lsl	r5,0x1
80002092:	e6 c3 fc 19 	sub	r3,r3,-999
80002096:	ea c5 fc 19 	sub	r5,r5,-999
8000209a:	e6 08 06 42 	mulu.d	r2,r3,r8
8000209e:	ea 08 06 44 	mulu.d	r4,r5,r8
800020a2:	e6 08 16 06 	lsr	r8,r3,0x6
800020a6:	a3 65       	lsl	r5,0x2
800020a8:	bd 68       	lsl	r8,0x1c
800020aa:	e2 15 0f 00 	andl	r5,0xf00,COH
800020ae:	e8 18 00 d9 	orl	r8,0xd9
800020b2:	0a 48       	or	r8,r5
800020b4:	e2 1e f0 00 	andl	lr,0xf000,COH
800020b8:	f1 ee 10 0e 	or	lr,r8,lr
800020bc:	f2 08 15 10 	lsl	r8,r9,0x10
800020c0:	e6 18 00 0f 	andh	r8,0xf,COH
800020c4:	10 4e       	or	lr,r8
800020c6:	f2 08 15 14 	lsl	r8,r9,0x14
800020ca:	e6 18 00 f0 	andh	r8,0xf0,COH
800020ce:	fd e8 10 08 	or	r8,lr,r8
  AVR32_HMATRIXB.sfr[AVR32_EBI_HMATRIX_NR];
#endif

  // Configure the SDRAM Controller with SDRAM setup and timing information.
  // All timings below are rounded up because they are minimal values.
  AVR32_SDRAMC.cr =
800020d2:	fe 6a 20 00 	mov	r10,-122880
      ((( SDRAM_COL_BITS                 -    8) << AVR32_SDRAMC_CR_NC_OFFSET  ) & AVR32_SDRAMC_CR_NC_MASK  ) |
800020d6:	e6 1b 0f 00 	andh	r11,0xf00,COH
800020da:	f1 eb 10 0b 	or	r11,r8,r11
      ((((SDRAM_TRC  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRC_OFFSET ) & AVR32_SDRAMC_CR_TRC_MASK ) |
      ((((SDRAM_TRP  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRP_OFFSET ) & AVR32_SDRAMC_CR_TRP_MASK ) |
      ((((SDRAM_TRCD * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRCD_OFFSET) & AVR32_SDRAMC_CR_TRCD_MASK) |
      ((((SDRAM_TRAS * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRAS_OFFSET) & AVR32_SDRAMC_CR_TRAS_MASK) |
      ((((SDRAM_TXSR * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TXSR_OFFSET) & AVR32_SDRAMC_CR_TXSR_MASK);
  AVR32_SDRAMC.cr;
800020de:	95 2b       	st.w	r10[0x8],r11

  // Issue a NOP command to the SDRAM in order to start the generation of SDRAMC signals.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_NOP;
800020e0:	74 28       	ld.w	r8,r10[0x8]
800020e2:	30 18       	mov	r8,1
  AVR32_SDRAMC.mr;
800020e4:	95 08       	st.w	r10[0x0],r8
  sdram[0];
800020e6:	74 08       	ld.w	r8,r10[0x0]
800020e8:	fc 18 d0 00 	movh	r8,0xd000
 * \param ck Number of HSB clock cycles to wait.
 */
static void sdramc_ck_delay(unsigned long ck)
{
  // Use the CPU cycle counter (CPU and HSB clocks are the same).
  unsigned long delay_start_cycle = Get_system_register(AVR32_COUNT);
800020ec:	90 08       	ld.sh	r8,r8[0x0]
800020ee:	e1 b8 00 42 	mfsr	r8,0x108
  unsigned long delay_end_cycle = delay_start_cycle + ck;
800020f2:	ee 0a 10 64 	mul	r10,r7,100
800020f6:	f0 0a 00 0a 	add	r10,r8,r10

  // To be safer, the end of wait is based on an inequality test, so CPU cycle
  // counter wrap around is checked.
  if (delay_start_cycle > delay_end_cycle)
800020fa:	14 38       	cp.w	r8,r10
800020fc:	e0 88 00 06 	brls	80002108 <sdramc_init+0x100>
  {
    while ((unsigned long)Get_system_register(AVR32_COUNT) > delay_end_cycle);
80002100:	e1 b8 00 42 	mfsr	r8,0x108
80002104:	10 3a       	cp.w	r10,r8
  }
  while ((unsigned long)Get_system_register(AVR32_COUNT) < delay_end_cycle);
80002106:	cf d3       	brcs	80002100 <sdramc_init+0xf8>
80002108:	e1 b8 00 42 	mfsr	r8,0x108
8000210c:	10 3a       	cp.w	r10,r8
8000210e:	fe 9b ff fd 	brhi	80002108 <sdramc_init+0x100>

  // Wait during the SDRAM stable-clock initialization delay.
  sdramc_us_delay(SDRAM_STABLE_CLOCK_INIT_DELAY, hsb_mhz_up);

  // Issue a PRECHARGE ALL command to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_BANKS_PRECHARGE;
80002112:	fe 68 20 00 	mov	r8,-122880
80002116:	30 2a       	mov	r10,2
  AVR32_SDRAMC.mr;
80002118:	91 0a       	st.w	r8[0x0],r10
  sdram[0];
8000211a:	70 08       	ld.w	r8,r8[0x0]
8000211c:	fc 18 d0 00 	movh	r8,0xd000
 * \param ck Number of HSB clock cycles to wait.
 */
static void sdramc_ck_delay(unsigned long ck)
{
  // Use the CPU cycle counter (CPU and HSB clocks are the same).
  unsigned long delay_start_cycle = Get_system_register(AVR32_COUNT);
80002120:	90 08       	ld.sh	r8,r8[0x0]
80002122:	e1 b8 00 42 	mfsr	r8,0x108
  unsigned long delay_end_cycle = delay_start_cycle + ck;
80002126:	f0 09 00 09 	add	r9,r8,r9

  // To be safer, the end of wait is based on an inequality test, so CPU cycle
  // counter wrap around is checked.
  if (delay_start_cycle > delay_end_cycle)
8000212a:	12 38       	cp.w	r8,r9
8000212c:	e0 88 00 06 	brls	80002138 <sdramc_init+0x130>
  {
    while ((unsigned long)Get_system_register(AVR32_COUNT) > delay_end_cycle);
80002130:	e1 b8 00 42 	mfsr	r8,0x108
80002134:	10 39       	cp.w	r9,r8
  }
  while ((unsigned long)Get_system_register(AVR32_COUNT) < delay_end_cycle);
80002136:	cf d3       	brcs	80002130 <sdramc_init+0x128>
80002138:	e1 b8 00 42 	mfsr	r8,0x108
8000213c:	10 39       	cp.w	r9,r8
8000213e:	fe 9b ff fd 	brhi	80002138 <sdramc_init+0x130>
  AVR32_SDRAMC.mr;
  sdram[0];
  sdramc_ns_delay(SDRAM_TRP, hsb_mhz_up);

  // Issue initialization AUTO REFRESH commands to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_AUTO_REFRESH;
80002142:	fe 68 20 00 	mov	r8,-122880
80002146:	30 4a       	mov	r10,4
  AVR32_SDRAMC.mr;
80002148:	91 0a       	st.w	r8[0x0],r10
8000214a:	70 08       	ld.w	r8,r8[0x0]
8000214c:	f8 09 15 01 	lsl	r9,r12,0x1
80002150:	e0 68 4d d3 	mov	r8,19923
80002154:	ea 18 10 62 	orh	r8,0x1062
80002158:	f2 c9 fc 19 	sub	r9,r9,-999
8000215c:	30 0a       	mov	r10,0
8000215e:	f2 08 06 48 	mulu.d	r8,r9,r8
  for (i = 0; i < SDRAM_INIT_AUTO_REFRESH_COUNT; i++)
  {
    sdram[0];
80002162:	fc 1b d0 00 	movh	r11,0xd000
  sdram[0];
  sdramc_ns_delay(SDRAM_TRP, hsb_mhz_up);

  // Issue initialization AUTO REFRESH commands to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_AUTO_REFRESH;
  AVR32_SDRAMC.mr;
80002166:	f2 0c 16 06 	lsr	r12,r9,0x6
 * \param ck Number of HSB clock cycles to wait.
 */
static void sdramc_ck_delay(unsigned long ck)
{
  // Use the CPU cycle counter (CPU and HSB clocks are the same).
  unsigned long delay_start_cycle = Get_system_register(AVR32_COUNT);
8000216a:	96 08       	ld.sh	r8,r11[0x0]
8000216c:	e1 b8 00 42 	mfsr	r8,0x108
  unsigned long delay_end_cycle = delay_start_cycle + ck;
80002170:	f0 0c 00 09 	add	r9,r8,r12

  // To be safer, the end of wait is based on an inequality test, so CPU cycle
  // counter wrap around is checked.
  if (delay_start_cycle > delay_end_cycle)
80002174:	12 38       	cp.w	r8,r9
80002176:	e0 88 00 06 	brls	80002182 <sdramc_init+0x17a>
  {
    while ((unsigned long)Get_system_register(AVR32_COUNT) > delay_end_cycle);
8000217a:	e1 b8 00 42 	mfsr	r8,0x108
8000217e:	10 39       	cp.w	r9,r8
  }
  while ((unsigned long)Get_system_register(AVR32_COUNT) < delay_end_cycle);
80002180:	cf d3       	brcs	8000217a <sdramc_init+0x172>
80002182:	e1 b8 00 42 	mfsr	r8,0x108
80002186:	10 39       	cp.w	r9,r8
80002188:	fe 9b ff fd 	brhi	80002182 <sdramc_init+0x17a>
  sdramc_ns_delay(SDRAM_TRP, hsb_mhz_up);

  // Issue initialization AUTO REFRESH commands to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_AUTO_REFRESH;
  AVR32_SDRAMC.mr;
  for (i = 0; i < SDRAM_INIT_AUTO_REFRESH_COUNT; i++)
8000218c:	2f fa       	sub	r10,-1
8000218e:	58 2a       	cp.w	r10,2
  //  - bit 3: burst type: sequential (0b);
  //  - bits 4 to 6: CAS latency: AVR32_SDRAMC.CR.cas;
  //  - bits 7 to 8: operating mode: standard operation (00b);
  //  - bit 9: write burst mode: programmed burst length (0b);
  //  - all other bits: reserved: 0b.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_LOAD_MODE;
80002190:	ce d1       	brne	8000216a <sdramc_init+0x162>
80002192:	fe 68 20 00 	mov	r8,-122880
80002196:	30 39       	mov	r9,3
  AVR32_SDRAMC.mr;
80002198:	91 09       	st.w	r8[0x0],r9
  sdram[0];
8000219a:	70 08       	ld.w	r8,r8[0x0]
8000219c:	fc 18 d0 00 	movh	r8,0xd000
 * \param ck Number of HSB clock cycles to wait.
 */
static void sdramc_ck_delay(unsigned long ck)
{
  // Use the CPU cycle counter (CPU and HSB clocks are the same).
  unsigned long delay_start_cycle = Get_system_register(AVR32_COUNT);
800021a0:	90 08       	ld.sh	r8,r8[0x0]
800021a2:	e1 b8 00 42 	mfsr	r8,0x108
  unsigned long delay_end_cycle = delay_start_cycle + ck;
800021a6:	e0 69 4d d3 	mov	r9,19923
800021aa:	ea 19 10 62 	orh	r9,0x1062
800021ae:	ee 0b 15 01 	lsl	r11,r7,0x1
800021b2:	f6 cb fc 19 	sub	r11,r11,-999
800021b6:	f6 09 06 4a 	mulu.d	r10,r11,r9
800021ba:	f6 09 16 06 	lsr	r9,r11,0x6
800021be:	f0 09 00 09 	add	r9,r8,r9

  // To be safer, the end of wait is based on an inequality test, so CPU cycle
  // counter wrap around is checked.
  if (delay_start_cycle > delay_end_cycle)
800021c2:	12 38       	cp.w	r8,r9
800021c4:	e0 88 00 06 	brls	800021d0 <sdramc_init+0x1c8>
  {
    while ((unsigned long)Get_system_register(AVR32_COUNT) > delay_end_cycle);
800021c8:	e1 b8 00 42 	mfsr	r8,0x108
800021cc:	10 39       	cp.w	r9,r8
  }
  while ((unsigned long)Get_system_register(AVR32_COUNT) < delay_end_cycle);
800021ce:	cf d3       	brcs	800021c8 <sdramc_init+0x1c0>
800021d0:	e1 b8 00 42 	mfsr	r8,0x108
800021d4:	10 39       	cp.w	r9,r8
800021d6:	fe 9b ff fd 	brhi	800021d0 <sdramc_init+0x1c8>
  AVR32_SDRAMC.mr;
  sdram[0];
  sdramc_ns_delay(SDRAM_TMRD, hsb_mhz_up);

  // Switch the SDRAM Controller to normal mode.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_NORMAL;
800021da:	30 09       	mov	r9,0
800021dc:	fe 68 20 00 	mov	r8,-122880
  AVR32_SDRAMC.mr;
800021e0:	91 09       	st.w	r8[0x0],r9
  sdram[0];
800021e2:	70 09       	ld.w	r9,r8[0x0]
800021e4:	fc 19 d0 00 	movh	r9,0xd000

  // Write the refresh period into the SDRAMC Refresh Timer Register.
  // tR is rounded down because it is a maximal value.
  AVR32_SDRAMC.tr = (SDRAM_TR * hsb_mhz_dn) / 1000;
800021e8:	92 09       	ld.sh	r9,r9[0x0]
800021ea:	e0 69 1e 84 	mov	r9,7812
800021ee:	e0 6b de 83 	mov	r11,56963
800021f2:	ea 1b 43 1b 	orh	r11,0x431b
800021f6:	ec 0b 06 4a 	mulu.d	r10,r6,r11
800021fa:	b3 8b       	lsr	r11,0x12
800021fc:	b3 3b       	mul	r11,r9
800021fe:	e0 69 4d d3 	mov	r9,19923
80002202:	ea 19 10 62 	orh	r9,0x1062
80002206:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000220a:	f6 09 16 06 	lsr	r9,r11,0x6
  AVR32_SDRAMC.tr;
8000220e:	91 19       	st.w	r8[0x4],r9
}
80002210:	70 18       	ld.w	r8,r8[0x4]
80002212:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002216:	d7 03       	nop
80002218:	80 01       	ld.sh	r1,r0[0x0]
8000221a:	6e 00       	ld.w	r0,r7[0x0]

8000221c <LodePNG_convert>:
 converts from any color type to 24-bit or 32-bit (later maybe more supported). return value = LodePNG error code
 the out buffer must have (w * h * bpp + 7) / 8 bytes, where bpp is the bits per pixel of the output color type (LodePNG_InfoColor_getBpp)
 for < 8 bpp images, there may _not_ be padding bits at the end of scanlines.
 */
 unsigned LodePNG_convert(unsigned char* out, const unsigned char* in, LodePNG_InfoColor* infoOut, LodePNG_InfoColor* infoIn, unsigned w, unsigned h)
 {
8000221c:	d4 31       	pushm	r0-r7,lr
8000221e:	20 2d       	sub	sp,8
80002220:	40 be       	lddsp	lr,sp[0x2c]
   const size_t numpixels = w * h; /*amount of pixels*/
80002222:	fc 08 02 48 	mul	r8,lr,r8
   info->palette[4 * info->palettesize + 3] = a;
   info->palettesize++;
   return 0;
 }
 
 unsigned LodePNG_InfoColor_getBpp(const LodePNG_InfoColor* info) { return getBpp(info->colorType, info->bitDepth); } /*calculate bits per pixel out of colorType and bitDepth*/
80002226:	74 0e       	ld.w	lr,r10[0x0]
80002228:	74 1a       	ld.w	r10,r10[0x4]
8000222a:	58 6e       	cp.w	lr,6
8000222c:	e0 88 00 1b 	brls	80002262 <LodePNG_convert+0x46>
80002230:	30 03       	mov	r3,0
 unsigned LodePNG_InfoColor_isAlphaType(const LodePNG_InfoColor* info) { return (info->colorType & 4) != 0; }
 
 unsigned LodePNG_InfoColor_equal(const LodePNG_InfoColor* info1, const LodePNG_InfoColor* info2)
 {
   return info1->colorType == info2->colorType
       && info1->bitDepth  == info2->bitDepth; /*palette and color key not compared*/
80002232:	72 01       	ld.w	r1,r9[0x0]
 unsigned LodePNG_InfoColor_isGreyscaleType(const LodePNG_InfoColor* info) { return info->colorType == 0 || info->colorType == 4; }
 unsigned LodePNG_InfoColor_isAlphaType(const LodePNG_InfoColor* info) { return (info->colorType & 4) != 0; }
 
 unsigned LodePNG_InfoColor_equal(const LodePNG_InfoColor* info1, const LodePNG_InfoColor* info2)
 {
   return info1->colorType == info2->colorType
80002234:	02 3e       	cp.w	lr,r1
80002236:	c2 00       	breq	80002276 <LodePNG_convert+0x5a>
     size_t i, size = (w * h * LodePNG_InfoColor_getBpp(infoIn) + 7) / 8;
     for(i = 0; i < size; i++) out[i] = in[i];
     return 0;
   }
 
   if((infoOut->colorType == 2 || infoOut->colorType == 6) && infoOut->bitDepth == 8)
80002238:	58 6e       	cp.w	lr,6
8000223a:	5f 06       	sreq	r6
8000223c:	58 2e       	cp.w	lr,2
8000223e:	5f 07       	sreq	r7
 }
 
 unsigned LodePNG_InfoColor_getBpp(const LodePNG_InfoColor* info) { return getBpp(info->colorType, info->bitDepth); } /*calculate bits per pixel out of colorType and bitDepth*/
 unsigned LodePNG_InfoColor_getChannels(const LodePNG_InfoColor* info) { return getNumColorChannels(info->colorType); }
 unsigned LodePNG_InfoColor_isGreyscaleType(const LodePNG_InfoColor* info) { return info->colorType == 0 || info->colorType == 4; }
 unsigned LodePNG_InfoColor_isAlphaType(const LodePNG_InfoColor* info) { return (info->colorType & 4) != 0; }
80002240:	e5 de c0 41 	bfextu	r2,lr,0x2,0x1
     size_t i, size = (w * h * LodePNG_InfoColor_getBpp(infoIn) + 7) / 8;
     for(i = 0; i < size; i++) out[i] = in[i];
     return 0;
   }
 
   if((infoOut->colorType == 2 || infoOut->colorType == 6) && infoOut->bitDepth == 8)
80002244:	ed e7 10 07 	or	r7,r6,r7
80002248:	e0 81 00 b7 	brne	800023b6 <LodePNG_convert+0x19a>
         break;
         default: break;
       }
     }
   }
   else if(LodePNG_InfoColor_isGreyscaleType(infoOut) && infoOut->bitDepth == 8) /*conversion from greyscale to greyscale*/
8000224c:	58 0e       	cp.w	lr,0
8000224e:	5f 07       	sreq	r7
80002250:	58 4e       	cp.w	lr,4
80002252:	5f 0e       	sreq	lr
80002254:	0e 4e       	or	lr,r7
80002256:	c0 30       	breq	8000225c <LodePNG_convert+0x40>
80002258:	58 8a       	cp.w	r10,8
8000225a:	c5 00       	breq	800022fa <LodePNG_convert+0xde>
       }
     }
     else /*infoIn->bitDepth is less than 8 bit per channel*/
     {
       if(infoIn->colorType != 0) return 31; /*colorType 0 is the only greyscale type with < 8 bits per channel*/
       for(i = 0; i < numpixels; i++)
8000225c:	33 bc       	mov	r12,59
     }
   }
   else return 59;
 
   return 0;
 }
8000225e:	2f ed       	sub	sp,-8
80002260:	d8 32       	popm	r0-r7,pc
   info->palette[4 * info->palettesize + 3] = a;
   info->palettesize++;
   return 0;
 }
 
 unsigned LodePNG_InfoColor_getBpp(const LodePNG_InfoColor* info) { return getBpp(info->colorType, info->bitDepth); } /*calculate bits per pixel out of colorType and bitDepth*/
80002262:	fe f7 08 46 	ld.w	r7,pc[2118]
 unsigned LodePNG_InfoColor_isAlphaType(const LodePNG_InfoColor* info) { return (info->colorType & 4) != 0; }
 
 unsigned LodePNG_InfoColor_equal(const LodePNG_InfoColor* info1, const LodePNG_InfoColor* info2)
 {
   return info1->colorType == info2->colorType
       && info1->bitDepth  == info2->bitDepth; /*palette and color key not compared*/
80002266:	72 01       	ld.w	r1,r9[0x0]
   info->palette[4 * info->palettesize + 3] = a;
   info->palettesize++;
   return 0;
 }
 
 unsigned LodePNG_InfoColor_getBpp(const LodePNG_InfoColor* info) { return getBpp(info->colorType, info->bitDepth); } /*calculate bits per pixel out of colorType and bitDepth*/
80002268:	ee 0e 03 23 	ld.w	r3,r7[lr<<0x2]
8000226c:	f4 03 02 43 	mul	r3,r10,r3
80002270:	a3 93       	lsr	r3,0x3
 unsigned LodePNG_InfoColor_isGreyscaleType(const LodePNG_InfoColor* info) { return info->colorType == 0 || info->colorType == 4; }
 unsigned LodePNG_InfoColor_isAlphaType(const LodePNG_InfoColor* info) { return (info->colorType & 4) != 0; }
 
 unsigned LodePNG_InfoColor_equal(const LodePNG_InfoColor* info1, const LodePNG_InfoColor* info2)
 {
   return info1->colorType == info2->colorType
80002272:	02 3e       	cp.w	lr,r1
80002274:	ce 21       	brne	80002238 <LodePNG_convert+0x1c>
80002276:	72 17       	ld.w	r7,r9[0x4]
80002278:	0e 3a       	cp.w	r10,r7
8000227a:	cd f1       	brne	80002238 <LodePNG_convert+0x1c>
8000227c:	58 6e       	cp.w	lr,6
8000227e:	e0 8b 00 3b 	brhi	800022f4 <LodePNG_convert+0xd8>
   size_t i, c, bp = 0; /*bitpointer, used by less-than-8-bit color types*/
 
   /*cases where in and out already have the same format*/
   if(LodePNG_InfoColor_equal(infoIn, infoOut))
   {
     size_t i, size = (w * h * LodePNG_InfoColor_getBpp(infoIn) + 7) / 8;
80002282:	fe f9 08 26 	ld.w	r9,pc[2086]
80002286:	f2 0e 03 26 	ld.w	r6,r9[lr<<0x2]
8000228a:	f4 06 02 46 	mul	r6,r10,r6
8000228e:	b1 36       	mul	r6,r8
80002290:	2f 96       	sub	r6,-7
80002292:	ec 07 16 03 	lsr	r7,r6,0x3
     for(i = 0; i < size; i++) out[i] = in[i];
80002296:	c2 f0       	breq	800022f4 <LodePNG_convert+0xd8>
80002298:	f7 ec 10 08 	or	r8,r11,r12
8000229c:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800022a0:	5f 08       	sreq	r8
800022a2:	58 37       	cp.w	r7,3
800022a4:	5f b9       	srhi	r9
800022a6:	10 69       	and	r9,r8
800022a8:	f6 c8 ff fc 	sub	r8,r11,-4
800022ac:	10 3c       	cp.w	r12,r8
800022ae:	5f ba       	srhi	r10
800022b0:	f8 c8 ff fc 	sub	r8,r12,-4
800022b4:	10 3b       	cp.w	r11,r8
800022b6:	5f b8       	srhi	r8
800022b8:	f5 e8 10 08 	or	r8,r10,r8
800022bc:	f3 e8 00 08 	and	r8,r9,r8
800022c0:	e0 80 00 f0 	breq	800024a0 <LodePNG_convert+0x284>
800022c4:	a5 96       	lsr	r6,0x5
800022c6:	ec 09 15 02 	lsl	r9,r6,0x2
800022ca:	c0 d0       	breq	800022e4 <LodePNG_convert+0xc8>
800022cc:	30 08       	mov	r8,0
800022ce:	10 9a       	mov	r10,r8
800022d0:	f6 08 03 0e 	ld.w	lr,r11[r8]
800022d4:	f8 08 09 0e 	st.w	r12[r8],lr
800022d8:	2f fa       	sub	r10,-1
800022da:	2f c8       	sub	r8,-4
800022dc:	0c 3a       	cp.w	r10,r6
800022de:	cf 93       	brcs	800022d0 <LodePNG_convert+0xb4>
800022e0:	12 37       	cp.w	r7,r9
800022e2:	c0 90       	breq	800022f4 <LodePNG_convert+0xd8>
800022e4:	12 0b       	add	r11,r9
800022e6:	12 0c       	add	r12,r9
800022e8:	17 38       	ld.ub	r8,r11++
800022ea:	18 c8       	st.b	r12++,r8
800022ec:	2f f9       	sub	r9,-1
800022ee:	12 37       	cp.w	r7,r9
800022f0:	fe 9b ff fc 	brhi	800022e8 <LodePNG_convert+0xcc>
       }
     }
     else /*infoIn->bitDepth is less than 8 bit per channel*/
     {
       if(infoIn->colorType != 0) return 31; /*colorType 0 is the only greyscale type with < 8 bits per channel*/
       for(i = 0; i < numpixels; i++)
800022f4:	30 0c       	mov	r12,0
     }
   }
   else return 59;
 
   return 0;
 }
800022f6:	2f ed       	sub	sp,-8
800022f8:	d8 32       	popm	r0-r7,pc
       }
     }
   }
   else if(LodePNG_InfoColor_isGreyscaleType(infoOut) && infoOut->bitDepth == 8) /*conversion from greyscale to greyscale*/
   {
     if(!LodePNG_InfoColor_isGreyscaleType(infoIn)) return 62;
800022fa:	58 41       	cp.w	r1,4
800022fc:	5f 0e       	sreq	lr
800022fe:	58 01       	cp.w	r1,0
80002300:	5f 0a       	sreq	r10
80002302:	fd ea 10 0a 	or	r10,lr,r10
80002306:	e0 80 00 9d 	breq	80002440 <LodePNG_convert+0x224>
     if(infoIn->bitDepth == 8)
8000230a:	72 14       	ld.w	r4,r9[0x4]
8000230c:	58 84       	cp.w	r4,8
8000230e:	e0 80 00 9b 	breq	80002444 <LodePNG_convert+0x228>
           }
         break;
         default: return 31;
       }
     }
     else if(infoIn->bitDepth == 16)
80002312:	59 04       	cp.w	r4,16
80002314:	e0 80 01 12 	breq	80002538 <LodePNG_convert+0x31c>
         default: return 31;
       }
     }
     else /*infoIn->bitDepth is less than 8 bit per channel*/
     {
       if(infoIn->colorType != 0) return 31; /*colorType 0 is the only greyscale type with < 8 bits per channel*/
80002318:	58 01       	cp.w	r1,0
8000231a:	e0 81 00 ce 	brne	800024b6 <LodePNG_convert+0x29a>
       for(i = 0; i < numpixels; i++)
8000231e:	58 08       	cp.w	r8,0
80002320:	ce a0       	breq	800022f4 <LodePNG_convert+0xd8>
80002322:	02 9e       	mov	lr,r1
80002324:	02 90       	mov	r0,r1
       {
         unsigned value = readBitsFromReversedStream(&bp, in, infoIn->bitDepth);
         if(OUT_ALPHA) out[OUT_BYTES * i + 1] = 255;
         if(OUT_ALPHA && infoIn->key_defined && value && ((1U << infoIn->bitDepth) - 1U) == infoIn->key_r && ((1U << infoIn->bitDepth) - 1U)) out[OUT_BYTES * i + 1] = 0;
80002326:	08 9a       	mov	r10,r4
 
 static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0;
   size_t i;
   for(i = nbits - 1; i < nbits; i--) result += (unsigned)readBitFromReversedStream(bitpointer, bitstream) << i;
80002328:	f4 c7 00 01 	sub	r7,r10,1
8000232c:	14 37       	cp.w	r7,r10
8000232e:	e0 82 00 e5 	brhs	800024f8 <LodePNG_convert+0x2dc>
80002332:	30 05       	mov	r5,0
 /* / Reading and writing single bits and bytes from/to stream for LodePNG   / */
 /* ////////////////////////////////////////////////////////////////////////// */
 
 static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
80002334:	fc 06 16 03 	lsr	r6,lr,0x3
80002338:	f6 06 07 04 	ld.ub	r4,r11[r6]
8000233c:	fc 06 11 ff 	rsub	r6,lr,-1
   (*bitpointer)++;
80002340:	2f fe       	sub	lr,-1
 /* / Reading and writing single bits and bytes from/to stream for LodePNG   / */
 /* ////////////////////////////////////////////////////////////////////////// */
 
 static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
80002342:	ed d6 c0 03 	bfextu	r6,r6,0x0,0x3
80002346:	e8 06 08 46 	asr	r6,r4,r6
8000234a:	ed d6 c0 01 	bfextu	r6,r6,0x0,0x1
 
 static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0;
   size_t i;
   for(i = nbits - 1; i < nbits; i--) result += (unsigned)readBitFromReversedStream(bitpointer, bitstream) << i;
8000234e:	ec 07 09 46 	lsl	r6,r6,r7
80002352:	20 17       	sub	r7,1
80002354:	0c 05       	add	r5,r6
80002356:	14 37       	cp.w	r7,r10
80002358:	ce e3       	brcs	80002334 <LodePNG_convert+0x118>
8000235a:	ea 07 15 08 	lsl	r7,r5,0x8
8000235e:	0a 17       	sub	r7,r5
     {
       if(infoIn->colorType != 0) return 31; /*colorType 0 is the only greyscale type with < 8 bits per channel*/
       for(i = 0; i < numpixels; i++)
       {
         unsigned value = readBitsFromReversedStream(&bp, in, infoIn->bitDepth);
         if(OUT_ALPHA) out[OUT_BYTES * i + 1] = 255;
80002360:	58 02       	cp.w	r2,0
80002362:	c1 a0       	breq	80002396 <LodePNG_convert+0x17a>
80002364:	3f fa       	mov	r10,-1
 /*
 converts from any color type to 24-bit or 32-bit (later maybe more supported). return value = LodePNG error code
 the out buffer must have (w * h * bpp + 7) / 8 bytes, where bpp is the bits per pixel of the output color type (LodePNG_InfoColor_getBpp)
 for < 8 bpp images, there may _not_ be padding bits at the end of scanlines.
 */
 unsigned LodePNG_convert(unsigned char* out, const unsigned char* in, LodePNG_InfoColor* infoOut, LodePNG_InfoColor* infoIn, unsigned w, unsigned h)
80002366:	f8 01 00 06 	add	r6,r12,r1
       if(infoIn->colorType != 0) return 31; /*colorType 0 is the only greyscale type with < 8 bits per channel*/
       for(i = 0; i < numpixels; i++)
       {
         unsigned value = readBitsFromReversedStream(&bp, in, infoIn->bitDepth);
         if(OUT_ALPHA) out[OUT_BYTES * i + 1] = 255;
         if(OUT_ALPHA && infoIn->key_defined && value && ((1U << infoIn->bitDepth) - 1U) == infoIn->key_r && ((1U << infoIn->bitDepth) - 1U)) out[OUT_BYTES * i + 1] = 0;
8000236a:	58 05       	cp.w	r5,0
8000236c:	5f 15       	srne	r5
     {
       if(infoIn->colorType != 0) return 31; /*colorType 0 is the only greyscale type with < 8 bits per channel*/
       for(i = 0; i < numpixels; i++)
       {
         unsigned value = readBitsFromReversedStream(&bp, in, infoIn->bitDepth);
         if(OUT_ALPHA) out[OUT_BYTES * i + 1] = 255;
8000236e:	ac 9a       	st.b	r6[0x1],r10
         if(OUT_ALPHA && infoIn->key_defined && value && ((1U << infoIn->bitDepth) - 1U) == infoIn->key_r && ((1U << infoIn->bitDepth) - 1U)) out[OUT_BYTES * i + 1] = 0;
80002370:	72 4a       	ld.w	r10,r9[0x10]
80002372:	58 0a       	cp.w	r10,0
80002374:	5f 1a       	srne	r10
80002376:	eb ea 00 0a 	and	r10,r5,r10
8000237a:	30 05       	mov	r5,0
8000237c:	ea 0a 18 00 	cp.b	r10,r5
80002380:	e0 80 00 8e 	breq	8000249c <LodePNG_convert+0x280>
80002384:	72 1a       	ld.w	r10,r9[0x4]
80002386:	30 14       	mov	r4,1
80002388:	e8 0a 09 44 	lsl	r4,r4,r10
8000238c:	50 14       	stdsp	sp[0x4],r4
8000238e:	20 14       	sub	r4,1
80002390:	72 55       	ld.w	r5,r9[0x14]
80002392:	0a 34       	cp.w	r4,r5
80002394:	c7 f0       	breq	80002492 <LodePNG_convert+0x276>
         value = (value * 255) / ((1 << infoIn->bitDepth) - 1); /*scale value from 0 to 255*/
         out[OUT_BYTES * i] = (unsigned char)(value);
80002396:	30 16       	mov	r6,1
80002398:	ec 0a 09 4a 	lsl	r10,r6,r10
8000239c:	20 1a       	sub	r10,1
8000239e:	ee 0a 0d 06 	divu	r6,r7,r10
800023a2:	f8 01 0b 06 	st.b	r12[r1],r6
800023a6:	0c 95       	mov	r5,r6
       }
     }
     else /*infoIn->bitDepth is less than 8 bit per channel*/
     {
       if(infoIn->colorType != 0) return 31; /*colorType 0 is the only greyscale type with < 8 bits per channel*/
       for(i = 0; i < numpixels; i++)
800023a8:	2f f0       	sub	r0,-1
800023aa:	06 01       	add	r1,r3
800023ac:	00 38       	cp.w	r8,r0
800023ae:	fe 98 ff a3 	brls	800022f4 <LodePNG_convert+0xd8>
800023b2:	72 1a       	ld.w	r10,r9[0x4]
800023b4:	cb ab       	rjmp	80002328 <LodePNG_convert+0x10c>
     size_t i, size = (w * h * LodePNG_InfoColor_getBpp(infoIn) + 7) / 8;
     for(i = 0; i < size; i++) out[i] = in[i];
     return 0;
   }
 
   if((infoOut->colorType == 2 || infoOut->colorType == 6) && infoOut->bitDepth == 8)
800023b6:	58 8a       	cp.w	r10,8
800023b8:	fe 91 ff 4a 	brne	8000224c <LodePNG_convert+0x30>
   {
     if(infoIn->bitDepth == 8)
800023bc:	72 17       	ld.w	r7,r9[0x4]
800023be:	58 87       	cp.w	r7,8
800023c0:	e0 80 01 2b 	breq	80002616 <LodePNG_convert+0x3fa>
           }
         break;
         default: break;
       }
     }
     else if(infoIn->bitDepth == 16)
800023c4:	59 07       	cp.w	r7,16
800023c6:	e0 80 01 65 	breq	80002690 <LodePNG_convert+0x474>
         default: break;
       }
     }
     else /*infoIn->bitDepth is less than 8 bit per channel*/
     {
       switch(infoIn->colorType)
800023ca:	58 01       	cp.w	r1,0
800023cc:	e0 81 00 e8 	brne	8000259c <LodePNG_convert+0x380>
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
800023d0:	58 08       	cp.w	r8,0
800023d2:	c9 10       	breq	800022f4 <LodePNG_convert+0xd8>
800023d4:	02 9e       	mov	lr,r1
800023d6:	02 90       	mov	r0,r1
 
 static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0;
   size_t i;
   for(i = nbits - 1; i < nbits; i--) result += (unsigned)readBitFromReversedStream(bitpointer, bitstream) << i;
800023d8:	ee ca 00 01 	sub	r10,r7,1
800023dc:	0e 3a       	cp.w	r10,r7
800023de:	e0 82 01 79 	brhs	800026d0 <LodePNG_convert+0x4b4>
800023e2:	30 05       	mov	r5,0
 /* / Reading and writing single bits and bytes from/to stream for LodePNG   / */
 /* ////////////////////////////////////////////////////////////////////////// */
 
 static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
800023e4:	fc 06 16 03 	lsr	r6,lr,0x3
800023e8:	f6 06 07 04 	ld.ub	r4,r11[r6]
800023ec:	fc 06 11 ff 	rsub	r6,lr,-1
   (*bitpointer)++;
800023f0:	2f fe       	sub	lr,-1
 /* / Reading and writing single bits and bytes from/to stream for LodePNG   / */
 /* ////////////////////////////////////////////////////////////////////////// */
 
 static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
800023f2:	ed d6 c0 03 	bfextu	r6,r6,0x0,0x3
800023f6:	e8 06 08 46 	asr	r6,r4,r6
800023fa:	ed d6 c0 01 	bfextu	r6,r6,0x0,0x1
 
 static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0;
   size_t i;
   for(i = nbits - 1; i < nbits; i--) result += (unsigned)readBitFromReversedStream(bitpointer, bitstream) << i;
800023fe:	ec 0a 09 46 	lsl	r6,r6,r10
80002402:	20 1a       	sub	r10,1
80002404:	0c 05       	add	r5,r6
80002406:	0e 3a       	cp.w	r10,r7
80002408:	ce e3       	brcs	800023e4 <LodePNG_convert+0x1c8>
8000240a:	ea 06 15 08 	lsl	r6,r5,0x8
8000240e:	0a 16       	sub	r6,r5
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
           {
             unsigned value = readBitsFromReversedStream(&bp, in, infoIn->bitDepth);
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = 255;
80002410:	58 02       	cp.w	r2,0
80002412:	c5 41       	brne	800024ba <LodePNG_convert+0x29e>
80002414:	f8 01 00 0a 	add	r10,r12,r1
             if(OUT_ALPHA && infoIn->key_defined && value && ((1U << infoIn->bitDepth) - 1U) == infoIn->key_r && ((1U << infoIn->bitDepth) - 1U)) out[OUT_BYTES * i + 3] = 0;
             value = (value * 255) / ((1 << infoIn->bitDepth) - 1); /*scale value from 0 to 255*/
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = (unsigned char)(value);
80002418:	30 15       	mov	r5,1
8000241a:	ea 07 09 47 	lsl	r7,r5,r7
8000241e:	20 17       	sub	r7,1
80002420:	ec 07 0d 06 	divu	r6,r6,r7
80002424:	0c 97       	mov	r7,r6
80002426:	5c 57       	castu.b	r7
80002428:	b4 97       	st.b	r10[0x1],r7
8000242a:	b4 a7       	st.b	r10[0x2],r7
8000242c:	f8 01 0b 07 	st.b	r12[r1],r7
80002430:	0e 94       	mov	r4,r7
     else /*infoIn->bitDepth is less than 8 bit per channel*/
     {
       switch(infoIn->colorType)
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
80002432:	0a 00       	add	r0,r5
80002434:	06 01       	add	r1,r3
80002436:	00 38       	cp.w	r8,r0
80002438:	fe 98 ff 5e 	brls	800022f4 <LodePNG_convert+0xd8>
8000243c:	72 17       	ld.w	r7,r9[0x4]
8000243e:	cc db       	rjmp	800023d8 <LodePNG_convert+0x1bc>
       }
     }
   }
   else if(LodePNG_InfoColor_isGreyscaleType(infoOut) && infoOut->bitDepth == 8) /*conversion from greyscale to greyscale*/
   {
     if(!LodePNG_InfoColor_isGreyscaleType(infoIn)) return 62;
80002440:	33 ec       	mov	r12,62
80002442:	c0 eb       	rjmp	8000225e <LodePNG_convert+0x42>
     if(infoIn->bitDepth == 8)
     {
       switch(infoIn->colorType)
80002444:	58 01       	cp.w	r1,0
80002446:	c5 c1       	brne	800024fe <LodePNG_convert+0x2e2>
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
80002448:	58 08       	cp.w	r8,0
8000244a:	fe 90 ff 55 	breq	800022f4 <LodePNG_convert+0xd8>
8000244e:	58 02       	cp.w	r2,0
80002450:	c1 80       	breq	80002480 <LodePNG_convert+0x264>
80002452:	2f fc       	sub	r12,-1
           {
             if(OUT_ALPHA) out[OUT_BYTES * i + 1] = 255;
80002454:	3f fe       	mov	lr,-1
             out[OUT_BYTES * i] = in[i];
             if(OUT_ALPHA && infoIn->key_defined && in[i] == infoIn->key_r) out[OUT_BYTES * i + 1] = 0;
80002456:	02 96       	mov	r6,r1
       switch(infoIn->colorType)
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
           {
             if(OUT_ALPHA) out[OUT_BYTES * i + 1] = 255;
80002458:	b8 8e       	st.b	r12[0x0],lr
             out[OUT_BYTES * i] = in[i];
8000245a:	17 8a       	ld.ub	r10,r11[0x0]
8000245c:	f9 6a ff ff 	st.b	r12[-1],r10
     if(infoIn->bitDepth == 8)
     {
       switch(infoIn->colorType)
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
80002460:	2f f1       	sub	r1,-1
           {
             if(OUT_ALPHA) out[OUT_BYTES * i + 1] = 255;
             out[OUT_BYTES * i] = in[i];
             if(OUT_ALPHA && infoIn->key_defined && in[i] == infoIn->key_r) out[OUT_BYTES * i + 1] = 0;
80002462:	72 4a       	ld.w	r10,r9[0x10]
80002464:	58 0a       	cp.w	r10,0
80002466:	c0 60       	breq	80002472 <LodePNG_convert+0x256>
80002468:	17 87       	ld.ub	r7,r11[0x0]
8000246a:	72 5a       	ld.w	r10,r9[0x14]
8000246c:	14 37       	cp.w	r7,r10
8000246e:	f9 f6 0e 00 	st.beq	r12[0x0],r6
     if(infoIn->bitDepth == 8)
     {
       switch(infoIn->colorType)
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
80002472:	06 0c       	add	r12,r3
80002474:	2f fb       	sub	r11,-1
80002476:	02 38       	cp.w	r8,r1
80002478:	fe 9b ff f0 	brhi	80002458 <LodePNG_convert+0x23c>
       }
     }
     else /*infoIn->bitDepth is less than 8 bit per channel*/
     {
       if(infoIn->colorType != 0) return 31; /*colorType 0 is the only greyscale type with < 8 bits per channel*/
       for(i = 0; i < numpixels; i++)
8000247c:	30 0c       	mov	r12,0
8000247e:	c3 cb       	rjmp	800022f6 <LodePNG_convert+0xda>
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
           {
             if(OUT_ALPHA) out[OUT_BYTES * i + 1] = 255;
             out[OUT_BYTES * i] = in[i];
80002480:	f6 02 07 09 	ld.ub	r9,r11[r2]
80002484:	b8 89       	st.b	r12[0x0],r9
     if(infoIn->bitDepth == 8)
     {
       switch(infoIn->colorType)
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
80002486:	2f f2       	sub	r2,-1
80002488:	06 0c       	add	r12,r3
8000248a:	04 38       	cp.w	r8,r2
8000248c:	fe 9b ff fa 	brhi	80002480 <LodePNG_convert+0x264>
80002490:	c3 2b       	rjmp	800022f4 <LodePNG_convert+0xd8>
       if(infoIn->colorType != 0) return 31; /*colorType 0 is the only greyscale type with < 8 bits per channel*/
       for(i = 0; i < numpixels; i++)
       {
         unsigned value = readBitsFromReversedStream(&bp, in, infoIn->bitDepth);
         if(OUT_ALPHA) out[OUT_BYTES * i + 1] = 255;
         if(OUT_ALPHA && infoIn->key_defined && value && ((1U << infoIn->bitDepth) - 1U) == infoIn->key_r && ((1U << infoIn->bitDepth) - 1U)) out[OUT_BYTES * i + 1] = 0;
80002492:	40 14       	lddsp	r4,sp[0x4]
80002494:	58 14       	cp.w	r4,1
80002496:	c8 00       	breq	80002396 <LodePNG_convert+0x17a>
80002498:	30 0a       	mov	r10,0
8000249a:	ac 9a       	st.b	r6[0x1],r10
8000249c:	72 1a       	ld.w	r10,r9[0x4]
8000249e:	c7 cb       	rjmp	80002396 <LodePNG_convert+0x17a>
 
   /*cases where in and out already have the same format*/
   if(LodePNG_InfoColor_equal(infoIn, infoOut))
   {
     size_t i, size = (w * h * LodePNG_InfoColor_getBpp(infoIn) + 7) / 8;
     for(i = 0; i < size; i++) out[i] = in[i];
800024a0:	30 08       	mov	r8,0
800024a2:	f6 08 07 09 	ld.ub	r9,r11[r8]
800024a6:	f8 08 0b 09 	st.b	r12[r8],r9
800024aa:	2f f8       	sub	r8,-1
800024ac:	10 37       	cp.w	r7,r8
800024ae:	fe 9b ff fa 	brhi	800024a2 <LodePNG_convert+0x286>
       }
     }
     else /*infoIn->bitDepth is less than 8 bit per channel*/
     {
       if(infoIn->colorType != 0) return 31; /*colorType 0 is the only greyscale type with < 8 bits per channel*/
       for(i = 0; i < numpixels; i++)
800024b2:	30 0c       	mov	r12,0
800024b4:	c2 1b       	rjmp	800022f6 <LodePNG_convert+0xda>
800024b6:	31 fc       	mov	r12,31
800024b8:	cd 3a       	rjmp	8000225e <LodePNG_convert+0x42>
 /*
 converts from any color type to 24-bit or 32-bit (later maybe more supported). return value = LodePNG error code
 the out buffer must have (w * h * bpp + 7) / 8 bytes, where bpp is the bits per pixel of the output color type (LodePNG_InfoColor_getBpp)
 for < 8 bpp images, there may _not_ be padding bits at the end of scanlines.
 */
 unsigned LodePNG_convert(unsigned char* out, const unsigned char* in, LodePNG_InfoColor* infoOut, LodePNG_InfoColor* infoIn, unsigned w, unsigned h)
800024ba:	f8 01 00 0a 	add	r10,r12,r1
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
           {
             unsigned value = readBitsFromReversedStream(&bp, in, infoIn->bitDepth);
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = 255;
800024be:	3f f4       	mov	r4,-1
             if(OUT_ALPHA && infoIn->key_defined && value && ((1U << infoIn->bitDepth) - 1U) == infoIn->key_r && ((1U << infoIn->bitDepth) - 1U)) out[OUT_BYTES * i + 3] = 0;
800024c0:	58 05       	cp.w	r5,0
800024c2:	5f 15       	srne	r5
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
           {
             unsigned value = readBitsFromReversedStream(&bp, in, infoIn->bitDepth);
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = 255;
800024c4:	b4 b4       	st.b	r10[0x3],r4
             if(OUT_ALPHA && infoIn->key_defined && value && ((1U << infoIn->bitDepth) - 1U) == infoIn->key_r && ((1U << infoIn->bitDepth) - 1U)) out[OUT_BYTES * i + 3] = 0;
800024c6:	72 47       	ld.w	r7,r9[0x10]
800024c8:	58 07       	cp.w	r7,0
800024ca:	5f 17       	srne	r7
800024cc:	0e 65       	and	r5,r7
800024ce:	0a 97       	mov	r7,r5
800024d0:	30 05       	mov	r5,0
800024d2:	ea 07 18 00 	cp.b	r7,r5
800024d6:	c0 f0       	breq	800024f4 <LodePNG_convert+0x2d8>
800024d8:	72 17       	ld.w	r7,r9[0x4]
800024da:	30 14       	mov	r4,1
800024dc:	e8 07 09 44 	lsl	r4,r4,r7
800024e0:	50 14       	stdsp	sp[0x4],r4
800024e2:	20 14       	sub	r4,1
800024e4:	72 55       	ld.w	r5,r9[0x14]
800024e6:	0a 34       	cp.w	r4,r5
800024e8:	c9 81       	brne	80002418 <LodePNG_convert+0x1fc>
800024ea:	40 14       	lddsp	r4,sp[0x4]
800024ec:	58 14       	cp.w	r4,1
800024ee:	c9 50       	breq	80002418 <LodePNG_convert+0x1fc>
800024f0:	30 07       	mov	r7,0
800024f2:	b4 b7       	st.b	r10[0x3],r7
800024f4:	72 17       	ld.w	r7,r9[0x4]
800024f6:	c9 1b       	rjmp	80002418 <LodePNG_convert+0x1fc>
 
 static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0;
   size_t i;
   for(i = nbits - 1; i < nbits; i--) result += (unsigned)readBitFromReversedStream(bitpointer, bitstream) << i;
800024f8:	30 07       	mov	r7,0
800024fa:	0e 95       	mov	r5,r7
800024fc:	c3 2b       	rjmp	80002360 <LodePNG_convert+0x144>
   else if(LodePNG_InfoColor_isGreyscaleType(infoOut) && infoOut->bitDepth == 8) /*conversion from greyscale to greyscale*/
   {
     if(!LodePNG_InfoColor_isGreyscaleType(infoIn)) return 62;
     if(infoIn->bitDepth == 8)
     {
       switch(infoIn->colorType)
800024fe:	58 41       	cp.w	r1,4
80002500:	cd b1       	brne	800024b6 <LodePNG_convert+0x29a>
             out[OUT_BYTES * i] = in[i];
             if(OUT_ALPHA && infoIn->key_defined && in[i] == infoIn->key_r) out[OUT_BYTES * i + 1] = 0;
           }
         break;
         case 4: /*greyscale with alpha*/
           for(i = 0; i < numpixels; i++)
80002502:	58 08       	cp.w	r8,0
80002504:	fe 90 fe f8 	breq	800022f4 <LodePNG_convert+0xd8>
     if(infoIn->bitDepth == 8)
     {
       switch(infoIn->colorType)
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
80002508:	58 02       	cp.w	r2,0
8000250a:	c0 e0       	breq	80002526 <LodePNG_convert+0x30a>
             out[OUT_BYTES * i] = in[i];
             if(OUT_ALPHA && infoIn->key_defined && in[i] == infoIn->key_r) out[OUT_BYTES * i + 1] = 0;
           }
         break;
         case 4: /*greyscale with alpha*/
           for(i = 0; i < numpixels; i++)
8000250c:	30 09       	mov	r9,0
           {
             out[OUT_BYTES * i + 0] = in[2 * i + 0];
8000250e:	17 8a       	ld.ub	r10,r11[0x0]
80002510:	b8 8a       	st.b	r12[0x0],r10
             if(OUT_ALPHA) out[OUT_BYTES * i + 1] = in[2 * i + 1];
80002512:	17 9a       	ld.ub	r10,r11[0x1]
80002514:	b8 9a       	st.b	r12[0x1],r10
             out[OUT_BYTES * i] = in[i];
             if(OUT_ALPHA && infoIn->key_defined && in[i] == infoIn->key_r) out[OUT_BYTES * i + 1] = 0;
           }
         break;
         case 4: /*greyscale with alpha*/
           for(i = 0; i < numpixels; i++)
80002516:	2f f9       	sub	r9,-1
80002518:	2f eb       	sub	r11,-2
8000251a:	06 0c       	add	r12,r3
8000251c:	12 38       	cp.w	r8,r9
8000251e:	fe 9b ff f8 	brhi	8000250e <LodePNG_convert+0x2f2>
       }
     }
     else /*infoIn->bitDepth is less than 8 bit per channel*/
     {
       if(infoIn->colorType != 0) return 31; /*colorType 0 is the only greyscale type with < 8 bits per channel*/
       for(i = 0; i < numpixels; i++)
80002522:	30 0c       	mov	r12,0
80002524:	ce 9a       	rjmp	800022f6 <LodePNG_convert+0xda>
           }
         break;
         case 4: /*greyscale with alpha*/
           for(i = 0; i < numpixels; i++)
           {
             out[OUT_BYTES * i + 0] = in[2 * i + 0];
80002526:	17 89       	ld.ub	r9,r11[0x0]
80002528:	b8 89       	st.b	r12[0x0],r9
             out[OUT_BYTES * i] = in[i];
             if(OUT_ALPHA && infoIn->key_defined && in[i] == infoIn->key_r) out[OUT_BYTES * i + 1] = 0;
           }
         break;
         case 4: /*greyscale with alpha*/
           for(i = 0; i < numpixels; i++)
8000252a:	2f f2       	sub	r2,-1
8000252c:	2f eb       	sub	r11,-2
8000252e:	06 0c       	add	r12,r3
80002530:	04 38       	cp.w	r8,r2
80002532:	fe 9b ff fa 	brhi	80002526 <LodePNG_convert+0x30a>
80002536:	cd fa       	rjmp	800022f4 <LodePNG_convert+0xd8>
         default: return 31;
       }
     }
     else if(infoIn->bitDepth == 16)
     {
       switch(infoIn->colorType)
80002538:	58 01       	cp.w	r1,0
8000253a:	e0 81 00 8b 	brne	80002650 <LodePNG_convert+0x434>
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
8000253e:	58 08       	cp.w	r8,0
80002540:	fe 90 fe da 	breq	800022f4 <LodePNG_convert+0xd8>
80002544:	58 02       	cp.w	r2,0
80002546:	c2 20       	breq	8000258a <LodePNG_convert+0x36e>
80002548:	2f fc       	sub	r12,-1
8000254a:	f6 ce ff ff 	sub	lr,r11,-1
8000254e:	30 1a       	mov	r10,1
           {
             if(OUT_ALPHA) out[OUT_BYTES * i + 1] = 255;
80002550:	3f f6       	mov	r6,-1
80002552:	c0 28       	rjmp	80002556 <LodePNG_convert+0x33a>
     else if(infoIn->bitDepth == 16)
     {
       switch(infoIn->colorType)
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
80002554:	0e 9a       	mov	r10,r7
           {
             if(OUT_ALPHA) out[OUT_BYTES * i + 1] = 255;
80002556:	b8 86       	st.b	r12[0x0],r6
             out[OUT_BYTES * i] = in[2 * i];
80002558:	17 87       	ld.ub	r7,r11[0x0]
8000255a:	f9 67 ff ff 	st.b	r12[-1],r7
             if(OUT_ALPHA && infoIn->key_defined && 256U * in[i] + in[i + 1] == infoIn->key_r) out[OUT_BYTES * i + 1] = 0;
8000255e:	2f eb       	sub	r11,-2
80002560:	72 47       	ld.w	r7,r9[0x10]
80002562:	58 07       	cp.w	r7,0
80002564:	c0 a0       	breq	80002578 <LodePNG_convert+0x35c>
80002566:	1d 87       	ld.ub	r7,lr[0x0]
80002568:	fd 35 ff ff 	ld.ub	r5,lr[-1]
8000256c:	a9 65       	lsl	r5,0x8
8000256e:	0e 05       	add	r5,r7
80002570:	72 57       	ld.w	r7,r9[0x14]
80002572:	0e 35       	cp.w	r5,r7
80002574:	f9 f1 0e 00 	st.beq	r12[0x0],r1
80002578:	06 0c       	add	r12,r3
8000257a:	2f fe       	sub	lr,-1
8000257c:	f4 c7 ff ff 	sub	r7,r10,-1
     else if(infoIn->bitDepth == 16)
     {
       switch(infoIn->colorType)
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
80002580:	14 38       	cp.w	r8,r10
80002582:	fe 9b ff e9 	brhi	80002554 <LodePNG_convert+0x338>
       }
     }
     else /*infoIn->bitDepth is less than 8 bit per channel*/
     {
       if(infoIn->colorType != 0) return 31; /*colorType 0 is the only greyscale type with < 8 bits per channel*/
       for(i = 0; i < numpixels; i++)
80002586:	30 0c       	mov	r12,0
80002588:	cb 7a       	rjmp	800022f6 <LodePNG_convert+0xda>
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
           {
             if(OUT_ALPHA) out[OUT_BYTES * i + 1] = 255;
             out[OUT_BYTES * i] = in[2 * i];
8000258a:	17 89       	ld.ub	r9,r11[0x0]
8000258c:	b8 89       	st.b	r12[0x0],r9
8000258e:	2f f2       	sub	r2,-1
80002590:	2f eb       	sub	r11,-2
80002592:	06 0c       	add	r12,r3
     else if(infoIn->bitDepth == 16)
     {
       switch(infoIn->colorType)
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
80002594:	04 38       	cp.w	r8,r2
80002596:	fe 9b ff fa 	brhi	8000258a <LodePNG_convert+0x36e>
8000259a:	ca da       	rjmp	800022f4 <LodePNG_convert+0xd8>
         default: break;
       }
     }
     else /*infoIn->bitDepth is less than 8 bit per channel*/
     {
       switch(infoIn->colorType)
8000259c:	58 31       	cp.w	r1,3
8000259e:	fe 91 fe ab 	brne	800022f4 <LodePNG_convert+0xd8>
             value = (value * 255) / ((1 << infoIn->bitDepth) - 1); /*scale value from 0 to 255*/
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = (unsigned char)(value);
           }
         break;
         case 3: /*indexed color (palette)*/
           for(i = 0; i < numpixels; i++)
800025a2:	58 08       	cp.w	r8,0
800025a4:	fe 90 fe a8 	breq	800022f4 <LodePNG_convert+0xd8>
     else /*infoIn->bitDepth is less than 8 bit per channel*/
     {
       switch(infoIn->colorType)
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
800025a8:	30 0e       	mov	lr,0
         break;
         case 3: /*indexed color (palette)*/
           for(i = 0; i < numpixels; i++)
           {
             unsigned value = readBitsFromReversedStream(&bp, in, infoIn->bitDepth);
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = 255;
800025aa:	3f f1       	mov	r1,-1
     else /*infoIn->bitDepth is less than 8 bit per channel*/
     {
       switch(infoIn->colorType)
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
800025ac:	1c 94       	mov	r4,lr
 
 static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0;
   size_t i;
   for(i = nbits - 1; i < nbits; i--) result += (unsigned)readBitFromReversedStream(bitpointer, bitstream) << i;
800025ae:	ee ca 00 01 	sub	r10,r7,1
800025b2:	0e 3a       	cp.w	r10,r7
800025b4:	e0 82 00 8c 	brhs	800026cc <LodePNG_convert+0x4b0>
800025b8:	30 06       	mov	r6,0
 /* / Reading and writing single bits and bytes from/to stream for LodePNG   / */
 /* ////////////////////////////////////////////////////////////////////////// */
 
 static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
800025ba:	fc 05 16 03 	lsr	r5,lr,0x3
800025be:	f6 05 07 00 	ld.ub	r0,r11[r5]
800025c2:	fc 05 11 ff 	rsub	r5,lr,-1
   (*bitpointer)++;
800025c6:	2f fe       	sub	lr,-1
 /* / Reading and writing single bits and bytes from/to stream for LodePNG   / */
 /* ////////////////////////////////////////////////////////////////////////// */
 
 static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
800025c8:	eb d5 c0 03 	bfextu	r5,r5,0x0,0x3
800025cc:	e0 05 08 45 	asr	r5,r0,r5
800025d0:	eb d5 c0 01 	bfextu	r5,r5,0x0,0x1
 
 static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0;
   size_t i;
   for(i = nbits - 1; i < nbits; i--) result += (unsigned)readBitFromReversedStream(bitpointer, bitstream) << i;
800025d4:	ea 0a 09 45 	lsl	r5,r5,r10
800025d8:	20 1a       	sub	r10,1
800025da:	0a 06       	add	r6,r5
800025dc:	0e 3a       	cp.w	r10,r7
800025de:	ce e3       	brcs	800025ba <LodePNG_convert+0x39e>
         break;
         case 3: /*indexed color (palette)*/
           for(i = 0; i < numpixels; i++)
           {
             unsigned value = readBitsFromReversedStream(&bp, in, infoIn->bitDepth);
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = 255;
800025e0:	58 02       	cp.w	r2,0
800025e2:	f9 f1 1e 03 	st.bne	r12[0x3],r1
             if(value >= infoIn->palettesize) return 47;
800025e6:	72 3a       	ld.w	r10,r9[0xc]
800025e8:	14 36       	cp.w	r6,r10
800025ea:	e0 82 00 d9 	brhs	8000279c <LodePNG_convert+0x580>
             for(c = 0; c < OUT_BYTES; c++) out[OUT_BYTES * i + c] = infoIn->palette[4 * value + c]; /*get rgb colors from the palette*/
800025ee:	58 03       	cp.w	r3,0
800025f0:	c0 c0       	breq	80002608 <LodePNG_convert+0x3ec>
800025f2:	a3 66       	lsl	r6,0x2
800025f4:	18 97       	mov	r7,r12
800025f6:	30 0a       	mov	r10,0
800025f8:	72 25       	ld.w	r5,r9[0x8]
800025fa:	14 05       	add	r5,r10
800025fc:	ea 06 07 05 	ld.ub	r5,r5[r6]
80002600:	0e c5       	st.b	r7++,r5
80002602:	2f fa       	sub	r10,-1
80002604:	06 3a       	cp.w	r10,r3
80002606:	cf 93       	brcs	800025f8 <LodePNG_convert+0x3dc>
             value = (value * 255) / ((1 << infoIn->bitDepth) - 1); /*scale value from 0 to 255*/
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = (unsigned char)(value);
           }
         break;
         case 3: /*indexed color (palette)*/
           for(i = 0; i < numpixels; i++)
80002608:	2f f4       	sub	r4,-1
8000260a:	06 0c       	add	r12,r3
8000260c:	08 38       	cp.w	r8,r4
8000260e:	fe 98 fe 73 	brls	800022f4 <LodePNG_convert+0xd8>
80002612:	72 17       	ld.w	r7,r9[0x4]
80002614:	cc db       	rjmp	800025ae <LodePNG_convert+0x392>
 
   if((infoOut->colorType == 2 || infoOut->colorType == 6) && infoOut->bitDepth == 8)
   {
     if(infoIn->bitDepth == 8)
     {
       switch(infoIn->colorType)
80002616:	58 31       	cp.w	r1,3
80002618:	e0 80 01 45 	breq	800028a2 <LodePNG_convert+0x686>
8000261c:	e0 8b 00 5d 	brhi	800026d6 <LodePNG_convert+0x4ba>
80002620:	58 01       	cp.w	r1,0
80002622:	e0 81 00 de 	brne	800027de <LodePNG_convert+0x5c2>
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
80002626:	58 08       	cp.w	r8,0
80002628:	fe 90 fe 66 	breq	800022f4 <LodePNG_convert+0xd8>
8000262c:	58 02       	cp.w	r2,0
8000262e:	e0 81 01 f7 	brne	80002a1c <LodePNG_convert+0x800>
80002632:	2f ec       	sub	r12,-2
           {
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = 255;
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = in[i];
80002634:	f6 01 07 09 	ld.ub	r9,r11[r1]
80002638:	f9 69 ff fe 	st.b	r12[-2],r9
8000263c:	b8 89       	st.b	r12[0x0],r9
8000263e:	f9 69 ff ff 	st.b	r12[-1],r9
     if(infoIn->bitDepth == 8)
     {
       switch(infoIn->colorType)
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
80002642:	2f f1       	sub	r1,-1
80002644:	06 0c       	add	r12,r3
80002646:	02 38       	cp.w	r8,r1
80002648:	fe 9b ff f6 	brhi	80002634 <LodePNG_convert+0x418>
       }
     }
     else /*infoIn->bitDepth is less than 8 bit per channel*/
     {
       if(infoIn->colorType != 0) return 31; /*colorType 0 is the only greyscale type with < 8 bits per channel*/
       for(i = 0; i < numpixels; i++)
8000264c:	30 0c       	mov	r12,0
8000264e:	c5 4a       	rjmp	800022f6 <LodePNG_convert+0xda>
         default: return 31;
       }
     }
     else if(infoIn->bitDepth == 16)
     {
       switch(infoIn->colorType)
80002650:	58 41       	cp.w	r1,4
80002652:	fe 91 ff 32 	brne	800024b6 <LodePNG_convert+0x29a>
             out[OUT_BYTES * i] = in[2 * i];
             if(OUT_ALPHA && infoIn->key_defined && 256U * in[i] + in[i + 1] == infoIn->key_r) out[OUT_BYTES * i + 1] = 0;
           }
         break;
         case 4: /*greyscale with alpha*/
           for(i = 0; i < numpixels; i++)
80002656:	58 08       	cp.w	r8,0
80002658:	fe 90 fe 4e 	breq	800022f4 <LodePNG_convert+0xd8>
     else if(infoIn->bitDepth == 16)
     {
       switch(infoIn->colorType)
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
8000265c:	58 02       	cp.w	r2,0
8000265e:	c0 f0       	breq	8000267c <LodePNG_convert+0x460>
             out[OUT_BYTES * i] = in[2 * i];
             if(OUT_ALPHA && infoIn->key_defined && 256U * in[i] + in[i + 1] == infoIn->key_r) out[OUT_BYTES * i + 1] = 0;
           }
         break;
         case 4: /*greyscale with alpha*/
           for(i = 0; i < numpixels; i++)
80002660:	30 09       	mov	r9,0
           {
             out[OUT_BYTES * i] = in[4 * i]; /*most significant byte*/
80002662:	17 8a       	ld.ub	r10,r11[0x0]
80002664:	b8 8a       	st.b	r12[0x0],r10
             if(OUT_ALPHA) out[OUT_BYTES * i + 1] = in[4 * i + 2]; /*most significant byte*/
80002666:	17 aa       	ld.ub	r10,r11[0x2]
80002668:	b8 9a       	st.b	r12[0x1],r10
             out[OUT_BYTES * i] = in[2 * i];
             if(OUT_ALPHA && infoIn->key_defined && 256U * in[i] + in[i + 1] == infoIn->key_r) out[OUT_BYTES * i + 1] = 0;
           }
         break;
         case 4: /*greyscale with alpha*/
           for(i = 0; i < numpixels; i++)
8000266a:	2f f9       	sub	r9,-1
8000266c:	2f cb       	sub	r11,-4
8000266e:	06 0c       	add	r12,r3
80002670:	12 38       	cp.w	r8,r9
80002672:	fe 9b ff f8 	brhi	80002662 <LodePNG_convert+0x446>
       }
     }
     else /*infoIn->bitDepth is less than 8 bit per channel*/
     {
       if(infoIn->colorType != 0) return 31; /*colorType 0 is the only greyscale type with < 8 bits per channel*/
       for(i = 0; i < numpixels; i++)
80002676:	30 0c       	mov	r12,0
80002678:	fe 9f fe 3f 	bral	800022f6 <LodePNG_convert+0xda>
           }
         break;
         case 4: /*greyscale with alpha*/
           for(i = 0; i < numpixels; i++)
           {
             out[OUT_BYTES * i] = in[4 * i]; /*most significant byte*/
8000267c:	17 89       	ld.ub	r9,r11[0x0]
8000267e:	b8 89       	st.b	r12[0x0],r9
             out[OUT_BYTES * i] = in[2 * i];
             if(OUT_ALPHA && infoIn->key_defined && 256U * in[i] + in[i + 1] == infoIn->key_r) out[OUT_BYTES * i + 1] = 0;
           }
         break;
         case 4: /*greyscale with alpha*/
           for(i = 0; i < numpixels; i++)
80002680:	2f f2       	sub	r2,-1
80002682:	2f cb       	sub	r11,-4
80002684:	06 0c       	add	r12,r3
80002686:	04 38       	cp.w	r8,r2
80002688:	fe 9b ff fa 	brhi	8000267c <LodePNG_convert+0x460>
8000268c:	fe 9f fe 34 	bral	800022f4 <LodePNG_convert+0xd8>
         default: break;
       }
     }
     else if(infoIn->bitDepth == 16)
     {
       switch(infoIn->colorType)
80002690:	58 21       	cp.w	r1,2
80002692:	e0 80 01 43 	breq	80002918 <LodePNG_convert+0x6fc>
80002696:	e0 8b 00 86 	brhi	800027a2 <LodePNG_convert+0x586>
8000269a:	58 01       	cp.w	r1,0
8000269c:	fe 91 fe 2c 	brne	800022f4 <LodePNG_convert+0xd8>
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
800026a0:	58 08       	cp.w	r8,0
800026a2:	fe 90 fe 29 	breq	800022f4 <LodePNG_convert+0xd8>
800026a6:	58 02       	cp.w	r2,0
800026a8:	e0 81 01 93 	brne	800029ce <LodePNG_convert+0x7b2>
800026ac:	2f ec       	sub	r12,-2
           {
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = 255;
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = in[2 * i];
800026ae:	17 89       	ld.ub	r9,r11[0x0]
800026b0:	f9 69 ff fe 	st.b	r12[-2],r9
800026b4:	b8 89       	st.b	r12[0x0],r9
800026b6:	f9 69 ff ff 	st.b	r12[-1],r9
800026ba:	2f f1       	sub	r1,-1
800026bc:	2f eb       	sub	r11,-2
800026be:	06 0c       	add	r12,r3
     else if(infoIn->bitDepth == 16)
     {
       switch(infoIn->colorType)
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
800026c0:	02 38       	cp.w	r8,r1
800026c2:	fe 9b ff f6 	brhi	800026ae <LodePNG_convert+0x492>
       }
     }
     else /*infoIn->bitDepth is less than 8 bit per channel*/
     {
       if(infoIn->colorType != 0) return 31; /*colorType 0 is the only greyscale type with < 8 bits per channel*/
       for(i = 0; i < numpixels; i++)
800026c6:	30 0c       	mov	r12,0
800026c8:	fe 9f fe 17 	bral	800022f6 <LodePNG_convert+0xda>
 
 static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0;
   size_t i;
   for(i = nbits - 1; i < nbits; i--) result += (unsigned)readBitFromReversedStream(bitpointer, bitstream) << i;
800026cc:	30 06       	mov	r6,0
800026ce:	c8 9b       	rjmp	800025e0 <LodePNG_convert+0x3c4>
800026d0:	30 06       	mov	r6,0
800026d2:	0c 95       	mov	r5,r6
800026d4:	c9 ea       	rjmp	80002410 <LodePNG_convert+0x1f4>
 
   if((infoOut->colorType == 2 || infoOut->colorType == 6) && infoOut->bitDepth == 8)
   {
     if(infoIn->bitDepth == 8)
     {
       switch(infoIn->colorType)
800026d6:	58 41       	cp.w	r1,4
800026d8:	e0 80 00 cf 	breq	80002876 <LodePNG_convert+0x65a>
800026dc:	58 61       	cp.w	r1,6
800026de:	fe 91 fe 0b 	brne	800022f4 <LodePNG_convert+0xd8>
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = in[2 * i + 0];
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = in[2 * i + 1];
           }
         break;
         case 6: /*RGB with alpha*/
           for(i = 0; i < numpixels; i++)
800026e2:	58 08       	cp.w	r8,0
800026e4:	fe 90 fe 08 	breq	800022f4 <LodePNG_convert+0xd8>
800026e8:	30 01       	mov	r1,0
           {
             for(c = 0; c < OUT_BYTES; c++) out[OUT_BYTES * i + c] = in[4 * i + c];
800026ea:	e6 04 16 02 	lsr	r4,r3,0x2
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = in[2 * i + 0];
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = in[2 * i + 1];
           }
         break;
         case 6: /*RGB with alpha*/
           for(i = 0; i < numpixels; i++)
800026ee:	16 95       	mov	r5,r11
           {
             for(c = 0; c < OUT_BYTES; c++) out[OUT_BYTES * i + c] = in[4 * i + c];
800026f0:	e8 0a 15 02 	lsl	r10,r4,0x2
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = in[2 * i + 0];
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = in[2 * i + 1];
           }
         break;
         case 6: /*RGB with alpha*/
           for(i = 0; i < numpixels; i++)
800026f4:	18 96       	mov	r6,r12
800026f6:	02 92       	mov	r2,r1
           {
             for(c = 0; c < OUT_BYTES; c++) out[OUT_BYTES * i + c] = in[4 * i + c];
800026f8:	50 0a       	stdsp	sp[0x0],r10
800026fa:	58 03       	cp.w	r3,0
800026fc:	e0 80 01 66 	breq	800029c8 <LodePNG_convert+0x7ac>
80002700:	58 33       	cp.w	r3,3
80002702:	5f ba       	srhi	r10
80002704:	eb e6 10 09 	or	r9,r5,r6
80002708:	f3 d9 c0 02 	bfextu	r9,r9,0x0,0x2
8000270c:	5f 09       	sreq	r9
8000270e:	12 6a       	and	r10,r9
80002710:	ea c0 ff fc 	sub	r0,r5,-4
80002714:	ec c9 ff fc 	sub	r9,r6,-4
80002718:	00 36       	cp.w	r6,r0
8000271a:	5f be       	srhi	lr
8000271c:	12 35       	cp.w	r5,r9
8000271e:	5f b9       	srhi	r9
80002720:	fd e9 10 09 	or	r9,lr,r9
80002724:	f5 e9 00 09 	and	r9,r10,r9
80002728:	e4 0a 15 02 	lsl	r10,r2,0x2
8000272c:	50 1a       	stdsp	sp[0x4],r10
8000272e:	30 07       	mov	r7,0
80002730:	ee 09 18 00 	cp.b	r9,r7
80002734:	c2 b0       	breq	8000278a <LodePNG_convert+0x56e>
80002736:	40 0a       	lddsp	r10,sp[0x0]
80002738:	58 0a       	cp.w	r10,0
8000273a:	c0 f0       	breq	80002758 <LodePNG_convert+0x53c>
8000273c:	30 09       	mov	r9,0
8000273e:	12 9e       	mov	lr,r9
80002740:	ea 09 03 07 	ld.w	r7,r5[r9]
80002744:	ec 09 09 07 	st.w	r6[r9],r7
80002748:	2f fe       	sub	lr,-1
8000274a:	2f c9       	sub	r9,-4
8000274c:	1c 34       	cp.w	r4,lr
8000274e:	fe 9b ff f9 	brhi	80002740 <LodePNG_convert+0x524>
80002752:	40 09       	lddsp	r9,sp[0x0]
80002754:	12 33       	cp.w	r3,r9
80002756:	c1 00       	breq	80002776 <LodePNG_convert+0x55a>
80002758:	40 07       	lddsp	r7,sp[0x0]
8000275a:	40 1e       	lddsp	lr,sp[0x4]
8000275c:	e2 07 00 09 	add	r9,r1,r7
80002760:	0e 0e       	add	lr,r7
80002762:	f8 09 00 09 	add	r9,r12,r9
80002766:	f6 0e 00 0e 	add	lr,r11,lr
8000276a:	1d 37       	ld.ub	r7,lr++
8000276c:	12 c7       	st.b	r9++,r7
8000276e:	2f fa       	sub	r10,-1
80002770:	14 33       	cp.w	r3,r10
80002772:	fe 9b ff fc 	brhi	8000276a <LodePNG_convert+0x54e>
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = in[2 * i + 0];
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = in[2 * i + 1];
           }
         break;
         case 6: /*RGB with alpha*/
           for(i = 0; i < numpixels; i++)
80002776:	2f f2       	sub	r2,-1
80002778:	00 95       	mov	r5,r0
8000277a:	06 06       	add	r6,r3
8000277c:	06 01       	add	r1,r3
8000277e:	04 38       	cp.w	r8,r2
80002780:	fe 9b ff bd 	brhi	800026fa <LodePNG_convert+0x4de>
       }
     }
     else /*infoIn->bitDepth is less than 8 bit per channel*/
     {
       if(infoIn->colorType != 0) return 31; /*colorType 0 is the only greyscale type with < 8 bits per channel*/
       for(i = 0; i < numpixels; i++)
80002784:	30 0c       	mov	r12,0
80002786:	fe 9f fd b8 	bral	800022f6 <LodePNG_convert+0xda>
             if(in[i] >= infoIn->palettesize) return 46;
             for(c = 0; c < OUT_BYTES; c++) out[OUT_BYTES * i + c] = infoIn->palette[4 * in[i] + c]; /*get rgb colors from the palette*/
           }
         break;
         case 4: /*greyscale with alpha*/
           for(i = 0; i < numpixels; i++)
8000278a:	0c 9a       	mov	r10,r6
8000278c:	30 09       	mov	r9,0
           }
         break;
         case 6: /*RGB with alpha*/
           for(i = 0; i < numpixels; i++)
           {
             for(c = 0; c < OUT_BYTES; c++) out[OUT_BYTES * i + c] = in[4 * i + c];
8000278e:	0b 3e       	ld.ub	lr,r5++
80002790:	14 ce       	st.b	r10++,lr
80002792:	2f f9       	sub	r9,-1
80002794:	12 33       	cp.w	r3,r9
80002796:	fe 9b ff fc 	brhi	8000278e <LodePNG_convert+0x572>
8000279a:	ce eb       	rjmp	80002776 <LodePNG_convert+0x55a>
         case 3: /*indexed color (palette)*/
           for(i = 0; i < numpixels; i++)
           {
             unsigned value = readBitsFromReversedStream(&bp, in, infoIn->bitDepth);
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = 255;
             if(value >= infoIn->palettesize) return 47;
8000279c:	32 fc       	mov	r12,47
8000279e:	fe 9f fd 60 	bral	8000225e <LodePNG_convert+0x42>
         default: break;
       }
     }
     else if(infoIn->bitDepth == 16)
     {
       switch(infoIn->colorType)
800027a2:	58 41       	cp.w	r1,4
800027a4:	e0 80 00 a4 	breq	800028ec <LodePNG_convert+0x6d0>
800027a8:	58 61       	cp.w	r1,6
800027aa:	fe 91 fd a5 	brne	800022f4 <LodePNG_convert+0xd8>
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = in[4 * i]; /*most significant byte*/
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = in[4 * i + 2];
           }
         break;
         case 6: /*RGB with alpha*/
           for(i = 0; i < numpixels; i++)
800027ae:	58 08       	cp.w	r8,0
800027b0:	fe 90 fd a2 	breq	800022f4 <LodePNG_convert+0xd8>
800027b4:	30 06       	mov	r6,0
           {
             for(c = 0; c < OUT_BYTES; c++) out[OUT_BYTES * i + c] = in[8 * i + 2 * c];
800027b6:	58 03       	cp.w	r3,0
800027b8:	c0 a0       	breq	800027cc <LodePNG_convert+0x5b0>
             for(c = 0; c < 3; c++) out[OUT_BYTES * i + c] = in[6 * i + 2 * c];
             if(OUT_ALPHA && infoIn->key_defined && 256U * in[6 * i + 0] + in[6 * i + 1] == infoIn->key_r && 256U * in[6 * i + 2] + in[6 * i + 3] == infoIn->key_g && 256U * in[6 * i + 4] + in[6 * i + 5] == infoIn->key_b) out[OUT_BYTES * i + 3] = 0;
           }
         break;
         case 4: /*greyscale with alpha*/
           for(i = 0; i < numpixels; i++)
800027ba:	18 9e       	mov	lr,r12
800027bc:	16 9a       	mov	r10,r11
800027be:	30 09       	mov	r9,0
           }
         break;
         case 6: /*RGB with alpha*/
           for(i = 0; i < numpixels; i++)
           {
             for(c = 0; c < OUT_BYTES; c++) out[OUT_BYTES * i + c] = in[8 * i + 2 * c];
800027c0:	15 87       	ld.ub	r7,r10[0x0]
800027c2:	1c c7       	st.b	lr++,r7
800027c4:	2f f9       	sub	r9,-1
800027c6:	2f ea       	sub	r10,-2
800027c8:	06 39       	cp.w	r9,r3
800027ca:	cf b3       	brcs	800027c0 <LodePNG_convert+0x5a4>
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = in[4 * i]; /*most significant byte*/
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = in[4 * i + 2];
           }
         break;
         case 6: /*RGB with alpha*/
           for(i = 0; i < numpixels; i++)
800027cc:	2f f6       	sub	r6,-1
800027ce:	2f 8b       	sub	r11,-8
800027d0:	06 0c       	add	r12,r3
800027d2:	0c 38       	cp.w	r8,r6
800027d4:	fe 9b ff f1 	brhi	800027b6 <LodePNG_convert+0x59a>
       }
     }
     else /*infoIn->bitDepth is less than 8 bit per channel*/
     {
       if(infoIn->colorType != 0) return 31; /*colorType 0 is the only greyscale type with < 8 bits per channel*/
       for(i = 0; i < numpixels; i++)
800027d8:	30 0c       	mov	r12,0
800027da:	fe 9f fd 8e 	bral	800022f6 <LodePNG_convert+0xda>
 
   if((infoOut->colorType == 2 || infoOut->colorType == 6) && infoOut->bitDepth == 8)
   {
     if(infoIn->bitDepth == 8)
     {
       switch(infoIn->colorType)
800027de:	58 21       	cp.w	r1,2
800027e0:	fe 91 fd 8a 	brne	800022f4 <LodePNG_convert+0xd8>
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = in[i];
             if(OUT_ALPHA && infoIn->key_defined && in[i] == infoIn->key_r) out[OUT_BYTES * i + 3] = 0;
           }
         break;
         case 2: /*RGB color*/
           for(i = 0; i < numpixels; i++)
800027e4:	58 08       	cp.w	r8,0
800027e6:	fe 90 fd 87 	breq	800022f4 <LodePNG_convert+0xd8>
     if(infoIn->bitDepth == 8)
     {
       switch(infoIn->colorType)
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
800027ea:	30 0a       	mov	r10,0
800027ec:	f6 c7 ff ff 	sub	r7,r11,-1
800027f0:	f6 ce ff fe 	sub	lr,r11,-2
800027f4:	f8 c5 ff fd 	sub	r5,r12,-3
800027f8:	14 96       	mov	r6,r10
           }
         break;
         case 2: /*RGB color*/
           for(i = 0; i < numpixels; i++)
           {
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = 255;
800027fa:	3f f0       	mov	r0,-1
             for(c = 0; c < 3; c++) out[OUT_BYTES * i + c] = in[3 * i + c];
             if(OUT_ALPHA && infoIn->key_defined == 1 && in[3 * i + 0] == infoIn->key_r && in[3 * i + 1] == infoIn->key_g && in[3 * i + 2] == infoIn->key_b) out[OUT_BYTES * i + 3] = 0;
800027fc:	14 91       	mov	r1,r10
800027fe:	58 02       	cp.w	r2,0
80002800:	c2 80       	breq	80002850 <LodePNG_convert+0x634>
80002802:	50 18       	stdsp	sp[0x4],r8
80002804:	c0 88       	rjmp	80002814 <LodePNG_convert+0x5f8>
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = in[i];
             if(OUT_ALPHA && infoIn->key_defined && in[i] == infoIn->key_r) out[OUT_BYTES * i + 3] = 0;
           }
         break;
         case 2: /*RGB color*/
           for(i = 0; i < numpixels; i++)
80002806:	2f db       	sub	r11,-3
80002808:	2f d7       	sub	r7,-3
8000280a:	2f de       	sub	lr,-3
8000280c:	40 14       	lddsp	r4,sp[0x4]
8000280e:	0c 34       	cp.w	r4,r6
80002810:	fe 98 fd 72 	brls	800022f4 <LodePNG_convert+0xd8>
           {
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = 255;
80002814:	aa 80       	st.b	r5[0x0],r0
             for(c = 0; c < 3; c++) out[OUT_BYTES * i + c] = in[3 * i + c];
80002816:	17 84       	ld.ub	r4,r11[0x0]
80002818:	f8 0a 0b 04 	st.b	r12[r10],r4
8000281c:	0f 82       	ld.ub	r2,r7[0x0]
8000281e:	f8 0a 00 04 	add	r4,r12,r10
80002822:	a8 92       	st.b	r4[0x1],r2
80002824:	1d 82       	ld.ub	r2,lr[0x0]
80002826:	a8 a2       	st.b	r4[0x2],r2
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = in[i];
             if(OUT_ALPHA && infoIn->key_defined && in[i] == infoIn->key_r) out[OUT_BYTES * i + 3] = 0;
           }
         break;
         case 2: /*RGB color*/
           for(i = 0; i < numpixels; i++)
80002828:	2f f6       	sub	r6,-1
8000282a:	06 0a       	add	r10,r3
8000282c:	06 05       	add	r5,r3
           {
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = 255;
             for(c = 0; c < 3; c++) out[OUT_BYTES * i + c] = in[3 * i + c];
             if(OUT_ALPHA && infoIn->key_defined == 1 && in[3 * i + 0] == infoIn->key_r && in[3 * i + 1] == infoIn->key_g && in[3 * i + 2] == infoIn->key_b) out[OUT_BYTES * i + 3] = 0;
8000282e:	72 42       	ld.w	r2,r9[0x10]
80002830:	58 12       	cp.w	r2,1
80002832:	ce a1       	brne	80002806 <LodePNG_convert+0x5ea>
80002834:	17 82       	ld.ub	r2,r11[0x0]
80002836:	72 58       	ld.w	r8,r9[0x14]
80002838:	10 32       	cp.w	r2,r8
8000283a:	ce 61       	brne	80002806 <LodePNG_convert+0x5ea>
8000283c:	0f 82       	ld.ub	r2,r7[0x0]
8000283e:	72 68       	ld.w	r8,r9[0x18]
80002840:	10 32       	cp.w	r2,r8
80002842:	ce 21       	brne	80002806 <LodePNG_convert+0x5ea>
80002844:	1d 82       	ld.ub	r2,lr[0x0]
80002846:	72 78       	ld.w	r8,r9[0x1c]
80002848:	10 32       	cp.w	r2,r8
8000284a:	e9 f1 0e 03 	st.beq	r4[0x3],r1
8000284e:	cd cb       	rjmp	80002806 <LodePNG_convert+0x5ea>
         break;
         case 2: /*RGB color*/
           for(i = 0; i < numpixels; i++)
           {
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = 255;
             for(c = 0; c < 3; c++) out[OUT_BYTES * i + c] = in[3 * i + c];
80002850:	17 89       	ld.ub	r9,r11[0x0]
80002852:	f8 0a 0b 09 	st.b	r12[r10],r9
80002856:	0f 85       	ld.ub	r5,r7[0x0]
80002858:	f8 0a 00 09 	add	r9,r12,r10
8000285c:	b2 95       	st.b	r9[0x1],r5
8000285e:	1d 85       	ld.ub	r5,lr[0x0]
80002860:	b2 a5       	st.b	r9[0x2],r5
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = in[i];
             if(OUT_ALPHA && infoIn->key_defined && in[i] == infoIn->key_r) out[OUT_BYTES * i + 3] = 0;
           }
         break;
         case 2: /*RGB color*/
           for(i = 0; i < numpixels; i++)
80002862:	2f f6       	sub	r6,-1
80002864:	06 0a       	add	r10,r3
80002866:	2f db       	sub	r11,-3
80002868:	2f d7       	sub	r7,-3
8000286a:	2f de       	sub	lr,-3
8000286c:	0c 38       	cp.w	r8,r6
8000286e:	fe 9b ff f1 	brhi	80002850 <LodePNG_convert+0x634>
80002872:	fe 9f fd 41 	bral	800022f4 <LodePNG_convert+0xd8>
             if(in[i] >= infoIn->palettesize) return 46;
             for(c = 0; c < OUT_BYTES; c++) out[OUT_BYTES * i + c] = infoIn->palette[4 * in[i] + c]; /*get rgb colors from the palette*/
           }
         break;
         case 4: /*greyscale with alpha*/
           for(i = 0; i < numpixels; i++)
80002876:	58 08       	cp.w	r8,0
80002878:	fe 90 fd 3e 	breq	800022f4 <LodePNG_convert+0xd8>
             for(c = 0; c < 3; c++) out[OUT_BYTES * i + c] = in[3 * i + c];
             if(OUT_ALPHA && infoIn->key_defined == 1 && in[3 * i + 0] == infoIn->key_r && in[3 * i + 1] == infoIn->key_g && in[3 * i + 2] == infoIn->key_b) out[OUT_BYTES * i + 3] = 0;
           }
         break;
         case 3: /*indexed color (palette)*/
           for(i = 0; i < numpixels; i++)
8000287c:	58 02       	cp.w	r2,0
8000287e:	e0 81 00 eb 	brne	80002a54 <LodePNG_convert+0x838>
80002882:	2f ec       	sub	r12,-2
           }
         break;
         case 4: /*greyscale with alpha*/
           for(i = 0; i < numpixels; i++)
           {
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = in[2 * i + 0];
80002884:	17 89       	ld.ub	r9,r11[0x0]
80002886:	f9 69 ff fe 	st.b	r12[-2],r9
8000288a:	b8 89       	st.b	r12[0x0],r9
8000288c:	f9 69 ff ff 	st.b	r12[-1],r9
             if(in[i] >= infoIn->palettesize) return 46;
             for(c = 0; c < OUT_BYTES; c++) out[OUT_BYTES * i + c] = infoIn->palette[4 * in[i] + c]; /*get rgb colors from the palette*/
           }
         break;
         case 4: /*greyscale with alpha*/
           for(i = 0; i < numpixels; i++)
80002890:	2f f2       	sub	r2,-1
80002892:	2f eb       	sub	r11,-2
80002894:	06 0c       	add	r12,r3
80002896:	04 38       	cp.w	r8,r2
80002898:	fe 9b ff f6 	brhi	80002884 <LodePNG_convert+0x668>
       }
     }
     else /*infoIn->bitDepth is less than 8 bit per channel*/
     {
       if(infoIn->colorType != 0) return 31; /*colorType 0 is the only greyscale type with < 8 bits per channel*/
       for(i = 0; i < numpixels; i++)
8000289c:	30 0c       	mov	r12,0
8000289e:	fe 9f fd 2c 	bral	800022f6 <LodePNG_convert+0xda>
             for(c = 0; c < 3; c++) out[OUT_BYTES * i + c] = in[3 * i + c];
             if(OUT_ALPHA && infoIn->key_defined == 1 && in[3 * i + 0] == infoIn->key_r && in[3 * i + 1] == infoIn->key_g && in[3 * i + 2] == infoIn->key_b) out[OUT_BYTES * i + 3] = 0;
           }
         break;
         case 3: /*indexed color (palette)*/
           for(i = 0; i < numpixels; i++)
800028a2:	58 08       	cp.w	r8,0
800028a4:	fe 90 fd 28 	breq	800022f4 <LodePNG_convert+0xd8>
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = in[i];
             if(OUT_ALPHA && infoIn->key_defined && in[i] == infoIn->key_r) out[OUT_BYTES * i + 3] = 0;
           }
         break;
         case 2: /*RGB color*/
           for(i = 0; i < numpixels; i++)
800028a8:	30 05       	mov	r5,0
           }
         break;
         case 3: /*indexed color (palette)*/
           for(i = 0; i < numpixels; i++)
           {
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = 255;
800028aa:	3f f4       	mov	r4,-1
800028ac:	58 02       	cp.w	r2,0
800028ae:	f9 f4 1e 03 	st.bne	r12[0x3],r4
             if(in[i] >= infoIn->palettesize) return 46;
800028b2:	17 87       	ld.ub	r7,r11[0x0]
800028b4:	72 3a       	ld.w	r10,r9[0xc]
800028b6:	14 37       	cp.w	r7,r10
800028b8:	e0 82 00 e1 	brhs	80002a7a <LodePNG_convert+0x85e>
             for(c = 0; c < OUT_BYTES; c++) out[OUT_BYTES * i + c] = infoIn->palette[4 * in[i] + c]; /*get rgb colors from the palette*/
800028bc:	58 03       	cp.w	r3,0
800028be:	c0 e0       	breq	800028da <LodePNG_convert+0x6be>
800028c0:	18 9e       	mov	lr,r12
800028c2:	30 0a       	mov	r10,0
800028c4:	c0 28       	rjmp	800028c8 <LodePNG_convert+0x6ac>
800028c6:	17 87       	ld.ub	r7,r11[0x0]
800028c8:	f4 07 00 27 	add	r7,r10,r7<<0x2
800028cc:	72 26       	ld.w	r6,r9[0x8]
800028ce:	ec 07 07 07 	ld.ub	r7,r6[r7]
800028d2:	1c c7       	st.b	lr++,r7
800028d4:	2f fa       	sub	r10,-1
800028d6:	06 3a       	cp.w	r10,r3
800028d8:	cf 73       	brcs	800028c6 <LodePNG_convert+0x6aa>
             for(c = 0; c < 3; c++) out[OUT_BYTES * i + c] = in[3 * i + c];
             if(OUT_ALPHA && infoIn->key_defined == 1 && in[3 * i + 0] == infoIn->key_r && in[3 * i + 1] == infoIn->key_g && in[3 * i + 2] == infoIn->key_b) out[OUT_BYTES * i + 3] = 0;
           }
         break;
         case 3: /*indexed color (palette)*/
           for(i = 0; i < numpixels; i++)
800028da:	2f f5       	sub	r5,-1
800028dc:	2f fb       	sub	r11,-1
800028de:	06 0c       	add	r12,r3
800028e0:	0a 38       	cp.w	r8,r5
800028e2:	fe 9b ff e5 	brhi	800028ac <LodePNG_convert+0x690>
       }
     }
     else /*infoIn->bitDepth is less than 8 bit per channel*/
     {
       if(infoIn->colorType != 0) return 31; /*colorType 0 is the only greyscale type with < 8 bits per channel*/
       for(i = 0; i < numpixels; i++)
800028e6:	30 0c       	mov	r12,0
800028e8:	fe 9f fd 07 	bral	800022f6 <LodePNG_convert+0xda>
             for(c = 0; c < 3; c++) out[OUT_BYTES * i + c] = in[6 * i + 2 * c];
             if(OUT_ALPHA && infoIn->key_defined && 256U * in[6 * i + 0] + in[6 * i + 1] == infoIn->key_r && 256U * in[6 * i + 2] + in[6 * i + 3] == infoIn->key_g && 256U * in[6 * i + 4] + in[6 * i + 5] == infoIn->key_b) out[OUT_BYTES * i + 3] = 0;
           }
         break;
         case 4: /*greyscale with alpha*/
           for(i = 0; i < numpixels; i++)
800028ec:	58 08       	cp.w	r8,0
800028ee:	fe 90 fd 03 	breq	800022f4 <LodePNG_convert+0xd8>
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = in[2 * i];
             if(OUT_ALPHA && infoIn->key_defined && 256U * in[i] + in[i + 1] == infoIn->key_r) out[OUT_BYTES * i + 3] = 0;
           }
         break;
         case 2: /*RGB color*/
           for(i = 0; i < numpixels; i++)
800028f2:	58 02       	cp.w	r2,0
800028f4:	e0 81 00 c6 	brne	80002a80 <LodePNG_convert+0x864>
800028f8:	2f ec       	sub	r12,-2
           }
         break;
         case 4: /*greyscale with alpha*/
           for(i = 0; i < numpixels; i++)
           {
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = in[4 * i]; /*most significant byte*/
800028fa:	17 89       	ld.ub	r9,r11[0x0]
800028fc:	f9 69 ff fe 	st.b	r12[-2],r9
80002900:	b8 89       	st.b	r12[0x0],r9
80002902:	f9 69 ff ff 	st.b	r12[-1],r9
             for(c = 0; c < 3; c++) out[OUT_BYTES * i + c] = in[6 * i + 2 * c];
             if(OUT_ALPHA && infoIn->key_defined && 256U * in[6 * i + 0] + in[6 * i + 1] == infoIn->key_r && 256U * in[6 * i + 2] + in[6 * i + 3] == infoIn->key_g && 256U * in[6 * i + 4] + in[6 * i + 5] == infoIn->key_b) out[OUT_BYTES * i + 3] = 0;
           }
         break;
         case 4: /*greyscale with alpha*/
           for(i = 0; i < numpixels; i++)
80002906:	2f f2       	sub	r2,-1
80002908:	2f cb       	sub	r11,-4
8000290a:	06 0c       	add	r12,r3
8000290c:	04 38       	cp.w	r8,r2
8000290e:	fe 9b ff f6 	brhi	800028fa <LodePNG_convert+0x6de>
       }
     }
     else /*infoIn->bitDepth is less than 8 bit per channel*/
     {
       if(infoIn->colorType != 0) return 31; /*colorType 0 is the only greyscale type with < 8 bits per channel*/
       for(i = 0; i < numpixels; i++)
80002912:	30 0c       	mov	r12,0
80002914:	fe 9f fc f1 	bral	800022f6 <LodePNG_convert+0xda>
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = in[2 * i];
             if(OUT_ALPHA && infoIn->key_defined && 256U * in[i] + in[i + 1] == infoIn->key_r) out[OUT_BYTES * i + 3] = 0;
           }
         break;
         case 2: /*RGB color*/
           for(i = 0; i < numpixels; i++)
80002918:	58 08       	cp.w	r8,0
8000291a:	fe 90 fc ed 	breq	800022f4 <LodePNG_convert+0xd8>
     else if(infoIn->bitDepth == 16)
     {
       switch(infoIn->colorType)
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
8000291e:	30 0a       	mov	r10,0
80002920:	f6 c7 ff fe 	sub	r7,r11,-2
80002924:	f6 ce ff fc 	sub	lr,r11,-4
80002928:	f8 c5 ff fd 	sub	r5,r12,-3
8000292c:	14 96       	mov	r6,r10
           }
         break;
         case 2: /*RGB color*/
           for(i = 0; i < numpixels; i++)
           {
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = 255;
8000292e:	3f f0       	mov	r0,-1
             for(c = 0; c < 3; c++) out[OUT_BYTES * i + c] = in[6 * i + 2 * c];
             if(OUT_ALPHA && infoIn->key_defined && 256U * in[6 * i + 0] + in[6 * i + 1] == infoIn->key_r && 256U * in[6 * i + 2] + in[6 * i + 3] == infoIn->key_g && 256U * in[6 * i + 4] + in[6 * i + 5] == infoIn->key_b) out[OUT_BYTES * i + 3] = 0;
80002930:	14 91       	mov	r1,r10
80002932:	58 02       	cp.w	r2,0
80002934:	c3 70       	breq	800029a2 <LodePNG_convert+0x786>
80002936:	50 18       	stdsp	sp[0x4],r8
80002938:	c0 88       	rjmp	80002948 <LodePNG_convert+0x72c>
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = in[2 * i];
             if(OUT_ALPHA && infoIn->key_defined && 256U * in[i] + in[i + 1] == infoIn->key_r) out[OUT_BYTES * i + 3] = 0;
           }
         break;
         case 2: /*RGB color*/
           for(i = 0; i < numpixels; i++)
8000293a:	2f ab       	sub	r11,-6
8000293c:	2f a7       	sub	r7,-6
8000293e:	2f ae       	sub	lr,-6
80002940:	40 14       	lddsp	r4,sp[0x4]
80002942:	0c 34       	cp.w	r4,r6
80002944:	fe 98 fc d8 	brls	800022f4 <LodePNG_convert+0xd8>
           {
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = 255;
80002948:	aa 80       	st.b	r5[0x0],r0
             for(c = 0; c < 3; c++) out[OUT_BYTES * i + c] = in[6 * i + 2 * c];
8000294a:	17 84       	ld.ub	r4,r11[0x0]
8000294c:	f8 0a 0b 04 	st.b	r12[r10],r4
80002950:	0f 82       	ld.ub	r2,r7[0x0]
80002952:	f8 0a 00 04 	add	r4,r12,r10
80002956:	a8 92       	st.b	r4[0x1],r2
80002958:	1d 82       	ld.ub	r2,lr[0x0]
8000295a:	a8 a2       	st.b	r4[0x2],r2
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = in[2 * i];
             if(OUT_ALPHA && infoIn->key_defined && 256U * in[i] + in[i + 1] == infoIn->key_r) out[OUT_BYTES * i + 3] = 0;
           }
         break;
         case 2: /*RGB color*/
           for(i = 0; i < numpixels; i++)
8000295c:	2f f6       	sub	r6,-1
8000295e:	06 0a       	add	r10,r3
80002960:	06 05       	add	r5,r3
           {
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = 255;
             for(c = 0; c < 3; c++) out[OUT_BYTES * i + c] = in[6 * i + 2 * c];
             if(OUT_ALPHA && infoIn->key_defined && 256U * in[6 * i + 0] + in[6 * i + 1] == infoIn->key_r && 256U * in[6 * i + 2] + in[6 * i + 3] == infoIn->key_g && 256U * in[6 * i + 4] + in[6 * i + 5] == infoIn->key_b) out[OUT_BYTES * i + 3] = 0;
80002962:	72 42       	ld.w	r2,r9[0x10]
80002964:	58 02       	cp.w	r2,0
80002966:	ce a0       	breq	8000293a <LodePNG_convert+0x71e>
80002968:	17 82       	ld.ub	r2,r11[0x0]
8000296a:	a9 62       	lsl	r2,0x8
8000296c:	50 02       	stdsp	sp[0x0],r2
8000296e:	17 92       	ld.ub	r2,r11[0x1]
80002970:	40 08       	lddsp	r8,sp[0x0]
80002972:	04 08       	add	r8,r2
80002974:	72 52       	ld.w	r2,r9[0x14]
80002976:	04 38       	cp.w	r8,r2
80002978:	ce 11       	brne	8000293a <LodePNG_convert+0x71e>
8000297a:	0f 82       	ld.ub	r2,r7[0x0]
8000297c:	a9 62       	lsl	r2,0x8
8000297e:	50 02       	stdsp	sp[0x0],r2
80002980:	17 b2       	ld.ub	r2,r11[0x3]
80002982:	40 08       	lddsp	r8,sp[0x0]
80002984:	04 08       	add	r8,r2
80002986:	72 62       	ld.w	r2,r9[0x18]
80002988:	04 38       	cp.w	r8,r2
8000298a:	cd 81       	brne	8000293a <LodePNG_convert+0x71e>
8000298c:	1d 82       	ld.ub	r2,lr[0x0]
8000298e:	a9 62       	lsl	r2,0x8
80002990:	50 02       	stdsp	sp[0x0],r2
80002992:	17 d2       	ld.ub	r2,r11[0x5]
80002994:	40 08       	lddsp	r8,sp[0x0]
80002996:	04 08       	add	r8,r2
80002998:	72 72       	ld.w	r2,r9[0x1c]
8000299a:	04 38       	cp.w	r8,r2
8000299c:	e9 f1 0e 03 	st.beq	r4[0x3],r1
800029a0:	cc db       	rjmp	8000293a <LodePNG_convert+0x71e>
         break;
         case 2: /*RGB color*/
           for(i = 0; i < numpixels; i++)
           {
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = 255;
             for(c = 0; c < 3; c++) out[OUT_BYTES * i + c] = in[6 * i + 2 * c];
800029a2:	17 89       	ld.ub	r9,r11[0x0]
800029a4:	f8 0a 0b 09 	st.b	r12[r10],r9
800029a8:	0f 85       	ld.ub	r5,r7[0x0]
800029aa:	f8 0a 00 09 	add	r9,r12,r10
800029ae:	b2 95       	st.b	r9[0x1],r5
800029b0:	1d 85       	ld.ub	r5,lr[0x0]
800029b2:	b2 a5       	st.b	r9[0x2],r5
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = in[2 * i];
             if(OUT_ALPHA && infoIn->key_defined && 256U * in[i] + in[i + 1] == infoIn->key_r) out[OUT_BYTES * i + 3] = 0;
           }
         break;
         case 2: /*RGB color*/
           for(i = 0; i < numpixels; i++)
800029b4:	2f f6       	sub	r6,-1
800029b6:	06 0a       	add	r10,r3
800029b8:	2f ab       	sub	r11,-6
800029ba:	2f a7       	sub	r7,-6
800029bc:	2f ae       	sub	lr,-6
800029be:	0c 38       	cp.w	r8,r6
800029c0:	fe 9b ff f1 	brhi	800029a2 <LodePNG_convert+0x786>
800029c4:	fe 9f fc 98 	bral	800022f4 <LodePNG_convert+0xd8>
800029c8:	ea c0 ff fc 	sub	r0,r5,-4
800029cc:	cd 5a       	rjmp	80002776 <LodePNG_convert+0x55a>
     else if(infoIn->bitDepth == 16)
     {
       switch(infoIn->colorType)
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
800029ce:	2f dc       	sub	r12,-3
800029d0:	f6 ca ff ff 	sub	r10,r11,-1
800029d4:	30 1e       	mov	lr,1
           {
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = 255;
800029d6:	3f f6       	mov	r6,-1
800029d8:	c0 28       	rjmp	800029dc <LodePNG_convert+0x7c0>
     else if(infoIn->bitDepth == 16)
     {
       switch(infoIn->colorType)
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
800029da:	0e 9e       	mov	lr,r7
           {
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = 255;
800029dc:	b8 86       	st.b	r12[0x0],r6
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = in[2 * i];
800029de:	17 87       	ld.ub	r7,r11[0x0]
800029e0:	f9 67 ff fd 	st.b	r12[-3],r7
800029e4:	f9 67 ff ff 	st.b	r12[-1],r7
800029e8:	f9 67 ff fe 	st.b	r12[-2],r7
800029ec:	0e 95       	mov	r5,r7
             if(OUT_ALPHA && infoIn->key_defined && 256U * in[i] + in[i + 1] == infoIn->key_r) out[OUT_BYTES * i + 3] = 0;
800029ee:	2f eb       	sub	r11,-2
800029f0:	72 47       	ld.w	r7,r9[0x10]
800029f2:	58 07       	cp.w	r7,0
800029f4:	c0 a0       	breq	80002a08 <LodePNG_convert+0x7ec>
800029f6:	15 87       	ld.ub	r7,r10[0x0]
800029f8:	f5 35 ff ff 	ld.ub	r5,r10[-1]
800029fc:	a9 65       	lsl	r5,0x8
800029fe:	0e 05       	add	r5,r7
80002a00:	72 57       	ld.w	r7,r9[0x14]
80002a02:	0e 35       	cp.w	r5,r7
80002a04:	f9 f1 0e 00 	st.beq	r12[0x0],r1
80002a08:	06 0c       	add	r12,r3
80002a0a:	2f fa       	sub	r10,-1
80002a0c:	fc c7 ff ff 	sub	r7,lr,-1
     else if(infoIn->bitDepth == 16)
     {
       switch(infoIn->colorType)
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
80002a10:	1c 38       	cp.w	r8,lr
80002a12:	fe 9b ff e4 	brhi	800029da <LodePNG_convert+0x7be>
       }
     }
     else /*infoIn->bitDepth is less than 8 bit per channel*/
     {
       if(infoIn->colorType != 0) return 31; /*colorType 0 is the only greyscale type with < 8 bits per channel*/
       for(i = 0; i < numpixels; i++)
80002a16:	30 0c       	mov	r12,0
80002a18:	fe 9f fc 6f 	bral	800022f6 <LodePNG_convert+0xda>
     if(infoIn->bitDepth == 8)
     {
       switch(infoIn->colorType)
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
80002a1c:	2f dc       	sub	r12,-3
           {
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = 255;
80002a1e:	3f f7       	mov	r7,-1
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = in[i];
             if(OUT_ALPHA && infoIn->key_defined && in[i] == infoIn->key_r) out[OUT_BYTES * i + 3] = 0;
80002a20:	02 9e       	mov	lr,r1
       switch(infoIn->colorType)
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
           {
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = 255;
80002a22:	b8 87       	st.b	r12[0x0],r7
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = in[i];
80002a24:	17 8a       	ld.ub	r10,r11[0x0]
80002a26:	f9 6a ff fd 	st.b	r12[-3],r10
80002a2a:	f9 6a ff ff 	st.b	r12[-1],r10
80002a2e:	f9 6a ff fe 	st.b	r12[-2],r10
     if(infoIn->bitDepth == 8)
     {
       switch(infoIn->colorType)
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
80002a32:	2f f1       	sub	r1,-1
           {
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = 255;
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = in[i];
             if(OUT_ALPHA && infoIn->key_defined && in[i] == infoIn->key_r) out[OUT_BYTES * i + 3] = 0;
80002a34:	72 4a       	ld.w	r10,r9[0x10]
80002a36:	58 0a       	cp.w	r10,0
80002a38:	c0 60       	breq	80002a44 <LodePNG_convert+0x828>
80002a3a:	17 86       	ld.ub	r6,r11[0x0]
80002a3c:	72 5a       	ld.w	r10,r9[0x14]
80002a3e:	14 36       	cp.w	r6,r10
80002a40:	f9 fe 0e 00 	st.beq	r12[0x0],lr
     if(infoIn->bitDepth == 8)
     {
       switch(infoIn->colorType)
       {
         case 0: /*greyscale color*/
           for(i = 0; i < numpixels; i++)
80002a44:	06 0c       	add	r12,r3
80002a46:	2f fb       	sub	r11,-1
80002a48:	02 38       	cp.w	r8,r1
80002a4a:	fe 9b ff ec 	brhi	80002a22 <LodePNG_convert+0x806>
       }
     }
     else /*infoIn->bitDepth is less than 8 bit per channel*/
     {
       if(infoIn->colorType != 0) return 31; /*colorType 0 is the only greyscale type with < 8 bits per channel*/
       for(i = 0; i < numpixels; i++)
80002a4e:	30 0c       	mov	r12,0
80002a50:	fe 9f fc 53 	bral	800022f6 <LodePNG_convert+0xda>
             if(in[i] >= infoIn->palettesize) return 46;
             for(c = 0; c < OUT_BYTES; c++) out[OUT_BYTES * i + c] = infoIn->palette[4 * in[i] + c]; /*get rgb colors from the palette*/
           }
         break;
         case 4: /*greyscale with alpha*/
           for(i = 0; i < numpixels; i++)
80002a54:	2f ec       	sub	r12,-2
80002a56:	30 09       	mov	r9,0
           {
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = in[2 * i + 0];
80002a58:	17 8a       	ld.ub	r10,r11[0x0]
80002a5a:	f9 6a ff fe 	st.b	r12[-2],r10
80002a5e:	b8 8a       	st.b	r12[0x0],r10
80002a60:	f9 6a ff ff 	st.b	r12[-1],r10
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = in[2 * i + 1];
80002a64:	17 9a       	ld.ub	r10,r11[0x1]
80002a66:	b8 9a       	st.b	r12[0x1],r10
             if(in[i] >= infoIn->palettesize) return 46;
             for(c = 0; c < OUT_BYTES; c++) out[OUT_BYTES * i + c] = infoIn->palette[4 * in[i] + c]; /*get rgb colors from the palette*/
           }
         break;
         case 4: /*greyscale with alpha*/
           for(i = 0; i < numpixels; i++)
80002a68:	2f f9       	sub	r9,-1
80002a6a:	2f eb       	sub	r11,-2
80002a6c:	06 0c       	add	r12,r3
80002a6e:	12 38       	cp.w	r8,r9
80002a70:	fe 9b ff f4 	brhi	80002a58 <LodePNG_convert+0x83c>
       }
     }
     else /*infoIn->bitDepth is less than 8 bit per channel*/
     {
       if(infoIn->colorType != 0) return 31; /*colorType 0 is the only greyscale type with < 8 bits per channel*/
       for(i = 0; i < numpixels; i++)
80002a74:	30 0c       	mov	r12,0
80002a76:	fe 9f fc 40 	bral	800022f6 <LodePNG_convert+0xda>
         break;
         case 3: /*indexed color (palette)*/
           for(i = 0; i < numpixels; i++)
           {
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = 255;
             if(in[i] >= infoIn->palettesize) return 46;
80002a7a:	32 ec       	mov	r12,46
80002a7c:	fe 9f fb f1 	bral	8000225e <LodePNG_convert+0x42>
             for(c = 0; c < 3; c++) out[OUT_BYTES * i + c] = in[6 * i + 2 * c];
             if(OUT_ALPHA && infoIn->key_defined && 256U * in[6 * i + 0] + in[6 * i + 1] == infoIn->key_r && 256U * in[6 * i + 2] + in[6 * i + 3] == infoIn->key_g && 256U * in[6 * i + 4] + in[6 * i + 5] == infoIn->key_b) out[OUT_BYTES * i + 3] = 0;
           }
         break;
         case 4: /*greyscale with alpha*/
           for(i = 0; i < numpixels; i++)
80002a80:	2f ec       	sub	r12,-2
80002a82:	30 09       	mov	r9,0
           {
             out[OUT_BYTES * i + 0] = out[OUT_BYTES * i + 1] = out[OUT_BYTES * i + 2] = in[4 * i]; /*most significant byte*/
80002a84:	17 8a       	ld.ub	r10,r11[0x0]
80002a86:	f9 6a ff fe 	st.b	r12[-2],r10
80002a8a:	b8 8a       	st.b	r12[0x0],r10
80002a8c:	f9 6a ff ff 	st.b	r12[-1],r10
             if(OUT_ALPHA) out[OUT_BYTES * i + 3] = in[4 * i + 2];
80002a90:	17 aa       	ld.ub	r10,r11[0x2]
80002a92:	b8 9a       	st.b	r12[0x1],r10
             for(c = 0; c < 3; c++) out[OUT_BYTES * i + c] = in[6 * i + 2 * c];
             if(OUT_ALPHA && infoIn->key_defined && 256U * in[6 * i + 0] + in[6 * i + 1] == infoIn->key_r && 256U * in[6 * i + 2] + in[6 * i + 3] == infoIn->key_g && 256U * in[6 * i + 4] + in[6 * i + 5] == infoIn->key_b) out[OUT_BYTES * i + 3] = 0;
           }
         break;
         case 4: /*greyscale with alpha*/
           for(i = 0; i < numpixels; i++)
80002a94:	2f f9       	sub	r9,-1
80002a96:	2f cb       	sub	r11,-4
80002a98:	06 0c       	add	r12,r3
80002a9a:	12 38       	cp.w	r8,r9
80002a9c:	fe 9b ff f4 	brhi	80002a84 <LodePNG_convert+0x868>
       }
     }
     else /*infoIn->bitDepth is less than 8 bit per channel*/
     {
       if(infoIn->colorType != 0) return 31; /*colorType 0 is the only greyscale type with < 8 bits per channel*/
       for(i = 0; i < numpixels; i++)
80002aa0:	30 0c       	mov	r12,0
80002aa2:	fe 9f fc 2a 	bral	800022f6 <LodePNG_convert+0xda>
80002aa6:	d7 03       	nop
80002aa8:	80 01       	ld.sh	r1,r0[0x0]
80002aaa:	71 3c       	ld.w	r12,r8[0x4c]

80002aac <Adam7_getpassvalues>:
 static const unsigned ADAM7_IY[7] = { 0, 0, 4, 0, 2, 0, 1 }; /*y start values*/
 static const unsigned ADAM7_DX[7] = { 8, 8, 4, 4, 2, 2, 1 }; /*x delta values*/
 static const unsigned ADAM7_DY[7] = { 8, 8, 8, 4, 4, 2, 2 }; /*y delta values*/
 
 static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8], size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp)
 {
80002aac:	d4 31       	pushm	r0-r7,lr
80002aae:	20 ed       	sub	sp,56
   unsigned i;
 
   /*calculate width and height in pixels of each pass*/
   for(i = 0; i < 7; i++)
   {
     passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
80002ab0:	30 87       	mov	r7,8
 static const unsigned ADAM7_IY[7] = { 0, 0, 4, 0, 2, 0, 1 }; /*y start values*/
 static const unsigned ADAM7_DX[7] = { 8, 8, 4, 4, 2, 2, 1 }; /*x delta values*/
 static const unsigned ADAM7_DY[7] = { 8, 8, 8, 4, 4, 2, 2 }; /*y delta values*/
 
 static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8], size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp)
 {
80002ab2:	41 7e       	lddsp	lr,sp[0x5c]
   unsigned i;
 
   /*calculate width and height in pixels of each pass*/
   for(i = 0; i < 7; i++)
   {
     passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
80002ab4:	fc c3 ff f9 	sub	r3,lr,-7
80002ab8:	e6 07 0d 02 	divu	r2,r3,r7
80002abc:	99 02       	st.w	r12[0x0],r2
 static const unsigned ADAM7_IY[7] = { 0, 0, 4, 0, 2, 0, 1 }; /*y start values*/
 static const unsigned ADAM7_DX[7] = { 8, 8, 4, 4, 2, 2, 1 }; /*x delta values*/
 static const unsigned ADAM7_DY[7] = { 8, 8, 8, 4, 4, 2, 2 }; /*y delta values*/
 
 static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8], size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp)
 {
80002abe:	fa c4 ff a4 	sub	r4,sp,-92
80002ac2:	68 15       	ld.w	r5,r4[0x4]
 
   /*calculate width and height in pixels of each pass*/
   for(i = 0; i < 7; i++)
   {
     passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
     passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
80002ac4:	ea c6 ff f9 	sub	r6,r5,-7
80002ac8:	ec 07 0d 02 	divu	r2,r6,r7
80002acc:	97 02       	st.w	r11[0x0],r2
 static const unsigned ADAM7_IY[7] = { 0, 0, 4, 0, 2, 0, 1 }; /*y start values*/
 static const unsigned ADAM7_DX[7] = { 8, 8, 4, 4, 2, 2, 1 }; /*x delta values*/
 static const unsigned ADAM7_DY[7] = { 8, 8, 8, 4, 4, 2, 2 }; /*y delta values*/
 
 static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8], size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp)
 {
80002ace:	20 15       	sub	r5,1
80002ad0:	50 35       	stdsp	sp[0xc],r5
80002ad2:	68 27       	ld.w	r7,r4[0x8]
80002ad4:	20 1e       	sub	lr,1
   /*calculate width and height in pixels of each pass*/
   for(i = 0; i < 7; i++)
   {
     passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
     passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
     if(passw[i] == 0) passh[i] = 0;
80002ad6:	78 04       	ld.w	r4,r12[0x0]
80002ad8:	58 04       	cp.w	r4,0
80002ada:	e0 81 02 01 	brne	80002edc <Adam7_getpassvalues+0x430>
80002ade:	97 04       	st.w	r11[0x0],r4
     if(passh[i] == 0) passw[i] = 0;
80002ae0:	18 95       	mov	r5,r12
80002ae2:	0a a4       	st.w	r5++,r4
   unsigned i;
 
   /*calculate width and height in pixels of each pass*/
   for(i = 0; i < 7; i++)
   {
     passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
80002ae4:	30 81       	mov	r1,8
80002ae6:	fc c4 ff fc 	sub	r4,lr,-4
80002aea:	e8 01 0d 02 	divu	r2,r4,r1
80002aee:	50 74       	stdsp	sp[0x1c],r4
80002af0:	fa e3 00 14 	st.d	sp[20],r2
80002af4:	8b 02       	st.w	r5[0x0],r2
     passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
80002af6:	ec 01 0d 00 	divu	r0,r6,r1
80002afa:	f6 c6 ff fc 	sub	r6,r11,-4
80002afe:	50 96       	stdsp	sp[0x24],r6
80002b00:	8d 00       	st.w	r6[0x0],r0
     if(passw[i] == 0) passh[i] = 0;
80002b02:	6a 04       	ld.w	r4,r5[0x0]
80002b04:	58 04       	cp.w	r4,0
80002b06:	e0 81 01 e4 	brne	80002ece <Adam7_getpassvalues+0x422>
80002b0a:	40 93       	lddsp	r3,sp[0x24]
80002b0c:	87 04       	st.w	r3[0x0],r4
     if(passh[i] == 0) passw[i] = 0;
80002b0e:	8b 04       	st.w	r5[0x0],r4
   unsigned i;
 
   /*calculate width and height in pixels of each pass*/
   for(i = 0; i < 7; i++)
   {
     passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
80002b10:	f8 c2 ff f8 	sub	r2,r12,-8
80002b14:	40 76       	lddsp	r6,sp[0x1c]
80002b16:	30 41       	mov	r1,4
80002b18:	ec 01 0d 00 	divu	r0,r6,r1
80002b1c:	85 00       	st.w	r2[0x0],r0
     passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
80002b1e:	f6 c4 ff f8 	sub	r4,r11,-8
80002b22:	40 33       	lddsp	r3,sp[0xc]
80002b24:	50 d4       	stdsp	sp[0x34],r4
80002b26:	2f c3       	sub	r3,-4
80002b28:	50 73       	stdsp	sp[0x1c],r3
80002b2a:	30 81       	mov	r1,8
80002b2c:	e6 01 0d 00 	divu	r0,r3,r1
80002b30:	89 00       	st.w	r4[0x0],r0
80002b32:	50 50       	stdsp	sp[0x14],r0
     if(passw[i] == 0) passh[i] = 0;
80002b34:	64 04       	ld.w	r4,r2[0x0]
80002b36:	58 04       	cp.w	r4,0
80002b38:	e0 81 01 c4 	brne	80002ec0 <Adam7_getpassvalues+0x414>
80002b3c:	40 d1       	lddsp	r1,sp[0x34]
80002b3e:	83 04       	st.w	r1[0x0],r4
     if(passh[i] == 0) passw[i] = 0;
80002b40:	85 04       	st.w	r2[0x0],r4
   unsigned i;
 
   /*calculate width and height in pixels of each pass*/
   for(i = 0; i < 7; i++)
   {
     passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
80002b42:	fc c1 ff fe 	sub	r1,lr,-2
80002b46:	50 a1       	stdsp	sp[0x28],r1
80002b48:	f8 c3 ff f4 	sub	r3,r12,-12
80002b4c:	30 44       	mov	r4,4
80002b4e:	e2 04 0d 00 	divu	r0,r1,r4
80002b52:	87 00       	st.w	r3[0x0],r0
     passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
80002b54:	f6 c6 ff f4 	sub	r6,r11,-12
80002b58:	40 70       	lddsp	r0,sp[0x1c]
80002b5a:	50 c6       	stdsp	sp[0x30],r6
80002b5c:	e0 04 0d 00 	divu	r0,r0,r4
80002b60:	fa e1 00 14 	st.d	sp[20],r0
80002b64:	8d 00       	st.w	r6[0x0],r0
80002b66:	40 66       	lddsp	r6,sp[0x18]
     if(passw[i] == 0) passh[i] = 0;
80002b68:	66 01       	ld.w	r1,r3[0x0]
80002b6a:	58 01       	cp.w	r1,0
80002b6c:	e0 81 01 a2 	brne	80002eb0 <Adam7_getpassvalues+0x404>
80002b70:	40 c4       	lddsp	r4,sp[0x30]
80002b72:	89 01       	st.w	r4[0x0],r1
     if(passh[i] == 0) passw[i] = 0;
80002b74:	87 01       	st.w	r3[0x0],r1
   unsigned i;
 
   /*calculate width and height in pixels of each pass*/
   for(i = 0; i < 7; i++)
   {
     passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
80002b76:	30 21       	mov	r1,2
80002b78:	40 a6       	lddsp	r6,sp[0x28]
80002b7a:	ec 01 0d 00 	divu	r0,r6,r1
80002b7e:	f8 c4 ff f0 	sub	r4,r12,-16
     passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
80002b82:	f6 c1 ff f0 	sub	r1,r11,-16
   unsigned i;
 
   /*calculate width and height in pixels of each pass*/
   for(i = 0; i < 7; i++)
   {
     passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
80002b86:	89 00       	st.w	r4[0x0],r0
     passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
80002b88:	50 a1       	stdsp	sp[0x28],r1
80002b8a:	40 30       	lddsp	r0,sp[0xc]
80002b8c:	30 41       	mov	r1,4
80002b8e:	2f e0       	sub	r0,-2
80002b90:	50 50       	stdsp	sp[0x14],r0
80002b92:	e0 01 0d 00 	divu	r0,r0,r1
80002b96:	fa e1 00 00 	st.d	sp[0],r0
80002b9a:	40 a6       	lddsp	r6,sp[0x28]
80002b9c:	8d 00       	st.w	r6[0x0],r0
80002b9e:	40 11       	lddsp	r1,sp[0x4]
80002ba0:	50 71       	stdsp	sp[0x1c],r1
     if(passw[i] == 0) passh[i] = 0;
80002ba2:	68 06       	ld.w	r6,r4[0x0]
80002ba4:	58 06       	cp.w	r6,0
80002ba6:	e0 81 01 7c 	brne	80002e9e <Adam7_getpassvalues+0x3f2>
80002baa:	40 a0       	lddsp	r0,sp[0x28]
80002bac:	81 06       	st.w	r0[0x0],r6
     if(passh[i] == 0) passw[i] = 0;
80002bae:	89 06       	st.w	r4[0x0],r6
   unsigned i;
 
   /*calculate width and height in pixels of each pass*/
   for(i = 0; i < 7; i++)
   {
     passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
80002bb0:	2f fe       	sub	lr,-1
80002bb2:	30 21       	mov	r1,2
80002bb4:	50 7e       	stdsp	sp[0x1c],lr
80002bb6:	fc 01 0d 00 	divu	r0,lr,r1
80002bba:	f8 c6 ff ec 	sub	r6,r12,-20
     passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
80002bbe:	30 21       	mov	r1,2
   unsigned i;
 
   /*calculate width and height in pixels of each pass*/
   for(i = 0; i < 7; i++)
   {
     passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
80002bc0:	8d 00       	st.w	r6[0x0],r0
     passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
80002bc2:	40 50       	lddsp	r0,sp[0x14]
80002bc4:	e0 01 0d 00 	divu	r0,r0,r1
80002bc8:	fa e1 00 00 	st.d	sp[0],r0
80002bcc:	f6 c0 ff ec 	sub	r0,r11,-20
80002bd0:	50 50       	stdsp	sp[0x14],r0
80002bd2:	40 1e       	lddsp	lr,sp[0x4]
80002bd4:	81 0e       	st.w	r0[0x0],lr
80002bd6:	40 11       	lddsp	r1,sp[0x4]
80002bd8:	50 b1       	stdsp	sp[0x2c],r1
     if(passw[i] == 0) passh[i] = 0;
80002bda:	6c 0e       	ld.w	lr,r6[0x0]
80002bdc:	58 0e       	cp.w	lr,0
80002bde:	e0 81 01 59 	brne	80002e90 <Adam7_getpassvalues+0x3e4>
80002be2:	81 0e       	st.w	r0[0x0],lr
     if(passh[i] == 0) passw[i] = 0;
80002be4:	8d 0e       	st.w	r6[0x0],lr
   unsigned i;
 
   /*calculate width and height in pixels of each pass*/
   for(i = 0; i < 7; i++)
   {
     passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
80002be6:	f8 ce ff e8 	sub	lr,r12,-24
80002bea:	40 70       	lddsp	r0,sp[0x1c]
80002bec:	50 2e       	stdsp	sp[0x8],lr
80002bee:	30 1e       	mov	lr,1
80002bf0:	e0 0e 0d 00 	divu	r0,r0,lr
80002bf4:	fa e1 00 1c 	st.d	sp[28],r0
80002bf8:	40 2e       	lddsp	lr,sp[0x8]
80002bfa:	9d 00       	st.w	lr[0x0],r0
     passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
80002bfc:	f6 c0 ff e8 	sub	r0,r11,-24
80002c00:	40 31       	lddsp	r1,sp[0xc]
80002c02:	2f f1       	sub	r1,-1
80002c04:	50 00       	stdsp	sp[0x0],r0
80002c06:	02 90       	mov	r0,r1
80002c08:	30 21       	mov	r1,2
80002c0a:	e0 01 0d 00 	divu	r0,r0,r1
80002c0e:	fa e1 00 0c 	st.d	sp[12],r0
80002c12:	40 0e       	lddsp	lr,sp[0x0]
80002c14:	9d 00       	st.w	lr[0x0],r0
     if(passw[i] == 0) passh[i] = 0;
80002c16:	40 21       	lddsp	r1,sp[0x8]
80002c18:	62 01       	ld.w	r1,r1[0x0]
80002c1a:	50 b1       	stdsp	sp[0x2c],r1
 
   /*calculate width and height in pixels of each pass*/
   for(i = 0; i < 7; i++)
   {
     passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
     passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
80002c1c:	40 40       	lddsp	r0,sp[0x10]
     if(passw[i] == 0) passh[i] = 0;
80002c1e:	58 01       	cp.w	r1,0
80002c20:	e0 80 01 33 	breq	80002e86 <Adam7_getpassvalues+0x3da>
80002c24:	9d 00       	st.w	lr[0x0],r0
     if(passh[i] == 0) passw[i] = 0;
80002c26:	40 40       	lddsp	r0,sp[0x10]
80002c28:	58 00       	cp.w	r0,0
80002c2a:	e0 01 17 00 	moveq	r1,r0
80002c2e:	50 b1       	stdsp	sp[0x2c],r1
80002c30:	40 2e       	lddsp	lr,sp[0x8]
80002c32:	9d 01       	st.w	lr[0x0],r1
   }
 
   filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
80002c34:	30 00       	mov	r0,0
80002c36:	91 00       	st.w	r8[0x0],r0
80002c38:	93 00       	st.w	r9[0x0],r0
80002c3a:	95 00       	st.w	r10[0x0],r0
   for(i = 0; i < 7; i++)
   {
     filter_passstart[i + 1] = filter_passstart[i] + ((passw[i] && passh[i]) ? passh[i] * (1 + (passw[i] * bpp + 7) / 8) : 0); /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
80002c3c:	78 00       	ld.w	r0,r12[0x0]
80002c3e:	58 00       	cp.w	r0,0
80002c40:	c0 60       	breq	80002c4c <Adam7_getpassvalues+0x1a0>
80002c42:	76 0e       	ld.w	lr,r11[0x0]
80002c44:	50 3e       	stdsp	sp[0xc],lr
80002c46:	58 0e       	cp.w	lr,0
80002c48:	e0 81 01 7a 	brne	80002f3c <Adam7_getpassvalues+0x490>
80002c4c:	30 00       	mov	r0,0
80002c4e:	f4 c1 ff fc 	sub	r1,r10,-4
80002c52:	50 71       	stdsp	sp[0x1c],r1
80002c54:	83 00       	st.w	r1[0x0],r0
     padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7) / 8); /*bits padded if needed to fill full byte at end of each scanline*/
80002c56:	f2 c0 ff fc 	sub	r0,r9,-4
80002c5a:	50 30       	stdsp	sp[0xc],r0
80002c5c:	78 00       	ld.w	r0,r12[0x0]
80002c5e:	ee 00 02 40 	mul	r0,r7,r0
80002c62:	2f 90       	sub	r0,-7
80002c64:	a3 90       	lsr	r0,0x3
80002c66:	50 b0       	stdsp	sp[0x2c],r0
80002c68:	76 00       	ld.w	r0,r11[0x0]
80002c6a:	40 be       	lddsp	lr,sp[0x2c]
80002c6c:	40 31       	lddsp	r1,sp[0xc]
80002c6e:	a1 3e       	mul	lr,r0
80002c70:	72 00       	ld.w	r0,r9[0x0]
80002c72:	fc 00 00 00 	add	r0,lr,r0
80002c76:	83 00       	st.w	r1[0x0],r0
     passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7) / 8; /*only padded at end of reduced image*/
80002c78:	78 0c       	ld.w	r12,r12[0x0]
80002c7a:	ee 0c 02 4c 	mul	r12,r7,r12
80002c7e:	76 0b       	ld.w	r11,r11[0x0]
80002c80:	f8 0b 02 4b 	mul	r11,r12,r11
80002c84:	70 0c       	ld.w	r12,r8[0x0]
80002c86:	2f 9b       	sub	r11,-7
80002c88:	a3 9b       	lsr	r11,0x3
80002c8a:	18 0b       	add	r11,r12
80002c8c:	91 1b       	st.w	r8[0x4],r11
   }
 
   filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
   for(i = 0; i < 7; i++)
   {
     filter_passstart[i + 1] = filter_passstart[i] + ((passw[i] && passh[i]) ? passh[i] * (1 + (passw[i] * bpp + 7) / 8) : 0); /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
80002c8e:	40 7e       	lddsp	lr,sp[0x1c]
     padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7) / 8); /*bits padded if needed to fill full byte at end of each scanline*/
     passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7) / 8; /*only padded at end of reduced image*/
80002c90:	f0 cc ff fc 	sub	r12,r8,-4
   }
 
   filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
   for(i = 0; i < 7; i++)
   {
     filter_passstart[i + 1] = filter_passstart[i] + ((passw[i] && passh[i]) ? passh[i] * (1 + (passw[i] * bpp + 7) / 8) : 0); /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
80002c94:	7c 00       	ld.w	r0,lr[0x0]
80002c96:	6a 0b       	ld.w	r11,r5[0x0]
80002c98:	58 0b       	cp.w	r11,0
80002c9a:	c0 70       	breq	80002ca8 <Adam7_getpassvalues+0x1fc>
80002c9c:	40 91       	lddsp	r1,sp[0x24]
80002c9e:	62 01       	ld.w	r1,r1[0x0]
80002ca0:	50 71       	stdsp	sp[0x1c],r1
80002ca2:	58 01       	cp.w	r1,0
80002ca4:	e0 81 01 45 	brne	80002f2e <Adam7_getpassvalues+0x482>
80002ca8:	30 0b       	mov	r11,0
80002caa:	f6 00 00 00 	add	r0,r11,r0
80002cae:	95 20       	st.w	r10[0x8],r0
     padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7) / 8); /*bits padded if needed to fill full byte at end of each scanline*/
80002cb0:	40 30       	lddsp	r0,sp[0xc]
80002cb2:	60 00       	ld.w	r0,r0[0x0]
80002cb4:	40 9e       	lddsp	lr,sp[0x24]
80002cb6:	50 70       	stdsp	sp[0x1c],r0
80002cb8:	6a 00       	ld.w	r0,r5[0x0]
80002cba:	ee 00 02 40 	mul	r0,r7,r0
80002cbe:	2f 90       	sub	r0,-7
80002cc0:	a3 90       	lsr	r0,0x3
80002cc2:	50 30       	stdsp	sp[0xc],r0
80002cc4:	7c 00       	ld.w	r0,lr[0x0]
80002cc6:	40 31       	lddsp	r1,sp[0xc]
80002cc8:	40 7e       	lddsp	lr,sp[0x1c]
80002cca:	e2 00 02 40 	mul	r0,r1,r0
80002cce:	1c 00       	add	r0,lr
80002cd0:	50 30       	stdsp	sp[0xc],r0
80002cd2:	f2 c0 ff f8 	sub	r0,r9,-8
80002cd6:	40 31       	lddsp	r1,sp[0xc]
80002cd8:	81 01       	st.w	r0[0x0],r1
   }
 
   filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
   for(i = 0; i < 7; i++)
   {
     filter_passstart[i + 1] = filter_passstart[i] + ((passw[i] && passh[i]) ? passh[i] * (1 + (passw[i] * bpp + 7) / 8) : 0); /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
80002cda:	f4 cb ff f8 	sub	r11,r10,-8
     padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7) / 8); /*bits padded if needed to fill full byte at end of each scanline*/
     passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7) / 8; /*only padded at end of reduced image*/
80002cde:	78 0c       	ld.w	r12,r12[0x0]
80002ce0:	6a 05       	ld.w	r5,r5[0x0]
80002ce2:	40 9e       	lddsp	lr,sp[0x24]
80002ce4:	ee 05 02 45 	mul	r5,r7,r5
80002ce8:	7c 0e       	ld.w	lr,lr[0x0]
80002cea:	bd 35       	mul	r5,lr
80002cec:	2f 95       	sub	r5,-7
80002cee:	a3 95       	lsr	r5,0x3
80002cf0:	18 05       	add	r5,r12
80002cf2:	91 25       	st.w	r8[0x8],r5
80002cf4:	f0 cc ff f8 	sub	r12,r8,-8
   }
 
   filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
   for(i = 0; i < 7; i++)
   {
     filter_passstart[i + 1] = filter_passstart[i] + ((passw[i] && passh[i]) ? passh[i] * (1 + (passw[i] * bpp + 7) / 8) : 0); /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
80002cf8:	76 05       	ld.w	r5,r11[0x0]
80002cfa:	64 0b       	ld.w	r11,r2[0x0]
80002cfc:	58 0b       	cp.w	r11,0
80002cfe:	c0 70       	breq	80002d0c <Adam7_getpassvalues+0x260>
80002d00:	40 d1       	lddsp	r1,sp[0x34]
80002d02:	62 01       	ld.w	r1,r1[0x0]
80002d04:	50 91       	stdsp	sp[0x24],r1
80002d06:	58 01       	cp.w	r1,0
80002d08:	e0 81 01 0c 	brne	80002f20 <Adam7_getpassvalues+0x474>
80002d0c:	30 0b       	mov	r11,0
80002d0e:	f6 05 00 05 	add	r5,r11,r5
80002d12:	95 35       	st.w	r10[0xc],r5
     padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7) / 8); /*bits padded if needed to fill full byte at end of each scanline*/
80002d14:	60 00       	ld.w	r0,r0[0x0]
80002d16:	40 de       	lddsp	lr,sp[0x34]
80002d18:	50 90       	stdsp	sp[0x24],r0
80002d1a:	7c 05       	ld.w	r5,lr[0x0]
80002d1c:	64 00       	ld.w	r0,r2[0x0]
80002d1e:	ee 00 02 40 	mul	r0,r7,r0
80002d22:	2f 90       	sub	r0,-7
80002d24:	a3 90       	lsr	r0,0x3
80002d26:	ab 30       	mul	r0,r5
80002d28:	40 95       	lddsp	r5,sp[0x24]
80002d2a:	0a 00       	add	r0,r5
80002d2c:	93 30       	st.w	r9[0xc],r0
   }
 
   filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
   for(i = 0; i < 7; i++)
   {
     filter_passstart[i + 1] = filter_passstart[i] + ((passw[i] && passh[i]) ? passh[i] * (1 + (passw[i] * bpp + 7) / 8) : 0); /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
80002d2e:	f4 cb ff f4 	sub	r11,r10,-12
     padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7) / 8); /*bits padded if needed to fill full byte at end of each scanline*/
     passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7) / 8; /*only padded at end of reduced image*/
80002d32:	64 00       	ld.w	r0,r2[0x0]
80002d34:	78 0c       	ld.w	r12,r12[0x0]
80002d36:	7c 02       	ld.w	r2,lr[0x0]
80002d38:	ee 00 02 40 	mul	r0,r7,r0
80002d3c:	e0 02 02 42 	mul	r2,r0,r2
80002d40:	2f 92       	sub	r2,-7
80002d42:	a3 92       	lsr	r2,0x3
80002d44:	18 02       	add	r2,r12
80002d46:	91 32       	st.w	r8[0xc],r2
 
   filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
   for(i = 0; i < 7; i++)
   {
     filter_passstart[i + 1] = filter_passstart[i] + ((passw[i] && passh[i]) ? passh[i] * (1 + (passw[i] * bpp + 7) / 8) : 0); /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
     padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7) / 8); /*bits padded if needed to fill full byte at end of each scanline*/
80002d48:	f2 c5 ff f4 	sub	r5,r9,-12
   }
 
   filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
   for(i = 0; i < 7; i++)
   {
     filter_passstart[i + 1] = filter_passstart[i] + ((passw[i] && passh[i]) ? passh[i] * (1 + (passw[i] * bpp + 7) / 8) : 0); /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
80002d4c:	76 02       	ld.w	r2,r11[0x0]
     padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7) / 8); /*bits padded if needed to fill full byte at end of each scanline*/
     passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7) / 8; /*only padded at end of reduced image*/
80002d4e:	f0 cc ff f4 	sub	r12,r8,-12
   }
 
   filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
   for(i = 0; i < 7; i++)
   {
     filter_passstart[i + 1] = filter_passstart[i] + ((passw[i] && passh[i]) ? passh[i] * (1 + (passw[i] * bpp + 7) / 8) : 0); /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
80002d52:	66 0b       	ld.w	r11,r3[0x0]
80002d54:	58 0b       	cp.w	r11,0
80002d56:	c0 60       	breq	80002d62 <Adam7_getpassvalues+0x2b6>
80002d58:	40 c1       	lddsp	r1,sp[0x30]
80002d5a:	62 00       	ld.w	r0,r1[0x0]
80002d5c:	58 00       	cp.w	r0,0
80002d5e:	e0 81 00 da 	brne	80002f12 <Adam7_getpassvalues+0x466>
80002d62:	30 0b       	mov	r11,0
80002d64:	f6 02 00 02 	add	r2,r11,r2
80002d68:	95 42       	st.w	r10[0x10],r2
     padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7) / 8); /*bits padded if needed to fill full byte at end of each scanline*/
80002d6a:	66 00       	ld.w	r0,r3[0x0]
80002d6c:	6a 05       	ld.w	r5,r5[0x0]
80002d6e:	40 ce       	lddsp	lr,sp[0x30]
80002d70:	ee 00 02 40 	mul	r0,r7,r0
80002d74:	7c 02       	ld.w	r2,lr[0x0]
80002d76:	2f 90       	sub	r0,-7
80002d78:	a3 90       	lsr	r0,0x3
80002d7a:	e0 02 03 45 	mac	r5,r0,r2
80002d7e:	93 45       	st.w	r9[0x10],r5
   }
 
   filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
   for(i = 0; i < 7; i++)
   {
     filter_passstart[i + 1] = filter_passstart[i] + ((passw[i] && passh[i]) ? passh[i] * (1 + (passw[i] * bpp + 7) / 8) : 0); /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
80002d80:	f4 cb ff f0 	sub	r11,r10,-16
     padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7) / 8); /*bits padded if needed to fill full byte at end of each scanline*/
     passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7) / 8; /*only padded at end of reduced image*/
80002d84:	66 05       	ld.w	r5,r3[0x0]
80002d86:	78 0c       	ld.w	r12,r12[0x0]
80002d88:	7c 03       	ld.w	r3,lr[0x0]
80002d8a:	ee 05 02 45 	mul	r5,r7,r5
80002d8e:	a7 35       	mul	r5,r3
80002d90:	2f 95       	sub	r5,-7
80002d92:	a3 95       	lsr	r5,0x3
80002d94:	18 05       	add	r5,r12
80002d96:	91 45       	st.w	r8[0x10],r5
 
   filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
   for(i = 0; i < 7; i++)
   {
     filter_passstart[i + 1] = filter_passstart[i] + ((passw[i] && passh[i]) ? passh[i] * (1 + (passw[i] * bpp + 7) / 8) : 0); /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
     padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7) / 8); /*bits padded if needed to fill full byte at end of each scanline*/
80002d98:	f2 c2 ff f0 	sub	r2,r9,-16
   }
 
   filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
   for(i = 0; i < 7; i++)
   {
     filter_passstart[i + 1] = filter_passstart[i] + ((passw[i] && passh[i]) ? passh[i] * (1 + (passw[i] * bpp + 7) / 8) : 0); /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
80002d9c:	76 05       	ld.w	r5,r11[0x0]
     padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7) / 8); /*bits padded if needed to fill full byte at end of each scanline*/
     passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7) / 8; /*only padded at end of reduced image*/
80002d9e:	f0 cc ff f0 	sub	r12,r8,-16
   }
 
   filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
   for(i = 0; i < 7; i++)
   {
     filter_passstart[i + 1] = filter_passstart[i] + ((passw[i] && passh[i]) ? passh[i] * (1 + (passw[i] * bpp + 7) / 8) : 0); /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
80002da2:	68 0b       	ld.w	r11,r4[0x0]
80002da4:	58 0b       	cp.w	r11,0
80002da6:	c0 60       	breq	80002db2 <Adam7_getpassvalues+0x306>
80002da8:	40 a1       	lddsp	r1,sp[0x28]
80002daa:	62 03       	ld.w	r3,r1[0x0]
80002dac:	58 03       	cp.w	r3,0
80002dae:	e0 81 00 ab 	brne	80002f04 <Adam7_getpassvalues+0x458>
80002db2:	30 0b       	mov	r11,0
80002db4:	f6 05 00 05 	add	r5,r11,r5
80002db8:	95 55       	st.w	r10[0x14],r5
     padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7) / 8); /*bits padded if needed to fill full byte at end of each scanline*/
80002dba:	64 05       	ld.w	r5,r2[0x0]
80002dbc:	40 a0       	lddsp	r0,sp[0x28]
80002dbe:	68 02       	ld.w	r2,r4[0x0]
80002dc0:	60 03       	ld.w	r3,r0[0x0]
80002dc2:	ee 02 02 42 	mul	r2,r7,r2
80002dc6:	2f 92       	sub	r2,-7
80002dc8:	a3 92       	lsr	r2,0x3
80002dca:	e4 03 03 45 	mac	r5,r2,r3
80002dce:	93 55       	st.w	r9[0x14],r5
   }
 
   filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
   for(i = 0; i < 7; i++)
   {
     filter_passstart[i + 1] = filter_passstart[i] + ((passw[i] && passh[i]) ? passh[i] * (1 + (passw[i] * bpp + 7) / 8) : 0); /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
80002dd0:	f4 cb ff ec 	sub	r11,r10,-20
     padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7) / 8); /*bits padded if needed to fill full byte at end of each scanline*/
     passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7) / 8; /*only padded at end of reduced image*/
80002dd4:	68 04       	ld.w	r4,r4[0x0]
80002dd6:	78 05       	ld.w	r5,r12[0x0]
80002dd8:	40 ae       	lddsp	lr,sp[0x28]
80002dda:	ee 04 02 4c 	mul	r12,r7,r4
80002dde:	7c 03       	ld.w	r3,lr[0x0]
80002de0:	a7 3c       	mul	r12,r3
80002de2:	2f 9c       	sub	r12,-7
80002de4:	a3 9c       	lsr	r12,0x3
80002de6:	0a 0c       	add	r12,r5
80002de8:	91 5c       	st.w	r8[0x14],r12
 
   filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
   for(i = 0; i < 7; i++)
   {
     filter_passstart[i + 1] = filter_passstart[i] + ((passw[i] && passh[i]) ? passh[i] * (1 + (passw[i] * bpp + 7) / 8) : 0); /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
     padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7) / 8); /*bits padded if needed to fill full byte at end of each scanline*/
80002dea:	f2 c0 ff ec 	sub	r0,r9,-20
   }
 
   filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
   for(i = 0; i < 7; i++)
   {
     filter_passstart[i + 1] = filter_passstart[i] + ((passw[i] && passh[i]) ? passh[i] * (1 + (passw[i] * bpp + 7) / 8) : 0); /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
80002dee:	76 0c       	ld.w	r12,r11[0x0]
     padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7) / 8); /*bits padded if needed to fill full byte at end of each scanline*/
     passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7) / 8; /*only padded at end of reduced image*/
80002df0:	f0 c4 ff ec 	sub	r4,r8,-20
   }
 
   filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
   for(i = 0; i < 7; i++)
   {
     filter_passstart[i + 1] = filter_passstart[i] + ((passw[i] && passh[i]) ? passh[i] * (1 + (passw[i] * bpp + 7) / 8) : 0); /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
80002df4:	6c 0b       	ld.w	r11,r6[0x0]
80002df6:	58 0b       	cp.w	r11,0
80002df8:	c0 50       	breq	80002e02 <Adam7_getpassvalues+0x356>
80002dfa:	40 53       	lddsp	r3,sp[0x14]
80002dfc:	66 05       	ld.w	r5,r3[0x0]
80002dfe:	58 05       	cp.w	r5,0
80002e00:	c7 b1       	brne	80002ef6 <Adam7_getpassvalues+0x44a>
80002e02:	30 0b       	mov	r11,0
80002e04:	18 0b       	add	r11,r12
80002e06:	95 6b       	st.w	r10[0x18],r11
     padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7) / 8); /*bits padded if needed to fill full byte at end of each scanline*/
80002e08:	60 0c       	ld.w	r12,r0[0x0]
80002e0a:	6c 0b       	ld.w	r11,r6[0x0]
80002e0c:	40 52       	lddsp	r2,sp[0x14]
80002e0e:	ee 0b 02 4b 	mul	r11,r7,r11
80002e12:	64 03       	ld.w	r3,r2[0x0]
80002e14:	2f 9b       	sub	r11,-7
80002e16:	a3 9b       	lsr	r11,0x3
80002e18:	a7 3b       	mul	r11,r3
80002e1a:	18 0b       	add	r11,r12
80002e1c:	93 6b       	st.w	r9[0x18],r11
     passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7) / 8; /*only padded at end of reduced image*/
80002e1e:	68 0b       	ld.w	r11,r4[0x0]
80002e20:	6c 06       	ld.w	r6,r6[0x0]
80002e22:	64 03       	ld.w	r3,r2[0x0]
80002e24:	ee 06 02 46 	mul	r6,r7,r6
80002e28:	a7 36       	mul	r6,r3
80002e2a:	2f 96       	sub	r6,-7
80002e2c:	a3 96       	lsr	r6,0x3
80002e2e:	16 06       	add	r6,r11
80002e30:	91 66       	st.w	r8[0x18],r6
   }
 
   filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
   for(i = 0; i < 7; i++)
   {
     filter_passstart[i + 1] = filter_passstart[i] + ((passw[i] && passh[i]) ? passh[i] * (1 + (passw[i] * bpp + 7) / 8) : 0); /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
80002e32:	f4 c5 ff e8 	sub	r5,r10,-24
80002e36:	40 21       	lddsp	r1,sp[0x8]
     padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7) / 8); /*bits padded if needed to fill full byte at end of each scanline*/
80002e38:	f2 cc ff e8 	sub	r12,r9,-24
     passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7) / 8; /*only padded at end of reduced image*/
80002e3c:	f0 cb ff e8 	sub	r11,r8,-24
   }
 
   filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
   for(i = 0; i < 7; i++)
   {
     filter_passstart[i + 1] = filter_passstart[i] + ((passw[i] && passh[i]) ? passh[i] * (1 + (passw[i] * bpp + 7) / 8) : 0); /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
80002e40:	6a 05       	ld.w	r5,r5[0x0]
80002e42:	62 06       	ld.w	r6,r1[0x0]
80002e44:	58 06       	cp.w	r6,0
80002e46:	c0 50       	breq	80002e50 <Adam7_getpassvalues+0x3a4>
80002e48:	40 00       	lddsp	r0,sp[0x0]
80002e4a:	60 04       	ld.w	r4,r0[0x0]
80002e4c:	58 04       	cp.w	r4,0
80002e4e:	c4 d1       	brne	80002ee8 <Adam7_getpassvalues+0x43c>
80002e50:	30 06       	mov	r6,0
80002e52:	0a 06       	add	r6,r5
80002e54:	95 76       	st.w	r10[0x1c],r6
     padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7) / 8); /*bits padded if needed to fill full byte at end of each scanline*/
80002e56:	78 0c       	ld.w	r12,r12[0x0]
80002e58:	40 2e       	lddsp	lr,sp[0x8]
80002e5a:	40 05       	lddsp	r5,sp[0x0]
80002e5c:	7c 0a       	ld.w	r10,lr[0x0]
80002e5e:	6a 06       	ld.w	r6,r5[0x0]
80002e60:	ee 0a 02 4a 	mul	r10,r7,r10
80002e64:	2f 9a       	sub	r10,-7
80002e66:	a3 9a       	lsr	r10,0x3
80002e68:	ad 3a       	mul	r10,r6
80002e6a:	18 0a       	add	r10,r12
80002e6c:	93 7a       	st.w	r9[0x1c],r10
     passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7) / 8; /*only padded at end of reduced image*/
80002e6e:	6a 0a       	ld.w	r10,r5[0x0]
80002e70:	7c 09       	ld.w	r9,lr[0x0]
80002e72:	ee 09 02 49 	mul	r9,r7,r9
80002e76:	b5 39       	mul	r9,r10
80002e78:	76 0a       	ld.w	r10,r11[0x0]
80002e7a:	2f 99       	sub	r9,-7
80002e7c:	a3 99       	lsr	r9,0x3
80002e7e:	14 09       	add	r9,r10
80002e80:	91 79       	st.w	r8[0x1c],r9
   }
 }
80002e82:	2f 2d       	sub	sp,-56
80002e84:	d8 32       	popm	r0-r7,pc
80002e86:	02 90       	mov	r0,r1
80002e88:	40 01       	lddsp	r1,sp[0x0]
80002e8a:	83 00       	st.w	r1[0x0],r0
80002e8c:	40 b1       	lddsp	r1,sp[0x2c]
80002e8e:	cd 1a       	rjmp	80002c30 <Adam7_getpassvalues+0x184>
   /*calculate width and height in pixels of each pass*/
   for(i = 0; i < 7; i++)
   {
     passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
     passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
     if(passw[i] == 0) passh[i] = 0;
80002e90:	40 50       	lddsp	r0,sp[0x14]
80002e92:	81 01       	st.w	r0[0x0],r1
     if(passh[i] == 0) passw[i] = 0;
80002e94:	40 10       	lddsp	r0,sp[0x4]
80002e96:	58 00       	cp.w	r0,0
80002e98:	e0 0e 17 00 	moveq	lr,r0
80002e9c:	ca 4a       	rjmp	80002be4 <Adam7_getpassvalues+0x138>
80002e9e:	02 90       	mov	r0,r1
   /*calculate width and height in pixels of each pass*/
   for(i = 0; i < 7; i++)
   {
     passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
     passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
     if(passw[i] == 0) passh[i] = 0;
80002ea0:	40 a1       	lddsp	r1,sp[0x28]
80002ea2:	83 00       	st.w	r1[0x0],r0
     if(passh[i] == 0) passw[i] = 0;
80002ea4:	40 11       	lddsp	r1,sp[0x4]
80002ea6:	58 01       	cp.w	r1,0
80002ea8:	e2 06 17 00 	moveq	r6,r1
80002eac:	fe 9f fe 81 	bral	80002bae <Adam7_getpassvalues+0x102>
   /*calculate width and height in pixels of each pass*/
   for(i = 0; i < 7; i++)
   {
     passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
     passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
     if(passw[i] == 0) passh[i] = 0;
80002eb0:	40 c0       	lddsp	r0,sp[0x30]
80002eb2:	81 06       	st.w	r0[0x0],r6
     if(passh[i] == 0) passw[i] = 0;
80002eb4:	40 66       	lddsp	r6,sp[0x18]
80002eb6:	58 06       	cp.w	r6,0
80002eb8:	ec 01 17 00 	moveq	r1,r6
80002ebc:	fe 9f fe 5c 	bral	80002b74 <Adam7_getpassvalues+0xc8>
   /*calculate width and height in pixels of each pass*/
   for(i = 0; i < 7; i++)
   {
     passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
     passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
     if(passw[i] == 0) passh[i] = 0;
80002ec0:	40 d6       	lddsp	r6,sp[0x34]
     if(passh[i] == 0) passw[i] = 0;
80002ec2:	58 00       	cp.w	r0,0
80002ec4:	e0 04 17 00 	moveq	r4,r0
   /*calculate width and height in pixels of each pass*/
   for(i = 0; i < 7; i++)
   {
     passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
     passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
     if(passw[i] == 0) passh[i] = 0;
80002ec8:	8d 00       	st.w	r6[0x0],r0
80002eca:	fe 9f fe 3b 	bral	80002b40 <Adam7_getpassvalues+0x94>
80002ece:	40 92       	lddsp	r2,sp[0x24]
     if(passh[i] == 0) passw[i] = 0;
80002ed0:	58 00       	cp.w	r0,0
80002ed2:	e0 04 17 00 	moveq	r4,r0
   /*calculate width and height in pixels of each pass*/
   for(i = 0; i < 7; i++)
   {
     passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
     passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
     if(passw[i] == 0) passh[i] = 0;
80002ed6:	85 00       	st.w	r2[0x0],r0
80002ed8:	fe 9f fe 1b 	bral	80002b0e <Adam7_getpassvalues+0x62>
80002edc:	97 02       	st.w	r11[0x0],r2
     if(passh[i] == 0) passw[i] = 0;
80002ede:	58 02       	cp.w	r2,0
80002ee0:	e4 04 17 00 	moveq	r4,r2
80002ee4:	fe 9f fd fe 	bral	80002ae0 <Adam7_getpassvalues+0x34>
   }
 
   filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
   for(i = 0; i < 7; i++)
   {
     filter_passstart[i + 1] = filter_passstart[i] + ((passw[i] && passh[i]) ? passh[i] * (1 + (passw[i] * bpp + 7) / 8) : 0); /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
80002ee8:	ee 06 02 46 	mul	r6,r7,r6
80002eec:	2f 96       	sub	r6,-7
80002eee:	a3 96       	lsr	r6,0x3
80002ef0:	2f f6       	sub	r6,-1
80002ef2:	a9 36       	mul	r6,r4
80002ef4:	ca fb       	rjmp	80002e52 <Adam7_getpassvalues+0x3a6>
80002ef6:	ee 0b 02 4b 	mul	r11,r7,r11
80002efa:	2f 9b       	sub	r11,-7
80002efc:	a3 9b       	lsr	r11,0x3
80002efe:	2f fb       	sub	r11,-1
80002f00:	ab 3b       	mul	r11,r5
80002f02:	c8 1b       	rjmp	80002e04 <Adam7_getpassvalues+0x358>
80002f04:	ee 0b 02 4b 	mul	r11,r7,r11
80002f08:	2f 9b       	sub	r11,-7
80002f0a:	a3 9b       	lsr	r11,0x3
80002f0c:	2f fb       	sub	r11,-1
80002f0e:	a7 3b       	mul	r11,r3
80002f10:	c5 2b       	rjmp	80002db4 <Adam7_getpassvalues+0x308>
80002f12:	ee 0b 02 4b 	mul	r11,r7,r11
80002f16:	2f 9b       	sub	r11,-7
80002f18:	a3 9b       	lsr	r11,0x3
80002f1a:	2f fb       	sub	r11,-1
80002f1c:	a1 3b       	mul	r11,r0
80002f1e:	c2 3b       	rjmp	80002d64 <Adam7_getpassvalues+0x2b8>
80002f20:	ee 0b 02 4b 	mul	r11,r7,r11
80002f24:	2f 9b       	sub	r11,-7
80002f26:	a3 9b       	lsr	r11,0x3
80002f28:	2f fb       	sub	r11,-1
80002f2a:	a3 3b       	mul	r11,r1
80002f2c:	cf 1a       	rjmp	80002d0e <Adam7_getpassvalues+0x262>
80002f2e:	ee 0b 02 4b 	mul	r11,r7,r11
80002f32:	2f 9b       	sub	r11,-7
80002f34:	a3 9b       	lsr	r11,0x3
80002f36:	2f fb       	sub	r11,-1
80002f38:	a3 3b       	mul	r11,r1
80002f3a:	cb 8a       	rjmp	80002caa <Adam7_getpassvalues+0x1fe>
80002f3c:	ee 00 02 40 	mul	r0,r7,r0
80002f40:	2f 90       	sub	r0,-7
80002f42:	a3 90       	lsr	r0,0x3
80002f44:	2f f0       	sub	r0,-1
80002f46:	bd 30       	mul	r0,lr
80002f48:	fe 9f fe 83 	bral	80002c4e <Adam7_getpassvalues+0x1a2>

80002f4c <unfilterScanline>:
 
   decoder->error = checkColorValidity(decoder->infoPng.color.colorType, decoder->infoPng.color.bitDepth);
 }
 
 static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon, size_t bytewidth, unsigned char filterType, size_t length)
 {
80002f4c:	d4 31       	pushm	r0-r7,lr
80002f4e:	20 2d       	sub	sp,8
   the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead
   recon and scanline MAY be the same memory address! precon must be disjoint.
   */
 
   size_t i;
   switch(filterType)
80002f50:	30 27       	mov	r7,2
 
   decoder->error = checkColorValidity(decoder->infoPng.color.colorType, decoder->infoPng.color.bitDepth);
 }
 
 static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon, size_t bytewidth, unsigned char filterType, size_t length)
 {
80002f52:	40 be       	lddsp	lr,sp[0x2c]
   the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead
   recon and scanline MAY be the same memory address! precon must be disjoint.
   */
 
   size_t i;
   switch(filterType)
80002f54:	ee 08 18 00 	cp.b	r8,r7
80002f58:	e0 80 01 6a 	breq	8000322c <unfilterScanline+0x2e0>
80002f5c:	e0 88 00 0f 	brls	80002f7a <unfilterScanline+0x2e>
80002f60:	30 37       	mov	r7,3
80002f62:	ee 08 18 00 	cp.b	r8,r7
80002f66:	e0 80 01 00 	breq	80003166 <unfilterScanline+0x21a>
80002f6a:	30 47       	mov	r7,4
80002f6c:	ee 08 18 00 	cp.b	r8,r7
80002f70:	e0 80 00 a5 	breq	800030ba <unfilterScanline+0x16e>
80002f74:	32 4c       	mov	r12,36
       }
       break;
     default: return 36; /*error: unexisting filter type given*/
   }
   return 0;
 }
80002f76:	2f ed       	sub	sp,-8
80002f78:	d8 32       	popm	r0-r7,pc
   the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead
   recon and scanline MAY be the same memory address! precon must be disjoint.
   */
 
   size_t i;
   switch(filterType)
80002f7a:	30 0a       	mov	r10,0
80002f7c:	f4 08 18 00 	cp.b	r8,r10
80002f80:	e0 80 01 20 	breq	800031c0 <unfilterScanline+0x274>
80002f84:	30 17       	mov	r7,1
80002f86:	ee 08 18 00 	cp.b	r8,r7
80002f8a:	cf 51       	brne	80002f74 <unfilterScanline+0x28>
   {
     case 0:
       for(i = 0; i < length; i++) recon[i] = scanline[i];
       break;
     case 1:
       for(i =         0; i < bytewidth; i++) recon[i] = scanline[i];
80002f8c:	58 09       	cp.w	r9,0
80002f8e:	c3 40       	breq	80002ff6 <unfilterScanline+0xaa>
 
   size_t i;
   switch(filterType)
   {
     case 0:
       for(i = 0; i < length; i++) recon[i] = scanline[i];
80002f90:	f7 ec 10 08 	or	r8,r11,r12
80002f94:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80002f98:	5f 08       	sreq	r8
80002f9a:	58 39       	cp.w	r9,3
80002f9c:	5f b7       	srhi	r7
80002f9e:	10 67       	and	r7,r8
80002fa0:	f6 c8 ff fc 	sub	r8,r11,-4
80002fa4:	10 3c       	cp.w	r12,r8
80002fa6:	5f b6       	srhi	r6
80002fa8:	f8 c8 ff fc 	sub	r8,r12,-4
80002fac:	10 3b       	cp.w	r11,r8
80002fae:	5f b8       	srhi	r8
80002fb0:	ed e8 10 08 	or	r8,r6,r8
80002fb4:	ef e8 00 08 	and	r8,r7,r8
80002fb8:	f4 08 18 00 	cp.b	r8,r10
80002fbc:	e0 80 01 90 	breq	800032dc <unfilterScanline+0x390>
80002fc0:	f2 05 16 02 	lsr	r5,r9,0x2
80002fc4:	ea 0a 15 02 	lsl	r10,r5,0x2
80002fc8:	c0 d0       	breq	80002fe2 <unfilterScanline+0x96>
80002fca:	30 08       	mov	r8,0
80002fcc:	10 97       	mov	r7,r8
       break;
     case 1:
       for(i =         0; i < bytewidth; i++) recon[i] = scanline[i];
80002fce:	f6 08 03 06 	ld.w	r6,r11[r8]
80002fd2:	f8 08 09 06 	st.w	r12[r8],r6
80002fd6:	2f f7       	sub	r7,-1
80002fd8:	2f c8       	sub	r8,-4
80002fda:	0a 37       	cp.w	r7,r5
80002fdc:	cf 93       	brcs	80002fce <unfilterScanline+0x82>
80002fde:	14 39       	cp.w	r9,r10
80002fe0:	c0 b0       	breq	80002ff6 <unfilterScanline+0xaa>
80002fe2:	f6 0a 00 07 	add	r7,r11,r10
80002fe6:	f8 0a 00 08 	add	r8,r12,r10
80002fea:	0f 36       	ld.ub	r6,r7++
80002fec:	10 c6       	st.b	r8++,r6
80002fee:	2f fa       	sub	r10,-1
80002ff0:	14 39       	cp.w	r9,r10
80002ff2:	fe 9b ff fc 	brhi	80002fea <unfilterScanline+0x9e>
       for(i = bytewidth; i <    length; i++) recon[i] = scanline[i] + recon[i - bytewidth];
80002ff6:	12 3e       	cp.w	lr,r9
80002ff8:	e0 88 00 5e 	brls	800030b4 <unfilterScanline+0x168>
   if(decoder->infoPng.interlaceMethod > 1)    { decoder->error = 34; return; } /*error: only interlace methods 0 and 1 exist in the specification*/
 
   decoder->error = checkColorValidity(decoder->infoPng.color.colorType, decoder->infoPng.color.bitDepth);
 }
 
 static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon, size_t bytewidth, unsigned char filterType, size_t length)
80002ffc:	f8 09 00 04 	add	r4,r12,r9
80003000:	e8 c8 ff fc 	sub	r8,r4,-4
80003004:	f6 09 00 03 	add	r3,r11,r9
80003008:	10 3c       	cp.w	r12,r8
8000300a:	5f b7       	srhi	r7
8000300c:	10 33       	cp.w	r3,r8
8000300e:	5f b6       	srhi	r6
80003010:	e7 e4 10 08 	or	r8,r3,r4
80003014:	f9 e8 10 08 	or	r8,r12,r8
80003018:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000301c:	5f 08       	sreq	r8
8000301e:	fc 09 01 02 	sub	r2,lr,r9
80003022:	58 32       	cp.w	r2,3
80003024:	5f ba       	srhi	r10
80003026:	10 6a       	and	r10,r8
80003028:	e6 c8 ff fc 	sub	r8,r3,-4
8000302c:	10 34       	cp.w	r4,r8
8000302e:	5f b8       	srhi	r8
80003030:	0c 48       	or	r8,r6
80003032:	10 6a       	and	r10,r8
80003034:	f8 c8 ff fc 	sub	r8,r12,-4
80003038:	10 34       	cp.w	r4,r8
8000303a:	5f b8       	srhi	r8
8000303c:	0e 48       	or	r8,r7
8000303e:	f5 e8 00 08 	and	r8,r10,r8
80003042:	e0 80 01 62 	breq	80003306 <unfilterScanline+0x3ba>
80003046:	e4 00 16 02 	lsr	r0,r2,0x2
8000304a:	e0 01 15 02 	lsl	r1,r0,0x2
8000304e:	e0 80 02 bd 	breq	800035c8 <unfilterScanline+0x67c>
80003052:	30 08       	mov	r8,0
80003054:	10 97       	mov	r7,r8
80003056:	f8 08 03 05 	ld.w	r5,r12[r8]
8000305a:	e6 08 03 06 	ld.w	r6,r3[r8]
     case 0:
       for(i = 0; i < length; i++) recon[i] = scanline[i];
       break;
     case 1:
       for(i =         0; i < bytewidth; i++) recon[i] = scanline[i];
       for(i = bytewidth; i <    length; i++) recon[i] = scanline[i] + recon[i - bytewidth];
8000305e:	eb e6 20 0a 	eor	r10,r5,r6
80003062:	e4 15 7f 7f 	andh	r5,0x7f7f
80003066:	e0 15 7f 7f 	andl	r5,0x7f7f
8000306a:	e4 1a 80 80 	andh	r10,0x8080
8000306e:	e0 1a 80 80 	andl	r10,0x8080
80003072:	e4 16 7f 7f 	andh	r6,0x7f7f
80003076:	e0 16 7f 7f 	andl	r6,0x7f7f
8000307a:	ea 06 00 06 	add	r6,r5,r6
8000307e:	ed ea 20 0a 	eor	r10,r6,r10
80003082:	e8 08 09 0a 	st.w	r4[r8],r10
80003086:	2f f7       	sub	r7,-1
80003088:	2f c8       	sub	r8,-4
8000308a:	00 37       	cp.w	r7,r0
8000308c:	ce 53       	brcs	80003056 <unfilterScanline+0x10a>
8000308e:	e2 09 00 08 	add	r8,r1,r9
80003092:	02 32       	cp.w	r2,r1
80003094:	c1 00       	breq	800030b4 <unfilterScanline+0x168>
80003096:	f0 09 01 09 	sub	r9,r8,r9
8000309a:	10 0b       	add	r11,r8
8000309c:	f8 09 00 09 	add	r9,r12,r9
800030a0:	10 0c       	add	r12,r8
800030a2:	13 37       	ld.ub	r7,r9++
800030a4:	17 3a       	ld.ub	r10,r11++
800030a6:	ee 0a 00 0a 	add	r10,r7,r10
800030aa:	18 ca       	st.b	r12++,r10
800030ac:	2f f8       	sub	r8,-1
800030ae:	10 3e       	cp.w	lr,r8
800030b0:	fe 9b ff f9 	brhi	800030a2 <unfilterScanline+0x156>
         for(i = bytewidth; i <    length; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
       }
       else
       {
         for(i =         0; i < bytewidth; i++) recon[i] = scanline[i];
         for(i = bytewidth; i <    length; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(recon[i - bytewidth], 0, 0));
800030b4:	30 0c       	mov	r12,0
       }
       break;
     default: return 36; /*error: unexisting filter type given*/
   }
   return 0;
 }
800030b6:	2f ed       	sub	sp,-8
800030b8:	d8 32       	popm	r0-r7,pc
         for(i =         0; i < bytewidth; i++) recon[i] = scanline[i];
         for(i = bytewidth; i <    length; i++) recon[i] = scanline[i] + recon[i - bytewidth] / 2;
       }
       break;
     case 4:
       if(precon)
800030ba:	58 0a       	cp.w	r10,0
800030bc:	e0 80 01 d4 	breq	80003464 <unfilterScanline+0x518>
       {
         for(i =         0; i < bytewidth; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(0, precon[i], 0));
800030c0:	58 09       	cp.w	r9,0
800030c2:	c1 20       	breq	800030e6 <unfilterScanline+0x19a>
800030c4:	30 08       	mov	r8,0
800030c6:	f4 08 07 07 	ld.ub	r7,r10[r8]
 
 /*Paeth predicter, used by PNG filter type 4*/
 static int paethPredictor(int a, int b, int c)
 {
   int p = a + b - c;
   int pa = p > a ? p - a : a - p;
800030ca:	0e 96       	mov	r6,r7
800030cc:	5c 56       	castu.b	r6
       }
       break;
     case 4:
       if(precon)
       {
         for(i =         0; i < bytewidth; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(0, precon[i], 0));
800030ce:	f6 08 07 05 	ld.ub	r5,r11[r8]
 
 /*Paeth predicter, used by PNG filter type 4*/
 static int paethPredictor(int a, int b, int c)
 {
   int p = a + b - c;
   int pa = p > a ? p - a : a - p;
800030d2:	58 07       	cp.w	r7,0
800030d4:	ee 06 17 00 	moveq	r6,r7
       }
       break;
     case 4:
       if(precon)
       {
         for(i =         0; i < bytewidth; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(0, precon[i], 0));
800030d8:	0a 06       	add	r6,r5
800030da:	f8 08 0b 06 	st.b	r12[r8],r6
800030de:	2f f8       	sub	r8,-1
800030e0:	10 39       	cp.w	r9,r8
800030e2:	fe 9b ff f2 	brhi	800030c6 <unfilterScanline+0x17a>
         for(i = bytewidth; i <    length; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
800030e6:	12 3e       	cp.w	lr,r9
800030e8:	fe 98 ff e6 	brls	800030b4 <unfilterScanline+0x168>
800030ec:	f6 09 00 04 	add	r4,r11,r9
800030f0:	f4 09 00 05 	add	r5,r10,r9
800030f4:	30 0b       	mov	r11,0
800030f6:	f8 09 00 02 	add	r2,r12,r9
   int p = a + b - c;
   int pa = p > a ? p - a : a - p;
   int pb = p > b ? p - b : b - p;
   int pc = p > c ? p - c : c - p;
 
   if(pa <= pb && pa <= pc) return a;
800030fa:	50 0c       	stdsp	sp[0x0],r12
800030fc:	50 1a       	stdsp	sp[0x4],r10
800030fe:	c0 c8       	rjmp	80003116 <unfilterScanline+0x1ca>
80003100:	18 98       	mov	r8,r12
       break;
     case 4:
       if(precon)
       {
         for(i =         0; i < bytewidth; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(0, precon[i], 0));
         for(i = bytewidth; i <    length; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
80003102:	02 08       	add	r8,r1
80003104:	04 c8       	st.b	r2++,r8
80003106:	2f fb       	sub	r11,-1
80003108:	2f f4       	sub	r4,-1
8000310a:	2f f5       	sub	r5,-1
8000310c:	f6 09 00 08 	add	r8,r11,r9
80003110:	10 3e       	cp.w	lr,r8
80003112:	fe 98 ff d1 	brls	800030b4 <unfilterScanline+0x168>
80003116:	40 07       	lddsp	r7,sp[0x0]
80003118:	40 18       	lddsp	r8,sp[0x4]
8000311a:	ee 0b 07 0c 	ld.ub	r12,r7[r11]
8000311e:	f0 0b 07 0a 	ld.ub	r10,r8[r11]
80003122:	0b 88       	ld.ub	r8,r5[0x0]
 }
 
 /*Paeth predicter, used by PNG filter type 4*/
 static int paethPredictor(int a, int b, int c)
 {
   int p = a + b - c;
80003124:	f8 08 00 06 	add	r6,r12,r8
80003128:	14 16       	sub	r6,r10
   int pa = p > a ? p - a : a - p;
8000312a:	0c 3c       	cp.w	r12,r6
8000312c:	ed dc e5 17 	sublt	r7,r6,r12
80003130:	f9 d6 e4 17 	subge	r7,r12,r6
   int pb = p > b ? p - b : b - p;
80003134:	0c 38       	cp.w	r8,r6
80003136:	ed d8 e5 13 	sublt	r3,r6,r8
8000313a:	f1 d6 e4 13 	subge	r3,r8,r6
   int pc = p > c ? p - c : c - p;
8000313e:	0c 3a       	cp.w	r10,r6
80003140:	ed da e5 16 	sublt	r6,r6,r10
80003144:	f5 d6 e4 16 	subge	r6,r10,r6
 
   if(pa <= pb && pa <= pc) return a;
80003148:	06 37       	cp.w	r7,r3
8000314a:	5f a0       	srle	r0
8000314c:	0c 37       	cp.w	r7,r6
8000314e:	5f a7       	srle	r7
       break;
     case 4:
       if(precon)
       {
         for(i =         0; i < bytewidth; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(0, precon[i], 0));
         for(i = bytewidth; i <    length; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
80003150:	09 81       	ld.ub	r1,r4[0x0]
   int p = a + b - c;
   int pa = p > a ? p - a : a - p;
   int pb = p > b ? p - b : b - p;
   int pc = p > c ? p - c : c - p;
 
   if(pa <= pb && pa <= pc) return a;
80003152:	ef e0 00 00 	and	r0,r7,r0
80003156:	30 07       	mov	r7,0
80003158:	ee 00 18 00 	cp.b	r0,r7
8000315c:	cd 21       	brne	80003100 <unfilterScanline+0x1b4>
   else if(pb <= pc) return b;
8000315e:	0c 33       	cp.w	r3,r6
80003160:	f4 08 17 90 	movgt	r8,r10
80003164:	cc fb       	rjmp	80003102 <unfilterScanline+0x1b6>
     case 2:
       if(precon) for(i = 0; i < length; i++) recon[i] = scanline[i] + precon[i];
       else       for(i = 0; i < length; i++) recon[i] = scanline[i];
       break;
     case 3:
       if(precon)
80003166:	58 0a       	cp.w	r10,0
80003168:	e0 80 01 2a 	breq	800033bc <unfilterScanline+0x470>
       {
         for(i =         0; i < bytewidth; i++) recon[i] = scanline[i] + precon[i] / 2;
8000316c:	58 09       	cp.w	r9,0
8000316e:	c0 f0       	breq	8000318c <unfilterScanline+0x240>
80003170:	30 08       	mov	r8,0
80003172:	f4 08 07 07 	ld.ub	r7,r10[r8]
80003176:	f6 08 07 06 	ld.ub	r6,r11[r8]
8000317a:	a1 97       	lsr	r7,0x1
8000317c:	ec 07 00 07 	add	r7,r6,r7
80003180:	f8 08 0b 07 	st.b	r12[r8],r7
80003184:	2f f8       	sub	r8,-1
80003186:	10 39       	cp.w	r9,r8
80003188:	fe 9b ff f5 	brhi	80003172 <unfilterScanline+0x226>
         for(i = bytewidth; i <    length; i++) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) / 2);
8000318c:	12 3e       	cp.w	lr,r9
8000318e:	fe 98 ff 93 	brls	800030b4 <unfilterScanline+0x168>
80003192:	12 0b       	add	r11,r9
80003194:	12 0a       	add	r10,r9
80003196:	f8 09 00 07 	add	r7,r12,r9
8000319a:	30 08       	mov	r8,0
8000319c:	15 35       	ld.ub	r5,r10++
8000319e:	f8 08 07 06 	ld.ub	r6,r12[r8]
800031a2:	ea 06 00 06 	add	r6,r5,r6
800031a6:	17 35       	ld.ub	r5,r11++
800031a8:	a1 56       	asr	r6,0x1
800031aa:	ea 06 00 06 	add	r6,r5,r6
800031ae:	0e c6       	st.b	r7++,r6
800031b0:	2f f8       	sub	r8,-1
800031b2:	f0 09 00 06 	add	r6,r8,r9
800031b6:	0c 3e       	cp.w	lr,r6
800031b8:	fe 9b ff f2 	brhi	8000319c <unfilterScanline+0x250>
         for(i = bytewidth; i <    length; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
       }
       else
       {
         for(i =         0; i < bytewidth; i++) recon[i] = scanline[i];
         for(i = bytewidth; i <    length; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(recon[i - bytewidth], 0, 0));
800031bc:	30 0c       	mov	r12,0
800031be:	c7 cb       	rjmp	800030b6 <unfilterScanline+0x16a>
 
   size_t i;
   switch(filterType)
   {
     case 0:
       for(i = 0; i < length; i++) recon[i] = scanline[i];
800031c0:	58 0e       	cp.w	lr,0
800031c2:	fe 90 ff 79 	breq	800030b4 <unfilterScanline+0x168>
800031c6:	f7 ec 10 08 	or	r8,r11,r12
800031ca:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800031ce:	5f 08       	sreq	r8
800031d0:	58 3e       	cp.w	lr,3
800031d2:	5f b9       	srhi	r9
800031d4:	10 69       	and	r9,r8
800031d6:	f6 c8 ff fc 	sub	r8,r11,-4
800031da:	10 3c       	cp.w	r12,r8
800031dc:	5f b7       	srhi	r7
800031de:	f8 c8 ff fc 	sub	r8,r12,-4
800031e2:	10 3b       	cp.w	r11,r8
800031e4:	5f b8       	srhi	r8
800031e6:	ef e8 10 08 	or	r8,r7,r8
800031ea:	f3 e8 00 08 	and	r8,r9,r8
800031ee:	f4 08 18 00 	cp.b	r8,r10
800031f2:	c7 f0       	breq	800032f0 <unfilterScanline+0x3a4>
800031f4:	fc 06 16 02 	lsr	r6,lr,0x2
800031f8:	ec 09 15 02 	lsl	r9,r6,0x2
800031fc:	c0 e0       	breq	80003218 <unfilterScanline+0x2cc>
800031fe:	30 08       	mov	r8,0
80003200:	10 9a       	mov	r10,r8
80003202:	f6 08 03 07 	ld.w	r7,r11[r8]
80003206:	f8 08 09 07 	st.w	r12[r8],r7
8000320a:	2f fa       	sub	r10,-1
8000320c:	2f c8       	sub	r8,-4
8000320e:	0c 3a       	cp.w	r10,r6
80003210:	cf 93       	brcs	80003202 <unfilterScanline+0x2b6>
80003212:	12 3e       	cp.w	lr,r9
80003214:	fe 90 ff 50 	breq	800030b4 <unfilterScanline+0x168>
80003218:	12 0b       	add	r11,r9
8000321a:	12 0c       	add	r12,r9
8000321c:	17 38       	ld.ub	r8,r11++
8000321e:	18 c8       	st.b	r12++,r8
80003220:	2f f9       	sub	r9,-1
80003222:	12 3e       	cp.w	lr,r9
80003224:	fe 9b ff fc 	brhi	8000321c <unfilterScanline+0x2d0>
         for(i = bytewidth; i <    length; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
       }
       else
       {
         for(i =         0; i < bytewidth; i++) recon[i] = scanline[i];
         for(i = bytewidth; i <    length; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(recon[i - bytewidth], 0, 0));
80003228:	30 0c       	mov	r12,0
8000322a:	c4 6b       	rjmp	800030b6 <unfilterScanline+0x16a>
     case 1:
       for(i =         0; i < bytewidth; i++) recon[i] = scanline[i];
       for(i = bytewidth; i <    length; i++) recon[i] = scanline[i] + recon[i - bytewidth];
       break;
     case 2:
       if(precon) for(i = 0; i < length; i++) recon[i] = scanline[i] + precon[i];
8000322c:	58 0a       	cp.w	r10,0
8000322e:	e0 80 00 8a 	breq	80003342 <unfilterScanline+0x3f6>
80003232:	58 0e       	cp.w	lr,0
80003234:	fe 90 ff 40 	breq	800030b4 <unfilterScanline+0x168>
   if(decoder->infoPng.interlaceMethod > 1)    { decoder->error = 34; return; } /*error: only interlace methods 0 and 1 exist in the specification*/
 
   decoder->error = checkColorValidity(decoder->infoPng.color.colorType, decoder->infoPng.color.bitDepth);
 }
 
 static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon, size_t bytewidth, unsigned char filterType, size_t length)
80003238:	f8 c8 ff fc 	sub	r8,r12,-4
8000323c:	10 3a       	cp.w	r10,r8
8000323e:	5f b7       	srhi	r7
80003240:	10 3b       	cp.w	r11,r8
80003242:	5f b6       	srhi	r6
80003244:	f7 ec 10 08 	or	r8,r11,r12
80003248:	f5 e8 10 08 	or	r8,r10,r8
8000324c:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80003250:	5f 08       	sreq	r8
80003252:	58 3e       	cp.w	lr,3
80003254:	5f b9       	srhi	r9
80003256:	10 69       	and	r9,r8
80003258:	f6 c8 ff fc 	sub	r8,r11,-4
8000325c:	10 3c       	cp.w	r12,r8
8000325e:	5f b8       	srhi	r8
80003260:	0c 48       	or	r8,r6
80003262:	10 69       	and	r9,r8
80003264:	f4 c8 ff fc 	sub	r8,r10,-4
80003268:	10 3c       	cp.w	r12,r8
8000326a:	5f b8       	srhi	r8
8000326c:	0e 48       	or	r8,r7
8000326e:	f3 e8 00 08 	and	r8,r9,r8
80003272:	c5 90       	breq	80003324 <unfilterScanline+0x3d8>
80003274:	fc 03 16 02 	lsr	r3,lr,0x2
80003278:	e6 07 15 02 	lsl	r7,r3,0x2
8000327c:	c2 20       	breq	800032c0 <unfilterScanline+0x374>
8000327e:	30 08       	mov	r8,0
80003280:	10 96       	mov	r6,r8
80003282:	f4 08 03 04 	ld.w	r4,r10[r8]
80003286:	f6 08 03 05 	ld.w	r5,r11[r8]
     case 1:
       for(i =         0; i < bytewidth; i++) recon[i] = scanline[i];
       for(i = bytewidth; i <    length; i++) recon[i] = scanline[i] + recon[i - bytewidth];
       break;
     case 2:
       if(precon) for(i = 0; i < length; i++) recon[i] = scanline[i] + precon[i];
8000328a:	eb e4 20 09 	eor	r9,r5,r4
8000328e:	e4 14 7f 7f 	andh	r4,0x7f7f
80003292:	e0 14 7f 7f 	andl	r4,0x7f7f
80003296:	e4 19 80 80 	andh	r9,0x8080
8000329a:	e0 19 80 80 	andl	r9,0x8080
8000329e:	e4 15 7f 7f 	andh	r5,0x7f7f
800032a2:	e0 15 7f 7f 	andl	r5,0x7f7f
800032a6:	e8 05 00 05 	add	r5,r4,r5
800032aa:	eb e9 20 09 	eor	r9,r5,r9
800032ae:	f8 08 09 09 	st.w	r12[r8],r9
800032b2:	2f f6       	sub	r6,-1
800032b4:	2f c8       	sub	r8,-4
800032b6:	06 36       	cp.w	r6,r3
800032b8:	ce 53       	brcs	80003282 <unfilterScanline+0x336>
800032ba:	0e 3e       	cp.w	lr,r7
800032bc:	fe 90 fe fc 	breq	800030b4 <unfilterScanline+0x168>
800032c0:	0e 0b       	add	r11,r7
800032c2:	0e 0a       	add	r10,r7
800032c4:	0e 0c       	add	r12,r7
800032c6:	15 39       	ld.ub	r9,r10++
800032c8:	17 38       	ld.ub	r8,r11++
800032ca:	f2 08 00 08 	add	r8,r9,r8
800032ce:	18 c8       	st.b	r12++,r8
800032d0:	2f f7       	sub	r7,-1
800032d2:	0e 3e       	cp.w	lr,r7
800032d4:	fe 9b ff f9 	brhi	800032c6 <unfilterScanline+0x37a>
         for(i = bytewidth; i <    length; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
       }
       else
       {
         for(i =         0; i < bytewidth; i++) recon[i] = scanline[i];
         for(i = bytewidth; i <    length; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(recon[i - bytewidth], 0, 0));
800032d8:	30 0c       	mov	r12,0
800032da:	ce ea       	rjmp	800030b6 <unfilterScanline+0x16a>
   {
     case 0:
       for(i = 0; i < length; i++) recon[i] = scanline[i];
       break;
     case 1:
       for(i =         0; i < bytewidth; i++) recon[i] = scanline[i];
800032dc:	30 08       	mov	r8,0
800032de:	f6 08 07 0a 	ld.ub	r10,r11[r8]
800032e2:	f8 08 0b 0a 	st.b	r12[r8],r10
800032e6:	2f f8       	sub	r8,-1
800032e8:	10 39       	cp.w	r9,r8
800032ea:	fe 9b ff fa 	brhi	800032de <unfilterScanline+0x392>
800032ee:	c8 4a       	rjmp	80002ff6 <unfilterScanline+0xaa>
 
   size_t i;
   switch(filterType)
   {
     case 0:
       for(i = 0; i < length; i++) recon[i] = scanline[i];
800032f0:	30 08       	mov	r8,0
800032f2:	f6 08 07 09 	ld.ub	r9,r11[r8]
800032f6:	f8 08 0b 09 	st.b	r12[r8],r9
800032fa:	2f f8       	sub	r8,-1
800032fc:	10 3e       	cp.w	lr,r8
800032fe:	fe 9b ff fa 	brhi	800032f2 <unfilterScanline+0x3a6>
         for(i = bytewidth; i <    length; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
       }
       else
       {
         for(i =         0; i < bytewidth; i++) recon[i] = scanline[i];
         for(i = bytewidth; i <    length; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(recon[i - bytewidth], 0, 0));
80003302:	30 0c       	mov	r12,0
80003304:	cd 9a       	rjmp	800030b6 <unfilterScanline+0x16a>
     case 0:
       for(i = 0; i < length; i++) recon[i] = scanline[i];
       break;
     case 1:
       for(i =         0; i < bytewidth; i++) recon[i] = scanline[i];
       for(i = bytewidth; i <    length; i++) recon[i] = scanline[i] + recon[i - bytewidth];
80003306:	30 08       	mov	r8,0
80003308:	f8 08 07 0b 	ld.ub	r11,r12[r8]
8000330c:	07 3a       	ld.ub	r10,r3++
8000330e:	f6 0a 00 0a 	add	r10,r11,r10
80003312:	08 ca       	st.b	r4++,r10
80003314:	2f f8       	sub	r8,-1
80003316:	f0 09 00 0a 	add	r10,r8,r9
8000331a:	14 3e       	cp.w	lr,r10
8000331c:	fe 9b ff f6 	brhi	80003308 <unfilterScanline+0x3bc>
         for(i = bytewidth; i <    length; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
       }
       else
       {
         for(i =         0; i < bytewidth; i++) recon[i] = scanline[i];
         for(i = bytewidth; i <    length; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(recon[i - bytewidth], 0, 0));
80003320:	30 0c       	mov	r12,0
80003322:	cc aa       	rjmp	800030b6 <unfilterScanline+0x16a>
     case 1:
       for(i =         0; i < bytewidth; i++) recon[i] = scanline[i];
       for(i = bytewidth; i <    length; i++) recon[i] = scanline[i] + recon[i - bytewidth];
       break;
     case 2:
       if(precon) for(i = 0; i < length; i++) recon[i] = scanline[i] + precon[i];
80003324:	30 08       	mov	r8,0
80003326:	f4 08 07 07 	ld.ub	r7,r10[r8]
8000332a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000332e:	ee 09 00 09 	add	r9,r7,r9
80003332:	f8 08 0b 09 	st.b	r12[r8],r9
80003336:	2f f8       	sub	r8,-1
80003338:	10 3e       	cp.w	lr,r8
8000333a:	fe 9b ff f6 	brhi	80003326 <unfilterScanline+0x3da>
         for(i = bytewidth; i <    length; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
       }
       else
       {
         for(i =         0; i < bytewidth; i++) recon[i] = scanline[i];
         for(i = bytewidth; i <    length; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(recon[i - bytewidth], 0, 0));
8000333e:	30 0c       	mov	r12,0
80003340:	cb ba       	rjmp	800030b6 <unfilterScanline+0x16a>
       for(i =         0; i < bytewidth; i++) recon[i] = scanline[i];
       for(i = bytewidth; i <    length; i++) recon[i] = scanline[i] + recon[i - bytewidth];
       break;
     case 2:
       if(precon) for(i = 0; i < length; i++) recon[i] = scanline[i] + precon[i];
       else       for(i = 0; i < length; i++) recon[i] = scanline[i];
80003342:	58 0e       	cp.w	lr,0
80003344:	fe 90 fe b8 	breq	800030b4 <unfilterScanline+0x168>
     case 1:
       for(i =         0; i < bytewidth; i++) recon[i] = scanline[i];
       for(i = bytewidth; i <    length; i++) recon[i] = scanline[i] + recon[i - bytewidth];
       break;
     case 2:
       if(precon) for(i = 0; i < length; i++) recon[i] = scanline[i] + precon[i];
80003348:	f7 ec 10 08 	or	r8,r11,r12
8000334c:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80003350:	5f 08       	sreq	r8
80003352:	58 3e       	cp.w	lr,3
80003354:	5f b9       	srhi	r9
80003356:	10 69       	and	r9,r8
80003358:	f6 c8 ff fc 	sub	r8,r11,-4
8000335c:	10 3c       	cp.w	r12,r8
8000335e:	5f b7       	srhi	r7
80003360:	f8 c8 ff fc 	sub	r8,r12,-4
80003364:	10 3b       	cp.w	r11,r8
80003366:	5f b8       	srhi	r8
80003368:	ef e8 10 08 	or	r8,r7,r8
8000336c:	10 69       	and	r9,r8
8000336e:	f4 09 18 00 	cp.b	r9,r10
80003372:	c1 c0       	breq	800033aa <unfilterScanline+0x45e>
80003374:	fc 06 16 02 	lsr	r6,lr,0x2
80003378:	ec 08 15 02 	lsl	r8,r6,0x2
8000337c:	c0 d0       	breq	80003396 <unfilterScanline+0x44a>
8000337e:	14 99       	mov	r9,r10
       else       for(i = 0; i < length; i++) recon[i] = scanline[i];
80003380:	f6 0a 03 07 	ld.w	r7,r11[r10]
80003384:	f8 0a 09 07 	st.w	r12[r10],r7
80003388:	2f f9       	sub	r9,-1
8000338a:	2f ca       	sub	r10,-4
8000338c:	0c 39       	cp.w	r9,r6
8000338e:	cf 93       	brcs	80003380 <unfilterScanline+0x434>
80003390:	10 3e       	cp.w	lr,r8
80003392:	fe 90 fe 91 	breq	800030b4 <unfilterScanline+0x168>
80003396:	10 0b       	add	r11,r8
80003398:	10 0c       	add	r12,r8
8000339a:	17 39       	ld.ub	r9,r11++
8000339c:	18 c9       	st.b	r12++,r9
8000339e:	2f f8       	sub	r8,-1
800033a0:	10 3e       	cp.w	lr,r8
800033a2:	fe 9b ff fc 	brhi	8000339a <unfilterScanline+0x44e>
         for(i = bytewidth; i <    length; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
       }
       else
       {
         for(i =         0; i < bytewidth; i++) recon[i] = scanline[i];
         for(i = bytewidth; i <    length; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(recon[i - bytewidth], 0, 0));
800033a6:	30 0c       	mov	r12,0
800033a8:	c8 7a       	rjmp	800030b6 <unfilterScanline+0x16a>
       for(i =         0; i < bytewidth; i++) recon[i] = scanline[i];
       for(i = bytewidth; i <    length; i++) recon[i] = scanline[i] + recon[i - bytewidth];
       break;
     case 2:
       if(precon) for(i = 0; i < length; i++) recon[i] = scanline[i] + precon[i];
       else       for(i = 0; i < length; i++) recon[i] = scanline[i];
800033aa:	f6 0a 07 08 	ld.ub	r8,r11[r10]
800033ae:	f8 0a 0b 08 	st.b	r12[r10],r8
800033b2:	2f fa       	sub	r10,-1
800033b4:	14 3e       	cp.w	lr,r10
800033b6:	fe 9b ff fa 	brhi	800033aa <unfilterScanline+0x45e>
800033ba:	c7 da       	rjmp	800030b4 <unfilterScanline+0x168>
         for(i =         0; i < bytewidth; i++) recon[i] = scanline[i] + precon[i] / 2;
         for(i = bytewidth; i <    length; i++) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) / 2);
       }
       else
       {
         for(i =         0; i < bytewidth; i++) recon[i] = scanline[i];
800033bc:	58 09       	cp.w	r9,0
800033be:	c3 30       	breq	80003424 <unfilterScanline+0x4d8>
       break;
     case 3:
       if(precon)
       {
         for(i =         0; i < bytewidth; i++) recon[i] = scanline[i] + precon[i] / 2;
         for(i = bytewidth; i <    length; i++) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) / 2);
800033c0:	f7 ec 10 08 	or	r8,r11,r12
800033c4:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800033c8:	5f 08       	sreq	r8
800033ca:	58 39       	cp.w	r9,3
800033cc:	5f b7       	srhi	r7
800033ce:	10 67       	and	r7,r8
800033d0:	f6 c8 ff fc 	sub	r8,r11,-4
800033d4:	10 3c       	cp.w	r12,r8
800033d6:	5f b6       	srhi	r6
800033d8:	f8 c8 ff fc 	sub	r8,r12,-4
800033dc:	10 3b       	cp.w	r11,r8
800033de:	5f b8       	srhi	r8
800033e0:	ed e8 10 08 	or	r8,r6,r8
800033e4:	ef e8 00 08 	and	r8,r7,r8
800033e8:	10 97       	mov	r7,r8
800033ea:	f4 07 18 00 	cp.b	r7,r10
800033ee:	c3 20       	breq	80003452 <unfilterScanline+0x506>
800033f0:	f2 05 16 02 	lsr	r5,r9,0x2
800033f4:	ea 08 15 02 	lsl	r8,r5,0x2
800033f8:	c0 c0       	breq	80003410 <unfilterScanline+0x4c4>
800033fa:	14 97       	mov	r7,r10
       }
       else
       {
         for(i =         0; i < bytewidth; i++) recon[i] = scanline[i];
800033fc:	f6 0a 03 06 	ld.w	r6,r11[r10]
80003400:	f8 0a 09 06 	st.w	r12[r10],r6
80003404:	2f f7       	sub	r7,-1
80003406:	2f ca       	sub	r10,-4
80003408:	0a 37       	cp.w	r7,r5
8000340a:	cf 93       	brcs	800033fc <unfilterScanline+0x4b0>
8000340c:	10 39       	cp.w	r9,r8
8000340e:	c0 b0       	breq	80003424 <unfilterScanline+0x4d8>
80003410:	f6 08 00 07 	add	r7,r11,r8
80003414:	f8 08 00 0a 	add	r10,r12,r8
80003418:	0f 36       	ld.ub	r6,r7++
8000341a:	14 c6       	st.b	r10++,r6
8000341c:	2f f8       	sub	r8,-1
8000341e:	10 39       	cp.w	r9,r8
80003420:	fe 9b ff fc 	brhi	80003418 <unfilterScanline+0x4cc>
         for(i = bytewidth; i <    length; i++) recon[i] = scanline[i] + recon[i - bytewidth] / 2;
80003424:	12 3e       	cp.w	lr,r9
80003426:	fe 98 fe 47 	brls	800030b4 <unfilterScanline+0x168>
8000342a:	12 0b       	add	r11,r9
8000342c:	f8 09 00 0a 	add	r10,r12,r9
80003430:	30 08       	mov	r8,0
80003432:	f8 08 07 07 	ld.ub	r7,r12[r8]
80003436:	17 36       	ld.ub	r6,r11++
80003438:	a1 97       	lsr	r7,0x1
8000343a:	ec 07 00 07 	add	r7,r6,r7
8000343e:	14 c7       	st.b	r10++,r7
80003440:	2f f8       	sub	r8,-1
80003442:	f0 09 00 07 	add	r7,r8,r9
80003446:	0e 3e       	cp.w	lr,r7
80003448:	fe 9b ff f5 	brhi	80003432 <unfilterScanline+0x4e6>
         for(i = bytewidth; i <    length; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
       }
       else
       {
         for(i =         0; i < bytewidth; i++) recon[i] = scanline[i];
         for(i = bytewidth; i <    length; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(recon[i - bytewidth], 0, 0));
8000344c:	30 0c       	mov	r12,0
8000344e:	fe 9f fe 34 	bral	800030b6 <unfilterScanline+0x16a>
         for(i =         0; i < bytewidth; i++) recon[i] = scanline[i] + precon[i] / 2;
         for(i = bytewidth; i <    length; i++) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) / 2);
       }
       else
       {
         for(i =         0; i < bytewidth; i++) recon[i] = scanline[i];
80003452:	f6 0a 07 08 	ld.ub	r8,r11[r10]
80003456:	f8 0a 0b 08 	st.b	r12[r10],r8
8000345a:	2f fa       	sub	r10,-1
8000345c:	14 39       	cp.w	r9,r10
8000345e:	fe 9b ff fa 	brhi	80003452 <unfilterScanline+0x506>
80003462:	ce 1b       	rjmp	80003424 <unfilterScanline+0x4d8>
         for(i =         0; i < bytewidth; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(0, precon[i], 0));
         for(i = bytewidth; i <    length; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
       }
       else
       {
         for(i =         0; i < bytewidth; i++) recon[i] = scanline[i];
80003464:	58 09       	cp.w	r9,0
80003466:	c3 30       	breq	800034cc <unfilterScanline+0x580>
       break;
     case 4:
       if(precon)
       {
         for(i =         0; i < bytewidth; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(0, precon[i], 0));
         for(i = bytewidth; i <    length; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
80003468:	f7 ec 10 08 	or	r8,r11,r12
8000346c:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80003470:	5f 08       	sreq	r8
80003472:	58 39       	cp.w	r9,3
80003474:	5f b7       	srhi	r7
80003476:	10 67       	and	r7,r8
80003478:	f6 c8 ff fc 	sub	r8,r11,-4
8000347c:	10 3c       	cp.w	r12,r8
8000347e:	5f b6       	srhi	r6
80003480:	f8 c8 ff fc 	sub	r8,r12,-4
80003484:	10 3b       	cp.w	r11,r8
80003486:	5f b8       	srhi	r8
80003488:	ed e8 10 08 	or	r8,r6,r8
8000348c:	ef e8 00 08 	and	r8,r7,r8
80003490:	10 97       	mov	r7,r8
80003492:	f4 07 18 00 	cp.b	r7,r10
80003496:	c7 e0       	breq	80003592 <unfilterScanline+0x646>
80003498:	f2 05 16 02 	lsr	r5,r9,0x2
8000349c:	ea 08 15 02 	lsl	r8,r5,0x2
800034a0:	c0 c0       	breq	800034b8 <unfilterScanline+0x56c>
800034a2:	14 97       	mov	r7,r10
       }
       else
       {
         for(i =         0; i < bytewidth; i++) recon[i] = scanline[i];
800034a4:	f6 0a 03 06 	ld.w	r6,r11[r10]
800034a8:	f8 0a 09 06 	st.w	r12[r10],r6
800034ac:	2f f7       	sub	r7,-1
800034ae:	2f ca       	sub	r10,-4
800034b0:	0a 37       	cp.w	r7,r5
800034b2:	cf 93       	brcs	800034a4 <unfilterScanline+0x558>
800034b4:	10 39       	cp.w	r9,r8
800034b6:	c0 b0       	breq	800034cc <unfilterScanline+0x580>
800034b8:	f6 08 00 07 	add	r7,r11,r8
800034bc:	f8 08 00 0a 	add	r10,r12,r8
800034c0:	0f 36       	ld.ub	r6,r7++
800034c2:	14 c6       	st.b	r10++,r6
800034c4:	2f f8       	sub	r8,-1
800034c6:	10 39       	cp.w	r9,r8
800034c8:	fe 9b ff fc 	brhi	800034c0 <unfilterScanline+0x574>
         for(i = bytewidth; i <    length; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(recon[i - bytewidth], 0, 0));
800034cc:	12 3e       	cp.w	lr,r9
800034ce:	fe 98 fd f3 	brls	800030b4 <unfilterScanline+0x168>
   if(decoder->infoPng.interlaceMethod > 1)    { decoder->error = 34; return; } /*error: only interlace methods 0 and 1 exist in the specification*/
 
   decoder->error = checkColorValidity(decoder->infoPng.color.colorType, decoder->infoPng.color.bitDepth);
 }
 
 static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon, size_t bytewidth, unsigned char filterType, size_t length)
800034d2:	fc 09 01 02 	sub	r2,lr,r9
800034d6:	58 32       	cp.w	r2,3
800034d8:	5f b6       	srhi	r6
800034da:	f8 09 00 04 	add	r4,r12,r9
800034de:	f6 09 00 03 	add	r3,r11,r9
800034e2:	e8 c8 ff fc 	sub	r8,r4,-4
800034e6:	e7 e4 10 0a 	or	r10,r3,r4
800034ea:	10 3c       	cp.w	r12,r8
800034ec:	5f b7       	srhi	r7
800034ee:	10 33       	cp.w	r3,r8
800034f0:	5f b8       	srhi	r8
800034f2:	f9 ea 10 0a 	or	r10,r12,r10
800034f6:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
800034fa:	5f 0a       	sreq	r10
800034fc:	ed ea 00 0a 	and	r10,r6,r10
80003500:	e6 c6 ff fc 	sub	r6,r3,-4
80003504:	0c 34       	cp.w	r4,r6
80003506:	5f b6       	srhi	r6
80003508:	ed e8 10 08 	or	r8,r6,r8
8000350c:	10 6a       	and	r10,r8
8000350e:	f8 c8 ff fc 	sub	r8,r12,-4
80003512:	10 34       	cp.w	r4,r8
80003514:	5f b8       	srhi	r8
80003516:	0e 48       	or	r8,r7
80003518:	f5 e8 00 08 	and	r8,r10,r8
8000351c:	c4 40       	breq	800035a4 <unfilterScanline+0x658>
8000351e:	e4 00 16 02 	lsr	r0,r2,0x2
80003522:	e0 01 15 02 	lsl	r1,r0,0x2
80003526:	c4 f0       	breq	800035c4 <unfilterScanline+0x678>
80003528:	30 08       	mov	r8,0
8000352a:	10 97       	mov	r7,r8
8000352c:	e6 08 03 05 	ld.w	r5,r3[r8]
80003530:	f8 08 03 06 	ld.w	r6,r12[r8]
         for(i = bytewidth; i <    length; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
       }
       else
       {
         for(i =         0; i < bytewidth; i++) recon[i] = scanline[i];
         for(i = bytewidth; i <    length; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(recon[i - bytewidth], 0, 0));
80003534:	ed e5 20 0a 	eor	r10,r6,r5
80003538:	e4 15 7f 7f 	andh	r5,0x7f7f
8000353c:	e0 15 7f 7f 	andl	r5,0x7f7f
80003540:	e4 1a 80 80 	andh	r10,0x8080
80003544:	e0 1a 80 80 	andl	r10,0x8080
80003548:	e4 16 7f 7f 	andh	r6,0x7f7f
8000354c:	e0 16 7f 7f 	andl	r6,0x7f7f
80003550:	ea 06 00 06 	add	r6,r5,r6
80003554:	ed ea 20 0a 	eor	r10,r6,r10
80003558:	e8 08 09 0a 	st.w	r4[r8],r10
8000355c:	2f f7       	sub	r7,-1
8000355e:	2f c8       	sub	r8,-4
80003560:	00 37       	cp.w	r7,r0
80003562:	ce 53       	brcs	8000352c <unfilterScanline+0x5e0>
80003564:	e2 09 00 08 	add	r8,r1,r9
80003568:	02 32       	cp.w	r2,r1
8000356a:	fe 90 fd a5 	breq	800030b4 <unfilterScanline+0x168>
8000356e:	f0 09 01 09 	sub	r9,r8,r9
80003572:	10 0b       	add	r11,r8
80003574:	f8 09 00 09 	add	r9,r12,r9
80003578:	10 0c       	add	r12,r8
8000357a:	13 37       	ld.ub	r7,r9++
8000357c:	17 3a       	ld.ub	r10,r11++
8000357e:	ee 0a 00 0a 	add	r10,r7,r10
80003582:	18 ca       	st.b	r12++,r10
80003584:	2f f8       	sub	r8,-1
80003586:	10 3e       	cp.w	lr,r8
80003588:	fe 9b ff f9 	brhi	8000357a <unfilterScanline+0x62e>
8000358c:	30 0c       	mov	r12,0
8000358e:	fe 9f fd 94 	bral	800030b6 <unfilterScanline+0x16a>
         for(i =         0; i < bytewidth; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(0, precon[i], 0));
         for(i = bytewidth; i <    length; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
       }
       else
       {
         for(i =         0; i < bytewidth; i++) recon[i] = scanline[i];
80003592:	f6 0a 07 08 	ld.ub	r8,r11[r10]
80003596:	f8 0a 0b 08 	st.b	r12[r10],r8
8000359a:	2f fa       	sub	r10,-1
8000359c:	14 39       	cp.w	r9,r10
8000359e:	fe 9b ff fa 	brhi	80003592 <unfilterScanline+0x646>
800035a2:	c9 5b       	rjmp	800034cc <unfilterScanline+0x580>
         for(i = bytewidth; i <    length; i++) recon[i] = (unsigned char)(scanline[i] + paethPredictor(recon[i - bytewidth], 0, 0));
800035a4:	30 08       	mov	r8,0
800035a6:	f8 08 07 0b 	ld.ub	r11,r12[r8]
800035aa:	07 3a       	ld.ub	r10,r3++
800035ac:	f6 0a 00 0a 	add	r10,r11,r10
800035b0:	08 ca       	st.b	r4++,r10
800035b2:	2f f8       	sub	r8,-1
800035b4:	f0 09 00 0a 	add	r10,r8,r9
800035b8:	14 3e       	cp.w	lr,r10
800035ba:	fe 9b ff f6 	brhi	800035a6 <unfilterScanline+0x65a>
800035be:	30 0c       	mov	r12,0
800035c0:	fe 9f fd 7b 	bral	800030b6 <unfilterScanline+0x16a>
   if(decoder->infoPng.interlaceMethod > 1)    { decoder->error = 34; return; } /*error: only interlace methods 0 and 1 exist in the specification*/
 
   decoder->error = checkColorValidity(decoder->infoPng.color.colorType, decoder->infoPng.color.bitDepth);
 }
 
 static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon, size_t bytewidth, unsigned char filterType, size_t length)
800035c4:	12 98       	mov	r8,r9
800035c6:	cd 4b       	rjmp	8000356e <unfilterScanline+0x622>
800035c8:	12 98       	mov	r8,r9
800035ca:	fe 9f fd 66 	bral	80003096 <unfilterScanline+0x14a>
800035ce:	d7 03       	nop

800035d0 <LodePNG_IText_clear>:
   }
   return 0;
 }
 
 void LodePNG_IText_clear(LodePNG_IText* text)
 {
800035d0:	eb cd 40 f8 	pushm	r3-r7,lr
800035d4:	18 97       	mov	r7,r12
   size_t i;
   for(i = 0; i < text->num; i++)
800035d6:	78 08       	ld.w	r8,r12[0x0]
800035d8:	58 08       	cp.w	r8,0
800035da:	c2 30       	breq	80003620 <LodePNG_IText_clear+0x50>
800035dc:	30 05       	mov	r5,0
 }
 
 static void string_cleanup(char** out) /*free the above pair again*/
 {
   free(*out);
   *out = NULL;
800035de:	0a 94       	mov	r4,r5
 }
 
 void LodePNG_IText_clear(LodePNG_IText* text)
 {
   size_t i;
   for(i = 0; i < text->num; i++)
800035e0:	ea 06 15 02 	lsl	r6,r5,0x2
     {
     string_cleanup(&text->keys[i]);
800035e4:	6e 13       	ld.w	r3,r7[0x4]
800035e6:	0c 03       	add	r3,r6
   string_resize(out, 0);
 }
 
 static void string_cleanup(char** out) /*free the above pair again*/
 {
   free(*out);
800035e8:	66 0c       	ld.w	r12,r3[0x0]
800035ea:	e0 a0 64 81 	rcall	8000feec <free>
   *out = NULL;
800035ee:	87 04       	st.w	r3[0x0],r4
 {
   size_t i;
   for(i = 0; i < text->num; i++)
     {
     string_cleanup(&text->keys[i]);
     string_cleanup(&text->langtags[i]);
800035f0:	6e 23       	ld.w	r3,r7[0x8]
800035f2:	0c 03       	add	r3,r6
   string_resize(out, 0);
 }
 
 static void string_cleanup(char** out) /*free the above pair again*/
 {
   free(*out);
800035f4:	66 0c       	ld.w	r12,r3[0x0]
800035f6:	e0 a0 64 7b 	rcall	8000feec <free>
   *out = NULL;
800035fa:	87 04       	st.w	r3[0x0],r4
   size_t i;
   for(i = 0; i < text->num; i++)
     {
     string_cleanup(&text->keys[i]);
     string_cleanup(&text->langtags[i]);
     string_cleanup(&text->transkeys[i]);
800035fc:	6e 33       	ld.w	r3,r7[0xc]
800035fe:	0c 03       	add	r3,r6
   string_resize(out, 0);
 }
 
 static void string_cleanup(char** out) /*free the above pair again*/
 {
   free(*out);
80003600:	66 0c       	ld.w	r12,r3[0x0]
80003602:	e0 a0 64 75 	rcall	8000feec <free>
   *out = NULL;
80003606:	87 04       	st.w	r3[0x0],r4
   for(i = 0; i < text->num; i++)
     {
     string_cleanup(&text->keys[i]);
     string_cleanup(&text->langtags[i]);
     string_cleanup(&text->transkeys[i]);
     string_cleanup(&text->strings[i]);
80003608:	6e 48       	ld.w	r8,r7[0x10]
8000360a:	f0 06 00 06 	add	r6,r8,r6
   string_resize(out, 0);
 }
 
 static void string_cleanup(char** out) /*free the above pair again*/
 {
   free(*out);
8000360e:	6c 0c       	ld.w	r12,r6[0x0]
80003610:	e0 a0 64 6e 	rcall	8000feec <free>
   *out = NULL;
80003614:	8d 04       	st.w	r6[0x0],r4
 }
 
 void LodePNG_IText_clear(LodePNG_IText* text)
 {
   size_t i;
   for(i = 0; i < text->num; i++)
80003616:	2f f5       	sub	r5,-1
80003618:	6e 08       	ld.w	r8,r7[0x0]
8000361a:	0a 38       	cp.w	r8,r5
8000361c:	fe 9b ff e2 	brhi	800035e0 <LodePNG_IText_clear+0x10>
     string_cleanup(&text->keys[i]);
     string_cleanup(&text->langtags[i]);
     string_cleanup(&text->transkeys[i]);
     string_cleanup(&text->strings[i]);
     }
   free(text->keys);
80003620:	6e 1c       	ld.w	r12,r7[0x4]
80003622:	e0 a0 64 65 	rcall	8000feec <free>
   free(text->langtags);
80003626:	6e 2c       	ld.w	r12,r7[0x8]
80003628:	e0 a0 64 62 	rcall	8000feec <free>
   free(text->transkeys);
8000362c:	6e 3c       	ld.w	r12,r7[0xc]
8000362e:	e0 a0 64 5f 	rcall	8000feec <free>
   free(text->strings);
80003632:	6e 4c       	ld.w	r12,r7[0x10]
80003634:	e0 a0 64 5c 	rcall	8000feec <free>
 }
80003638:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

8000363c <ucvector_resize>:
8000363c:	eb cd 40 e0 	pushm	r5-r7,lr
   free(((ucvector*)p)->data);
   ((ucvector*)p)->data = NULL;
 }
 
 static unsigned ucvector_resize(ucvector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
80003640:	18 97       	mov	r7,r12
80003642:	16 96       	mov	r6,r11
   if(size * sizeof(unsigned char) > p->allocsize)
80003644:	78 28       	ld.w	r8,r12[0x8]
80003646:	16 38       	cp.w	r8,r11
80003648:	c0 53       	brcs	80003652 <ucvector_resize+0x16>
       p->data = (unsigned char*)data;
       p->size = size;
     }
     else return 0; /*error: not enough memory*/
   }
   else p->size = size;
8000364a:	8f 1b       	st.w	r7[0x4],r11
8000364c:	30 1c       	mov	r12,1
   return 1;
 }
8000364e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
 
 static unsigned ucvector_resize(ucvector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned char) > p->allocsize)
   {
     size_t newsize = size * sizeof(unsigned char) * 2;
80003652:	f6 05 15 01 	lsl	r5,r11,0x1
     void* data = realloc(p->data, newsize);
80003656:	78 0c       	ld.w	r12,r12[0x0]
80003658:	0a 9b       	mov	r11,r5
8000365a:	e0 a0 67 1f 	rcall	80010498 <realloc>
     if(data)
8000365e:	cf 80       	breq	8000364e <ucvector_resize+0x12>
     {
       p->allocsize = newsize;
       p->data = (unsigned char*)data;
80003660:	8f 0c       	st.w	r7[0x0],r12
       p->size = size;
80003662:	8f 16       	st.w	r7[0x4],r6
   {
     size_t newsize = size * sizeof(unsigned char) * 2;
     void* data = realloc(p->data, newsize);
     if(data)
     {
       p->allocsize = newsize;
80003664:	8f 25       	st.w	r7[0x8],r5
       p->data = (unsigned char*)data;
       p->size = size;
80003666:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
8000366a:	d7 03       	nop

8000366c <string_init>:
8000366c:	eb cd 40 c0 	pushm	r6-r7,lr
   return data != 0;
 }
 
 static void string_init(char** out) /*init a {char*, size_t} pair for use as string*/
 {
   *out = NULL;
80003670:	30 07       	mov	r7,0
   }
   return data != 0;
 }
 
 static void string_init(char** out) /*init a {char*, size_t} pair for use as string*/
 {
80003672:	18 96       	mov	r6,r12
   *out = NULL;
80003674:	99 07       	st.w	r12[0x0],r7
 
 #ifdef LODEPNG_COMPILE_PNG
 #ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
 static unsigned string_resize(char** out, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   char* data = (char*)realloc(*out, size + 1);
80003676:	30 1b       	mov	r11,1
80003678:	0e 9c       	mov	r12,r7
8000367a:	e0 a0 67 0f 	rcall	80010498 <realloc>
   if(data)
   {
     data[size] = 0; /*null termination char*/
8000367e:	f9 f7 1e 00 	st.bne	r12[0x0],r7
     *out = data;
80003682:	ed fc 1a 00 	st.wne	r6[0x0],r12
80003686:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000368a:	d7 03       	nop

8000368c <LodePNG_append_chunk>:
8000368c:	eb cd 40 f8 	pushm	r3-r7,lr
   unsigned total_chunk_length = LodePNG_chunk_length(chunk) + 12;
   return &chunk[total_chunk_length];
 }
 
 unsigned LodePNG_append_chunk(unsigned char** out, size_t* outlength, const unsigned char* chunk) /*appends chunk that was already created, to the data. Returns error code.*/
 {
80003690:	20 1d       	sub	sp,4
   unsigned i;
   unsigned total_chunk_length = LodePNG_chunk_length(chunk) + 12;
80003692:	15 b8       	ld.ub	r8,r10[0x3]
80003694:	15 87       	ld.ub	r7,r10[0x0]
80003696:	f1 e7 11 87 	or	r7,r8,r7<<0x18
8000369a:	15 98       	ld.ub	r8,r10[0x1]
   unsigned char *chunk_start, *new_buffer;
   size_t new_length = (*outlength) + total_chunk_length;
8000369c:	76 05       	ld.w	r5,r11[0x0]
 }
 
 unsigned LodePNG_append_chunk(unsigned char** out, size_t* outlength, const unsigned char* chunk) /*appends chunk that was already created, to the data. Returns error code.*/
 {
   unsigned i;
   unsigned total_chunk_length = LodePNG_chunk_length(chunk) + 12;
8000369e:	ef e8 11 07 	or	r7,r7,r8<<0x10
   unsigned total_chunk_length = LodePNG_chunk_length(chunk) + 12;
   return &chunk[total_chunk_length];
 }
 
 unsigned LodePNG_append_chunk(unsigned char** out, size_t* outlength, const unsigned char* chunk) /*appends chunk that was already created, to the data. Returns error code.*/
 {
800036a2:	16 94       	mov	r4,r11
   unsigned i;
   unsigned total_chunk_length = LodePNG_chunk_length(chunk) + 12;
800036a4:	15 a8       	ld.ub	r8,r10[0x2]
   unsigned total_chunk_length = LodePNG_chunk_length(chunk) + 12;
   return &chunk[total_chunk_length];
 }
 
 unsigned LodePNG_append_chunk(unsigned char** out, size_t* outlength, const unsigned char* chunk) /*appends chunk that was already created, to the data. Returns error code.*/
 {
800036a6:	18 93       	mov	r3,r12
   unsigned i;
   unsigned total_chunk_length = LodePNG_chunk_length(chunk) + 12;
800036a8:	ef e8 10 87 	or	r7,r7,r8<<0x8
800036ac:	2f 47       	sub	r7,-12
   unsigned char *chunk_start, *new_buffer;
   size_t new_length = (*outlength) + total_chunk_length;
800036ae:	ee 05 00 06 	add	r6,r7,r5
   if(new_length < total_chunk_length || new_length < (*outlength)) return 77; /*integer overflow happened*/
800036b2:	0c 37       	cp.w	r7,r6
800036b4:	e0 8b 00 05 	brhi	800036be <LodePNG_append_chunk+0x32>
800036b8:	0c 35       	cp.w	r5,r6
800036ba:	e0 88 00 06 	brls	800036c6 <LodePNG_append_chunk+0x3a>
   if(!new_buffer) return 9929;
   (*out) = new_buffer;
   (*outlength) = new_length;
   chunk_start = &(*out)[new_length - total_chunk_length];
 
   for(i = 0; i < total_chunk_length; i++) chunk_start[i] = chunk[i];
800036be:	34 dc       	mov	r12,77
 
   return 0;
 }
800036c0:	2f fd       	sub	sp,-4
800036c2:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
   unsigned total_chunk_length = LodePNG_chunk_length(chunk) + 12;
   unsigned char *chunk_start, *new_buffer;
   size_t new_length = (*outlength) + total_chunk_length;
   if(new_length < total_chunk_length || new_length < (*outlength)) return 77; /*integer overflow happened*/
 
   new_buffer = (unsigned char*)realloc(*out, new_length);
800036c6:	78 0c       	ld.w	r12,r12[0x0]
800036c8:	0c 9b       	mov	r11,r6
800036ca:	50 0a       	stdsp	sp[0x0],r10
800036cc:	e0 a0 66 e6 	rcall	80010498 <realloc>
   if(!new_buffer) return 9929;
800036d0:	40 0a       	lddsp	r10,sp[0x0]
800036d2:	c4 80       	breq	80003762 <LodePNG_append_chunk+0xd6>
   (*out) = new_buffer;
800036d4:	87 0c       	st.w	r3[0x0],r12
   (*outlength) = new_length;
800036d6:	89 06       	st.w	r4[0x0],r6
   chunk_start = &(*out)[new_length - total_chunk_length];
800036d8:	0e 16       	sub	r6,r7
800036da:	66 08       	ld.w	r8,r3[0x0]
800036dc:	f0 06 00 06 	add	r6,r8,r6
 
   for(i = 0; i < total_chunk_length; i++) chunk_start[i] = chunk[i];
800036e0:	58 07       	cp.w	r7,0
800036e2:	c3 10       	breq	80003744 <LodePNG_append_chunk+0xb8>
800036e4:	f0 05 00 05 	add	r5,r8,r5
800036e8:	eb ea 10 08 	or	r8,r5,r10
800036ec:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800036f0:	5f 08       	sreq	r8
800036f2:	58 37       	cp.w	r7,3
800036f4:	5f b9       	srhi	r9
800036f6:	10 69       	and	r9,r8
800036f8:	f4 c8 ff fc 	sub	r8,r10,-4
800036fc:	10 35       	cp.w	r5,r8
800036fe:	5f bb       	srhi	r11
80003700:	ea c8 ff fc 	sub	r8,r5,-4
80003704:	10 3a       	cp.w	r10,r8
80003706:	5f b8       	srhi	r8
80003708:	f7 e8 10 08 	or	r8,r11,r8
8000370c:	f3 e8 00 08 	and	r8,r9,r8
80003710:	c1 e0       	breq	8000374c <LodePNG_append_chunk+0xc0>
80003712:	ee 04 16 02 	lsr	r4,r7,0x2
80003716:	e8 09 15 02 	lsl	r9,r4,0x2
8000371a:	c0 d0       	breq	80003734 <LodePNG_append_chunk+0xa8>
8000371c:	30 08       	mov	r8,0
8000371e:	10 9b       	mov	r11,r8
80003720:	f4 08 03 0c 	ld.w	r12,r10[r8]
80003724:	ea 08 09 0c 	st.w	r5[r8],r12
80003728:	2f fb       	sub	r11,-1
8000372a:	2f c8       	sub	r8,-4
8000372c:	08 3b       	cp.w	r11,r4
8000372e:	cf 93       	brcs	80003720 <LodePNG_append_chunk+0x94>
80003730:	12 37       	cp.w	r7,r9
80003732:	c0 90       	breq	80003744 <LodePNG_append_chunk+0xb8>
80003734:	12 0a       	add	r10,r9
80003736:	12 06       	add	r6,r9
80003738:	15 38       	ld.ub	r8,r10++
8000373a:	0c c8       	st.b	r6++,r8
8000373c:	2f f9       	sub	r9,-1
8000373e:	12 37       	cp.w	r7,r9
80003740:	fe 9b ff fc 	brhi	80003738 <LodePNG_append_chunk+0xac>
80003744:	30 0c       	mov	r12,0
 
   return 0;
 }
80003746:	2f fd       	sub	sp,-4
80003748:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
   if(!new_buffer) return 9929;
   (*out) = new_buffer;
   (*outlength) = new_length;
   chunk_start = &(*out)[new_length - total_chunk_length];
 
   for(i = 0; i < total_chunk_length; i++) chunk_start[i] = chunk[i];
8000374c:	30 08       	mov	r8,0
8000374e:	f4 08 07 09 	ld.ub	r9,r10[r8]
80003752:	ec 08 0b 09 	st.b	r6[r8],r9
80003756:	2f f8       	sub	r8,-1
80003758:	10 37       	cp.w	r7,r8
8000375a:	fe 9b ff fa 	brhi	8000374e <LodePNG_append_chunk+0xc2>
8000375e:	30 0c       	mov	r12,0
80003760:	cf 3b       	rjmp	80003746 <LodePNG_append_chunk+0xba>
   unsigned char *chunk_start, *new_buffer;
   size_t new_length = (*outlength) + total_chunk_length;
   if(new_length < total_chunk_length || new_length < (*outlength)) return 77; /*integer overflow happened*/
 
   new_buffer = (unsigned char*)realloc(*out, new_length);
   if(!new_buffer) return 9929;
80003762:	e0 6c 26 c9 	mov	r12,9929
80003766:	ca db       	rjmp	800036c0 <LodePNG_append_chunk+0x34>

80003768 <string_set>:
80003768:	eb cd 40 e0 	pushm	r5-r7,lr
   free(*out);
   *out = NULL;
 }
 
 static void string_set(char** out, const char* in)
 {
8000376c:	16 95       	mov	r5,r11
8000376e:	18 96       	mov	r6,r12
   size_t insize = strlen(in), i = 0;
80003770:	16 9c       	mov	r12,r11
80003772:	e0 a0 68 29 	rcall	800107c4 <strlen>
80003776:	18 97       	mov	r7,r12
 
 #ifdef LODEPNG_COMPILE_PNG
 #ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
 static unsigned string_resize(char** out, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   char* data = (char*)realloc(*out, size + 1);
80003778:	6c 0c       	ld.w	r12,r6[0x0]
8000377a:	ee cb ff ff 	sub	r11,r7,-1
8000377e:	e0 a0 66 8d 	rcall	80010498 <realloc>
   if(data)
80003782:	c1 20       	breq	800037a6 <string_set+0x3e>
   {
     data[size] = 0; /*null termination char*/
80003784:	30 08       	mov	r8,0
80003786:	f8 07 0b 08 	st.b	r12[r7],r8
     *out = data;
8000378a:	8d 0c       	st.w	r6[0x0],r12
 }
 
 static void string_set(char** out, const char* in)
 {
   size_t insize = strlen(in), i = 0;
   if(string_resize(out, insize)) for(i = 0; i < insize; i++) (*out)[i] = in[i];
8000378c:	58 07       	cp.w	r7,0
8000378e:	c0 c0       	breq	800037a6 <string_set+0x3e>
80003790:	30 08       	mov	r8,0
80003792:	c0 28       	rjmp	80003796 <string_set+0x2e>
80003794:	6c 0c       	ld.w	r12,r6[0x0]
80003796:	ea 08 07 09 	ld.ub	r9,r5[r8]
8000379a:	f8 08 0b 09 	st.b	r12[r8],r9
8000379e:	2f f8       	sub	r8,-1
800037a0:	10 37       	cp.w	r7,r8
800037a2:	fe 9b ff f9 	brhi	80003794 <string_set+0x2c>
800037a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800037aa:	d7 03       	nop

800037ac <LodePNG_IText_add>:
800037ac:	d4 31       	pushm	r0-r7,lr
800037ae:	20 1d       	sub	sp,4
800037b0:	18 97       	mov	r7,r12
800037b2:	14 96       	mov	r6,r10
   free(text->transkeys);
   free(text->strings);
 }
 
 unsigned LodePNG_IText_add(LodePNG_IText* text, const char* key, const char* langtag, const char* transkey, const char* str)
 {
800037b4:	12 95       	mov	r5,r9
800037b6:	10 91       	mov	r1,r8
800037b8:	16 90       	mov	r0,r11
   char** new_keys = (char**)(realloc(text->keys, sizeof(char*) * (text->num + 1)));
800037ba:	78 0b       	ld.w	r11,r12[0x0]
800037bc:	78 1c       	ld.w	r12,r12[0x4]
800037be:	2f fb       	sub	r11,-1
800037c0:	a3 6b       	lsl	r11,0x2
800037c2:	e0 a0 66 6b 	rcall	80010498 <realloc>
   char** new_langtags = (char**)(realloc(text->langtags, sizeof(char*) * (text->num + 1)));
800037c6:	6e 0b       	ld.w	r11,r7[0x0]
   free(text->strings);
 }
 
 unsigned LodePNG_IText_add(LodePNG_IText* text, const char* key, const char* langtag, const char* transkey, const char* str)
 {
   char** new_keys = (char**)(realloc(text->keys, sizeof(char*) * (text->num + 1)));
800037c8:	18 94       	mov	r4,r12
   char** new_langtags = (char**)(realloc(text->langtags, sizeof(char*) * (text->num + 1)));
800037ca:	2f fb       	sub	r11,-1
800037cc:	6e 2c       	ld.w	r12,r7[0x8]
800037ce:	a3 6b       	lsl	r11,0x2
800037d0:	e0 a0 66 64 	rcall	80010498 <realloc>
   char** new_transkeys = (char**)(realloc(text->transkeys, sizeof(char*) * (text->num + 1)));
800037d4:	6e 0b       	ld.w	r11,r7[0x0]
 }
 
 unsigned LodePNG_IText_add(LodePNG_IText* text, const char* key, const char* langtag, const char* transkey, const char* str)
 {
   char** new_keys = (char**)(realloc(text->keys, sizeof(char*) * (text->num + 1)));
   char** new_langtags = (char**)(realloc(text->langtags, sizeof(char*) * (text->num + 1)));
800037d6:	18 93       	mov	r3,r12
   char** new_transkeys = (char**)(realloc(text->transkeys, sizeof(char*) * (text->num + 1)));
800037d8:	2f fb       	sub	r11,-1
800037da:	6e 3c       	ld.w	r12,r7[0xc]
800037dc:	a3 6b       	lsl	r11,0x2
800037de:	e0 a0 66 5d 	rcall	80010498 <realloc>
   char** new_strings = (char**)(realloc(text->strings, sizeof(char*) * (text->num + 1)));
800037e2:	6e 0b       	ld.w	r11,r7[0x0]
 
 unsigned LodePNG_IText_add(LodePNG_IText* text, const char* key, const char* langtag, const char* transkey, const char* str)
 {
   char** new_keys = (char**)(realloc(text->keys, sizeof(char*) * (text->num + 1)));
   char** new_langtags = (char**)(realloc(text->langtags, sizeof(char*) * (text->num + 1)));
   char** new_transkeys = (char**)(realloc(text->transkeys, sizeof(char*) * (text->num + 1)));
800037e4:	18 92       	mov	r2,r12
   char** new_strings = (char**)(realloc(text->strings, sizeof(char*) * (text->num + 1)));
800037e6:	2f fb       	sub	r11,-1
800037e8:	6e 4c       	ld.w	r12,r7[0x10]
800037ea:	a3 6b       	lsl	r11,0x2
800037ec:	e0 a0 66 56 	rcall	80010498 <realloc>
   if(!new_keys || !new_langtags || !new_transkeys || !new_strings)
800037f0:	58 03       	cp.w	r3,0
800037f2:	5f 0a       	sreq	r10
800037f4:	58 04       	cp.w	r4,0
800037f6:	5f 09       	sreq	r9
 unsigned LodePNG_IText_add(LodePNG_IText* text, const char* key, const char* langtag, const char* transkey, const char* str)
 {
   char** new_keys = (char**)(realloc(text->keys, sizeof(char*) * (text->num + 1)));
   char** new_langtags = (char**)(realloc(text->langtags, sizeof(char*) * (text->num + 1)));
   char** new_transkeys = (char**)(realloc(text->transkeys, sizeof(char*) * (text->num + 1)));
   char** new_strings = (char**)(realloc(text->strings, sizeof(char*) * (text->num + 1)));
800037f8:	18 98       	mov	r8,r12
   if(!new_keys || !new_langtags || !new_transkeys || !new_strings)
800037fa:	f5 e9 10 09 	or	r9,r10,r9
800037fe:	30 0a       	mov	r10,0
80003800:	f4 09 18 00 	cp.b	r9,r10
80003804:	c0 a1       	brne	80003818 <LodePNG_IText_add+0x6c>
80003806:	58 0c       	cp.w	r12,0
80003808:	5f 0b       	sreq	r11
8000380a:	58 02       	cp.w	r2,0
8000380c:	5f 0a       	sreq	r10
8000380e:	f7 ea 10 0a 	or	r10,r11,r10
80003812:	f2 0a 18 00 	cp.b	r10,r9
80003816:	c1 30       	breq	8000383c <LodePNG_IText_add+0x90>
   {
     free(new_keys);
80003818:	50 08       	stdsp	sp[0x0],r8
8000381a:	08 9c       	mov	r12,r4
8000381c:	e0 a0 63 68 	rcall	8000feec <free>
     free(new_langtags);
80003820:	06 9c       	mov	r12,r3
80003822:	e0 a0 63 65 	rcall	8000feec <free>
     free(new_transkeys);
80003826:	04 9c       	mov	r12,r2
80003828:	e0 a0 63 62 	rcall	8000feec <free>
     free(new_strings);
8000382c:	40 08       	lddsp	r8,sp[0x0]
8000382e:	10 9c       	mov	r12,r8
80003830:	e0 a0 63 5e 	rcall	8000feec <free>
80003834:	e0 6c 26 ce 	mov	r12,9934
 
   string_init(&text->strings[text->num - 1]);
   string_set(&text->strings[text->num - 1], str);
 
   return 0;
 }
80003838:	2f fd       	sub	sp,-4
8000383a:	d8 32       	popm	r0-r7,pc
     free(new_transkeys);
     free(new_strings);
     return 9934;
   }
 
   text->num++;
8000383c:	6e 08       	ld.w	r8,r7[0x0]
   text->keys = new_keys;
   text->langtags = new_langtags;
   text->transkeys = new_transkeys;
   text->strings = new_strings;
8000383e:	8f 4c       	st.w	r7[0x10],r12
 
   string_init(&text->keys[text->num - 1]);
80003840:	e8 08 00 2c 	add	r12,r4,r8<<0x2
     free(new_transkeys);
     free(new_strings);
     return 9934;
   }
 
   text->num++;
80003844:	2f f8       	sub	r8,-1
   text->keys = new_keys;
   text->langtags = new_langtags;
80003846:	8f 23       	st.w	r7[0x8],r3
     free(new_transkeys);
     free(new_strings);
     return 9934;
   }
 
   text->num++;
80003848:	8f 08       	st.w	r7[0x0],r8
   text->keys = new_keys;
   text->langtags = new_langtags;
   text->transkeys = new_transkeys;
8000384a:	8f 32       	st.w	r7[0xc],r2
     free(new_strings);
     return 9934;
   }
 
   text->num++;
   text->keys = new_keys;
8000384c:	8f 14       	st.w	r7[0x4],r4
   text->langtags = new_langtags;
   text->transkeys = new_transkeys;
   text->strings = new_strings;
 
   string_init(&text->keys[text->num - 1]);
8000384e:	c0 ff       	rcall	8000366c <string_init>
80003850:	6e 18       	ld.w	r8,r7[0x4]
   string_set(&text->keys[text->num - 1], key);
80003852:	00 9b       	mov	r11,r0
80003854:	6e 0c       	ld.w	r12,r7[0x0]
80003856:	20 1c       	sub	r12,1
80003858:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000385c:	c8 6f       	rcall	80003768 <string_set>
8000385e:	6e 28       	ld.w	r8,r7[0x8]
80003860:	6e 0c       	ld.w	r12,r7[0x0]
 
   string_init(&text->langtags[text->num - 1]);
80003862:	20 1c       	sub	r12,1
80003864:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80003868:	c0 2f       	rcall	8000366c <string_init>
8000386a:	6e 28       	ld.w	r8,r7[0x8]
8000386c:	0c 9b       	mov	r11,r6
8000386e:	6e 0c       	ld.w	r12,r7[0x0]
   string_set(&text->langtags[text->num - 1], langtag);
80003870:	20 1c       	sub	r12,1
80003872:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80003876:	c7 9f       	rcall	80003768 <string_set>
80003878:	6e 38       	ld.w	r8,r7[0xc]
8000387a:	6e 0c       	ld.w	r12,r7[0x0]
8000387c:	20 1c       	sub	r12,1
8000387e:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
 
   string_init(&text->transkeys[text->num - 1]);
80003882:	cf 5e       	rcall	8000366c <string_init>
80003884:	6e 38       	ld.w	r8,r7[0xc]
80003886:	0a 9b       	mov	r11,r5
80003888:	6e 0c       	ld.w	r12,r7[0x0]
8000388a:	20 1c       	sub	r12,1
8000388c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
   string_set(&text->transkeys[text->num - 1], transkey);
80003890:	c6 cf       	rcall	80003768 <string_set>
80003892:	6e 48       	ld.w	r8,r7[0x10]
80003894:	6e 0c       	ld.w	r12,r7[0x0]
80003896:	20 1c       	sub	r12,1
80003898:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000389c:	ce 8e       	rcall	8000366c <string_init>
 
   string_init(&text->strings[text->num - 1]);
8000389e:	6e 48       	ld.w	r8,r7[0x10]
800038a0:	6e 0c       	ld.w	r12,r7[0x0]
800038a2:	02 9b       	mov	r11,r1
800038a4:	20 1c       	sub	r12,1
800038a6:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800038aa:	c5 ff       	rcall	80003768 <string_set>
   string_set(&text->strings[text->num - 1], str);
800038ac:	30 0c       	mov	r12,0
800038ae:	cc 5b       	rjmp	80003838 <LodePNG_IText_add+0x8c>

800038b0 <LodePNG_chunk_type_equals>:
800038b0:	eb cd 40 c0 	pushm	r6-r7,lr
800038b4:	18 96       	mov	r6,r12
800038b6:	16 97       	mov	r7,r11
800038b8:	16 9c       	mov	r12,r11
800038ba:	e0 a0 67 85 	rcall	800107c4 <strlen>
 
   return 0;
800038be:	58 4c       	cp.w	r12,4
800038c0:	c0 30       	breq	800038c6 <LodePNG_chunk_type_equals+0x16>
800038c2:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
800038c6:	0d c9       	ld.ub	r9,r6[0x4]
800038c8:	0f 88       	ld.ub	r8,r7[0x0]
800038ca:	f0 09 18 00 	cp.b	r9,r8
800038ce:	c0 30       	breq	800038d4 <LodePNG_chunk_type_equals+0x24>
 }
 
 unsigned char LodePNG_chunk_type_equals(const unsigned char* chunk, const char* type) /*check if the type is the given type*/
 {
   if(strlen(type) != 4) return 0;
   return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
800038d0:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
800038d4:	0d d9       	ld.ub	r9,r6[0x5]
800038d6:	0f 98       	ld.ub	r8,r7[0x1]
800038d8:	f0 09 18 00 	cp.b	r9,r8
800038dc:	cf a1       	brne	800038d0 <LodePNG_chunk_type_equals+0x20>
800038de:	0d e9       	ld.ub	r9,r6[0x6]
800038e0:	0f a8       	ld.ub	r8,r7[0x2]
800038e2:	f0 09 18 00 	cp.b	r9,r8
800038e6:	cf 51       	brne	800038d0 <LodePNG_chunk_type_equals+0x20>
800038e8:	0d f9       	ld.ub	r9,r6[0x7]
800038ea:	0f b8       	ld.ub	r8,r7[0x3]
800038ec:	f0 09 18 00 	cp.b	r9,r8
800038f0:	5f 0c       	sreq	r12
800038f2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800038f6:	d7 03       	nop

800038f8 <HuffmanTree_makeFromLengths2>:
800038f8:	d4 31       	pushm	r0-r7,lr
800038fa:	78 a6       	ld.w	r6,r12[0x28]
 
   return 0;
 }
 
 static unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree) /*given that numcodes, lengths and maxbitlen are already filled in correctly. return value is error.*/
 {
800038fc:	18 97       	mov	r7,r12
   uivector nextcode;
   unsigned bits, n, error = 0;
 
   uivector_init(&blcount);
   uivector_init(&nextcode);
   if(!uivector_resize(&tree->tree1d, tree->numcodes)
800038fe:	78 58       	ld.w	r8,r12[0x14]
   ((uivector*)p)->data = NULL;
 }
 
 static unsigned uivector_resize(uivector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned) > p->allocsize)
80003900:	ec 09 15 02 	lsl	r9,r6,0x2
   uivector nextcode;
   unsigned bits, n, error = 0;
 
   uivector_init(&blcount);
   uivector_init(&nextcode);
   if(!uivector_resize(&tree->tree1d, tree->numcodes)
80003904:	10 39       	cp.w	r9,r8
80003906:	e0 8b 00 dc 	brhi	80003abe <HuffmanTree_makeFromLengths2+0x1c6>
       p->data = (unsigned*)data;
       p->size = size;
     }
     else return 0;
   }
   else p->size = size;
8000390a:	99 46       	st.w	r12[0x10],r6
   unsigned bits, n, error = 0;
 
   uivector_init(&blcount);
   uivector_init(&nextcode);
   if(!uivector_resize(&tree->tree1d, tree->numcodes)
   || !uivector_resizev(&blcount, tree->maxbitlen + 1, 0)
8000390c:	6e 95       	ld.w	r5,r7[0x24]
8000390e:	2f f5       	sub	r5,-1
   ((uivector*)p)->data = NULL;
 }
 
 static unsigned uivector_resize(uivector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned) > p->allocsize)
80003910:	ea 06 15 02 	lsl	r6,r5,0x2
80003914:	e0 81 00 e5 	brne	80003ade <HuffmanTree_makeFromLengths2+0x1e6>
 
 static unsigned uivector_resizev(uivector* p, size_t size, unsigned value) /*resize and give all new elements the value*/
 {
   size_t oldsize = p->size, i;
   if(!uivector_resize(p, size)) return 0;
   for(i = oldsize; i < size; i++) p->data[i] = value;
80003918:	58 05       	cp.w	r5,0
8000391a:	c0 90       	breq	8000392c <HuffmanTree_makeFromLengths2+0x34>
8000391c:	30 08       	mov	r8,0
8000391e:	0c 99       	mov	r9,r6
80003920:	10 9a       	mov	r10,r8
80003922:	12 aa       	st.w	r9++,r10
80003924:	2f f8       	sub	r8,-1
80003926:	10 35       	cp.w	r5,r8
80003928:	fe 9b ff fd 	brhi	80003922 <HuffmanTree_makeFromLengths2+0x2a>
 
   uivector_init(&blcount);
   uivector_init(&nextcode);
   if(!uivector_resize(&tree->tree1d, tree->numcodes)
   || !uivector_resizev(&blcount, tree->maxbitlen + 1, 0)
   || !uivector_resizev(&nextcode, tree->maxbitlen + 1, 0))
8000392c:	6e 95       	ld.w	r5,r7[0x24]
8000392e:	2f f5       	sub	r5,-1
   ((uivector*)p)->data = NULL;
 }
 
 static unsigned uivector_resize(uivector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned) > p->allocsize)
80003930:	ea 04 15 02 	lsl	r4,r5,0x2
80003934:	e0 81 00 fd 	brne	80003b2e <HuffmanTree_makeFromLengths2+0x236>
 
 static unsigned uivector_resizev(uivector* p, size_t size, unsigned value) /*resize and give all new elements the value*/
 {
   size_t oldsize = p->size, i;
   if(!uivector_resize(p, size)) return 0;
   for(i = oldsize; i < size; i++) p->data[i] = value;
80003938:	58 05       	cp.w	r5,0
8000393a:	c0 90       	breq	8000394c <HuffmanTree_makeFromLengths2+0x54>
8000393c:	30 08       	mov	r8,0
8000393e:	08 99       	mov	r9,r4
80003940:	10 9a       	mov	r10,r8
80003942:	12 aa       	st.w	r9++,r10
80003944:	2f f8       	sub	r8,-1
80003946:	10 35       	cp.w	r5,r8
80003948:	fe 9b ff fd 	brhi	80003942 <HuffmanTree_makeFromLengths2+0x4a>
     error = 9902;
 
   if(!error)
   {
     /*step 1: count number of instances of each code length*/
     for(bits = 0; bits < tree->numcodes; bits++) blcount.data[tree->lengths.data[bits]]++;
8000394c:	6e a9       	ld.w	r9,r7[0x28]
8000394e:	58 09       	cp.w	r9,0
80003950:	c0 f0       	breq	8000396e <HuffmanTree_makeFromLengths2+0x76>
 
 static unsigned uivector_resizev(uivector* p, size_t size, unsigned value) /*resize and give all new elements the value*/
 {
   size_t oldsize = p->size, i;
   if(!uivector_resize(p, size)) return 0;
   for(i = oldsize; i < size; i++) p->data[i] = value;
80003952:	30 08       	mov	r8,0
     error = 9902;
 
   if(!error)
   {
     /*step 1: count number of instances of each code length*/
     for(bits = 0; bits < tree->numcodes; bits++) blcount.data[tree->lengths.data[bits]]++;
80003954:	6e 69       	ld.w	r9,r7[0x18]
80003956:	f2 08 03 29 	ld.w	r9,r9[r8<<0x2]
8000395a:	ec 09 03 2a 	ld.w	r10,r6[r9<<0x2]
8000395e:	2f fa       	sub	r10,-1
80003960:	ec 09 09 2a 	st.w	r6[r9<<0x2],r10
80003964:	2f f8       	sub	r8,-1
80003966:	6e a9       	ld.w	r9,r7[0x28]
80003968:	10 39       	cp.w	r9,r8
8000396a:	fe 9b ff f5 	brhi	80003954 <HuffmanTree_makeFromLengths2+0x5c>
     /*step 2: generate the nextcode values*/
     for(bits = 1; bits <= tree->maxbitlen; bits++) nextcode.data[bits] = (nextcode.data[bits - 1] + blcount.data[bits - 1]) << 1;
8000396e:	6e 98       	ld.w	r8,r7[0x24]
80003970:	58 08       	cp.w	r8,0
80003972:	c1 00       	breq	80003992 <HuffmanTree_makeFromLengths2+0x9a>
80003974:	08 98       	mov	r8,r4
80003976:	0c 9a       	mov	r10,r6
80003978:	30 19       	mov	r9,1
8000397a:	15 0c       	ld.w	r12,r10++
8000397c:	70 0b       	ld.w	r11,r8[0x0]
8000397e:	f8 0b 00 0b 	add	r11,r12,r11
80003982:	a1 7b       	lsl	r11,0x1
80003984:	91 1b       	st.w	r8[0x4],r11
80003986:	2f f9       	sub	r9,-1
80003988:	2f c8       	sub	r8,-4
8000398a:	6e 9b       	ld.w	r11,r7[0x24]
8000398c:	12 3b       	cp.w	r11,r9
8000398e:	cf 62       	brcc	8000397a <HuffmanTree_makeFromLengths2+0x82>
80003990:	6e a9       	ld.w	r9,r7[0x28]
     /*step 3: generate all the codes*/
     for(n = 0; n < tree->numcodes; n++) if(tree->lengths.data[n] != 0) tree->tree1d.data[n] = nextcode.data[tree->lengths.data[n]]++;
80003992:	58 09       	cp.w	r9,0
80003994:	c1 50       	breq	800039be <HuffmanTree_makeFromLengths2+0xc6>
80003996:	30 08       	mov	r8,0
80003998:	f0 0b 15 02 	lsl	r11,r8,0x2
8000399c:	6e 6a       	ld.w	r10,r7[0x18]
8000399e:	2f f8       	sub	r8,-1
800039a0:	f4 0b 03 0a 	ld.w	r10,r10[r11]
800039a4:	e8 0a 00 2c 	add	r12,r4,r10<<0x2
800039a8:	58 0a       	cp.w	r10,0
800039aa:	c0 80       	breq	800039ba <HuffmanTree_makeFromLengths2+0xc2>
800039ac:	78 09       	ld.w	r9,r12[0x0]
800039ae:	6e 3a       	ld.w	r10,r7[0xc]
800039b0:	f4 0b 09 09 	st.w	r10[r11],r9
800039b4:	2f f9       	sub	r9,-1
800039b6:	99 09       	st.w	r12[0x0],r9
800039b8:	6e a9       	ld.w	r9,r7[0x28]
800039ba:	12 38       	cp.w	r8,r9
800039bc:	ce e3       	brcs	80003998 <HuffmanTree_makeFromLengths2+0xa0>
 } uivector;
 
 static void uivector_cleanup(void* p)
 {
   ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
   free(((uivector*)p)->data);
800039be:	0c 9c       	mov	r12,r6
800039c0:	e0 a0 62 96 	rcall	8000feec <free>
800039c4:	08 9c       	mov	r12,r4
800039c6:	e0 a0 62 93 	rcall	8000feec <free>
   ((uivector*)p)->data = NULL;
 }
 
 static unsigned uivector_resize(uivector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned) > p->allocsize)
800039ca:	6e 28       	ld.w	r8,r7[0x8]
 {
   unsigned nodefilled = 0; /*up to which node it is filled*/
   unsigned treepos = 0; /*position in the tree (1 of the numcodes columns)*/
   unsigned n, i;
 
   if(!uivector_resize(&tree->tree2d, tree->numcodes * 2)) return 9901; /*if failed return not enough memory error*/
800039cc:	6e a5       	ld.w	r5,r7[0x28]
800039ce:	ea 06 15 01 	lsl	r6,r5,0x1
   ((uivector*)p)->data = NULL;
 }
 
 static unsigned uivector_resize(uivector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned) > p->allocsize)
800039d2:	ea 09 15 03 	lsl	r9,r5,0x3
800039d6:	10 39       	cp.w	r9,r8
800039d8:	e0 8b 00 95 	brhi	80003b02 <HuffmanTree_makeFromLengths2+0x20a>
       p->data = (unsigned*)data;
       p->size = size;
     }
     else return 0;
   }
   else p->size = size;
800039dc:	8f 16       	st.w	r7[0x4],r6
   unsigned n, i;
 
   if(!uivector_resize(&tree->tree2d, tree->numcodes * 2)) return 9901; /*if failed return not enough memory error*/
   /*convert tree1d[] to tree2d[][]. In the 2D array, a value of 32767 means uninited, a value >= numcodes is an address to another bit, a value < numcodes is a code. The 2 rows are the 2 possible bit values (0 or 1), there are as many columns as codes - 1
   a good huffmann tree has N * 2 - 1 nodes, of which N - 1 are internal nodes. Here, the internal nodes are stored (what their 0 and 1 option point to). There is only memory for such good tree currently, if there are more nodes (due to too long length codes), error 55 will happen*/
   for(n = 0;  n < tree->numcodes * 2; n++) tree->tree2d.data[n] = 32767; /*32767 here means the tree2d isn't filled there yet*/
800039de:	0a 9a       	mov	r10,r5
800039e0:	ea 08 15 01 	lsl	r8,r5,0x1
800039e4:	c0 e0       	breq	80003a00 <HuffmanTree_makeFromLengths2+0x108>
       p->data = (unsigned*)data;
       p->size = size;
     }
     else return 0;
   }
   else p->size = size;
800039e6:	30 08       	mov	r8,0
   unsigned n, i;
 
   if(!uivector_resize(&tree->tree2d, tree->numcodes * 2)) return 9901; /*if failed return not enough memory error*/
   /*convert tree1d[] to tree2d[][]. In the 2D array, a value of 32767 means uninited, a value >= numcodes is an address to another bit, a value < numcodes is a code. The 2 rows are the 2 possible bit values (0 or 1), there are as many columns as codes - 1
   a good huffmann tree has N * 2 - 1 nodes, of which N - 1 are internal nodes. Here, the internal nodes are stored (what their 0 and 1 option point to). There is only memory for such good tree currently, if there are more nodes (due to too long length codes), error 55 will happen*/
   for(n = 0;  n < tree->numcodes * 2; n++) tree->tree2d.data[n] = 32767; /*32767 here means the tree2d isn't filled there yet*/
800039e8:	e0 6b 7f ff 	mov	r11,32767
800039ec:	6e 09       	ld.w	r9,r7[0x0]
800039ee:	f2 08 09 2b 	st.w	r9[r8<<0x2],r11
800039f2:	2f f8       	sub	r8,-1
800039f4:	6e a5       	ld.w	r5,r7[0x28]
800039f6:	0a 9a       	mov	r10,r5
800039f8:	ea 09 15 01 	lsl	r9,r5,0x1
800039fc:	12 38       	cp.w	r8,r9
800039fe:	cf 73       	brcs	800039ec <HuffmanTree_makeFromLengths2+0xf4>
 
   for(n = 0; n < tree->numcodes; n++) /*the codes*/
80003a00:	58 05       	cp.w	r5,0
80003a02:	e0 80 00 95 	breq	80003b2c <HuffmanTree_makeFromLengths2+0x234>
80003a06:	30 02       	mov	r2,0
80003a08:	6e 63       	ld.w	r3,r7[0x18]
80003a0a:	04 99       	mov	r9,r2
80003a0c:	04 9e       	mov	lr,r2
80003a0e:	e4 04 15 02 	lsl	r4,r2,0x2
   for(i = 0; i < tree->lengths.data[n]; i++) /*the bits for this code*/
80003a12:	e6 04 03 0b 	ld.w	r11,r3[r4]
80003a16:	58 0b       	cp.w	r11,0
80003a18:	c3 c0       	breq	80003a90 <HuffmanTree_makeFromLengths2+0x198>
   {
     unsigned char bit = (unsigned char)((tree->tree1d.data[n] >> (tree->lengths.data[n] - i - 1)) & 1);
80003a1a:	6e 38       	ld.w	r8,r7[0xc]
80003a1c:	f0 04 03 0c 	ld.w	r12,r8[r4]
     if(treepos > tree->numcodes - 2) return 55; /*error 55: oversubscribed; see description in header*/
80003a20:	ea c8 00 02 	sub	r8,r5,2
80003a24:	12 38       	cp.w	r8,r9
80003a26:	c6 43       	brcs	80003aee <HuffmanTree_makeFromLengths2+0x1f6>
   for(n = 0;  n < tree->numcodes * 2; n++) tree->tree2d.data[n] = 32767; /*32767 here means the tree2d isn't filled there yet*/
 
   for(n = 0; n < tree->numcodes; n++) /*the codes*/
   for(i = 0; i < tree->lengths.data[n]; i++) /*the bits for this code*/
   {
     unsigned char bit = (unsigned char)((tree->tree1d.data[n] >> (tree->lengths.data[n] - i - 1)) & 1);
80003a28:	f6 c8 00 01 	sub	r8,r11,1
80003a2c:	f8 08 0a 4c 	lsr	r12,r12,r8
80003a30:	30 18       	mov	r8,1
80003a32:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80003a36:	c1 58       	rjmp	80003a60 <HuffmanTree_makeFromLengths2+0x168>
         nodefilled++;
         tree->tree2d.data[2 * treepos + bit] = nodefilled + tree->numcodes; /*addresses encoded with numcodes added to it*/
         treepos = nodefilled;
       }
     }
     else treepos = tree->tree2d.data[2 * treepos + bit] - tree->numcodes;
80003a38:	14 19       	sub	r9,r10
   /*convert tree1d[] to tree2d[][]. In the 2D array, a value of 32767 means uninited, a value >= numcodes is an address to another bit, a value < numcodes is a code. The 2 rows are the 2 possible bit values (0 or 1), there are as many columns as codes - 1
   a good huffmann tree has N * 2 - 1 nodes, of which N - 1 are internal nodes. Here, the internal nodes are stored (what their 0 and 1 option point to). There is only memory for such good tree currently, if there are more nodes (due to too long length codes), error 55 will happen*/
   for(n = 0;  n < tree->numcodes * 2; n++) tree->tree2d.data[n] = 32767; /*32767 here means the tree2d isn't filled there yet*/
 
   for(n = 0; n < tree->numcodes; n++) /*the codes*/
   for(i = 0; i < tree->lengths.data[n]; i++) /*the bits for this code*/
80003a3a:	16 38       	cp.w	r8,r11
80003a3c:	c2 92       	brcc	80003a8e <HuffmanTree_makeFromLengths2+0x196>
   {
     unsigned char bit = (unsigned char)((tree->tree1d.data[n] >> (tree->lengths.data[n] - i - 1)) & 1);
80003a3e:	6e 3c       	ld.w	r12,r7[0xc]
80003a40:	f0 c1 ff ff 	sub	r1,r8,-1
80003a44:	f8 04 03 00 	ld.w	r0,r12[r4]
     if(treepos > tree->numcodes - 2) return 55; /*error 55: oversubscribed; see description in header*/
80003a48:	f4 c6 00 02 	sub	r6,r10,2
80003a4c:	12 36       	cp.w	r6,r9
80003a4e:	c5 03       	brcs	80003aee <HuffmanTree_makeFromLengths2+0x1f6>
   for(n = 0;  n < tree->numcodes * 2; n++) tree->tree2d.data[n] = 32767; /*32767 here means the tree2d isn't filled there yet*/
 
   for(n = 0; n < tree->numcodes; n++) /*the codes*/
   for(i = 0; i < tree->lengths.data[n]; i++) /*the bits for this code*/
   {
     unsigned char bit = (unsigned char)((tree->tree1d.data[n] >> (tree->lengths.data[n] - i - 1)) & 1);
80003a50:	f6 cc 00 01 	sub	r12,r11,1
80003a54:	10 1c       	sub	r12,r8
80003a56:	02 98       	mov	r8,r1
80003a58:	e0 0c 0a 4c 	lsr	r12,r0,r12
80003a5c:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
     if(treepos > tree->numcodes - 2) return 55; /*error 55: oversubscribed; see description in header*/
     if(tree->tree2d.data[2 * treepos + bit] == 32767) /*not yet filled in*/
80003a60:	f8 09 00 19 	add	r9,r12,r9<<0x1
80003a64:	6e 06       	ld.w	r6,r7[0x0]
80003a66:	ec 09 00 2c 	add	r12,r6,r9<<0x2
80003a6a:	78 09       	ld.w	r9,r12[0x0]
80003a6c:	e0 49 7f ff 	cp.w	r9,32767
80003a70:	ce 41       	brne	80003a38 <HuffmanTree_makeFromLengths2+0x140>
     {
       if(i + 1 == tree->lengths.data[n]) /*last bit*/
80003a72:	16 38       	cp.w	r8,r11
80003a74:	c3 f0       	breq	80003af2 <HuffmanTree_makeFromLengths2+0x1fa>
         tree->tree2d.data[2 * treepos + bit] = n; /*put the current code in it*/
         treepos = 0;
       }
       else /*put address of the next step in here, first that address has to be found of course (it's just nodefilled + 1)...*/
       {
         nodefilled++;
80003a76:	2f fe       	sub	lr,-1
         tree->tree2d.data[2 * treepos + bit] = nodefilled + tree->numcodes; /*addresses encoded with numcodes added to it*/
80003a78:	fc 0a 00 0a 	add	r10,lr,r10
80003a7c:	99 0a       	st.w	r12[0x0],r10
80003a7e:	1c 99       	mov	r9,lr
80003a80:	6e aa       	ld.w	r10,r7[0x28]
80003a82:	6e 63       	ld.w	r3,r7[0x18]
80003a84:	14 95       	mov	r5,r10
80003a86:	e6 04 03 0b 	ld.w	r11,r3[r4]
   /*convert tree1d[] to tree2d[][]. In the 2D array, a value of 32767 means uninited, a value >= numcodes is an address to another bit, a value < numcodes is a code. The 2 rows are the 2 possible bit values (0 or 1), there are as many columns as codes - 1
   a good huffmann tree has N * 2 - 1 nodes, of which N - 1 are internal nodes. Here, the internal nodes are stored (what their 0 and 1 option point to). There is only memory for such good tree currently, if there are more nodes (due to too long length codes), error 55 will happen*/
   for(n = 0;  n < tree->numcodes * 2; n++) tree->tree2d.data[n] = 32767; /*32767 here means the tree2d isn't filled there yet*/
 
   for(n = 0; n < tree->numcodes; n++) /*the codes*/
   for(i = 0; i < tree->lengths.data[n]; i++) /*the bits for this code*/
80003a8a:	16 38       	cp.w	r8,r11
80003a8c:	cd 93       	brcs	80003a3e <HuffmanTree_makeFromLengths2+0x146>
80003a8e:	0a 9a       	mov	r10,r5
   if(!uivector_resize(&tree->tree2d, tree->numcodes * 2)) return 9901; /*if failed return not enough memory error*/
   /*convert tree1d[] to tree2d[][]. In the 2D array, a value of 32767 means uninited, a value >= numcodes is an address to another bit, a value < numcodes is a code. The 2 rows are the 2 possible bit values (0 or 1), there are as many columns as codes - 1
   a good huffmann tree has N * 2 - 1 nodes, of which N - 1 are internal nodes. Here, the internal nodes are stored (what their 0 and 1 option point to). There is only memory for such good tree currently, if there are more nodes (due to too long length codes), error 55 will happen*/
   for(n = 0;  n < tree->numcodes * 2; n++) tree->tree2d.data[n] = 32767; /*32767 here means the tree2d isn't filled there yet*/
 
   for(n = 0; n < tree->numcodes; n++) /*the codes*/
80003a90:	2f f2       	sub	r2,-1
80003a92:	0a 32       	cp.w	r2,r5
80003a94:	cb d3       	brcs	80003a0e <HuffmanTree_makeFromLengths2+0x116>
         treepos = nodefilled;
       }
     }
     else treepos = tree->tree2d.data[2 * treepos + bit] - tree->numcodes;
   }
   for(n = 0;  n < tree->numcodes * 2; n++) if(tree->tree2d.data[n] == 32767) tree->tree2d.data[n] = 0; /*remove possible remaining 32767's*/
80003a96:	ea 0a 15 01 	lsl	r10,r5,0x1
80003a9a:	c4 90       	breq	80003b2c <HuffmanTree_makeFromLengths2+0x234>
80003a9c:	30 08       	mov	r8,0
80003a9e:	10 9c       	mov	r12,r8
80003aa0:	c0 38       	rjmp	80003aa6 <HuffmanTree_makeFromLengths2+0x1ae>
80003aa2:	14 38       	cp.w	r8,r10
80003aa4:	c4 42       	brcc	80003b2c <HuffmanTree_makeFromLengths2+0x234>
80003aa6:	6e 09       	ld.w	r9,r7[0x0]
80003aa8:	f2 08 00 29 	add	r9,r9,r8<<0x2
80003aac:	2f f8       	sub	r8,-1
80003aae:	72 0b       	ld.w	r11,r9[0x0]
80003ab0:	e0 4b 7f ff 	cp.w	r11,32767
80003ab4:	cf 71       	brne	80003aa2 <HuffmanTree_makeFromLengths2+0x1aa>
80003ab6:	93 0c       	st.w	r9[0x0],r12
80003ab8:	6e aa       	ld.w	r10,r7[0x28]
80003aba:	a1 7a       	lsl	r10,0x1
80003abc:	cf 3b       	rjmp	80003aa2 <HuffmanTree_makeFromLengths2+0x1aa>
 
 static unsigned uivector_resize(uivector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned) > p->allocsize)
   {
     size_t newsize = size * sizeof(unsigned) * 2;
80003abe:	ec 05 15 03 	lsl	r5,r6,0x3
     void* data = realloc(p->data, newsize);
80003ac2:	78 3c       	ld.w	r12,r12[0xc]
80003ac4:	0a 9b       	mov	r11,r5
80003ac6:	e0 a0 64 e9 	rcall	80010498 <realloc>
     if(data)
80003aca:	c2 70       	breq	80003b18 <HuffmanTree_makeFromLengths2+0x220>
     {
       p->allocsize = newsize;
80003acc:	8f 55       	st.w	r7[0x14],r5
       p->data = (unsigned*)data;
       p->size = size;
80003ace:	8f 46       	st.w	r7[0x10],r6
     size_t newsize = size * sizeof(unsigned) * 2;
     void* data = realloc(p->data, newsize);
     if(data)
     {
       p->allocsize = newsize;
       p->data = (unsigned*)data;
80003ad0:	8f 3c       	st.w	r7[0xc],r12
   unsigned bits, n, error = 0;
 
   uivector_init(&blcount);
   uivector_init(&nextcode);
   if(!uivector_resize(&tree->tree1d, tree->numcodes)
   || !uivector_resizev(&blcount, tree->maxbitlen + 1, 0)
80003ad2:	6e 95       	ld.w	r5,r7[0x24]
80003ad4:	2f f5       	sub	r5,-1
   ((uivector*)p)->data = NULL;
 }
 
 static unsigned uivector_resize(uivector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned) > p->allocsize)
80003ad6:	ea 06 15 02 	lsl	r6,r5,0x2
80003ada:	fe 90 ff 1f 	breq	80003918 <HuffmanTree_makeFromLengths2+0x20>
   {
     size_t newsize = size * sizeof(unsigned) * 2;
     void* data = realloc(p->data, newsize);
80003ade:	ea 0b 15 03 	lsl	r11,r5,0x3
80003ae2:	30 0c       	mov	r12,0
80003ae4:	e0 a0 64 da 	rcall	80010498 <realloc>
     if(data)
80003ae8:	c1 80       	breq	80003b18 <HuffmanTree_makeFromLengths2+0x220>
     {
       p->allocsize = newsize;
       p->data = (unsigned*)data;
80003aea:	18 96       	mov	r6,r12
80003aec:	c1 6b       	rjmp	80003918 <HuffmanTree_makeFromLengths2+0x20>
         treepos = nodefilled;
       }
     }
     else treepos = tree->tree2d.data[2 * treepos + bit] - tree->numcodes;
   }
   for(n = 0;  n < tree->numcodes * 2; n++) if(tree->tree2d.data[n] == 32767) tree->tree2d.data[n] = 0; /*remove possible remaining 32767's*/
80003aee:	33 7c       	mov	r12,55
80003af0:	d8 32       	popm	r0-r7,pc
     if(treepos > tree->numcodes - 2) return 55; /*error 55: oversubscribed; see description in header*/
     if(tree->tree2d.data[2 * treepos + bit] == 32767) /*not yet filled in*/
     {
       if(i + 1 == tree->lengths.data[n]) /*last bit*/
       {
         tree->tree2d.data[2 * treepos + bit] = n; /*put the current code in it*/
80003af2:	99 02       	st.w	r12[0x0],r2
80003af4:	30 09       	mov	r9,0
80003af6:	6e a5       	ld.w	r5,r7[0x28]
80003af8:	6e 63       	ld.w	r3,r7[0x18]
80003afa:	0a 9a       	mov	r10,r5
80003afc:	e6 04 03 0b 	ld.w	r11,r3[r4]
80003b00:	c9 db       	rjmp	80003a3a <HuffmanTree_makeFromLengths2+0x142>
 
 static unsigned uivector_resize(uivector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned) > p->allocsize)
   {
     size_t newsize = size * sizeof(unsigned) * 2;
80003b02:	a5 65       	lsl	r5,0x4
     void* data = realloc(p->data, newsize);
80003b04:	6e 0c       	ld.w	r12,r7[0x0]
80003b06:	0a 9b       	mov	r11,r5
80003b08:	e0 a0 64 c8 	rcall	80010498 <realloc>
     if(data)
80003b0c:	c1 90       	breq	80003b3e <HuffmanTree_makeFromLengths2+0x246>
     {
       p->allocsize = newsize;
80003b0e:	8f 25       	st.w	r7[0x8],r5
       p->data = (unsigned*)data;
80003b10:	8f 0c       	st.w	r7[0x0],r12
       p->size = size;
80003b12:	8f 16       	st.w	r7[0x4],r6
80003b14:	6e a5       	ld.w	r5,r7[0x28]
80003b16:	c6 4b       	rjmp	800039de <HuffmanTree_makeFromLengths2+0xe6>
     error = 9902;
 
   if(!error)
   {
     /*step 1: count number of instances of each code length*/
     for(bits = 0; bits < tree->numcodes; bits++) blcount.data[tree->lengths.data[bits]]++;
80003b18:	30 06       	mov	r6,0
 } uivector;
 
 static void uivector_cleanup(void* p)
 {
   ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
   free(((uivector*)p)->data);
80003b1a:	0c 9c       	mov	r12,r6
80003b1c:	e0 a0 61 e8 	rcall	8000feec <free>
80003b20:	30 0c       	mov	r12,0
80003b22:	e0 a0 61 e5 	rcall	8000feec <free>
80003b26:	e0 6c 26 ae 	mov	r12,9902
80003b2a:	d8 32       	popm	r0-r7,pc
         treepos = nodefilled;
       }
     }
     else treepos = tree->tree2d.data[2 * treepos + bit] - tree->numcodes;
   }
   for(n = 0;  n < tree->numcodes * 2; n++) if(tree->tree2d.data[n] == 32767) tree->tree2d.data[n] = 0; /*remove possible remaining 32767's*/
80003b2c:	d8 3a       	popm	r0-r7,pc,r12=0
 static unsigned uivector_resize(uivector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned) > p->allocsize)
   {
     size_t newsize = size * sizeof(unsigned) * 2;
     void* data = realloc(p->data, newsize);
80003b2e:	ea 0b 15 03 	lsl	r11,r5,0x3
80003b32:	30 0c       	mov	r12,0
80003b34:	e0 a0 64 b2 	rcall	80010498 <realloc>
     if(data)
80003b38:	cf 10       	breq	80003b1a <HuffmanTree_makeFromLengths2+0x222>
     {
       p->allocsize = newsize;
       p->data = (unsigned*)data;
80003b3a:	18 94       	mov	r4,r12
80003b3c:	cf ea       	rjmp	80003938 <HuffmanTree_makeFromLengths2+0x40>
 {
   if(size * sizeof(unsigned) > p->allocsize)
   {
     size_t newsize = size * sizeof(unsigned) * 2;
     void* data = realloc(p->data, newsize);
     if(data)
80003b3e:	e0 6c 26 ad 	mov	r12,9901
80003b42:	d8 32       	popm	r0-r7,pc

80003b44 <HuffmanTree_makeFromLengths>:
80003b44:	eb cd 40 e0 	pushm	r5-r7,lr
80003b48:	20 2d       	sub	sp,8
80003b4a:	16 96       	mov	r6,r11
   else return error;
 }
 
 /*given the code lengths (as stored in the PNG file), generate the tree as defined by Deflate. maxbitlen is the maximum bits that a code in the tree can have. return value is error.*/
 static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen, size_t numcodes, unsigned maxbitlen)
 {
80003b4c:	18 97       	mov	r7,r12
   ((uivector*)p)->data = NULL;
 }
 
 static unsigned uivector_resize(uivector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned) > p->allocsize)
80003b4e:	f4 0b 15 02 	lsl	r11,r10,0x2
 
 /*given the code lengths (as stored in the PNG file), generate the tree as defined by Deflate. maxbitlen is the maximum bits that a code in the tree can have. return value is error.*/
 static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen, size_t numcodes, unsigned maxbitlen)
 {
   unsigned i;
   if(!uivector_resize(&tree->lengths, numcodes)) return 9903;
80003b52:	78 88       	ld.w	r8,r12[0x20]
80003b54:	10 3b       	cp.w	r11,r8
80003b56:	e0 8b 00 15 	brhi	80003b80 <HuffmanTree_makeFromLengths+0x3c>
       p->data = (unsigned*)data;
       p->size = size;
     }
     else return 0;
   }
   else p->size = size;
80003b5a:	99 7a       	st.w	r12[0x1c],r10
 /*given the code lengths (as stored in the PNG file), generate the tree as defined by Deflate. maxbitlen is the maximum bits that a code in the tree can have. return value is error.*/
 static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen, size_t numcodes, unsigned maxbitlen)
 {
   unsigned i;
   if(!uivector_resize(&tree->lengths, numcodes)) return 9903;
   for(i = 0; i < numcodes; i++) tree->lengths.data[i] = bitlen[i];
80003b5c:	58 0a       	cp.w	r10,0
80003b5e:	c0 a0       	breq	80003b72 <HuffmanTree_makeFromLengths+0x2e>
80003b60:	30 08       	mov	r8,0
80003b62:	6e 6b       	ld.w	r11,r7[0x18]
80003b64:	0d 0c       	ld.w	r12,r6++
80003b66:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
80003b6a:	2f f8       	sub	r8,-1
80003b6c:	10 3a       	cp.w	r10,r8
80003b6e:	fe 9b ff fa 	brhi	80003b62 <HuffmanTree_makeFromLengths+0x1e>
   tree->numcodes = (unsigned)numcodes; /*number of symbols*/
80003b72:	8f aa       	st.w	r7[0x28],r10
   tree->maxbitlen = maxbitlen;
80003b74:	8f 99       	st.w	r7[0x24],r9
   return HuffmanTree_makeFromLengths2(tree);
80003b76:	0e 9c       	mov	r12,r7
80003b78:	cc 0e       	rcall	800038f8 <HuffmanTree_makeFromLengths2>
80003b7a:	2f ed       	sub	sp,-8
 }
80003b7c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003b80:	f4 05 15 03 	lsl	r5,r10,0x3
 
 static unsigned uivector_resize(uivector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned) > p->allocsize)
   {
     size_t newsize = size * sizeof(unsigned) * 2;
80003b84:	78 6c       	ld.w	r12,r12[0x18]
     void* data = realloc(p->data, newsize);
80003b86:	0a 9b       	mov	r11,r5
80003b88:	50 1a       	stdsp	sp[0x4],r10
80003b8a:	50 09       	stdsp	sp[0x0],r9
80003b8c:	e0 a0 64 86 	rcall	80010498 <realloc>
80003b90:	40 1a       	lddsp	r10,sp[0x4]
     if(data)
80003b92:	40 09       	lddsp	r9,sp[0x0]
80003b94:	c0 50       	breq	80003b9e <HuffmanTree_makeFromLengths+0x5a>
80003b96:	8f 85       	st.w	r7[0x20],r5
     {
       p->allocsize = newsize;
80003b98:	8f 6c       	st.w	r7[0x18],r12
       p->data = (unsigned*)data;
80003b9a:	8f 7a       	st.w	r7[0x1c],r10
       p->size = size;
80003b9c:	ce 0b       	rjmp	80003b5c <HuffmanTree_makeFromLengths+0x18>
80003b9e:	e0 6c 26 af 	mov	r12,9903
 {
   if(size * sizeof(unsigned) > p->allocsize)
   {
     size_t newsize = size * sizeof(unsigned) * 2;
     void* data = realloc(p->data, newsize);
     if(data)
80003ba2:	ce cb       	rjmp	80003b7a <HuffmanTree_makeFromLengths+0x36>

80003ba4 <LodePNG_Decoder_init>:
80003ba4:	30 6a       	mov	r10,6
80003ba6:	30 08       	mov	r8,0
80003ba8:	30 19       	mov	r9,1
80003baa:	f9 4a 00 48 	st.w	r12[72],r10
80003bae:	99 5a       	st.w	r12[0x14],r10
 {
   settings->color_convert = 1;
 #ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
   settings->readTextChunks = 1;
 #endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
   settings->ignoreCrc = 0;
80003bb0:	99 18       	st.w	r12[0x4],r8
 void LodePNG_InfoColor_init(LodePNG_InfoColor* info)
 {
   info->key_defined = 0;
   info->key_r = info->key_g = info->key_b = 0;
   info->colorType = 6;
   info->bitDepth = 8;
80003bb2:	30 8a       	mov	r10,8
 #ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
   settings->readTextChunks = 1;
 #endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
   settings->ignoreCrc = 0;
 #ifdef LODEPNG_COMPILE_UNKNOWN_CHUNKS
   settings->rememberUnknownChunks = 0;
80003bb4:	99 48       	st.w	r12[0x10],r8
 
 #ifdef LODEPNG_COMPILE_DECODER
 
 void LodeZlib_DecompressSettings_init(LodeZlib_DecompressSettings* settings)
 {
   settings->ignoreAdler32 = 0;
80003bb6:	99 08       	st.w	r12[0x0],r8
 
 /* ////////////////////////////////////////////////////////////////////////// */
 
 void LodePNG_InfoColor_init(LodePNG_InfoColor* info)
 {
   info->key_defined = 0;
80003bb8:	99 98       	st.w	r12[0x24],r8
   info->key_r = info->key_g = info->key_b = 0;
80003bba:	99 c8       	st.w	r12[0x30],r8
80003bbc:	99 b8       	st.w	r12[0x2c],r8
80003bbe:	99 a8       	st.w	r12[0x28],r8
   info->colorType = 6;
   info->bitDepth = 8;
   info->palette = 0;
80003bc0:	99 78       	st.w	r12[0x1c],r8
   info->palettesize = 0;
80003bc2:	99 88       	st.w	r12[0x20],r8
 
 #endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
 
 void LodePNG_InfoPng_init(LodePNG_InfoPng* info)
 {
   info->width = info->height = 0;
80003bc4:	99 e8       	st.w	r12[0x38],r8
80003bc6:	99 d8       	st.w	r12[0x34],r8
 
 /* ////////////////////////////////////////////////////////////////////////// */
 
 void LodePNG_InfoColor_init(LodePNG_InfoColor* info)
 {
   info->key_defined = 0;
80003bc8:	f9 48 00 58 	st.w	r12[88],r8
   info->key_r = info->key_g = info->key_b = 0;
80003bcc:	f9 48 00 64 	st.w	r12[100],r8
80003bd0:	f9 48 00 60 	st.w	r12[96],r8
80003bd4:	f9 48 00 5c 	st.w	r12[92],r8
   info->colorType = 6;
   info->bitDepth = 8;
   info->palette = 0;
80003bd8:	f9 48 00 50 	st.w	r12[80],r8
   info->palettesize = 0;
80003bdc:	f9 48 00 54 	st.w	r12[84],r8
 
 void LodePNG_InfoPng_init(LodePNG_InfoPng* info)
 {
   info->width = info->height = 0;
   LodePNG_InfoColor_init(&info->color);
   info->interlaceMethod = 0;
80003be0:	f9 48 00 44 	st.w	r12[68],r8
   info->compressionMethod = 0;
80003be4:	99 f8       	st.w	r12[0x3c],r8
   info->filterMethod = 0;
80003be6:	f9 48 00 40 	st.w	r12[64],r8
 #ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
   info->background_defined = 0;
80003bea:	f9 48 00 68 	st.w	r12[104],r8
   info->background_r = info->background_g = info->background_b = 0;
80003bee:	f9 48 00 74 	st.w	r12[116],r8
80003bf2:	f9 48 00 70 	st.w	r12[112],r8
80003bf6:	f9 48 00 6c 	st.w	r12[108],r8
 
 #ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
 
 void LodePNG_Text_init(LodePNG_Text* text)
 {
   text->num = 0;
80003bfa:	f9 48 00 78 	st.w	r12[120],r8
   text->keys = NULL;
80003bfe:	f9 48 00 7c 	st.w	r12[124],r8
   text->strings = NULL;
80003c02:	f9 48 00 80 	st.w	r12[128],r8
 }
 #endif /*LODEPNG_COMPILE_DISK*/
 
 void LodePNG_DecodeSettings_init(LodePNG_DecodeSettings* settings)
 {
   settings->color_convert = 1;
80003c06:	99 29       	st.w	r12[0x8],r9
 #ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
   settings->readTextChunks = 1;
80003c08:	99 39       	st.w	r12[0xc],r9
 void LodePNG_InfoColor_init(LodePNG_InfoColor* info)
 {
   info->key_defined = 0;
   info->key_r = info->key_g = info->key_b = 0;
   info->colorType = 6;
   info->bitDepth = 8;
80003c0a:	f9 4a 00 4c 	st.w	r12[76],r10
80003c0e:	99 6a       	st.w	r12[0x18],r10
 
 /******************************************************************************/
 
 void LodePNG_IText_init(LodePNG_IText* text)
 {
   text->num = 0;
80003c10:	f9 48 00 84 	st.w	r12[132],r8
 void LodePNG_Decoder_init(LodePNG_Decoder* decoder)
 {
   LodePNG_DecodeSettings_init(&decoder->settings);
   LodePNG_InfoRaw_init(&decoder->infoRaw);
   LodePNG_InfoPng_init(&decoder->infoPng);
   decoder->error = 1;
80003c14:	f9 49 00 d0 	st.w	r12[208],r9
 
 void LodePNG_UnknownChunks_init(LodePNG_UnknownChunks* chunks)
 {
   unsigned i;
   for(i = 0; i < 3; i++) chunks->data[i] = 0;
   for(i = 0; i < 3; i++) chunks->datasize[i] = 0;
80003c18:	f9 48 00 cc 	st.w	r12[204],r8
 /******************************************************************************/
 
 void LodePNG_IText_init(LodePNG_IText* text)
 {
   text->num = 0;
   text->keys = NULL;
80003c1c:	f9 48 00 88 	st.w	r12[136],r8
   text->langtags = NULL;
80003c20:	f9 48 00 8c 	st.w	r12[140],r8
   text->transkeys = NULL;
80003c24:	f9 48 00 90 	st.w	r12[144],r8
   text->strings = NULL;
80003c28:	f9 48 00 94 	st.w	r12[148],r8
   info->background_r = info->background_g = info->background_b = 0;
 
   LodePNG_Text_init(&info->text);
   LodePNG_IText_init(&info->itext);
 
   info->time_defined = 0;
80003c2c:	f9 68 00 98 	st.b	r12[152],r8
   info->phys_defined = 0;
80003c30:	f9 48 00 a8 	st.w	r12[168],r8
 #ifdef LODEPNG_COMPILE_UNKNOWN_CHUNKS
 
 void LodePNG_UnknownChunks_init(LodePNG_UnknownChunks* chunks)
 {
   unsigned i;
   for(i = 0; i < 3; i++) chunks->data[i] = 0;
80003c34:	f9 48 00 b8 	st.w	r12[184],r8
80003c38:	f9 48 00 bc 	st.w	r12[188],r8
80003c3c:	f9 48 00 c0 	st.w	r12[192],r8
   for(i = 0; i < 3; i++) chunks->datasize[i] = 0;
80003c40:	f9 48 00 c4 	st.w	r12[196],r8
80003c44:	f9 48 00 c8 	st.w	r12[200],r8
 {
   LodePNG_DecodeSettings_init(&decoder->settings);
   LodePNG_InfoRaw_init(&decoder->infoRaw);
   LodePNG_InfoPng_init(&decoder->infoPng);
   decoder->error = 1;
 }
80003c48:	5e fc       	retal	r12
80003c4a:	d7 03       	nop

80003c4c <LodePNG_InfoPng_cleanup>:
   LodePNG_UnknownChunks_init(&info->unknown_chunks);
 #endif /*LODEPNG_COMPILE_UNKNOWN_CHUNKS*/
 }
 
 void LodePNG_InfoPng_cleanup(LodePNG_InfoPng* info)
 {
80003c4c:	eb cd 40 fc 	pushm	r2-r7,lr
80003c50:	18 92       	mov	r2,r12
   LodePNG_InfoColor_clearPalette(info);
 }
 
 void LodePNG_InfoColor_clearPalette(LodePNG_InfoColor* info)
 {
   if(info->palette) free(info->palette);
80003c52:	78 7c       	ld.w	r12,r12[0x1c]
80003c54:	58 0c       	cp.w	r12,0
80003c56:	c0 30       	breq	80003c5c <LodePNG_InfoPng_cleanup+0x10>
80003c58:	e0 a0 61 4a 	rcall	8000feec <free>
   info->palettesize = 0;
80003c5c:	30 07       	mov	r7,0
80003c5e:	85 87       	st.w	r2[0x20],r7
 
 void LodePNG_InfoPng_cleanup(LodePNG_InfoPng* info)
 {
   LodePNG_InfoColor_cleanup(&info->color);
 #ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
   LodePNG_Text_cleanup(&info->text);
80003c60:	e4 c6 ff bc 	sub	r6,r2,-68
80003c64:	65 18       	ld.w	r8,r2[0x44]
80003c66:	58 08       	cp.w	r8,0
80003c68:	c1 50       	breq	80003c92 <LodePNG_InfoPng_cleanup+0x46>
 }
 
 static void string_cleanup(char** out) /*free the above pair again*/
 {
   free(*out);
   *out = NULL;
80003c6a:	0e 93       	mov	r3,r7
 
 void LodePNG_InfoPng_cleanup(LodePNG_InfoPng* info)
 {
   LodePNG_InfoColor_cleanup(&info->color);
 #ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
   LodePNG_Text_cleanup(&info->text);
80003c6c:	ee 05 15 02 	lsl	r5,r7,0x2
 void LodePNG_Text_clear(LodePNG_Text* text)
 {
   size_t i;
   for(i = 0; i < text->num; i++)
     {
     string_cleanup(&text->keys[i]);
80003c70:	6c 14       	ld.w	r4,r6[0x4]
80003c72:	0a 04       	add	r4,r5
   string_resize(out, 0);
 }
 
 static void string_cleanup(char** out) /*free the above pair again*/
 {
   free(*out);
80003c74:	68 0c       	ld.w	r12,r4[0x0]
80003c76:	e0 a0 61 3b 	rcall	8000feec <free>
   *out = NULL;
80003c7a:	89 03       	st.w	r4[0x0],r3
 {
   size_t i;
   for(i = 0; i < text->num; i++)
     {
     string_cleanup(&text->keys[i]);
     string_cleanup(&text->strings[i]);
80003c7c:	6c 28       	ld.w	r8,r6[0x8]
80003c7e:	f0 05 00 05 	add	r5,r8,r5
   string_resize(out, 0);
 }
 
 static void string_cleanup(char** out) /*free the above pair again*/
 {
   free(*out);
80003c82:	6a 0c       	ld.w	r12,r5[0x0]
80003c84:	e0 a0 61 34 	rcall	8000feec <free>
   *out = NULL;
80003c88:	8b 03       	st.w	r5[0x0],r3
 }
 
 void LodePNG_Text_clear(LodePNG_Text* text)
 {
   size_t i;
   for(i = 0; i < text->num; i++)
80003c8a:	2f f7       	sub	r7,-1
80003c8c:	6c 08       	ld.w	r8,r6[0x0]
80003c8e:	10 37       	cp.w	r7,r8
80003c90:	ce e3       	brcs	80003c6c <LodePNG_InfoPng_cleanup+0x20>
     {
     string_cleanup(&text->keys[i]);
     string_cleanup(&text->strings[i]);
     }
   free(text->keys);
80003c92:	65 2c       	ld.w	r12,r2[0x48]
80003c94:	e0 a0 61 2c 	rcall	8000feec <free>
   free(text->strings);
80003c98:	65 3c       	ld.w	r12,r2[0x4c]
80003c9a:	e0 a0 61 29 	rcall	8000feec <free>
   text->strings = NULL;
 }
 
 void LodePNG_IText_cleanup(LodePNG_IText* text)
 {
   LodePNG_IText_clear(text);
80003c9e:	e4 cc ff b0 	sub	r12,r2,-80
80003ca2:	fe b0 fc 97 	rcall	800035d0 <LodePNG_IText_clear>
 }
 
 void LodePNG_UnknownChunks_cleanup(LodePNG_UnknownChunks* chunks)
 {
   unsigned i;
   for(i = 0; i < 3; i++) free(chunks->data[i]);
80003ca6:	e4 fc 00 84 	ld.w	r12,r2[132]
80003caa:	e0 a0 61 21 	rcall	8000feec <free>
80003cae:	e4 fc 00 88 	ld.w	r12,r2[136]
80003cb2:	e0 a0 61 1d 	rcall	8000feec <free>
80003cb6:	e4 fc 00 8c 	ld.w	r12,r2[140]
80003cba:	e0 a0 61 19 	rcall	8000feec <free>
   LodePNG_IText_cleanup(&info->itext);
 #endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
 #ifdef LODEPNG_COMPILE_UNKNOWN_CHUNKS
   LodePNG_UnknownChunks_cleanup(&info->unknown_chunks);
 #endif /*LODEPNG_COMPILE_UNKNOWN_CHUNKS*/
 }
80003cbe:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80003cc2:	d7 03       	nop

80003cc4 <LodePNG_Decoder_cleanup>:
80003cc4:	eb cd 40 fc 	pushm	r2-r7,lr
80003cc8:	18 92       	mov	r2,r12
80003cca:	78 7c       	ld.w	r12,r12[0x1c]
   LodePNG_InfoColor_clearPalette(info);
 }
 
 void LodePNG_InfoColor_clearPalette(LodePNG_InfoColor* info)
 {
   if(info->palette) free(info->palette);
80003ccc:	58 0c       	cp.w	r12,0
80003cce:	c0 30       	breq	80003cd4 <LodePNG_Decoder_cleanup+0x10>
80003cd0:	e0 a0 61 0e 	rcall	8000feec <free>
   info->palettesize = 0;
80003cd4:	30 08       	mov	r8,0
80003cd6:	85 88       	st.w	r2[0x20],r8
   LodePNG_InfoColor_clearPalette(info);
 }
 
 void LodePNG_InfoColor_clearPalette(LodePNG_InfoColor* info)
 {
   if(info->palette) free(info->palette);
80003cd8:	65 4c       	ld.w	r12,r2[0x50]
80003cda:	58 0c       	cp.w	r12,0
80003cdc:	c0 30       	breq	80003ce2 <LodePNG_Decoder_cleanup+0x1e>
80003cde:	e0 a0 61 07 	rcall	8000feec <free>
   info->palettesize = 0;
80003ce2:	30 07       	mov	r7,0
80003ce4:	e5 47 00 54 	st.w	r2[84],r7
 
 void LodePNG_InfoPng_cleanup(LodePNG_InfoPng* info)
 {
   LodePNG_InfoColor_cleanup(&info->color);
 #ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
   LodePNG_Text_cleanup(&info->text);
80003ce8:	e4 c6 ff 88 	sub	r6,r2,-120
 }
 
 void LodePNG_Decoder_cleanup(LodePNG_Decoder* decoder)
 {
   LodePNG_InfoRaw_cleanup(&decoder->infoRaw);
   LodePNG_InfoPng_cleanup(&decoder->infoPng);
80003cec:	65 e8       	ld.w	r8,r2[0x78]
80003cee:	58 08       	cp.w	r8,0
80003cf0:	c1 50       	breq	80003d1a <LodePNG_Decoder_cleanup+0x56>
 }
 
 static void string_cleanup(char** out) /*free the above pair again*/
 {
   free(*out);
   *out = NULL;
80003cf2:	0e 93       	mov	r3,r7
 }
 
 void LodePNG_Decoder_cleanup(LodePNG_Decoder* decoder)
 {
   LodePNG_InfoRaw_cleanup(&decoder->infoRaw);
   LodePNG_InfoPng_cleanup(&decoder->infoPng);
80003cf4:	ee 05 15 02 	lsl	r5,r7,0x2
 void LodePNG_Text_clear(LodePNG_Text* text)
 {
   size_t i;
   for(i = 0; i < text->num; i++)
     {
     string_cleanup(&text->keys[i]);
80003cf8:	6c 14       	ld.w	r4,r6[0x4]
80003cfa:	0a 04       	add	r4,r5
   string_resize(out, 0);
 }
 
 static void string_cleanup(char** out) /*free the above pair again*/
 {
   free(*out);
80003cfc:	68 0c       	ld.w	r12,r4[0x0]
80003cfe:	e0 a0 60 f7 	rcall	8000feec <free>
   *out = NULL;
80003d02:	89 03       	st.w	r4[0x0],r3
 {
   size_t i;
   for(i = 0; i < text->num; i++)
     {
     string_cleanup(&text->keys[i]);
     string_cleanup(&text->strings[i]);
80003d04:	6c 28       	ld.w	r8,r6[0x8]
80003d06:	f0 05 00 05 	add	r5,r8,r5
   string_resize(out, 0);
 }
 
 static void string_cleanup(char** out) /*free the above pair again*/
 {
   free(*out);
80003d0a:	6a 0c       	ld.w	r12,r5[0x0]
80003d0c:	e0 a0 60 f0 	rcall	8000feec <free>
   *out = NULL;
80003d10:	8b 03       	st.w	r5[0x0],r3
 }
 
 void LodePNG_Text_clear(LodePNG_Text* text)
 {
   size_t i;
   for(i = 0; i < text->num; i++)
80003d12:	2f f7       	sub	r7,-1
80003d14:	6c 08       	ld.w	r8,r6[0x0]
80003d16:	10 37       	cp.w	r7,r8
80003d18:	ce e3       	brcs	80003cf4 <LodePNG_Decoder_cleanup+0x30>
     {
     string_cleanup(&text->keys[i]);
     string_cleanup(&text->strings[i]);
     }
   free(text->keys);
80003d1a:	65 fc       	ld.w	r12,r2[0x7c]
80003d1c:	e0 a0 60 e8 	rcall	8000feec <free>
   free(text->strings);
80003d20:	e4 fc 00 80 	ld.w	r12,r2[128]
80003d24:	e0 a0 60 e4 	rcall	8000feec <free>
   text->strings = NULL;
 }
 
 void LodePNG_IText_cleanup(LodePNG_IText* text)
 {
   LodePNG_IText_clear(text);
80003d28:	e4 cc ff 7c 	sub	r12,r2,-132
80003d2c:	fe b0 fc 52 	rcall	800035d0 <LodePNG_IText_clear>
 }
 
 void LodePNG_UnknownChunks_cleanup(LodePNG_UnknownChunks* chunks)
 {
   unsigned i;
   for(i = 0; i < 3; i++) free(chunks->data[i]);
80003d30:	e4 fc 00 b8 	ld.w	r12,r2[184]
80003d34:	e0 a0 60 dc 	rcall	8000feec <free>
80003d38:	e4 fc 00 bc 	ld.w	r12,r2[188]
80003d3c:	e0 a0 60 d8 	rcall	8000feec <free>
80003d40:	e4 fc 00 c0 	ld.w	r12,r2[192]
80003d44:	e0 a0 60 d4 	rcall	8000feec <free>
 
 void LodePNG_Decoder_cleanup(LodePNG_Decoder* decoder)
 {
   LodePNG_InfoRaw_cleanup(&decoder->infoRaw);
   LodePNG_InfoPng_cleanup(&decoder->infoPng);
 }
80003d48:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc

80003d4c <inflateHuffmanBlock>:
80003d4c:	d4 31       	pushm	r0-r7,lr
80003d4e:	fa cd 00 e4 	sub	sp,sp,228
80003d52:	30 03       	mov	r3,0
   return 1;
 }
 
 static void uivector_init(uivector* p)
 {
   p->data = NULL;
80003d54:	52 e3       	stdsp	sp[0xb8],r3
   p->size = p->allocsize = 0;
80003d56:	53 03       	stdsp	sp[0xc0],r3
80003d58:	52 f3       	stdsp	sp[0xbc],r3
   return 1;
 }
 
 static void uivector_init(uivector* p)
 {
   p->data = NULL;
80003d5a:	53 13       	stdsp	sp[0xc4],r3
   p->size = p->allocsize = 0;
80003d5c:	53 33       	stdsp	sp[0xcc],r3
80003d5e:	53 23       	stdsp	sp[0xc8],r3
   return 1;
 }
 
 static void uivector_init(uivector* p)
 {
   p->data = NULL;
80003d60:	53 43       	stdsp	sp[0xd0],r3
   p->size = p->allocsize = 0;
80003d62:	53 63       	stdsp	sp[0xd8],r3
80003d64:	53 53       	stdsp	sp[0xd4],r3
   return 1;
 }
 
 static void uivector_init(uivector* p)
 {
   p->data = NULL;
80003d66:	52 33       	stdsp	sp[0x8c],r3
   p->size = p->allocsize = 0;
80003d68:	52 53       	stdsp	sp[0x94],r3
80003d6a:	52 43       	stdsp	sp[0x90],r3
   return 1;
 }
 
 static void uivector_init(uivector* p)
 {
   p->data = NULL;
80003d6c:	52 63       	stdsp	sp[0x98],r3
   p->size = p->allocsize = 0;
80003d6e:	52 83       	stdsp	sp[0xa0],r3
80003d70:	52 73       	stdsp	sp[0x9c],r3
   return 1;
 }
 
 static void uivector_init(uivector* p)
 {
   p->data = NULL;
80003d72:	52 93       	stdsp	sp[0xa4],r3
   p->size = p->allocsize = 0;
80003d74:	52 b3       	stdsp	sp[0xac],r3
80003d76:	52 a3       	stdsp	sp[0xa8],r3
   return error;
 }
 
 /*inflate a block with dynamic of fixed Huffman tree*/
 static unsigned inflateHuffmanBlock(ucvector* out, const unsigned char* in, size_t* bp, size_t* pos, size_t inlength, unsigned btype)
 {
80003d78:	10 94       	mov	r4,r8
80003d7a:	18 92       	mov	r2,r12
80003d7c:	16 96       	mov	r6,r11
80003d7e:	14 97       	mov	r7,r10
80003d80:	12 95       	mov	r5,r9
80003d82:	44 28       	lddsp	r8,sp[0x108]
   HuffmanTree codetreeD; /*31, the code tree for distance codes*/
 
   HuffmanTree_init(&codetree);
   HuffmanTree_init(&codetreeD);
 
   if(btype == 1) getTreeInflateFixed(&codetree, &codetreeD);
80003d84:	58 18       	cp.w	r8,1
80003d86:	e0 80 01 27 	breq	80003fd4 <inflateHuffmanBlock+0x288>
   else if(btype == 2)
80003d8a:	58 28       	cp.w	r8,2
80003d8c:	e0 80 01 b0 	breq	800040ec <inflateHuffmanBlock+0x3a0>
 
 static void uivector_cleanup(void* p)
 {
   ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
   free(((uivector*)p)->data);
   ((uivector*)p)->data = NULL;
80003d90:	30 0b       	mov	r11,0
80003d92:	42 ec       	lddsp	r12,sp[0xb8]
       (*pos)++;
     }
     else if(code >= FIRST_LENGTH_CODE_INDEX && code <= LAST_LENGTH_CODE_INDEX) /*length code*/
     {
       /*part 1: get length base*/
       size_t length = LENGTHBASE[code - FIRST_LENGTH_CODE_INDEX];
80003d94:	fe f8 0b 60 	ld.w	r8,pc[2912]
80003d98:	16 9e       	mov	lr,r11
     HuffmanTree_init(&codelengthcodetree);
     error = getTreeInflateDynamic(&codetree, &codetreeD, &codelengthcodetree, in, bp, inlength);
     HuffmanTree_cleanup(&codelengthcodetree);
   }
 
   while(!endreached && !error)
80003d9a:	e7 ee 10 0e 	or	lr,r3,lr
80003d9e:	c2 41       	brne	80003de6 <inflateHuffmanBlock+0x9a>
 
 static void uivector_cleanup(void* p)
 {
   ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
   free(((uivector*)p)->data);
   ((uivector*)p)->data = NULL;
80003da0:	6e 09       	ld.w	r9,r7[0x0]
 {
   unsigned treepos = 0, decoded, ct;
   for(;;)
   {
     unsigned char bit;
     if(((*bp) & 0x07) == 0 && ((*bp) >> 3) > inlength) { *error = 10; return 0; } /*error: end of input memory reached without endcode*/
80003da2:	f5 d9 c0 03 	bfextu	r10,r9,0x0,0x3
80003da6:	c4 60       	breq	80003e32 <inflateHuffmanBlock+0xe6>
80003da8:	f2 0b 16 03 	lsr	r11,r9,0x3
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80003dac:	ec 0b 07 0b 	ld.ub	r11,r6[r11]
80003db0:	2f f9       	sub	r9,-1
   (*bitpointer)++;
80003db2:	8f 09       	st.w	r7[0x0],r9
 return value is error.*/
 static unsigned HuffmanTree_decode(const HuffmanTree* tree, unsigned* decoded, unsigned* result, unsigned* treepos, unsigned char bit)
 {
   if((*treepos) >= tree->numcodes) return 11; /*error: it appeared outside the codetree*/
 
   (*result) = tree->tree2d.data[2 * (*treepos) + bit];
80003db4:	f6 0a 08 4a 	asr	r10,r11,r10
 bit is the bit that was just read from the stream
 you have to decode a full symbol (let the decode function return true) before you can try to decode another one, otherwise the state isn't reset
 return value is error.*/
 static unsigned HuffmanTree_decode(const HuffmanTree* tree, unsigned* decoded, unsigned* result, unsigned* treepos, unsigned char bit)
 {
   if((*treepos) >= tree->numcodes) return 11; /*error: it appeared outside the codetree*/
80003db8:	43 8b       	lddsp	r11,sp[0xe0]
 
   (*result) = tree->tree2d.data[2 * (*treepos) + bit];
80003dba:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80003dbe:	f4 0e 00 1a 	add	r10,r10,lr<<0x1
 bit is the bit that was just read from the stream
 you have to decode a full symbol (let the decode function return true) before you can try to decode another one, otherwise the state isn't reset
 return value is error.*/
 static unsigned HuffmanTree_decode(const HuffmanTree* tree, unsigned* decoded, unsigned* result, unsigned* treepos, unsigned char bit)
 {
   if((*treepos) >= tree->numcodes) return 11; /*error: it appeared outside the codetree*/
80003dc2:	1c 3b       	cp.w	r11,lr
80003dc4:	e0 88 00 10 	brls	80003de4 <inflateHuffmanBlock+0x98>
 
   (*result) = tree->tree2d.data[2 * (*treepos) + bit];
80003dc8:	f8 0a 03 23 	ld.w	r3,r12[r10<<0x2]
   (*decoded) = ((*result) < tree->numcodes);
 
   if(*decoded) (*treepos) = 0;
   else (*treepos) = (*result) - tree->numcodes;
80003dcc:	e6 0b 01 0e 	sub	lr,r3,r11
   if((*treepos) >= tree->numcodes) return 11; /*error: it appeared outside the codetree*/
 
   (*result) = tree->tree2d.data[2 * (*treepos) + bit];
   (*decoded) = ((*result) < tree->numcodes);
 
   if(*decoded) (*treepos) = 0;
80003dd0:	06 3b       	cp.w	r11,r3
80003dd2:	fe 98 ff e8 	brls	80003da2 <inflateHuffmanBlock+0x56>
 
   if(!error && bitlen.data[256] == 0) { error = 64; } /*the length of the end code 256 must be larger than 0*/
 
   /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
   if(!error) error = HuffmanTree_makeFromLengths(codetree, &bitlen.data[0], bitlen.size, 15);
   if(!error) error = HuffmanTree_makeFromLengths(codetreeD, &bitlenD.data[0], bitlenD.size, 15);
80003dd6:	12 9a       	mov	r10,r9
 
   while(!endreached && !error)
   {
     unsigned code = huffmanDecodeSymbol(&error, in, bp, &codetree, inlength);
     if(error) break; /*some error happened in the above function*/
     if(code == 256) endreached = 1; /*end code*/
80003dd8:	e0 43 01 00 	cp.w	r3,256
80003ddc:	c3 11       	brne	80003e3e <inflateHuffmanBlock+0xf2>
80003dde:	30 1e       	mov	lr,1
       start = (*pos);
       backward = start - distance;
       if((*pos) + length >= out->size) ucvector_resize(out, ((*pos) + length) * 2); /*reserve more room at once*/
       if((*pos) + length >= out->size) { error = 9914; break; } /*not enough memory*/
 
       for(forward = 0; forward < length; forward++)
80003de0:	30 03       	mov	r3,0
80003de2:	cd cb       	rjmp	80003d9a <inflateHuffmanBlock+0x4e>
 bit is the bit that was just read from the stream
 you have to decode a full symbol (let the decode function return true) before you can try to decode another one, otherwise the state isn't reset
 return value is error.*/
 static unsigned HuffmanTree_decode(const HuffmanTree* tree, unsigned* decoded, unsigned* result, unsigned* treepos, unsigned char bit)
 {
   if((*treepos) >= tree->numcodes) return 11; /*error: it appeared outside the codetree*/
80003de4:	30 b3       	mov	r3,11
   size_t allocsize; /*allocated size in bytes*/
 } uivector;
 
 static void uivector_cleanup(void* p)
 {
   ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
80003de6:	30 07       	mov	r7,0
80003de8:	53 07       	stdsp	sp[0xc0],r7
80003dea:	52 f7       	stdsp	sp[0xbc],r7
   free(((uivector*)p)->data);
80003dec:	e0 a0 60 80 	rcall	8000feec <free>
80003df0:	43 1c       	lddsp	r12,sp[0xc4]
   ((uivector*)p)->data = NULL;
80003df2:	52 e7       	stdsp	sp[0xb8],r7
   size_t allocsize; /*allocated size in bytes*/
 } uivector;
 
 static void uivector_cleanup(void* p)
 {
   ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
80003df4:	53 37       	stdsp	sp[0xcc],r7
80003df6:	53 27       	stdsp	sp[0xc8],r7
   free(((uivector*)p)->data);
80003df8:	e0 a0 60 7a 	rcall	8000feec <free>
80003dfc:	43 4c       	lddsp	r12,sp[0xd0]
   ((uivector*)p)->data = NULL;
80003dfe:	53 17       	stdsp	sp[0xc4],r7
   size_t allocsize; /*allocated size in bytes*/
 } uivector;
 
 static void uivector_cleanup(void* p)
 {
   ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
80003e00:	53 67       	stdsp	sp[0xd8],r7
80003e02:	53 57       	stdsp	sp[0xd4],r7
   free(((uivector*)p)->data);
80003e04:	e0 a0 60 74 	rcall	8000feec <free>
80003e08:	42 3c       	lddsp	r12,sp[0x8c]
   ((uivector*)p)->data = NULL;
80003e0a:	53 47       	stdsp	sp[0xd0],r7
   size_t allocsize; /*allocated size in bytes*/
 } uivector;
 
 static void uivector_cleanup(void* p)
 {
   ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
80003e0c:	52 57       	stdsp	sp[0x94],r7
80003e0e:	52 47       	stdsp	sp[0x90],r7
   free(((uivector*)p)->data);
80003e10:	e0 a0 60 6e 	rcall	8000feec <free>
80003e14:	42 6c       	lddsp	r12,sp[0x98]
   ((uivector*)p)->data = NULL;
80003e16:	52 37       	stdsp	sp[0x8c],r7
   size_t allocsize; /*allocated size in bytes*/
 } uivector;
 
 static void uivector_cleanup(void* p)
 {
   ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
80003e18:	52 87       	stdsp	sp[0xa0],r7
80003e1a:	52 77       	stdsp	sp[0x9c],r7
   free(((uivector*)p)->data);
80003e1c:	e0 a0 60 68 	rcall	8000feec <free>
80003e20:	42 9c       	lddsp	r12,sp[0xa4]
   size_t allocsize; /*allocated size in bytes*/
 } uivector;
 
 static void uivector_cleanup(void* p)
 {
   ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
80003e22:	52 a7       	stdsp	sp[0xa8],r7
   free(((uivector*)p)->data);
   ((uivector*)p)->data = NULL;
80003e24:	52 67       	stdsp	sp[0x98],r7
   size_t allocsize; /*allocated size in bytes*/
 } uivector;
 
 static void uivector_cleanup(void* p)
 {
   ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
80003e26:	52 b7       	stdsp	sp[0xac],r7
   free(((uivector*)p)->data);
80003e28:	e0 a0 60 62 	rcall	8000feec <free>
 
   HuffmanTree_cleanup(&codetree);
   HuffmanTree_cleanup(&codetreeD);
 
   return error;
 }
80003e2c:	06 9c       	mov	r12,r3
80003e2e:	2c 7d       	sub	sp,-228
80003e30:	d8 32       	popm	r0-r7,pc
 {
   unsigned treepos = 0, decoded, ct;
   for(;;)
   {
     unsigned char bit;
     if(((*bp) & 0x07) == 0 && ((*bp) >> 3) > inlength) { *error = 10; return 0; } /*error: end of input memory reached without endcode*/
80003e32:	f2 0b 16 03 	lsr	r11,r9,0x3
80003e36:	16 34       	cp.w	r4,r11
80003e38:	cb a2       	brcc	80003dac <inflateHuffmanBlock+0x60>
 
   (*result) = tree->tree2d.data[2 * (*treepos) + bit];
   (*decoded) = ((*result) < tree->numcodes);
 
   if(*decoded) (*treepos) = 0;
   else (*treepos) = (*result) - tree->numcodes;
80003e3a:	30 a3       	mov	r3,10
80003e3c:	cd 5b       	rjmp	80003de6 <inflateHuffmanBlock+0x9a>
   while(!endreached && !error)
   {
     unsigned code = huffmanDecodeSymbol(&error, in, bp, &codetree, inlength);
     if(error) break; /*some error happened in the above function*/
     if(code == 256) endreached = 1; /*end code*/
     else if(code <= 255) /*literal symbol*/
80003e3e:	e0 43 00 ff 	cp.w	r3,255
80003e42:	e0 8b 00 11 	brhi	80003e64 <inflateHuffmanBlock+0x118>
     {
       if((*pos) >= out->size) ucvector_resize(out, ((*pos) + 1) * 2); /*reserve more room at once*/
80003e46:	6a 09       	ld.w	r9,r5[0x0]
80003e48:	64 1a       	ld.w	r10,r2[0x4]
80003e4a:	14 39       	cp.w	r9,r10
80003e4c:	e0 82 00 b2 	brhs	80003fb0 <inflateHuffmanBlock+0x264>
       if((*pos) >= out->size) { error = 9913; break; } /*not enough memory*/
       out->data[(*pos)] = (unsigned char)(code);
80003e50:	64 0a       	ld.w	r10,r2[0x0]
80003e52:	f4 09 0b 03 	st.b	r10[r9],r3
       (*pos)++;
80003e56:	30 0e       	mov	lr,0
80003e58:	6a 09       	ld.w	r9,r5[0x0]
       start = (*pos);
       backward = start - distance;
       if((*pos) + length >= out->size) ucvector_resize(out, ((*pos) + length) * 2); /*reserve more room at once*/
       if((*pos) + length >= out->size) { error = 9914; break; } /*not enough memory*/
 
       for(forward = 0; forward < length; forward++)
80003e5a:	30 03       	mov	r3,0
     else if(code <= 255) /*literal symbol*/
     {
       if((*pos) >= out->size) ucvector_resize(out, ((*pos) + 1) * 2); /*reserve more room at once*/
       if((*pos) >= out->size) { error = 9913; break; } /*not enough memory*/
       out->data[(*pos)] = (unsigned char)(code);
       (*pos)++;
80003e5c:	2f f9       	sub	r9,-1
80003e5e:	8b 09       	st.w	r5[0x0],r9
80003e60:	42 ec       	lddsp	r12,sp[0xb8]
80003e62:	c9 cb       	rjmp	80003d9a <inflateHuffmanBlock+0x4e>
     }
     else if(code >= FIRST_LENGTH_CODE_INDEX && code <= LAST_LENGTH_CODE_INDEX) /*length code*/
80003e64:	e6 c3 01 01 	sub	r3,r3,257
80003e68:	59 c3       	cp.w	r3,28
80003e6a:	e0 8b 00 76 	brhi	80003f56 <inflateHuffmanBlock+0x20a>
       size_t length = LENGTHBASE[code - FIRST_LENGTH_CODE_INDEX];
       unsigned codeD, distance, numextrabitsD;
       size_t start, forward, backward, numextrabits;
 
       /*part 2: get extra bits and add the value of that to length*/
       numextrabits = LENGTHEXTRA[code - FIRST_LENGTH_CODE_INDEX];
80003e6e:	fe f0 0a 8a 	ld.w	r0,pc[2698]
80003e72:	e0 03 03 21 	ld.w	r1,r0[r3<<0x2]
       (*pos)++;
     }
     else if(code >= FIRST_LENGTH_CODE_INDEX && code <= LAST_LENGTH_CODE_INDEX) /*length code*/
     {
       /*part 1: get length base*/
       size_t length = LENGTHBASE[code - FIRST_LENGTH_CODE_INDEX];
80003e76:	f0 03 03 23 	ld.w	r3,r8[r3<<0x2]
80003e7a:	50 43       	stdsp	sp[0x10],r3
       unsigned codeD, distance, numextrabitsD;
       size_t start, forward, backward, numextrabits;
 
       /*part 2: get extra bits and add the value of that to length*/
       numextrabits = LENGTHEXTRA[code - FIRST_LENGTH_CODE_INDEX];
       if(((*bp) >> 3) >= inlength) { error = 51; break; } /*error, bit pointer will jump past memory*/
80003e7c:	f2 0e 16 03 	lsr	lr,r9,0x3
80003e80:	1c 34       	cp.w	r4,lr
80003e82:	e0 88 05 2b 	brls	800048d8 <inflateHuffmanBlock+0xb8c>
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
80003e86:	58 01       	cp.w	r1,0
80003e88:	e0 80 00 a4 	breq	80003fd0 <inflateHuffmanBlock+0x284>
80003e8c:	30 00       	mov	r0,0
80003e8e:	00 9b       	mov	r11,r0
80003e90:	c0 38       	rjmp	80003e96 <inflateHuffmanBlock+0x14a>
80003e92:	f2 0e 16 03 	lsr	lr,r9,0x3
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80003e96:	ec 0e 07 03 	ld.ub	r3,r6[lr]
80003e9a:	fd d9 c0 03 	bfextu	lr,r9,0x0,0x3
   (*bitpointer)++;
80003e9e:	2f f9       	sub	r9,-1
80003ea0:	8f 09       	st.w	r7[0x0],r9
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80003ea2:	e6 0e 08 4e 	asr	lr,r3,lr
80003ea6:	fd de c0 01 	bfextu	lr,lr,0x0,0x1
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
80003eaa:	fc 0b 09 4e 	lsl	lr,lr,r11
80003eae:	2f fb       	sub	r11,-1
80003eb0:	1c 00       	add	r0,lr
80003eb2:	16 31       	cp.w	r1,r11
80003eb4:	fe 9b ff ef 	brhi	80003e92 <inflateHuffmanBlock+0x146>
80003eb8:	e2 0a 00 09 	add	r9,r1,r10
80003ebc:	f2 0e 16 03 	lsr	lr,r9,0x3
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80003ec0:	f2 ca ff ff 	sub	r10,r9,-1
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
80003ec4:	30 0b       	mov	r11,0
 {
   unsigned treepos = 0, decoded, ct;
   for(;;)
   {
     unsigned char bit;
     if(((*bp) & 0x07) == 0 && ((*bp) >> 3) > inlength) { *error = 10; return 0; } /*error: end of input memory reached without endcode*/
80003ec6:	f3 d9 c0 03 	bfextu	r9,r9,0x0,0x3
80003eca:	c0 31       	brne	80003ed0 <inflateHuffmanBlock+0x184>
80003ecc:	1c 34       	cp.w	r4,lr
80003ece:	cb 63       	brcs	80003e3a <inflateHuffmanBlock+0xee>
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80003ed0:	ec 0e 07 0e 	ld.ub	lr,r6[lr]
   (*bitpointer)++;
80003ed4:	8f 0a       	st.w	r7[0x0],r10
 return value is error.*/
 static unsigned HuffmanTree_decode(const HuffmanTree* tree, unsigned* decoded, unsigned* result, unsigned* treepos, unsigned char bit)
 {
   if((*treepos) >= tree->numcodes) return 11; /*error: it appeared outside the codetree*/
 
   (*result) = tree->tree2d.data[2 * (*treepos) + bit];
80003ed6:	fc 09 08 49 	asr	r9,lr,r9
 bit is the bit that was just read from the stream
 you have to decode a full symbol (let the decode function return true) before you can try to decode another one, otherwise the state isn't reset
 return value is error.*/
 static unsigned HuffmanTree_decode(const HuffmanTree* tree, unsigned* decoded, unsigned* result, unsigned* treepos, unsigned char bit)
 {
   if((*treepos) >= tree->numcodes) return 11; /*error: it appeared outside the codetree*/
80003eda:	42 de       	lddsp	lr,sp[0xb4]
 
   (*result) = tree->tree2d.data[2 * (*treepos) + bit];
80003edc:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80003ee0:	f2 0b 00 13 	add	r3,r9,r11<<0x1
 bit is the bit that was just read from the stream
 you have to decode a full symbol (let the decode function return true) before you can try to decode another one, otherwise the state isn't reset
 return value is error.*/
 static unsigned HuffmanTree_decode(const HuffmanTree* tree, unsigned* decoded, unsigned* result, unsigned* treepos, unsigned char bit)
 {
   if((*treepos) >= tree->numcodes) return 11; /*error: it appeared outside the codetree*/
80003ee4:	16 3e       	cp.w	lr,r11
80003ee6:	fe 98 ff 7f 	brls	80003de4 <inflateHuffmanBlock+0x98>
 
   (*result) = tree->tree2d.data[2 * (*treepos) + bit];
80003eea:	42 3b       	lddsp	r11,sp[0x8c]
   (*decoded) = ((*result) < tree->numcodes);
 
   if(*decoded) (*treepos) = 0;
   else (*treepos) = (*result) - tree->numcodes;
80003eec:	14 99       	mov	r9,r10
 return value is error.*/
 static unsigned HuffmanTree_decode(const HuffmanTree* tree, unsigned* decoded, unsigned* result, unsigned* treepos, unsigned char bit)
 {
   if((*treepos) >= tree->numcodes) return 11; /*error: it appeared outside the codetree*/
 
   (*result) = tree->tree2d.data[2 * (*treepos) + bit];
80003eee:	f6 03 03 23 	ld.w	r3,r11[r3<<0x2]
   (*decoded) = ((*result) < tree->numcodes);
 
   if(*decoded) (*treepos) = 0;
   else (*treepos) = (*result) - tree->numcodes;
80003ef2:	e6 0e 01 0b 	sub	r11,r3,lr
   if((*treepos) >= tree->numcodes) return 11; /*error: it appeared outside the codetree*/
 
   (*result) = tree->tree2d.data[2 * (*treepos) + bit];
   (*decoded) = ((*result) < tree->numcodes);
 
   if(*decoded) (*treepos) = 0;
80003ef6:	06 3e       	cp.w	lr,r3
80003ef8:	e0 8b 00 32 	brhi	80003f5c <inflateHuffmanBlock+0x210>
80003efc:	f4 0e 16 03 	lsr	lr,r10,0x3
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80003f00:	f2 ca ff ff 	sub	r10,r9,-1
 {
   unsigned treepos = 0, decoded, ct;
   for(;;)
   {
     unsigned char bit;
     if(((*bp) & 0x07) == 0 && ((*bp) >> 3) > inlength) { *error = 10; return 0; } /*error: end of input memory reached without endcode*/
80003f04:	f3 d9 c0 03 	bfextu	r9,r9,0x0,0x3
80003f08:	ce 41       	brne	80003ed0 <inflateHuffmanBlock+0x184>
80003f0a:	ce 1b       	rjmp	80003ecc <inflateHuffmanBlock+0x180>
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
80003f0c:	1c 93       	mov	r3,lr
       size_t start, forward, backward, numextrabits;
 
       /*part 2: get extra bits and add the value of that to length*/
       numextrabits = LENGTHEXTRA[code - FIRST_LENGTH_CODE_INDEX];
       if(((*bp) >> 3) >= inlength) { error = 51; break; } /*error, bit pointer will jump past memory*/
       length += readBitsFromStream(bp, in, numextrabits);
80003f0e:	40 41       	lddsp	r1,sp[0x10]
       distance += readBitsFromStream(bp, in, numextrabitsD);
 
       /*part 5: fill in all the out[n] values based on the length and dist*/
       start = (*pos);
       backward = start - distance;
       if((*pos) + length >= out->size) ucvector_resize(out, ((*pos) + length) * 2); /*reserve more room at once*/
80003f10:	64 19       	ld.w	r9,r2[0x4]
       size_t start, forward, backward, numextrabits;
 
       /*part 2: get extra bits and add the value of that to length*/
       numextrabits = LENGTHEXTRA[code - FIRST_LENGTH_CODE_INDEX];
       if(((*bp) >> 3) >= inlength) { error = 51; break; } /*error, bit pointer will jump past memory*/
       length += readBitsFromStream(bp, in, numextrabits);
80003f12:	02 00       	add	r0,r1
       numextrabitsD = DISTANCEEXTRA[codeD];
       if(((*bp) >> 3) >= inlength) { error = 51; break; } /*error, bit pointer will jump past memory*/
       distance += readBitsFromStream(bp, in, numextrabitsD);
 
       /*part 5: fill in all the out[n] values based on the length and dist*/
       start = (*pos);
80003f14:	6a 01       	ld.w	r1,r5[0x0]
       backward = start - distance;
       if((*pos) + length >= out->size) ucvector_resize(out, ((*pos) + length) * 2); /*reserve more room at once*/
80003f16:	e0 01 00 0a 	add	r10,r0,r1
80003f1a:	12 3a       	cp.w	r10,r9
80003f1c:	e0 82 00 d6 	brhs	800040c8 <inflateHuffmanBlock+0x37c>
80003f20:	02 9a       	mov	r10,r1
       if((*pos) + length >= out->size) { error = 9914; break; } /*not enough memory*/
 
       for(forward = 0; forward < length; forward++)
80003f22:	58 00       	cp.w	r0,0
80003f24:	c1 80       	breq	80003f54 <inflateHuffmanBlock+0x208>
       if(((*bp) >> 3) >= inlength) { error = 51; break; } /*error, bit pointer will jump past memory*/
       distance += readBitsFromStream(bp, in, numextrabitsD);
 
       /*part 5: fill in all the out[n] values based on the length and dist*/
       start = (*pos);
       backward = start - distance;
80003f26:	40 5e       	lddsp	lr,sp[0x14]
80003f28:	e2 0e 01 09 	sub	r9,r1,lr
80003f2c:	30 0b       	mov	r11,0
80003f2e:	f2 03 01 03 	sub	r3,r9,r3
80003f32:	06 99       	mov	r9,r3
       if((*pos) + length >= out->size) ucvector_resize(out, ((*pos) + length) * 2); /*reserve more room at once*/
       if((*pos) + length >= out->size) { error = 9914; break; } /*not enough memory*/
 
       for(forward = 0; forward < length; forward++)
       {
         out->data[(*pos)] = out->data[backward];
80003f34:	64 0c       	ld.w	r12,r2[0x0]
80003f36:	f8 09 07 0e 	ld.ub	lr,r12[r9]
80003f3a:	f8 0a 0b 0e 	st.b	r12[r10],lr
         (*pos)++;
80003f3e:	6a 0a       	ld.w	r10,r5[0x0]
80003f40:	2f fa       	sub	r10,-1
80003f42:	8b 0a       	st.w	r5[0x0],r10
         backward++;
80003f44:	2f f9       	sub	r9,-1
       start = (*pos);
       backward = start - distance;
       if((*pos) + length >= out->size) ucvector_resize(out, ((*pos) + length) * 2); /*reserve more room at once*/
       if((*pos) + length >= out->size) { error = 9914; break; } /*not enough memory*/
 
       for(forward = 0; forward < length; forward++)
80003f46:	2f fb       	sub	r11,-1
       {
         out->data[(*pos)] = out->data[backward];
         (*pos)++;
         backward++;
80003f48:	12 31       	cp.w	r1,r9
80003f4a:	e6 09 17 80 	movls	r9,r3
       start = (*pos);
       backward = start - distance;
       if((*pos) + length >= out->size) ucvector_resize(out, ((*pos) + length) * 2); /*reserve more room at once*/
       if((*pos) + length >= out->size) { error = 9914; break; } /*not enough memory*/
 
       for(forward = 0; forward < length; forward++)
80003f4e:	16 30       	cp.w	r0,r11
80003f50:	fe 9b ff f2 	brhi	80003f34 <inflateHuffmanBlock+0x1e8>
80003f54:	42 ec       	lddsp	r12,sp[0xb8]
80003f56:	30 0e       	mov	lr,0
80003f58:	30 03       	mov	r3,0
80003f5a:	c2 0b       	rjmp	80003d9a <inflateHuffmanBlock+0x4e>
       length += readBitsFromStream(bp, in, numextrabits);
 
       /*part 3: get distance code*/
       codeD = huffmanDecodeSymbol(&error, in, bp, &codetreeD, inlength);
       if(error) break;
       if(codeD > 29) { error = 18; break; } /*error: invalid distance code (30-31 are never used)*/
80003f5c:	59 d3       	cp.w	r3,29
80003f5e:	e0 8b 04 98 	brhi	8000488e <inflateHuffmanBlock+0xb42>
       distance = DISTANCEBASE[codeD];
 
       /*part 4: get extra bits from distance*/
       numextrabitsD = DISTANCEEXTRA[codeD];
80003f62:	fe fb 09 9a 	ld.w	r11,pc[2458]
 
       /*part 3: get distance code*/
       codeD = huffmanDecodeSymbol(&error, in, bp, &codetreeD, inlength);
       if(error) break;
       if(codeD > 29) { error = 18; break; } /*error: invalid distance code (30-31 are never used)*/
       distance = DISTANCEBASE[codeD];
80003f66:	fe f9 09 9a 	ld.w	r9,pc[2458]
 
       /*part 4: get extra bits from distance*/
       numextrabitsD = DISTANCEEXTRA[codeD];
80003f6a:	f6 03 03 2e 	ld.w	lr,r11[r3<<0x2]
 
       /*part 3: get distance code*/
       codeD = huffmanDecodeSymbol(&error, in, bp, &codetreeD, inlength);
       if(error) break;
       if(codeD > 29) { error = 18; break; } /*error: invalid distance code (30-31 are never used)*/
       distance = DISTANCEBASE[codeD];
80003f6e:	f2 03 03 23 	ld.w	r3,r9[r3<<0x2]
80003f72:	50 53       	stdsp	sp[0x14],r3
 
       /*part 4: get extra bits from distance*/
       numextrabitsD = DISTANCEEXTRA[codeD];
       if(((*bp) >> 3) >= inlength) { error = 51; break; } /*error, bit pointer will jump past memory*/
80003f74:	f4 0b 16 03 	lsr	r11,r10,0x3
80003f78:	16 34       	cp.w	r4,r11
80003f7a:	e0 88 04 af 	brls	800048d8 <inflateHuffmanBlock+0xb8c>
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
80003f7e:	58 0e       	cp.w	lr,0
80003f80:	cc 60       	breq	80003f0c <inflateHuffmanBlock+0x1c0>
80003f82:	30 03       	mov	r3,0
80003f84:	06 99       	mov	r9,r3
80003f86:	c0 38       	rjmp	80003f8c <inflateHuffmanBlock+0x240>
80003f88:	f4 0b 16 03 	lsr	r11,r10,0x3
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80003f8c:	ec 0b 07 0c 	ld.ub	r12,r6[r11]
80003f90:	f7 da c0 03 	bfextu	r11,r10,0x0,0x3
   (*bitpointer)++;
80003f94:	2f fa       	sub	r10,-1
80003f96:	8f 0a       	st.w	r7[0x0],r10
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80003f98:	f8 0b 08 4b 	asr	r11,r12,r11
80003f9c:	f7 db c0 01 	bfextu	r11,r11,0x0,0x1
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
80003fa0:	f6 09 09 4b 	lsl	r11,r11,r9
80003fa4:	2f f9       	sub	r9,-1
80003fa6:	16 03       	add	r3,r11
80003fa8:	12 3e       	cp.w	lr,r9
80003faa:	fe 9b ff ef 	brhi	80003f88 <inflateHuffmanBlock+0x23c>
80003fae:	cb 0b       	rjmp	80003f0e <inflateHuffmanBlock+0x1c2>
     unsigned code = huffmanDecodeSymbol(&error, in, bp, &codetree, inlength);
     if(error) break; /*some error happened in the above function*/
     if(code == 256) endreached = 1; /*end code*/
     else if(code <= 255) /*literal symbol*/
     {
       if((*pos) >= out->size) ucvector_resize(out, ((*pos) + 1) * 2); /*reserve more room at once*/
80003fb0:	2f f9       	sub	r9,-1
   ((ucvector*)p)->data = NULL;
 }
 
 static unsigned ucvector_resize(ucvector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned char) > p->allocsize)
80003fb2:	64 2a       	ld.w	r10,r2[0x8]
     unsigned code = huffmanDecodeSymbol(&error, in, bp, &codetree, inlength);
     if(error) break; /*some error happened in the above function*/
     if(code == 256) endreached = 1; /*end code*/
     else if(code <= 255) /*literal symbol*/
     {
       if((*pos) >= out->size) ucvector_resize(out, ((*pos) + 1) * 2); /*reserve more room at once*/
80003fb4:	f2 01 15 01 	lsl	r1,r9,0x1
   ((ucvector*)p)->data = NULL;
 }
 
 static unsigned ucvector_resize(ucvector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned char) > p->allocsize)
80003fb8:	14 31       	cp.w	r1,r10
80003fba:	e0 8b 01 fc 	brhi	800043b2 <inflateHuffmanBlock+0x666>
       p->data = (unsigned char*)data;
       p->size = size;
     }
     else return 0; /*error: not enough memory*/
   }
   else p->size = size;
80003fbe:	85 11       	st.w	r2[0x4],r1
80003fc0:	6a 09       	ld.w	r9,r5[0x0]
     if(error) break; /*some error happened in the above function*/
     if(code == 256) endreached = 1; /*end code*/
     else if(code <= 255) /*literal symbol*/
     {
       if((*pos) >= out->size) ucvector_resize(out, ((*pos) + 1) * 2); /*reserve more room at once*/
       if((*pos) >= out->size) { error = 9913; break; } /*not enough memory*/
80003fc2:	12 31       	cp.w	r1,r9
80003fc4:	fe 9b ff 46 	brhi	80003e50 <inflateHuffmanBlock+0x104>
80003fc8:	e0 63 26 b9 	mov	r3,9913
80003fcc:	42 ec       	lddsp	r12,sp[0xb8]
80003fce:	c0 cb       	rjmp	80003de6 <inflateHuffmanBlock+0x9a>
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
80003fd0:	02 90       	mov	r0,r1
80003fd2:	c7 7b       	rjmp	80003ec0 <inflateHuffmanBlock+0x174>
 static unsigned uivector_resize(uivector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned) > p->allocsize)
   {
     size_t newsize = size * sizeof(unsigned) * 2;
     void* data = realloc(p->data, newsize);
80003fd4:	06 9c       	mov	r12,r3
80003fd6:	e0 6b 09 00 	mov	r11,2304
80003fda:	e0 a0 62 5f 	rcall	80010498 <realloc>
80003fde:	18 93       	mov	r3,r12
     if(data)
80003fe0:	c4 20       	breq	80004064 <inflateHuffmanBlock+0x318>
 
   return error;
 }
 
 /*inflate a block with dynamic of fixed Huffman tree*/
 static unsigned inflateHuffmanBlock(ucvector* out, const unsigned char* in, size_t* bp, size_t* pos, size_t inlength, unsigned btype)
80003fe2:	f8 ca fd c0 	sub	r10,r12,-576
80003fe6:	18 98       	mov	r8,r12
   if(!uivector_resize(&bitlen, NUM_DEFLATE_CODE_SYMBOLS)) error = 9909;
 
   if(!error)
   {
     /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/
     for(i =   0; i <= 143; i++) bitlen.data[i] = 8;
80003fe8:	30 89       	mov	r9,8
80003fea:	10 a9       	st.w	r8++,r9
80003fec:	14 38       	cp.w	r8,r10
80003fee:	cf e1       	brne	80003fea <inflateHuffmanBlock+0x29e>
 
   return error;
 }
 
 /*inflate a block with dynamic of fixed Huffman tree*/
 static unsigned inflateHuffmanBlock(ucvector* out, const unsigned char* in, size_t* bp, size_t* pos, size_t inlength, unsigned btype)
80003ff0:	e6 ca fc 00 	sub	r10,r3,-1024
 
   if(!error)
   {
     /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/
     for(i =   0; i <= 143; i++) bitlen.data[i] = 8;
     for(i = 144; i <= 255; i++) bitlen.data[i] = 9;
80003ff4:	30 99       	mov	r9,9
80003ff6:	10 a9       	st.w	r8++,r9
80003ff8:	14 38       	cp.w	r8,r10
80003ffa:	cf e1       	brne	80003ff6 <inflateHuffmanBlock+0x2aa>
 
   return error;
 }
 
 /*inflate a block with dynamic of fixed Huffman tree*/
 static unsigned inflateHuffmanBlock(ucvector* out, const unsigned char* in, size_t* bp, size_t* pos, size_t inlength, unsigned btype)
80003ffc:	e6 ca fb a0 	sub	r10,r3,-1120
   if(!error)
   {
     /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/
     for(i =   0; i <= 143; i++) bitlen.data[i] = 8;
     for(i = 144; i <= 255; i++) bitlen.data[i] = 9;
     for(i = 256; i <= 279; i++) bitlen.data[i] = 7;
80004000:	30 79       	mov	r9,7
80004002:	10 a9       	st.w	r8++,r9
80004004:	14 38       	cp.w	r8,r10
80004006:	cf e1       	brne	80004002 <inflateHuffmanBlock+0x2b6>
     for(i = 280; i <= 287; i++) bitlen.data[i] = 8;
80004008:	30 88       	mov	r8,8
8000400a:	e7 48 04 7c 	st.w	r3[1148],r8
8000400e:	e7 48 04 60 	st.w	r3[1120],r8
80004012:	e7 48 04 64 	st.w	r3[1124],r8
80004016:	e7 48 04 68 	st.w	r3[1128],r8
8000401a:	e7 48 04 6c 	st.w	r3[1132],r8
8000401e:	e7 48 04 70 	st.w	r3[1136],r8
80004022:	e7 48 04 74 	st.w	r3[1140],r8
80004026:	e7 48 04 78 	st.w	r3[1144],r8
   ((uivector*)p)->data = NULL;
 }
 
 static unsigned uivector_resize(uivector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned) > p->allocsize)
8000402a:	43 68       	lddsp	r8,sp[0xd8]
8000402c:	e0 48 04 7f 	cp.w	r8,1151
80004030:	e0 88 03 ff 	brls	8000482e <inflateHuffmanBlock+0xae2>
       p->data = (unsigned*)data;
       p->size = size;
     }
     else return 0;
   }
   else p->size = size;
80004034:	e0 68 01 20 	mov	r8,288
80004038:	43 49       	lddsp	r9,sp[0xd0]
8000403a:	53 58       	stdsp	sp[0xd4],r8
 } uivector;
 
 static void uivector_cleanup(void* p)
 {
   ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
   free(((uivector*)p)->data);
8000403c:	30 08       	mov	r8,0
8000403e:	c0 28       	rjmp	80004042 <inflateHuffmanBlock+0x2f6>
       p->data = (unsigned*)data;
       p->size = size;
     }
     else return 0;
   }
   else p->size = size;
80004040:	43 49       	lddsp	r9,sp[0xd0]
 /*given the code lengths (as stored in the PNG file), generate the tree as defined by Deflate. maxbitlen is the maximum bits that a code in the tree can have. return value is error.*/
 static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen, size_t numcodes, unsigned maxbitlen)
 {
   unsigned i;
   if(!uivector_resize(&tree->lengths, numcodes)) return 9903;
   for(i = 0; i < numcodes; i++) tree->lengths.data[i] = bitlen[i];
80004042:	e6 08 03 0a 	ld.w	r10,r3[r8]
80004046:	f2 08 09 0a 	st.w	r9[r8],r10
8000404a:	2f c8       	sub	r8,-4
8000404c:	e0 48 04 80 	cp.w	r8,1152
80004050:	cf 81       	brne	80004040 <inflateHuffmanBlock+0x2f4>
   tree->numcodes = (unsigned)numcodes; /*number of symbols*/
80004052:	e0 68 01 20 	mov	r8,288
80004056:	53 88       	stdsp	sp[0xe0],r8
   tree->maxbitlen = maxbitlen;
80004058:	30 f8       	mov	r8,15
   return HuffmanTree_makeFromLengths2(tree);
8000405a:	fa cc ff 48 	sub	r12,sp,-184
 {
   unsigned i;
   if(!uivector_resize(&tree->lengths, numcodes)) return 9903;
   for(i = 0; i < numcodes; i++) tree->lengths.data[i] = bitlen[i];
   tree->numcodes = (unsigned)numcodes; /*number of symbols*/
   tree->maxbitlen = maxbitlen;
8000405e:	53 78       	stdsp	sp[0xdc],r8
   return HuffmanTree_makeFromLengths2(tree);
80004060:	fe b0 fc 4c 	rcall	800038f8 <HuffmanTree_makeFromLengths2>
 } uivector;
 
 static void uivector_cleanup(void* p)
 {
   ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
   free(((uivector*)p)->data);
80004064:	06 9c       	mov	r12,r3
80004066:	e0 a0 5f 43 	rcall	8000feec <free>
 static unsigned uivector_resize(uivector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned) > p->allocsize)
   {
     size_t newsize = size * sizeof(unsigned) * 2;
     void* data = realloc(p->data, newsize);
8000406a:	e0 6b 01 00 	mov	r11,256
8000406e:	30 0c       	mov	r12,0
80004070:	e0 a0 62 14 	rcall	80010498 <realloc>
80004074:	18 93       	mov	r3,r12
     if(data)
80004076:	c2 30       	breq	800040bc <inflateHuffmanBlock+0x370>
     {
       p->allocsize = newsize;
       p->data = (unsigned*)data;
80004078:	18 98       	mov	r8,r12
 
   return error;
 }
 
 /*inflate a block with dynamic of fixed Huffman tree*/
 static unsigned inflateHuffmanBlock(ucvector* out, const unsigned char* in, size_t* bp, size_t* pos, size_t inlength, unsigned btype)
8000407a:	f8 ca ff 80 	sub	r10,r12,-128
   if(!uivector_resize(&bitlen, NUM_DISTANCE_SYMBOLS)) error = 9910;
 
   /*there are 32 distance codes, but 30-31 are unused*/
   if(!error)
   {
     for(i = 0; i < NUM_DISTANCE_SYMBOLS; i++) bitlen.data[i] = 5;
8000407e:	30 59       	mov	r9,5
80004080:	10 a9       	st.w	r8++,r9
80004082:	14 38       	cp.w	r8,r10
80004084:	cf e1       	brne	80004080 <inflateHuffmanBlock+0x334>
   ((uivector*)p)->data = NULL;
 }
 
 static unsigned uivector_resize(uivector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned) > p->allocsize)
80004086:	42 b8       	lddsp	r8,sp[0xac]
80004088:	e0 48 00 7f 	cp.w	r8,127
8000408c:	e0 88 03 be 	brls	80004808 <inflateHuffmanBlock+0xabc>
       p->data = (unsigned*)data;
       p->size = size;
     }
     else return 0;
   }
   else p->size = size;
80004090:	32 08       	mov	r8,32
80004092:	42 99       	lddsp	r9,sp[0xa4]
80004094:	52 a8       	stdsp	sp[0xa8],r8
 } uivector;
 
 static void uivector_cleanup(void* p)
 {
   ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
   free(((uivector*)p)->data);
80004096:	30 08       	mov	r8,0
80004098:	c0 28       	rjmp	8000409c <inflateHuffmanBlock+0x350>
       p->data = (unsigned*)data;
       p->size = size;
     }
     else return 0;
   }
   else p->size = size;
8000409a:	42 99       	lddsp	r9,sp[0xa4]
 /*given the code lengths (as stored in the PNG file), generate the tree as defined by Deflate. maxbitlen is the maximum bits that a code in the tree can have. return value is error.*/
 static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen, size_t numcodes, unsigned maxbitlen)
 {
   unsigned i;
   if(!uivector_resize(&tree->lengths, numcodes)) return 9903;
   for(i = 0; i < numcodes; i++) tree->lengths.data[i] = bitlen[i];
8000409c:	e6 08 03 0a 	ld.w	r10,r3[r8]
800040a0:	f2 08 09 0a 	st.w	r9[r8],r10
800040a4:	2f c8       	sub	r8,-4
800040a6:	e0 48 00 80 	cp.w	r8,128
800040aa:	cf 81       	brne	8000409a <inflateHuffmanBlock+0x34e>
   tree->numcodes = (unsigned)numcodes; /*number of symbols*/
800040ac:	32 08       	mov	r8,32
800040ae:	52 d8       	stdsp	sp[0xb4],r8
   tree->maxbitlen = maxbitlen;
800040b0:	30 f8       	mov	r8,15
   return HuffmanTree_makeFromLengths2(tree);
800040b2:	fa cc ff 74 	sub	r12,sp,-140
 {
   unsigned i;
   if(!uivector_resize(&tree->lengths, numcodes)) return 9903;
   for(i = 0; i < numcodes; i++) tree->lengths.data[i] = bitlen[i];
   tree->numcodes = (unsigned)numcodes; /*number of symbols*/
   tree->maxbitlen = maxbitlen;
800040b6:	52 c8       	stdsp	sp[0xb0],r8
   return HuffmanTree_makeFromLengths2(tree);
800040b8:	fe b0 fc 20 	rcall	800038f8 <HuffmanTree_makeFromLengths2>
 } uivector;
 
 static void uivector_cleanup(void* p)
 {
   ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
   free(((uivector*)p)->data);
800040bc:	06 9c       	mov	r12,r3
800040be:	30 03       	mov	r3,0
800040c0:	e0 a0 5f 16 	rcall	8000feec <free>
800040c4:	fe 9f fe 66 	bral	80003d90 <inflateHuffmanBlock+0x44>
       distance += readBitsFromStream(bp, in, numextrabitsD);
 
       /*part 5: fill in all the out[n] values based on the length and dist*/
       start = (*pos);
       backward = start - distance;
       if((*pos) + length >= out->size) ucvector_resize(out, ((*pos) + length) * 2); /*reserve more room at once*/
800040c8:	f4 09 15 01 	lsl	r9,r10,0x1
   ((ucvector*)p)->data = NULL;
 }
 
 static unsigned ucvector_resize(ucvector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned char) > p->allocsize)
800040cc:	64 2b       	ld.w	r11,r2[0x8]
800040ce:	16 39       	cp.w	r9,r11
800040d0:	e0 8b 01 9d 	brhi	8000440a <inflateHuffmanBlock+0x6be>
       p->data = (unsigned char*)data;
       p->size = size;
     }
     else return 0; /*error: not enough memory*/
   }
   else p->size = size;
800040d4:	85 19       	st.w	r2[0x4],r9
 
       /*part 5: fill in all the out[n] values based on the length and dist*/
       start = (*pos);
       backward = start - distance;
       if((*pos) + length >= out->size) ucvector_resize(out, ((*pos) + length) * 2); /*reserve more room at once*/
       if((*pos) + length >= out->size) { error = 9914; break; } /*not enough memory*/
800040d6:	6a 0a       	ld.w	r10,r5[0x0]
800040d8:	e0 0a 00 0b 	add	r11,r0,r10
800040dc:	12 3b       	cp.w	r11,r9
800040de:	fe 93 ff 22 	brlo	80003f22 <inflateHuffmanBlock+0x1d6>
800040e2:	e0 63 26 ba 	mov	r3,9914
800040e6:	42 ec       	lddsp	r12,sp[0xb8]
800040e8:	fe 9f fe 7f 	bral	80003de6 <inflateHuffmanBlock+0x9a>
   return 1;
 }
 
 static void uivector_init(uivector* p)
 {
   p->data = NULL;
800040ec:	51 83       	stdsp	sp[0x60],r3
   p->size = p->allocsize = 0;
800040ee:	51 a3       	stdsp	sp[0x68],r3
800040f0:	51 93       	stdsp	sp[0x64],r3
   return 1;
 }
 
 static void uivector_init(uivector* p)
 {
   p->data = NULL;
800040f2:	51 b3       	stdsp	sp[0x6c],r3
   p->size = p->allocsize = 0;
800040f4:	51 d3       	stdsp	sp[0x74],r3
800040f6:	51 c3       	stdsp	sp[0x70],r3
   return 1;
 }
 
 static void uivector_init(uivector* p)
 {
   p->data = NULL;
800040f8:	51 e3       	stdsp	sp[0x78],r3
   p->size = p->allocsize = 0;
800040fa:	52 03       	stdsp	sp[0x80],r3
800040fc:	51 f3       	stdsp	sp[0x7c],r3
   unsigned n, HLIT, HDIST, HCLEN, i;
   uivector bitlen;
   uivector bitlenD;
   uivector codelengthcode;
 
   if((*bp) >> 3 >= inlength - 2) { return 49; } /*the bit pointer is or will go past the memory*/
800040fe:	74 08       	ld.w	r8,r10[0x0]
80004100:	e8 ca 00 02 	sub	r10,r4,2
80004104:	f0 09 16 03 	lsr	r9,r8,0x3
80004108:	14 39       	cp.w	r9,r10
8000410a:	e0 82 01 6a 	brhs	800043de <inflateHuffmanBlock+0x692>
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
8000410e:	f6 09 07 09 	ld.ub	r9,r11[r9]
80004112:	50 b9       	stdsp	sp[0x2c],r9
   (*bitpointer)++;
80004114:	f0 cc ff ff 	sub	r12,r8,-1
80004118:	8f 0c       	st.w	r7[0x0],r12
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
8000411a:	f8 09 16 03 	lsr	r9,r12,0x3
8000411e:	ec 09 07 09 	ld.ub	r9,r6[r9]
80004122:	50 c9       	stdsp	sp[0x30],r9
   (*bitpointer)++;
80004124:	f8 cb ff ff 	sub	r11,r12,-1
80004128:	8f 0b       	st.w	r7[0x0],r11
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
8000412a:	f6 09 16 03 	lsr	r9,r11,0x3
8000412e:	ec 09 07 09 	ld.ub	r9,r6[r9]
80004132:	50 d9       	stdsp	sp[0x34],r9
   (*bitpointer)++;
80004134:	f6 ca ff ff 	sub	r10,r11,-1
80004138:	8f 0a       	st.w	r7[0x0],r10
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
8000413a:	f4 0e 16 03 	lsr	lr,r10,0x3
8000413e:	ec 0e 07 0e 	ld.ub	lr,r6[lr]
80004142:	50 ee       	stdsp	sp[0x38],lr
   (*bitpointer)++;
80004144:	f4 c9 ff ff 	sub	r9,r10,-1
80004148:	8f 09       	st.w	r7[0x0],r9
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
8000414a:	f2 01 16 03 	lsr	r1,r9,0x3
8000414e:	ec 01 07 01 	ld.ub	r1,r6[r1]
80004152:	50 f1       	stdsp	sp[0x3c],r1
   (*bitpointer)++;
80004154:	f2 ce ff ff 	sub	lr,r9,-1
80004158:	8f 0e       	st.w	r7[0x0],lr
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
8000415a:	f0 ce ff fb 	sub	lr,r8,-5
8000415e:	50 ae       	stdsp	sp[0x28],lr
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80004160:	a3 9e       	lsr	lr,0x3
80004162:	ec 0e 07 0e 	ld.ub	lr,r6[lr]
80004166:	51 0e       	stdsp	sp[0x40],lr
   (*bitpointer)++;
80004168:	f0 c1 ff fa 	sub	r1,r8,-6
8000416c:	f0 c0 ff f9 	sub	r0,r8,-7
80004170:	8f 01       	st.w	r7[0x0],r1
80004172:	50 00       	stdsp	sp[0x0],r0
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80004174:	e2 00 16 03 	lsr	r0,r1,0x3
80004178:	ec 00 07 00 	ld.ub	r0,r6[r0]
8000417c:	51 10       	stdsp	sp[0x44],r0
   (*bitpointer)++;
8000417e:	40 0e       	lddsp	lr,sp[0x0]
80004180:	f0 c0 ff f8 	sub	r0,r8,-8
80004184:	8f 0e       	st.w	r7[0x0],lr
80004186:	50 70       	stdsp	sp[0x1c],r0
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80004188:	1c 90       	mov	r0,lr
8000418a:	a3 90       	lsr	r0,0x3
8000418c:	ec 00 07 00 	ld.ub	r0,r6[r0]
80004190:	51 20       	stdsp	sp[0x48],r0
   (*bitpointer)++;
80004192:	40 7e       	lddsp	lr,sp[0x1c]
80004194:	f0 c0 ff f7 	sub	r0,r8,-9
80004198:	8f 0e       	st.w	r7[0x0],lr
8000419a:	50 60       	stdsp	sp[0x18],r0
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
8000419c:	1c 90       	mov	r0,lr
8000419e:	a3 90       	lsr	r0,0x3
800041a0:	ec 00 07 00 	ld.ub	r0,r6[r0]
800041a4:	51 30       	stdsp	sp[0x4c],r0
   (*bitpointer)++;
800041a6:	f0 c0 ff f6 	sub	r0,r8,-10
800041aa:	40 6e       	lddsp	lr,sp[0x18]
800041ac:	8f 0e       	st.w	r7[0x0],lr
800041ae:	50 90       	stdsp	sp[0x24],r0
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
800041b0:	1c 90       	mov	r0,lr
800041b2:	a3 90       	lsr	r0,0x3
800041b4:	ec 00 07 00 	ld.ub	r0,r6[r0]
800041b8:	51 40       	stdsp	sp[0x50],r0
   (*bitpointer)++;
800041ba:	40 9e       	lddsp	lr,sp[0x24]
800041bc:	f0 c0 ff f5 	sub	r0,r8,-11
800041c0:	8f 0e       	st.w	r7[0x0],lr
800041c2:	50 80       	stdsp	sp[0x20],r0
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
800041c4:	1c 90       	mov	r0,lr
800041c6:	a3 90       	lsr	r0,0x3
800041c8:	ec 00 07 00 	ld.ub	r0,r6[r0]
800041cc:	51 50       	stdsp	sp[0x54],r0
   (*bitpointer)++;
800041ce:	40 8e       	lddsp	lr,sp[0x20]
800041d0:	f0 c0 ff f4 	sub	r0,r8,-12
800041d4:	8f 0e       	st.w	r7[0x0],lr
800041d6:	50 50       	stdsp	sp[0x14],r0
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
800041d8:	1c 90       	mov	r0,lr
800041da:	a3 90       	lsr	r0,0x3
800041dc:	ec 00 07 00 	ld.ub	r0,r6[r0]
800041e0:	51 60       	stdsp	sp[0x58],r0
   (*bitpointer)++;
800041e2:	40 5e       	lddsp	lr,sp[0x14]
800041e4:	f0 c0 ff f3 	sub	r0,r8,-13
800041e8:	8f 0e       	st.w	r7[0x0],lr
800041ea:	50 40       	stdsp	sp[0x10],r0
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
800041ec:	1c 90       	mov	r0,lr
800041ee:	a3 90       	lsr	r0,0x3
800041f0:	ec 00 07 00 	ld.ub	r0,r6[r0]
800041f4:	51 70       	stdsp	sp[0x5c],r0
   (*bitpointer)++;
800041f6:	40 4e       	lddsp	lr,sp[0x10]
800041f8:	8f 0e       	st.w	r7[0x0],lr
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
800041fa:	40 a0       	lddsp	r0,sp[0x28]
800041fc:	e1 d0 c0 03 	bfextu	r0,r0,0x0,0x3
80004200:	41 0e       	lddsp	lr,sp[0x40]
80004202:	fc 00 08 4e 	asr	lr,lr,r0
80004206:	41 10       	lddsp	r0,sp[0x44]
80004208:	e3 d1 c0 03 	bfextu	r1,r1,0x0,0x3
8000420c:	e0 01 08 41 	asr	r1,r0,r1
80004210:	e1 de c0 01 	bfextu	r0,lr,0x0,0x1
80004214:	e3 d1 c0 01 	bfextu	r1,r1,0x0,0x1
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
80004218:	e0 01 00 10 	add	r0,r0,r1<<0x1
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
8000421c:	40 01       	lddsp	r1,sp[0x0]
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
8000421e:	50 a0       	stdsp	sp[0x28],r0
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80004220:	41 20       	lddsp	r0,sp[0x48]
80004222:	fd d1 c0 03 	bfextu	lr,r1,0x0,0x3
80004226:	e0 0e 08 41 	asr	r1,r0,lr
8000422a:	40 70       	lddsp	r0,sp[0x1c]
8000422c:	fd d0 c0 03 	bfextu	lr,r0,0x0,0x3
80004230:	41 30       	lddsp	r0,sp[0x4c]
80004232:	e0 0e 08 4e 	asr	lr,r0,lr
80004236:	50 7e       	stdsp	sp[0x1c],lr
80004238:	fd d1 c0 01 	bfextu	lr,r1,0x0,0x1
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
8000423c:	40 a1       	lddsp	r1,sp[0x28]
8000423e:	e2 0e 00 20 	add	r0,r1,lr<<0x2
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80004242:	40 71       	lddsp	r1,sp[0x1c]
80004244:	fd d1 c0 01 	bfextu	lr,r1,0x0,0x1
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
80004248:	e0 0e 00 30 	add	r0,r0,lr<<0x3
8000424c:	50 70       	stdsp	sp[0x1c],r0
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
8000424e:	40 60       	lddsp	r0,sp[0x18]
80004250:	fd d0 c0 03 	bfextu	lr,r0,0x0,0x3
80004254:	41 40       	lddsp	r0,sp[0x50]
80004256:	e0 0e 08 41 	asr	r1,r0,lr
8000425a:	40 90       	lddsp	r0,sp[0x24]
8000425c:	e3 d1 c0 01 	bfextu	r1,r1,0x0,0x1
80004260:	fd d0 c0 03 	bfextu	lr,r0,0x0,0x3
80004264:	41 50       	lddsp	r0,sp[0x54]
80004266:	e0 0e 08 4e 	asr	lr,r0,lr
8000426a:	fd de c0 01 	bfextu	lr,lr,0x0,0x1
8000426e:	50 6e       	stdsp	sp[0x18],lr
80004270:	40 80       	lddsp	r0,sp[0x20]
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
80004272:	e2 0e 15 04 	lsl	lr,r1,0x4
80004276:	40 71       	lddsp	r1,sp[0x1c]
80004278:	02 0e       	add	lr,r1
8000427a:	50 7e       	stdsp	sp[0x1c],lr
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
8000427c:	fd d0 c0 03 	bfextu	lr,r0,0x0,0x3
80004280:	41 60       	lddsp	r0,sp[0x58]
80004282:	e0 0e 08 41 	asr	r1,r0,lr
80004286:	40 50       	lddsp	r0,sp[0x14]
80004288:	fd d0 c0 03 	bfextu	lr,r0,0x0,0x3
8000428c:	41 70       	lddsp	r0,sp[0x5c]
8000428e:	e0 0e 08 4e 	asr	lr,r0,lr
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
80004292:	40 60       	lddsp	r0,sp[0x18]
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80004294:	fd de c0 01 	bfextu	lr,lr,0x0,0x1
80004298:	e3 d1 c0 01 	bfextu	r1,r1,0x0,0x1
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
8000429c:	e0 01 00 11 	add	r1,r0,r1<<0x1
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
800042a0:	40 b0       	lddsp	r0,sp[0x2c]
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
800042a2:	e2 0e 00 21 	add	r1,r1,lr<<0x2
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
800042a6:	40 4e       	lddsp	lr,sp[0x10]
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
800042a8:	50 51       	stdsp	sp[0x14],r1
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
800042aa:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
800042ae:	e3 de c0 03 	bfextu	r1,lr,0x0,0x3
   (*bitpointer)++;
800042b2:	f0 ce ff f2 	sub	lr,r8,-14
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
800042b6:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800042ba:	e0 08 08 48 	asr	r8,r0,r8
800042be:	40 c0       	lddsp	r0,sp[0x30]
800042c0:	e0 0c 08 4c 	asr	r12,r0,r12
800042c4:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
800042c8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800042cc:	f7 db c0 03 	bfextu	r11,r11,0x0,0x3
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
800042d0:	f0 0c 00 18 	add	r8,r8,r12<<0x1
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
800042d4:	40 dc       	lddsp	r12,sp[0x34]
800042d6:	f8 0b 08 4b 	asr	r11,r12,r11
800042da:	f7 db c0 01 	bfextu	r11,r11,0x0,0x1
800042de:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
800042e2:	f0 0b 00 28 	add	r8,r8,r11<<0x2
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
800042e6:	40 eb       	lddsp	r11,sp[0x38]
800042e8:	f6 0a 08 4a 	asr	r10,r11,r10
800042ec:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
800042f0:	f3 d9 c0 03 	bfextu	r9,r9,0x0,0x3
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
800042f4:	f0 0a 00 38 	add	r8,r8,r10<<0x3
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
800042f8:	40 fa       	lddsp	r10,sp[0x3c]
800042fa:	f4 09 08 49 	asr	r9,r10,r9
800042fe:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
80004302:	a5 69       	lsl	r9,0x4
80004304:	10 09       	add	r9,r8
80004306:	50 99       	stdsp	sp[0x24],r9
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80004308:	40 48       	lddsp	r8,sp[0x10]
8000430a:	a3 98       	lsr	r8,0x3
8000430c:	ec 08 07 08 	ld.ub	r8,r6[r8]
   (*bitpointer)++;
80004310:	8f 0e       	st.w	r7[0x0],lr
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80004312:	f0 01 08 48 	asr	r8,r8,r1
 
   if((*bp) >> 3 >= inlength - 2) { return 49; } /*the bit pointer is or will go past the memory*/
 
   HLIT =  readBitsFromStream(bp, in, 5) + 257; /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
   HDIST = readBitsFromStream(bp, in, 5) + 1; /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/
   HCLEN = readBitsFromStream(bp, in, 4) + 4; /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/
80004316:	40 59       	lddsp	r9,sp[0x14]
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80004318:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
 static unsigned uivector_resize(uivector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned) > p->allocsize)
   {
     size_t newsize = size * sizeof(unsigned) * 2;
     void* data = realloc(p->data, newsize);
8000431c:	e0 6b 00 98 	mov	r11,152
 
   if((*bp) >> 3 >= inlength - 2) { return 49; } /*the bit pointer is or will go past the memory*/
 
   HLIT =  readBitsFromStream(bp, in, 5) + 257; /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
   HDIST = readBitsFromStream(bp, in, 5) + 1; /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/
   HCLEN = readBitsFromStream(bp, in, 4) + 4; /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/
80004320:	f2 08 00 30 	add	r0,r9,r8<<0x3
 static unsigned uivector_resize(uivector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned) > p->allocsize)
   {
     size_t newsize = size * sizeof(unsigned) * 2;
     void* data = realloc(p->data, newsize);
80004324:	06 9c       	mov	r12,r3
 
   if((*bp) >> 3 >= inlength - 2) { return 49; } /*the bit pointer is or will go past the memory*/
 
   HLIT =  readBitsFromStream(bp, in, 5) + 257; /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
   HDIST = readBitsFromStream(bp, in, 5) + 1; /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/
   HCLEN = readBitsFromStream(bp, in, 4) + 4; /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/
80004326:	2f c0       	sub	r0,-4
 static unsigned uivector_resize(uivector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned) > p->allocsize)
   {
     size_t newsize = size * sizeof(unsigned) * 2;
     void* data = realloc(p->data, newsize);
80004328:	e0 a0 60 b8 	rcall	80010498 <realloc>
8000432c:	18 91       	mov	r1,r12
     if(data)
8000432e:	e0 80 02 91 	breq	80004850 <inflateHuffmanBlock+0xb04>
     {
       p->allocsize = newsize;
       p->data = (unsigned*)data;
80004332:	fe f8 05 d2 	ld.w	r8,pc[1490]
80004336:	50 42       	stdsp	sp[0x10],r2
80004338:	50 55       	stdsp	sp[0x14],r5
8000433a:	c3 48       	rjmp	800043a2 <inflateHuffmanBlock+0x656>
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
8000433c:	6e 0b       	ld.w	r11,r7[0x0]
   (*bitpointer)++;
8000433e:	f6 ca ff ff 	sub	r10,r11,-1
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80004342:	f6 09 16 03 	lsr	r9,r11,0x3
80004346:	ec 09 07 02 	ld.ub	r2,r6[r9]
   (*bitpointer)++;
8000434a:	8f 0a       	st.w	r7[0x0],r10
8000434c:	f4 c9 ff ff 	sub	r9,r10,-1
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80004350:	f4 0c 16 03 	lsr	r12,r10,0x3
80004354:	ec 0c 07 05 	ld.ub	r5,r6[r12]
   (*bitpointer)++;
80004358:	8f 09       	st.w	r7[0x0],r9
8000435a:	f2 cc ff ff 	sub	r12,r9,-1
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
8000435e:	f2 0e 16 03 	lsr	lr,r9,0x3
80004362:	ec 0e 07 0e 	ld.ub	lr,r6[lr]
   (*bitpointer)++;
80004366:	8f 0c       	st.w	r7[0x0],r12
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80004368:	f7 db c0 03 	bfextu	r11,r11,0x0,0x3
 
   if(!error)
   {
     for(i = 0; i < NUM_CODE_LENGTH_CODES; i++)
     {
       if(i < HCLEN) codelengthcode.data[CLCL[i]] = readBitsFromStream(bp, in, 3);
8000436c:	70 0c       	ld.w	r12,r8[0x0]
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
8000436e:	e4 0b 08 4b 	asr	r11,r2,r11
80004372:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80004376:	f7 db c0 01 	bfextu	r11,r11,0x0,0x1
8000437a:	ea 0a 08 4a 	asr	r10,r5,r10
8000437e:	f3 d9 c0 03 	bfextu	r9,r9,0x0,0x3
80004382:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80004386:	fc 09 08 49 	asr	r9,lr,r9
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
8000438a:	f6 0a 00 1a 	add	r10,r11,r10<<0x1
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
8000438e:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
 
   if(!error)
   {
     for(i = 0; i < NUM_CODE_LENGTH_CODES; i++)
     {
       if(i < HCLEN) codelengthcode.data[CLCL[i]] = readBitsFromStream(bp, in, 3);
80004392:	f4 09 00 2a 	add	r10,r10,r9<<0x2
80004396:	e2 0c 09 2a 	st.w	r1[r12<<0x2],r10
   uivector_init(&codelengthcode);
   if(!uivector_resize(&codelengthcode, NUM_CODE_LENGTH_CODES)) error = 9911;
 
   if(!error)
   {
     for(i = 0; i < NUM_CODE_LENGTH_CODES; i++)
8000439a:	2f f3       	sub	r3,-1
8000439c:	2f c8       	sub	r8,-4
8000439e:	59 33       	cp.w	r3,19
800043a0:	c4 a0       	breq	80004434 <inflateHuffmanBlock+0x6e8>
     {
       if(i < HCLEN) codelengthcode.data[CLCL[i]] = readBitsFromStream(bp, in, 3);
800043a2:	06 30       	cp.w	r0,r3
800043a4:	fe 9b ff cc 	brhi	8000433c <inflateHuffmanBlock+0x5f0>
       else codelengthcode.data[CLCL[i]] = 0; /*if not, it must stay 0*/
800043a8:	70 09       	ld.w	r9,r8[0x0]
800043aa:	30 0e       	mov	lr,0
800043ac:	e2 09 09 2e 	st.w	r1[r9<<0x2],lr
800043b0:	cf 5b       	rjmp	8000439a <inflateHuffmanBlock+0x64e>
 
 static unsigned ucvector_resize(ucvector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned char) > p->allocsize)
   {
     size_t newsize = size * sizeof(unsigned char) * 2;
800043b2:	f2 00 15 02 	lsl	r0,r9,0x2
     void* data = realloc(p->data, newsize);
800043b6:	64 0c       	ld.w	r12,r2[0x0]
800043b8:	00 9b       	mov	r11,r0
800043ba:	50 18       	stdsp	sp[0x4],r8
800043bc:	e0 a0 60 6e 	rcall	80010498 <realloc>
     if(data)
800043c0:	40 18       	lddsp	r8,sp[0x4]
800043c2:	eb f9 00 00 	ld.weq	r9,r5[0x0]
800043c6:	e5 f1 00 01 	ld.weq	r1,r2[0x4]
     {
       p->allocsize = newsize;
800043ca:	e5 f0 1a 02 	st.wne	r2[0x8],r0
       p->data = (unsigned char*)data;
800043ce:	e5 fc 1a 00 	st.wne	r2[0x0],r12
       p->size = size;
800043d2:	e5 f1 1a 01 	st.wne	r2[0x4],r1
800043d6:	eb f9 10 00 	ld.wne	r9,r5[0x0]
800043da:	fe 9f fd f4 	bral	80003fc2 <inflateHuffmanBlock+0x276>
   unsigned n, HLIT, HDIST, HCLEN, i;
   uivector bitlen;
   uivector bitlenD;
   uivector codelengthcode;
 
   if((*bp) >> 3 >= inlength - 2) { return 49; } /*the bit pointer is or will go past the memory*/
800043de:	33 13       	mov	r3,49
   size_t allocsize; /*allocated size in bytes*/
 } uivector;
 
 static void uivector_cleanup(void* p)
 {
   ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
800043e0:	30 01       	mov	r1,0
   free(((uivector*)p)->data);
800043e2:	41 8c       	lddsp	r12,sp[0x60]
   size_t allocsize; /*allocated size in bytes*/
 } uivector;
 
 static void uivector_cleanup(void* p)
 {
   ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
800043e4:	51 a1       	stdsp	sp[0x68],r1
800043e6:	51 91       	stdsp	sp[0x64],r1
   free(((uivector*)p)->data);
800043e8:	e0 a0 5d 82 	rcall	8000feec <free>
800043ec:	41 bc       	lddsp	r12,sp[0x6c]
   ((uivector*)p)->data = NULL;
800043ee:	51 81       	stdsp	sp[0x60],r1
   size_t allocsize; /*allocated size in bytes*/
 } uivector;
 
 static void uivector_cleanup(void* p)
 {
   ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
800043f0:	51 d1       	stdsp	sp[0x74],r1
800043f2:	51 c1       	stdsp	sp[0x70],r1
   free(((uivector*)p)->data);
800043f4:	e0 a0 5d 7c 	rcall	8000feec <free>
800043f8:	41 ec       	lddsp	r12,sp[0x78]
   ((uivector*)p)->data = NULL;
800043fa:	51 b1       	stdsp	sp[0x6c],r1
   size_t allocsize; /*allocated size in bytes*/
 } uivector;
 
 static void uivector_cleanup(void* p)
 {
   ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
800043fc:	52 01       	stdsp	sp[0x80],r1
800043fe:	51 f1       	stdsp	sp[0x7c],r1
   free(((uivector*)p)->data);
80004400:	e0 a0 5d 76 	rcall	8000feec <free>
   ((uivector*)p)->data = NULL;
80004404:	51 e1       	stdsp	sp[0x78],r1
80004406:	fe 9f fc c5 	bral	80003d90 <inflateHuffmanBlock+0x44>
 
 static unsigned ucvector_resize(ucvector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned char) > p->allocsize)
   {
     size_t newsize = size * sizeof(unsigned char) * 2;
8000440a:	a3 6a       	lsl	r10,0x2
     void* data = realloc(p->data, newsize);
8000440c:	64 0c       	ld.w	r12,r2[0x0]
8000440e:	14 9b       	mov	r11,r10
80004410:	50 2a       	stdsp	sp[0x8],r10
80004412:	50 39       	stdsp	sp[0xc],r9
80004414:	50 18       	stdsp	sp[0x4],r8
80004416:	e0 a0 60 41 	rcall	80010498 <realloc>
     if(data)
8000441a:	40 2a       	lddsp	r10,sp[0x8]
8000441c:	40 39       	lddsp	r9,sp[0xc]
8000441e:	40 18       	lddsp	r8,sp[0x4]
80004420:	e5 f9 00 01 	ld.weq	r9,r2[0x4]
     {
       p->allocsize = newsize;
80004424:	e5 fa 1a 02 	st.wne	r2[0x8],r10
       p->data = (unsigned char*)data;
80004428:	e5 fc 1a 00 	st.wne	r2[0x0],r12
       p->size = size;
8000442c:	e5 f9 1a 01 	st.wne	r2[0x4],r9
80004430:	fe 9f fe 53 	bral	800040d6 <inflateHuffmanBlock+0x38a>
80004434:	40 42       	lddsp	r2,sp[0x10]
80004436:	40 55       	lddsp	r5,sp[0x14]
   ((uivector*)p)->data = NULL;
 }
 
 static unsigned uivector_resize(uivector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned) > p->allocsize)
80004438:	42 08       	lddsp	r8,sp[0x80]
8000443a:	e0 48 00 4b 	cp.w	r8,75
8000443e:	e0 88 02 1a 	brls	80004872 <inflateHuffmanBlock+0xb26>
       p->data = (unsigned*)data;
       p->size = size;
     }
     else return 0;
   }
   else p->size = size;
80004442:	51 f3       	stdsp	sp[0x7c],r3
80004444:	41 e9       	lddsp	r9,sp[0x78]
 } uivector;
 
 static void uivector_cleanup(void* p)
 {
   ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
   free(((uivector*)p)->data);
80004446:	30 08       	mov	r8,0
80004448:	c0 28       	rjmp	8000444c <inflateHuffmanBlock+0x700>
       p->data = (unsigned*)data;
       p->size = size;
     }
     else return 0;
   }
   else p->size = size;
8000444a:	41 e9       	lddsp	r9,sp[0x78]
 /*given the code lengths (as stored in the PNG file), generate the tree as defined by Deflate. maxbitlen is the maximum bits that a code in the tree can have. return value is error.*/
 static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen, size_t numcodes, unsigned maxbitlen)
 {
   unsigned i;
   if(!uivector_resize(&tree->lengths, numcodes)) return 9903;
   for(i = 0; i < numcodes; i++) tree->lengths.data[i] = bitlen[i];
8000444c:	e2 08 03 0a 	ld.w	r10,r1[r8]
80004450:	f2 08 09 0a 	st.w	r9[r8],r10
80004454:	2f c8       	sub	r8,-4
80004456:	e0 48 00 4c 	cp.w	r8,76
8000445a:	cf 81       	brne	8000444a <inflateHuffmanBlock+0x6fe>
   tree->numcodes = (unsigned)numcodes; /*number of symbols*/
8000445c:	31 38       	mov	r8,19
8000445e:	52 28       	stdsp	sp[0x88],r8
   tree->maxbitlen = maxbitlen;
80004460:	30 78       	mov	r8,7
   return HuffmanTree_makeFromLengths2(tree);
80004462:	fa cc ff a0 	sub	r12,sp,-96
 {
   unsigned i;
   if(!uivector_resize(&tree->lengths, numcodes)) return 9903;
   for(i = 0; i < numcodes; i++) tree->lengths.data[i] = bitlen[i];
   tree->numcodes = (unsigned)numcodes; /*number of symbols*/
   tree->maxbitlen = maxbitlen;
80004466:	52 18       	stdsp	sp[0x84],r8
   return HuffmanTree_makeFromLengths2(tree);
80004468:	fe b0 fa 48 	rcall	800038f8 <HuffmanTree_makeFromLengths2>
8000446c:	18 93       	mov	r3,r12
 } uivector;
 
 static void uivector_cleanup(void* p)
 {
   ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
   free(((uivector*)p)->data);
8000446e:	02 9c       	mov	r12,r1
80004470:	e0 a0 5d 3e 	rcall	8000feec <free>
 
     error = HuffmanTree_makeFromLengths(codelengthcodetree, codelengthcode.data, codelengthcode.size, 7);
   }
 
   uivector_cleanup(&codelengthcode);
   if(error) return error;
80004474:	58 03       	cp.w	r3,0
80004476:	cb 51       	brne	800043e0 <inflateHuffmanBlock+0x694>
 static unsigned uivector_resize(uivector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned) > p->allocsize)
   {
     size_t newsize = size * sizeof(unsigned) * 2;
     void* data = realloc(p->data, newsize);
80004478:	e0 6b 09 00 	mov	r11,2304
8000447c:	06 9c       	mov	r12,r3
8000447e:	e0 a0 60 0d 	rcall	80010498 <realloc>
     if(data)
80004482:	e0 80 02 27 	breq	800048d0 <inflateHuffmanBlock+0xb84>
     {
       p->allocsize = newsize;
       p->data = (unsigned*)data;
80004486:	50 4c       	stdsp	sp[0x10],r12
80004488:	18 98       	mov	r8,r12
 
   return error;
 }
 
 /*inflate a block with dynamic of fixed Huffman tree*/
 static unsigned inflateHuffmanBlock(ucvector* out, const unsigned char* in, size_t* bp, size_t* pos, size_t inlength, unsigned btype)
8000448a:	f8 c9 fb 80 	sub	r9,r12,-1152
 
 static unsigned uivector_resizev(uivector* p, size_t size, unsigned value) /*resize and give all new elements the value*/
 {
   size_t oldsize = p->size, i;
   if(!uivector_resize(p, size)) return 0;
   for(i = oldsize; i < size; i++) p->data[i] = value;
8000448e:	10 a3       	st.w	r8++,r3
80004490:	12 38       	cp.w	r8,r9
80004492:	cf e1       	brne	8000448e <inflateHuffmanBlock+0x742>
80004494:	e0 6c 01 20 	mov	r12,288
80004498:	50 bc       	stdsp	sp[0x2c],r12
 static unsigned uivector_resize(uivector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned) > p->allocsize)
   {
     size_t newsize = size * sizeof(unsigned) * 2;
     void* data = realloc(p->data, newsize);
8000449a:	e0 6b 01 00 	mov	r11,256
8000449e:	30 0c       	mov	r12,0
800044a0:	e0 a0 5f fc 	rcall	80010498 <realloc>
800044a4:	50 5c       	stdsp	sp[0x14],r12
     if(data)
800044a6:	e0 80 02 12 	breq	800048ca <inflateHuffmanBlock+0xb7e>
     {
       p->allocsize = newsize;
       p->data = (unsigned*)data;
800044aa:	40 58       	lddsp	r8,sp[0x14]
 
 static unsigned uivector_resizev(uivector* p, size_t size, unsigned value) /*resize and give all new elements the value*/
 {
   size_t oldsize = p->size, i;
   if(!uivector_resize(p, size)) return 0;
   for(i = oldsize; i < size; i++) p->data[i] = value;
800044ac:	30 09       	mov	r9,0
 
   return error;
 }
 
 /*inflate a block with dynamic of fixed Huffman tree*/
 static unsigned inflateHuffmanBlock(ucvector* out, const unsigned char* in, size_t* bp, size_t* pos, size_t inlength, unsigned btype)
800044ae:	10 9a       	mov	r10,r8
800044b0:	28 0a       	sub	r10,-128
 
 static unsigned uivector_resizev(uivector* p, size_t size, unsigned value) /*resize and give all new elements the value*/
 {
   size_t oldsize = p->size, i;
   if(!uivector_resize(p, size)) return 0;
   for(i = oldsize; i < size; i++) p->data[i] = value;
800044b2:	10 a9       	st.w	r8++,r9
800044b4:	14 38       	cp.w	r8,r10
800044b6:	cf e1       	brne	800044b2 <inflateHuffmanBlock+0x766>
800044b8:	32 0b       	mov	r11,32
800044ba:	50 ab       	stdsp	sp[0x28],r11
   uivector_init(&bitlen);
   uivector_resizev(&bitlen, NUM_DEFLATE_CODE_SYMBOLS, 0);
   uivector_init(&bitlenD);
   uivector_resizev(&bitlenD, NUM_DISTANCE_SYMBOLS, 0);
   i = 0;
   if(!bitlen.data || !bitlenD.data) error = 9912;
800044bc:	40 4a       	lddsp	r10,sp[0x10]
800044be:	58 0a       	cp.w	r10,0
800044c0:	e0 80 02 0f 	breq	800048de <inflateHuffmanBlock+0xb92>
800044c4:	40 59       	lddsp	r9,sp[0x14]
800044c6:	58 09       	cp.w	r9,0
800044c8:	e0 80 02 0b 	breq	800048de <inflateHuffmanBlock+0xb92>
   uivector bitlenD;
   uivector codelengthcode;
 
   if((*bp) >> 3 >= inlength - 2) { return 49; } /*the bit pointer is or will go past the memory*/
 
   HLIT =  readBitsFromStream(bp, in, 5) + 257; /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
800044cc:	40 98       	lddsp	r8,sp[0x24]
800044ce:	f0 ce fe ff 	sub	lr,r8,-257
       if((*bp) >> 3 >= inlength) { error = 50; break; } /*error, bit pointer jumps past memory*/
 
       replength += readBitsFromStream(bp, in, 2);
 
       if((i - 1) < HLIT) value = bitlen.data[i - 1];
       else value = bitlenD.data[i - HLIT - 1];
800044d2:	fc 00 11 ff 	rsub	r0,lr,-1
   uivector bitlenD;
   uivector codelengthcode;
 
   if((*bp) >> 3 >= inlength - 2) { return 49; } /*the bit pointer is or will go past the memory*/
 
   HLIT =  readBitsFromStream(bp, in, 5) + 257; /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
800044d6:	30 03       	mov	r3,0
800044d8:	40 71       	lddsp	r1,sp[0x1c]
       if((*bp) >> 3 >= inlength) { error = 50; break; } /*error, bit pointer jumps past memory*/
 
       replength += readBitsFromStream(bp, in, 2);
 
       if((i - 1) < HLIT) value = bitlen.data[i - 1];
       else value = bitlenD.data[i - HLIT - 1];
800044da:	51 40       	stdsp	sp[0x50],r0
   uivector bitlenD;
   uivector codelengthcode;
 
   if((*bp) >> 3 >= inlength - 2) { return 49; } /*the bit pointer is or will go past the memory*/
 
   HLIT =  readBitsFromStream(bp, in, 5) + 257; /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
800044dc:	2f f1       	sub	r1,-1
800044de:	06 98       	mov	r8,r3
800044e0:	1c 01       	add	r1,lr
800044e2:	06 90       	mov	r0,r3
   uivector_resizev(&bitlen, NUM_DEFLATE_CODE_SYMBOLS, 0);
   uivector_init(&bitlenD);
   uivector_resizev(&bitlenD, NUM_DISTANCE_SYMBOLS, 0);
   i = 0;
   if(!bitlen.data || !bitlenD.data) error = 9912;
   else while(i < HLIT + HDIST) /*i is the current symbol we're reading in the part that contains the code lengths of lit/len codes and dist codes*/
800044e4:	02 38       	cp.w	r8,r1
800044e6:	e0 82 01 bb 	brhs	8000485c <inflateHuffmanBlock+0xb10>
   uivector bitlenD;
   uivector codelengthcode;
 
   if((*bp) >> 3 >= inlength - 2) { return 49; } /*the bit pointer is or will go past the memory*/
 
   HLIT =  readBitsFromStream(bp, in, 5) + 257; /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
800044ea:	6e 0a       	ld.w	r10,r7[0x0]
800044ec:	30 0c       	mov	r12,0
 {
   unsigned treepos = 0, decoded, ct;
   for(;;)
   {
     unsigned char bit;
     if(((*bp) & 0x07) == 0 && ((*bp) >> 3) > inlength) { *error = 10; return 0; } /*error: end of input memory reached without endcode*/
800044ee:	f7 da c0 03 	bfextu	r11,r10,0x0,0x3
800044f2:	c1 a0       	breq	80004526 <inflateHuffmanBlock+0x7da>
800044f4:	f4 09 16 03 	lsr	r9,r10,0x3
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
800044f8:	ec 09 07 03 	ld.ub	r3,r6[r9]
800044fc:	f4 c9 ff ff 	sub	r9,r10,-1
   (*bitpointer)++;
80004500:	8f 09       	st.w	r7[0x0],r9
 return value is error.*/
 static unsigned HuffmanTree_decode(const HuffmanTree* tree, unsigned* decoded, unsigned* result, unsigned* treepos, unsigned char bit)
 {
   if((*treepos) >= tree->numcodes) return 11; /*error: it appeared outside the codetree*/
 
   (*result) = tree->tree2d.data[2 * (*treepos) + bit];
80004502:	e6 0b 08 43 	asr	r3,r3,r11
 bit is the bit that was just read from the stream
 you have to decode a full symbol (let the decode function return true) before you can try to decode another one, otherwise the state isn't reset
 return value is error.*/
 static unsigned HuffmanTree_decode(const HuffmanTree* tree, unsigned* decoded, unsigned* result, unsigned* treepos, unsigned char bit)
 {
   if((*treepos) >= tree->numcodes) return 11; /*error: it appeared outside the codetree*/
80004506:	42 2b       	lddsp	r11,sp[0x88]
 
   (*result) = tree->tree2d.data[2 * (*treepos) + bit];
80004508:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000450c:	e6 0c 00 13 	add	r3,r3,r12<<0x1
 bit is the bit that was just read from the stream
 you have to decode a full symbol (let the decode function return true) before you can try to decode another one, otherwise the state isn't reset
 return value is error.*/
 static unsigned HuffmanTree_decode(const HuffmanTree* tree, unsigned* decoded, unsigned* result, unsigned* treepos, unsigned char bit)
 {
   if((*treepos) >= tree->numcodes) return 11; /*error: it appeared outside the codetree*/
80004510:	18 3b       	cp.w	r11,r12
80004512:	e0 8b 00 10 	brhi	80004532 <inflateHuffmanBlock+0x7e6>
80004516:	30 b3       	mov	r3,11
 } uivector;
 
 static void uivector_cleanup(void* p)
 {
   ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
   free(((uivector*)p)->data);
80004518:	40 4c       	lddsp	r12,sp[0x10]
8000451a:	e0 a0 5c e9 	rcall	8000feec <free>
8000451e:	40 5c       	lddsp	r12,sp[0x14]
80004520:	e0 a0 5c e6 	rcall	8000feec <free>
80004524:	c5 eb       	rjmp	800043e0 <inflateHuffmanBlock+0x694>
 {
   unsigned treepos = 0, decoded, ct;
   for(;;)
   {
     unsigned char bit;
     if(((*bp) & 0x07) == 0 && ((*bp) >> 3) > inlength) { *error = 10; return 0; } /*error: end of input memory reached without endcode*/
80004526:	f4 09 16 03 	lsr	r9,r10,0x3
8000452a:	12 34       	cp.w	r4,r9
8000452c:	ce 62       	brcc	800044f8 <inflateHuffmanBlock+0x7ac>
 
   (*result) = tree->tree2d.data[2 * (*treepos) + bit];
   (*decoded) = ((*result) < tree->numcodes);
 
   if(*decoded) (*treepos) = 0;
   else (*treepos) = (*result) - tree->numcodes;
8000452e:	30 a3       	mov	r3,10
80004530:	cf 4b       	rjmp	80004518 <inflateHuffmanBlock+0x7cc>
 return value is error.*/
 static unsigned HuffmanTree_decode(const HuffmanTree* tree, unsigned* decoded, unsigned* result, unsigned* treepos, unsigned char bit)
 {
   if((*treepos) >= tree->numcodes) return 11; /*error: it appeared outside the codetree*/
 
   (*result) = tree->tree2d.data[2 * (*treepos) + bit];
80004532:	41 8c       	lddsp	r12,sp[0x60]
   (*decoded) = ((*result) < tree->numcodes);
 
   if(*decoded) (*treepos) = 0;
   else (*treepos) = (*result) - tree->numcodes;
80004534:	12 9a       	mov	r10,r9
 return value is error.*/
 static unsigned HuffmanTree_decode(const HuffmanTree* tree, unsigned* decoded, unsigned* result, unsigned* treepos, unsigned char bit)
 {
   if((*treepos) >= tree->numcodes) return 11; /*error: it appeared outside the codetree*/
 
   (*result) = tree->tree2d.data[2 * (*treepos) + bit];
80004536:	f8 03 03 23 	ld.w	r3,r12[r3<<0x2]
   (*decoded) = ((*result) < tree->numcodes);
 
   if(*decoded) (*treepos) = 0;
   else (*treepos) = (*result) - tree->numcodes;
8000453a:	e6 0b 01 0c 	sub	r12,r3,r11
   if((*treepos) >= tree->numcodes) return 11; /*error: it appeared outside the codetree*/
 
   (*result) = tree->tree2d.data[2 * (*treepos) + bit];
   (*decoded) = ((*result) < tree->numcodes);
 
   if(*decoded) (*treepos) = 0;
8000453e:	06 3b       	cp.w	r11,r3
80004540:	fe 98 ff d7 	brls	800044ee <inflateHuffmanBlock+0x7a2>
   else while(i < HLIT + HDIST) /*i is the current symbol we're reading in the part that contains the code lengths of lit/len codes and dist codes*/
   {
     unsigned code = huffmanDecodeSymbol(&error, in, bp, codelengthcodetree, inlength);
     if(error) break;
 
     if(code <= 15) /*a length code*/
80004544:	58 f3       	cp.w	r3,15
80004546:	e0 8b 00 0b 	brhi	8000455c <inflateHuffmanBlock+0x810>
     {
       if(i < HLIT) bitlen.data[i] = code;
8000454a:	10 3e       	cp.w	lr,r8
8000454c:	e0 88 00 b3 	brls	800046b2 <inflateHuffmanBlock+0x966>
80004550:	40 4c       	lddsp	r12,sp[0x10]
80004552:	f8 08 09 23 	st.w	r12[r8<<0x2],r3
       else bitlenD.data[i - HLIT] = code;
       i++;
80004556:	2f f8       	sub	r8,-1
80004558:	30 03       	mov	r3,0
8000455a:	cc 5b       	rjmp	800044e4 <inflateHuffmanBlock+0x798>
     }
     else if(code == 16) /*repeat previous*/
8000455c:	59 03       	cp.w	r3,16
8000455e:	e0 80 00 b0 	breq	800046be <inflateHuffmanBlock+0x972>
         if(i < HLIT) bitlen.data[i] = value;
         else bitlenD.data[i - HLIT] = value;
         i++;
       }
     }
     else if(code == 17) /*repeat "0" 3-10 times*/
80004562:	59 13       	cp.w	r3,17
80004564:	e0 80 00 f7 	breq	80004752 <inflateHuffmanBlock+0xa06>
         if(i < HLIT) bitlen.data[i] = 0;
         else bitlenD.data[i - HLIT] = 0;
         i++;
       }
     }
     else if(code == 18) /*repeat "0" 11-138 times*/
80004568:	59 23       	cp.w	r3,18
8000456a:	e0 81 01 c1 	brne	800048ec <inflateHuffmanBlock+0xba0>
     {
       unsigned replength = 11; /*read in the bits that indicate repeat length*/
       if((*bp) >> 3 >= inlength) { error = 50; break; } /*error, bit pointer jumps past memory*/
8000456e:	f2 0a 16 03 	lsr	r10,r9,0x3
80004572:	14 34       	cp.w	r4,r10
80004574:	e0 88 01 b9 	brls	800048e6 <inflateHuffmanBlock+0xb9a>
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80004578:	ec 0a 07 0a 	ld.ub	r10,r6[r10]
8000457c:	50 ca       	stdsp	sp[0x30],r10
   (*bitpointer)++;
8000457e:	f2 cc ff ff 	sub	r12,r9,-1
80004582:	8f 0c       	st.w	r7[0x0],r12
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80004584:	f8 0a 16 03 	lsr	r10,r12,0x3
80004588:	ec 0a 07 0a 	ld.ub	r10,r6[r10]
8000458c:	50 da       	stdsp	sp[0x34],r10
   (*bitpointer)++;
8000458e:	f8 cb ff ff 	sub	r11,r12,-1
80004592:	8f 0b       	st.w	r7[0x0],r11
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80004594:	f6 03 16 03 	lsr	r3,r11,0x3
80004598:	ec 03 07 03 	ld.ub	r3,r6[r3]
8000459c:	50 e3       	stdsp	sp[0x38],r3
   (*bitpointer)++;
8000459e:	f6 ca ff ff 	sub	r10,r11,-1
800045a2:	8f 0a       	st.w	r7[0x0],r10
800045a4:	f4 c3 ff ff 	sub	r3,r10,-1
800045a8:	50 73       	stdsp	sp[0x1c],r3
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
800045aa:	f4 03 16 03 	lsr	r3,r10,0x3
800045ae:	ec 03 07 03 	ld.ub	r3,r6[r3]
800045b2:	50 f3       	stdsp	sp[0x3c],r3
   (*bitpointer)++;
800045b4:	40 73       	lddsp	r3,sp[0x1c]
800045b6:	8f 03       	st.w	r7[0x0],r3
800045b8:	2f f3       	sub	r3,-1
800045ba:	50 63       	stdsp	sp[0x18],r3
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
800045bc:	40 73       	lddsp	r3,sp[0x1c]
800045be:	a3 93       	lsr	r3,0x3
800045c0:	ec 03 07 03 	ld.ub	r3,r6[r3]
800045c4:	51 03       	stdsp	sp[0x40],r3
   (*bitpointer)++;
800045c6:	40 63       	lddsp	r3,sp[0x18]
800045c8:	8f 03       	st.w	r7[0x0],r3
800045ca:	2f f3       	sub	r3,-1
800045cc:	50 83       	stdsp	sp[0x20],r3
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
800045ce:	40 63       	lddsp	r3,sp[0x18]
800045d0:	a3 93       	lsr	r3,0x3
800045d2:	ec 03 07 03 	ld.ub	r3,r6[r3]
800045d6:	51 13       	stdsp	sp[0x44],r3
   (*bitpointer)++;
800045d8:	40 83       	lddsp	r3,sp[0x20]
800045da:	8f 03       	st.w	r7[0x0],r3
800045dc:	2f f3       	sub	r3,-1
800045de:	51 33       	stdsp	sp[0x4c],r3
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
800045e0:	40 83       	lddsp	r3,sp[0x20]
800045e2:	a3 93       	lsr	r3,0x3
800045e4:	ec 03 07 03 	ld.ub	r3,r6[r3]
800045e8:	51 23       	stdsp	sp[0x48],r3
   (*bitpointer)++;
800045ea:	41 33       	lddsp	r3,sp[0x4c]
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
800045ec:	f3 d9 c0 03 	bfextu	r9,r9,0x0,0x3
   (*bitpointer)++;
800045f0:	8f 03       	st.w	r7[0x0],r3
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
800045f2:	40 c3       	lddsp	r3,sp[0x30]
800045f4:	e6 09 08 49 	asr	r9,r3,r9
800045f8:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800045fc:	f7 db c0 03 	bfextu	r11,r11,0x0,0x3
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
80004600:	f2 c3 ff f5 	sub	r3,r9,-11
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80004604:	f3 dc c0 03 	bfextu	r9,r12,0x0,0x3
80004608:	40 dc       	lddsp	r12,sp[0x34]
8000460a:	f8 09 08 49 	asr	r9,r12,r9
8000460e:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004612:	40 ec       	lddsp	r12,sp[0x38]
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
80004614:	e6 09 00 13 	add	r3,r3,r9<<0x1
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80004618:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
8000461c:	f8 0b 08 49 	asr	r9,r12,r11
80004620:	40 fb       	lddsp	r11,sp[0x3c]
80004622:	f6 0a 08 4a 	asr	r10,r11,r10
80004626:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000462a:	41 0c       	lddsp	r12,sp[0x40]
8000462c:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
80004630:	e6 09 00 29 	add	r9,r3,r9<<0x2
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80004634:	40 73       	lddsp	r3,sp[0x1c]
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
80004636:	f2 0a 00 39 	add	r9,r9,r10<<0x3
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
8000463a:	f5 d3 c0 03 	bfextu	r10,r3,0x0,0x3
8000463e:	f8 0a 08 4a 	asr	r10,r12,r10
80004642:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
80004646:	a5 6a       	lsl	r10,0x4
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80004648:	40 6b       	lddsp	r11,sp[0x18]
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
8000464a:	14 09       	add	r9,r10
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
8000464c:	40 8c       	lddsp	r12,sp[0x20]
8000464e:	f5 db c0 03 	bfextu	r10,r11,0x0,0x3
80004652:	41 13       	lddsp	r3,sp[0x44]
80004654:	e6 0a 08 4a 	asr	r10,r3,r10
80004658:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
     }
     else if(code == 18) /*repeat "0" 11-138 times*/
     {
       unsigned replength = 11; /*read in the bits that indicate repeat length*/
       if((*bp) >> 3 >= inlength) { error = 50; break; } /*error, bit pointer jumps past memory*/
       replength += readBitsFromStream(bp, in, 7);
8000465c:	a5 7a       	lsl	r10,0x5
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
8000465e:	41 2b       	lddsp	r11,sp[0x48]
     }
     else if(code == 18) /*repeat "0" 11-138 times*/
     {
       unsigned replength = 11; /*read in the bits that indicate repeat length*/
       if((*bp) >> 3 >= inlength) { error = 50; break; } /*error, bit pointer jumps past memory*/
       replength += readBitsFromStream(bp, in, 7);
80004660:	14 09       	add	r9,r10
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80004662:	f5 dc c0 03 	bfextu	r10,r12,0x0,0x3
80004666:	f6 0a 08 4a 	asr	r10,r11,r10
8000466a:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
     }
     else if(code == 18) /*repeat "0" 11-138 times*/
     {
       unsigned replength = 11; /*read in the bits that indicate repeat length*/
       if((*bp) >> 3 >= inlength) { error = 50; break; } /*error, bit pointer jumps past memory*/
       replength += readBitsFromStream(bp, in, 7);
8000466e:	a7 6c       	lsl	r12,0x6
80004670:	f2 0c 00 0c 	add	r12,r9,r12
 
       /*repeat this value in the next lengths*/
       for(n = 0; n < replength; n++)
80004674:	c1 d0       	breq	800046ae <inflateHuffmanBlock+0x962>
80004676:	40 9a       	lddsp	r10,sp[0x24]
80004678:	40 59       	lddsp	r9,sp[0x14]
8000467a:	f0 0a 01 0b 	sub	r11,r8,r10
8000467e:	40 43       	lddsp	r3,sp[0x10]
80004680:	a3 6b       	lsl	r11,0x2
80004682:	e6 08 00 2a 	add	r10,r3,r8<<0x2
80004686:	f6 cb 04 04 	sub	r11,r11,1028
8000468a:	f2 0b 00 0b 	add	r11,r9,r11
8000468e:	30 09       	mov	r9,0
80004690:	c0 58       	rjmp	8000469a <inflateHuffmanBlock+0x94e>
80004692:	2f ca       	sub	r10,-4
80004694:	2f cb       	sub	r11,-4
       {
         if(i >= HLIT + HDIST) { error = 15; break; } /*error: i is larger than the amount of codes*/
80004696:	02 38       	cp.w	r8,r1
80004698:	c5 b2       	brcc	8000474e <inflateHuffmanBlock+0xa02>
         if(i < HLIT) bitlen.data[i] = 0;
8000469a:	10 3e       	cp.w	lr,r8
8000469c:	f5 f0 ba 00 	st.whi	r10[0x0],r0
         else bitlenD.data[i - HLIT] = 0;
800046a0:	f7 f0 8a 00 	st.wls	r11[0x0],r0
       unsigned replength = 11; /*read in the bits that indicate repeat length*/
       if((*bp) >> 3 >= inlength) { error = 50; break; } /*error, bit pointer jumps past memory*/
       replength += readBitsFromStream(bp, in, 7);
 
       /*repeat this value in the next lengths*/
       for(n = 0; n < replength; n++)
800046a4:	2f f9       	sub	r9,-1
       {
         if(i >= HLIT + HDIST) { error = 15; break; } /*error: i is larger than the amount of codes*/
         if(i < HLIT) bitlen.data[i] = 0;
         else bitlenD.data[i - HLIT] = 0;
         i++;
800046a6:	2f f8       	sub	r8,-1
       unsigned replength = 11; /*read in the bits that indicate repeat length*/
       if((*bp) >> 3 >= inlength) { error = 50; break; } /*error, bit pointer jumps past memory*/
       replength += readBitsFromStream(bp, in, 7);
 
       /*repeat this value in the next lengths*/
       for(n = 0; n < replength; n++)
800046a8:	12 3c       	cp.w	r12,r9
800046aa:	fe 9b ff f4 	brhi	80004692 <inflateHuffmanBlock+0x946>
800046ae:	30 03       	mov	r3,0
800046b0:	c1 ab       	rjmp	800044e4 <inflateHuffmanBlock+0x798>
     if(error) break;
 
     if(code <= 15) /*a length code*/
     {
       if(i < HLIT) bitlen.data[i] = code;
       else bitlenD.data[i - HLIT] = code;
800046b2:	f0 0e 01 09 	sub	r9,r8,lr
800046b6:	40 5b       	lddsp	r11,sp[0x14]
800046b8:	f6 09 09 23 	st.w	r11[r9<<0x2],r3
800046bc:	c4 db       	rjmp	80004556 <inflateHuffmanBlock+0x80a>
     else if(code == 16) /*repeat previous*/
     {
       unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/
       unsigned value; /*set value to the previous code*/
 
       if((*bp) >> 3 >= inlength) { error = 50; break; } /*error, bit pointer jumps past memory*/
800046be:	f2 0b 16 03 	lsr	r11,r9,0x3
800046c2:	16 34       	cp.w	r4,r11
800046c4:	e0 88 01 11 	brls	800048e6 <inflateHuffmanBlock+0xb9a>
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
   (*bitpointer)++;
800046c8:	f2 ca ff ff 	sub	r10,r9,-1
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
800046cc:	ec 0b 07 0c 	ld.ub	r12,r6[r11]
   (*bitpointer)++;
800046d0:	8f 0a       	st.w	r7[0x0],r10
800046d2:	f4 c3 ff ff 	sub	r3,r10,-1
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
800046d6:	f4 0b 16 03 	lsr	r11,r10,0x3
800046da:	f3 d9 c0 03 	bfextu	r9,r9,0x0,0x3
800046de:	ec 0b 07 0b 	ld.ub	r11,r6[r11]
800046e2:	f8 09 08 49 	asr	r9,r12,r9
   (*bitpointer)++;
800046e6:	8f 03       	st.w	r7[0x0],r3
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
800046e8:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
       unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/
       unsigned value; /*set value to the previous code*/
 
       if((*bp) >> 3 >= inlength) { error = 50; break; } /*error, bit pointer jumps past memory*/
 
       replength += readBitsFromStream(bp, in, 2);
800046ec:	2f d9       	sub	r9,-3
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
800046ee:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
800046f2:	f6 0a 08 4a 	asr	r10,r11,r10
800046f6:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
       unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/
       unsigned value; /*set value to the previous code*/
 
       if((*bp) >> 3 >= inlength) { error = 50; break; } /*error, bit pointer jumps past memory*/
 
       replength += readBitsFromStream(bp, in, 2);
800046fa:	f2 0c 00 1c 	add	r12,r9,r12<<0x1
 
       if((i - 1) < HLIT) value = bitlen.data[i - 1];
800046fe:	f0 c9 00 01 	sub	r9,r8,1
80004702:	12 3e       	cp.w	lr,r9
80004704:	e0 88 00 7c 	brls	800047fc <inflateHuffmanBlock+0xab0>
80004708:	40 4a       	lddsp	r10,sp[0x10]
8000470a:	f4 09 03 23 	ld.w	r3,r10[r9<<0x2]
       else value = bitlenD.data[i - HLIT - 1];
       /*repeat this value in the next lengths*/
       for(n = 0; n < replength; n++)
8000470e:	58 0c       	cp.w	r12,0
80004710:	cc f0       	breq	800046ae <inflateHuffmanBlock+0x962>
80004712:	40 59       	lddsp	r9,sp[0x14]
80004714:	40 9a       	lddsp	r10,sp[0x24]
80004716:	f0 0a 01 0b 	sub	r11,r8,r10
8000471a:	a3 6b       	lsl	r11,0x2
8000471c:	f6 cb 04 04 	sub	r11,r11,1028
80004720:	f2 0b 00 0b 	add	r11,r9,r11
80004724:	40 49       	lddsp	r9,sp[0x10]
80004726:	f2 08 00 2a 	add	r10,r9,r8<<0x2
8000472a:	30 09       	mov	r9,0
8000472c:	c0 58       	rjmp	80004736 <inflateHuffmanBlock+0x9ea>
8000472e:	2f ca       	sub	r10,-4
80004730:	2f cb       	sub	r11,-4
       {
         if(i >= HLIT + HDIST) { error = 13; break; } /*error: i is larger than the amount of codes*/
80004732:	02 38       	cp.w	r8,r1
80004734:	c6 22       	brcc	800047f8 <inflateHuffmanBlock+0xaac>
         if(i < HLIT) bitlen.data[i] = value;
80004736:	10 3e       	cp.w	lr,r8
80004738:	f5 f3 ba 00 	st.whi	r10[0x0],r3
         else bitlenD.data[i - HLIT] = value;
8000473c:	f7 f3 8a 00 	st.wls	r11[0x0],r3
       replength += readBitsFromStream(bp, in, 2);
 
       if((i - 1) < HLIT) value = bitlen.data[i - 1];
       else value = bitlenD.data[i - HLIT - 1];
       /*repeat this value in the next lengths*/
       for(n = 0; n < replength; n++)
80004740:	2f f9       	sub	r9,-1
       {
         if(i >= HLIT + HDIST) { error = 13; break; } /*error: i is larger than the amount of codes*/
         if(i < HLIT) bitlen.data[i] = value;
         else bitlenD.data[i - HLIT] = value;
         i++;
80004742:	2f f8       	sub	r8,-1
       replength += readBitsFromStream(bp, in, 2);
 
       if((i - 1) < HLIT) value = bitlen.data[i - 1];
       else value = bitlenD.data[i - HLIT - 1];
       /*repeat this value in the next lengths*/
       for(n = 0; n < replength; n++)
80004744:	12 3c       	cp.w	r12,r9
80004746:	fe 9b ff f4 	brhi	8000472e <inflateHuffmanBlock+0x9e2>
       unsigned replength = 11; /*read in the bits that indicate repeat length*/
       if((*bp) >> 3 >= inlength) { error = 50; break; } /*error, bit pointer jumps past memory*/
       replength += readBitsFromStream(bp, in, 7);
 
       /*repeat this value in the next lengths*/
       for(n = 0; n < replength; n++)
8000474a:	30 03       	mov	r3,0
8000474c:	cc ca       	rjmp	800044e4 <inflateHuffmanBlock+0x798>
       {
         if(i >= HLIT + HDIST) { error = 15; break; } /*error: i is larger than the amount of codes*/
8000474e:	30 f3       	mov	r3,15
80004750:	cc aa       	rjmp	800044e4 <inflateHuffmanBlock+0x798>
       }
     }
     else if(code == 17) /*repeat "0" 3-10 times*/
     {
       unsigned replength = 3; /*read in the bits that indicate repeat length*/
       if((*bp) >> 3 >= inlength) { error = 50; break; } /*error, bit pointer jumps past memory*/
80004752:	f2 0a 16 03 	lsr	r10,r9,0x3
80004756:	14 34       	cp.w	r4,r10
80004758:	e0 88 00 c7 	brls	800048e6 <inflateHuffmanBlock+0xb9a>
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
8000475c:	ec 0a 07 0a 	ld.ub	r10,r6[r10]
80004760:	50 8a       	stdsp	sp[0x20],r10
   (*bitpointer)++;
80004762:	f2 cb ff ff 	sub	r11,r9,-1
80004766:	8f 0b       	st.w	r7[0x0],r11
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80004768:	f6 0c 16 03 	lsr	r12,r11,0x3
8000476c:	ec 0c 07 0c 	ld.ub	r12,r6[r12]
80004770:	50 6c       	stdsp	sp[0x18],r12
   (*bitpointer)++;
80004772:	f6 ca ff ff 	sub	r10,r11,-1
80004776:	8f 0a       	st.w	r7[0x0],r10
80004778:	f4 cc ff ff 	sub	r12,r10,-1
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
8000477c:	f4 03 16 03 	lsr	r3,r10,0x3
80004780:	ec 03 07 03 	ld.ub	r3,r6[r3]
   (*bitpointer)++;
80004784:	8f 0c       	st.w	r7[0x0],r12
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
80004786:	40 8c       	lddsp	r12,sp[0x20]
80004788:	f3 d9 c0 03 	bfextu	r9,r9,0x0,0x3
8000478c:	f8 09 08 49 	asr	r9,r12,r9
80004790:	40 6c       	lddsp	r12,sp[0x18]
80004792:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004796:	f7 db c0 03 	bfextu	r11,r11,0x0,0x3
 }
 
 static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
 {
   unsigned result = 0, i;
   for(i = 0; i < nbits; i++) result += ((unsigned)readBitFromStream(bitpointer, bitstream)) << i;
8000479a:	2f d9       	sub	r9,-3
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
8000479c:	f8 0b 08 4b 	asr	r11,r12,r11
800047a0:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
800047a4:	f7 db c0 01 	bfextu	r11,r11,0x0,0x1
800047a8:	e6 0a 08 4a 	asr	r10,r3,r10
     else if(code == 17) /*repeat "0" 3-10 times*/
     {
       unsigned replength = 3; /*read in the bits that indicate repeat length*/
       if((*bp) >> 3 >= inlength) { error = 50; break; } /*error, bit pointer jumps past memory*/
 
       replength += readBitsFromStream(bp, in, 3);
800047ac:	f2 0b 00 19 	add	r9,r9,r11<<0x1
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
800047b0:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
     else if(code == 17) /*repeat "0" 3-10 times*/
     {
       unsigned replength = 3; /*read in the bits that indicate repeat length*/
       if((*bp) >> 3 >= inlength) { error = 50; break; } /*error, bit pointer jumps past memory*/
 
       replength += readBitsFromStream(bp, in, 3);
800047b4:	f2 0c 00 2c 	add	r12,r9,r12<<0x2
 
       /*repeat this value in the next lengths*/
       for(n = 0; n < replength; n++)
800047b8:	fe 90 ff 7b 	breq	800046ae <inflateHuffmanBlock+0x962>
800047bc:	40 9a       	lddsp	r10,sp[0x24]
800047be:	40 59       	lddsp	r9,sp[0x14]
800047c0:	f0 0a 01 0b 	sub	r11,r8,r10
800047c4:	40 43       	lddsp	r3,sp[0x10]
800047c6:	a3 6b       	lsl	r11,0x2
800047c8:	e6 08 00 2a 	add	r10,r3,r8<<0x2
800047cc:	f6 cb 04 04 	sub	r11,r11,1028
800047d0:	f2 0b 00 0b 	add	r11,r9,r11
800047d4:	30 09       	mov	r9,0
800047d6:	c0 58       	rjmp	800047e0 <inflateHuffmanBlock+0xa94>
800047d8:	2f ca       	sub	r10,-4
800047da:	2f cb       	sub	r11,-4
       {
         if(i >= HLIT + HDIST) { error = 14; break; } /*error: i is larger than the amount of codes*/
800047dc:	02 38       	cp.w	r8,r1
800047de:	c2 52       	brcc	80004828 <inflateHuffmanBlock+0xadc>
         if(i < HLIT) bitlen.data[i] = 0;
800047e0:	10 3e       	cp.w	lr,r8
800047e2:	f5 f0 ba 00 	st.whi	r10[0x0],r0
         else bitlenD.data[i - HLIT] = 0;
800047e6:	f7 f0 8a 00 	st.wls	r11[0x0],r0
       if((*bp) >> 3 >= inlength) { error = 50; break; } /*error, bit pointer jumps past memory*/
 
       replength += readBitsFromStream(bp, in, 3);
 
       /*repeat this value in the next lengths*/
       for(n = 0; n < replength; n++)
800047ea:	2f f9       	sub	r9,-1
       {
         if(i >= HLIT + HDIST) { error = 14; break; } /*error: i is larger than the amount of codes*/
         if(i < HLIT) bitlen.data[i] = 0;
         else bitlenD.data[i - HLIT] = 0;
         i++;
800047ec:	2f f8       	sub	r8,-1
       if((*bp) >> 3 >= inlength) { error = 50; break; } /*error, bit pointer jumps past memory*/
 
       replength += readBitsFromStream(bp, in, 3);
 
       /*repeat this value in the next lengths*/
       for(n = 0; n < replength; n++)
800047ee:	12 3c       	cp.w	r12,r9
800047f0:	fe 9b ff f4 	brhi	800047d8 <inflateHuffmanBlock+0xa8c>
       unsigned replength = 11; /*read in the bits that indicate repeat length*/
       if((*bp) >> 3 >= inlength) { error = 50; break; } /*error, bit pointer jumps past memory*/
       replength += readBitsFromStream(bp, in, 7);
 
       /*repeat this value in the next lengths*/
       for(n = 0; n < replength; n++)
800047f4:	30 03       	mov	r3,0
800047f6:	c7 7a       	rjmp	800044e4 <inflateHuffmanBlock+0x798>
       if((i - 1) < HLIT) value = bitlen.data[i - 1];
       else value = bitlenD.data[i - HLIT - 1];
       /*repeat this value in the next lengths*/
       for(n = 0; n < replength; n++)
       {
         if(i >= HLIT + HDIST) { error = 13; break; } /*error: i is larger than the amount of codes*/
800047f8:	30 d3       	mov	r3,13
800047fa:	c7 5a       	rjmp	800044e4 <inflateHuffmanBlock+0x798>
       if((*bp) >> 3 >= inlength) { error = 50; break; } /*error, bit pointer jumps past memory*/
 
       replength += readBitsFromStream(bp, in, 2);
 
       if((i - 1) < HLIT) value = bitlen.data[i - 1];
       else value = bitlenD.data[i - HLIT - 1];
800047fc:	41 49       	lddsp	r9,sp[0x50]
800047fe:	40 5b       	lddsp	r11,sp[0x14]
80004800:	10 09       	add	r9,r8
80004802:	f6 09 03 23 	ld.w	r3,r11[r9<<0x2]
80004806:	c8 4b       	rjmp	8000470e <inflateHuffmanBlock+0x9c2>
 static unsigned uivector_resize(uivector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned) > p->allocsize)
   {
     size_t newsize = size * sizeof(unsigned) * 2;
     void* data = realloc(p->data, newsize);
80004808:	e0 6b 01 00 	mov	r11,256
8000480c:	42 9c       	lddsp	r12,sp[0xa4]
8000480e:	e0 a0 5e 45 	rcall	80010498 <realloc>
     if(data)
80004812:	fe 90 fc 55 	breq	800040bc <inflateHuffmanBlock+0x370>
     {
       p->allocsize = newsize;
80004816:	e0 68 01 00 	mov	r8,256
       p->data = (unsigned*)data;
8000481a:	18 99       	mov	r9,r12
   {
     size_t newsize = size * sizeof(unsigned) * 2;
     void* data = realloc(p->data, newsize);
     if(data)
     {
       p->allocsize = newsize;
8000481c:	52 b8       	stdsp	sp[0xac],r8
       p->data = (unsigned*)data;
8000481e:	52 9c       	stdsp	sp[0xa4],r12
       p->size = size;
80004820:	32 08       	mov	r8,32
80004822:	52 a8       	stdsp	sp[0xa8],r8
80004824:	fe 9f fc 39 	bral	80004096 <inflateHuffmanBlock+0x34a>
       replength += readBitsFromStream(bp, in, 3);
 
       /*repeat this value in the next lengths*/
       for(n = 0; n < replength; n++)
       {
         if(i >= HLIT + HDIST) { error = 14; break; } /*error: i is larger than the amount of codes*/
80004828:	30 e3       	mov	r3,14
8000482a:	fe 9f fe 5d 	bral	800044e4 <inflateHuffmanBlock+0x798>
 static unsigned uivector_resize(uivector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned) > p->allocsize)
   {
     size_t newsize = size * sizeof(unsigned) * 2;
     void* data = realloc(p->data, newsize);
8000482e:	e0 6b 09 00 	mov	r11,2304
80004832:	43 4c       	lddsp	r12,sp[0xd0]
80004834:	e0 a0 5e 32 	rcall	80010498 <realloc>
     if(data)
80004838:	fe 90 fc 16 	breq	80004064 <inflateHuffmanBlock+0x318>
     {
       p->allocsize = newsize;
8000483c:	e0 68 09 00 	mov	r8,2304
       p->data = (unsigned*)data;
80004840:	18 99       	mov	r9,r12
   {
     size_t newsize = size * sizeof(unsigned) * 2;
     void* data = realloc(p->data, newsize);
     if(data)
     {
       p->allocsize = newsize;
80004842:	53 68       	stdsp	sp[0xd8],r8
       p->data = (unsigned*)data;
80004844:	53 4c       	stdsp	sp[0xd0],r12
       p->size = size;
80004846:	e0 68 01 20 	mov	r8,288
8000484a:	53 58       	stdsp	sp[0xd4],r8
8000484c:	fe 9f fb f8 	bral	8000403c <inflateHuffmanBlock+0x2f0>
 } uivector;
 
 static void uivector_cleanup(void* p)
 {
   ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
   free(((uivector*)p)->data);
80004850:	e0 a0 5b 4e 	rcall	8000feec <free>
80004854:	e0 63 26 b7 	mov	r3,9911
80004858:	fe 9f fd c4 	bral	800043e0 <inflateHuffmanBlock+0x694>
       }
     }
     else { error = 16; break; } /*error: somehow an unexisting code appeared. This can never happen.*/
   }
 
   if(!error && bitlen.data[256] == 0) { error = 64; } /*the length of the end code 256 must be larger than 0*/
8000485c:	58 03       	cp.w	r3,0
8000485e:	fe 91 fe 5d 	brne	80004518 <inflateHuffmanBlock+0x7cc>
80004862:	40 41       	lddsp	r1,sp[0x10]
80004864:	e2 f8 04 00 	ld.w	r8,r1[1024]
80004868:	58 08       	cp.w	r8,0
8000486a:	c1 51       	brne	80004894 <inflateHuffmanBlock+0xb48>
8000486c:	34 03       	mov	r3,64
8000486e:	fe 9f fe 55 	bral	80004518 <inflateHuffmanBlock+0x7cc>
 static unsigned uivector_resize(uivector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned) > p->allocsize)
   {
     size_t newsize = size * sizeof(unsigned) * 2;
     void* data = realloc(p->data, newsize);
80004872:	e0 6b 00 98 	mov	r11,152
80004876:	41 ec       	lddsp	r12,sp[0x78]
80004878:	e0 a0 5e 10 	rcall	80010498 <realloc>
     if(data)
8000487c:	c2 00       	breq	800048bc <inflateHuffmanBlock+0xb70>
     {
       p->allocsize = newsize;
8000487e:	e0 68 00 98 	mov	r8,152
       p->data = (unsigned*)data;
       p->size = size;
80004882:	51 f3       	stdsp	sp[0x7c],r3
     size_t newsize = size * sizeof(unsigned) * 2;
     void* data = realloc(p->data, newsize);
     if(data)
     {
       p->allocsize = newsize;
       p->data = (unsigned*)data;
80004884:	18 99       	mov	r9,r12
80004886:	51 ec       	stdsp	sp[0x78],r12
   {
     size_t newsize = size * sizeof(unsigned) * 2;
     void* data = realloc(p->data, newsize);
     if(data)
     {
       p->allocsize = newsize;
80004888:	52 08       	stdsp	sp[0x80],r8
8000488a:	fe 9f fd de 	bral	80004446 <inflateHuffmanBlock+0x6fa>
       length += readBitsFromStream(bp, in, numextrabits);
 
       /*part 3: get distance code*/
       codeD = huffmanDecodeSymbol(&error, in, bp, &codetreeD, inlength);
       if(error) break;
       if(codeD > 29) { error = 18; break; } /*error: invalid distance code (30-31 are never used)*/
8000488e:	31 23       	mov	r3,18
80004890:	fe 9f fa ab 	bral	80003de6 <inflateHuffmanBlock+0x9a>
   }
 
   if(!error && bitlen.data[256] == 0) { error = 64; } /*the length of the end code 256 must be larger than 0*/
 
   /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
   if(!error) error = HuffmanTree_makeFromLengths(codetree, &bitlen.data[0], bitlen.size, 15);
80004894:	40 ba       	lddsp	r10,sp[0x2c]
80004896:	30 f9       	mov	r9,15
80004898:	40 4b       	lddsp	r11,sp[0x10]
8000489a:	fa cc ff 48 	sub	r12,sp,-184
8000489e:	fe b0 f9 53 	rcall	80003b44 <HuffmanTree_makeFromLengths>
800048a2:	18 93       	mov	r3,r12
   if(!error) error = HuffmanTree_makeFromLengths(codetreeD, &bitlenD.data[0], bitlenD.size, 15);
800048a4:	fe 91 fe 3a 	brne	80004518 <inflateHuffmanBlock+0x7cc>
800048a8:	40 aa       	lddsp	r10,sp[0x28]
800048aa:	30 f9       	mov	r9,15
800048ac:	40 5b       	lddsp	r11,sp[0x14]
800048ae:	fa cc ff 74 	sub	r12,sp,-140
800048b2:	fe b0 f9 49 	rcall	80003b44 <HuffmanTree_makeFromLengths>
800048b6:	18 93       	mov	r3,r12
800048b8:	fe 9f fe 30 	bral	80004518 <inflateHuffmanBlock+0x7cc>
 } uivector;
 
 static void uivector_cleanup(void* p)
 {
   ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
   free(((uivector*)p)->data);
800048bc:	02 9c       	mov	r12,r1
800048be:	e0 63 26 af 	mov	r3,9903
800048c2:	e0 a0 5b 15 	rcall	8000feec <free>
800048c6:	fe 9f fd 8d 	bral	800043e0 <inflateHuffmanBlock+0x694>
 {
   if(size * sizeof(unsigned) > p->allocsize)
   {
     size_t newsize = size * sizeof(unsigned) * 2;
     void* data = realloc(p->data, newsize);
     if(data)
800048ca:	50 ac       	stdsp	sp[0x28],r12
800048cc:	fe 9f fd f8 	bral	800044bc <inflateHuffmanBlock+0x770>
800048d0:	50 4c       	stdsp	sp[0x10],r12
800048d2:	50 bc       	stdsp	sp[0x2c],r12
800048d4:	fe 9f fd e3 	bral	8000449a <inflateHuffmanBlock+0x74e>
     HuffmanTree_init(&codelengthcodetree);
     error = getTreeInflateDynamic(&codetree, &codetreeD, &codelengthcodetree, in, bp, inlength);
     HuffmanTree_cleanup(&codelengthcodetree);
   }
 
   while(!endreached && !error)
800048d8:	33 33       	mov	r3,51
800048da:	fe 9f fa 86 	bral	80003de6 <inflateHuffmanBlock+0x9a>
   else while(i < HLIT + HDIST) /*i is the current symbol we're reading in the part that contains the code lengths of lit/len codes and dist codes*/
   {
     unsigned code = huffmanDecodeSymbol(&error, in, bp, codelengthcodetree, inlength);
     if(error) break;
 
     if(code <= 15) /*a length code*/
800048de:	e0 63 26 b8 	mov	r3,9912
800048e2:	fe 9f fe 1b 	bral	80004518 <inflateHuffmanBlock+0x7cc>
800048e6:	33 23       	mov	r3,50
800048e8:	fe 9f fe 18 	bral	80004518 <inflateHuffmanBlock+0x7cc>
         if(i < HLIT) bitlen.data[i] = 0;
         else bitlenD.data[i - HLIT] = 0;
         i++;
       }
     }
     else if(code == 18) /*repeat "0" 11-138 times*/
800048ec:	31 03       	mov	r3,16
800048ee:	fe 9f fe 15 	bral	80004518 <inflateHuffmanBlock+0x7cc>
800048f2:	d7 03       	nop
800048f4:	80 01       	ld.sh	r1,r0[0x0]
800048f6:	6f cc       	ld.w	r12,r7[0x70]
800048f8:	80 01       	ld.sh	r1,r0[0x0]
800048fa:	71 90       	ld.w	r0,r8[0x64]
800048fc:	80 01       	ld.sh	r1,r0[0x0]
800048fe:	70 c4       	ld.w	r4,r8[0x30]
80004900:	80 01       	ld.sh	r1,r0[0x0]
80004902:	6f 54       	ld.w	r4,r7[0x54]
80004904:	80 01       	ld.sh	r1,r0[0x0]
80004906:	70 40       	ld.w	r0,r8[0x10]

80004908 <LodeZlib_decompress>:
80004908:	d4 31       	pushm	r0-r7,lr
8000490a:	20 ad       	sub	sp,40
8000490c:	18 93       	mov	r3,r12
8000490e:	16 92       	mov	r2,r11
80004910:	14 96       	mov	r6,r10
80004912:	12 97       	mov	r7,r9
80004914:	10 91       	mov	r1,r8
80004916:	58 19       	cp.w	r9,1
 {
   unsigned error = 0;
   unsigned CM, CINFO, FDICT;
   ucvector outv;
 
   if(insize < 2) { error = 53; return error; } /*error, size of zlib data too small*/
80004918:	e0 88 00 2e 	brls	80004974 <LodeZlib_decompress+0x6c>
   /*read information from zlib header*/
   if((in[0] * 256 + in[1]) % 31 != 0) { error = 24; return error; } /*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/
8000491c:	15 89       	ld.ub	r9,r10[0x0]
8000491e:	15 9b       	ld.ub	r11,r10[0x1]
80004920:	f2 08 15 08 	lsl	r8,r9,0x8
80004924:	e0 65 08 43 	mov	r5,2115
80004928:	ea 15 84 21 	orh	r5,0x8421
8000492c:	f6 08 00 08 	add	r8,r11,r8
80004930:	f0 05 04 44 	muls.d	r4,r8,r5
80004934:	f0 05 00 0a 	add	r10,r8,r5
80004938:	a5 4a       	asr	r10,0x4
8000493a:	f4 0c 15 05 	lsl	r12,r10,0x5
8000493e:	f8 0a 01 0a 	sub	r10,r12,r10
80004942:	14 18       	sub	r8,r10
80004944:	c1 21       	brne	80004968 <LodeZlib_decompress+0x60>
   CINFO = (in[0] >> 4) & 15;
   /*FCHECK = in[1] & 31; //FCHECK is already tested above*/
   FDICT = (in[1] >> 5) & 1;
   /*FLEVEL = (in[1] >> 6) & 3; //not really important, all it does it to give a compiler warning about unused variable, we don't care what encoding setting the encoder used*/
 
   if(CM != 8 || CINFO > 7) { error = 25; return error; } /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
80004946:	f5 d9 c0 04 	bfextu	r10,r9,0x0,0x4
8000494a:	a5 89       	lsr	r9,0x4
8000494c:	58 8a       	cp.w	r10,8
8000494e:	5f 1a       	srne	r10
80004950:	58 79       	cp.w	r9,7
80004952:	5f b9       	srhi	r9
80004954:	14 49       	or	r9,r10
80004956:	f0 09 18 00 	cp.b	r9,r8
8000495a:	c0 a1       	brne	8000496e <LodeZlib_decompress+0x66>
   if(FDICT != 0) { error = 26; return error; } /*error: the specification of PNG says about the zlib stream: "The additional flags shall not specify a preset dictionary."*/
8000495c:	f7 db c0 a1 	bfextu	r11,r11,0x5,0x1
80004960:	c0 d0       	breq	8000497a <LodeZlib_decompress+0x72>
80004962:	31 ac       	mov	r12,26
     unsigned checksum = adler32(outv.data, (unsigned)outv.size);
     if(checksum != ADLER32) { error = 58; return error; }
   }
 
   return error;
 }
80004964:	2f 6d       	sub	sp,-40
80004966:	d8 32       	popm	r0-r7,pc
   unsigned CM, CINFO, FDICT;
   ucvector outv;
 
   if(insize < 2) { error = 53; return error; } /*error, size of zlib data too small*/
   /*read information from zlib header*/
   if((in[0] * 256 + in[1]) % 31 != 0) { error = 24; return error; } /*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/
80004968:	31 8c       	mov	r12,24
     unsigned checksum = adler32(outv.data, (unsigned)outv.size);
     if(checksum != ADLER32) { error = 58; return error; }
   }
 
   return error;
 }
8000496a:	2f 6d       	sub	sp,-40
8000496c:	d8 32       	popm	r0-r7,pc
   CINFO = (in[0] >> 4) & 15;
   /*FCHECK = in[1] & 31; //FCHECK is already tested above*/
   FDICT = (in[1] >> 5) & 1;
   /*FLEVEL = (in[1] >> 6) & 3; //not really important, all it does it to give a compiler warning about unused variable, we don't care what encoding setting the encoder used*/
 
   if(CM != 8 || CINFO > 7) { error = 25; return error; } /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
8000496e:	31 9c       	mov	r12,25
     unsigned checksum = adler32(outv.data, (unsigned)outv.size);
     if(checksum != ADLER32) { error = 58; return error; }
   }
 
   return error;
 }
80004970:	2f 6d       	sub	sp,-40
80004972:	d8 32       	popm	r0-r7,pc
 {
   unsigned error = 0;
   unsigned CM, CINFO, FDICT;
   ucvector outv;
 
   if(insize < 2) { error = 53; return error; } /*error, size of zlib data too small*/
80004974:	33 5c       	mov	r12,53
     unsigned checksum = adler32(outv.data, (unsigned)outv.size);
     if(checksum != ADLER32) { error = 58; return error; }
   }
 
   return error;
 }
80004976:	2f 6d       	sub	sp,-40
80004978:	d8 32       	popm	r0-r7,pc
 /*inflate the deflated data (cfr. deflate spec); return value is the error*/
 unsigned LodeFlate_inflate(ucvector* out, const unsigned char* in, size_t insize, size_t inpos)
 {
   size_t bp = 0; /*bit pointer in the "in" data, current byte is bp >> 3, current bit is bp & 0x7 (from lsb to msb of the byte)*/
   unsigned BFINAL = 0;
   size_t pos = 0; /*byte position in the out buffer*/
8000497a:	50 8b       	stdsp	sp[0x20],r11
   /*FLEVEL = (in[1] >> 6) & 3; //not really important, all it does it to give a compiler warning about unused variable, we don't care what encoding setting the encoder used*/
 
   if(CM != 8 || CINFO > 7) { error = 25; return error; } /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
   if(FDICT != 0) { error = 26; return error; } /*error: the specification of PNG says about the zlib stream: "The additional flags shall not specify a preset dictionary."*/
 
   ucvector_init_buffer(&outv, *out, *outsize); /*ucvector-controlled version of the output buffer, for dynamic array*/
8000497c:	64 08       	ld.w	r8,r2[0x0]
 #ifdef LODEPNG_COMPILE_ZLIB
 /*you can both convert from vector to buffer&size and vica versa*/
 static void ucvector_init_buffer(ucvector* p, unsigned char* buffer, size_t size)
 {
   p->data = buffer;
   p->allocsize = p->size = size;
8000497e:	50 78       	stdsp	sp[0x1c],r8
80004980:	50 68       	stdsp	sp[0x18],r8
 
 #ifdef LODEPNG_COMPILE_ZLIB
 /*you can both convert from vector to buffer&size and vica versa*/
 static void ucvector_init_buffer(ucvector* p, unsigned char* buffer, size_t size)
 {
   p->data = buffer;
80004982:	66 08       	ld.w	r8,r3[0x0]
 
   while(!BFINAL)
   {
     unsigned BTYPE;
     if((bp >> 3) >= insize) return 52; /*error, bit pointer will jump past memory*/
     BFINAL = readBitFromStream(&bp, &in[inpos]);
80004984:	ec c5 ff fe 	sub	r5,r6,-2
 
 #ifdef LODEPNG_COMPILE_ZLIB
 /*you can both convert from vector to buffer&size and vica versa*/
 static void ucvector_init_buffer(ucvector* p, unsigned char* buffer, size_t size)
 {
   p->data = buffer;
80004988:	50 58       	stdsp	sp[0x14],r8
   unsigned BFINAL = 0;
   size_t pos = 0; /*byte position in the out buffer*/
 
   unsigned error = 0;
 
   while(!BFINAL)
8000498a:	50 36       	stdsp	sp[0xc],r6
   unsigned LEN, NLEN, n, error = 0;
   while(((*bp) & 0x7) != 0) (*bp)++;
   p = (*bp) / 8; /*byte position*/
 
   /*read LEN (2 bytes) and NLEN (2 bytes)*/
   if(p >= inlength - 4) return 52; /*error, bit pointer will jump past memory*/
8000498c:	ee c8 00 04 	sub	r8,r7,4
 /*inflate the deflated data (cfr. deflate spec); return value is the error*/
 unsigned LodeFlate_inflate(ucvector* out, const unsigned char* in, size_t insize, size_t inpos)
 {
   size_t bp = 0; /*bit pointer in the "in" data, current byte is bp >> 3, current bit is bp & 0x7 (from lsb to msb of the byte)*/
   unsigned BFINAL = 0;
   size_t pos = 0; /*byte position in the out buffer*/
80004990:	16 94       	mov	r4,r11
   unsigned LEN, NLEN, n, error = 0;
   while(((*bp) & 0x7) != 0) (*bp)++;
   p = (*bp) / 8; /*byte position*/
 
   /*read LEN (2 bytes) and NLEN (2 bytes)*/
   if(p >= inlength - 4) return 52; /*error, bit pointer will jump past memory*/
80004992:	50 18       	stdsp	sp[0x4],r8
   unsigned BFINAL = 0;
   size_t pos = 0; /*byte position in the out buffer*/
 
   unsigned error = 0;
 
   while(!BFINAL)
80004994:	0e 96       	mov	r6,r7
80004996:	50 41       	stdsp	sp[0x10],r1
   {
     unsigned BTYPE;
     if((bp >> 3) >= insize) return 52; /*error, bit pointer will jump past memory*/
80004998:	e8 0a 16 03 	lsr	r10,r4,0x3
8000499c:	14 36       	cp.w	r6,r10
8000499e:	e0 88 00 37 	brls	80004a0c <LodeZlib_decompress+0x104>
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
   (*bitpointer)++;
800049a2:	e8 c9 ff ff 	sub	r9,r4,-1
800049a6:	f2 c8 ff ff 	sub	r8,r9,-1
800049aa:	f0 c1 ff ff 	sub	r1,r8,-1
800049ae:	50 91       	stdsp	sp[0x24],r1
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
 {
   unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> ((*bitpointer) & 0x7)) & 1);
800049b0:	ea 0a 07 07 	ld.ub	r7,r5[r10]
800049b4:	f2 0a 16 03 	lsr	r10,r9,0x3
800049b8:	ea 0a 07 0a 	ld.ub	r10,r5[r10]
800049bc:	f3 d9 c0 03 	bfextu	r9,r9,0x0,0x3
800049c0:	f4 09 08 49 	asr	r9,r10,r9
800049c4:	f0 0a 16 03 	lsr	r10,r8,0x3
800049c8:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800049cc:	ea 0a 07 0a 	ld.ub	r10,r5[r10]
800049d0:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800049d4:	f4 08 08 48 	asr	r8,r10,r8
800049d8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
   while(!BFINAL)
   {
     unsigned BTYPE;
     if((bp >> 3) >= insize) return 52; /*error, bit pointer will jump past memory*/
     BFINAL = readBitFromStream(&bp, &in[inpos]);
     BTYPE = 1 * readBitFromStream(&bp, &in[inpos]); BTYPE += 2 * readBitFromStream(&bp, &in[inpos]);
800049dc:	f2 08 00 18 	add	r8,r9,r8<<0x1
 
     if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
800049e0:	58 38       	cp.w	r8,3
800049e2:	e0 80 00 88 	breq	80004af2 <LodeZlib_decompress+0x1ea>
     else if(BTYPE == 0) error = inflateNoCompression(out, &in[inpos], &bp, &pos, insize); /*no compression*/
800049e6:	58 08       	cp.w	r8,0
800049e8:	c3 01       	brne	80004a48 <LodeZlib_decompress+0x140>
 static unsigned inflateNoCompression(ucvector* out, const unsigned char* in, size_t* bp, size_t* pos, size_t inlength)
 {
   /*go to first boundary of byte*/
   size_t p;
   unsigned LEN, NLEN, n, error = 0;
   while(((*bp) & 0x7) != 0) (*bp)++;
800049ea:	f1 d1 c0 03 	bfextu	r8,r1,0x0,0x3
800049ee:	c0 b0       	breq	80004a04 <LodeZlib_decompress+0xfc>
800049f0:	e8 c1 ff fc 	sub	r1,r4,-4
800049f4:	c0 28       	rjmp	800049f8 <LodeZlib_decompress+0xf0>
800049f6:	12 91       	mov	r1,r9
800049f8:	e2 c9 ff ff 	sub	r9,r1,-1
800049fc:	f1 d1 c0 03 	bfextu	r8,r1,0x0,0x3
80004a00:	cf b1       	brne	800049f6 <LodeZlib_decompress+0xee>
80004a02:	50 91       	stdsp	sp[0x24],r1
   p = (*bp) / 8; /*byte position*/
80004a04:	a3 91       	lsr	r1,0x3
 
   /*read LEN (2 bytes) and NLEN (2 bytes)*/
   if(p >= inlength - 4) return 52; /*error, bit pointer will jump past memory*/
80004a06:	40 10       	lddsp	r0,sp[0x4]
80004a08:	00 31       	cp.w	r1,r0
80004a0a:	c0 83       	brcs	80004a1a <LodeZlib_decompress+0x112>
80004a0c:	33 4c       	mov	r12,52
   if(CM != 8 || CINFO > 7) { error = 25; return error; } /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
   if(FDICT != 0) { error = 26; return error; } /*error: the specification of PNG says about the zlib stream: "The additional flags shall not specify a preset dictionary."*/
 
   ucvector_init_buffer(&outv, *out, *outsize); /*ucvector-controlled version of the output buffer, for dynamic array*/
   error = LodeFlate_inflate(&outv, in, insize, 2);
   *out = outv.data;
80004a0e:	40 58       	lddsp	r8,sp[0x14]
80004a10:	87 08       	st.w	r3[0x0],r8
   *outsize = outv.size;
80004a12:	40 68       	lddsp	r8,sp[0x18]
80004a14:	85 08       	st.w	r2[0x0],r8
     unsigned checksum = adler32(outv.data, (unsigned)outv.size);
     if(checksum != ADLER32) { error = 58; return error; }
   }
 
   return error;
 }
80004a16:	2f 6d       	sub	sp,-40
80004a18:	d8 32       	popm	r0-r7,pc
   while(((*bp) & 0x7) != 0) (*bp)++;
   p = (*bp) / 8; /*byte position*/
 
   /*read LEN (2 bytes) and NLEN (2 bytes)*/
   if(p >= inlength - 4) return 52; /*error, bit pointer will jump past memory*/
   LEN = in[p] + 256 * in[p + 1]; p += 2;
80004a1a:	ea 01 00 09 	add	r9,r5,r1
80004a1e:	13 90       	ld.ub	r0,r9[0x1]
80004a20:	ea 01 07 09 	ld.ub	r9,r5[r1]
80004a24:	e2 c8 ff fe 	sub	r8,r1,-2
80004a28:	a9 60       	lsl	r0,0x8
80004a2a:	12 00       	add	r0,r9
   NLEN = in[p] + 256 * in[p + 1]; p += 2;
 
   /*check if 16-bit NLEN is really the one's complement of LEN*/
   if(LEN + NLEN != 65535) return 21; /*error: NLEN is not one's complement of LEN*/
80004a2c:	ea 08 00 09 	add	r9,r5,r8
80004a30:	13 9a       	ld.ub	r10,r9[0x1]
80004a32:	ea 08 07 09 	ld.ub	r9,r5[r8]
80004a36:	a9 6a       	lsl	r10,0x8
80004a38:	f4 09 00 09 	add	r9,r10,r9
80004a3c:	00 09       	add	r9,r0
80004a3e:	e0 49 ff ff 	cp.w	r9,65535
80004a42:	c1 e0       	breq	80004a7e <LodeZlib_decompress+0x176>
80004a44:	31 5c       	mov	r12,21
80004a46:	ce 4b       	rjmp	80004a0e <LodeZlib_decompress+0x106>
     BFINAL = readBitFromStream(&bp, &in[inpos]);
     BTYPE = 1 * readBitFromStream(&bp, &in[inpos]); BTYPE += 2 * readBitFromStream(&bp, &in[inpos]);
 
     if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
     else if(BTYPE == 0) error = inflateNoCompression(out, &in[inpos], &bp, &pos, insize); /*no compression*/
     else error = inflateHuffmanBlock(out, &in[inpos], &bp, &pos, insize, BTYPE); /*compression, BTYPE 01 or 10*/
80004a48:	1a d8       	st.w	--sp,r8
80004a4a:	0a 9b       	mov	r11,r5
80004a4c:	fa c9 ff dc 	sub	r9,sp,-36
80004a50:	fa ca ff d8 	sub	r10,sp,-40
80004a54:	fa cc ff e8 	sub	r12,sp,-24
80004a58:	0c 98       	mov	r8,r6
80004a5a:	fe b0 f9 79 	rcall	80003d4c <inflateHuffmanBlock>
     if(error) return error;
80004a5e:	2f fd       	sub	sp,-4
80004a60:	58 0c       	cp.w	r12,0
80004a62:	cd 61       	brne	80004a0e <LodeZlib_decompress+0x106>
   unsigned BFINAL = 0;
   size_t pos = 0; /*byte position in the out buffer*/
 
   unsigned error = 0;
 
   while(!BFINAL)
80004a64:	e9 d4 c0 03 	bfextu	r4,r4,0x0,0x3
80004a68:	ee 04 08 47 	asr	r7,r7,r4
80004a6c:	30 00       	mov	r0,0
80004a6e:	e3 d7 c0 01 	bfextu	r1,r7,0x0,0x1
80004a72:	02 97       	mov	r7,r1
80004a74:	e0 01 18 00 	cp.b	r1,r0
80004a78:	c3 11       	brne	80004ada <LodeZlib_decompress+0x1d2>
80004a7a:	40 94       	lddsp	r4,sp[0x24]
80004a7c:	c8 eb       	rjmp	80004998 <LodeZlib_decompress+0x90>
   NLEN = in[p] + 256 * in[p + 1]; p += 2;
 
   /*check if 16-bit NLEN is really the one's complement of LEN*/
   if(LEN + NLEN != 65535) return 21; /*error: NLEN is not one's complement of LEN*/
 
   if((*pos) + LEN >= out->size) { if(!ucvector_resize(out, (*pos) + LEN)) return 9915; }
80004a7e:	40 8b       	lddsp	r11,sp[0x20]
80004a80:	40 69       	lddsp	r9,sp[0x18]
80004a82:	e0 0b 00 0b 	add	r11,r0,r11
80004a86:	12 3b       	cp.w	r11,r9
80004a88:	c1 f2       	brcc	80004ac6 <LodeZlib_decompress+0x1be>
   p = (*bp) / 8; /*byte position*/
 
   /*read LEN (2 bytes) and NLEN (2 bytes)*/
   if(p >= inlength - 4) return 52; /*error, bit pointer will jump past memory*/
   LEN = in[p] + 256 * in[p + 1]; p += 2;
   NLEN = in[p] + 256 * in[p + 1]; p += 2;
80004a8a:	2f e8       	sub	r8,-2
   if(LEN + NLEN != 65535) return 21; /*error: NLEN is not one's complement of LEN*/
 
   if((*pos) + LEN >= out->size) { if(!ucvector_resize(out, (*pos) + LEN)) return 9915; }
 
   /*read the literal data: LEN bytes are now stored in the out buffer*/
   if(p + LEN > inlength) return 23; /*error: reading outside of in buffer*/
80004a8c:	e0 08 00 0e 	add	lr,r0,r8
80004a90:	1c 36       	cp.w	r6,lr
80004a92:	c1 83       	brcs	80004ac2 <LodeZlib_decompress+0x1ba>
   for(n = 0; n < LEN; n++) out->data[(*pos)++] = in[p++];
80004a94:	58 00       	cp.w	r0,0
80004a96:	c1 30       	breq	80004abc <LodeZlib_decompress+0x1b4>
80004a98:	40 38       	lddsp	r8,sp[0xc]
80004a9a:	e2 ca ff fa 	sub	r10,r1,-6
80004a9e:	30 09       	mov	r9,0
80004aa0:	f0 0a 00 0a 	add	r10,r8,r10
80004aa4:	40 88       	lddsp	r8,sp[0x20]
80004aa6:	15 3c       	ld.ub	r12,r10++
80004aa8:	40 5b       	lddsp	r11,sp[0x14]
80004aaa:	f6 08 0b 0c 	st.b	r11[r8],r12
80004aae:	2f f8       	sub	r8,-1
80004ab0:	50 88       	stdsp	sp[0x20],r8
80004ab2:	2f f9       	sub	r9,-1
80004ab4:	12 30       	cp.w	r0,r9
80004ab6:	fe 9b ff f8 	brhi	80004aa6 <LodeZlib_decompress+0x19e>
80004aba:	1c 98       	mov	r8,lr
 
   (*bp) = p * 8;
80004abc:	a3 78       	lsl	r8,0x3
80004abe:	50 98       	stdsp	sp[0x24],r8
80004ac0:	cd 2b       	rjmp	80004a64 <LodeZlib_decompress+0x15c>
   if(LEN + NLEN != 65535) return 21; /*error: NLEN is not one's complement of LEN*/
 
   if((*pos) + LEN >= out->size) { if(!ucvector_resize(out, (*pos) + LEN)) return 9915; }
 
   /*read the literal data: LEN bytes are now stored in the out buffer*/
   if(p + LEN > inlength) return 23; /*error: reading outside of in buffer*/
80004ac2:	31 7c       	mov	r12,23
80004ac4:	ca 5b       	rjmp	80004a0e <LodeZlib_decompress+0x106>
   NLEN = in[p] + 256 * in[p + 1]; p += 2;
 
   /*check if 16-bit NLEN is really the one's complement of LEN*/
   if(LEN + NLEN != 65535) return 21; /*error: NLEN is not one's complement of LEN*/
 
   if((*pos) + LEN >= out->size) { if(!ucvector_resize(out, (*pos) + LEN)) return 9915; }
80004ac6:	50 08       	stdsp	sp[0x0],r8
80004ac8:	fa cc ff ec 	sub	r12,sp,-20
80004acc:	fe b0 f5 b8 	rcall	8000363c <ucvector_resize>
80004ad0:	40 08       	lddsp	r8,sp[0x0]
80004ad2:	cd c1       	brne	80004a8a <LodeZlib_decompress+0x182>
 
   if(!settings->ignoreAdler32)
   {
     unsigned ADLER32 = LodeZlib_read32bitInt(&in[insize - 4]);
     unsigned checksum = adler32(outv.data, (unsigned)outv.size);
     if(checksum != ADLER32) { error = 58; return error; }
80004ad4:	e0 6c 26 bb 	mov	r12,9915
80004ad8:	c9 bb       	rjmp	80004a0e <LodeZlib_decompress+0x106>
80004ada:	0c 97       	mov	r7,r6
80004adc:	40 41       	lddsp	r1,sp[0x10]
80004ade:	40 36       	lddsp	r6,sp[0xc]
     else if(BTYPE == 0) error = inflateNoCompression(out, &in[inpos], &bp, &pos, insize); /*no compression*/
     else error = inflateHuffmanBlock(out, &in[inpos], &bp, &pos, insize, BTYPE); /*compression, BTYPE 01 or 10*/
     if(error) return error;
   }
 
   if(!ucvector_resize(out, pos)) error = 9916; /*Only now we know the true size of out, resize it to that*/
80004ae0:	40 8b       	lddsp	r11,sp[0x20]
80004ae2:	fa cc ff ec 	sub	r12,sp,-20
80004ae6:	fe b0 f5 ab 	rcall	8000363c <ucvector_resize>
80004aea:	c0 61       	brne	80004af6 <LodeZlib_decompress+0x1ee>
80004aec:	e0 6c 26 bc 	mov	r12,9916
80004af0:	c8 fb       	rjmp	80004a0e <LodeZlib_decompress+0x106>
     unsigned BTYPE;
     if((bp >> 3) >= insize) return 52; /*error, bit pointer will jump past memory*/
     BFINAL = readBitFromStream(&bp, &in[inpos]);
     BTYPE = 1 * readBitFromStream(&bp, &in[inpos]); BTYPE += 2 * readBitFromStream(&bp, &in[inpos]);
 
     if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
80004af2:	31 4c       	mov	r12,20
80004af4:	c8 db       	rjmp	80004a0e <LodeZlib_decompress+0x106>
   if(CM != 8 || CINFO > 7) { error = 25; return error; } /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
   if(FDICT != 0) { error = 26; return error; } /*error: the specification of PNG says about the zlib stream: "The additional flags shall not specify a preset dictionary."*/
 
   ucvector_init_buffer(&outv, *out, *outsize); /*ucvector-controlled version of the output buffer, for dynamic array*/
   error = LodeFlate_inflate(&outv, in, insize, 2);
   *out = outv.data;
80004af6:	40 5e       	lddsp	lr,sp[0x14]
80004af8:	87 0e       	st.w	r3[0x0],lr
   *outsize = outv.size;
80004afa:	40 69       	lddsp	r9,sp[0x18]
80004afc:	85 09       	st.w	r2[0x0],r9
   if(error) return error;
 
   if(!settings->ignoreAdler32)
80004afe:	62 0a       	ld.w	r10,r1[0x0]
80004b00:	58 0a       	cp.w	r10,0
80004b02:	c5 01       	brne	80004ba2 <LodeZlib_decompress+0x29a>
   {
     unsigned ADLER32 = LodeZlib_read32bitInt(&in[insize - 4]);
80004b04:	ee c8 00 04 	sub	r8,r7,4
     unsigned checksum = adler32(outv.data, (unsigned)outv.size);
80004b08:	12 97       	mov	r7,r9
   *outsize = outv.size;
   if(error) return error;
 
   if(!settings->ignoreAdler32)
   {
     unsigned ADLER32 = LodeZlib_read32bitInt(&in[insize - 4]);
80004b0a:	10 06       	add	r6,r8
 }
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 unsigned LodeZlib_read32bitInt(const unsigned char* buffer)
 {
   return (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];
80004b0c:	0d b2       	ld.ub	r2,r6[0x3]
80004b0e:	0d 81       	ld.ub	r1,r6[0x0]
80004b10:	0d 93       	ld.ub	r3,r6[0x1]
80004b12:	0d a4       	ld.ub	r4,r6[0x2]
 static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len)
 {
    unsigned s1 = adler & 0xffff;
    unsigned s2 = (adler >> 16) & 0xffff;
 
   while(len > 0)
80004b14:	58 09       	cp.w	r9,0
80004b16:	c4 40       	breq	80004b9e <LodeZlib_decompress+0x296>
80004b18:	30 19       	mov	r9,1
   {
     /*at least 5550 sums can be done before the sums overflow, saving us from a lot of module divisions*/
     unsigned amount = len > 5550 ? 5550 : len;
80004b1a:	e0 65 15 ae 	mov	r5,5550
     {
       s1 = (s1 + *data++);
       s2 = (s2 + s1);
       amount--;
     }
     s1 %= 65521;
80004b1e:	e0 66 80 71 	mov	r6,32881
80004b22:	ea 16 80 07 	orh	r6,0x8007
80004b26:	50 31       	stdsp	sp[0xc],r1
    unsigned s2 = (adler >> 16) & 0xffff;
 
   while(len > 0)
   {
     /*at least 5550 sums can be done before the sums overflow, saving us from a lot of module divisions*/
     unsigned amount = len > 5550 ? 5550 : len;
80004b28:	e0 47 15 ae 	cp.w	r7,5550
80004b2c:	ee 0c 17 80 	movls	r12,r7
80004b30:	ea 0c 17 b0 	movhi	r12,r5
     len -= amount;
80004b34:	18 17       	sub	r7,r12
     while(amount > 0)
80004b36:	58 0c       	cp.w	r12,0
80004b38:	c0 a0       	breq	80004b4c <LodeZlib_decompress+0x244>
80004b3a:	30 08       	mov	r8,0
     {
       s1 = (s1 + *data++);
80004b3c:	fc 08 07 0b 	ld.ub	r11,lr[r8]
       s2 = (s2 + s1);
80004b40:	2f f8       	sub	r8,-1
     /*at least 5550 sums can be done before the sums overflow, saving us from a lot of module divisions*/
     unsigned amount = len > 5550 ? 5550 : len;
     len -= amount;
     while(amount > 0)
     {
       s1 = (s1 + *data++);
80004b42:	16 09       	add	r9,r11
       s2 = (s2 + s1);
80004b44:	12 0a       	add	r10,r9
   while(len > 0)
   {
     /*at least 5550 sums can be done before the sums overflow, saving us from a lot of module divisions*/
     unsigned amount = len > 5550 ? 5550 : len;
     len -= amount;
     while(amount > 0)
80004b46:	10 3c       	cp.w	r12,r8
80004b48:	cf a1       	brne	80004b3c <LodeZlib_decompress+0x234>
80004b4a:	18 0e       	add	lr,r12
     {
       s1 = (s1 + *data++);
       s2 = (s2 + s1);
       amount--;
     }
     s1 %= 65521;
80004b4c:	f2 06 06 40 	mulu.d	r0,r9,r6
80004b50:	fa e1 00 04 	st.d	sp[4],r0
     s2 %= 65521;
80004b54:	f4 06 06 40 	mulu.d	r0,r10,r6
     {
       s1 = (s1 + *data++);
       s2 = (s2 + s1);
       amount--;
     }
     s1 %= 65521;
80004b58:	40 1b       	lddsp	r11,sp[0x4]
     s2 %= 65521;
80004b5a:	fa e1 00 04 	st.d	sp[4],r0
     {
       s1 = (s1 + *data++);
       s2 = (s2 + s1);
       amount--;
     }
     s1 %= 65521;
80004b5e:	af 9b       	lsr	r11,0xf
80004b60:	f6 0c 15 0c 	lsl	r12,r11,0xc
80004b64:	16 1c       	sub	r12,r11
80004b66:	a5 6c       	lsl	r12,0x4
80004b68:	f8 0b 00 0b 	add	r11,r12,r11
     s2 %= 65521;
80004b6c:	40 18       	lddsp	r8,sp[0x4]
     {
       s1 = (s1 + *data++);
       s2 = (s2 + s1);
       amount--;
     }
     s1 %= 65521;
80004b6e:	16 19       	sub	r9,r11
     s2 %= 65521;
80004b70:	af 98       	lsr	r8,0xf
80004b72:	f0 0b 15 0c 	lsl	r11,r8,0xc
80004b76:	10 1b       	sub	r11,r8
80004b78:	a5 6b       	lsl	r11,0x4
80004b7a:	f6 08 00 08 	add	r8,r11,r8
80004b7e:	10 1a       	sub	r10,r8
 static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len)
 {
    unsigned s1 = adler & 0xffff;
    unsigned s2 = (adler >> 16) & 0xffff;
 
   while(len > 0)
80004b80:	58 07       	cp.w	r7,0
80004b82:	cd 31       	brne	80004b28 <LodeZlib_decompress+0x220>
80004b84:	40 31       	lddsp	r1,sp[0xc]
80004b86:	f3 ea 11 09 	or	r9,r9,r10<<0x10
 
   if(!settings->ignoreAdler32)
   {
     unsigned ADLER32 = LodeZlib_read32bitInt(&in[insize - 4]);
     unsigned checksum = adler32(outv.data, (unsigned)outv.size);
     if(checksum != ADLER32) { error = 58; return error; }
80004b8a:	e5 e1 11 82 	or	r2,r2,r1<<0x18
80004b8e:	e5 e3 11 03 	or	r3,r2,r3<<0x10
80004b92:	e7 e4 10 84 	or	r4,r3,r4<<0x8
80004b96:	12 34       	cp.w	r4,r9
80004b98:	c0 50       	breq	80004ba2 <LodeZlib_decompress+0x29a>
80004b9a:	33 ac       	mov	r12,58
80004b9c:	ce 4a       	rjmp	80004964 <LodeZlib_decompress+0x5c>
 static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len)
 {
    unsigned s1 = adler & 0xffff;
    unsigned s2 = (adler >> 16) & 0xffff;
 
   while(len > 0)
80004b9e:	30 19       	mov	r9,1
80004ba0:	cf 5b       	rjmp	80004b8a <LodeZlib_decompress+0x282>
 
   if(!settings->ignoreAdler32)
   {
     unsigned ADLER32 = LodeZlib_read32bitInt(&in[insize - 4]);
     unsigned checksum = adler32(outv.data, (unsigned)outv.size);
     if(checksum != ADLER32) { error = 58; return error; }
80004ba2:	30 0c       	mov	r12,0
80004ba4:	ce 0a       	rjmp	80004964 <LodeZlib_decompress+0x5c>
80004ba6:	d7 03       	nop

80004ba8 <LodePNG_inspect>:
80004ba8:	d4 31       	pushm	r0-r7,lr
80004baa:	20 2d       	sub	sp,8
80004bac:	58 0b       	cp.w	r11,0
80004bae:	5f 08       	sreq	r8
 /* ////////////////////////////////////////////////////////////////////////// */
 
 /*read the information from the header and store it in the LodePNG_Info. return value is error*/
 void LodePNG_inspect(LodePNG_Decoder* decoder, const unsigned char* in, size_t inlength)
 {
   if(inlength == 0 || in == 0) { decoder->error = 48; return; } /*the given data is empty*/
80004bb0:	58 0a       	cp.w	r10,0
80004bb2:	5f 09       	sreq	r9
 /* / PNG Decoder                                                            / */
 /* ////////////////////////////////////////////////////////////////////////// */
 
 /*read the information from the header and store it in the LodePNG_Info. return value is error*/
 void LodePNG_inspect(LodePNG_Decoder* decoder, const unsigned char* in, size_t inlength)
 {
80004bb4:	18 97       	mov	r7,r12
   if(inlength == 0 || in == 0) { decoder->error = 48; return; } /*the given data is empty*/
80004bb6:	f3 e8 10 08 	or	r8,r9,r8
80004bba:	c5 c1       	brne	80004c72 <LodePNG_inspect+0xca>
   if(inlength < 29) { decoder->error = 27; return; } /*error: the data length is smaller than the length of the header*/
80004bbc:	59 ca       	cp.w	r10,28
80004bbe:	e0 8b 00 07 	brhi	80004bcc <LodePNG_inspect+0x24>
80004bc2:	31 b8       	mov	r8,27
80004bc4:	f9 48 00 d0 	st.w	r12[208],r8
   if(decoder->infoPng.compressionMethod != 0) { decoder->error = 32; return; } /*error: only compression method 0 is allowed in the specification*/
   if(decoder->infoPng.filterMethod != 0)      { decoder->error = 33; return; } /*error: only filter method 0 is allowed in the specification*/
   if(decoder->infoPng.interlaceMethod > 1)    { decoder->error = 34; return; } /*error: only interlace methods 0 and 1 exist in the specification*/
 
   decoder->error = checkColorValidity(decoder->infoPng.color.colorType, decoder->infoPng.color.bitDepth);
 }
80004bc8:	2f ed       	sub	sp,-8
80004bca:	d8 32       	popm	r0-r7,pc
 {
   if(inlength == 0 || in == 0) { decoder->error = 48; return; } /*the given data is empty*/
   if(inlength < 29) { decoder->error = 27; return; } /*error: the data length is smaller than the length of the header*/
 
   /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/
   LodePNG_InfoPng_cleanup(&decoder->infoPng);
80004bcc:	50 0b       	stdsp	sp[0x0],r11
80004bce:	2c cc       	sub	r12,-52
80004bd0:	fe b0 f8 3e 	rcall	80003c4c <LodePNG_InfoPng_cleanup>
 
 void LodePNG_InfoColor_init(LodePNG_InfoColor* info)
 {
   info->key_defined = 0;
   info->key_r = info->key_g = info->key_b = 0;
   info->colorType = 6;
80004bd4:	30 69       	mov	r9,6
 
 #endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
 
 void LodePNG_InfoPng_init(LodePNG_InfoPng* info)
 {
   info->width = info->height = 0;
80004bd6:	30 08       	mov	r8,0
 
 void LodePNG_InfoColor_init(LodePNG_InfoColor* info)
 {
   info->key_defined = 0;
   info->key_r = info->key_g = info->key_b = 0;
   info->colorType = 6;
80004bd8:	ef 49 00 48 	st.w	r7[72],r9
 
 #endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
 
 void LodePNG_InfoPng_init(LodePNG_InfoPng* info)
 {
   info->width = info->height = 0;
80004bdc:	8f e8       	st.w	r7[0x38],r8
80004bde:	8f d8       	st.w	r7[0x34],r8
 
 /* ////////////////////////////////////////////////////////////////////////// */
 
 void LodePNG_InfoColor_init(LodePNG_InfoColor* info)
 {
   info->key_defined = 0;
80004be0:	ef 48 00 58 	st.w	r7[88],r8
   info->key_r = info->key_g = info->key_b = 0;
80004be4:	ef 48 00 64 	st.w	r7[100],r8
80004be8:	ef 48 00 60 	st.w	r7[96],r8
80004bec:	ef 48 00 5c 	st.w	r7[92],r8
   info->colorType = 6;
   info->bitDepth = 8;
   info->palette = 0;
80004bf0:	ef 48 00 50 	st.w	r7[80],r8
   info->palettesize = 0;
80004bf4:	ef 48 00 54 	st.w	r7[84],r8
 
 void LodePNG_InfoPng_init(LodePNG_InfoPng* info)
 {
   info->width = info->height = 0;
   LodePNG_InfoColor_init(&info->color);
   info->interlaceMethod = 0;
80004bf8:	ef 48 00 44 	st.w	r7[68],r8
   info->compressionMethod = 0;
80004bfc:	8f f8       	st.w	r7[0x3c],r8
   info->filterMethod = 0;
80004bfe:	ef 48 00 40 	st.w	r7[64],r8
 #ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
   info->background_defined = 0;
80004c02:	ef 48 00 68 	st.w	r7[104],r8
   info->background_r = info->background_g = info->background_b = 0;
80004c06:	ef 48 00 74 	st.w	r7[116],r8
80004c0a:	ef 48 00 70 	st.w	r7[112],r8
80004c0e:	ef 48 00 6c 	st.w	r7[108],r8
 
 #ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
 
 void LodePNG_Text_init(LodePNG_Text* text)
 {
   text->num = 0;
80004c12:	ef 48 00 78 	st.w	r7[120],r8
   text->keys = NULL;
80004c16:	ef 48 00 7c 	st.w	r7[124],r8
   text->strings = NULL;
80004c1a:	ef 48 00 80 	st.w	r7[128],r8
 
 /******************************************************************************/
 
 void LodePNG_IText_init(LodePNG_IText* text)
 {
   text->num = 0;
80004c1e:	ef 48 00 84 	st.w	r7[132],r8
   text->keys = NULL;
80004c22:	ef 48 00 88 	st.w	r7[136],r8
   text->langtags = NULL;
80004c26:	ef 48 00 8c 	st.w	r7[140],r8
   text->transkeys = NULL;
80004c2a:	ef 48 00 90 	st.w	r7[144],r8
   text->strings = NULL;
80004c2e:	ef 48 00 94 	st.w	r7[148],r8
   info->background_r = info->background_g = info->background_b = 0;
 
   LodePNG_Text_init(&info->text);
   LodePNG_IText_init(&info->itext);
 
   info->time_defined = 0;
80004c32:	ef 68 00 98 	st.b	r7[152],r8
   info->phys_defined = 0;
80004c36:	ef 48 00 a8 	st.w	r7[168],r8
 #ifdef LODEPNG_COMPILE_UNKNOWN_CHUNKS
 
 void LodePNG_UnknownChunks_init(LodePNG_UnknownChunks* chunks)
 {
   unsigned i;
   for(i = 0; i < 3; i++) chunks->data[i] = 0;
80004c3a:	ef 48 00 b8 	st.w	r7[184],r8
80004c3e:	ef 48 00 bc 	st.w	r7[188],r8
80004c42:	ef 48 00 c0 	st.w	r7[192],r8
   for(i = 0; i < 3; i++) chunks->datasize[i] = 0;
80004c46:	ef 48 00 c4 	st.w	r7[196],r8
80004c4a:	ef 48 00 c8 	st.w	r7[200],r8
80004c4e:	ef 48 00 cc 	st.w	r7[204],r8
 void LodePNG_InfoColor_init(LodePNG_InfoColor* info)
 {
   info->key_defined = 0;
   info->key_r = info->key_g = info->key_b = 0;
   info->colorType = 6;
   info->bitDepth = 8;
80004c52:	30 89       	mov	r9,8
80004c54:	ef 49 00 4c 	st.w	r7[76],r9
   if(inlength < 29) { decoder->error = 27; return; } /*error: the data length is smaller than the length of the header*/
 
   /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/
   LodePNG_InfoPng_cleanup(&decoder->infoPng);
   LodePNG_InfoPng_init(&decoder->infoPng);
   decoder->error = 0;
80004c58:	ef 48 00 d0 	st.w	r7[208],r8
 
   if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71 || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10) { decoder->error = 28; return; } /*error: the first 8 bytes are not the correct PNG signature*/
80004c5c:	40 0b       	lddsp	r11,sp[0x0]
80004c5e:	38 98       	mov	r8,-119
80004c60:	17 89       	ld.ub	r9,r11[0x0]
80004c62:	f0 09 18 00 	cp.b	r9,r8
80004c66:	c0 b0       	breq	80004c7c <LodePNG_inspect+0xd4>
80004c68:	31 c8       	mov	r8,28
80004c6a:	ef 48 00 d0 	st.w	r7[208],r8
   if(decoder->infoPng.compressionMethod != 0) { decoder->error = 32; return; } /*error: only compression method 0 is allowed in the specification*/
   if(decoder->infoPng.filterMethod != 0)      { decoder->error = 33; return; } /*error: only filter method 0 is allowed in the specification*/
   if(decoder->infoPng.interlaceMethod > 1)    { decoder->error = 34; return; } /*error: only interlace methods 0 and 1 exist in the specification*/
 
   decoder->error = checkColorValidity(decoder->infoPng.color.colorType, decoder->infoPng.color.bitDepth);
 }
80004c6e:	2f ed       	sub	sp,-8
80004c70:	d8 32       	popm	r0-r7,pc
 /* ////////////////////////////////////////////////////////////////////////// */
 
 /*read the information from the header and store it in the LodePNG_Info. return value is error*/
 void LodePNG_inspect(LodePNG_Decoder* decoder, const unsigned char* in, size_t inlength)
 {
   if(inlength == 0 || in == 0) { decoder->error = 48; return; } /*the given data is empty*/
80004c72:	33 08       	mov	r8,48
80004c74:	f9 48 00 d0 	st.w	r12[208],r8
   if(decoder->infoPng.compressionMethod != 0) { decoder->error = 32; return; } /*error: only compression method 0 is allowed in the specification*/
   if(decoder->infoPng.filterMethod != 0)      { decoder->error = 33; return; } /*error: only filter method 0 is allowed in the specification*/
   if(decoder->infoPng.interlaceMethod > 1)    { decoder->error = 34; return; } /*error: only interlace methods 0 and 1 exist in the specification*/
 
   decoder->error = checkColorValidity(decoder->infoPng.color.colorType, decoder->infoPng.color.bitDepth);
 }
80004c78:	2f ed       	sub	sp,-8
80004c7a:	d8 32       	popm	r0-r7,pc
   /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/
   LodePNG_InfoPng_cleanup(&decoder->infoPng);
   LodePNG_InfoPng_init(&decoder->infoPng);
   decoder->error = 0;
 
   if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71 || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10) { decoder->error = 28; return; } /*error: the first 8 bytes are not the correct PNG signature*/
80004c7c:	17 99       	ld.ub	r9,r11[0x1]
80004c7e:	35 08       	mov	r8,80
80004c80:	f0 09 18 00 	cp.b	r9,r8
80004c84:	cf 21       	brne	80004c68 <LodePNG_inspect+0xc0>
80004c86:	17 a9       	ld.ub	r9,r11[0x2]
80004c88:	34 e8       	mov	r8,78
80004c8a:	f0 09 18 00 	cp.b	r9,r8
80004c8e:	ce d1       	brne	80004c68 <LodePNG_inspect+0xc0>
80004c90:	17 b9       	ld.ub	r9,r11[0x3]
80004c92:	34 78       	mov	r8,71
80004c94:	f0 09 18 00 	cp.b	r9,r8
80004c98:	ce 81       	brne	80004c68 <LodePNG_inspect+0xc0>
80004c9a:	17 c9       	ld.ub	r9,r11[0x4]
80004c9c:	30 d8       	mov	r8,13
80004c9e:	f0 09 18 00 	cp.b	r9,r8
80004ca2:	ce 31       	brne	80004c68 <LodePNG_inspect+0xc0>
80004ca4:	17 d8       	ld.ub	r8,r11[0x5]
80004ca6:	30 a9       	mov	r9,10
80004ca8:	f2 08 18 00 	cp.b	r8,r9
80004cac:	cd e1       	brne	80004c68 <LodePNG_inspect+0xc0>
80004cae:	17 ea       	ld.ub	r10,r11[0x6]
80004cb0:	31 a9       	mov	r9,26
80004cb2:	f2 0a 18 00 	cp.b	r10,r9
80004cb6:	cd 91       	brne	80004c68 <LodePNG_inspect+0xc0>
80004cb8:	17 f9       	ld.ub	r9,r11[0x7]
80004cba:	f0 09 18 00 	cp.b	r9,r8
80004cbe:	cd 51       	brne	80004c68 <LodePNG_inspect+0xc0>
   if(in[12] != 'I' || in[13] != 'H' || in[14] != 'D' || in[15] != 'R') { decoder->error = 29; return; } /*error: it doesn't start with a IHDR chunk!*/
80004cc0:	f6 cc ff f4 	sub	r12,r11,-12
80004cc4:	34 98       	mov	r8,73
80004cc6:	19 89       	ld.ub	r9,r12[0x0]
80004cc8:	f0 09 18 00 	cp.b	r9,r8
80004ccc:	c0 50       	breq	80004cd6 <LodePNG_inspect+0x12e>
80004cce:	31 d8       	mov	r8,29
80004cd0:	ef 48 00 d0 	st.w	r7[208],r8
80004cd4:	c7 ab       	rjmp	80004bc8 <LodePNG_inspect+0x20>
80004cd6:	f7 39 00 0d 	ld.ub	r9,r11[13]
80004cda:	34 88       	mov	r8,72
80004cdc:	f0 09 18 00 	cp.b	r9,r8
80004ce0:	cf 71       	brne	80004cce <LodePNG_inspect+0x126>
80004ce2:	f7 39 00 0e 	ld.ub	r9,r11[14]
80004ce6:	34 48       	mov	r8,68
80004ce8:	f0 09 18 00 	cp.b	r9,r8
80004cec:	cf 11       	brne	80004cce <LodePNG_inspect+0x126>
80004cee:	f7 39 00 0f 	ld.ub	r9,r11[15]
80004cf2:	35 28       	mov	r8,82
80004cf4:	f0 09 18 00 	cp.b	r9,r8
80004cf8:	ce b1       	brne	80004cce <LodePNG_inspect+0x126>
 
   /*read the values given in the header*/
   decoder->infoPng.width = LodePNG_read32bitInt(&in[16]);
80004cfa:	f6 c8 ff f0 	sub	r8,r11,-16
80004cfe:	11 a9       	ld.ub	r9,r8[0x2]
80004d00:	11 8e       	ld.ub	lr,r8[0x0]
80004d02:	11 ba       	ld.ub	r10,r8[0x3]
80004d04:	11 98       	ld.ub	r8,r8[0x1]
80004d06:	f5 ee 11 8a 	or	r10,r10,lr<<0x18
80004d0a:	f5 e8 11 08 	or	r8,r10,r8<<0x10
80004d0e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80004d12:	8f d8       	st.w	r7[0x34],r8
   decoder->infoPng.height = LodePNG_read32bitInt(&in[20]);
80004d14:	f6 c8 ff ec 	sub	r8,r11,-20
80004d18:	11 a9       	ld.ub	r9,r8[0x2]
80004d1a:	11 ba       	ld.ub	r10,r8[0x3]
80004d1c:	11 8e       	ld.ub	lr,r8[0x0]
80004d1e:	11 98       	ld.ub	r8,r8[0x1]
80004d20:	f5 ee 11 8a 	or	r10,r10,lr<<0x18
80004d24:	f5 e8 11 08 	or	r8,r10,r8<<0x10
80004d28:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80004d2c:	8f e8       	st.w	r7[0x38],r8
   decoder->infoPng.color.bitDepth = in[24];
80004d2e:	f7 38 00 18 	ld.ub	r8,r11[24]
80004d32:	ef 48 00 4c 	st.w	r7[76],r8
   decoder->infoPng.color.colorType = in[25];
80004d36:	f7 38 00 19 	ld.ub	r8,r11[25]
80004d3a:	ef 48 00 48 	st.w	r7[72],r8
   decoder->infoPng.compressionMethod = in[26];
80004d3e:	f7 39 00 1a 	ld.ub	r9,r11[26]
80004d42:	8f f9       	st.w	r7[0x3c],r9
   decoder->infoPng.filterMethod = in[27];
80004d44:	f7 38 00 1b 	ld.ub	r8,r11[27]
80004d48:	ef 48 00 40 	st.w	r7[64],r8
   decoder->infoPng.interlaceMethod = in[28];
80004d4c:	f7 38 00 1c 	ld.ub	r8,r11[28]
80004d50:	ef 48 00 44 	st.w	r7[68],r8
 
   if(!decoder->settings.ignoreCrc)
80004d54:	6e 18       	ld.w	r8,r7[0x4]
80004d56:	58 08       	cp.w	r8,0
80004d58:	c0 e0       	breq	80004d74 <LodePNG_inspect+0x1cc>
     unsigned CRC = LodePNG_read32bitInt(&in[29]);
     unsigned checksum = Crc32_crc(&in[12], 17);
     if(CRC != checksum) { decoder->error = 57; return; }
   }
 
   if(decoder->infoPng.compressionMethod != 0) { decoder->error = 32; return; } /*error: only compression method 0 is allowed in the specification*/
80004d5a:	58 09       	cp.w	r9,0
80004d5c:	c6 41       	brne	80004e24 <LodePNG_inspect+0x27c>
   if(decoder->infoPng.filterMethod != 0)      { decoder->error = 33; return; } /*error: only filter method 0 is allowed in the specification*/
80004d5e:	6f 08       	ld.w	r8,r7[0x40]
80004d60:	58 08       	cp.w	r8,0
80004d62:	c5 d1       	brne	80004e1c <LodePNG_inspect+0x274>
   if(decoder->infoPng.interlaceMethod > 1)    { decoder->error = 34; return; } /*error: only interlace methods 0 and 1 exist in the specification*/
80004d64:	6f 18       	ld.w	r8,r7[0x44]
80004d66:	58 18       	cp.w	r8,1
80004d68:	e0 88 00 2c 	brls	80004dc0 <LodePNG_inspect+0x218>
80004d6c:	32 28       	mov	r8,34
80004d6e:	ef 48 00 d0 	st.w	r7[208],r8
80004d72:	c2 bb       	rjmp	80004bc8 <LodePNG_inspect+0x20>
   decoder->infoPng.filterMethod = in[27];
   decoder->infoPng.interlaceMethod = in[28];
 
   if(!decoder->settings.ignoreCrc)
   {
     unsigned CRC = LodePNG_read32bitInt(&in[29]);
80004d74:	f6 c8 ff e3 	sub	r8,r11,-29
   (*bitpointer)++;
 }
 
 static unsigned LodePNG_read32bitInt(const unsigned char* buffer)
 {
   return (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];
80004d78:	11 82       	ld.ub	r2,r8[0x0]
80004d7a:	11 94       	ld.ub	r4,r8[0x1]
80004d7c:	11 a9       	ld.ub	r9,r8[0x2]
80004d7e:	50 19       	stdsp	sp[0x4],r9
 static unsigned Crc32_update_crc(const unsigned char* buf, unsigned crc, size_t len)
 {
   unsigned c = crc;
   size_t n;
 
   if(!Crc32_crc_table_computed) Crc32_make_crc_table();
80004d80:	e0 6e 05 60 	mov	lr,1376
80004d84:	11 b3       	ld.ub	r3,r8[0x3]
80004d86:	7c 0a       	ld.w	r10,lr[0x0]
80004d88:	58 0a       	cp.w	r10,0
80004d8a:	c2 90       	breq	80004ddc <LodePNG_inspect+0x234>
 /* ////////////////////////////////////////////////////////////////////////// */
 /* / PNG Decoder                                                            / */
 /* ////////////////////////////////////////////////////////////////////////// */
 
 /*read the information from the header and store it in the LodePNG_Info. return value is error*/
 void LodePNG_inspect(LodePNG_Decoder* decoder, const unsigned char* in, size_t inlength)
80004d8c:	e0 69 05 64 	mov	r9,1380
   size_t n;
 
   if(!Crc32_crc_table_computed) Crc32_make_crc_table();
   for(n = 0; n < len; n++)
   {
     c = Crc32_crc_table[(c ^ buf[n]) & 0xff] ^ (c >> 8);
80004d90:	3f fa       	mov	r10,-1
80004d92:	19 3b       	ld.ub	r11,r12++
80004d94:	f5 eb 20 0b 	eor	r11,r10,r11
80004d98:	f2 0b 0f 8b 	ld.w	r11,r9[r11:b<<2]
 {
   unsigned c = crc;
   size_t n;
 
   if(!Crc32_crc_table_computed) Crc32_make_crc_table();
   for(n = 0; n < len; n++)
80004d9c:	f7 ea 22 8a 	eor	r10,r11,r10>>0x8
 
   if(!decoder->settings.ignoreCrc)
   {
     unsigned CRC = LodePNG_read32bitInt(&in[29]);
     unsigned checksum = Crc32_crc(&in[12], 17);
     if(CRC != checksum) { decoder->error = 57; return; }
80004da0:	10 3c       	cp.w	r12,r8
80004da2:	cf 81       	brne	80004d92 <LodePNG_inspect+0x1ea>
80004da4:	e7 e2 11 88 	or	r8,r3,r2<<0x18
80004da8:	40 19       	lddsp	r9,sp[0x4]
80004daa:	f1 e4 11 08 	or	r8,r8,r4<<0x10
80004dae:	5c da       	com	r10
80004db0:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80004db4:	14 38       	cp.w	r8,r10
80004db6:	c3 10       	breq	80004e18 <LodePNG_inspect+0x270>
80004db8:	33 98       	mov	r8,57
80004dba:	ef 48 00 d0 	st.w	r7[208],r8
 /* ////////////////////////////////////////////////////////////////////////// */
 
 /*return type is a LodePNG error code*/
 static unsigned checkColorValidity(unsigned colorType, unsigned bd) /*bd = bitDepth*/
 {
   switch(colorType)
80004dbe:	c0 5b       	rjmp	80004bc8 <LodePNG_inspect+0x20>
80004dc0:	6f 38       	ld.w	r8,r7[0x4c]
80004dc2:	6f 2a       	ld.w	r10,r7[0x48]
80004dc4:	58 3a       	cp.w	r10,3
80004dc6:	c5 10       	breq	80004e68 <LodePNG_inspect+0x2c0>
80004dc8:	e0 8b 00 35 	brhi	80004e32 <LodePNG_inspect+0x28a>
80004dcc:	58 0a       	cp.w	r10,0
80004dce:	c4 00       	breq	80004e4e <LodePNG_inspect+0x2a6>
80004dd0:	58 2a       	cp.w	r10,2
 
   if(decoder->infoPng.compressionMethod != 0) { decoder->error = 32; return; } /*error: only compression method 0 is allowed in the specification*/
   if(decoder->infoPng.filterMethod != 0)      { decoder->error = 33; return; } /*error: only filter method 0 is allowed in the specification*/
   if(decoder->infoPng.interlaceMethod > 1)    { decoder->error = 34; return; } /*error: only interlace methods 0 and 1 exist in the specification*/
 
   decoder->error = checkColorValidity(decoder->infoPng.color.colorType, decoder->infoPng.color.bitDepth);
80004dd2:	c3 40       	breq	80004e3a <LodePNG_inspect+0x292>
80004dd4:	31 f8       	mov	r8,31
80004dd6:	ef 48 00 d0 	st.w	r7[208],r8
 static unsigned Crc32_update_crc(const unsigned char* buf, unsigned crc, size_t len)
 {
   unsigned c = crc;
   size_t n;
 
   if(!Crc32_crc_table_computed) Crc32_make_crc_table();
80004dda:	cf 7a       	rjmp	80004bc8 <LodePNG_inspect+0x20>
80004ddc:	e0 69 05 64 	mov	r9,1380
   for(n = 0; n < 256; n++)
   {
     c = n;
     for(k = 0; k < 8; k++)
     {
       if(c & 1) c = 0xedb88320L ^ (c >> 1);
80004de0:	14 90       	mov	r0,r10
80004de2:	12 96       	mov	r6,r9
80004de4:	30 0b       	mov	r11,0
80004de6:	e0 05 16 01 	lsr	r5,r0,0x1
80004dea:	2f fb       	sub	r11,-1
80004dec:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
80004df0:	0a 91       	mov	r1,r5
80004df2:	ee 11 ed b8 	eorh	r1,0xedb8
80004df6:	ec 11 83 20 	eorl	r1,0x8320
80004dfa:	58 00       	cp.w	r0,0
80004dfc:	ea 00 17 00 	moveq	r0,r5
 {
   unsigned c, k, n;
   for(n = 0; n < 256; n++)
   {
     c = n;
     for(k = 0; k < 8; k++)
80004e00:	e2 00 17 10 	movne	r0,r1
 
 /*Make the table for a fast CRC.*/
 static void Crc32_make_crc_table(void)
 {
   unsigned c, k, n;
   for(n = 0; n < 256; n++)
80004e04:	58 8b       	cp.w	r11,8
80004e06:	cf 01       	brne	80004de6 <LodePNG_inspect+0x23e>
80004e08:	0c a0       	st.w	r6++,r0
80004e0a:	f4 c0 ff ff 	sub	r0,r10,-1
80004e0e:	e0 40 01 00 	cp.w	r0,256
 
   if(!decoder->settings.ignoreCrc)
   {
     unsigned CRC = LodePNG_read32bitInt(&in[29]);
     unsigned checksum = Crc32_crc(&in[12], 17);
     if(CRC != checksum) { decoder->error = 57; return; }
80004e12:	c0 d0       	breq	80004e2c <LodePNG_inspect+0x284>
80004e14:	00 9a       	mov	r10,r0
   }
 
   if(decoder->infoPng.compressionMethod != 0) { decoder->error = 32; return; } /*error: only compression method 0 is allowed in the specification*/
   if(decoder->infoPng.filterMethod != 0)      { decoder->error = 33; return; } /*error: only filter method 0 is allowed in the specification*/
80004e16:	ce 7b       	rjmp	80004de4 <LodePNG_inspect+0x23c>
80004e18:	6e f9       	ld.w	r9,r7[0x3c]
80004e1a:	ca 0b       	rjmp	80004d5a <LodePNG_inspect+0x1b2>
80004e1c:	32 18       	mov	r8,33
     unsigned CRC = LodePNG_read32bitInt(&in[29]);
     unsigned checksum = Crc32_crc(&in[12], 17);
     if(CRC != checksum) { decoder->error = 57; return; }
   }
 
   if(decoder->infoPng.compressionMethod != 0) { decoder->error = 32; return; } /*error: only compression method 0 is allowed in the specification*/
80004e1e:	ef 48 00 d0 	st.w	r7[208],r8
80004e22:	cd 3a       	rjmp	80004bc8 <LodePNG_inspect+0x20>
80004e24:	32 08       	mov	r8,32
       if(c & 1) c = 0xedb88320L ^ (c >> 1);
       else c = c >> 1;
     }
     Crc32_crc_table[n] = c;
   }
   Crc32_crc_table_computed = 1;
80004e26:	ef 48 00 d0 	st.w	r7[208],r8
80004e2a:	cc fa       	rjmp	80004bc8 <LodePNG_inspect+0x20>
 /* ////////////////////////////////////////////////////////////////////////// */
 
 /*return type is a LodePNG error code*/
 static unsigned checkColorValidity(unsigned colorType, unsigned bd) /*bd = bitDepth*/
 {
   switch(colorType)
80004e2c:	30 1a       	mov	r10,1
80004e2e:	9d 0a       	st.w	lr[0x0],r10
80004e30:	cb 0b       	rjmp	80004d90 <LodePNG_inspect+0x1e8>
80004e32:	58 4a       	cp.w	r10,4
   {
     case 0: if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break; /*grey*/
     case 2: if(!(                                 bd == 8 || bd == 16)) return 37; break; /*RGB*/
     case 3: if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break; /*palette*/
     case 4: if(!(                                 bd == 8 || bd == 16)) return 37; break; /*grey + alpha*/
     case 6: if(!(                                 bd == 8 || bd == 16)) return 37; break; /*RGBA*/
80004e34:	c0 30       	breq	80004e3a <LodePNG_inspect+0x292>
80004e36:	58 6a       	cp.w	r10,6
80004e38:	cc e1       	brne	80004dd4 <LodePNG_inspect+0x22c>
80004e3a:	58 88       	cp.w	r8,8
80004e3c:	5f 1a       	srne	r10
80004e3e:	59 08       	cp.w	r8,16
80004e40:	5f 18       	srne	r8
80004e42:	14 68       	and	r8,r10
80004e44:	f2 08 18 00 	cp.b	r8,r9
 /*return type is a LodePNG error code*/
 static unsigned checkColorValidity(unsigned colorType, unsigned bd) /*bd = bitDepth*/
 {
   switch(colorType)
   {
     case 0: if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break; /*grey*/
80004e48:	c0 e0       	breq	80004e64 <LodePNG_inspect+0x2bc>
80004e4a:	32 58       	mov	r8,37
80004e4c:	cc 5b       	rjmp	80004dd6 <LodePNG_inspect+0x22e>
80004e4e:	58 48       	cp.w	r8,4
80004e50:	5f 1a       	srne	r10
80004e52:	f0 cb 00 01 	sub	r11,r8,1
80004e56:	58 1b       	cp.w	r11,1
80004e58:	5f bb       	srhi	r11
80004e5a:	f7 ea 00 0a 	and	r10,r11,r10
     case 2: if(!(                                 bd == 8 || bd == 16)) return 37; break; /*RGB*/
     case 3: if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break; /*palette*/
     case 4: if(!(                                 bd == 8 || bd == 16)) return 37; break; /*grey + alpha*/
     case 6: if(!(                                 bd == 8 || bd == 16)) return 37; break; /*RGBA*/
80004e5e:	f2 0a 18 00 	cp.b	r10,r9
 {
   switch(colorType)
   {
     case 0: if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break; /*grey*/
     case 2: if(!(                                 bd == 8 || bd == 16)) return 37; break; /*RGB*/
     case 3: if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break; /*palette*/
80004e62:	ce c1       	brne	80004e3a <LodePNG_inspect+0x292>
80004e64:	30 08       	mov	r8,0
80004e66:	cb 8b       	rjmp	80004dd6 <LodePNG_inspect+0x22e>
80004e68:	58 48       	cp.w	r8,4
80004e6a:	5f 1a       	srne	r10
80004e6c:	f0 cb 00 01 	sub	r11,r8,1
80004e70:	58 1b       	cp.w	r11,1
80004e72:	5f bb       	srhi	r11
80004e74:	f7 ea 00 0a 	and	r10,r11,r10
80004e78:	f2 0a 18 00 	cp.b	r10,r9
80004e7c:	cf 40       	breq	80004e64 <LodePNG_inspect+0x2bc>
80004e7e:	58 88       	cp.w	r8,8
80004e80:	ce 51       	brne	80004e4a <LodePNG_inspect+0x2a2>
80004e82:	cf 1b       	rjmp	80004e64 <LodePNG_inspect+0x2bc>

80004e84 <LodePNG_Text_add>:
80004e84:	eb cd 40 f8 	pushm	r3-r7,lr
80004e88:	18 97       	mov	r7,r12
80004e8a:	14 96       	mov	r6,r10
   free(text->keys);
   free(text->strings);
 }
 
 unsigned LodePNG_Text_add(LodePNG_Text* text, const char* key, const char* str)
 {
80004e8c:	16 95       	mov	r5,r11
   char** new_keys = (char**)(realloc(text->keys, sizeof(char*) * (text->num + 1)));
80004e8e:	78 0b       	ld.w	r11,r12[0x0]
80004e90:	78 1c       	ld.w	r12,r12[0x4]
80004e92:	2f fb       	sub	r11,-1
80004e94:	a3 6b       	lsl	r11,0x2
80004e96:	e0 a0 5b 01 	rcall	80010498 <realloc>
   char** new_strings = (char**)(realloc(text->strings, sizeof(char*) * (text->num + 1)));
80004e9a:	6e 0b       	ld.w	r11,r7[0x0]
   free(text->strings);
 }
 
 unsigned LodePNG_Text_add(LodePNG_Text* text, const char* key, const char* str)
 {
   char** new_keys = (char**)(realloc(text->keys, sizeof(char*) * (text->num + 1)));
80004e9c:	18 94       	mov	r4,r12
   char** new_strings = (char**)(realloc(text->strings, sizeof(char*) * (text->num + 1)));
80004e9e:	2f fb       	sub	r11,-1
80004ea0:	6e 2c       	ld.w	r12,r7[0x8]
80004ea2:	a3 6b       	lsl	r11,0x2
80004ea4:	e0 a0 5a fa 	rcall	80010498 <realloc>
   if(!new_keys || !new_strings)
80004ea8:	58 04       	cp.w	r4,0
80004eaa:	5f 08       	sreq	r8
80004eac:	58 0c       	cp.w	r12,0
80004eae:	5f 09       	sreq	r9
 }
 
 unsigned LodePNG_Text_add(LodePNG_Text* text, const char* key, const char* str)
 {
   char** new_keys = (char**)(realloc(text->keys, sizeof(char*) * (text->num + 1)));
   char** new_strings = (char**)(realloc(text->strings, sizeof(char*) * (text->num + 1)));
80004eb0:	18 93       	mov	r3,r12
   if(!new_keys || !new_strings)
80004eb2:	f3 e8 10 08 	or	r8,r9,r8
80004eb6:	c0 b0       	breq	80004ecc <LodePNG_Text_add+0x48>
   {
     free(new_keys);
80004eb8:	08 9c       	mov	r12,r4
80004eba:	e0 a0 58 19 	rcall	8000feec <free>
     free(new_strings);
80004ebe:	06 9c       	mov	r12,r3
80004ec0:	e0 a0 58 16 	rcall	8000feec <free>
80004ec4:	e0 6c 26 cd 	mov	r12,9933
     return 9933;
80004ec8:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
   }
 
   text->num++;
80004ecc:	6e 08       	ld.w	r8,r7[0x0]
   text->keys = new_keys;
   text->strings = new_strings;
80004ece:	8f 2c       	st.w	r7[0x8],r12
     free(new_keys);
     free(new_strings);
     return 9933;
   }
 
   text->num++;
80004ed0:	f0 c9 ff ff 	sub	r9,r8,-1
   text->keys = new_keys;
80004ed4:	8f 14       	st.w	r7[0x4],r4
     free(new_keys);
     free(new_strings);
     return 9933;
   }
 
   text->num++;
80004ed6:	8f 09       	st.w	r7[0x0],r9
   text->keys = new_keys;
   text->strings = new_strings;
 
   string_init(&text->keys[text->num - 1]);
80004ed8:	e8 08 00 24 	add	r4,r4,r8<<0x2
   return data != 0;
 }
 
 static void string_init(char** out) /*init a {char*, size_t} pair for use as string*/
 {
   *out = NULL;
80004edc:	30 03       	mov	r3,0
 
 #ifdef LODEPNG_COMPILE_PNG
 #ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
 static unsigned string_resize(char** out, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   char* data = (char*)realloc(*out, size + 1);
80004ede:	30 1b       	mov	r11,1
   return data != 0;
 }
 
 static void string_init(char** out) /*init a {char*, size_t} pair for use as string*/
 {
   *out = NULL;
80004ee0:	89 03       	st.w	r4[0x0],r3
 
 #ifdef LODEPNG_COMPILE_PNG
 #ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
 static unsigned string_resize(char** out, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   char* data = (char*)realloc(*out, size + 1);
80004ee2:	06 9c       	mov	r12,r3
80004ee4:	e0 a0 5a da 	rcall	80010498 <realloc>
   if(data)
   {
     data[size] = 0; /*null termination char*/
80004ee8:	f9 f3 1e 00 	st.bne	r12[0x0],r3
     *out = data;
80004eec:	e9 fc 1a 00 	st.wne	r4[0x0],r12
   text->num++;
   text->keys = new_keys;
   text->strings = new_strings;
 
   string_init(&text->keys[text->num - 1]);
   string_set(&text->keys[text->num - 1], key);
80004ef0:	6e 18       	ld.w	r8,r7[0x4]
80004ef2:	6e 03       	ld.w	r3,r7[0x0]
   *out = NULL;
 }
 
 static void string_set(char** out, const char* in)
 {
   size_t insize = strlen(in), i = 0;
80004ef4:	0a 9c       	mov	r12,r5
   text->num++;
   text->keys = new_keys;
   text->strings = new_strings;
 
   string_init(&text->keys[text->num - 1]);
   string_set(&text->keys[text->num - 1], key);
80004ef6:	20 13       	sub	r3,1
80004ef8:	f0 03 00 23 	add	r3,r8,r3<<0x2
   *out = NULL;
 }
 
 static void string_set(char** out, const char* in)
 {
   size_t insize = strlen(in), i = 0;
80004efc:	e0 a0 5c 64 	rcall	800107c4 <strlen>
80004f00:	18 94       	mov	r4,r12
 
 #ifdef LODEPNG_COMPILE_PNG
 #ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
 static unsigned string_resize(char** out, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   char* data = (char*)realloc(*out, size + 1);
80004f02:	66 0c       	ld.w	r12,r3[0x0]
80004f04:	e8 cb ff ff 	sub	r11,r4,-1
80004f08:	e0 a0 5a c8 	rcall	80010498 <realloc>
   if(data)
80004f0c:	c1 20       	breq	80004f30 <LodePNG_Text_add+0xac>
   {
     data[size] = 0; /*null termination char*/
80004f0e:	30 08       	mov	r8,0
80004f10:	f8 04 0b 08 	st.b	r12[r4],r8
     *out = data;
80004f14:	87 0c       	st.w	r3[0x0],r12
 }
 
 static void string_set(char** out, const char* in)
 {
   size_t insize = strlen(in), i = 0;
   if(string_resize(out, insize)) for(i = 0; i < insize; i++) (*out)[i] = in[i];
80004f16:	58 04       	cp.w	r4,0
80004f18:	c0 c0       	breq	80004f30 <LodePNG_Text_add+0xac>
80004f1a:	30 08       	mov	r8,0
80004f1c:	c0 28       	rjmp	80004f20 <LodePNG_Text_add+0x9c>
80004f1e:	66 0c       	ld.w	r12,r3[0x0]
80004f20:	ea 08 07 09 	ld.ub	r9,r5[r8]
80004f24:	f8 08 0b 09 	st.b	r12[r8],r9
80004f28:	2f f8       	sub	r8,-1
80004f2a:	10 34       	cp.w	r4,r8
80004f2c:	fe 9b ff f9 	brhi	80004f1e <LodePNG_Text_add+0x9a>
   text->strings = new_strings;
 
   string_init(&text->keys[text->num - 1]);
   string_set(&text->keys[text->num - 1], key);
 
   string_init(&text->strings[text->num - 1]);
80004f30:	6e 28       	ld.w	r8,r7[0x8]
80004f32:	6e 04       	ld.w	r4,r7[0x0]
   return data != 0;
 }
 
 static void string_init(char** out) /*init a {char*, size_t} pair for use as string*/
 {
   *out = NULL;
80004f34:	30 05       	mov	r5,0
 
 #ifdef LODEPNG_COMPILE_PNG
 #ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
 static unsigned string_resize(char** out, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   char* data = (char*)realloc(*out, size + 1);
80004f36:	30 1b       	mov	r11,1
80004f38:	0a 9c       	mov	r12,r5
   text->strings = new_strings;
 
   string_init(&text->keys[text->num - 1]);
   string_set(&text->keys[text->num - 1], key);
 
   string_init(&text->strings[text->num - 1]);
80004f3a:	20 14       	sub	r4,1
80004f3c:	f0 04 00 24 	add	r4,r8,r4<<0x2
   return data != 0;
 }
 
 static void string_init(char** out) /*init a {char*, size_t} pair for use as string*/
 {
   *out = NULL;
80004f40:	89 05       	st.w	r4[0x0],r5
 
 #ifdef LODEPNG_COMPILE_PNG
 #ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
 static unsigned string_resize(char** out, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   char* data = (char*)realloc(*out, size + 1);
80004f42:	e0 a0 5a ab 	rcall	80010498 <realloc>
   if(data)
   {
     data[size] = 0; /*null termination char*/
80004f46:	f9 f5 1e 00 	st.bne	r12[0x0],r5
     *out = data;
80004f4a:	e9 fc 1a 00 	st.wne	r4[0x0],r12
 
   string_init(&text->keys[text->num - 1]);
   string_set(&text->keys[text->num - 1], key);
 
   string_init(&text->strings[text->num - 1]);
   string_set(&text->strings[text->num - 1], str);
80004f4e:	6e 28       	ld.w	r8,r7[0x8]
80004f50:	6e 05       	ld.w	r5,r7[0x0]
   *out = NULL;
 }
 
 static void string_set(char** out, const char* in)
 {
   size_t insize = strlen(in), i = 0;
80004f52:	0c 9c       	mov	r12,r6
 
   string_init(&text->keys[text->num - 1]);
   string_set(&text->keys[text->num - 1], key);
 
   string_init(&text->strings[text->num - 1]);
   string_set(&text->strings[text->num - 1], str);
80004f54:	20 15       	sub	r5,1
80004f56:	f0 05 00 25 	add	r5,r8,r5<<0x2
   *out = NULL;
 }
 
 static void string_set(char** out, const char* in)
 {
   size_t insize = strlen(in), i = 0;
80004f5a:	e0 a0 5c 35 	rcall	800107c4 <strlen>
80004f5e:	18 97       	mov	r7,r12
 
 #ifdef LODEPNG_COMPILE_PNG
 #ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
 static unsigned string_resize(char** out, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   char* data = (char*)realloc(*out, size + 1);
80004f60:	6a 0c       	ld.w	r12,r5[0x0]
80004f62:	ee cb ff ff 	sub	r11,r7,-1
80004f66:	e0 a0 5a 99 	rcall	80010498 <realloc>
   if(data)
80004f6a:	c1 20       	breq	80004f8e <LodePNG_Text_add+0x10a>
   {
     data[size] = 0; /*null termination char*/
80004f6c:	30 08       	mov	r8,0
80004f6e:	f8 07 0b 08 	st.b	r12[r7],r8
     *out = data;
80004f72:	8b 0c       	st.w	r5[0x0],r12
 }
 
 static void string_set(char** out, const char* in)
 {
   size_t insize = strlen(in), i = 0;
   if(string_resize(out, insize)) for(i = 0; i < insize; i++) (*out)[i] = in[i];
80004f74:	58 07       	cp.w	r7,0
80004f76:	c0 c0       	breq	80004f8e <LodePNG_Text_add+0x10a>
80004f78:	30 08       	mov	r8,0
80004f7a:	c0 28       	rjmp	80004f7e <LodePNG_Text_add+0xfa>
80004f7c:	6a 0c       	ld.w	r12,r5[0x0]
80004f7e:	ec 08 07 09 	ld.ub	r9,r6[r8]
80004f82:	f8 08 0b 09 	st.b	r12[r8],r9
80004f86:	2f f8       	sub	r8,-1
80004f88:	10 37       	cp.w	r7,r8
80004f8a:	fe 9b ff f9 	brhi	80004f7c <LodePNG_Text_add+0xf8>
80004f8e:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80004f92:	d7 03       	nop

80004f94 <decodeGeneric>:
80004f94:	d4 31       	pushm	r0-r7,lr
80004f96:	fa cd 01 a0 	sub	sp,sp,416
80004f9a:	50 eb       	stdsp	sp[0x38],r11
80004f9c:	30 0b       	mov	r11,0
80004f9e:	40 ee       	lddsp	lr,sp[0x38]
   /*for unknown chunk order*/
   unsigned unknown = 0;
   unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/
 
   /*provide some proper output values if error will happen*/
   *out = 0;
80004fa0:	9d 0b       	st.w	lr[0x0],r11
   return error;
 }
 
 /*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
 static void decodeGeneric(LodePNG_Decoder* decoder, unsigned char** out, size_t* outsize, const unsigned char* in, size_t size)
 {
80004fa2:	50 fa       	stdsp	sp[0x3c],r10
   unsigned unknown = 0;
   unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/
 
   /*provide some proper output values if error will happen*/
   *out = 0;
   *outsize = 0;
80004fa4:	95 0b       	st.w	r10[0x0],r11
   return error;
 }
 
 /*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
 static void decodeGeneric(LodePNG_Decoder* decoder, unsigned char** out, size_t* outsize, const unsigned char* in, size_t size)
 {
80004fa6:	10 93       	mov	r3,r8
80004fa8:	12 95       	mov	r5,r9
 
   /*provide some proper output values if error will happen*/
   *out = 0;
   *outsize = 0;
 
   if(size == 0 || in == 0) { decoder->error = 48; return; } /*the given data is empty*/
80004faa:	58 09       	cp.w	r9,0
80004fac:	5f 08       	sreq	r8
80004fae:	58 03       	cp.w	r3,0
80004fb0:	5f 09       	sreq	r9
   return error;
 }
 
 /*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
 static void decodeGeneric(LodePNG_Decoder* decoder, unsigned char** out, size_t* outsize, const unsigned char* in, size_t size)
 {
80004fb2:	18 97       	mov	r7,r12
 
   /*provide some proper output values if error will happen*/
   *out = 0;
   *outsize = 0;
 
   if(size == 0 || in == 0) { decoder->error = 48; return; } /*the given data is empty*/
80004fb4:	f3 e8 10 08 	or	r8,r9,r8
80004fb8:	f6 08 18 00 	cp.b	r8,r11
80004fbc:	c0 60       	breq	80004fc8 <decodeGeneric+0x34>
80004fbe:	33 08       	mov	r8,48
80004fc0:	f9 48 00 d0 	st.w	r12[208],r8
     }
     ucvector_cleanup(&scanlines);
   }
 
   ucvector_cleanup(&idat);
 }
80004fc4:	29 8d       	sub	sp,-416
80004fc6:	d8 32       	popm	r0-r7,pc
   *out = 0;
   *outsize = 0;
 
   if(size == 0 || in == 0) { decoder->error = 48; return; } /*the given data is empty*/
 
   LodePNG_inspect(decoder, in, size); /*reads header and resets other parameters in decoder->infoPng*/
80004fc8:	06 9a       	mov	r10,r3
80004fca:	0a 9b       	mov	r11,r5
80004fcc:	fe b0 fd ee 	rcall	80004ba8 <LodePNG_inspect>
   if(decoder->error) return;
80004fd0:	ee f8 00 d0 	ld.w	r8,r7[208]
80004fd4:	58 08       	cp.w	r8,0
80004fd6:	cf 71       	brne	80004fc4 <decodeGeneric+0x30>
           str = (char*)malloc(length + 1);
           if(!str) { decoder->error = 9939; break; }
           str[length] = 0;
           for(i = 0; i < length; i++) str[i] = data[string2_begin + i];
 
           decoder->error = LodePNG_Text_add(&decoder->infoPng.text, key, str);
80004fd8:	ee cc ff 88 	sub	r12,r7,-120
             if(!ucvector_resize(&decoded, length + 1)) { decoder->error = 9944; break; }
             decoded.data[length] = 0;
             for(i = 0; i < length; i++) decoded.data[i] = data[begin + i];
           }
 
           decoder->error = LodePNG_IText_add(&decoder->infoPng.itext, key, langtag, transkey, (char*)decoded.data);
80004fdc:	ee cb ff 7c 	sub	r11,r7,-132
80004fe0:	30 1a       	mov	r10,1
80004fe2:	50 c8       	stdsp	sp[0x30],r8
   LodePNG_inspect(decoder, in, size); /*reads header and resets other parameters in decoder->infoPng*/
   if(decoder->error) return;
 
   ucvector_init(&idat);
 
   chunk = &in[33]; /*first byte of the first chunk after the header*/
80004fe4:	ea c6 ff df 	sub	r6,r5,-33
           str = (char*)malloc(length + 1);
           if(!str) { decoder->error = 9939; break; }
           str[length] = 0;
           for(i = 0; i < length; i++) str[i] = data[string2_begin + i];
 
           decoder->error = LodePNG_Text_add(&decoder->infoPng.text, key, str);
80004fe8:	51 4c       	stdsp	sp[0x50],r12
             if(!ucvector_resize(&decoded, length + 1)) { decoder->error = 9944; break; }
             decoded.data[length] = 0;
             for(i = 0; i < length; i++) decoded.data[i] = data[begin + i];
           }
 
           decoder->error = LodePNG_IText_add(&decoder->infoPng.itext, key, langtag, transkey, (char*)decoded.data);
80004fea:	51 5b       	stdsp	sp[0x54],r11
80004fec:	50 d8       	stdsp	sp[0x34],r8
80004fee:	10 91       	mov	r1,r8
80004ff0:	50 9a       	stdsp	sp[0x24],r10
80004ff2:	50 a8       	stdsp	sp[0x28],r8
   while(!IEND) /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk. IDAT data is put at the start of the in buffer*/
   {
     unsigned chunkLength;
     const unsigned char* data; /*the data in the chunk*/
 
     if((size_t)((chunk - in) + 12) > size || chunk < in) { decoder->error = 30; break; } /*error: size of the in buffer too small to contain next chunk*/
80004ff4:	10 94       	mov	r4,r8
80004ff6:	50 63       	stdsp	sp[0x18],r3
80004ff8:	06 9e       	mov	lr,r3
80004ffa:	0a 36       	cp.w	r6,r5
80004ffc:	5f 39       	srlo	r9
80004ffe:	ec 05 01 08 	sub	r8,r6,r5
80005002:	2f 48       	sub	r8,-12
80005004:	1c 38       	cp.w	r8,lr
80005006:	5f ba       	srhi	r10
80005008:	f5 e9 10 09 	or	r9,r10,r9
8000500c:	e8 09 18 00 	cp.b	r9,r4
80005010:	e0 81 01 89 	brne	80005322 <decodeGeneric+0x38e>
   (*bitpointer)++;
 }
 
 static unsigned LodePNG_read32bitInt(const unsigned char* buffer)
 {
   return (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];
80005014:	ec ca ff fd 	sub	r10,r6,-3
80005018:	ec cc ff ff 	sub	r12,r6,-1
8000501c:	50 2a       	stdsp	sp[0x8],r10
8000501e:	50 4c       	stdsp	sp[0x10],r12
80005020:	ec cb ff fe 	sub	r11,r6,-2
80005024:	50 3b       	stdsp	sp[0xc],r11
80005026:	0d 8a       	ld.ub	r10,r6[0x0]
80005028:	40 2e       	lddsp	lr,sp[0x8]
8000502a:	17 83       	ld.ub	r3,r11[0x0]
8000502c:	1d 89       	ld.ub	r9,lr[0x0]
8000502e:	f3 ea 11 89 	or	r9,r9,r10<<0x18
80005032:	19 8a       	ld.ub	r10,r12[0x0]
80005034:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005038:	f3 e3 10 83 	or	r3,r9,r3<<0x8
     unsigned chunkLength;
     const unsigned char* data; /*the data in the chunk*/
 
     if((size_t)((chunk - in) + 12) > size || chunk < in) { decoder->error = 30; break; } /*error: size of the in buffer too small to contain next chunk*/
     chunkLength = LodePNG_chunk_length(chunk); /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
     if(chunkLength > 2147483647) { decoder->error = 63; break; }
8000503c:	58 03       	cp.w	r3,0
8000503e:	e0 85 01 6e 	brlt	8000531a <decodeGeneric+0x386>
     if((size_t)((chunk - in) + chunkLength + 12) > size || (chunk + chunkLength + 12) < in) { decoder->error = 35; break; } /*error: size of the in buffer too small to contain next chunk*/
80005042:	06 08       	add	r8,r3
80005044:	40 6c       	lddsp	r12,sp[0x18]
80005046:	10 3c       	cp.w	r12,r8
80005048:	e0 83 01 61 	brlo	8000530a <decodeGeneric+0x376>
8000504c:	e6 c8 ff f4 	sub	r8,r3,-12
80005050:	ec 08 00 08 	add	r8,r6,r8
80005054:	10 35       	cp.w	r5,r8
80005056:	e0 8b 01 5a 	brhi	8000530a <decodeGeneric+0x376>
 }
 
 unsigned char LodePNG_chunk_type_equals(const unsigned char* chunk, const char* type) /*check if the type is the given type*/
 {
   if(strlen(type) != 4) return 0;
   return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
8000505a:	ec cb ff fc 	sub	r11,r6,-4
8000505e:	50 7b       	stdsp	sp[0x1c],r11
   return &chunk[8];
 }
 
 const unsigned char* LodePNG_chunk_data_const(const unsigned char* chunk) /*get pointer to the data of the chunk*/
 {
   return &chunk[8];
80005060:	ec c0 ff f8 	sub	r0,r6,-8
 }
 
 unsigned char LodePNG_chunk_type_equals(const unsigned char* chunk, const char* type) /*check if the type is the given type*/
 {
   if(strlen(type) != 4) return 0;
   return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
80005064:	17 82       	ld.ub	r2,r11[0x0]
80005066:	34 98       	mov	r8,73
80005068:	f0 02 18 00 	cp.b	r2,r8
8000506c:	c3 70       	breq	800050da <decodeGeneric+0x146>
8000506e:	35 08       	mov	r8,80
80005070:	f0 02 18 00 	cp.b	r2,r8
80005074:	e0 80 01 5b 	breq	8000532a <decodeGeneric+0x396>
         decoder->infoPng.color.palette[4 * i + 3] = 255; /*alpha*/
       }
       critical_pos = 2;
     }
     /*palette transparency chunk (tRNS)*/
     else if(LodePNG_chunk_type_equals(chunk, "tRNS"))
80005078:	fe fb 10 e0 	ld.w	r11,pc[4320]
8000507c:	0c 9c       	mov	r12,r6
8000507e:	fe b0 f4 19 	rcall	800038b0 <LodePNG_chunk_type_equals>
80005082:	18 9a       	mov	r10,r12
80005084:	e0 80 02 ed 	breq	8000565e <decodeGeneric+0x6ca>
     {
       if(decoder->infoPng.color.colorType == 3)
80005088:	6f 2b       	ld.w	r11,r7[0x48]
8000508a:	58 3b       	cp.w	r11,3
8000508c:	e0 80 01 b7 	breq	800053fa <decodeGeneric+0x466>
       {
         if(chunkLength > decoder->infoPng.color.palettesize) { decoder->error = 39; break; } /*error: more alpha values given than there are palette entries*/
         for(i = 0; i < chunkLength; i++) decoder->infoPng.color.palette[4 * i + 3] = data[i];
       }
       else if(decoder->infoPng.color.colorType == 0)
80005090:	58 0b       	cp.w	r11,0
80005092:	e0 80 01 c6 	breq	8000541e <decodeGeneric+0x48a>
       {
         if(chunkLength != 2) { decoder->error = 40; break; } /*error: this chunk must be 2 bytes for greyscale image*/
         decoder->infoPng.color.key_defined = 1;
         decoder->infoPng.color.key_r = decoder->infoPng.color.key_g = decoder->infoPng.color.key_b = 256 * data[0] + data[1];
       }
       else if(decoder->infoPng.color.colorType == 2)
80005096:	58 2b       	cp.w	r11,2
80005098:	e0 81 03 40 	brne	80005718 <decodeGeneric+0x784>
       {
         if(chunkLength != 6) { decoder->error = 41; break; } /*error: this chunk must be 6 bytes for RGB image*/
8000509c:	58 63       	cp.w	r3,6
8000509e:	e0 81 03 38 	brne	8000570e <decodeGeneric+0x77a>
         decoder->infoPng.color.key_defined = 1;
800050a2:	30 18       	mov	r8,1
800050a4:	ef 48 00 58 	st.w	r7[88],r8
         decoder->infoPng.color.key_r = 256 * data[0] + data[1];
800050a8:	01 99       	ld.ub	r9,r0[0x1]
800050aa:	01 88       	ld.ub	r8,r0[0x0]
800050ac:	a9 68       	lsl	r8,0x8
800050ae:	f2 08 00 08 	add	r8,r9,r8
800050b2:	ef 48 00 5c 	st.w	r7[92],r8
         decoder->infoPng.color.key_g = 256 * data[2] + data[3];
800050b6:	01 a8       	ld.ub	r8,r0[0x2]
800050b8:	f0 09 15 08 	lsl	r9,r8,0x8
800050bc:	01 b8       	ld.ub	r8,r0[0x3]
800050be:	f2 08 00 08 	add	r8,r9,r8
         decoder->infoPng.color.key_b = 256 * data[4] + data[5];
800050c2:	02 92       	mov	r2,r1
       else if(decoder->infoPng.color.colorType == 2)
       {
         if(chunkLength != 6) { decoder->error = 41; break; } /*error: this chunk must be 6 bytes for RGB image*/
         decoder->infoPng.color.key_defined = 1;
         decoder->infoPng.color.key_r = 256 * data[0] + data[1];
         decoder->infoPng.color.key_g = 256 * data[2] + data[3];
800050c4:	ef 48 00 60 	st.w	r7[96],r8
         decoder->infoPng.color.key_b = 256 * data[4] + data[5];
800050c8:	30 0b       	mov	r11,0
800050ca:	01 d9       	ld.ub	r9,r0[0x5]
800050cc:	01 c8       	ld.ub	r8,r0[0x4]
800050ce:	a9 68       	lsl	r8,0x8
800050d0:	12 08       	add	r8,r9
800050d2:	ef 48 00 64 	st.w	r7[100],r8
800050d6:	40 ae       	lddsp	lr,sp[0x28]
800050d8:	c7 79       	rjmp	800053c6 <decodeGeneric+0x432>
 }
 
 unsigned char LodePNG_chunk_type_equals(const unsigned char* chunk, const char* type) /*check if the type is the given type*/
 {
   if(strlen(type) != 4) return 0;
   return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
800050da:	0d d9       	ld.ub	r9,r6[0x5]
800050dc:	34 4a       	mov	r10,68
800050de:	f4 09 18 00 	cp.b	r9,r10
800050e2:	c1 20       	breq	80005106 <decodeGeneric+0x172>
800050e4:	34 58       	mov	r8,69
800050e6:	f0 09 18 00 	cp.b	r9,r8
800050ea:	cc 71       	brne	80005078 <decodeGeneric+0xe4>
800050ec:	0d e9       	ld.ub	r9,r6[0x6]
800050ee:	34 e8       	mov	r8,78
800050f0:	f0 09 18 00 	cp.b	r9,r8
800050f4:	cc 21       	brne	80005078 <decodeGeneric+0xe4>
800050f6:	0d f8       	ld.ub	r8,r6[0x7]
800050f8:	f4 08 18 00 	cp.b	r8,r10
800050fc:	cb e1       	brne	80005078 <decodeGeneric+0xe4>
800050fe:	02 92       	mov	r2,r1
80005100:	30 1b       	mov	r11,1
80005102:	40 ae       	lddsp	lr,sp[0x28]
80005104:	c6 19       	rjmp	800053c6 <decodeGeneric+0x432>
80005106:	0d e9       	ld.ub	r9,r6[0x6]
80005108:	34 18       	mov	r8,65
8000510a:	f0 09 18 00 	cp.b	r9,r8
8000510e:	cb 51       	brne	80005078 <decodeGeneric+0xe4>
80005110:	0d f9       	ld.ub	r9,r6[0x7]
80005112:	35 48       	mov	r8,84
80005114:	f0 09 18 00 	cp.b	r9,r8
80005118:	cb 01       	brne	80005078 <decodeGeneric+0xe4>
 
     /*IDAT chunk, containing compressed image data*/
     if(LodePNG_chunk_type_equals(chunk, "IDAT"))
     {
       size_t oldsize = idat.size;
       if(!ucvector_resize(&idat, oldsize + chunkLength)) { decoder->error = 9936; break; }
8000511a:	e6 01 00 02 	add	r2,r3,r1
   ((ucvector*)p)->data = NULL;
 }
 
 static unsigned ucvector_resize(ucvector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned char) > p->allocsize)
8000511e:	40 da       	lddsp	r10,sp[0x34]
80005120:	14 32       	cp.w	r2,r10
80005122:	e0 8b 01 e1 	brhi	800054e4 <decodeGeneric+0x550>
     /*IDAT chunk, containing compressed image data*/
     if(LodePNG_chunk_type_equals(chunk, "IDAT"))
     {
       size_t oldsize = idat.size;
       if(!ucvector_resize(&idat, oldsize + chunkLength)) { decoder->error = 9936; break; }
       for(i = 0; i < chunkLength; i++) idat.data[oldsize + i] = data[i];
80005126:	58 03       	cp.w	r3,0
80005128:	c3 70       	breq	80005196 <decodeGeneric+0x202>
8000512a:	ec c8 ff f4 	sub	r8,r6,-12
8000512e:	40 ca       	lddsp	r10,sp[0x30]
80005130:	02 0a       	add	r10,r1
80005132:	10 3a       	cp.w	r10,r8
80005134:	5f bb       	srhi	r11
80005136:	f5 e0 10 08 	or	r8,r10,r0
8000513a:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000513e:	5f 08       	sreq	r8
80005140:	58 33       	cp.w	r3,3
80005142:	5f b9       	srhi	r9
80005144:	10 69       	and	r9,r8
80005146:	f4 c8 ff fc 	sub	r8,r10,-4
8000514a:	10 30       	cp.w	r0,r8
8000514c:	5f b8       	srhi	r8
8000514e:	f7 e8 10 08 	or	r8,r11,r8
80005152:	f3 e8 00 08 	and	r8,r9,r8
80005156:	e8 08 18 00 	cp.b	r8,r4
8000515a:	e0 80 01 d1 	breq	800054fc <decodeGeneric+0x568>
8000515e:	e6 0b 16 02 	lsr	r11,r3,0x2
80005162:	f6 08 15 02 	lsl	r8,r11,0x2
80005166:	c0 90       	breq	80005178 <decodeGeneric+0x1e4>
80005168:	30 09       	mov	r9,0
8000516a:	01 0c       	ld.w	r12,r0++
8000516c:	14 ac       	st.w	r10++,r12
8000516e:	2f f9       	sub	r9,-1
80005170:	16 39       	cp.w	r9,r11
80005172:	cf c3       	brcs	8000516a <decodeGeneric+0x1d6>
80005174:	10 33       	cp.w	r3,r8
80005176:	c1 00       	breq	80005196 <decodeGeneric+0x202>
80005178:	f0 01 00 0a 	add	r10,r8,r1
8000517c:	40 ce       	lddsp	lr,sp[0x30]
8000517e:	f0 c9 ff f8 	sub	r9,r8,-8
80005182:	fc 0a 00 0a 	add	r10,lr,r10
80005186:	ec 09 00 09 	add	r9,r6,r9
8000518a:	13 3b       	ld.ub	r11,r9++
8000518c:	14 cb       	st.b	r10++,r11
8000518e:	2f f8       	sub	r8,-1
80005190:	10 33       	cp.w	r3,r8
80005192:	fe 9b ff fc 	brhi	8000518a <decodeGeneric+0x1f6>
 #ifdef LODEPNG_COMPILE_UNKNOWN_CHUNKS
       if(decoder->settings.rememberUnknownChunks)
       {
         LodePNG_UnknownChunks* unknown = &decoder->infoPng.unknown_chunks;
         decoder->error = LodePNG_append_chunk(&unknown->data[critical_pos - 1], &unknown->datasize[critical_pos - 1], chunk);
         if(decoder->error) break;
80005196:	30 3b       	mov	r11,3
80005198:	50 9b       	stdsp	sp[0x24],r11
8000519a:	40 ae       	lddsp	lr,sp[0x28]
       }
 #endif /*LODEPNG_COMPILE_UNKNOWN_CHUNKS*/
     }
 
     if(!decoder->settings.ignoreCrc && !unknown) /*check CRC if wanted, only on known chunk types*/
8000519c:	6e 18       	ld.w	r8,r7[0x4]
 #ifdef LODEPNG_COMPILE_UNKNOWN_CHUNKS
       if(decoder->settings.rememberUnknownChunks)
       {
         LodePNG_UnknownChunks* unknown = &decoder->infoPng.unknown_chunks;
         decoder->error = LodePNG_append_chunk(&unknown->data[critical_pos - 1], &unknown->datasize[critical_pos - 1], chunk);
         if(decoder->error) break;
8000519e:	30 0b       	mov	r11,0
       }
 #endif /*LODEPNG_COMPILE_UNKNOWN_CHUNKS*/
     }
 
     if(!decoder->settings.ignoreCrc && !unknown) /*check CRC if wanted, only on known chunk types*/
800051a0:	fd e8 10 08 	or	r8,lr,r8
800051a4:	e0 81 01 16 	brne	800053d0 <decodeGeneric+0x43c>
   (*bitpointer)++;
 }
 
 static unsigned LodePNG_read32bitInt(const unsigned char* buffer)
 {
   return (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];
800051a8:	0d 89       	ld.ub	r9,r6[0x0]
800051aa:	40 2c       	lddsp	r12,sp[0x8]
800051ac:	40 4a       	lddsp	r10,sp[0x10]
800051ae:	19 88       	ld.ub	r8,r12[0x0]
800051b0:	f1 e9 11 88 	or	r8,r8,r9<<0x18
800051b4:	15 89       	ld.ub	r9,r10[0x0]
800051b6:	40 3e       	lddsp	lr,sp[0xc]
800051b8:	f1 e9 11 08 	or	r8,r8,r9<<0x10
800051bc:	1d 89       	ld.ub	r9,lr[0x0]
800051be:	f1 e9 10 88 	or	r8,r8,r9<<0x8
 
 unsigned LodePNG_chunk_check_crc(const unsigned char* chunk) /*returns 0 if the crc is correct, error code if it's incorrect*/
 {
   unsigned length = LodePNG_chunk_length(chunk);
   unsigned CRC = LodePNG_read32bitInt(&chunk[length + 8]);
   unsigned checksum = Crc32_crc(&chunk[4], length + 4); /*the CRC is taken of the data and the 4 chunk type letters, not the length*/
800051c2:	f0 cc ff fc 	sub	r12,r8,-4
 }
 
 unsigned LodePNG_chunk_check_crc(const unsigned char* chunk) /*returns 0 if the crc is correct, error code if it's incorrect*/
 {
   unsigned length = LodePNG_chunk_length(chunk);
   unsigned CRC = LodePNG_read32bitInt(&chunk[length + 8]);
800051c6:	2f 88       	sub	r8,-8
800051c8:	ec 08 00 08 	add	r8,r6,r8
   (*bitpointer)++;
 }
 
 static unsigned LodePNG_read32bitInt(const unsigned char* buffer)
 {
   return (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];
800051cc:	11 ba       	ld.ub	r10,r8[0x3]
800051ce:	50 ba       	stdsp	sp[0x2c],r10
800051d0:	11 80       	ld.ub	r0,r8[0x0]
800051d2:	11 99       	ld.ub	r9,r8[0x1]
800051d4:	50 59       	stdsp	sp[0x14],r9
800051d6:	11 a8       	ld.ub	r8,r8[0x2]
800051d8:	50 88       	stdsp	sp[0x20],r8
 static unsigned Crc32_update_crc(const unsigned char* buf, unsigned crc, size_t len)
 {
   unsigned c = crc;
   size_t n;
 
   if(!Crc32_crc_table_computed) Crc32_make_crc_table();
800051da:	e0 61 05 60 	mov	r1,1376
800051de:	62 08       	ld.w	r8,r1[0x0]
800051e0:	58 08       	cp.w	r8,0
800051e2:	c7 11       	brne	800052c4 <decodeGeneric+0x330>
800051e4:	e0 6a 05 64 	mov	r10,1380
   for(n = 0; n < 256; n++)
   {
     c = n;
     for(k = 0; k < 8; k++)
     {
       if(c & 1) c = 0xedb88320L ^ (c >> 1);
800051e8:	f0 09 16 01 	lsr	r9,r8,0x1
800051ec:	12 9e       	mov	lr,r9
800051ee:	ee 1e ed b8 	eorh	lr,0xedb8
800051f2:	ec 1e 83 20 	eorl	lr,0x8320
800051f6:	e7 d8 c0 01 	bfextu	r3,r8,0x0,0x1
800051fa:	fc 03 17 10 	movne	r3,lr
800051fe:	f2 03 17 00 	moveq	r3,r9
80005202:	e6 09 16 01 	lsr	r9,r3,0x1
80005206:	12 9e       	mov	lr,r9
80005208:	ee 1e ed b8 	eorh	lr,0xedb8
8000520c:	ec 1e 83 20 	eorl	lr,0x8320
80005210:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
80005214:	fc 03 17 10 	movne	r3,lr
80005218:	f2 03 17 00 	moveq	r3,r9
8000521c:	e6 09 16 01 	lsr	r9,r3,0x1
80005220:	12 9e       	mov	lr,r9
80005222:	ee 1e ed b8 	eorh	lr,0xedb8
80005226:	ec 1e 83 20 	eorl	lr,0x8320
8000522a:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000522e:	fc 03 17 10 	movne	r3,lr
80005232:	f2 03 17 00 	moveq	r3,r9
80005236:	e6 09 16 01 	lsr	r9,r3,0x1
8000523a:	12 9e       	mov	lr,r9
8000523c:	ee 1e ed b8 	eorh	lr,0xedb8
80005240:	ec 1e 83 20 	eorl	lr,0x8320
80005244:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
80005248:	fc 03 17 10 	movne	r3,lr
8000524c:	f2 03 17 00 	moveq	r3,r9
80005250:	e6 09 16 01 	lsr	r9,r3,0x1
80005254:	12 9e       	mov	lr,r9
80005256:	ee 1e ed b8 	eorh	lr,0xedb8
8000525a:	ec 1e 83 20 	eorl	lr,0x8320
8000525e:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
80005262:	fc 03 17 10 	movne	r3,lr
80005266:	f2 03 17 00 	moveq	r3,r9
8000526a:	e6 09 16 01 	lsr	r9,r3,0x1
8000526e:	12 9e       	mov	lr,r9
80005270:	ee 1e ed b8 	eorh	lr,0xedb8
80005274:	ec 1e 83 20 	eorl	lr,0x8320
80005278:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000527c:	fc 03 17 10 	movne	r3,lr
80005280:	f2 03 17 00 	moveq	r3,r9
80005284:	e6 09 16 01 	lsr	r9,r3,0x1
80005288:	12 9e       	mov	lr,r9
8000528a:	ee 1e ed b8 	eorh	lr,0xedb8
8000528e:	ec 1e 83 20 	eorl	lr,0x8320
80005292:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
80005296:	fc 03 17 10 	movne	r3,lr
8000529a:	f2 03 17 00 	moveq	r3,r9
8000529e:	e6 09 16 01 	lsr	r9,r3,0x1
800052a2:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
800052a6:	12 9e       	mov	lr,r9
800052a8:	ee 1e ed b8 	eorh	lr,0xedb8
800052ac:	ec 1e 83 20 	eorl	lr,0x8320
       else c = c >> 1;
     }
     Crc32_crc_table[n] = c;
800052b0:	58 03       	cp.w	r3,0
800052b2:	fc 09 17 10 	movne	r9,lr
800052b6:	14 a9       	st.w	r10++,r9
 
 /*Make the table for a fast CRC.*/
 static void Crc32_make_crc_table(void)
 {
   unsigned c, k, n;
   for(n = 0; n < 256; n++)
800052b8:	2f f8       	sub	r8,-1
800052ba:	e0 48 01 00 	cp.w	r8,256
800052be:	c9 51       	brne	800051e8 <decodeGeneric+0x254>
       if(c & 1) c = 0xedb88320L ^ (c >> 1);
       else c = c >> 1;
     }
     Crc32_crc_table[n] = c;
   }
   Crc32_crc_table_computed = 1;
800052c0:	30 18       	mov	r8,1
800052c2:	83 08       	st.w	r1[0x0],r8
 {
   unsigned c = crc;
   size_t n;
 
   if(!Crc32_crc_table_computed) Crc32_make_crc_table();
   for(n = 0; n < len; n++)
800052c4:	58 0c       	cp.w	r12,0
800052c6:	e0 80 01 26 	breq	80005512 <decodeGeneric+0x57e>
800052ca:	40 7a       	lddsp	r10,sp[0x1c]
800052cc:	3f f8       	mov	r8,-1
800052ce:	30 09       	mov	r9,0
800052d0:	e0 63 05 64 	mov	r3,1380
   {
     c = Crc32_crc_table[(c ^ buf[n]) & 0xff] ^ (c >> 8);
800052d4:	15 3e       	ld.ub	lr,r10++
 {
   unsigned c = crc;
   size_t n;
 
   if(!Crc32_crc_table_computed) Crc32_make_crc_table();
   for(n = 0; n < len; n++)
800052d6:	2f f9       	sub	r9,-1
   {
     c = Crc32_crc_table[(c ^ buf[n]) & 0xff] ^ (c >> 8);
800052d8:	f1 ee 20 0e 	eor	lr,r8,lr
800052dc:	e6 0e 0f 8e 	ld.w	lr,r3[lr:b<<2]
800052e0:	fd e8 22 88 	eor	r8,lr,r8>>0x8
 {
   unsigned c = crc;
   size_t n;
 
   if(!Crc32_crc_table_computed) Crc32_make_crc_table();
   for(n = 0; n < len; n++)
800052e4:	12 3c       	cp.w	r12,r9
800052e6:	fe 9b ff f7 	brhi	800052d4 <decodeGeneric+0x340>
800052ea:	5c d8       	com	r8
 unsigned LodePNG_chunk_check_crc(const unsigned char* chunk) /*returns 0 if the crc is correct, error code if it's incorrect*/
 {
   unsigned length = LodePNG_chunk_length(chunk);
   unsigned CRC = LodePNG_read32bitInt(&chunk[length + 8]);
   unsigned checksum = Crc32_crc(&chunk[4], length + 4); /*the CRC is taken of the data and the 4 chunk type letters, not the length*/
   if(CRC != checksum) return 1;
800052ec:	40 be       	lddsp	lr,sp[0x2c]
800052ee:	40 5c       	lddsp	r12,sp[0x14]
800052f0:	fd e0 11 80 	or	r0,lr,r0<<0x18
800052f4:	40 8a       	lddsp	r10,sp[0x20]
800052f6:	e1 ec 11 00 	or	r0,r0,r12<<0x10
800052fa:	e1 ea 10 80 	or	r0,r0,r10<<0x8
800052fe:	10 30       	cp.w	r0,r8
80005300:	c6 80       	breq	800053d0 <decodeGeneric+0x43c>
 #endif /*LODEPNG_COMPILE_UNKNOWN_CHUNKS*/
     }
 
     if(!decoder->settings.ignoreCrc && !unknown) /*check CRC if wanted, only on known chunk types*/
     {
       if(LodePNG_chunk_check_crc(chunk)) { decoder->error = 57; break; }
80005302:	33 98       	mov	r8,57
80005304:	ef 48 00 d0 	st.w	r7[208],r8
80005308:	c0 48       	rjmp	80005310 <decodeGeneric+0x37c>
     const unsigned char* data; /*the data in the chunk*/
 
     if((size_t)((chunk - in) + 12) > size || chunk < in) { decoder->error = 30; break; } /*error: size of the in buffer too small to contain next chunk*/
     chunkLength = LodePNG_chunk_length(chunk); /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
     if(chunkLength > 2147483647) { decoder->error = 63; break; }
     if((size_t)((chunk - in) + chunkLength + 12) > size || (chunk + chunkLength + 12) < in) { decoder->error = 35; break; } /*error: size of the in buffer too small to contain next chunk*/
8000530a:	32 38       	mov	r8,35
8000530c:	ef 48 00 d0 	st.w	r7[208],r8
 } ucvector;
 
 static void ucvector_cleanup(void* p)
 {
   ((ucvector*)p)->size = ((ucvector*)p)->allocsize = 0;
   free(((ucvector*)p)->data);
80005310:	40 cc       	lddsp	r12,sp[0x30]
80005312:	e0 a0 55 ed 	rcall	8000feec <free>
     }
     ucvector_cleanup(&scanlines);
   }
 
   ucvector_cleanup(&idat);
 }
80005316:	29 8d       	sub	sp,-416
80005318:	d8 32       	popm	r0-r7,pc
     unsigned chunkLength;
     const unsigned char* data; /*the data in the chunk*/
 
     if((size_t)((chunk - in) + 12) > size || chunk < in) { decoder->error = 30; break; } /*error: size of the in buffer too small to contain next chunk*/
     chunkLength = LodePNG_chunk_length(chunk); /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
     if(chunkLength > 2147483647) { decoder->error = 63; break; }
8000531a:	33 f8       	mov	r8,63
8000531c:	ef 48 00 d0 	st.w	r7[208],r8
80005320:	cf 8b       	rjmp	80005310 <decodeGeneric+0x37c>
   while(!IEND) /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk. IDAT data is put at the start of the in buffer*/
   {
     unsigned chunkLength;
     const unsigned char* data; /*the data in the chunk*/
 
     if((size_t)((chunk - in) + 12) > size || chunk < in) { decoder->error = 30; break; } /*error: size of the in buffer too small to contain next chunk*/
80005322:	31 e8       	mov	r8,30
80005324:	ef 48 00 d0 	st.w	r7[208],r8
80005328:	cf 4b       	rjmp	80005310 <decodeGeneric+0x37c>
 }
 
 unsigned char LodePNG_chunk_type_equals(const unsigned char* chunk, const char* type) /*check if the type is the given type*/
 {
   if(strlen(type) != 4) return 0;
   return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
8000532a:	0d d9       	ld.ub	r9,r6[0x5]
8000532c:	34 c8       	mov	r8,76
8000532e:	f0 09 18 00 	cp.b	r9,r8
80005332:	fe 91 fe a3 	brne	80005078 <decodeGeneric+0xe4>
80005336:	0d e9       	ld.ub	r9,r6[0x6]
80005338:	35 48       	mov	r8,84
8000533a:	f0 09 18 00 	cp.b	r9,r8
8000533e:	fe 91 fe 9d 	brne	80005078 <decodeGeneric+0xe4>
80005342:	0d f9       	ld.ub	r9,r6[0x7]
80005344:	34 58       	mov	r8,69
80005346:	f0 09 18 00 	cp.b	r9,r8
8000534a:	fe 91 fe 97 	brne	80005078 <decodeGeneric+0xe4>
     }
     /*palette chunk (PLTE)*/
     else if(LodePNG_chunk_type_equals(chunk, "PLTE"))
     {
       unsigned pos = 0;
       if(decoder->infoPng.color.palette) free(decoder->infoPng.color.palette);
8000534e:	6f 4c       	ld.w	r12,r7[0x50]
80005350:	58 0c       	cp.w	r12,0
80005352:	c0 30       	breq	80005358 <decodeGeneric+0x3c4>
80005354:	e0 a0 55 cc 	rcall	8000feec <free>
       decoder->infoPng.color.palettesize = chunkLength / 3;
80005358:	e0 68 aa ab 	mov	r8,43691
8000535c:	ea 18 aa aa 	orh	r8,0xaaaa
80005360:	e6 08 06 42 	mulu.d	r2,r3,r8
80005364:	a1 93       	lsr	r3,0x1
80005366:	ef 43 00 54 	st.w	r7[84],r3
       decoder->infoPng.color.palette = (unsigned char*)malloc(4 * decoder->infoPng.color.palettesize);
8000536a:	e6 0c 15 02 	lsl	r12,r3,0x2
8000536e:	e0 a0 55 c7 	rcall	8000fefc <malloc>
80005372:	ef 4c 00 50 	st.w	r7[80],r12
       if(!decoder->infoPng.color.palette && decoder->infoPng.color.palettesize) { decoder->error = 9937; break; }
80005376:	e0 80 01 6a 	breq	8000564a <decodeGeneric+0x6b6>
       if(!decoder->infoPng.color.palette) decoder->infoPng.color.palettesize = 0; /*malloc failed...*/
       if(decoder->infoPng.color.palettesize > 256) { decoder->error = 38; break; } /*error: palette too big*/
8000537a:	6f 58       	ld.w	r8,r7[0x54]
8000537c:	e0 48 01 00 	cp.w	r8,256
80005380:	e0 8b 04 5a 	brhi	80005c34 <decodeGeneric+0xca0>
       for(i = 0; i < decoder->infoPng.color.palettesize; i++)
80005384:	58 08       	cp.w	r8,0
80005386:	c1 b0       	breq	800053bc <decodeGeneric+0x428>
       if(decoder->infoPng.color.palette) free(decoder->infoPng.color.palette);
       decoder->infoPng.color.palettesize = chunkLength / 3;
       decoder->infoPng.color.palette = (unsigned char*)malloc(4 * decoder->infoPng.color.palettesize);
       if(!decoder->infoPng.color.palette && decoder->infoPng.color.palettesize) { decoder->error = 9937; break; }
       if(!decoder->infoPng.color.palette) decoder->infoPng.color.palettesize = 0; /*malloc failed...*/
       if(decoder->infoPng.color.palettesize > 256) { decoder->error = 38; break; } /*error: palette too big*/
80005388:	30 18       	mov	r8,1
8000538a:	30 09       	mov	r9,0
       for(i = 0; i < decoder->infoPng.color.palettesize; i++)
       {
         decoder->infoPng.color.palette[4 * i + 0] = data[pos++]; /*R*/
         decoder->infoPng.color.palette[4 * i + 1] = data[pos++]; /*G*/
         decoder->infoPng.color.palette[4 * i + 2] = data[pos++]; /*B*/
         decoder->infoPng.color.palette[4 * i + 3] = 255; /*alpha*/
8000538c:	3f fb       	mov	r11,-1
8000538e:	c0 28       	rjmp	80005392 <decodeGeneric+0x3fe>
       decoder->infoPng.color.palettesize = chunkLength / 3;
       decoder->infoPng.color.palette = (unsigned char*)malloc(4 * decoder->infoPng.color.palettesize);
       if(!decoder->infoPng.color.palette && decoder->infoPng.color.palettesize) { decoder->error = 9937; break; }
       if(!decoder->infoPng.color.palette) decoder->infoPng.color.palettesize = 0; /*malloc failed...*/
       if(decoder->infoPng.color.palettesize > 256) { decoder->error = 38; break; } /*error: palette too big*/
       for(i = 0; i < decoder->infoPng.color.palettesize; i++)
80005390:	6f 4c       	ld.w	r12,r7[0x50]
       {
         decoder->infoPng.color.palette[4 * i + 0] = data[pos++]; /*R*/
80005392:	01 8a       	ld.ub	r10,r0[0x0]
80005394:	f8 09 0b 2a 	st.b	r12[r9<<0x2],r10
         decoder->infoPng.color.palette[4 * i + 1] = data[pos++]; /*G*/
80005398:	6f 4a       	ld.w	r10,r7[0x50]
8000539a:	01 9c       	ld.ub	r12,r0[0x1]
8000539c:	f4 08 0b 0c 	st.b	r10[r8],r12
         decoder->infoPng.color.palette[4 * i + 2] = data[pos++]; /*B*/
800053a0:	6f 4a       	ld.w	r10,r7[0x50]
800053a2:	10 0a       	add	r10,r8
800053a4:	01 ac       	ld.ub	r12,r0[0x2]
800053a6:	b4 9c       	st.b	r10[0x1],r12
         decoder->infoPng.color.palette[4 * i + 3] = 255; /*alpha*/
800053a8:	6f 4a       	ld.w	r10,r7[0x50]
800053aa:	10 0a       	add	r10,r8
800053ac:	b4 ab       	st.b	r10[0x2],r11
       decoder->infoPng.color.palettesize = chunkLength / 3;
       decoder->infoPng.color.palette = (unsigned char*)malloc(4 * decoder->infoPng.color.palettesize);
       if(!decoder->infoPng.color.palette && decoder->infoPng.color.palettesize) { decoder->error = 9937; break; }
       if(!decoder->infoPng.color.palette) decoder->infoPng.color.palettesize = 0; /*malloc failed...*/
       if(decoder->infoPng.color.palettesize > 256) { decoder->error = 38; break; } /*error: palette too big*/
       for(i = 0; i < decoder->infoPng.color.palettesize; i++)
800053ae:	2f f9       	sub	r9,-1
800053b0:	2f d0       	sub	r0,-3
800053b2:	2f c8       	sub	r8,-4
800053b4:	6f 5a       	ld.w	r10,r7[0x54]
800053b6:	12 3a       	cp.w	r10,r9
800053b8:	fe 9b ff ec 	brhi	80005390 <decodeGeneric+0x3fc>
 #ifdef LODEPNG_COMPILE_UNKNOWN_CHUNKS
       if(decoder->settings.rememberUnknownChunks)
       {
         LodePNG_UnknownChunks* unknown = &decoder->infoPng.unknown_chunks;
         decoder->error = LodePNG_append_chunk(&unknown->data[critical_pos - 1], &unknown->datasize[critical_pos - 1], chunk);
         if(decoder->error) break;
800053bc:	30 2a       	mov	r10,2
800053be:	02 92       	mov	r2,r1
800053c0:	50 9a       	stdsp	sp[0x24],r10
800053c2:	30 0b       	mov	r11,0
800053c4:	40 ae       	lddsp	lr,sp[0x28]
       }
 #endif /*LODEPNG_COMPILE_UNKNOWN_CHUNKS*/
     }
 
     if(!decoder->settings.ignoreCrc && !unknown) /*check CRC if wanted, only on known chunk types*/
800053c6:	6e 18       	ld.w	r8,r7[0x4]
800053c8:	fd e8 10 08 	or	r8,lr,r8
800053cc:	fe 90 fe ee 	breq	800051a8 <decodeGeneric+0x214>
     {
       if(LodePNG_chunk_check_crc(chunk)) { decoder->error = 57; break; }
     }
 
     if(!IEND) chunk = LodePNG_chunk_next_const(chunk);
800053d0:	58 0b       	cp.w	r11,0
800053d2:	c3 a1       	brne	80005446 <decodeGeneric+0x4b2>
   return &chunk[total_chunk_length];
 }
 
 const unsigned char* LodePNG_chunk_next_const(const unsigned char* chunk) /*don't use on IEND chunk, as there is no next chunk then*/
 {
   unsigned total_chunk_length = LodePNG_chunk_length(chunk) + 12;
800053d4:	40 29       	lddsp	r9,sp[0x8]
800053d6:	40 4e       	lddsp	lr,sp[0x10]
800053d8:	13 88       	ld.ub	r8,r9[0x0]
800053da:	0d 8b       	ld.ub	r11,r6[0x0]
800053dc:	1d 89       	ld.ub	r9,lr[0x0]
800053de:	40 3c       	lddsp	r12,sp[0xc]
800053e0:	f1 eb 11 88 	or	r8,r8,r11<<0x18
800053e4:	19 8a       	ld.ub	r10,r12[0x0]
800053e6:	f1 e9 11 08 	or	r8,r8,r9<<0x10
   return &chunk[total_chunk_length];
800053ea:	04 91       	mov	r1,r2
   return &chunk[total_chunk_length];
 }
 
 const unsigned char* LodePNG_chunk_next_const(const unsigned char* chunk) /*don't use on IEND chunk, as there is no next chunk then*/
 {
   unsigned total_chunk_length = LodePNG_chunk_length(chunk) + 12;
800053ec:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800053f0:	40 6e       	lddsp	lr,sp[0x18]
800053f2:	2f 48       	sub	r8,-12
   return &chunk[total_chunk_length];
800053f4:	10 06       	add	r6,r8
800053f6:	fe 9f fe 02 	bral	80004ffa <decodeGeneric+0x66>
     /*palette transparency chunk (tRNS)*/
     else if(LodePNG_chunk_type_equals(chunk, "tRNS"))
     {
       if(decoder->infoPng.color.colorType == 3)
       {
         if(chunkLength > decoder->infoPng.color.palettesize) { decoder->error = 39; break; } /*error: more alpha values given than there are palette entries*/
800053fa:	6f 58       	ld.w	r8,r7[0x54]
800053fc:	06 38       	cp.w	r8,r3
800053fe:	e0 83 01 92 	brlo	80005722 <decodeGeneric+0x78e>
80005402:	30 09       	mov	r9,0
80005404:	c0 78       	rjmp	80005412 <decodeGeneric+0x47e>
         for(i = 0; i < chunkLength; i++) decoder->infoPng.color.palette[4 * i + 3] = data[i];
80005406:	6f 48       	ld.w	r8,r7[0x50]
80005408:	01 3a       	ld.ub	r10,r0++
8000540a:	2f f9       	sub	r9,-1
8000540c:	f0 0b 0b 0a 	st.b	r8[r11],r10
80005410:	2f cb       	sub	r11,-4
80005412:	06 39       	cp.w	r9,r3
80005414:	cf 93       	brcs	80005406 <decodeGeneric+0x472>
 #ifdef LODEPNG_COMPILE_UNKNOWN_CHUNKS
       if(decoder->settings.rememberUnknownChunks)
       {
         LodePNG_UnknownChunks* unknown = &decoder->infoPng.unknown_chunks;
         decoder->error = LodePNG_append_chunk(&unknown->data[critical_pos - 1], &unknown->datasize[critical_pos - 1], chunk);
         if(decoder->error) break;
80005416:	02 92       	mov	r2,r1
80005418:	30 0b       	mov	r11,0
8000541a:	40 ae       	lddsp	lr,sp[0x28]
8000541c:	cd 5b       	rjmp	800053c6 <decodeGeneric+0x432>
         if(chunkLength > decoder->infoPng.color.palettesize) { decoder->error = 39; break; } /*error: more alpha values given than there are palette entries*/
         for(i = 0; i < chunkLength; i++) decoder->infoPng.color.palette[4 * i + 3] = data[i];
       }
       else if(decoder->infoPng.color.colorType == 0)
       {
         if(chunkLength != 2) { decoder->error = 40; break; } /*error: this chunk must be 2 bytes for greyscale image*/
8000541e:	58 23       	cp.w	r3,2
80005420:	e0 81 04 0f 	brne	80005c3e <decodeGeneric+0xcaa>
         decoder->infoPng.color.key_defined = 1;
80005424:	30 18       	mov	r8,1
80005426:	ef 48 00 58 	st.w	r7[88],r8
         decoder->infoPng.color.key_r = decoder->infoPng.color.key_g = decoder->infoPng.color.key_b = 256 * data[0] + data[1];
8000542a:	01 88       	ld.ub	r8,r0[0x0]
8000542c:	02 92       	mov	r2,r1
8000542e:	f0 09 15 08 	lsl	r9,r8,0x8
80005432:	01 98       	ld.ub	r8,r0[0x1]
80005434:	12 08       	add	r8,r9
80005436:	ef 48 00 5c 	st.w	r7[92],r8
8000543a:	ef 48 00 64 	st.w	r7[100],r8
8000543e:	ef 48 00 60 	st.w	r7[96],r8
80005442:	40 ae       	lddsp	lr,sp[0x28]
80005444:	cc 1b       	rjmp	800053c6 <decodeGeneric+0x432>
     }
 
     if(!IEND) chunk = LodePNG_chunk_next_const(chunk);
   }
 
   if(!decoder->error)
80005446:	ee f8 00 d0 	ld.w	r8,r7[208]
8000544a:	58 08       	cp.w	r8,0
8000544c:	fe 91 ff 62 	brne	80005310 <decodeGeneric+0x37c>
 #endif /*LODEPNG_COMPILE_DECODER*/
 
 static void ucvector_init(ucvector* p)
 {
   p->data = NULL;
   p->size = p->allocsize = 0;
80005450:	56 68       	stdsp	sp[0x198],r8
 #endif /*LODEPNG_COMPILE_PNG*/
 #endif /*LODEPNG_COMPILE_DECODER*/
 
 static void ucvector_init(ucvector* p)
 {
   p->data = NULL;
80005452:	56 58       	stdsp	sp[0x194],r8
   p->size = p->allocsize = 0;
80005454:	56 78       	stdsp	sp[0x19c],r8
 
   if(!decoder->error)
   {
     ucvector scanlines;
     ucvector_init(&scanlines);
     if(!ucvector_resize(&scanlines, ((decoder->infoPng.width * (decoder->infoPng.height * LodePNG_InfoColor_getBpp(&decoder->infoPng.color) + 7)) / 8) + decoder->infoPng.height)) decoder->error = 9945; /*maximum final image length is already reserved in the vector's length - this is not really necessary*/
80005456:	6e da       	ld.w	r10,r7[0x34]
80005458:	6e e8       	ld.w	r8,r7[0x38]
   info->palette[4 * info->palettesize + 3] = a;
   info->palettesize++;
   return 0;
 }
 
 unsigned LodePNG_InfoColor_getBpp(const LodePNG_InfoColor* info) { return getBpp(info->colorType, info->bitDepth); } /*calculate bits per pixel out of colorType and bitDepth*/
8000545a:	6f 3b       	ld.w	r11,r7[0x4c]
8000545c:	6f 29       	ld.w	r9,r7[0x48]
8000545e:	58 69       	cp.w	r9,6
80005460:	e0 8b 00 57 	brhi	8000550e <decodeGeneric+0x57a>
80005464:	b1 3b       	mul	r11,r8
80005466:	fe fc 0c f6 	ld.w	r12,pc[3318]
8000546a:	f8 09 03 29 	ld.w	r9,r12[r9<<0x2]
8000546e:	f6 09 02 49 	mul	r9,r11,r9
80005472:	2f 99       	sub	r9,-7
 
   if(!decoder->error)
   {
     ucvector scanlines;
     ucvector_init(&scanlines);
     if(!ucvector_resize(&scanlines, ((decoder->infoPng.width * (decoder->infoPng.height * LodePNG_InfoColor_getBpp(&decoder->infoPng.color) + 7)) / 8) + decoder->infoPng.height)) decoder->error = 9945; /*maximum final image length is already reserved in the vector's length - this is not really necessary*/
80005474:	b5 39       	mul	r9,r10
80005476:	f2 05 16 03 	lsr	r5,r9,0x3
8000547a:	10 05       	add	r5,r8
   ((ucvector*)p)->data = NULL;
 }
 
 static unsigned ucvector_resize(ucvector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned char) > p->allocsize)
8000547c:	e0 81 01 1c 	brne	800056b4 <decodeGeneric+0x720>
       p->data = (unsigned char*)data;
       p->size = size;
     }
     else return 0; /*error: not enough memory*/
   }
   else p->size = size;
80005480:	56 65       	stdsp	sp[0x198],r5
 */
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned LodePNG_decompress(unsigned char** out, size_t* outsize, const unsigned char* in, size_t insize, const LodeZlib_DecompressSettings* settings)
 {
   return LodeZlib_decompress(out, outsize, in, insize, settings);
80005482:	04 99       	mov	r9,r2
80005484:	0e 98       	mov	r8,r7
80005486:	40 ca       	lddsp	r10,sp[0x30]
80005488:	fa cb fe 68 	sub	r11,sp,-408
8000548c:	fa cc fe 6c 	sub	r12,sp,-404
80005490:	fe b0 fa 3c 	rcall	80004908 <LodeZlib_decompress>
   if(!decoder->error)
   {
     ucvector scanlines;
     ucvector_init(&scanlines);
     if(!ucvector_resize(&scanlines, ((decoder->infoPng.width * (decoder->infoPng.height * LodePNG_InfoColor_getBpp(&decoder->infoPng.color) + 7)) / 8) + decoder->infoPng.height)) decoder->error = 9945; /*maximum final image length is already reserved in the vector's length - this is not really necessary*/
     if(!decoder->error) decoder->error = LodePNG_decompress(&scanlines.data, &scanlines.size, idat.data, idat.size, &decoder->settings.zlibsettings); /*decompress with the Zlib decompressor*/
80005494:	ef 4c 00 d0 	st.w	r7[208],r12
 
     if(!decoder->error)
80005498:	e0 81 03 d8 	brne	80005c48 <decodeGeneric+0xcb4>
 #endif /*LODEPNG_COMPILE_PNG*/
 #endif /*LODEPNG_COMPILE_DECODER*/
 
 static void ucvector_init(ucvector* p)
 {
   p->data = NULL;
8000549c:	56 2c       	stdsp	sp[0x188],r12
   p->size = p->allocsize = 0;
8000549e:	56 4c       	stdsp	sp[0x190],r12
800054a0:	56 3c       	stdsp	sp[0x18c],r12
 
     if(!decoder->error)
     {
       ucvector outv;
       ucvector_init(&outv);
       if(!ucvector_resizev(&outv, (decoder->infoPng.height * decoder->infoPng.width * LodePNG_InfoColor_getBpp(&decoder->infoPng.color) + 7) / 8, 0)) decoder->error = 9946;
800054a2:	6e ea       	ld.w	r10,r7[0x38]
800054a4:	6e d6       	ld.w	r6,r7[0x34]
   info->palette[4 * info->palettesize + 3] = a;
   info->palettesize++;
   return 0;
 }
 
 unsigned LodePNG_InfoColor_getBpp(const LodePNG_InfoColor* info) { return getBpp(info->colorType, info->bitDepth); } /*calculate bits per pixel out of colorType and bitDepth*/
800054a6:	6f 39       	ld.w	r9,r7[0x4c]
800054a8:	6f 28       	ld.w	r8,r7[0x48]
800054aa:	58 68       	cp.w	r8,6
800054ac:	e0 88 01 16 	brls	800056d8 <decodeGeneric+0x744>
800054b0:	18 96       	mov	r6,r12
 #ifdef LODEPNG_COMPILE_DECODER
 #ifdef LODEPNG_COMPILE_PNG
 static unsigned ucvector_resizev(ucvector* p, size_t size, unsigned char value) /*resize and give all new elements the value*/
 {
   size_t oldsize = p->size, i;
   if(!ucvector_resize(p, size)) return 0;
800054b2:	0c 9b       	mov	r11,r6
800054b4:	fa cc fe 78 	sub	r12,sp,-392
800054b8:	fe b0 f0 c2 	rcall	8000363c <ucvector_resize>
800054bc:	c2 d1       	brne	80005516 <decodeGeneric+0x582>
 
     if(!decoder->error)
     {
       ucvector outv;
       ucvector_init(&outv);
       if(!ucvector_resizev(&outv, (decoder->infoPng.height * decoder->infoPng.width * LodePNG_InfoColor_getBpp(&decoder->infoPng.color) + 7) / 8, 0)) decoder->error = 9946;
800054be:	e0 68 26 da 	mov	r8,9946
800054c2:	ef 48 00 d0 	st.w	r7[208],r8
800054c6:	46 24       	lddsp	r4,sp[0x188]
800054c8:	46 56       	lddsp	r6,sp[0x194]
       if(!decoder->error) decoder->error = postProcessScanlines(outv.data, scanlines.data, &decoder->infoPng);
       *out = outv.data;
800054ca:	40 ee       	lddsp	lr,sp[0x38]
800054cc:	9d 04       	st.w	lr[0x0],r4
       *outsize = outv.size;
800054ce:	46 38       	lddsp	r8,sp[0x18c]
800054d0:	40 fc       	lddsp	r12,sp[0x3c]
800054d2:	99 08       	st.w	r12[0x0],r8
   size_t allocsize; /*allocated size*/
 } ucvector;
 
 static void ucvector_cleanup(void* p)
 {
   ((ucvector*)p)->size = ((ucvector*)p)->allocsize = 0;
800054d4:	30 07       	mov	r7,0
   free(((ucvector*)p)->data);
800054d6:	0c 9c       	mov	r12,r6
   size_t allocsize; /*allocated size*/
 } ucvector;
 
 static void ucvector_cleanup(void* p)
 {
   ((ucvector*)p)->size = ((ucvector*)p)->allocsize = 0;
800054d8:	56 77       	stdsp	sp[0x19c],r7
800054da:	56 67       	stdsp	sp[0x198],r7
   free(((ucvector*)p)->data);
800054dc:	e0 a0 55 08 	rcall	8000feec <free>
   ((ucvector*)p)->data = NULL;
800054e0:	56 57       	stdsp	sp[0x194],r7
800054e2:	c1 7b       	rjmp	80005310 <decodeGeneric+0x37c>
 
 static unsigned ucvector_resize(ucvector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned char) > p->allocsize)
   {
     size_t newsize = size * sizeof(unsigned char) * 2;
800054e4:	e4 09 15 01 	lsl	r9,r2,0x1
     void* data = realloc(p->data, newsize);
800054e8:	40 cc       	lddsp	r12,sp[0x30]
 
 static unsigned ucvector_resize(ucvector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned char) > p->allocsize)
   {
     size_t newsize = size * sizeof(unsigned char) * 2;
800054ea:	50 d9       	stdsp	sp[0x34],r9
     void* data = realloc(p->data, newsize);
800054ec:	12 9b       	mov	r11,r9
800054ee:	e0 a0 57 d5 	rcall	80010498 <realloc>
     if(data)
800054f2:	e0 80 00 a2 	breq	80005636 <decodeGeneric+0x6a2>
     {
       p->allocsize = newsize;
       p->data = (unsigned char*)data;
800054f6:	50 cc       	stdsp	sp[0x30],r12
800054f8:	fe 9f fe 17 	bral	80005126 <decodeGeneric+0x192>
 
     /*IDAT chunk, containing compressed image data*/
     if(LodePNG_chunk_type_equals(chunk, "IDAT"))
     {
       size_t oldsize = idat.size;
       if(!ucvector_resize(&idat, oldsize + chunkLength)) { decoder->error = 9936; break; }
800054fc:	30 08       	mov	r8,0
       for(i = 0; i < chunkLength; i++) idat.data[oldsize + i] = data[i];
800054fe:	01 39       	ld.ub	r9,r0++
80005500:	14 c9       	st.b	r10++,r9
80005502:	2f f8       	sub	r8,-1
80005504:	10 33       	cp.w	r3,r8
80005506:	fe 9b ff fc 	brhi	800054fe <decodeGeneric+0x56a>
8000550a:	fe 9f fe 46 	bral	80005196 <decodeGeneric+0x202>
   info->palette[4 * info->palettesize + 3] = a;
   info->palettesize++;
   return 0;
 }
 
 unsigned LodePNG_InfoColor_getBpp(const LodePNG_InfoColor* info) { return getBpp(info->colorType, info->bitDepth); } /*calculate bits per pixel out of colorType and bitDepth*/
8000550e:	30 79       	mov	r9,7
80005510:	cb 2b       	rjmp	80005474 <decodeGeneric+0x4e0>
 {
   unsigned c = crc;
   size_t n;
 
   if(!Crc32_crc_table_computed) Crc32_make_crc_table();
   for(n = 0; n < len; n++)
80005512:	18 98       	mov	r8,r12
80005514:	ce ca       	rjmp	800052ec <decodeGeneric+0x358>
 #ifdef LODEPNG_COMPILE_PNG
 static unsigned ucvector_resizev(ucvector* p, size_t size, unsigned char value) /*resize and give all new elements the value*/
 {
   size_t oldsize = p->size, i;
   if(!ucvector_resize(p, size)) return 0;
   for(i = oldsize; i < size; i++) p->data[i] = value;
80005516:	58 06       	cp.w	r6,0
80005518:	c0 90       	breq	8000552a <decodeGeneric+0x596>
8000551a:	30 08       	mov	r8,0
8000551c:	10 99       	mov	r9,r8
8000551e:	46 2a       	lddsp	r10,sp[0x188]
80005520:	f4 08 0b 09 	st.b	r10[r8],r9
80005524:	2f f8       	sub	r8,-1
80005526:	0c 38       	cp.w	r8,r6
80005528:	cf b3       	brcs	8000551e <decodeGeneric+0x58a>
     if(!decoder->error)
     {
       ucvector outv;
       ucvector_init(&outv);
       if(!ucvector_resizev(&outv, (decoder->infoPng.height * decoder->infoPng.width * LodePNG_InfoColor_getBpp(&decoder->infoPng.color) + 7) / 8, 0)) decoder->error = 9946;
       if(!decoder->error) decoder->error = postProcessScanlines(outv.data, scanlines.data, &decoder->infoPng);
8000552a:	ee f3 00 d0 	ld.w	r3,r7[208]
8000552e:	58 03       	cp.w	r3,0
80005530:	e0 81 00 ec 	brne	80005708 <decodeGeneric+0x774>
80005534:	46 56       	lddsp	r6,sp[0x194]
80005536:	46 24       	lddsp	r4,sp[0x188]
   info->palette[4 * info->palettesize + 3] = a;
   info->palettesize++;
   return 0;
 }
 
 unsigned LodePNG_InfoColor_getBpp(const LodePNG_InfoColor* info) { return getBpp(info->colorType, info->bitDepth); } /*calculate bits per pixel out of colorType and bitDepth*/
80005538:	6f 35       	ld.w	r5,r7[0x4c]
8000553a:	6f 28       	ld.w	r8,r7[0x48]
8000553c:	58 68       	cp.w	r8,6
8000553e:	e0 8b 00 82 	brhi	80005642 <decodeGeneric+0x6ae>
   *) if no Adam7: 1) unfilter 2) remove padding bits (= posible extra bits per scanline if bpp < 8)
   *) if adam7: 1) 7x unfilter 2) 7x remove padding bits 3) Adam7_deinterlace
   NOTE: the in buffer will be overwritten with intermediate data!
   */
   unsigned bpp = LodePNG_InfoColor_getBpp(&infoPng->color);
   unsigned w = infoPng->width;
80005542:	6e d0       	ld.w	r0,r7[0x34]
   unsigned h = infoPng->height;
80005544:	6e eb       	ld.w	r11,r7[0x38]
80005546:	50 3b       	stdsp	sp[0xc],r11
   return 0; /*unexisting color type*/
 }
 
 static unsigned getBpp(unsigned colorType, unsigned bitDepth)
 {
   return getNumColorChannels(colorType) * bitDepth; /*bits per pixel is amount of channels * bits per channel*/
80005548:	fe f9 0c 14 	ld.w	r9,pc[3092]
8000554c:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80005550:	b1 35       	mul	r5,r8
   */
   unsigned bpp = LodePNG_InfoColor_getBpp(&infoPng->color);
   unsigned w = infoPng->width;
   unsigned h = infoPng->height;
   unsigned error = 0;
   if(bpp == 0) return 31; /*error: invalid colortype*/
80005552:	58 05       	cp.w	r5,0
80005554:	c7 70       	breq	80005642 <decodeGeneric+0x6ae>
     if(!decoder->error)
     {
       ucvector outv;
       ucvector_init(&outv);
       if(!ucvector_resizev(&outv, (decoder->infoPng.height * decoder->infoPng.width * LodePNG_InfoColor_getBpp(&decoder->infoPng.color) + 7) / 8, 0)) decoder->error = 9946;
       if(!decoder->error) decoder->error = postProcessScanlines(outv.data, scanlines.data, &decoder->infoPng);
80005556:	6f 1a       	ld.w	r10,r7[0x44]
80005558:	58 0a       	cp.w	r10,0
8000555a:	e0 81 03 a8 	brne	80005caa <decodeGeneric+0xd16>
   unsigned error = 0;
   if(bpp == 0) return 31; /*error: invalid colortype*/
 
   if(infoPng->interlaceMethod == 0)
   {
     if(bpp < 8 && w * bpp != ((w * bpp + 7) / 8) * 8)
8000555e:	58 75       	cp.w	r5,7
80005560:	e0 8b 03 7e 	brhi	80005c5c <decodeGeneric+0xcc8>
80005564:	ea 00 02 42 	mul	r2,r5,r0
80005568:	e4 c3 ff f9 	sub	r3,r2,-7
8000556c:	a3 93       	lsr	r3,0x3
8000556e:	e6 09 15 03 	lsl	r9,r3,0x3
80005572:	50 29       	stdsp	sp[0x8],r9
80005574:	12 32       	cp.w	r2,r9
80005576:	e0 80 03 77 	breq	80005c64 <decodeGeneric+0xcd0>
 
   return error;
 }
 
 /*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
 static void decodeGeneric(LodePNG_Decoder* decoder, unsigned char** out, size_t* outsize, const unsigned char* in, size_t size)
8000557a:	e6 c8 ff ff 	sub	r8,r3,-1
   unsigned error = 0;
   if(bpp == 0) return 31; /*error: invalid colortype*/
 
   if(infoPng->interlaceMethod == 0)
   {
     if(bpp < 8 && w * bpp != ((w * bpp + 7) / 8) * 8)
8000557e:	0c 95       	mov	r5,r6
 
   return error;
 }
 
 /*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
 static void decodeGeneric(LodePNG_Decoder* decoder, unsigned char** out, size_t* outsize, const unsigned char* in, size_t size)
80005580:	50 68       	stdsp	sp[0x18],r8
80005582:	ec c1 ff ff 	sub	r1,r6,-1
80005586:	14 90       	mov	r0,r10
80005588:	c1 38       	rjmp	800055ae <decodeGeneric+0x61a>
   {
     size_t outindex = linebytes * y;
     size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
     unsigned char filterType = in[inindex];
 
     unsigned error = unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes);
8000558a:	1a d3       	st.w	--sp,r3
8000558c:	40 7e       	lddsp	lr,sp[0x1c]
 
   return error;
 }
 
 /*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
 static void decodeGeneric(LodePNG_Decoder* decoder, unsigned char** out, size_t* outsize, const unsigned char* in, size_t size)
8000558e:	50 55       	stdsp	sp[0x14],r5
   {
     size_t outindex = linebytes * y;
     size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
     unsigned char filterType = in[inindex];
 
     unsigned error = unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes);
80005590:	02 9b       	mov	r11,r1
80005592:	e3 38 ff ff 	ld.ub	r8,r1[-1]
80005596:	0a 9c       	mov	r12,r5
80005598:	1c 01       	add	r1,lr
8000559a:	30 19       	mov	r9,1
   unsigned char* prevline = 0;
 
   size_t bytewidth = (bpp + 7) / 8; /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
   size_t linebytes = (w * bpp + 7) / 8;
 
   for(y = 0; y < h; y++)
8000559c:	2f f0       	sub	r0,-1
   {
     size_t outindex = linebytes * y;
     size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
     unsigned char filterType = in[inindex];
 
     unsigned error = unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes);
8000559e:	fe b0 ec d7 	rcall	80002f4c <unfilterScanline>
800055a2:	06 05       	add	r5,r3
     if(error) return error;
800055a4:	2f fd       	sub	sp,-4
800055a6:	58 0c       	cp.w	r12,0
800055a8:	e0 81 00 ad 	brne	80005702 <decodeGeneric+0x76e>
   unsigned char* prevline = 0;
 
   size_t bytewidth = (bpp + 7) / 8; /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
   size_t linebytes = (w * bpp + 7) / 8;
 
   for(y = 0; y < h; y++)
800055ac:	40 4a       	lddsp	r10,sp[0x10]
800055ae:	40 3c       	lddsp	r12,sp[0xc]
800055b0:	00 3c       	cp.w	r12,r0
800055b2:	fe 9b ff ec 	brhi	8000558a <decodeGeneric+0x5f6>
 
   return error;
 }
 
 /*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
 static void decodeGeneric(LodePNG_Decoder* decoder, unsigned char** out, size_t* outsize, const unsigned char* in, size_t size)
800055b6:	e4 0b 11 00 	rsub	r11,r2,0
800055ba:	40 2a       	lddsp	r10,sp[0x8]
800055bc:	5c 3a       	neg	r10
800055be:	30 08       	mov	r8,0
800055c0:	50 6b       	stdsp	sp[0x18],r11
800055c2:	50 4a       	stdsp	sp[0x10],r10
800055c4:	10 9c       	mov	r12,r8
800055c6:	10 9b       	mov	r11,r8
800055c8:	10 9a       	mov	r10,r8
800055ca:	10 95       	mov	r5,r8
   only useful if (ilinebits - olinebits) is a value in the range 1..7
   */
   unsigned y;
   size_t diff = ilinebits - olinebits;
   size_t obp = 0, ibp = 0; /*bit pointers*/
   for(y = 0; y < h; y++)
800055cc:	40 39       	lddsp	r9,sp[0xc]
800055ce:	0a 39       	cp.w	r9,r5
800055d0:	e0 88 00 98 	brls	80005700 <decodeGeneric+0x76c>
 #endif /*LODEPNG_COMPILE_DECODER*/
 
 static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)
 {
   /*the current bit in bitstream may be 0 or 1 for this to work*/
   if(bit == 0) bitstream[(*bitpointer) >> 3] &=  (unsigned char)(~(1 << (7 - ((*bitpointer) & 0x7))));
800055d4:	f0 ce 00 01 	sub	lr,r8,1
   only useful if (ilinebits - olinebits) is a value in the range 1..7
   */
   unsigned y;
   size_t diff = ilinebits - olinebits;
   size_t obp = 0, ibp = 0; /*bit pointers*/
   for(y = 0; y < h; y++)
800055d8:	30 09       	mov	r9,0
 #endif /*LODEPNG_COMPILE_DECODER*/
 
 static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)
 {
   /*the current bit in bitstream may be 0 or 1 for this to work*/
   if(bit == 0) bitstream[(*bitpointer) >> 3] &=  (unsigned char)(~(1 << (7 - ((*bitpointer) & 0x7))));
800055da:	50 5e       	stdsp	sp[0x14],lr
800055dc:	50 88       	stdsp	sp[0x20],r8
   else bitstream[(*bitpointer) >> 3] |=  (1 << (7 - ((*bitpointer) & 0x7)));
800055de:	f8 ce 00 01 	sub	lr,r12,1
   size_t diff = ilinebits - olinebits;
   size_t obp = 0, ibp = 0; /*bit pointers*/
   for(y = 0; y < h; y++)
   {
     size_t x;
     for(x = 0; x < olinebits; x++)
800055e2:	f2 0a 00 03 	add	r3,r9,r10
800055e6:	f2 0b 00 00 	add	r0,r9,r11
 #endif /*LODEPNG_COMPILE_DECODER*/
 
 static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)
 {
   /*the current bit in bitstream may be 0 or 1 for this to work*/
   if(bit == 0) bitstream[(*bitpointer) >> 3] &=  (unsigned char)(~(1 << (7 - ((*bitpointer) & 0x7))));
800055ea:	e6 01 16 03 	lsr	r1,r3,0x3
800055ee:	e8 01 00 01 	add	r1,r4,r1
   else bitstream[(*bitpointer) >> 3] |=  (1 << (7 - ((*bitpointer) & 0x7)));
800055f2:	02 93       	mov	r3,r1
   size_t diff = ilinebits - olinebits;
   size_t obp = 0, ibp = 0; /*bit pointers*/
   for(y = 0; y < h; y++)
   {
     size_t x;
     for(x = 0; x < olinebits; x++)
800055f4:	12 32       	cp.w	r2,r9
800055f6:	e0 88 03 14 	brls	80005c1e <decodeGeneric+0xc8a>
 #endif /*LODEPNG_COMPILE_DECODER*/
 
 static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)
 {
   /*the current bit in bitstream may be 0 or 1 for this to work*/
   if(bit == 0) bitstream[(*bitpointer) >> 3] &=  (unsigned char)(~(1 << (7 - ((*bitpointer) & 0x7))));
800055fa:	a3 90       	lsr	r0,0x3
800055fc:	ec 00 07 00 	ld.ub	r0,r6[r0]
80005600:	50 70       	stdsp	sp[0x1c],r0
80005602:	40 78       	lddsp	r8,sp[0x1c]
80005604:	40 50       	lddsp	r0,sp[0x14]
80005606:	12 10       	sub	r0,r9
80005608:	e1 d0 c0 03 	bfextu	r0,r0,0x0,0x3
8000560c:	f0 00 08 40 	asr	r0,r8,r0
80005610:	30 08       	mov	r8,0
80005612:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
80005616:	f0 00 18 00 	cp.b	r0,r8
8000561a:	e0 81 02 f4 	brne	80005c02 <decodeGeneric+0xc6e>
8000561e:	03 83       	ld.ub	r3,r1[0x0]
80005620:	fc 09 01 00 	sub	r0,lr,r9
80005624:	30 18       	mov	r8,1
80005626:	e1 d0 c0 03 	bfextu	r0,r0,0x0,0x3
   size_t diff = ilinebits - olinebits;
   size_t obp = 0, ibp = 0; /*bit pointers*/
   for(y = 0; y < h; y++)
   {
     size_t x;
     for(x = 0; x < olinebits; x++)
8000562a:	2f f9       	sub	r9,-1
 #endif /*LODEPNG_COMPILE_DECODER*/
 
 static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)
 {
   /*the current bit in bitstream may be 0 or 1 for this to work*/
   if(bit == 0) bitstream[(*bitpointer) >> 3] &=  (unsigned char)(~(1 << (7 - ((*bitpointer) & 0x7))));
8000562c:	f0 00 09 40 	lsl	r0,r8,r0
80005630:	00 83       	andn	r3,r0
80005632:	a2 83       	st.b	r1[0x0],r3
80005634:	cd 7b       	rjmp	800055e2 <decodeGeneric+0x64e>
 
     /*IDAT chunk, containing compressed image data*/
     if(LodePNG_chunk_type_equals(chunk, "IDAT"))
     {
       size_t oldsize = idat.size;
       if(!ucvector_resize(&idat, oldsize + chunkLength)) { decoder->error = 9936; break; }
80005636:	e0 68 26 d0 	mov	r8,9936
8000563a:	ef 48 00 d0 	st.w	r7[208],r8
8000563e:	fe 9f fe 69 	bral	80005310 <decodeGeneric+0x37c>
       }
     }
   }
   else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/
   {
     for(i = 0; i < 7; i++)
80005642:	31 fc       	mov	r12,31
     if(!decoder->error)
     {
       ucvector outv;
       ucvector_init(&outv);
       if(!ucvector_resizev(&outv, (decoder->infoPng.height * decoder->infoPng.width * LodePNG_InfoColor_getBpp(&decoder->infoPng.color) + 7) / 8, 0)) decoder->error = 9946;
       if(!decoder->error) decoder->error = postProcessScanlines(outv.data, scanlines.data, &decoder->infoPng);
80005644:	ef 4c 00 d0 	st.w	r7[208],r12
80005648:	c4 1b       	rjmp	800054ca <decodeGeneric+0x536>
     {
       unsigned pos = 0;
       if(decoder->infoPng.color.palette) free(decoder->infoPng.color.palette);
       decoder->infoPng.color.palettesize = chunkLength / 3;
       decoder->infoPng.color.palette = (unsigned char*)malloc(4 * decoder->infoPng.color.palettesize);
       if(!decoder->infoPng.color.palette && decoder->infoPng.color.palettesize) { decoder->error = 9937; break; }
8000564a:	6f 5b       	ld.w	r11,r7[0x54]
8000564c:	58 0b       	cp.w	r11,0
8000564e:	c6 f1       	brne	8000572c <decodeGeneric+0x798>
       if(!decoder->infoPng.color.palette) decoder->infoPng.color.palettesize = 0; /*malloc failed...*/
80005650:	ef 4b 00 54 	st.w	r7[84],r11
80005654:	30 2c       	mov	r12,2
80005656:	02 92       	mov	r2,r1
80005658:	50 9c       	stdsp	sp[0x24],r12
8000565a:	40 ae       	lddsp	lr,sp[0x28]
8000565c:	cb 5a       	rjmp	800053c6 <decodeGeneric+0x432>
       }
       else { decoder->error = 42; break; } /*error: tRNS chunk not allowed for other color models*/
     }
 #ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
     /*background color chunk (bKGD)*/
     else if(LodePNG_chunk_type_equals(chunk, "bKGD"))
8000565e:	50 0a       	stdsp	sp[0x0],r10
80005660:	fe fb 0b 00 	ld.w	r11,pc[2816]
80005664:	0c 9c       	mov	r12,r6
80005666:	fe b0 f1 25 	rcall	800038b0 <LodePNG_chunk_type_equals>
8000566a:	40 0a       	lddsp	r10,sp[0x0]
8000566c:	18 99       	mov	r9,r12
8000566e:	e0 80 00 a0 	breq	800057ae <decodeGeneric+0x81a>
     {
       if(decoder->infoPng.color.colorType == 3)
80005672:	6f 28       	ld.w	r8,r7[0x48]
80005674:	58 38       	cp.w	r8,3
80005676:	e0 80 00 8e 	breq	80005792 <decodeGeneric+0x7fe>
       {
         if(chunkLength != 1) { decoder->error = 43; break; } /*error: this chunk must be 1 byte for indexed color image*/
         decoder->infoPng.background_defined = 1;
         decoder->infoPng.background_r = decoder->infoPng.background_g = decoder->infoPng.background_g = data[0];
       }
       else if(decoder->infoPng.color.colorType == 0 || decoder->infoPng.color.colorType == 4)
8000567a:	58 48       	cp.w	r8,4
8000567c:	5f 0b       	sreq	r11
8000567e:	58 08       	cp.w	r8,0
80005680:	5f 09       	sreq	r9
80005682:	f7 e9 10 09 	or	r9,r11,r9
80005686:	e8 09 18 00 	cp.b	r9,r4
8000568a:	c5 c0       	breq	80005742 <decodeGeneric+0x7ae>
       {
         if(chunkLength != 2) { decoder->error = 44; break; } /*error: this chunk must be 2 bytes for greyscale image*/
8000568c:	58 23       	cp.w	r3,2
8000568e:	c5 51       	brne	80005738 <decodeGeneric+0x7a4>
         decoder->infoPng.background_defined = 1;
80005690:	30 18       	mov	r8,1
80005692:	ef 48 00 68 	st.w	r7[104],r8
         decoder->infoPng.background_r = decoder->infoPng.background_g = decoder->infoPng.background_b = 256 * data[0] + data[1];
80005696:	01 88       	ld.ub	r8,r0[0x0]
80005698:	02 92       	mov	r2,r1
8000569a:	f0 09 15 08 	lsl	r9,r8,0x8
8000569e:	14 9b       	mov	r11,r10
800056a0:	01 98       	ld.ub	r8,r0[0x1]
800056a2:	12 08       	add	r8,r9
800056a4:	ef 48 00 6c 	st.w	r7[108],r8
800056a8:	ef 48 00 74 	st.w	r7[116],r8
800056ac:	ef 48 00 70 	st.w	r7[112],r8
800056b0:	40 ae       	lddsp	lr,sp[0x28]
800056b2:	c8 aa       	rjmp	800053c6 <decodeGeneric+0x432>
 
 static unsigned ucvector_resize(ucvector* p, size_t size) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(size * sizeof(unsigned char) > p->allocsize)
   {
     size_t newsize = size * sizeof(unsigned char) * 2;
800056b4:	ea 04 15 01 	lsl	r4,r5,0x1
     void* data = realloc(p->data, newsize);
800056b8:	30 0c       	mov	r12,0
800056ba:	08 9b       	mov	r11,r4
800056bc:	e0 a0 56 ee 	rcall	80010498 <realloc>
     if(data)
800056c0:	e0 80 02 c7 	breq	80005c4e <decodeGeneric+0xcba>
     {
       p->allocsize = newsize;
800056c4:	56 74       	stdsp	sp[0x19c],r4
       p->data = (unsigned char*)data;
       p->size = size;
800056c6:	56 65       	stdsp	sp[0x198],r5
     size_t newsize = size * sizeof(unsigned char) * 2;
     void* data = realloc(p->data, newsize);
     if(data)
     {
       p->allocsize = newsize;
       p->data = (unsigned char*)data;
800056c8:	56 5c       	stdsp	sp[0x194],r12
800056ca:	ee f8 00 d0 	ld.w	r8,r7[208]
   if(!decoder->error)
   {
     ucvector scanlines;
     ucvector_init(&scanlines);
     if(!ucvector_resize(&scanlines, ((decoder->infoPng.width * (decoder->infoPng.height * LodePNG_InfoColor_getBpp(&decoder->infoPng.color) + 7)) / 8) + decoder->infoPng.height)) decoder->error = 9945; /*maximum final image length is already reserved in the vector's length - this is not really necessary*/
     if(!decoder->error) decoder->error = LodePNG_decompress(&scanlines.data, &scanlines.size, idat.data, idat.size, &decoder->settings.zlibsettings); /*decompress with the Zlib decompressor*/
800056ce:	58 08       	cp.w	r8,0
800056d0:	fe 90 fe d9 	breq	80005482 <decodeGeneric+0x4ee>
800056d4:	18 96       	mov	r6,r12
800056d6:	cf fa       	rjmp	800054d4 <decodeGeneric+0x540>
   info->palette[4 * info->palettesize + 3] = a;
   info->palettesize++;
   return 0;
 }
 
 unsigned LodePNG_InfoColor_getBpp(const LodePNG_InfoColor* info) { return getBpp(info->colorType, info->bitDepth); } /*calculate bits per pixel out of colorType and bitDepth*/
800056d8:	b5 36       	mul	r6,r10
800056da:	b3 36       	mul	r6,r9
800056dc:	fe f9 0a 80 	ld.w	r9,pc[2688]
800056e0:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800056e4:	b1 36       	mul	r6,r8
800056e6:	2f 96       	sub	r6,-7
800056e8:	a3 96       	lsr	r6,0x3
800056ea:	ce 4a       	rjmp	800054b2 <decodeGeneric+0x51e>
     for(i = 0; i < 7; i++)
     {
       unsigned x, y, b;
       size_t bytewidth = bpp / 8;
       for(y = 0; y < passh[i]; y++)
       for(x = 0; x < passw[i]; x++)
800056ec:	40 29       	lddsp	r9,sp[0x8]
800056ee:	2f c9       	sub	r9,-4
800056f0:	50 29       	stdsp	sp[0x8],r9
800056f2:	2f c1       	sub	r1,-4
800056f4:	2f ce       	sub	lr,-4
800056f6:	2f c2       	sub	r2,-4
 
   Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
 
   if(bpp >= 8)
   {
     for(i = 0; i < 7; i++)
800056f8:	59 ce       	cp.w	lr,28
800056fa:	e0 81 04 86 	brne	80006006 <decodeGeneric+0x1072>
800056fe:	40 47       	lddsp	r7,sp[0x10]
       }
     }
   }
   else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/
   {
     for(i = 0; i < 7; i++)
80005700:	30 0c       	mov	r12,0
80005702:	46 24       	lddsp	r4,sp[0x188]
80005704:	46 56       	lddsp	r6,sp[0x194]
80005706:	c9 fb       	rjmp	80005644 <decodeGeneric+0x6b0>
80005708:	46 24       	lddsp	r4,sp[0x188]
8000570a:	46 56       	lddsp	r6,sp[0x194]
8000570c:	cd fa       	rjmp	800054ca <decodeGeneric+0x536>
         decoder->infoPng.color.key_defined = 1;
         decoder->infoPng.color.key_r = decoder->infoPng.color.key_g = decoder->infoPng.color.key_b = 256 * data[0] + data[1];
       }
       else if(decoder->infoPng.color.colorType == 2)
       {
         if(chunkLength != 6) { decoder->error = 41; break; } /*error: this chunk must be 6 bytes for RGB image*/
8000570e:	32 98       	mov	r8,41
80005710:	ef 48 00 d0 	st.w	r7[208],r8
80005714:	fe 9f fd fe 	bral	80005310 <decodeGeneric+0x37c>
         decoder->infoPng.color.key_defined = 1;
         decoder->infoPng.color.key_r = 256 * data[0] + data[1];
         decoder->infoPng.color.key_g = 256 * data[2] + data[3];
         decoder->infoPng.color.key_b = 256 * data[4] + data[5];
       }
       else { decoder->error = 42; break; } /*error: tRNS chunk not allowed for other color models*/
80005718:	32 a8       	mov	r8,42
8000571a:	ef 48 00 d0 	st.w	r7[208],r8
8000571e:	fe 9f fd f9 	bral	80005310 <decodeGeneric+0x37c>
     /*palette transparency chunk (tRNS)*/
     else if(LodePNG_chunk_type_equals(chunk, "tRNS"))
     {
       if(decoder->infoPng.color.colorType == 3)
       {
         if(chunkLength > decoder->infoPng.color.palettesize) { decoder->error = 39; break; } /*error: more alpha values given than there are palette entries*/
80005722:	32 78       	mov	r8,39
80005724:	ef 48 00 d0 	st.w	r7[208],r8
80005728:	fe 9f fd f4 	bral	80005310 <decodeGeneric+0x37c>
     {
       unsigned pos = 0;
       if(decoder->infoPng.color.palette) free(decoder->infoPng.color.palette);
       decoder->infoPng.color.palettesize = chunkLength / 3;
       decoder->infoPng.color.palette = (unsigned char*)malloc(4 * decoder->infoPng.color.palettesize);
       if(!decoder->infoPng.color.palette && decoder->infoPng.color.palettesize) { decoder->error = 9937; break; }
8000572c:	e0 68 26 d1 	mov	r8,9937
80005730:	ef 48 00 d0 	st.w	r7[208],r8
80005734:	fe 9f fd ee 	bral	80005310 <decodeGeneric+0x37c>
         decoder->infoPng.background_defined = 1;
         decoder->infoPng.background_r = decoder->infoPng.background_g = decoder->infoPng.background_g = data[0];
       }
       else if(decoder->infoPng.color.colorType == 0 || decoder->infoPng.color.colorType == 4)
       {
         if(chunkLength != 2) { decoder->error = 44; break; } /*error: this chunk must be 2 bytes for greyscale image*/
80005738:	32 c8       	mov	r8,44
8000573a:	ef 48 00 d0 	st.w	r7[208],r8
8000573e:	fe 9f fd e9 	bral	80005310 <decodeGeneric+0x37c>
         decoder->infoPng.background_defined = 1;
         decoder->infoPng.background_r = decoder->infoPng.background_g = decoder->infoPng.background_b = 256 * data[0] + data[1];
       }
       else if(decoder->infoPng.color.colorType == 2 || decoder->infoPng.color.colorType == 6)
80005742:	58 28       	cp.w	r8,2
80005744:	5f 09       	sreq	r9
80005746:	58 68       	cp.w	r8,6
80005748:	5f 08       	sreq	r8
8000574a:	12 48       	or	r8,r9
8000574c:	e8 08 18 00 	cp.b	r8,r4
80005750:	fe 90 fe 63 	breq	80005416 <decodeGeneric+0x482>
       {
         if(chunkLength != 6) { decoder->error = 45; break; } /*error: this chunk must be 6 bytes for greyscale image*/
80005754:	58 63       	cp.w	r3,6
80005756:	c4 a1       	brne	800057ea <decodeGeneric+0x856>
         decoder->infoPng.background_defined = 1;
80005758:	30 18       	mov	r8,1
8000575a:	ef 48 00 68 	st.w	r7[104],r8
         decoder->infoPng.background_r = 256 * data[0] + data[1];
8000575e:	01 99       	ld.ub	r9,r0[0x1]
80005760:	01 88       	ld.ub	r8,r0[0x0]
80005762:	a9 68       	lsl	r8,0x8
80005764:	f2 08 00 08 	add	r8,r9,r8
80005768:	ef 48 00 6c 	st.w	r7[108],r8
         decoder->infoPng.background_g = 256 * data[2] + data[3];
8000576c:	01 a8       	ld.ub	r8,r0[0x2]
8000576e:	f0 09 15 08 	lsl	r9,r8,0x8
80005772:	01 b8       	ld.ub	r8,r0[0x3]
80005774:	f2 08 00 08 	add	r8,r9,r8
         decoder->infoPng.background_b = 256 * data[4] + data[5];
80005778:	02 92       	mov	r2,r1
       else if(decoder->infoPng.color.colorType == 2 || decoder->infoPng.color.colorType == 6)
       {
         if(chunkLength != 6) { decoder->error = 45; break; } /*error: this chunk must be 6 bytes for greyscale image*/
         decoder->infoPng.background_defined = 1;
         decoder->infoPng.background_r = 256 * data[0] + data[1];
         decoder->infoPng.background_g = 256 * data[2] + data[3];
8000577a:	ef 48 00 70 	st.w	r7[112],r8
         decoder->infoPng.background_b = 256 * data[4] + data[5];
8000577e:	14 9b       	mov	r11,r10
80005780:	01 d9       	ld.ub	r9,r0[0x5]
80005782:	01 c8       	ld.ub	r8,r0[0x4]
80005784:	a9 68       	lsl	r8,0x8
80005786:	12 08       	add	r8,r9
80005788:	ef 48 00 74 	st.w	r7[116],r8
8000578c:	40 ae       	lddsp	lr,sp[0x28]
8000578e:	fe 9f fe 1c 	bral	800053c6 <decodeGeneric+0x432>
     /*background color chunk (bKGD)*/
     else if(LodePNG_chunk_type_equals(chunk, "bKGD"))
     {
       if(decoder->infoPng.color.colorType == 3)
       {
         if(chunkLength != 1) { decoder->error = 43; break; } /*error: this chunk must be 1 byte for indexed color image*/
80005792:	58 13       	cp.w	r3,1
80005794:	c3 01       	brne	800057f4 <decodeGeneric+0x860>
         decoder->infoPng.background_defined = 1;
80005796:	ef 43 00 68 	st.w	r7[104],r3
         decoder->infoPng.background_r = decoder->infoPng.background_g = decoder->infoPng.background_g = data[0];
8000579a:	02 92       	mov	r2,r1
8000579c:	01 88       	ld.ub	r8,r0[0x0]
8000579e:	14 9b       	mov	r11,r10
800057a0:	ef 48 00 6c 	st.w	r7[108],r8
800057a4:	ef 48 00 70 	st.w	r7[112],r8
800057a8:	40 ae       	lddsp	lr,sp[0x28]
800057aa:	fe 9f fe 0e 	bral	800053c6 <decodeGeneric+0x432>
         decoder->infoPng.background_g = 256 * data[2] + data[3];
         decoder->infoPng.background_b = 256 * data[4] + data[5];
       }
     }
     /*text chunk (tEXt)*/
     else if(LodePNG_chunk_type_equals(chunk, "tEXt"))
800057ae:	50 19       	stdsp	sp[0x4],r9
800057b0:	fe fb 09 b4 	ld.w	r11,pc[2484]
800057b4:	0c 9c       	mov	r12,r6
800057b6:	fe b0 f0 7d 	rcall	800038b0 <LodePNG_chunk_type_equals>
800057ba:	40 19       	lddsp	r9,sp[0x4]
800057bc:	18 98       	mov	r8,r12
800057be:	c3 30       	breq	80005824 <decodeGeneric+0x890>
     {
       if(decoder->settings.readTextChunks)
800057c0:	6e 38       	ld.w	r8,r7[0xc]
800057c2:	58 08       	cp.w	r8,0
800057c4:	fe 90 fe 29 	breq	80005416 <decodeGeneric+0x482>
       {
         char *key = 0, *str = 0;
 
         while(!decoder->error) /*not really a while loop, only used to break on error*/
800057c8:	ee f2 00 d0 	ld.w	r2,r7[208]
800057cc:	58 02       	cp.w	r2,0
800057ce:	c1 80       	breq	800057fe <decodeGeneric+0x86a>
800057d0:	12 93       	mov	r3,r9
800057d2:	12 90       	mov	r0,r9
           decoder->error = LodePNG_Text_add(&decoder->infoPng.text, key, str);
 
           break;
         }
 
         free(key);
800057d4:	00 9c       	mov	r12,r0
800057d6:	e0 a0 53 8b 	rcall	8000feec <free>
         free(str);
800057da:	06 9c       	mov	r12,r3
800057dc:	e0 a0 53 88 	rcall	8000feec <free>
800057e0:	02 92       	mov	r2,r1
800057e2:	30 0b       	mov	r11,0
800057e4:	40 ae       	lddsp	lr,sp[0x28]
800057e6:	fe 9f fd f0 	bral	800053c6 <decodeGeneric+0x432>
         decoder->infoPng.background_defined = 1;
         decoder->infoPng.background_r = decoder->infoPng.background_g = decoder->infoPng.background_b = 256 * data[0] + data[1];
       }
       else if(decoder->infoPng.color.colorType == 2 || decoder->infoPng.color.colorType == 6)
       {
         if(chunkLength != 6) { decoder->error = 45; break; } /*error: this chunk must be 6 bytes for greyscale image*/
800057ea:	32 d8       	mov	r8,45
800057ec:	ef 48 00 d0 	st.w	r7[208],r8
800057f0:	fe 9f fd 90 	bral	80005310 <decodeGeneric+0x37c>
     /*background color chunk (bKGD)*/
     else if(LodePNG_chunk_type_equals(chunk, "bKGD"))
     {
       if(decoder->infoPng.color.colorType == 3)
       {
         if(chunkLength != 1) { decoder->error = 43; break; } /*error: this chunk must be 1 byte for indexed color image*/
800057f4:	32 b8       	mov	r8,43
800057f6:	ef 48 00 d0 	st.w	r7[208],r8
800057fa:	fe 9f fd 8b 	bral	80005310 <decodeGeneric+0x37c>
     {
       if(decoder->settings.readTextChunks)
       {
         char *key = 0, *str = 0;
 
         while(!decoder->error) /*not really a while loop, only used to break on error*/
800057fe:	00 9b       	mov	r11,r0
80005800:	00 99       	mov	r9,r0
80005802:	c0 58       	rjmp	8000580c <decodeGeneric+0x878>
         {
           unsigned length, string2_begin;
 
           for(length = 0; length < chunkLength && data[length] != 0; length++) ;
80005804:	13 38       	ld.ub	r8,r9++
80005806:	58 08       	cp.w	r8,0
80005808:	c0 40       	breq	80005810 <decodeGeneric+0x87c>
8000580a:	2f f2       	sub	r2,-1
8000580c:	06 32       	cp.w	r2,r3
8000580e:	cf b3       	brcs	80005804 <decodeGeneric+0x870>
           if(length + 1 >= chunkLength) { decoder->error = 75; break; }
80005810:	e4 ca ff ff 	sub	r10,r2,-1
80005814:	06 3a       	cp.w	r10,r3
80005816:	c5 53       	brcs	800058c0 <decodeGeneric+0x92c>
80005818:	34 b8       	mov	r8,75
8000581a:	30 03       	mov	r3,0
8000581c:	ef 48 00 d0 	st.w	r7[208],r8
80005820:	06 90       	mov	r0,r3
80005822:	cd 9b       	rjmp	800057d4 <decodeGeneric+0x840>
         free(key);
         free(str);
       }
     }
     /*compressed text chunk (zTXt)*/
     else if(LodePNG_chunk_type_equals(chunk, "zTXt"))
80005824:	50 18       	stdsp	sp[0x4],r8
80005826:	fe fb 09 42 	ld.w	r11,pc[2370]
8000582a:	0c 9c       	mov	r12,r6
8000582c:	fe b0 f0 42 	rcall	800038b0 <LodePNG_chunk_type_equals>
80005830:	40 18       	lddsp	r8,sp[0x4]
80005832:	18 99       	mov	r9,r12
80005834:	c2 70       	breq	80005882 <decodeGeneric+0x8ee>
     {
       if(decoder->settings.readTextChunks)
80005836:	6e 39       	ld.w	r9,r7[0xc]
80005838:	58 09       	cp.w	r9,0
8000583a:	fe 90 fd ee 	breq	80005416 <decodeGeneric+0x482>
 #endif /*LODEPNG_COMPILE_PNG*/
 #endif /*LODEPNG_COMPILE_DECODER*/
 
 static void ucvector_init(ucvector* p)
 {
   p->data = NULL;
8000583e:	56 58       	stdsp	sp[0x194],r8
   p->size = p->allocsize = 0;
80005840:	56 78       	stdsp	sp[0x19c],r8
80005842:	56 68       	stdsp	sp[0x198],r8
         char *key = 0;
         ucvector decoded;
 
         ucvector_init(&decoded);
 
         while(!decoder->error) /*not really a while loop, only used to break on error*/
80005844:	ee f2 00 d0 	ld.w	r2,r7[208]
80005848:	58 02       	cp.w	r2,0
8000584a:	c1 30       	breq	80005870 <decodeGeneric+0x8dc>
8000584c:	50 58       	stdsp	sp[0x14],r8
           decoder->error = LodePNG_Text_add(&decoder->infoPng.text, key, (char*)decoded.data);
 
           break;
         }
 
         free(key);
8000584e:	40 5c       	lddsp	r12,sp[0x14]
           break;
         }
 
         free(key);
         free(langtag);
         free(transkey);
80005850:	e0 a0 53 4e 	rcall	8000feec <free>
   size_t allocsize; /*allocated size*/
 } ucvector;
 
 static void ucvector_cleanup(void* p)
 {
   ((ucvector*)p)->size = ((ucvector*)p)->allocsize = 0;
80005854:	30 03       	mov	r3,0
   free(((ucvector*)p)->data);
80005856:	46 5c       	lddsp	r12,sp[0x194]
   size_t allocsize; /*allocated size*/
 } ucvector;
 
 static void ucvector_cleanup(void* p)
 {
   ((ucvector*)p)->size = ((ucvector*)p)->allocsize = 0;
80005858:	56 73       	stdsp	sp[0x19c],r3
8000585a:	56 63       	stdsp	sp[0x198],r3
   free(((ucvector*)p)->data);
8000585c:	e0 a0 53 48 	rcall	8000feec <free>
   ((ucvector*)p)->data = NULL;
80005860:	56 53       	stdsp	sp[0x194],r3
 
         free(key);
         free(langtag);
         free(transkey);
         ucvector_cleanup(&decoded);
         if(decoder->error) break;
80005862:	ee f8 00 d0 	ld.w	r8,r7[208]
80005866:	58 08       	cp.w	r8,0
80005868:	fe 90 fd d7 	breq	80005416 <decodeGeneric+0x482>
8000586c:	fe 9f fd 52 	bral	80005310 <decodeGeneric+0x37c>
         char *key = 0;
         ucvector decoded;
 
         ucvector_init(&decoded);
 
         while(!decoder->error) /*not really a while loop, only used to break on error*/
80005870:	00 9a       	mov	r10,r0
80005872:	00 99       	mov	r9,r0
         {
           for(length = 0; length < chunkLength && data[length] != 0; length++) ;
80005874:	06 32       	cp.w	r2,r3
80005876:	c3 a2       	brcc	800058ea <decodeGeneric+0x956>
80005878:	13 38       	ld.ub	r8,r9++
8000587a:	58 08       	cp.w	r8,0
8000587c:	c3 70       	breq	800058ea <decodeGeneric+0x956>
8000587e:	2f f2       	sub	r2,-1
80005880:	cf ab       	rjmp	80005874 <decodeGeneric+0x8e0>
         ucvector_cleanup(&decoded);
         if(decoder->error) break;
       }
     }
     /*international text chunk (iTXt)*/
     else if(LodePNG_chunk_type_equals(chunk, "iTXt"))
80005882:	50 19       	stdsp	sp[0x4],r9
80005884:	fe fb 08 e8 	ld.w	r11,pc[2280]
80005888:	0c 9c       	mov	r12,r6
8000588a:	fe b0 f0 13 	rcall	800038b0 <LodePNG_chunk_type_equals>
8000588e:	40 19       	lddsp	r9,sp[0x4]
80005890:	18 98       	mov	r8,r12
80005892:	c7 90       	breq	80005984 <decodeGeneric+0x9f0>
     {
       if(decoder->settings.readTextChunks)
80005894:	6e 38       	ld.w	r8,r7[0xc]
80005896:	58 08       	cp.w	r8,0
80005898:	fe 90 fd bf 	breq	80005416 <decodeGeneric+0x482>
 #endif /*LODEPNG_COMPILE_PNG*/
 #endif /*LODEPNG_COMPILE_DECODER*/
 
 static void ucvector_init(ucvector* p)
 {
   p->data = NULL;
8000589c:	56 59       	stdsp	sp[0x194],r9
   p->size = p->allocsize = 0;
8000589e:	56 79       	stdsp	sp[0x19c],r9
800058a0:	56 69       	stdsp	sp[0x198],r9
         unsigned length, begin, compressed;
         char *key = 0, *langtag = 0, *transkey = 0;
         ucvector decoded;
         ucvector_init(&decoded);
 
         while(!decoder->error) /*not really a while loop, only used to break on error*/
800058a2:	ee f2 00 d0 	ld.w	r2,r7[208]
800058a6:	58 02       	cp.w	r2,0
800058a8:	c3 30       	breq	8000590e <decodeGeneric+0x97a>
800058aa:	12 92       	mov	r2,r9
800058ac:	50 59       	stdsp	sp[0x14],r9
800058ae:	50 89       	stdsp	sp[0x20],r9
           decoder->error = LodePNG_IText_add(&decoder->infoPng.itext, key, langtag, transkey, (char*)decoded.data);
 
           break;
         }
 
         free(key);
800058b0:	40 8c       	lddsp	r12,sp[0x20]
800058b2:	e0 a0 53 1d 	rcall	8000feec <free>
         free(langtag);
800058b6:	40 5c       	lddsp	r12,sp[0x14]
800058b8:	e0 a0 53 1a 	rcall	8000feec <free>
         free(transkey);
800058bc:	04 9c       	mov	r12,r2
800058be:	cc 9b       	rjmp	80005850 <decodeGeneric+0x8bc>
         {
           unsigned length, string2_begin;
 
           for(length = 0; length < chunkLength && data[length] != 0; length++) ;
           if(length + 1 >= chunkLength) { decoder->error = 75; break; }
           key = (char*)malloc(length + 1);
800058c0:	14 9c       	mov	r12,r10
800058c2:	50 1b       	stdsp	sp[0x4],r11
800058c4:	50 0a       	stdsp	sp[0x0],r10
800058c6:	e0 a0 53 1b 	rcall	8000fefc <malloc>
800058ca:	50 5c       	stdsp	sp[0x14],r12
800058cc:	18 90       	mov	r0,r12
           if(!key) { decoder->error = 9938; break; }
800058ce:	40 1b       	lddsp	r11,sp[0x4]
800058d0:	40 0a       	lddsp	r10,sp[0x0]
800058d2:	c3 80       	breq	80005942 <decodeGeneric+0x9ae>
           key[length] = 0;
800058d4:	f8 02 0b 04 	st.b	r12[r2],r4
800058d8:	30 09       	mov	r9,0
           for(i = 0; i < length; i++) key[i] = data[i];
800058da:	04 39       	cp.w	r9,r2
800058dc:	c1 12       	brcc	800058fe <decodeGeneric+0x96a>
800058de:	17 38       	ld.ub	r8,r11++
800058e0:	40 5e       	lddsp	lr,sp[0x14]
800058e2:	fc 09 0b 08 	st.b	lr[r9],r8
800058e6:	2f f9       	sub	r9,-1
800058e8:	cf 9b       	rjmp	800058da <decodeGeneric+0x946>
         ucvector_init(&decoded);
 
         while(!decoder->error) /*not really a while loop, only used to break on error*/
         {
           for(length = 0; length < chunkLength && data[length] != 0; length++) ;
           if(length + 2 >= chunkLength) { decoder->error = 75; break; }
800058ea:	e4 cb ff fe 	sub	r11,r2,-2
800058ee:	06 3b       	cp.w	r11,r3
800058f0:	c2 f3       	brcs	8000594e <decodeGeneric+0x9ba>
800058f2:	34 b8       	mov	r8,75
800058f4:	ef 48 00 d0 	st.w	r7[208],r8
800058f8:	30 0c       	mov	r12,0
800058fa:	50 5c       	stdsp	sp[0x14],r12
800058fc:	ca 9b       	rjmp	8000584e <decodeGeneric+0x8ba>
           if(!key) { decoder->error = 9938; break; }
           key[length] = 0;
           for(i = 0; i < length; i++) key[i] = data[i];
 
           string2_begin = length + 1;
           if(string2_begin > chunkLength)  { decoder->error = 75; break; }
800058fe:	06 3a       	cp.w	r10,r3
80005900:	e0 88 00 6b 	brls	800059d6 <decodeGeneric+0xa42>
80005904:	34 b8       	mov	r8,75
80005906:	30 03       	mov	r3,0
80005908:	ef 48 00 d0 	st.w	r7[208],r8
8000590c:	c6 4b       	rjmp	800057d4 <decodeGeneric+0x840>
         ucvector decoded;
         ucvector_init(&decoded);
 
         while(!decoder->error) /*not really a while loop, only used to break on error*/
         {
           if(chunkLength < 5) { decoder->error = 76; break; }
8000590e:	58 43       	cp.w	r3,4
80005910:	e0 88 00 d7 	brls	80005abe <decodeGeneric+0xb2a>
80005914:	00 9a       	mov	r10,r0
80005916:	00 99       	mov	r9,r0
           for(length = 0; length < chunkLength && data[length] != 0; length++) ;
80005918:	13 88       	ld.ub	r8,r9[0x0]
8000591a:	e8 08 18 00 	cp.b	r8,r4
8000591e:	c0 50       	breq	80005928 <decodeGeneric+0x994>
80005920:	2f f2       	sub	r2,-1
80005922:	2f f9       	sub	r9,-1
80005924:	06 32       	cp.w	r2,r3
80005926:	cf 93       	brcs	80005918 <decodeGeneric+0x984>
           if(length + 2 >= chunkLength) { decoder->error = 75; break; }
80005928:	e4 cb ff fe 	sub	r11,r2,-2
8000592c:	50 5b       	stdsp	sp[0x14],r11
8000592e:	06 3b       	cp.w	r11,r3
80005930:	e0 83 00 cd 	brlo	80005aca <decodeGeneric+0xb36>
80005934:	34 b8       	mov	r8,75
80005936:	ef 48 00 d0 	st.w	r7[208],r8
8000593a:	30 02       	mov	r2,0
8000593c:	50 52       	stdsp	sp[0x14],r2
8000593e:	50 82       	stdsp	sp[0x20],r2
80005940:	cb 8b       	rjmp	800058b0 <decodeGeneric+0x91c>
           unsigned length, string2_begin;
 
           for(length = 0; length < chunkLength && data[length] != 0; length++) ;
           if(length + 1 >= chunkLength) { decoder->error = 75; break; }
           key = (char*)malloc(length + 1);
           if(!key) { decoder->error = 9938; break; }
80005942:	e0 68 26 d2 	mov	r8,9938
80005946:	18 93       	mov	r3,r12
80005948:	ef 48 00 d0 	st.w	r7[208],r8
8000594c:	c4 4b       	rjmp	800057d4 <decodeGeneric+0x840>
 
         while(!decoder->error) /*not really a while loop, only used to break on error*/
         {
           for(length = 0; length < chunkLength && data[length] != 0; length++) ;
           if(length + 2 >= chunkLength) { decoder->error = 75; break; }
           key = (char*)malloc(length + 1);
8000594e:	e4 c9 ff ff 	sub	r9,r2,-1
80005952:	50 1b       	stdsp	sp[0x4],r11
80005954:	50 0a       	stdsp	sp[0x0],r10
80005956:	50 b9       	stdsp	sp[0x2c],r9
80005958:	12 9c       	mov	r12,r9
8000595a:	e0 a0 52 d1 	rcall	8000fefc <malloc>
8000595e:	50 5c       	stdsp	sp[0x14],r12
80005960:	50 8c       	stdsp	sp[0x20],r12
           if(!key) { decoder->error = 9940; break; }
80005962:	40 1b       	lddsp	r11,sp[0x4]
80005964:	40 0a       	lddsp	r10,sp[0x0]
80005966:	e0 80 00 d4 	breq	80005b0e <decodeGeneric+0xb7a>
           key[length] = 0;
8000596a:	40 58       	lddsp	r8,sp[0x14]
8000596c:	30 09       	mov	r9,0
8000596e:	f0 02 0b 04 	st.b	r8[r2],r4
           for(i = 0; i < length; i++) key[i] = data[i];
80005972:	04 39       	cp.w	r9,r2
80005974:	e0 82 00 c3 	brhs	80005afa <decodeGeneric+0xb66>
80005978:	15 38       	ld.ub	r8,r10++
8000597a:	40 8e       	lddsp	lr,sp[0x20]
8000597c:	fc 09 0b 08 	st.b	lr[r9],r8
80005980:	2f f9       	sub	r9,-1
80005982:	cf 8b       	rjmp	80005972 <decodeGeneric+0x9de>
         free(transkey);
         ucvector_cleanup(&decoded);
         if(decoder->error) break;
       }
     }
     else if(LodePNG_chunk_type_equals(chunk, "tIME"))
80005984:	50 18       	stdsp	sp[0x4],r8
80005986:	fe fb 07 ea 	ld.w	r11,pc[2026]
8000598a:	0c 9c       	mov	r12,r6
8000598c:	fe b0 ef 92 	rcall	800038b0 <LodePNG_chunk_type_equals>
80005990:	40 18       	lddsp	r8,sp[0x4]
80005992:	18 99       	mov	r9,r12
80005994:	c3 e0       	breq	80005a10 <decodeGeneric+0xa7c>
     {
       if(chunkLength != 7) { decoder->error = 73; break; }
80005996:	58 73       	cp.w	r3,7
80005998:	c3 71       	brne	80005a06 <decodeGeneric+0xa72>
       decoder->infoPng.time.year = 256 * data[0] + data[+ 1];
       decoder->infoPng.time.month = data[2];
       decoder->infoPng.time.day = data[3];
       decoder->infoPng.time.hour = data[4];
       decoder->infoPng.time.minute = data[5];
       decoder->infoPng.time.second = data[6];
8000599a:	10 9b       	mov	r11,r8
       }
     }
     else if(LodePNG_chunk_type_equals(chunk, "tIME"))
     {
       if(chunkLength != 7) { decoder->error = 73; break; }
       decoder->infoPng.time_defined = 1;
8000599c:	30 18       	mov	r8,1
8000599e:	ef 68 00 98 	st.b	r7[152],r8
       decoder->infoPng.time.year = 256 * data[0] + data[+ 1];
800059a2:	01 99       	ld.ub	r9,r0[0x1]
800059a4:	01 88       	ld.ub	r8,r0[0x0]
800059a6:	a9 68       	lsl	r8,0x8
800059a8:	f2 08 00 08 	add	r8,r9,r8
800059ac:	ef 48 00 9c 	st.w	r7[156],r8
       decoder->infoPng.time.month = data[2];
800059b0:	01 a8       	ld.ub	r8,r0[0x2]
800059b2:	ef 68 00 a0 	st.b	r7[160],r8
       decoder->infoPng.time.day = data[3];
800059b6:	01 b8       	ld.ub	r8,r0[0x3]
800059b8:	ef 68 00 a1 	st.b	r7[161],r8
       decoder->infoPng.time.hour = data[4];
800059bc:	01 c8       	ld.ub	r8,r0[0x4]
800059be:	ef 68 00 a2 	st.b	r7[162],r8
       decoder->infoPng.time.minute = data[5];
800059c2:	01 d8       	ld.ub	r8,r0[0x5]
       decoder->infoPng.time.second = data[6];
800059c4:	02 92       	mov	r2,r1
       decoder->infoPng.time_defined = 1;
       decoder->infoPng.time.year = 256 * data[0] + data[+ 1];
       decoder->infoPng.time.month = data[2];
       decoder->infoPng.time.day = data[3];
       decoder->infoPng.time.hour = data[4];
       decoder->infoPng.time.minute = data[5];
800059c6:	ef 68 00 a3 	st.b	r7[163],r8
       decoder->infoPng.time.second = data[6];
800059ca:	01 e8       	ld.ub	r8,r0[0x6]
800059cc:	ef 68 00 a4 	st.b	r7[164],r8
800059d0:	40 ae       	lddsp	lr,sp[0x28]
800059d2:	fe 9f fc fa 	bral	800053c6 <decodeGeneric+0x432>
           key[length] = 0;
           for(i = 0; i < length; i++) key[i] = data[i];
 
           string2_begin = length + 1;
           if(string2_begin > chunkLength)  { decoder->error = 75; break; }
           length = chunkLength - string2_begin;
800059d6:	e6 0a 01 0b 	sub	r11,r3,r10
           str = (char*)malloc(length + 1);
800059da:	f6 cc ff ff 	sub	r12,r11,-1
800059de:	50 1b       	stdsp	sp[0x4],r11
800059e0:	e0 a0 52 8e 	rcall	8000fefc <malloc>
           if(!str) { decoder->error = 9939; break; }
800059e4:	40 1b       	lddsp	r11,sp[0x4]
           for(i = 0; i < length; i++) key[i] = data[i];
 
           string2_begin = length + 1;
           if(string2_begin > chunkLength)  { decoder->error = 75; break; }
           length = chunkLength - string2_begin;
           str = (char*)malloc(length + 1);
800059e6:	18 93       	mov	r3,r12
800059e8:	18 9a       	mov	r10,r12
           if(!str) { decoder->error = 9939; break; }
800059ea:	c5 30       	breq	80005a90 <decodeGeneric+0xafc>
           str[length] = 0;
800059ec:	2f 72       	sub	r2,-9
800059ee:	f8 0b 0b 04 	st.b	r12[r11],r4
800059f2:	ec 02 00 02 	add	r2,r6,r2
800059f6:	30 08       	mov	r8,0
           for(i = 0; i < length; i++) str[i] = data[string2_begin + i];
800059f8:	16 38       	cp.w	r8,r11
800059fa:	c4 42       	brcc	80005a82 <decodeGeneric+0xaee>
800059fc:	05 39       	ld.ub	r9,r2++
800059fe:	f4 08 0b 09 	st.b	r10[r8],r9
80005a02:	2f f8       	sub	r8,-1
80005a04:	cf ab       	rjmp	800059f8 <decodeGeneric+0xa64>
         if(decoder->error) break;
       }
     }
     else if(LodePNG_chunk_type_equals(chunk, "tIME"))
     {
       if(chunkLength != 7) { decoder->error = 73; break; }
80005a06:	34 98       	mov	r8,73
80005a08:	ef 48 00 d0 	st.w	r7[208],r8
80005a0c:	fe 9f fc 82 	bral	80005310 <decodeGeneric+0x37c>
       decoder->infoPng.time.day = data[3];
       decoder->infoPng.time.hour = data[4];
       decoder->infoPng.time.minute = data[5];
       decoder->infoPng.time.second = data[6];
     }
     else if(LodePNG_chunk_type_equals(chunk, "pHYs"))
80005a10:	50 19       	stdsp	sp[0x4],r9
80005a12:	fe fb 07 62 	ld.w	r11,pc[1890]
80005a16:	0c 9c       	mov	r12,r6
80005a18:	fe b0 ef 4c 	rcall	800038b0 <LodePNG_chunk_type_equals>
80005a1c:	40 19       	lddsp	r9,sp[0x4]
80005a1e:	c4 30       	breq	80005aa4 <decodeGeneric+0xb10>
     {
       if(chunkLength != 9) { decoder->error = 74; break; }
80005a20:	58 93       	cp.w	r3,9
80005a22:	c3 c1       	brne	80005a9a <decodeGeneric+0xb06>
       decoder->infoPng.phys_defined = 1;
80005a24:	30 18       	mov	r8,1
       decoder->infoPng.phys_x = 16777216 * data[0] + 65536 * data[1] + 256 * data[2] + data[3];
       decoder->infoPng.phys_y = 16777216 * data[4] + 65536 * data[5] + 256 * data[6] + data[7];
       decoder->infoPng.phys_unit = data[8];
80005a26:	12 9b       	mov	r11,r9
       decoder->infoPng.time.second = data[6];
     }
     else if(LodePNG_chunk_type_equals(chunk, "pHYs"))
     {
       if(chunkLength != 9) { decoder->error = 74; break; }
       decoder->infoPng.phys_defined = 1;
80005a28:	ef 48 00 a8 	st.w	r7[168],r8
       decoder->infoPng.phys_x = 16777216 * data[0] + 65536 * data[1] + 256 * data[2] + data[3];
80005a2c:	01 99       	ld.ub	r9,r0[0x1]
80005a2e:	01 88       	ld.ub	r8,r0[0x0]
80005a30:	a9 68       	lsl	r8,0x8
80005a32:	f2 08 00 08 	add	r8,r9,r8
80005a36:	f0 09 15 08 	lsl	r9,r8,0x8
80005a3a:	01 a8       	ld.ub	r8,r0[0x2]
80005a3c:	f2 08 00 08 	add	r8,r9,r8
80005a40:	f0 09 15 08 	lsl	r9,r8,0x8
80005a44:	01 b8       	ld.ub	r8,r0[0x3]
80005a46:	f2 08 00 08 	add	r8,r9,r8
80005a4a:	ef 48 00 ac 	st.w	r7[172],r8
       decoder->infoPng.phys_y = 16777216 * data[4] + 65536 * data[5] + 256 * data[6] + data[7];
80005a4e:	01 c8       	ld.ub	r8,r0[0x4]
80005a50:	f0 09 15 08 	lsl	r9,r8,0x8
80005a54:	01 d8       	ld.ub	r8,r0[0x5]
80005a56:	f2 08 00 08 	add	r8,r9,r8
80005a5a:	f0 09 15 08 	lsl	r9,r8,0x8
80005a5e:	01 e8       	ld.ub	r8,r0[0x6]
80005a60:	f2 08 00 08 	add	r8,r9,r8
80005a64:	f0 09 15 08 	lsl	r9,r8,0x8
80005a68:	01 f8       	ld.ub	r8,r0[0x7]
80005a6a:	f2 08 00 08 	add	r8,r9,r8
       decoder->infoPng.phys_unit = data[8];
80005a6e:	02 92       	mov	r2,r1
     else if(LodePNG_chunk_type_equals(chunk, "pHYs"))
     {
       if(chunkLength != 9) { decoder->error = 74; break; }
       decoder->infoPng.phys_defined = 1;
       decoder->infoPng.phys_x = 16777216 * data[0] + 65536 * data[1] + 256 * data[2] + data[3];
       decoder->infoPng.phys_y = 16777216 * data[4] + 65536 * data[5] + 256 * data[6] + data[7];
80005a70:	ef 48 00 b0 	st.w	r7[176],r8
       decoder->infoPng.phys_unit = data[8];
80005a74:	e1 38 00 08 	ld.ub	r8,r0[8]
80005a78:	ef 68 00 b4 	st.b	r7[180],r8
80005a7c:	40 ae       	lddsp	lr,sp[0x28]
80005a7e:	fe 9f fc a4 	bral	800053c6 <decodeGeneric+0x432>
           str = (char*)malloc(length + 1);
           if(!str) { decoder->error = 9939; break; }
           str[length] = 0;
           for(i = 0; i < length; i++) str[i] = data[string2_begin + i];
 
           decoder->error = LodePNG_Text_add(&decoder->infoPng.text, key, str);
80005a82:	40 5b       	lddsp	r11,sp[0x14]
80005a84:	41 4c       	lddsp	r12,sp[0x50]
80005a86:	fe b0 f9 ff 	rcall	80004e84 <LodePNG_Text_add>
80005a8a:	ef 4c 00 d0 	st.w	r7[208],r12
 
           break;
80005a8e:	ca 3a       	rjmp	800057d4 <decodeGeneric+0x840>
 
           string2_begin = length + 1;
           if(string2_begin > chunkLength)  { decoder->error = 75; break; }
           length = chunkLength - string2_begin;
           str = (char*)malloc(length + 1);
           if(!str) { decoder->error = 9939; break; }
80005a90:	e0 68 26 d3 	mov	r8,9939
80005a94:	ef 48 00 d0 	st.w	r7[208],r8
80005a98:	c9 ea       	rjmp	800057d4 <decodeGeneric+0x840>
       decoder->infoPng.time.minute = data[5];
       decoder->infoPng.time.second = data[6];
     }
     else if(LodePNG_chunk_type_equals(chunk, "pHYs"))
     {
       if(chunkLength != 9) { decoder->error = 74; break; }
80005a9a:	34 a8       	mov	r8,74
80005a9c:	ef 48 00 d0 	st.w	r7[208],r8
80005aa0:	fe 9f fc 38 	bral	80005310 <decodeGeneric+0x37c>
       decoder->infoPng.phys_unit = data[8];
     }
 #endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
     else /*it's not an implemented chunk type, so ignore it: skip over the data*/
     {
       if(LodePNG_chunk_critical(chunk)) { decoder->error = 69; break; } /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/
80005aa4:	e2 12 00 20 	andl	r2,0x20,COH
80005aa8:	c7 60       	breq	80005b94 <decodeGeneric+0xc00>
       unknown = 1;
 #ifdef LODEPNG_COMPILE_UNKNOWN_CHUNKS
       if(decoder->settings.rememberUnknownChunks)
80005aaa:	6e 48       	ld.w	r8,r7[0x10]
80005aac:	58 08       	cp.w	r8,0
80005aae:	c3 c1       	brne	80005b26 <decodeGeneric+0xb92>
       {
         LodePNG_UnknownChunks* unknown = &decoder->infoPng.unknown_chunks;
         decoder->error = LodePNG_append_chunk(&unknown->data[critical_pos - 1], &unknown->datasize[critical_pos - 1], chunk);
         if(decoder->error) break;
80005ab0:	30 19       	mov	r9,1
80005ab2:	02 92       	mov	r2,r1
80005ab4:	50 a9       	stdsp	sp[0x28],r9
80005ab6:	30 0b       	mov	r11,0
80005ab8:	12 9e       	mov	lr,r9
80005aba:	fe 9f fc 86 	bral	800053c6 <decodeGeneric+0x432>
         ucvector decoded;
         ucvector_init(&decoded);
 
         while(!decoder->error) /*not really a while loop, only used to break on error*/
         {
           if(chunkLength < 5) { decoder->error = 76; break; }
80005abe:	34 c8       	mov	r8,76
80005ac0:	ef 48 00 d0 	st.w	r7[208],r8
80005ac4:	50 52       	stdsp	sp[0x14],r2
80005ac6:	50 82       	stdsp	sp[0x20],r2
80005ac8:	cf 4a       	rjmp	800058b0 <decodeGeneric+0x91c>
           for(length = 0; length < chunkLength && data[length] != 0; length++) ;
           if(length + 2 >= chunkLength) { decoder->error = 75; break; }
           key = (char*)malloc(length + 1);
80005aca:	e4 cb ff ff 	sub	r11,r2,-1
80005ace:	50 0a       	stdsp	sp[0x0],r10
80005ad0:	16 9c       	mov	r12,r11
80005ad2:	50 1b       	stdsp	sp[0x4],r11
80005ad4:	e0 a0 52 14 	rcall	8000fefc <malloc>
80005ad8:	50 8c       	stdsp	sp[0x20],r12
80005ada:	51 3c       	stdsp	sp[0x4c],r12
           if(!key) { decoder->error = 9941; break; }
80005adc:	40 1b       	lddsp	r11,sp[0x4]
80005ade:	40 0a       	lddsp	r10,sp[0x0]
80005ae0:	c4 20       	breq	80005b64 <decodeGeneric+0xbd0>
           key[length] = 0;
80005ae2:	40 89       	lddsp	r9,sp[0x20]
80005ae4:	f2 02 0b 04 	st.b	r9[r2],r4
80005ae8:	30 09       	mov	r9,0
           for(i = 0; i < length; i++) key[i] = data[i];
80005aea:	04 39       	cp.w	r9,r2
80005aec:	c2 d2       	brcc	80005b46 <decodeGeneric+0xbb2>
80005aee:	15 38       	ld.ub	r8,r10++
80005af0:	41 3e       	lddsp	lr,sp[0x4c]
80005af2:	fc 09 0b 08 	st.b	lr[r9],r8
80005af6:	2f f9       	sub	r9,-1
80005af8:	cf 9b       	rjmp	80005aea <decodeGeneric+0xb56>
           key = (char*)malloc(length + 1);
           if(!key) { decoder->error = 9940; break; }
           key[length] = 0;
           for(i = 0; i < length; i++) key[i] = data[i];
 
           if(data[length + 1] != 0) { decoder->error = 72; break; } /*the 0 byte indicating compression must be 0*/
80005afa:	40 bc       	lddsp	r12,sp[0x2c]
80005afc:	e0 0c 07 02 	ld.ub	r2,r0[r12]
80005b00:	e8 02 18 00 	cp.b	r2,r4
80005b04:	c0 a0       	breq	80005b18 <decodeGeneric+0xb84>
80005b06:	34 88       	mov	r8,72
80005b08:	ef 48 00 d0 	st.w	r7[208],r8
80005b0c:	ca 1a       	rjmp	8000584e <decodeGeneric+0x8ba>
         while(!decoder->error) /*not really a while loop, only used to break on error*/
         {
           for(length = 0; length < chunkLength && data[length] != 0; length++) ;
           if(length + 2 >= chunkLength) { decoder->error = 75; break; }
           key = (char*)malloc(length + 1);
           if(!key) { decoder->error = 9940; break; }
80005b0e:	e0 68 26 d4 	mov	r8,9940
80005b12:	ef 48 00 d0 	st.w	r7[208],r8
80005b16:	c9 ca       	rjmp	8000584e <decodeGeneric+0x8ba>
           for(i = 0; i < length; i++) key[i] = data[i];
 
           if(data[length + 1] != 0) { decoder->error = 72; break; } /*the 0 byte indicating compression must be 0*/
 
           string2_begin = length + 2;
           if(string2_begin > chunkLength)  { decoder->error = 75; break; }
80005b18:	06 3b       	cp.w	r11,r3
80005b1a:	e0 88 00 42 	brls	80005b9e <decodeGeneric+0xc0a>
80005b1e:	34 b8       	mov	r8,75
80005b20:	ef 48 00 d0 	st.w	r7[208],r8
80005b24:	c9 5a       	rjmp	8000584e <decodeGeneric+0x8ba>
       unknown = 1;
 #ifdef LODEPNG_COMPILE_UNKNOWN_CHUNKS
       if(decoder->settings.rememberUnknownChunks)
       {
         LodePNG_UnknownChunks* unknown = &decoder->infoPng.unknown_chunks;
         decoder->error = LodePNG_append_chunk(&unknown->data[critical_pos - 1], &unknown->datasize[critical_pos - 1], chunk);
80005b26:	40 9b       	lddsp	r11,sp[0x24]
80005b28:	40 9c       	lddsp	r12,sp[0x24]
80005b2a:	2d 0b       	sub	r11,-48
80005b2c:	2d 3c       	sub	r12,-45
80005b2e:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
80005b32:	ee 0c 00 2c 	add	r12,r7,r12<<0x2
80005b36:	0c 9a       	mov	r10,r6
80005b38:	fe b0 ed aa 	rcall	8000368c <LodePNG_append_chunk>
80005b3c:	ef 4c 00 d0 	st.w	r7[208],r12
         if(decoder->error) break;
80005b40:	cb 80       	breq	80005ab0 <decodeGeneric+0xb1c>
80005b42:	fe 9f fb e7 	bral	80005310 <decodeGeneric+0x37c>
           key = (char*)malloc(length + 1);
           if(!key) { decoder->error = 9941; break; }
           key[length] = 0;
           for(i = 0; i < length; i++) key[i] = data[i];
 
           compressed = data[length + 1];
80005b46:	e0 0b 07 0b 	ld.ub	r11,r0[r11]
80005b4a:	50 bb       	stdsp	sp[0x2c],r11
           if(data[length + 2] != 0) { decoder->error = 72; break; } /*the 0 byte indicating compression must be 0*/
80005b4c:	40 5c       	lddsp	r12,sp[0x14]
80005b4e:	e0 0c 07 08 	ld.ub	r8,r0[r12]
80005b52:	e8 08 18 00 	cp.b	r8,r4
80005b56:	c0 e0       	breq	80005b72 <decodeGeneric+0xbde>
80005b58:	34 88       	mov	r8,72
80005b5a:	ef 48 00 d0 	st.w	r7[208],r8
80005b5e:	30 02       	mov	r2,0
80005b60:	50 52       	stdsp	sp[0x14],r2
80005b62:	ca 7a       	rjmp	800058b0 <decodeGeneric+0x91c>
         {
           if(chunkLength < 5) { decoder->error = 76; break; }
           for(length = 0; length < chunkLength && data[length] != 0; length++) ;
           if(length + 2 >= chunkLength) { decoder->error = 75; break; }
           key = (char*)malloc(length + 1);
           if(!key) { decoder->error = 9941; break; }
80005b64:	e0 68 26 d5 	mov	r8,9941
80005b68:	ef 48 00 d0 	st.w	r7[208],r8
80005b6c:	50 5c       	stdsp	sp[0x14],r12
80005b6e:	40 82       	lddsp	r2,sp[0x20]
80005b70:	ca 0a       	rjmp	800058b0 <decodeGeneric+0x91c>
           for(i = 0; i < length; i++) key[i] = data[i];
 
           compressed = data[length + 1];
           if(data[length + 2] != 0) { decoder->error = 72; break; } /*the 0 byte indicating compression must be 0*/
 
           begin = length + 3;
80005b72:	e4 c8 ff f5 	sub	r8,r2,-11
80005b76:	e4 cc ff fd 	sub	r12,r2,-3
80005b7a:	ec 08 00 0a 	add	r10,r6,r8
80005b7e:	18 99       	mov	r9,r12
80005b80:	14 9b       	mov	r11,r10
80005b82:	30 02       	mov	r2,0
           length = 0;
           for(i = begin; i < chunkLength && data[i] != 0; i++) length++;
80005b84:	06 39       	cp.w	r9,r3
80005b86:	c3 02       	brcc	80005be6 <decodeGeneric+0xc52>
80005b88:	2f f9       	sub	r9,-1
80005b8a:	17 38       	ld.ub	r8,r11++
80005b8c:	58 08       	cp.w	r8,0
80005b8e:	c2 c0       	breq	80005be6 <decodeGeneric+0xc52>
80005b90:	2f f2       	sub	r2,-1
80005b92:	cf 9b       	rjmp	80005b84 <decodeGeneric+0xbf0>
       decoder->infoPng.phys_unit = data[8];
     }
 #endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
     else /*it's not an implemented chunk type, so ignore it: skip over the data*/
     {
       if(LodePNG_chunk_critical(chunk)) { decoder->error = 69; break; } /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/
80005b94:	34 58       	mov	r8,69
80005b96:	ef 48 00 d0 	st.w	r7[208],r8
80005b9a:	fe 9f fb bb 	bral	80005310 <decodeGeneric+0x37c>
 */
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned LodePNG_decompress(unsigned char** out, size_t* outsize, const unsigned char* in, size_t insize, const LodeZlib_DecompressSettings* settings)
 {
   return LodeZlib_decompress(out, outsize, in, insize, settings);
80005b9e:	e6 0b 01 09 	sub	r9,r3,r11
80005ba2:	e0 0b 00 0a 	add	r10,r0,r11
80005ba6:	fa c3 fe 6c 	sub	r3,sp,-404
80005baa:	0e 98       	mov	r8,r7
80005bac:	fa cb fe 68 	sub	r11,sp,-408
80005bb0:	06 9c       	mov	r12,r3
80005bb2:	fe b0 f6 ab 	rcall	80004908 <LodeZlib_decompress>
           if(data[length + 1] != 0) { decoder->error = 72; break; } /*the 0 byte indicating compression must be 0*/
 
           string2_begin = length + 2;
           if(string2_begin > chunkLength)  { decoder->error = 75; break; }
           length = chunkLength - string2_begin;
           decoder->error = LodePNG_decompress(&decoded.data, &decoded.size, (unsigned char*)(&data[string2_begin]), length, &decoder->settings.zlibsettings);
80005bb6:	ef 4c 00 d0 	st.w	r7[208],r12
           if(decoder->error) break;
80005bba:	fe 91 fe 4a 	brne	8000584e <decodeGeneric+0x8ba>
 }
 #endif /*LODEPNG_COMPILE_ZLIB*/
 
 static unsigned ucvector_push_back(ucvector* p, unsigned char c) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(!ucvector_resize(p, p->size + 1)) return 0;
80005bbe:	46 6b       	lddsp	r11,sp[0x198]
80005bc0:	06 9c       	mov	r12,r3
80005bc2:	2f fb       	sub	r11,-1
80005bc4:	fe b0 ed 3c 	rcall	8000363c <ucvector_resize>
80005bc8:	c0 60       	breq	80005bd4 <decodeGeneric+0xc40>
   p->data[p->size - 1] = c;
80005bca:	46 69       	lddsp	r9,sp[0x198]
80005bcc:	46 58       	lddsp	r8,sp[0x194]
80005bce:	12 08       	add	r8,r9
80005bd0:	f1 62 ff ff 	st.b	r8[-1],r2
           length = chunkLength - string2_begin;
           decoder->error = LodePNG_decompress(&decoded.data, &decoded.size, (unsigned char*)(&data[string2_begin]), length, &decoder->settings.zlibsettings);
           if(decoder->error) break;
           ucvector_push_back(&decoded, 0);
 
           decoder->error = LodePNG_Text_add(&decoder->infoPng.text, key, (char*)decoded.data);
80005bd4:	40 8b       	lddsp	r11,sp[0x20]
80005bd6:	46 5a       	lddsp	r10,sp[0x194]
80005bd8:	41 4c       	lddsp	r12,sp[0x50]
80005bda:	fe b0 f9 55 	rcall	80004e84 <LodePNG_Text_add>
80005bde:	ef 4c 00 d0 	st.w	r7[208],r12
 
           break;
80005be2:	fe 9f fe 36 	bral	8000584e <decodeGeneric+0x8ba>
           if(data[length + 2] != 0) { decoder->error = 72; break; } /*the 0 byte indicating compression must be 0*/
 
           begin = length + 3;
           length = 0;
           for(i = begin; i < chunkLength && data[i] != 0; i++) length++;
           if(begin + length + 1 >= chunkLength) { decoder->error = 75; break; }
80005be6:	f8 c8 ff ff 	sub	r8,r12,-1
80005bea:	f0 02 00 0b 	add	r11,r8,r2
80005bee:	06 3b       	cp.w	r11,r3
80005bf0:	e0 83 01 08 	brlo	80005e00 <decodeGeneric+0xe6c>
80005bf4:	34 b8       	mov	r8,75
80005bf6:	ef 48 00 d0 	st.w	r7[208],r8
80005bfa:	30 02       	mov	r2,0
80005bfc:	50 52       	stdsp	sp[0x14],r2
80005bfe:	fe 9f fe 59 	bral	800058b0 <decodeGeneric+0x91c>
 
 static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)
 {
   /*the current bit in bitstream may be 0 or 1 for this to work*/
   if(bit == 0) bitstream[(*bitpointer) >> 3] &=  (unsigned char)(~(1 << (7 - ((*bitpointer) & 0x7))));
   else bitstream[(*bitpointer) >> 3] |=  (1 << (7 - ((*bitpointer) & 0x7)));
80005c02:	fc 09 01 00 	sub	r0,lr,r9
80005c06:	07 81       	ld.ub	r1,r3[0x0]
80005c08:	e1 d0 c0 03 	bfextu	r0,r0,0x0,0x3
80005c0c:	30 18       	mov	r8,1
   size_t diff = ilinebits - olinebits;
   size_t obp = 0, ibp = 0; /*bit pointers*/
   for(y = 0; y < h; y++)
   {
     size_t x;
     for(x = 0; x < olinebits; x++)
80005c0e:	2f f9       	sub	r9,-1
 
 static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)
 {
   /*the current bit in bitstream may be 0 or 1 for this to work*/
   if(bit == 0) bitstream[(*bitpointer) >> 3] &=  (unsigned char)(~(1 << (7 - ((*bitpointer) & 0x7))));
   else bitstream[(*bitpointer) >> 3] |=  (1 << (7 - ((*bitpointer) & 0x7)));
80005c10:	f0 00 09 40 	lsl	r0,r8,r0
80005c14:	e1 e1 10 01 	or	r1,r0,r1
80005c18:	a6 81       	st.b	r3[0x0],r1
80005c1a:	fe 9f fc e4 	bral	800055e2 <decodeGeneric+0x64e>
   size_t diff = ilinebits - olinebits;
   size_t obp = 0, ibp = 0; /*bit pointers*/
   for(y = 0; y < h; y++)
   {
     size_t x;
     for(x = 0; x < olinebits; x++)
80005c1e:	40 2e       	lddsp	lr,sp[0x8]
80005c20:	40 88       	lddsp	r8,sp[0x20]
80005c22:	1c 0b       	add	r11,lr
   only useful if (ilinebits - olinebits) is a value in the range 1..7
   */
   unsigned y;
   size_t diff = ilinebits - olinebits;
   size_t obp = 0, ibp = 0; /*bit pointers*/
   for(y = 0; y < h; y++)
80005c24:	40 69       	lddsp	r9,sp[0x18]
80005c26:	40 4e       	lddsp	lr,sp[0x10]
   {
     size_t x;
     for(x = 0; x < olinebits; x++)
80005c28:	04 0a       	add	r10,r2
   only useful if (ilinebits - olinebits) is a value in the range 1..7
   */
   unsigned y;
   size_t diff = ilinebits - olinebits;
   size_t obp = 0, ibp = 0; /*bit pointers*/
   for(y = 0; y < h; y++)
80005c2a:	2f f5       	sub	r5,-1
80005c2c:	12 0c       	add	r12,r9
80005c2e:	1c 08       	add	r8,lr
80005c30:	fe 9f fc ce 	bral	800055cc <decodeGeneric+0x638>
       if(decoder->infoPng.color.palette) free(decoder->infoPng.color.palette);
       decoder->infoPng.color.palettesize = chunkLength / 3;
       decoder->infoPng.color.palette = (unsigned char*)malloc(4 * decoder->infoPng.color.palettesize);
       if(!decoder->infoPng.color.palette && decoder->infoPng.color.palettesize) { decoder->error = 9937; break; }
       if(!decoder->infoPng.color.palette) decoder->infoPng.color.palettesize = 0; /*malloc failed...*/
       if(decoder->infoPng.color.palettesize > 256) { decoder->error = 38; break; } /*error: palette too big*/
80005c34:	32 68       	mov	r8,38
80005c36:	ef 48 00 d0 	st.w	r7[208],r8
80005c3a:	fe 9f fb 6b 	bral	80005310 <decodeGeneric+0x37c>
         if(chunkLength > decoder->infoPng.color.palettesize) { decoder->error = 39; break; } /*error: more alpha values given than there are palette entries*/
         for(i = 0; i < chunkLength; i++) decoder->infoPng.color.palette[4 * i + 3] = data[i];
       }
       else if(decoder->infoPng.color.colorType == 0)
       {
         if(chunkLength != 2) { decoder->error = 40; break; } /*error: this chunk must be 2 bytes for greyscale image*/
80005c3e:	32 88       	mov	r8,40
80005c40:	ef 48 00 d0 	st.w	r7[208],r8
80005c44:	fe 9f fb 66 	bral	80005310 <decodeGeneric+0x37c>
80005c48:	46 56       	lddsp	r6,sp[0x194]
80005c4a:	fe 9f fc 45 	bral	800054d4 <decodeGeneric+0x540>
 
   if(!decoder->error)
   {
     ucvector scanlines;
     ucvector_init(&scanlines);
     if(!ucvector_resize(&scanlines, ((decoder->infoPng.width * (decoder->infoPng.height * LodePNG_InfoColor_getBpp(&decoder->infoPng.color) + 7)) / 8) + decoder->infoPng.height)) decoder->error = 9945; /*maximum final image length is already reserved in the vector's length - this is not really necessary*/
80005c4e:	e0 68 26 d9 	mov	r8,9945
80005c52:	ef 48 00 d0 	st.w	r7[208],r8
80005c56:	46 56       	lddsp	r6,sp[0x194]
80005c58:	fe 9f fc 3e 	bral	800054d4 <decodeGeneric+0x540>
   only useful if (ilinebits - olinebits) is a value in the range 1..7
   */
   unsigned y;
   size_t diff = ilinebits - olinebits;
   size_t obp = 0, ibp = 0; /*bit pointers*/
   for(y = 0; y < h; y++)
80005c5c:	ea 00 02 43 	mul	r3,r5,r0
80005c60:	2f 93       	sub	r3,-7
80005c62:	a3 93       	lsr	r3,0x3
   */
 
   unsigned y;
   unsigned char* prevline = 0;
 
   size_t bytewidth = (bpp + 7) / 8; /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
80005c64:	2f 95       	sub	r5,-7
 
   return error;
 }
 
 /*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
 static void decodeGeneric(LodePNG_Decoder* decoder, unsigned char** out, size_t* outsize, const unsigned char* in, size_t size)
80005c66:	30 0a       	mov	r10,0
   */
 
   unsigned y;
   unsigned char* prevline = 0;
 
   size_t bytewidth = (bpp + 7) / 8; /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
80005c68:	ea 01 16 03 	lsr	r1,r5,0x3
 
   return error;
 }
 
 /*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
 static void decodeGeneric(LodePNG_Decoder* decoder, unsigned char** out, size_t* outsize, const unsigned char* in, size_t size)
80005c6c:	2f f6       	sub	r6,-1
80005c6e:	e6 c0 ff ff 	sub	r0,r3,-1
80005c72:	14 95       	mov	r5,r10
80005c74:	c1 28       	rjmp	80005c98 <decodeGeneric+0xd04>
   {
     size_t outindex = linebytes * y;
     size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
     unsigned char filterType = in[inindex];
 
     unsigned error = unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes);
80005c76:	1a d3       	st.w	--sp,r3
80005c78:	0c 9b       	mov	r11,r6
80005c7a:	ed 38 ff ff 	ld.ub	r8,r6[-1]
80005c7e:	08 9c       	mov	r12,r4
 
   return error;
 }
 
 /*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
 static void decodeGeneric(LodePNG_Decoder* decoder, unsigned char** out, size_t* outsize, const unsigned char* in, size_t size)
80005c80:	08 92       	mov	r2,r4
   {
     size_t outindex = linebytes * y;
     size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
     unsigned char filterType = in[inindex];
 
     unsigned error = unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes);
80005c82:	02 99       	mov	r9,r1
   unsigned char* prevline = 0;
 
   size_t bytewidth = (bpp + 7) / 8; /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
   size_t linebytes = (w * bpp + 7) / 8;
 
   for(y = 0; y < h; y++)
80005c84:	2f f5       	sub	r5,-1
   {
     size_t outindex = linebytes * y;
     size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
     unsigned char filterType = in[inindex];
 
     unsigned error = unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes);
80005c86:	fe b0 e9 63 	rcall	80002f4c <unfilterScanline>
80005c8a:	00 06       	add	r6,r0
80005c8c:	06 04       	add	r4,r3
     if(error) return error;
80005c8e:	2f fd       	sub	sp,-4
80005c90:	58 0c       	cp.w	r12,0
80005c92:	fe 91 fd 38 	brne	80005702 <decodeGeneric+0x76e>
   unsigned char* prevline = 0;
 
   size_t bytewidth = (bpp + 7) / 8; /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
   size_t linebytes = (w * bpp + 7) / 8;
 
   for(y = 0; y < h; y++)
80005c96:	04 9a       	mov	r10,r2
80005c98:	40 3c       	lddsp	r12,sp[0xc]
80005c9a:	0a 3c       	cp.w	r12,r5
80005c9c:	fe 9b ff ed 	brhi	80005c76 <decodeGeneric+0xce2>
80005ca0:	30 0c       	mov	r12,0
80005ca2:	46 24       	lddsp	r4,sp[0x188]
80005ca4:	46 56       	lddsp	r6,sp[0x194]
80005ca6:	fe 9f fc cf 	bral	80005644 <decodeGeneric+0x6b0>
   else /*interlaceMethod is 1 (Adam7)*/
   {
     unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
     unsigned i;
 
     Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
80005caa:	1a d5       	st.w	--sp,r5
80005cac:	40 4b       	lddsp	r11,sp[0x10]
80005cae:	1a db       	st.w	--sp,r11
80005cb0:	1a d0       	st.w	--sp,r0
80005cb2:	fa c9 ff 1c 	sub	r9,sp,-228
80005cb6:	fa cb fe a4 	sub	r11,sp,-348
80005cba:	fa cc fe 88 	sub	r12,sp,-376
80005cbe:	fa c8 ff 3c 	sub	r8,sp,-196
80005cc2:	50 5b       	stdsp	sp[0x14],r11
80005cc4:	fa ca fe fc 	sub	r10,sp,-260
80005cc8:	12 92       	mov	r2,r9
80005cca:	18 91       	mov	r1,r12
80005ccc:	fe b0 e6 f0 	rcall	80002aac <Adam7_getpassvalues>
80005cd0:	ea c8 ff f9 	sub	r8,r5,-7
80005cd4:	2f dd       	sub	sp,-12
80005cd6:	a3 98       	lsr	r8,0x3
 
 static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)
 {
   /*the current bit in bitstream may be 0 or 1 for this to work*/
   if(bit == 0) bitstream[(*bitpointer) >> 3] &=  (unsigned char)(~(1 << (7 - ((*bitpointer) & 0x7))));
   else bitstream[(*bitpointer) >> 3] |=  (1 << (7 - ((*bitpointer) & 0x7)));
80005cd8:	50 d0       	stdsp	sp[0x34],r0
   else /*interlaceMethod is 1 (Adam7)*/
   {
     unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
     unsigned i;
 
     Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
80005cda:	50 88       	stdsp	sp[0x20],r8
 
 static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)
 {
   /*the current bit in bitstream may be 0 or 1 for this to work*/
   if(bit == 0) bitstream[(*bitpointer) >> 3] &=  (unsigned char)(~(1 << (7 - ((*bitpointer) & 0x7))));
   else bitstream[(*bitpointer) >> 3] |=  (1 << (7 - ((*bitpointer) & 0x7)));
80005cdc:	50 57       	stdsp	sp[0x14],r7
80005cde:	50 b4       	stdsp	sp[0x2c],r4
 
   return error;
 }
 
 /*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
 static void decodeGeneric(LodePNG_Decoder* decoder, unsigned char** out, size_t* outsize, const unsigned char* in, size_t size)
80005ce0:	fa ca ff 08 	sub	r10,sp,-248
 
   unsigned y;
   unsigned char* prevline = 0;
 
   size_t bytewidth = (bpp + 7) / 8; /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
   size_t linebytes = (w * bpp + 7) / 8;
80005ce4:	62 00       	ld.w	r0,r1[0x0]
 
   return error;
 }
 
 /*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
 static void decodeGeneric(LodePNG_Decoder* decoder, unsigned char** out, size_t* outsize, const unsigned char* in, size_t size)
80005ce6:	f4 03 03 04 	ld.w	r4,r10[r3]
 
   unsigned y;
   unsigned char* prevline = 0;
 
   size_t bytewidth = (bpp + 7) / 8; /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
   size_t linebytes = (w * bpp + 7) / 8;
80005cea:	ea 00 02 40 	mul	r0,r5,r0
80005cee:	64 07       	ld.w	r7,r2[0x0]
80005cf0:	2f 90       	sub	r0,-7
 
   return error;
 }
 
 /*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
 static void decodeGeneric(LodePNG_Decoder* decoder, unsigned char** out, size_t* outsize, const unsigned char* in, size_t size)
80005cf2:	ec 04 00 04 	add	r4,r6,r4
 
   unsigned y;
   unsigned char* prevline = 0;
 
   size_t bytewidth = (bpp + 7) / 8; /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
   size_t linebytes = (w * bpp + 7) / 8;
80005cf6:	a3 90       	lsr	r0,0x3
 
   return error;
 }
 
 /*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
 static void decodeGeneric(LodePNG_Decoder* decoder, unsigned char** out, size_t* outsize, const unsigned char* in, size_t size)
80005cf8:	30 0a       	mov	r10,0
 
     Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
 
     for(i = 0; i < 7; i++)
     {
       error = unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp);
80005cfa:	40 29       	lddsp	r9,sp[0x8]
 
   return error;
 }
 
 /*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
 static void decodeGeneric(LodePNG_Decoder* decoder, unsigned char** out, size_t* outsize, const unsigned char* in, size_t size)
80005cfc:	e0 c8 ff ff 	sub	r8,r0,-1
 
     Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
 
     for(i = 0; i < 7; i++)
     {
       error = unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp);
80005d00:	72 09       	ld.w	r9,r9[0x0]
 
   unsigned y;
   unsigned char* prevline = 0;
 
   size_t bytewidth = (bpp + 7) / 8; /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
   size_t linebytes = (w * bpp + 7) / 8;
80005d02:	ec 07 00 07 	add	r7,r6,r7
 
   return error;
 }
 
 /*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
 static void decodeGeneric(LodePNG_Decoder* decoder, unsigned char** out, size_t* outsize, const unsigned char* in, size_t size)
80005d06:	2f f4       	sub	r4,-1
 
     Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
 
     for(i = 0; i < 7; i++)
     {
       error = unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp);
80005d08:	50 99       	stdsp	sp[0x24],r9
 
   return error;
 }
 
 /*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
 static void decodeGeneric(LodePNG_Decoder* decoder, unsigned char** out, size_t* outsize, const unsigned char* in, size_t size)
80005d0a:	50 78       	stdsp	sp[0x1c],r8
80005d0c:	50 4a       	stdsp	sp[0x10],r10
80005d0e:	c1 58       	rjmp	80005d38 <decodeGeneric+0xda4>
   {
     size_t outindex = linebytes * y;
     size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
     unsigned char filterType = in[inindex];
 
     unsigned error = unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes);
80005d10:	1a d0       	st.w	--sp,r0
   unsigned char* prevline = 0;
 
   size_t bytewidth = (bpp + 7) / 8; /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
   size_t linebytes = (w * bpp + 7) / 8;
 
   for(y = 0; y < h; y++)
80005d12:	40 5e       	lddsp	lr,sp[0x14]
   {
     size_t outindex = linebytes * y;
     size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
     unsigned char filterType = in[inindex];
 
     unsigned error = unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes);
80005d14:	40 8c       	lddsp	r12,sp[0x20]
   unsigned char* prevline = 0;
 
   size_t bytewidth = (bpp + 7) / 8; /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
   size_t linebytes = (w * bpp + 7) / 8;
 
   for(y = 0; y < h; y++)
80005d16:	2f fe       	sub	lr,-1
 
   return error;
 }
 
 /*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
 static void decodeGeneric(LodePNG_Decoder* decoder, unsigned char** out, size_t* outsize, const unsigned char* in, size_t size)
80005d18:	50 77       	stdsp	sp[0x1c],r7
   unsigned char* prevline = 0;
 
   size_t bytewidth = (bpp + 7) / 8; /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
   size_t linebytes = (w * bpp + 7) / 8;
 
   for(y = 0; y < h; y++)
80005d1a:	50 5e       	stdsp	sp[0x14],lr
   {
     size_t outindex = linebytes * y;
     size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
     unsigned char filterType = in[inindex];
 
     unsigned error = unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes);
80005d1c:	08 9b       	mov	r11,r4
80005d1e:	e9 38 ff ff 	ld.ub	r8,r4[-1]
80005d22:	40 99       	lddsp	r9,sp[0x24]
80005d24:	18 04       	add	r4,r12
80005d26:	0e 9c       	mov	r12,r7
80005d28:	00 07       	add	r7,r0
80005d2a:	fe b0 e9 11 	rcall	80002f4c <unfilterScanline>
     if(error) return error;
80005d2e:	2f fd       	sub	sp,-4
80005d30:	58 0c       	cp.w	r12,0
80005d32:	e0 81 00 a4 	brne	80005e7a <decodeGeneric+0xee6>
   unsigned char* prevline = 0;
 
   size_t bytewidth = (bpp + 7) / 8; /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
   size_t linebytes = (w * bpp + 7) / 8;
 
   for(y = 0; y < h; y++)
80005d36:	40 6a       	lddsp	r10,sp[0x18]
80005d38:	40 9b       	lddsp	r11,sp[0x24]
80005d3a:	40 49       	lddsp	r9,sp[0x10]
80005d3c:	12 3b       	cp.w	r11,r9
80005d3e:	fe 9b ff e9 	brhi	80005d10 <decodeGeneric+0xd7c>
 
     for(i = 0; i < 7; i++)
     {
       error = unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp);
       if(error) return error;
       if(bpp < 8) /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline, move bytes instead of bits or move not at all*/
80005d42:	58 75       	cp.w	r5,7
80005d44:	e0 8b 00 aa 	brhi	80005e98 <decodeGeneric+0xf04>
       {
         /*remove padding bits in scanlines; after this there still may be padding bits between the different reduced images: each reduced image still starts nicely at a byte*/
         removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp, ((passw[i] * bpp + 7) / 8) * 8, passh[i]);
80005d48:	64 08       	ld.w	r8,r2[0x0]
80005d4a:	ec 08 00 08 	add	r8,r6,r8
80005d4e:	50 48       	stdsp	sp[0x10],r8
80005d50:	fa c8 ff 48 	sub	r8,sp,-184
   in and out are allowed to be the same buffer, in may also be higher but still overlapping; in must have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
   also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
   only useful if (ilinebits - olinebits) is a value in the range 1..7
   */
   unsigned y;
   size_t diff = ilinebits - olinebits;
80005d54:	30 09       	mov	r9,0
       error = unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp);
       if(error) return error;
       if(bpp < 8) /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline, move bytes instead of bits or move not at all*/
       {
         /*remove padding bits in scanlines; after this there still may be padding bits between the different reduced images: each reduced image still starts nicely at a byte*/
         removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp, ((passw[i] * bpp + 7) / 8) * 8, passh[i]);
80005d56:	f0 03 03 0c 	ld.w	r12,r8[r3]
80005d5a:	62 0a       	ld.w	r10,r1[0x0]
80005d5c:	40 27       	lddsp	r7,sp[0x8]
80005d5e:	ea 0a 02 4a 	mul	r10,r5,r10
80005d62:	6e 07       	ld.w	r7,r7[0x0]
   in and out are allowed to be the same buffer, in may also be higher but still overlapping; in must have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
   also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
   only useful if (ilinebits - olinebits) is a value in the range 1..7
   */
   unsigned y;
   size_t diff = ilinebits - olinebits;
80005d64:	f4 c8 ff f9 	sub	r8,r10,-7
       error = unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp);
       if(error) return error;
       if(bpp < 8) /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline, move bytes instead of bits or move not at all*/
       {
         /*remove padding bits in scanlines; after this there still may be padding bits between the different reduced images: each reduced image still starts nicely at a byte*/
         removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp, ((passw[i] * bpp + 7) / 8) * 8, passh[i]);
80005d68:	ec 0c 00 0c 	add	r12,r6,r12
   in and out are allowed to be the same buffer, in may also be higher but still overlapping; in must have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
   also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
   only useful if (ilinebits - olinebits) is a value in the range 1..7
   */
   unsigned y;
   size_t diff = ilinebits - olinebits;
80005d6c:	e0 18 ff f8 	andl	r8,0xfff8
       error = unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp);
       if(error) return error;
       if(bpp < 8) /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline, move bytes instead of bits or move not at all*/
       {
         /*remove padding bits in scanlines; after this there still may be padding bits between the different reduced images: each reduced image still starts nicely at a byte*/
         removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp, ((passw[i] * bpp + 7) / 8) * 8, passh[i]);
80005d70:	50 97       	stdsp	sp[0x24],r7
   in and out are allowed to be the same buffer, in may also be higher but still overlapping; in must have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
   also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
   only useful if (ilinebits - olinebits) is a value in the range 1..7
   */
   unsigned y;
   size_t diff = ilinebits - olinebits;
80005d72:	14 18       	sub	r8,r10
80005d74:	12 9b       	mov	r11,r9
80005d76:	50 a8       	stdsp	sp[0x28],r8
80005d78:	50 69       	stdsp	sp[0x18],r9
80005d7a:	51 02       	stdsp	sp[0x40],r2
   size_t obp = 0, ibp = 0; /*bit pointers*/
   for(y = 0; y < h; y++)
80005d7c:	40 9e       	lddsp	lr,sp[0x24]
80005d7e:	40 68       	lddsp	r8,sp[0x18]
80005d80:	10 3e       	cp.w	lr,r8
80005d82:	e0 88 00 8a 	brls	80005e96 <decodeGeneric+0xf02>
   {
     size_t x;
     for(x = 0; x < olinebits; x++)
80005d86:	58 0a       	cp.w	r10,0
80005d88:	e0 80 00 81 	breq	80005e8a <decodeGeneric+0xef6>
 
 static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)
 {
   /*the current bit in bitstream may be 0 or 1 for this to work*/
   if(bit == 0) bitstream[(*bitpointer) >> 3] &=  (unsigned char)(~(1 << (7 - ((*bitpointer) & 0x7))));
   else bitstream[(*bitpointer) >> 3] |=  (1 << (7 - ((*bitpointer) & 0x7)));
80005d8c:	f6 0e 11 ff 	rsub	lr,r11,-1
   in and out are allowed to be the same buffer, in may also be higher but still overlapping; in must have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
   also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
   only useful if (ilinebits - olinebits) is a value in the range 1..7
   */
   unsigned y;
   size_t diff = ilinebits - olinebits;
80005d90:	30 08       	mov	r8,0
 #endif /*LODEPNG_COMPILE_DECODER*/
 
 static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)
 {
   /*the current bit in bitstream may be 0 or 1 for this to work*/
   if(bit == 0) bitstream[(*bitpointer) >> 3] &=  (unsigned char)(~(1 << (7 - ((*bitpointer) & 0x7))));
80005d92:	f2 00 11 ff 	rsub	r0,r9,-1
   else bitstream[(*bitpointer) >> 3] |=  (1 << (7 - ((*bitpointer) & 0x7)));
80005d96:	50 7e       	stdsp	sp[0x1c],lr
80005d98:	51 16       	stdsp	sp[0x44],r6
80005d9a:	c0 f8       	rjmp	80005db8 <decodeGeneric+0xe24>
 #endif /*LODEPNG_COMPILE_DECODER*/
 
 static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)
 {
   /*the current bit in bitstream may be 0 or 1 for this to work*/
   if(bit == 0) bitstream[(*bitpointer) >> 3] &=  (unsigned char)(~(1 << (7 - ((*bitpointer) & 0x7))));
80005d9c:	05 8e       	ld.ub	lr,r2[0x0]
80005d9e:	40 77       	lddsp	r7,sp[0x1c]
80005da0:	30 16       	mov	r6,1
80005da2:	10 17       	sub	r7,r8
80005da4:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
80005da8:	ec 07 09 47 	lsl	r7,r6,r7
80005dac:	0e 8e       	andn	lr,r7
80005dae:	a4 8e       	st.b	r2[0x0],lr
   size_t diff = ilinebits - olinebits;
   size_t obp = 0, ibp = 0; /*bit pointers*/
   for(y = 0; y < h; y++)
   {
     size_t x;
     for(x = 0; x < olinebits; x++)
80005db0:	2f f8       	sub	r8,-1
80005db2:	10 3a       	cp.w	r10,r8
80005db4:	e0 88 00 68 	brls	80005e84 <decodeGeneric+0xef0>
 #endif /*LODEPNG_COMPILE_DECODER*/
 
 static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)
 {
   /*the current bit in bitstream may be 0 or 1 for this to work*/
   if(bit == 0) bitstream[(*bitpointer) >> 3] &=  (unsigned char)(~(1 << (7 - ((*bitpointer) & 0x7))));
80005db8:	f0 09 00 0e 	add	lr,r8,r9
80005dbc:	40 46       	lddsp	r6,sp[0x10]
80005dbe:	a3 9e       	lsr	lr,0x3
80005dc0:	ec 0e 07 07 	ld.ub	r7,r6[lr]
   in and out are allowed to be the same buffer, in may also be higher but still overlapping; in must have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
   also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
   only useful if (ilinebits - olinebits) is a value in the range 1..7
   */
   unsigned y;
   size_t diff = ilinebits - olinebits;
80005dc4:	f0 0b 00 04 	add	r4,r8,r11
 #endif /*LODEPNG_COMPILE_DECODER*/
 
 static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)
 {
   /*the current bit in bitstream may be 0 or 1 for this to work*/
   if(bit == 0) bitstream[(*bitpointer) >> 3] &=  (unsigned char)(~(1 << (7 - ((*bitpointer) & 0x7))));
80005dc8:	e0 08 01 0e 	sub	lr,r0,r8
80005dcc:	e8 02 16 03 	lsr	r2,r4,0x3
80005dd0:	fd de c0 03 	bfextu	lr,lr,0x0,0x3
80005dd4:	f8 02 00 02 	add	r2,r12,r2
80005dd8:	ee 0e 08 4e 	asr	lr,r7,lr
80005ddc:	30 07       	mov	r7,0
80005dde:	fd de c0 01 	bfextu	lr,lr,0x0,0x1
80005de2:	ee 0e 18 00 	cp.b	lr,r7
80005de6:	cd b0       	breq	80005d9c <decodeGeneric+0xe08>
   else bitstream[(*bitpointer) >> 3] |=  (1 << (7 - ((*bitpointer) & 0x7)));
80005de8:	30 1e       	mov	lr,1
80005dea:	40 77       	lddsp	r7,sp[0x1c]
80005dec:	10 17       	sub	r7,r8
80005dee:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
80005df2:	fc 07 09 47 	lsl	r7,lr,r7
80005df6:	05 8e       	ld.ub	lr,r2[0x0]
80005df8:	ef ee 10 0e 	or	lr,r7,lr
80005dfc:	a4 8e       	st.b	r2[0x0],lr
80005dfe:	cd 9b       	rjmp	80005db0 <decodeGeneric+0xe1c>
 
           begin = length + 3;
           length = 0;
           for(i = begin; i < chunkLength && data[i] != 0; i++) length++;
           if(begin + length + 1 >= chunkLength) { decoder->error = 75; break; }
           langtag = (char*)malloc(length + 1);
80005e00:	50 1b       	stdsp	sp[0x4],r11
80005e02:	50 0a       	stdsp	sp[0x0],r10
80005e04:	e4 cc ff ff 	sub	r12,r2,-1
80005e08:	e0 a0 50 7a 	rcall	8000fefc <malloc>
80005e0c:	50 5c       	stdsp	sp[0x14],r12
80005e0e:	51 2c       	stdsp	sp[0x48],r12
           if(!langtag) { decoder->error = 9942; break; }
80005e10:	40 1b       	lddsp	r11,sp[0x4]
80005e12:	40 0a       	lddsp	r10,sp[0x0]
80005e14:	c2 c0       	breq	80005e6c <decodeGeneric+0xed8>
           langtag[length] = 0;
80005e16:	40 59       	lddsp	r9,sp[0x14]
80005e18:	f2 02 0b 04 	st.b	r9[r2],r4
80005e1c:	30 09       	mov	r9,0
           for(i = 0; i < length; i++) langtag[i] = data[begin + i];
80005e1e:	04 39       	cp.w	r9,r2
80005e20:	c0 72       	brcc	80005e2e <decodeGeneric+0xe9a>
80005e22:	15 38       	ld.ub	r8,r10++
80005e24:	41 2e       	lddsp	lr,sp[0x48]
80005e26:	fc 09 0b 08 	st.b	lr[r9],r8
80005e2a:	2f f9       	sub	r9,-1
80005e2c:	cf 9b       	rjmp	80005e1e <decodeGeneric+0xe8a>
80005e2e:	f6 c8 ff f8 	sub	r8,r11,-8
80005e32:	ec 08 00 08 	add	r8,r6,r8
80005e36:	51 08       	stdsp	sp[0x40],r8
80005e38:	30 08       	mov	r8,0
80005e3a:	41 0a       	lddsp	r10,sp[0x40]
 
           begin += length + 1;
           length = 0;
           for(i = begin; i < chunkLength && data[i] != 0; i++) length++;
80005e3c:	15 89       	ld.ub	r9,r10[0x0]
80005e3e:	e8 09 18 00 	cp.b	r9,r4
80005e42:	c0 80       	breq	80005e52 <decodeGeneric+0xebe>
80005e44:	2f f8       	sub	r8,-1
80005e46:	2f fa       	sub	r10,-1
80005e48:	f0 0b 00 09 	add	r9,r8,r11
80005e4c:	12 33       	cp.w	r3,r9
80005e4e:	fe 9b ff f7 	brhi	80005e3c <decodeGeneric+0xea8>
           if(begin + length + 1 >= chunkLength) { decoder->error = 75; break; }
80005e52:	f6 c9 ff ff 	sub	r9,r11,-1
80005e56:	f2 08 00 0a 	add	r10,r9,r8
80005e5a:	06 3a       	cp.w	r10,r3
80005e5c:	e0 83 01 11 	brlo	8000607e <decodeGeneric+0x10ea>
80005e60:	34 b8       	mov	r8,75
80005e62:	30 02       	mov	r2,0
80005e64:	ef 48 00 d0 	st.w	r7[208],r8
80005e68:	fe 9f fd 24 	bral	800058b0 <decodeGeneric+0x91c>
           begin = length + 3;
           length = 0;
           for(i = begin; i < chunkLength && data[i] != 0; i++) length++;
           if(begin + length + 1 >= chunkLength) { decoder->error = 75; break; }
           langtag = (char*)malloc(length + 1);
           if(!langtag) { decoder->error = 9942; break; }
80005e6c:	e0 68 26 d6 	mov	r8,9942
80005e70:	ef 48 00 d0 	st.w	r7[208],r8
80005e74:	40 52       	lddsp	r2,sp[0x14]
80005e76:	fe 9f fd 1d 	bral	800058b0 <decodeGeneric+0x91c>
80005e7a:	40 57       	lddsp	r7,sp[0x14]
80005e7c:	46 24       	lddsp	r4,sp[0x188]
80005e7e:	46 56       	lddsp	r6,sp[0x194]
80005e80:	fe 9f fb e2 	bral	80005644 <decodeGeneric+0x6b0>
80005e84:	41 16       	lddsp	r6,sp[0x44]
   size_t diff = ilinebits - olinebits;
   size_t obp = 0, ibp = 0; /*bit pointers*/
   for(y = 0; y < h; y++)
   {
     size_t x;
     for(x = 0; x < olinebits; x++)
80005e86:	14 09       	add	r9,r10
80005e88:	14 0b       	add	r11,r10
   only useful if (ilinebits - olinebits) is a value in the range 1..7
   */
   unsigned y;
   size_t diff = ilinebits - olinebits;
   size_t obp = 0, ibp = 0; /*bit pointers*/
   for(y = 0; y < h; y++)
80005e8a:	40 67       	lddsp	r7,sp[0x18]
     for(x = 0; x < olinebits; x++)
     {
       unsigned char bit = readBitFromReversedStream(&ibp, in);
       setBitOfReversedStream(&obp, out, bit);
     }
     ibp += diff;
80005e8c:	40 a8       	lddsp	r8,sp[0x28]
   only useful if (ilinebits - olinebits) is a value in the range 1..7
   */
   unsigned y;
   size_t diff = ilinebits - olinebits;
   size_t obp = 0, ibp = 0; /*bit pointers*/
   for(y = 0; y < h; y++)
80005e8e:	2f f7       	sub	r7,-1
     for(x = 0; x < olinebits; x++)
     {
       unsigned char bit = readBitFromReversedStream(&ibp, in);
       setBitOfReversedStream(&obp, out, bit);
     }
     ibp += diff;
80005e90:	10 09       	add	r9,r8
   only useful if (ilinebits - olinebits) is a value in the range 1..7
   */
   unsigned y;
   size_t diff = ilinebits - olinebits;
   size_t obp = 0, ibp = 0; /*bit pointers*/
   for(y = 0; y < h; y++)
80005e92:	50 67       	stdsp	sp[0x18],r7
80005e94:	c7 4b       	rjmp	80005d7c <decodeGeneric+0xde8>
80005e96:	41 02       	lddsp	r2,sp[0x40]
   {
     size_t x;
     for(x = 0; x < olinebits; x++)
80005e98:	40 27       	lddsp	r7,sp[0x8]
80005e9a:	2f c7       	sub	r7,-4
80005e9c:	50 27       	stdsp	sp[0x8],r7
80005e9e:	2f c3       	sub	r3,-4
80005ea0:	2f c1       	sub	r1,-4
80005ea2:	2f c2       	sub	r2,-4
     unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
     unsigned i;
 
     Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
 
     for(i = 0; i < 7; i++)
80005ea4:	59 c3       	cp.w	r3,28
80005ea6:	fe 91 ff 1d 	brne	80005ce0 <decodeGeneric+0xd4c>
80005eaa:	40 d0       	lddsp	r0,sp[0x34]
80005eac:	40 57       	lddsp	r7,sp[0x14]
80005eae:	40 b4       	lddsp	r4,sp[0x2c]
   /*Note: this function works on image buffers WITHOUT padding bits at end of scanlines with non-multiple-of-8 bit amounts, only between reduced images is padding
   out must be big enough AND must be 0 everywhere if bpp < 8 in the current implementation (because that's likely a little bit faster)*/
   unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
   unsigned i;
 
   Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
80005eb0:	1a d5       	st.w	--sp,r5
80005eb2:	40 4e       	lddsp	lr,sp[0x10]
80005eb4:	1a de       	st.w	--sp,lr
80005eb6:	1a d0       	st.w	--sp,r0
80005eb8:	fa c1 fe dc 	sub	r1,sp,-292
80005ebc:	fa c2 fe c0 	sub	r2,sp,-320
80005ec0:	fa c8 ff 9c 	sub	r8,sp,-100
80005ec4:	fa c9 ff 7c 	sub	r9,sp,-132
80005ec8:	fa ca ff 5c 	sub	r10,sp,-164
80005ecc:	02 9b       	mov	r11,r1
80005ece:	04 9c       	mov	r12,r2
80005ed0:	fe b0 e5 ee 	rcall	80002aac <Adam7_getpassvalues>
 
   if(bpp >= 8)
80005ed4:	2f dd       	sub	sp,-12
80005ed6:	58 75       	cp.w	r5,7
80005ed8:	e0 8b 00 92 	brhi	80005ffc <decodeGeneric+0x1068>
80005edc:	30 0c       	mov	r12,0
80005ede:	ea 00 02 40 	mul	r0,r5,r0
80005ee2:	50 71       	stdsp	sp[0x1c],r1
80005ee4:	fe fb 02 94 	ld.w	r11,pc[660]
80005ee8:	50 b0       	stdsp	sp[0x2c],r0
80005eea:	50 42       	stdsp	sp[0x10],r2
80005eec:	50 2c       	stdsp	sp[0x8],r12
80005eee:	50 9b       	stdsp	sp[0x24],r11
 
 #ifdef LODEPNG_COMPILE_DECODER
 static void setBitOfReversedStream0(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)
 {
   /*the current bit in bitstream must be 0 for this to work*/
   if(bit) bitstream[(*bitpointer) >> 3] |=  (bit << (7 - ((*bitpointer) & 0x7))); /*earlier bit of huffman code is in a lesser significant bit of an earlier byte*/
80005ef0:	18 91       	mov	r1,r12
80005ef2:	30 1e       	mov	lr,1
80005ef4:	51 17       	stdsp	sp[0x44],r7
   else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/
   {
     for(i = 0; i < 7; i++)
     {
       unsigned x, y, b;
       unsigned ilinebits = bpp * passw[i];
80005ef6:	30 0c       	mov	r12,0
80005ef8:	40 47       	lddsp	r7,sp[0x10]
80005efa:	40 7a       	lddsp	r10,sp[0x1c]
80005efc:	6e 08       	ld.w	r8,r7[0x0]
80005efe:	50 6c       	stdsp	sp[0x18],r12
80005f00:	ea 08 02 4b 	mul	r11,r5,r8
80005f04:	74 09       	ld.w	r9,r10[0x0]
80005f06:	51 0b       	stdsp	sp[0x40],r11
80005f08:	50 5c       	stdsp	sp[0x14],r12
       unsigned olinebits = bpp * w;
       size_t obp, ibp; /*bit pointers (for out and in buffer)*/
       for(y = 0; y < passh[i]; y++)
80005f0a:	40 5c       	lddsp	r12,sp[0x14]
80005f0c:	12 3c       	cp.w	r12,r9
80005f0e:	c6 62       	brcc	80005fda <decodeGeneric+0x1046>
       for(x = 0; x < passw[i]; x++)
80005f10:	58 08       	cp.w	r8,0
80005f12:	c5 c0       	breq	80005fca <decodeGeneric+0x1036>
       {
         ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
         obp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
80005f14:	40 2a       	lddsp	r10,sp[0x8]
       unsigned x, y, b;
       unsigned ilinebits = bpp * passw[i];
       unsigned olinebits = bpp * w;
       size_t obp, ibp; /*bit pointers (for out and in buffer)*/
       for(y = 0; y < passh[i]; y++)
       for(x = 0; x < passw[i]; x++)
80005f16:	30 0b       	mov	r11,0
80005f18:	fe f9 02 64 	ld.w	r9,pc[612]
       {
         ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
         obp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
80005f1c:	f2 0a 03 09 	ld.w	r9,r9[r10]
       unsigned x, y, b;
       unsigned ilinebits = bpp * passw[i];
       unsigned olinebits = bpp * w;
       size_t obp, ibp; /*bit pointers (for out and in buffer)*/
       for(y = 0; y < passh[i]; y++)
       for(x = 0; x < passw[i]; x++)
80005f20:	50 3b       	stdsp	sp[0xc],r11
80005f22:	fe f8 02 5e 	ld.w	r8,pc[606]
       {
         ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
         obp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
80005f26:	50 a9       	stdsp	sp[0x28],r9
80005f28:	f0 0a 03 08 	ld.w	r8,r8[r10]
80005f2c:	fe f7 02 58 	ld.w	r7,pc[600]
       unsigned x, y, b;
       unsigned ilinebits = bpp * passw[i];
       unsigned olinebits = bpp * w;
       size_t obp, ibp; /*bit pointers (for out and in buffer)*/
       for(y = 0; y < passh[i]; y++)
       for(x = 0; x < passw[i]; x++)
80005f30:	40 9b       	lddsp	r11,sp[0x24]
       {
         ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
         obp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
80005f32:	ee 0a 03 09 	ld.w	r9,r7[r10]
       unsigned x, y, b;
       unsigned ilinebits = bpp * passw[i];
       unsigned olinebits = bpp * w;
       size_t obp, ibp; /*bit pointers (for out and in buffer)*/
       for(y = 0; y < passh[i]; y++)
       for(x = 0; x < passw[i]; x++)
80005f36:	76 0b       	ld.w	r11,r11[0x0]
       {
         ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
         obp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
80005f38:	f8 09 03 48 	mac	r8,r12,r9
       unsigned x, y, b;
       unsigned ilinebits = bpp * passw[i];
       unsigned olinebits = bpp * w;
       size_t obp, ibp; /*bit pointers (for out and in buffer)*/
       for(y = 0; y < passh[i]; y++)
       for(x = 0; x < passw[i]; x++)
80005f3c:	50 8b       	stdsp	sp[0x20],r11
       {
         ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
         obp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
80005f3e:	40 bc       	lddsp	r12,sp[0x2c]
       unsigned x, y, b;
       unsigned ilinebits = bpp * passw[i];
       unsigned olinebits = bpp * w;
       size_t obp, ibp; /*bit pointers (for out and in buffer)*/
       for(y = 0; y < passh[i]; y++)
       for(x = 0; x < passw[i]; x++)
80005f40:	40 30       	lddsp	r0,sp[0xc]
       {
         ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
         obp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
80005f42:	b9 38       	mul	r8,r12
80005f44:	50 d8       	stdsp	sp[0x34],r8
       unsigned olinebits = bpp * w;
       size_t obp, ibp; /*bit pointers (for out and in buffer)*/
       for(y = 0; y < passh[i]; y++)
       for(x = 0; x < passw[i]; x++)
       {
         ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
80005f46:	fa c9 ff a8 	sub	r9,sp,-88
80005f4a:	40 28       	lddsp	r8,sp[0x8]
80005f4c:	40 6c       	lddsp	r12,sp[0x18]
80005f4e:	f2 08 03 07 	ld.w	r7,r9[r8]
80005f52:	40 3b       	lddsp	r11,sp[0xc]
80005f54:	f8 07 00 37 	add	r7,r12,r7<<0x3
         obp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
80005f58:	40 aa       	lddsp	r10,sp[0x28]
       unsigned olinebits = bpp * w;
       size_t obp, ibp; /*bit pointers (for out and in buffer)*/
       for(y = 0; y < passh[i]; y++)
       for(x = 0; x < passw[i]; x++)
       {
         ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
80005f5a:	16 07       	add	r7,r11
         obp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
80005f5c:	40 8c       	lddsp	r12,sp[0x20]
80005f5e:	40 d9       	lddsp	r9,sp[0x34]
80005f60:	a1 3c       	mul	r12,r0
80005f62:	30 08       	mov	r8,0
80005f64:	14 0c       	add	r12,r10
 
 #ifdef LODEPNG_COMPILE_DECODER
 static void setBitOfReversedStream0(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)
 {
   /*the current bit in bitstream must be 0 for this to work*/
   if(bit) bitstream[(*bitpointer) >> 3] |=  (bit << (7 - ((*bitpointer) & 0x7))); /*earlier bit of huffman code is in a lesser significant bit of an earlier byte*/
80005f66:	ee 03 11 ff 	rsub	r3,r7,-1
       size_t obp, ibp; /*bit pointers (for out and in buffer)*/
       for(y = 0; y < passh[i]; y++)
       for(x = 0; x < passw[i]; x++)
       {
         ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
         obp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
80005f6a:	ab 3c       	mul	r12,r5
80005f6c:	12 0c       	add	r12,r9
 
 #ifdef LODEPNG_COMPILE_DECODER
 static void setBitOfReversedStream0(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)
 {
   /*the current bit in bitstream must be 0 for this to work*/
   if(bit) bitstream[(*bitpointer) >> 3] |=  (bit << (7 - ((*bitpointer) & 0x7))); /*earlier bit of huffman code is in a lesser significant bit of an earlier byte*/
80005f6e:	f8 02 11 ff 	rsub	r2,r12,-1
80005f72:	f0 07 00 0a 	add	r10,r8,r7
80005f76:	a3 9a       	lsr	r10,0x3
       size_t obp, ibp; /*bit pointers (for out and in buffer)*/
       for(y = 0; y < passh[i]; y++)
       for(x = 0; x < passw[i]; x++)
       {
         ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
         obp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
80005f78:	f0 0c 00 09 	add	r9,r8,r12
 
 #ifdef LODEPNG_COMPILE_DECODER
 static void setBitOfReversedStream0(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)
 {
   /*the current bit in bitstream must be 0 for this to work*/
   if(bit) bitstream[(*bitpointer) >> 3] |=  (bit << (7 - ((*bitpointer) & 0x7))); /*earlier bit of huffman code is in a lesser significant bit of an earlier byte*/
80005f7c:	ec 0a 07 0b 	ld.ub	r11,r6[r10]
80005f80:	a3 99       	lsr	r9,0x3
80005f82:	e6 08 01 0a 	sub	r10,r3,r8
80005f86:	e8 09 00 09 	add	r9,r4,r9
80005f8a:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005f8e:	f6 0a 08 4a 	asr	r10,r11,r10
80005f92:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80005f96:	e2 0a 18 00 	cp.b	r10,r1
80005f9a:	c0 b0       	breq	80005fb0 <decodeGeneric+0x101c>
80005f9c:	13 8a       	ld.ub	r10,r9[0x0]
80005f9e:	e4 08 01 0b 	sub	r11,r2,r8
80005fa2:	f7 db c0 03 	bfextu	r11,r11,0x0,0x3
80005fa6:	fc 0b 09 4b 	lsl	r11,lr,r11
80005faa:	f7 ea 10 0a 	or	r10,r11,r10
80005fae:	b2 8a       	st.b	r9[0x0],r10
       for(y = 0; y < passh[i]; y++)
       for(x = 0; x < passw[i]; x++)
       {
         ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
         obp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
         for(b = 0; b < bpp; b++)
80005fb0:	2f f8       	sub	r8,-1
80005fb2:	0a 38       	cp.w	r8,r5
80005fb4:	cd f1       	brne	80005f72 <decodeGeneric+0xfde>
       unsigned x, y, b;
       unsigned ilinebits = bpp * passw[i];
       unsigned olinebits = bpp * w;
       size_t obp, ibp; /*bit pointers (for out and in buffer)*/
       for(y = 0; y < passh[i]; y++)
       for(x = 0; x < passw[i]; x++)
80005fb6:	40 38       	lddsp	r8,sp[0xc]
80005fb8:	0a 08       	add	r8,r5
80005fba:	50 38       	stdsp	sp[0xc],r8
80005fbc:	40 47       	lddsp	r7,sp[0x10]
80005fbe:	2f f0       	sub	r0,-1
80005fc0:	6e 08       	ld.w	r8,r7[0x0]
80005fc2:	10 30       	cp.w	r0,r8
80005fc4:	cc 13       	brcs	80005f46 <decodeGeneric+0xfb2>
80005fc6:	40 7c       	lddsp	r12,sp[0x1c]
80005fc8:	78 09       	ld.w	r9,r12[0x0]
     {
       unsigned x, y, b;
       unsigned ilinebits = bpp * passw[i];
       unsigned olinebits = bpp * w;
       size_t obp, ibp; /*bit pointers (for out and in buffer)*/
       for(y = 0; y < passh[i]; y++)
80005fca:	40 5b       	lddsp	r11,sp[0x14]
80005fcc:	40 6a       	lddsp	r10,sp[0x18]
80005fce:	2f fb       	sub	r11,-1
80005fd0:	41 07       	lddsp	r7,sp[0x40]
80005fd2:	50 5b       	stdsp	sp[0x14],r11
80005fd4:	0e 0a       	add	r10,r7
80005fd6:	50 6a       	stdsp	sp[0x18],r10
80005fd8:	c9 9b       	rjmp	80005f0a <decodeGeneric+0xf76>
       for(x = 0; x < passw[i]; x++)
80005fda:	40 4a       	lddsp	r10,sp[0x10]
80005fdc:	40 29       	lddsp	r9,sp[0x8]
80005fde:	40 78       	lddsp	r8,sp[0x1c]
80005fe0:	40 97       	lddsp	r7,sp[0x24]
80005fe2:	2f ca       	sub	r10,-4
80005fe4:	2f c9       	sub	r9,-4
80005fe6:	2f c8       	sub	r8,-4
80005fe8:	2f c7       	sub	r7,-4
80005fea:	50 4a       	stdsp	sp[0x10],r10
80005fec:	50 29       	stdsp	sp[0x8],r9
80005fee:	50 78       	stdsp	sp[0x1c],r8
80005ff0:	50 97       	stdsp	sp[0x24],r7
       }
     }
   }
   else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/
   {
     for(i = 0; i < 7; i++)
80005ff2:	59 c9       	cp.w	r9,28
80005ff4:	c8 11       	brne	80005ef6 <decodeGeneric+0xf62>
80005ff6:	41 17       	lddsp	r7,sp[0x44]
80005ff8:	fe 9f fb 84 	bral	80005700 <decodeGeneric+0x76c>
   unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
   unsigned i;
 
   Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
 
   if(bpp >= 8)
80005ffc:	4d fa       	lddpc	r10,80006178 <decodeGeneric+0x11e4>
80005ffe:	a3 95       	lsr	r5,0x3
80006000:	50 2a       	stdsp	sp[0x8],r10
80006002:	30 0e       	mov	lr,0
80006004:	50 47       	stdsp	sp[0x10],r7
80006006:	62 09       	ld.w	r9,r1[0x0]
80006008:	30 07       	mov	r7,0
   {
     for(i = 0; i < 7; i++)
     {
       unsigned x, y, b;
       size_t bytewidth = bpp / 8;
       for(y = 0; y < passh[i]; y++)
8000600a:	12 37       	cp.w	r7,r9
8000600c:	fe 92 fb 70 	brhs	800056ec <decodeGeneric+0x758>
       for(x = 0; x < passw[i]; x++)
80006010:	64 08       	ld.w	r8,r2[0x0]
80006012:	58 08       	cp.w	r8,0
80006014:	c3 30       	breq	8000607a <decodeGeneric+0x10e6>
   unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
   unsigned i;
 
   Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
 
   if(bpp >= 8)
80006016:	4d c9       	lddpc	r9,80006184 <decodeGeneric+0x11f0>
80006018:	4d ac       	lddpc	r12,80006180 <decodeGeneric+0x11ec>
8000601a:	f2 0e 03 0a 	ld.w	r10,r9[lr]
8000601e:	f8 0e 03 09 	ld.w	r9,r12[lr]
80006022:	ee 0a 02 4a 	mul	r10,r7,r10
80006026:	f4 09 00 09 	add	r9,r10,r9
8000602a:	4d 5b       	lddpc	r11,8000617c <decodeGeneric+0x11e8>
8000602c:	f2 00 02 43 	mul	r3,r9,r0
     for(i = 0; i < 7; i++)
     {
       unsigned x, y, b;
       size_t bytewidth = bpp / 8;
       for(y = 0; y < passh[i]; y++)
       for(x = 0; x < passw[i]; x++)
80006030:	40 2a       	lddsp	r10,sp[0x8]
   unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
   unsigned i;
 
   Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
 
   if(bpp >= 8)
80006032:	f6 0e 03 09 	ld.w	r9,r11[lr]
     for(i = 0; i < 7; i++)
     {
       unsigned x, y, b;
       size_t bytewidth = bpp / 8;
       for(y = 0; y < passh[i]; y++)
       for(x = 0; x < passw[i]; x++)
80006036:	74 0a       	ld.w	r10,r10[0x0]
   unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
   unsigned i;
 
   Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
 
   if(bpp >= 8)
80006038:	12 03       	add	r3,r9
     for(i = 0; i < 7; i++)
     {
       unsigned x, y, b;
       size_t bytewidth = bpp / 8;
       for(y = 0; y < passh[i]; y++)
       for(x = 0; x < passw[i]; x++)
8000603a:	50 3a       	stdsp	sp[0xc],r10
8000603c:	30 0c       	mov	r12,0
   unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
   unsigned i;
 
   Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
 
   if(bpp >= 8)
8000603e:	af 38       	mul	r8,r7
80006040:	fa cb ff a8 	sub	r11,sp,-88
80006044:	f0 0c 00 09 	add	r9,r8,r12
80006048:	f6 0e 03 08 	ld.w	r8,r11[lr]
8000604c:	ab 39       	mul	r9,r5
8000604e:	f2 08 00 08 	add	r8,r9,r8
80006052:	40 39       	lddsp	r9,sp[0xc]
80006054:	ec 08 00 0a 	add	r10,r6,r8
80006058:	b9 39       	mul	r9,r12
8000605a:	30 08       	mov	r8,0
8000605c:	e6 09 00 09 	add	r9,r3,r9
80006060:	ab 39       	mul	r9,r5
80006062:	e8 09 00 09 	add	r9,r4,r9
       {
         size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
         size_t pixeloutstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
         for(b = 0; b < bytewidth; b++)
         {
           out[pixeloutstart + b] = in[pixelinstart + b];
80006066:	15 3b       	ld.ub	r11,r10++
80006068:	12 cb       	st.b	r9++,r11
       for(y = 0; y < passh[i]; y++)
       for(x = 0; x < passw[i]; x++)
       {
         size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
         size_t pixeloutstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
         for(b = 0; b < bytewidth; b++)
8000606a:	2f f8       	sub	r8,-1
8000606c:	0a 38       	cp.w	r8,r5
8000606e:	cf c3       	brcs	80006066 <decodeGeneric+0x10d2>
     for(i = 0; i < 7; i++)
     {
       unsigned x, y, b;
       size_t bytewidth = bpp / 8;
       for(y = 0; y < passh[i]; y++)
       for(x = 0; x < passw[i]; x++)
80006070:	2f fc       	sub	r12,-1
80006072:	64 08       	ld.w	r8,r2[0x0]
80006074:	10 3c       	cp.w	r12,r8
80006076:	ce 43       	brcs	8000603e <decodeGeneric+0x10aa>
80006078:	62 09       	ld.w	r9,r1[0x0]
   {
     for(i = 0; i < 7; i++)
     {
       unsigned x, y, b;
       size_t bytewidth = bpp / 8;
       for(y = 0; y < passh[i]; y++)
8000607a:	2f f7       	sub	r7,-1
8000607c:	cc 7b       	rjmp	8000600a <decodeGeneric+0x1076>
 
           begin += length + 1;
           length = 0;
           for(i = begin; i < chunkLength && data[i] != 0; i++) length++;
           if(begin + length + 1 >= chunkLength) { decoder->error = 75; break; }
           transkey = (char*)malloc(length + 1);
8000607e:	f0 cc ff ff 	sub	r12,r8,-1
80006082:	50 0a       	stdsp	sp[0x0],r10
80006084:	50 18       	stdsp	sp[0x4],r8
80006086:	e0 a0 4f 3b 	rcall	8000fefc <malloc>
8000608a:	51 1c       	stdsp	sp[0x44],r12
8000608c:	18 92       	mov	r2,r12
           if(!transkey) { decoder->error = 9943; break; }
8000608e:	40 0a       	lddsp	r10,sp[0x0]
80006090:	40 18       	lddsp	r8,sp[0x4]
80006092:	c1 50       	breq	800060bc <decodeGeneric+0x1128>
           transkey[length] = 0;
80006094:	f8 08 0b 04 	st.b	r12[r8],r4
80006098:	30 0b       	mov	r11,0
8000609a:	41 09       	lddsp	r9,sp[0x40]
           for(i = 0; i < length; i++) transkey[i] = data[begin + i];
8000609c:	10 3b       	cp.w	r11,r8
8000609e:	c0 72       	brcc	800060ac <decodeGeneric+0x1118>
800060a0:	13 3c       	ld.ub	r12,r9++
800060a2:	41 1e       	lddsp	lr,sp[0x44]
800060a4:	fc 0b 0b 0c 	st.b	lr[r11],r12
800060a8:	2f fb       	sub	r11,-1
800060aa:	cf 9b       	rjmp	8000609c <decodeGeneric+0x1108>
 
           begin += length + 1;
           if(begin > chunkLength)  { decoder->error = 75; break; }
800060ac:	06 3a       	cp.w	r10,r3
800060ae:	e0 88 00 0d 	brls	800060c8 <decodeGeneric+0x1134>
800060b2:	34 b8       	mov	r8,75
800060b4:	ef 48 00 d0 	st.w	r7[208],r8
800060b8:	fe 9f fb fc 	bral	800058b0 <decodeGeneric+0x91c>
           begin += length + 1;
           length = 0;
           for(i = begin; i < chunkLength && data[i] != 0; i++) length++;
           if(begin + length + 1 >= chunkLength) { decoder->error = 75; break; }
           transkey = (char*)malloc(length + 1);
           if(!transkey) { decoder->error = 9943; break; }
800060bc:	e0 68 26 d7 	mov	r8,9943
800060c0:	ef 48 00 d0 	st.w	r7[208],r8
800060c4:	fe 9f fb f6 	bral	800058b0 <decodeGeneric+0x91c>
           transkey[length] = 0;
           for(i = 0; i < length; i++) transkey[i] = data[begin + i];
 
           begin += length + 1;
           if(begin > chunkLength)  { decoder->error = 75; break; }
           length = chunkLength - begin;
800060c8:	14 13       	sub	r3,r10
 
           if(compressed)
800060ca:	40 bc       	lddsp	r12,sp[0x2c]
800060cc:	58 0c       	cp.w	r12,0
800060ce:	c2 70       	breq	8000611c <decodeGeneric+0x1188>
 */
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned LodePNG_decompress(unsigned char** out, size_t* outsize, const unsigned char* in, size_t insize, const LodeZlib_DecompressSettings* settings)
 {
   return LodeZlib_decompress(out, outsize, in, insize, settings);
800060d0:	e0 0a 00 0a 	add	r10,r0,r10
800060d4:	06 99       	mov	r9,r3
800060d6:	fa c0 fe 6c 	sub	r0,sp,-404
800060da:	0e 98       	mov	r8,r7
800060dc:	fa cb fe 68 	sub	r11,sp,-408
800060e0:	00 9c       	mov	r12,r0
800060e2:	fe b0 f4 13 	rcall	80004908 <LodeZlib_decompress>
           if(begin > chunkLength)  { decoder->error = 75; break; }
           length = chunkLength - begin;
 
           if(compressed)
           {
             decoder->error = LodePNG_decompress(&decoded.data, &decoded.size, (unsigned char*)(&data[begin]), length, &decoder->settings.zlibsettings);
800060e6:	ef 4c 00 d0 	st.w	r7[208],r12
 */
 
 #ifdef LODEPNG_COMPILE_DECODER
 static unsigned LodePNG_decompress(unsigned char** out, size_t* outsize, const unsigned char* in, size_t insize, const LodeZlib_DecompressSettings* settings)
 {
   return LodeZlib_decompress(out, outsize, in, insize, settings);
800060ea:	18 93       	mov	r3,r12
           length = chunkLength - begin;
 
           if(compressed)
           {
             decoder->error = LodePNG_decompress(&decoded.data, &decoded.size, (unsigned char*)(&data[begin]), length, &decoder->settings.zlibsettings);
             if(decoder->error) break;
800060ec:	fe 91 fb e2 	brne	800058b0 <decodeGeneric+0x91c>
 }
 #endif /*LODEPNG_COMPILE_ZLIB*/
 
 static unsigned ucvector_push_back(ucvector* p, unsigned char c) /*returns 1 if success, 0 if failure ==> nothing done*/
 {
   if(!ucvector_resize(p, p->size + 1)) return 0;
800060f0:	46 6b       	lddsp	r11,sp[0x198]
800060f2:	00 9c       	mov	r12,r0
800060f4:	2f fb       	sub	r11,-1
800060f6:	fe b0 ea a3 	rcall	8000363c <ucvector_resize>
800060fa:	c0 60       	breq	80006106 <decodeGeneric+0x1172>
   p->data[p->size - 1] = c;
800060fc:	46 69       	lddsp	r9,sp[0x198]
800060fe:	46 58       	lddsp	r8,sp[0x194]
80006100:	12 08       	add	r8,r9
80006102:	f1 63 ff ff 	st.b	r8[-1],r3
             if(!ucvector_resize(&decoded, length + 1)) { decoder->error = 9944; break; }
             decoded.data[length] = 0;
             for(i = 0; i < length; i++) decoded.data[i] = data[begin + i];
           }
 
           decoder->error = LodePNG_IText_add(&decoder->infoPng.itext, key, langtag, transkey, (char*)decoded.data);
80006106:	41 19       	lddsp	r9,sp[0x44]
80006108:	41 2a       	lddsp	r10,sp[0x48]
8000610a:	41 3b       	lddsp	r11,sp[0x4c]
8000610c:	46 58       	lddsp	r8,sp[0x194]
8000610e:	41 5c       	lddsp	r12,sp[0x54]
80006110:	fe b0 eb 4e 	rcall	800037ac <LodePNG_IText_add>
80006114:	ef 4c 00 d0 	st.w	r7[208],r12
 
           break;
80006118:	fe 9f fb cc 	bral	800058b0 <decodeGeneric+0x91c>
             if(decoder->error) break;
             ucvector_push_back(&decoded, 0);
           }
           else
           {
             if(!ucvector_resize(&decoded, length + 1)) { decoder->error = 9944; break; }
8000611c:	50 0a       	stdsp	sp[0x0],r10
8000611e:	e6 cb ff ff 	sub	r11,r3,-1
80006122:	fa cc fe 6c 	sub	r12,sp,-404
80006126:	fe b0 ea 8b 	rcall	8000363c <ucvector_resize>
8000612a:	40 0a       	lddsp	r10,sp[0x0]
8000612c:	c0 71       	brne	8000613a <decodeGeneric+0x11a6>
8000612e:	e0 68 26 d8 	mov	r8,9944
80006132:	ef 48 00 d0 	st.w	r7[208],r8
80006136:	fe 9f fb bd 	bral	800058b0 <decodeGeneric+0x91c>
             decoded.data[length] = 0;
8000613a:	2f 8a       	sub	r10,-8
8000613c:	40 b9       	lddsp	r9,sp[0x2c]
8000613e:	46 58       	lddsp	r8,sp[0x194]
80006140:	ec 0a 00 0a 	add	r10,r6,r10
80006144:	f0 03 0b 09 	st.b	r8[r3],r9
             for(i = 0; i < length; i++) decoded.data[i] = data[begin + i];
80006148:	06 39       	cp.w	r9,r3
8000614a:	cd e2       	brcc	80006106 <decodeGeneric+0x1172>
8000614c:	15 3b       	ld.ub	r11,r10++
8000614e:	46 58       	lddsp	r8,sp[0x194]
80006150:	f0 09 0b 0b 	st.b	r8[r9],r11
80006154:	2f f9       	sub	r9,-1
80006156:	cf 9b       	rjmp	80006148 <decodeGeneric+0x11b4>
80006158:	80 01       	ld.sh	r1,r0[0x0]
8000615a:	70 bc       	ld.w	r12,r8[0x2c]
8000615c:	80 01       	ld.sh	r1,r0[0x0]
8000615e:	71 3c       	ld.w	r12,r8[0x4c]
80006160:	80 01       	ld.sh	r1,r0[0x0]
80006162:	70 8c       	ld.w	r12,r8[0x20]
80006164:	80 01       	ld.sh	r1,r0[0x0]
80006166:	70 94       	ld.w	r4,r8[0x24]
80006168:	80 01       	ld.sh	r1,r0[0x0]
8000616a:	70 9c       	ld.w	r12,r8[0x24]
8000616c:	80 01       	ld.sh	r1,r0[0x0]
8000616e:	70 a4       	ld.w	r4,r8[0x28]
80006170:	80 01       	ld.sh	r1,r0[0x0]
80006172:	70 ac       	ld.w	r12,r8[0x28]
80006174:	80 01       	ld.sh	r1,r0[0x0]
80006176:	70 b4       	ld.w	r4,r8[0x2c]
80006178:	80 01       	ld.sh	r1,r0[0x0]
8000617a:	72 04       	ld.w	r4,r9[0x0]
8000617c:	80 01       	ld.sh	r1,r0[0x0]
8000617e:	71 58       	ld.w	r8,r8[0x54]
80006180:	80 01       	ld.sh	r1,r0[0x0]
80006182:	71 74       	ld.w	r4,r8[0x5c]
80006184:	80 01       	ld.sh	r1,r0[0x0]
80006186:	6f 38       	ld.w	r8,r7[0x4c]

80006188 <LodePNG_decode>:
80006188:	d4 21       	pushm	r4-r7,lr
8000618a:	30 04       	mov	r4,0
8000618c:	97 04       	st.w	r11[0x0],r4
8000618e:	18 97       	mov	r7,r12
80006190:	16 96       	mov	r6,r11
80006192:	14 95       	mov	r5,r10
80006194:	95 04       	st.w	r10[0x0],r4
80006196:	fe b0 f6 ff 	rcall	80004f94 <decodeGeneric>
8000619a:	ee f8 00 d0 	ld.w	r8,r7[208]
8000619e:	58 08       	cp.w	r8,0
800061a0:	c3 71       	brne	8000620e <LodePNG_decode+0x86>
800061a2:	6e 28       	ld.w	r8,r7[0x8]
800061a4:	58 08       	cp.w	r8,0
800061a6:	c3 51       	brne	80006210 <LodePNG_decode+0x88>
800061a8:	ee c6 ff b8 	sub	r6,r7,-72
800061ac:	ee c5 ff ec 	sub	r5,r7,-20
800061b0:	6e 7c       	ld.w	r12,r7[0x1c]
800061b2:	58 0c       	cp.w	r12,0
800061b4:	c0 30       	breq	800061ba <LodePNG_decode+0x32>
800061b6:	e0 a0 4e 9b 	rcall	8000feec <free>
800061ba:	30 04       	mov	r4,0
800061bc:	8f 84       	st.w	r7[0x20],r4
800061be:	ec e8 00 00 	ld.d	r8,r6[0]
 
 unsigned LodePNG_InfoColor_copy(LodePNG_InfoColor* dest, const LodePNG_InfoColor* source)
 {
   size_t i;
   LodePNG_InfoColor_cleanup(dest);
   *dest = *source;
800061c2:	ea e9 00 00 	st.d	r5[0],r8
800061c6:	ec e8 00 08 	ld.d	r8,r6[8]
800061ca:	ea e9 00 08 	st.d	r5[8],r8
800061ce:	ec e8 00 10 	ld.d	r8,r6[16]
800061d2:	ea e9 00 10 	st.d	r5[16],r8
800061d6:	ec e8 00 18 	ld.d	r8,r6[24]
800061da:	ea e9 00 18 	st.d	r5[24],r8
   dest->palette = (unsigned char*)malloc(source->palettesize * 4);
800061de:	6f 5c       	ld.w	r12,r7[0x54]
800061e0:	a3 6c       	lsl	r12,0x2
800061e2:	e0 a0 4e 8d 	rcall	8000fefc <malloc>
800061e6:	8f 7c       	st.w	r7[0x1c],r12
   if(!dest->palette && source->palettesize) return 9935;
800061e8:	c5 20       	breq	8000628c <LodePNG_decode+0x104>
   for(i = 0; i < source->palettesize * 4; i++) dest->palette[i] = source->palette[i];
800061ea:	6f 58       	ld.w	r8,r7[0x54]
800061ec:	a3 68       	lsl	r8,0x2
800061ee:	c0 c0       	breq	80006206 <LodePNG_decode+0x7e>
800061f0:	6c 28       	ld.w	r8,r6[0x8]
800061f2:	f0 04 07 09 	ld.ub	r9,r8[r4]
800061f6:	6a 28       	ld.w	r8,r5[0x8]
800061f8:	f0 04 0b 09 	st.b	r8[r4],r9
800061fc:	2f f4       	sub	r4,-1
800061fe:	6c 38       	ld.w	r8,r6[0xc]
80006200:	a3 68       	lsl	r8,0x2
80006202:	10 34       	cp.w	r4,r8
80006204:	cf 63       	brcs	800061f0 <LodePNG_decode+0x68>
80006206:	30 08       	mov	r8,0
   {
     /*color conversion needed; sort of copy of the data*/
     unsigned char* data = *out;
 
     /*TODO: check if this works according to the statement in the documentation: "The converter can convert from greyscale input color type, to 8-bit greyscale or greyscale with alpha"*/
     if(!(decoder->infoRaw.color.colorType == 2 || decoder->infoRaw.color.colorType == 6) && !(decoder->infoRaw.color.bitDepth == 8)) { decoder->error = 56; return; }
80006208:	ef 48 00 d0 	st.w	r7[208],r8
8000620c:	d8 22       	popm	r4-r7,pc
8000620e:	d8 22       	popm	r4-r7,pc
 unsigned LodePNG_InfoColor_isAlphaType(const LodePNG_InfoColor* info) { return (info->colorType & 4) != 0; }
 
 unsigned LodePNG_InfoColor_equal(const LodePNG_InfoColor* info1, const LodePNG_InfoColor* info2)
 {
   return info1->colorType == info2->colorType
       && info1->bitDepth  == info2->bitDepth; /*palette and color key not compared*/
80006210:	6e 58       	ld.w	r8,r7[0x14]
 {
   *out = 0;
   *outsize = 0;
   decodeGeneric(decoder, out, outsize, in, insize);
   if(decoder->error) return;
   if(!decoder->settings.color_convert || LodePNG_InfoColor_equal(&decoder->infoRaw.color, &decoder->infoPng.color))
80006212:	6f 29       	ld.w	r9,r7[0x48]
80006214:	12 38       	cp.w	r8,r9
80006216:	c3 20       	breq	8000627a <LodePNG_decode+0xf2>
     {
       decoder->error = 9947;
       *outsize = 0;
     }
     else decoder->error = LodePNG_convert(*out, data, &decoder->infoRaw.color, &decoder->infoPng.color, decoder->infoPng.width, decoder->infoPng.height);
     free(data);
80006218:	6e 69       	ld.w	r9,r7[0x18]
   {
     /*color conversion needed; sort of copy of the data*/
     unsigned char* data = *out;
 
     /*TODO: check if this works according to the statement in the documentation: "The converter can convert from greyscale input color type, to 8-bit greyscale or greyscale with alpha"*/
     if(!(decoder->infoRaw.color.colorType == 2 || decoder->infoRaw.color.colorType == 6) && !(decoder->infoRaw.color.bitDepth == 8)) { decoder->error = 56; return; }
8000621a:	58 68       	cp.w	r8,6
8000621c:	5f 1b       	srne	r11
8000621e:	58 28       	cp.w	r8,2
80006220:	5f 1a       	srne	r10
     }
   }
   else
   {
     /*color conversion needed; sort of copy of the data*/
     unsigned char* data = *out;
80006222:	6c 04       	ld.w	r4,r6[0x0]
 
     /*TODO: check if this works according to the statement in the documentation: "The converter can convert from greyscale input color type, to 8-bit greyscale or greyscale with alpha"*/
     if(!(decoder->infoRaw.color.colorType == 2 || decoder->infoRaw.color.colorType == 6) && !(decoder->infoRaw.color.bitDepth == 8)) { decoder->error = 56; return; }
80006224:	f7 ea 00 0a 	and	r10,r11,r10
80006228:	c2 51       	brne	80006272 <LodePNG_decode+0xea>
 
     *outsize = (decoder->infoPng.width * decoder->infoPng.height * LodePNG_InfoColor_getBpp(&decoder->infoRaw.color) + 7) / 8;
8000622a:	6e da       	ld.w	r10,r7[0x34]
8000622c:	6e eb       	ld.w	r11,r7[0x38]
8000622e:	58 68       	cp.w	r8,6
80006230:	e0 88 00 2a 	brls	80006284 <LodePNG_decode+0xfc>
80006234:	30 0c       	mov	r12,0
80006236:	f6 0a 02 48 	mul	r8,r11,r10
8000623a:	f0 09 02 49 	mul	r9,r8,r9
8000623e:	f2 0c 02 4c 	mul	r12,r9,r12
80006242:	2f 9c       	sub	r12,-7
80006244:	a3 9c       	lsr	r12,0x3
80006246:	8b 0c       	st.w	r5[0x0],r12
     *out = (unsigned char*)malloc(*outsize);
80006248:	e0 a0 4e 5a 	rcall	8000fefc <malloc>
8000624c:	8d 0c       	st.w	r6[0x0],r12
     if(!(*out))
8000624e:	c2 50       	breq	80006298 <LodePNG_decode+0x110>
     {
       decoder->error = 9947;
       *outsize = 0;
     }
     else decoder->error = LodePNG_convert(*out, data, &decoder->infoRaw.color, &decoder->infoPng.color, decoder->infoPng.width, decoder->infoPng.height);
80006250:	6e e8       	ld.w	r8,r7[0x38]
80006252:	ee c9 ff b8 	sub	r9,r7,-72
80006256:	1a d8       	st.w	--sp,r8
80006258:	ee ca ff ec 	sub	r10,r7,-20
8000625c:	6e d8       	ld.w	r8,r7[0x34]
8000625e:	08 9b       	mov	r11,r4
80006260:	fe b0 df de 	rcall	8000221c <LodePNG_convert>
80006264:	2f fd       	sub	sp,-4
80006266:	ef 4c 00 d0 	st.w	r7[208],r12
     free(data);
8000626a:	08 9c       	mov	r12,r4
8000626c:	e0 a0 4e 40 	rcall	8000feec <free>
80006270:	d8 22       	popm	r4-r7,pc
   {
     /*color conversion needed; sort of copy of the data*/
     unsigned char* data = *out;
 
     /*TODO: check if this works according to the statement in the documentation: "The converter can convert from greyscale input color type, to 8-bit greyscale or greyscale with alpha"*/
     if(!(decoder->infoRaw.color.colorType == 2 || decoder->infoRaw.color.colorType == 6) && !(decoder->infoRaw.color.bitDepth == 8)) { decoder->error = 56; return; }
80006272:	58 89       	cp.w	r9,8
80006274:	cd b0       	breq	8000622a <LodePNG_decode+0xa2>
80006276:	33 88       	mov	r8,56
80006278:	cc 8b       	rjmp	80006208 <LodePNG_decode+0x80>
 unsigned LodePNG_InfoColor_isAlphaType(const LodePNG_InfoColor* info) { return (info->colorType & 4) != 0; }
 
 unsigned LodePNG_InfoColor_equal(const LodePNG_InfoColor* info1, const LodePNG_InfoColor* info2)
 {
   return info1->colorType == info2->colorType
       && info1->bitDepth  == info2->bitDepth; /*palette and color key not compared*/
8000627a:	6e 69       	ld.w	r9,r7[0x18]
 {
   *out = 0;
   *outsize = 0;
   decodeGeneric(decoder, out, outsize, in, insize);
   if(decoder->error) return;
   if(!decoder->settings.color_convert || LodePNG_InfoColor_equal(&decoder->infoRaw.color, &decoder->infoPng.color))
8000627c:	6f 3a       	ld.w	r10,r7[0x4c]
8000627e:	14 39       	cp.w	r9,r10
80006280:	cc d1       	brne	8000621a <LodePNG_decode+0x92>
80006282:	d8 22       	popm	r4-r7,pc
     unsigned char* data = *out;
 
     /*TODO: check if this works according to the statement in the documentation: "The converter can convert from greyscale input color type, to 8-bit greyscale or greyscale with alpha"*/
     if(!(decoder->infoRaw.color.colorType == 2 || decoder->infoRaw.color.colorType == 6) && !(decoder->infoRaw.color.bitDepth == 8)) { decoder->error = 56; return; }
 
     *outsize = (decoder->infoPng.width * decoder->infoPng.height * LodePNG_InfoColor_getBpp(&decoder->infoRaw.color) + 7) / 8;
80006284:	48 8c       	lddpc	r12,800062a4 <LodePNG_decode+0x11c>
80006286:	f8 08 03 2c 	ld.w	r12,r12[r8<<0x2]
8000628a:	cd 6b       	rjmp	80006236 <LodePNG_decode+0xae>
     /*same color type, no copying or converting of data needed*/
     /*store the infoPng color settings on the infoRaw so that the infoRaw still reflects what colorType
     the raw image has to the end user*/
     if(!decoder->settings.color_convert)
     {
       decoder->error = LodePNG_InfoColor_copy(&decoder->infoRaw.color, &decoder->infoPng.color);
8000628c:	6f 58       	ld.w	r8,r7[0x54]
8000628e:	58 08       	cp.w	r8,0
80006290:	cb b0       	breq	80006206 <LodePNG_decode+0x7e>
80006292:	e0 68 26 cf 	mov	r8,9935
80006296:	cb 9b       	rjmp	80006208 <LodePNG_decode+0x80>
 
     *outsize = (decoder->infoPng.width * decoder->infoPng.height * LodePNG_InfoColor_getBpp(&decoder->infoRaw.color) + 7) / 8;
     *out = (unsigned char*)malloc(*outsize);
     if(!(*out))
     {
       decoder->error = 9947;
80006298:	e0 69 26 db 	mov	r9,9947
8000629c:	ef 49 00 d0 	st.w	r7[208],r9
       *outsize = 0;
800062a0:	8b 0c       	st.w	r5[0x0],r12
800062a2:	ce 4b       	rjmp	8000626a <LodePNG_decode+0xe2>
800062a4:	80 01       	ld.sh	r1,r0[0x0]
800062a6:	71 3c       	ld.w	r12,r8[0x4c]

800062a8 <apu_init>:
  Byte delta_control;
  Byte delta_da;
  Byte delta_address;
  Byte delta_dataLength;
};
APU apu_init(void) {
800062a8:	d4 01       	pushm	lr
  APU apu = (APU) malloc(sizeof(struct apu));
800062aa:	31 3c       	mov	r12,19
800062ac:	e0 a0 4e 28 	rcall	8000fefc <malloc>
  assert(apu != NULL);
800062b0:	c2 10       	breq	800062f2 <apu_init+0x4a>
  apu->pulse1_control = 0;
800062b2:	30 09       	mov	r9,0
  apu->noise_frequency1 = 0;
  apu->noise_frequency2 = 0;
  apu->delta_control = 0;
  apu->delta_da = 0;
  apu->delta_address = 0;
  apu->delta_dataLength = 0;
800062b4:	f9 69 00 12 	st.b	r12[18],r9
  Byte delta_dataLength;
};
APU apu_init(void) {
  APU apu = (APU) malloc(sizeof(struct apu));
  assert(apu != NULL);
  apu->pulse1_control = 0;
800062b8:	b8 89       	st.b	r12[0x0],r9
  apu->pulse1_rampControl = 0;
800062ba:	b8 99       	st.b	r12[0x1],r9
  apu->pulse1_fineTune = 0;
800062bc:	b8 a9       	st.b	r12[0x2],r9
  apu->pulse1_courseTune = 0;
800062be:	b8 b9       	st.b	r12[0x3],r9
  apu->pulse2_control = 0;
800062c0:	b8 c9       	st.b	r12[0x4],r9
  apu->pulse2_rampControl = 0;
800062c2:	b8 d9       	st.b	r12[0x5],r9
  apu->pulse2_fineTune = 0;
800062c4:	b8 e9       	st.b	r12[0x6],r9
  apu->pulse2_courseTune = 0;
800062c6:	b8 f9       	st.b	r12[0x7],r9
  apu->triangle_control1 = 0;
800062c8:	f9 69 00 08 	st.b	r12[8],r9
  apu->triangle_control2 = 0;
800062cc:	f9 69 00 09 	st.b	r12[9],r9
  apu->triangle_frequency1 = 0;
800062d0:	f9 69 00 0a 	st.b	r12[10],r9
  apu->triangle_frequency2 = 0;
800062d4:	f9 69 00 0b 	st.b	r12[11],r9
  apu->noise_control1 = 0;
800062d8:	f9 69 00 0c 	st.b	r12[12],r9
  apu->noise_frequency1 = 0;
800062dc:	f9 69 00 0d 	st.b	r12[13],r9
  apu->noise_frequency2 = 0;
800062e0:	f9 69 00 0e 	st.b	r12[14],r9
  apu->delta_control = 0;
800062e4:	f9 69 00 0f 	st.b	r12[15],r9
  apu->delta_da = 0;
800062e8:	f9 69 00 10 	st.b	r12[16],r9
  apu->delta_address = 0;
800062ec:	f9 69 00 11 	st.b	r12[17],r9
  apu->delta_dataLength = 0;
  return apu;
}
800062f0:	d8 02       	popm	pc
  Byte delta_address;
  Byte delta_dataLength;
};
APU apu_init(void) {
  APU apu = (APU) malloc(sizeof(struct apu));
  assert(apu != NULL);
800062f2:	48 49       	lddpc	r9,80006300 <apu_init+0x58>
800062f4:	48 4a       	lddpc	r10,80006304 <apu_init+0x5c>
800062f6:	31 eb       	mov	r11,30
800062f8:	48 4c       	lddpc	r12,80006308 <apu_init+0x60>
800062fa:	e0 a0 4d d3 	rcall	8000fea0 <__assert_func>
800062fe:	d7 03       	nop
80006300:	80 01       	ld.sh	r1,r0[0x0]
80006302:	72 2c       	ld.w	r12,r9[0x8]
80006304:	80 01       	ld.sh	r1,r0[0x0]
80006306:	72 20       	ld.w	r0,r9[0x8]
80006308:	80 01       	ld.sh	r1,r0[0x0]
8000630a:	72 38       	ld.w	r8,r9[0xc]

8000630c <cartridge_getNumProgramBanks>:


Byte cartridge_getNumProgramBanks(Cartridge cartridge1) {
//  assert(cartridge1 != NULL);
  return cartridge1->numProgramBanks;
}
8000630c:	19 8c       	ld.ub	r12,r12[0x0]
8000630e:	5e fc       	retal	r12

80006310 <cartridge_readProgramBank>:
inline Byte cartridge_readProgramBank(Cartridge cartridge1, Byte bank, Address address) {
80006310:	78 48       	ld.w	r8,r12[0x10]
80006312:	5c 7a       	castu.h	r10
80006314:	f0 0b 03 28 	ld.w	r8,r8[r11<<0x2]
 // assert(cartridge1 != NULL);
 // assert(bank < cartridge1->numProgramBanks);
//  assert(address < BYTES_PER_PROGRAM_BANK);
  return cartridge1->programBanks[bank]->bytes[address];
}
80006318:	f0 0a 07 0c 	ld.ub	r12,r8[r10]
8000631c:	5e fc       	retal	r12

8000631e <cartridge_readCharacterBank>:
inline Byte cartridge_readCharacterBank(Cartridge cartridge1, Byte bank, Address address) {
8000631e:	78 38       	ld.w	r8,r12[0xc]
80006320:	5c 7a       	castu.h	r10
80006322:	f0 0b 03 28 	ld.w	r8,r8[r11<<0x2]
 // assert(cartridge1 != NULL);
  //assert(bank < cartridge1->numCharacterBanks);
  //assert(address < BYTES_PER_CHARACTER_BANK);
  return cartridge1->characterBanks[bank]->bytes[address];
}
80006326:	f0 0a 07 0c 	ld.ub	r12,r8[r10]
8000632a:	5e fc       	retal	r12

8000632c <cartridge_getMMUNumber>:
  free(cartridge1);
}
Byte cartridge_getMMUNumber(Cartridge cartridge1) {
 // assert(cartridge1 != NULL);
  return cartridge1->mmuNumber;
}
8000632c:	f9 3c 00 0a 	ld.ub	r12,r12[10]
80006330:	5e fc       	retal	r12

80006332 <cartridge_getNumCharacterBanks>:
Byte cartridge_getNumCharacterBanks(Cartridge cartridge1) {
 // assert(cartridge1 != NULL);
  return cartridge1->numCharacterBanks;
}
80006332:	19 9c       	ld.ub	r12,r12[0x1]
80006334:	5e fc       	retal	r12

80006336 <cartridge_getMirrorType>:

MirrorType cartridge_getMirrorType(Cartridge cartridge1) {
 // assert(cartridge1 != NULL);
  return (cartridge1->mirrorType);
}
80006336:	78 1c       	ld.w	r12,r12[0x4]
80006338:	5e fc       	retal	r12
8000633a:	d7 03       	nop

8000633c <initHeader>:
  Byte  controlByte2;
  Byte  numRamBanks;
  Byte  magicReservedValues[7];
};

void initHeader( Header header1){
8000633c:	eb cd 40 e0 	pushm	r5-r7,lr
80006340:	20 1d       	sub	sp,4
80006342:	18 97       	mov	r7,r12
	//file_read_buf(&(header1->magicLabel),sizeof(header1->magicLabel));
	
	header1->magicLabel[0]=(uint8_t)file_getc();
80006344:	e0 a0 3e 5a 	rcall	8000dff8 <file_getc>
80006348:	ae 8c       	st.b	r7[0x0],r12
	header1->magicLabel[1]=(uint8_t)file_getc();
8000634a:	e0 a0 3e 57 	rcall	8000dff8 <file_getc>
8000634e:	ae 9c       	st.b	r7[0x1],r12
	header1->magicLabel[2]=(uint8_t)file_getc();
80006350:	e0 a0 3e 54 	rcall	8000dff8 <file_getc>
	char mensaje[]={""};
	char z;
	
	

sprintf(mensaje,"%c",header1->magicLabel[0]);
80006354:	0f 88       	ld.ub	r8,r7[0x0]
void initHeader( Header header1){
	//file_read_buf(&(header1->magicLabel),sizeof(header1->magicLabel));
	
	header1->magicLabel[0]=(uint8_t)file_getc();
	header1->magicLabel[1]=(uint8_t)file_getc();
	header1->magicLabel[2]=(uint8_t)file_getc();
80006356:	ae ac       	st.b	r7[0x2],r12
	char mensaje[]={""};
	char z;
	
	

sprintf(mensaje,"%c",header1->magicLabel[0]);
80006358:	1a 96       	mov	r6,sp
8000635a:	1a d8       	st.w	--sp,r8
	//file_read_buf(&(header1->magicLabel),sizeof(header1->magicLabel));
	
	header1->magicLabel[0]=(uint8_t)file_getc();
	header1->magicLabel[1]=(uint8_t)file_getc();
	header1->magicLabel[2]=(uint8_t)file_getc();
	char mensaje[]={""};
8000635c:	49 88       	lddpc	r8,800063bc <initHeader+0x80>
8000635e:	11 88       	ld.ub	r8,r8[0x0]
	char z;
	
	

sprintf(mensaje,"%c",header1->magicLabel[0]);
80006360:	49 85       	lddpc	r5,800063c0 <initHeader+0x84>
	//file_read_buf(&(header1->magicLabel),sizeof(header1->magicLabel));
	
	header1->magicLabel[0]=(uint8_t)file_getc();
	header1->magicLabel[1]=(uint8_t)file_getc();
	header1->magicLabel[2]=(uint8_t)file_getc();
	char mensaje[]={""};
80006362:	ba c8       	st.b	sp[0x4],r8
	char z;
	
	

sprintf(mensaje,"%c",header1->magicLabel[0]);
80006364:	0a 9b       	mov	r11,r5
80006366:	0c 9c       	mov	r12,r6
80006368:	e0 a0 52 10 	rcall	80010788 <sprintf>
//et024006_PrintString(mensaje,(const unsigned char*)&FONT8x8,10,110+(l+=10),BLUE,-1);
//usart_write_line(&AVR32_USART0,mensaje);


sprintf(mensaje,"%c",header1->magicLabel[1]);
8000636c:	0f 98       	ld.ub	r8,r7[0x1]
8000636e:	0a 9b       	mov	r11,r5
80006370:	1a d8       	st.w	--sp,r8
80006372:	0c 9c       	mov	r12,r6
80006374:	e0 a0 52 0a 	rcall	80010788 <sprintf>
//et024006_PrintString(mensaje,(const unsigned char*)&FONT8x8,10,110+(l+=10),BLUE,-1);
//usart_write_line(&AVR32_USART0,mensaje);


sprintf(mensaje,"%c",header1->magicLabel[2]);
80006378:	0f a8       	ld.ub	r8,r7[0x2]
8000637a:	0a 9b       	mov	r11,r5
8000637c:	1a d8       	st.w	--sp,r8
8000637e:	0c 9c       	mov	r12,r6
80006380:	e0 a0 52 04 	rcall	80010788 <sprintf>
//et024006_PrintString(mensaje,(const unsigned char*)&FONT8x8,10,110+(l+=10),BLUE,-1);
//usart_write_line(&AVR32_USART0,mensaje);
	
	header1->magicValue= file_getc();
80006384:	e0 a0 3e 3a 	rcall	8000dff8 <file_getc>
80006388:	ae bc       	st.b	r7[0x3],r12
	header1->numProgramBanks= file_getc();
8000638a:	e0 a0 3e 37 	rcall	8000dff8 <file_getc>
8000638e:	ae cc       	st.b	r7[0x4],r12
	header1->numCharacterBanks= file_getc();
80006390:	e0 a0 3e 34 	rcall	8000dff8 <file_getc>
80006394:	ae dc       	st.b	r7[0x5],r12
	header1->controlByte1= file_getc();
80006396:	e0 a0 3e 31 	rcall	8000dff8 <file_getc>
8000639a:	ae ec       	st.b	r7[0x6],r12
	header1->controlByte2= file_getc();
8000639c:	e0 a0 3e 2e 	rcall	8000dff8 <file_getc>
800063a0:	ae fc       	st.b	r7[0x7],r12
	header1->numRamBanks= file_getc();
800063a2:	e0 a0 3e 2b 	rcall	8000dff8 <file_getc>
	file_read_buf(header1->magicReservedValues,sizeof(header1->magicReservedValues));
800063a6:	30 7b       	mov	r11,7
	header1->magicValue= file_getc();
	header1->numProgramBanks= file_getc();
	header1->numCharacterBanks= file_getc();
	header1->controlByte1= file_getc();
	header1->controlByte2= file_getc();
	header1->numRamBanks= file_getc();
800063a8:	ef 6c 00 08 	st.b	r7[8],r12
	file_read_buf(header1->magicReservedValues,sizeof(header1->magicReservedValues));
800063ac:	ee cc ff f7 	sub	r12,r7,-9
800063b0:	e0 a0 3e a4 	rcall	8000e0f8 <file_read_buf>
800063b4:	2f dd       	sub	sp,-12
	};
800063b6:	2f fd       	sub	sp,-4
800063b8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800063bc:	80 01       	ld.sh	r1,r0[0x0]
800063be:	83 64       	st.w	r1[0x18],r4
800063c0:	80 01       	ld.sh	r1,r0[0x0]
800063c2:	72 a8       	ld.w	r8,r9[0x28]

800063c4 <cartridge_init>:
800063c4:	eb cd 40 e0 	pushm	r5-r7,lr
800063c8:	e0 6c 00 94 	mov	r12,148
800063cc:	e0 a0 4d 98 	rcall	8000fefc <malloc>
static void parseTitle(Cartridge cartridge1) {
 // assert(cartridge1 != NULL);
  //fread(cartridge->title, sizeof(Byte), 128, file);
}
Cartridge cartridge_init( int filename) {
  Cartridge cartridge1 = malloc(sizeof(struct cartridge));
800063d0:	18 97       	mov	r7,r12
  assert(cartridge1 != NULL);
800063d2:	e0 80 01 12 	breq	800065f6 <cartridge_init+0x232>
  //nav_filterlist_goto((uint16_t)filename); 
  
  //file_open(FOPEN_MODE_R);
  //assert(file != NULL);
  cartridge1->numProgramBanks = 0;
800063d6:	30 08       	mov	r8,0
  cartridge1->hasTrainer = FALSE;
  cartridge1->mmuNumber = 0;
  cartridge1->numRamBanks = 0;
  cartridge1->characterBanks = NULL;
  cartridge1->programBanks = NULL;
  cartridge1->title[0] = 0;
800063d8:	f9 68 00 14 	st.b	r12[20],r8
  assert(cartridge1 != NULL);
  //nav_filterlist_goto((uint16_t)filename); 
  
  //file_open(FOPEN_MODE_R);
  //assert(file != NULL);
  cartridge1->numProgramBanks = 0;
800063dc:	b8 88       	st.b	r12[0x0],r8
  cartridge1->numCharacterBanks = 0;
800063de:	b8 98       	st.b	r12[0x1],r8
  cartridge1->mirrorType = HORIZONTAL;
  cartridge1->hasBatteryPack = FALSE;
  cartridge1->hasTrainer = FALSE;
800063e0:	f9 68 00 09 	st.b	r12[9],r8
  cartridge1->mmuNumber = 0;
800063e4:	f9 68 00 0a 	st.b	r12[10],r8
  cartridge1->numRamBanks = 0;
800063e8:	f9 68 00 0b 	st.b	r12[11],r8
  
  //file_open(FOPEN_MODE_R);
  //assert(file != NULL);
  cartridge1->numProgramBanks = 0;
  cartridge1->numCharacterBanks = 0;
  cartridge1->mirrorType = HORIZONTAL;
800063ec:	30 08       	mov	r8,0
  cartridge1->hasBatteryPack = FALSE;
  cartridge1->hasTrainer = FALSE;
  cartridge1->mmuNumber = 0;
  cartridge1->numRamBanks = 0;
  cartridge1->characterBanks = NULL;
  cartridge1->programBanks = NULL;
800063ee:	99 48       	st.w	r12[0x10],r8
  
  //file_open(FOPEN_MODE_R);
  //assert(file != NULL);
  cartridge1->numProgramBanks = 0;
  cartridge1->numCharacterBanks = 0;
  cartridge1->mirrorType = HORIZONTAL;
800063f0:	99 18       	st.w	r12[0x4],r8
  cartridge1->hasBatteryPack = FALSE;
800063f2:	f9 68 00 08 	st.b	r12[8],r8
  cartridge1->hasTrainer = FALSE;
  cartridge1->mmuNumber = 0;
  cartridge1->numRamBanks = 0;
  cartridge1->characterBanks = NULL;
800063f6:	99 38       	st.w	r12[0xc],r8
//static void parseHeader(Cartridge cartridge, FILE *file) {
static void parseHeader(Cartridge cartridge1) {
  //assert(cartridge1 != NULL);
  //assert(file != NULL);
  //file_seek(0, FS_SEEK_SET);
  Header header1 = malloc(sizeof(struct header));
800063f8:	31 0c       	mov	r12,16
800063fa:	e0 a0 4d 81 	rcall	8000fefc <malloc>
800063fe:	18 96       	mov	r6,r12
  //assert(fread(header, sizeof(struct header), 1, file) == 1);
 // file_read_buf( header,sizeof(struct header));
  //memcpy(&rawData[0],&header,sizeof(struct header));
  
  initHeader(header1);
80006400:	c9 ef       	rcall	8000633c <initHeader>
80006402:	0d 89       	ld.ub	r9,r6[0x0]
  //usart_write_line(&AVR32_USART0,"parsing Header");
  assert(header1->magicLabel[0] == 'N');
80006404:	34 e8       	mov	r8,78
80006406:	f0 09 18 00 	cp.b	r9,r8
8000640a:	e0 81 00 d5 	brne	800065b4 <cartridge_init+0x1f0>
8000640e:	0d 99       	ld.ub	r9,r6[0x1]
  assert(header1->magicLabel[1] == 'E');
80006410:	34 58       	mov	r8,69
80006412:	f0 09 18 00 	cp.b	r9,r8
80006416:	e0 81 00 dc 	brne	800065ce <cartridge_init+0x20a>
8000641a:	0d a9       	ld.ub	r9,r6[0x2]
  assert(header1->magicLabel[2] == 'S');
8000641c:	35 38       	mov	r8,83
8000641e:	f0 09 18 00 	cp.b	r9,r8
80006422:	e0 81 00 cf 	brne	800065c0 <cartridge_init+0x1fc>
80006426:	0d b9       	ld.ub	r9,r6[0x3]
  //usart_write_line(&AVR32_USART0,"parsing Header2");
  assert(header1->magicValue == 0x1A);
80006428:	31 a8       	mov	r8,26
8000642a:	f0 09 18 00 	cp.b	r9,r8
8000642e:	e0 81 00 eb 	brne	80006604 <cartridge_init+0x240>
80006432:	0d c8       	ld.ub	r8,r6[0x4]
  //usart_write_line(&AVR32_USART0,"parsing Header3");
  cartridge1->numProgramBanks = header1->numProgramBanks;
80006434:	ae 88       	st.b	r7[0x0],r8
80006436:	58 08       	cp.w	r8,0
  assert(cartridge1->numProgramBanks > 0);
80006438:	e0 80 00 a9 	breq	8000658a <cartridge_init+0x1c6>
8000643c:	0d d8       	ld.ub	r8,r6[0x5]
  //usart_write_line(&AVR32_USART0,"parsing Header4");
  cartridge1->numCharacterBanks = header1->numCharacterBanks;
8000643e:	ae 98       	st.b	r7[0x1],r8
80006440:	ed 38 00 08 	ld.ub	r8,r6[8]
  cartridge1->numRamBanks = header1->numRamBanks;
80006444:	ef 68 00 0b 	st.b	r7[11],r8
80006448:	0d e8       	ld.ub	r8,r6[0x6]
  if ((header1->controlByte1 & MASK_BIT3) == MASK_BIT3) {
8000644a:	ed b8 00 03 	bld	r8,0x3
8000644e:	c7 c1       	brne	80006546 <cartridge_init+0x182>
80006450:	30 29       	mov	r9,2
    cartridge1->mirrorType = BOTH;
80006452:	8f 19       	st.w	r7[0x4],r9
80006454:	10 99       	mov	r9,r8
  } else if ((header1->controlByte1 & MASK_BIT0) == MASK_BIT0) {
    cartridge1->mirrorType = VERTICAL;
  } else {
    assert(FALSE);
  }
  if ((header1->controlByte1 & MASK_BIT1) == MASK_BIT1) {
80006456:	e2 19 00 02 	andl	r9,0x2,COH
8000645a:	f9 b9 01 01 	movne	r9,1
    cartridge1->hasBatteryPack = 1;
8000645e:	ef f9 1e 08 	st.bne	r7[0x8],r9
80006462:	ef f9 0e 08 	st.beq	r7[0x8],r9
  } else {
    cartridge1->hasBatteryPack = 0;
80006466:	10 99       	mov	r9,r8
  }
  if ((header1->controlByte1 & MASK_BIT2) == MASK_BIT2) {
80006468:	e2 19 00 04 	andl	r9,0x4,COH
8000646c:	f9 b9 01 01 	movne	r9,1
    cartridge1->hasTrainer = 1;
80006470:	ef f9 1e 09 	st.bne	r7[0x9],r9
80006474:	ef f9 0e 09 	st.beq	r7[0x9],r9
  } else {
    cartridge1->hasTrainer = 0;
80006478:	a5 88       	lsr	r8,0x4
  }
  cartridge1->mmuNumber = (header1->controlByte1 & (MASK_BIT4 | MASK_BIT5 | MASK_BIT6 |MASK_BIT7)) >> 4;
  cartridge1->mmuNumber += header1->controlByte2 & (MASK_BIT4 | MASK_BIT5 | MASK_BIT6 |MASK_BIT7);
8000647a:	0d f5       	ld.ub	r5,r6[0x7]
8000647c:	0a 99       	mov	r9,r5
8000647e:	e0 19 ff f0 	andl	r9,0xfff0
80006482:	f2 08 00 08 	add	r8,r9,r8
80006486:	ef 68 00 0a 	st.b	r7[10],r8
8000648a:	ed b5 00 00 	bld	r5,0x0
  assert((header1->controlByte2 & MASK_BIT0) == 0);
8000648e:	c7 70       	breq	8000657c <cartridge_init+0x1b8>
80006490:	ed b5 00 01 	bld	r5,0x1
  assert((header1->controlByte2 & MASK_BIT1) == 0);
80006494:	c6 d0       	breq	8000656e <cartridge_init+0x1aa>
80006496:	ed b5 00 02 	bld	r5,0x2
  assert((header1->controlByte2 & MASK_BIT2) == 0);
8000649a:	e0 80 00 86 	breq	800065a6 <cartridge_init+0x1e2>
8000649e:	e2 15 00 08 	andl	r5,0x8,COH
  assert((header1->controlByte2 & MASK_BIT3) == 0);
800064a2:	e0 81 00 9c 	brne	800065da <cartridge_init+0x216>
800064a6:	0a 9b       	mov	r11,r5
    assert(header1->magicReservedValues[i] == 0);
  }
  */
  //usart_write_line(&AVR32_USART0,"parsing Header6");
  
  file_seek(sizeof(struct header), FS_SEEK_SET);
800064a8:	31 0c       	mov	r12,16
800064aa:	e0 a0 3d 4b 	rcall	8000df40 <file_seek>
800064ae:	ef 38 00 09 	ld.ub	r8,r7[9]
  if (cartridge1->hasTrainer) {
800064b2:	ea 08 18 00 	cp.b	r8,r5
800064b6:	c0 60       	breq	800064c2 <cartridge_init+0xfe>
800064b8:	30 3b       	mov	r11,3
    file_seek(TRAINER_BYTES, FS_SEEK_CUR_FW);
800064ba:	e0 6c 02 00 	mov	r12,512
800064be:	e0 a0 3d 41 	rcall	8000df40 <file_seek>
800064c2:	0c 9c       	mov	r12,r6
  }
  free(header1);
800064c4:	e0 a0 4d 14 	rcall	8000feec <free>
800064c8:	0f 8c       	ld.ub	r12,r7[0x0]
//static void parseProgramBanks(Cartridge cartridge, FILE *file) {
static void parseProgramBanks(Cartridge cartridge1) {
  assert(cartridge1 != NULL);
  //usart_write_line(&AVR32_USART0,"parse BANK1");
  //assert(file != NULL);
  cartridge1->programBanks = (ProgramBank*) malloc(sizeof(ProgramBank) * cartridge1->numProgramBanks);
800064ca:	a3 6c       	lsl	r12,0x2
800064cc:	e0 a0 4d 18 	rcall	8000fefc <malloc>
800064d0:	8f 4c       	st.w	r7[0x10],r12
800064d2:	c6 30       	breq	80006598 <cartridge_init+0x1d4>
  assert(cartridge1->programBanks != NULL);
800064d4:	0f 89       	ld.ub	r9,r7[0x0]
  //usart_write_line(&AVR32_USART0,"parsing Bak2");
  int i;
 // Byte bytes[BYTES_PER_PROGRAM_BANK];
  for (i=0; i < cartridge1->numProgramBanks; i++) {
800064d6:	30 08       	mov	r8,0
800064d8:	f0 09 18 00 	cp.b	r9,r8
800064dc:	c1 30       	breq	80006502 <cartridge_init+0x13e>
800064de:	30 06       	mov	r6,0
static void parseProgramBanks(Cartridge cartridge1) {
  assert(cartridge1 != NULL);
  //usart_write_line(&AVR32_USART0,"parse BANK1");
  //assert(file != NULL);
  cartridge1->programBanks = (ProgramBank*) malloc(sizeof(ProgramBank) * cartridge1->numProgramBanks);
  assert(cartridge1->programBanks != NULL);
800064e0:	e0 6c 40 00 	mov	r12,16384
  //usart_write_line(&AVR32_USART0,"parsing Bak2");
  int i;
 // Byte bytes[BYTES_PER_PROGRAM_BANK];
  for (i=0; i < cartridge1->numProgramBanks; i++) {
    ProgramBank programBank1 = malloc(sizeof(struct programBank));
800064e4:	e0 a0 4d 0c 	rcall	8000fefc <malloc>
800064e8:	18 95       	mov	r5,r12
800064ea:	c3 b0       	breq	80006560 <cartridge_init+0x19c>
    
	assert(programBank1 != NULL);
800064ec:	e0 6b 40 00 	mov	r11,16384
	//usart_write_line(&AVR32_USART0,"parsing Bak3");
    //assert(fread(programBank, sizeof(struct programBank), 1, file) == 1);
    //memcpy(&rawData[sizeof(struct header)-1+i*sizeof(struct programBank)],programBank,sizeof(struct programBank));
    //file_read_buf(bytes,sizeof(bytes));
	file_read_buf(programBank1,sizeof(struct programBank));
800064f0:	e0 a0 3e 04 	rcall	8000e0f8 <file_read_buf>
800064f4:	6e 48       	ld.w	r8,r7[0x10]
	cartridge1->programBanks[i]=programBank1;
800064f6:	f0 06 09 25 	st.w	r8[r6<<0x2],r5
800064fa:	2f f6       	sub	r6,-1
  cartridge1->programBanks = (ProgramBank*) malloc(sizeof(ProgramBank) * cartridge1->numProgramBanks);
  assert(cartridge1->programBanks != NULL);
  //usart_write_line(&AVR32_USART0,"parsing Bak2");
  int i;
 // Byte bytes[BYTES_PER_PROGRAM_BANK];
  for (i=0; i < cartridge1->numProgramBanks; i++) {
800064fc:	0f 88       	ld.ub	r8,r7[0x0]
800064fe:	10 36       	cp.w	r6,r8
80006500:	cf 05       	brlt	800064e0 <cartridge_init+0x11c>
80006502:	0f 9c       	ld.ub	r12,r7[0x1]
//static void parseCharacterBanks(Cartridge cartridge, FILE *file) {
static void parseCharacterBanks(Cartridge cartridge1) {
  assert(cartridge1 != NULL);
  //usart_write_line(&AVR32_USART0,"parsing Bak4");
 // assert(file != NULL);
  cartridge1->characterBanks = (CharacterBank*) malloc(sizeof(struct characterBank) * cartridge1->numCharacterBanks);
80006504:	ad 7c       	lsl	r12,0xd
80006506:	e0 a0 4c fb 	rcall	8000fefc <malloc>
8000650a:	8f 3c       	st.w	r7[0xc],r12
8000650c:	c6 e0       	breq	800065e8 <cartridge_init+0x224>
  assert(cartridge1->characterBanks != NULL);
8000650e:	0f 99       	ld.ub	r9,r7[0x1]
  //usart_write_line(&AVR32_USART0,"parsing Bak5");
  int i;
//  Byte bytes[BYTES_PER_CHARACTER_BANK];
  for (i=0; i < cartridge1->numCharacterBanks; i++) {
80006510:	30 08       	mov	r8,0
80006512:	f0 09 18 00 	cp.b	r9,r8
80006516:	c1 30       	breq	8000653c <cartridge_init+0x178>
80006518:	30 06       	mov	r6,0
static void parseCharacterBanks(Cartridge cartridge1) {
  assert(cartridge1 != NULL);
  //usart_write_line(&AVR32_USART0,"parsing Bak4");
 // assert(file != NULL);
  cartridge1->characterBanks = (CharacterBank*) malloc(sizeof(struct characterBank) * cartridge1->numCharacterBanks);
  assert(cartridge1->characterBanks != NULL);
8000651a:	e0 6c 20 00 	mov	r12,8192
  //usart_write_line(&AVR32_USART0,"parsing Bak5");
  int i;
//  Byte bytes[BYTES_PER_CHARACTER_BANK];
  for (i=0; i < cartridge1->numCharacterBanks; i++) {
    CharacterBank characterBank1 = malloc(sizeof(struct characterBank));
8000651e:	e0 a0 4c ef 	rcall	8000fefc <malloc>
80006522:	18 95       	mov	r5,r12
80006524:	c1 70       	breq	80006552 <cartridge_init+0x18e>
    assert(characterBank1 != NULL);
80006526:	e0 6b 20 00 	mov	r11,8192
	//usart_write_line(&AVR32_USART0,"parsing Bak6");
	file_read_buf(characterBank1,sizeof(struct characterBank));
8000652a:	e0 a0 3d e7 	rcall	8000e0f8 <file_read_buf>
8000652e:	6e 38       	ld.w	r8,r7[0xc]
    ///assert(fread(characterBank, sizeof(struct characterBank), 1, file) == 1);
   // memcpy(&rawData[sizeof(struct header)-1+(cartridge->numProgramBanks)*sizeof(struct programBank)+i*sizeof(struct characterBank)],characterBank,sizeof(struct characterBank));
    //file_read_buf(bytes,sizeof(bytes));
	//memcpy(cartridge1->characterBanks[i]->bytes,bytes,sizeof(bytes));
      cartridge1->characterBanks[i] = characterBank1;
80006530:	f0 06 09 25 	st.w	r8[r6<<0x2],r5
80006534:	2f f6       	sub	r6,-1
  cartridge1->characterBanks = (CharacterBank*) malloc(sizeof(struct characterBank) * cartridge1->numCharacterBanks);
  assert(cartridge1->characterBanks != NULL);
  //usart_write_line(&AVR32_USART0,"parsing Bak5");
  int i;
//  Byte bytes[BYTES_PER_CHARACTER_BANK];
  for (i=0; i < cartridge1->numCharacterBanks; i++) {
80006536:	0f 98       	ld.ub	r8,r7[0x1]
80006538:	10 36       	cp.w	r6,r8
8000653a:	cf 05       	brlt	8000651a <cartridge_init+0x156>
8000653c:	e0 a0 3d 46 	rcall	8000dfc8 <file_close>
  parseProgramBanks(cartridge1);
  //usart_write_line(&AVR32_USART0,"Initiating program banks\n");
  parseCharacterBanks(cartridge1);
  //usart_write_line(&AVR32_USART0,"Initiating Cartridge\n");
  parseTitle(cartridge1);
  file_close();
80006540:	0e 9c       	mov	r12,r7
  //usart_write_line(&AVR32_USART0,"Cartridge1");
  return cartridge1;
}
80006542:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006546:	f3 d8 c0 01 	bfextu	r9,r8,0x0,0x1
  //usart_write_line(&AVR32_USART0,"parsing Header4");
  cartridge1->numCharacterBanks = header1->numCharacterBanks;
  cartridge1->numRamBanks = header1->numRamBanks;
  if ((header1->controlByte1 & MASK_BIT3) == MASK_BIT3) {
    cartridge1->mirrorType = BOTH;
  } else if ((header1->controlByte1 & MASK_BIT0) == 0) {
8000654a:	f9 b9 01 01 	movne	r9,1
    cartridge1->mirrorType = HORIZONTAL;
  } else if ((header1->controlByte1 & MASK_BIT0) == MASK_BIT0) {
    cartridge1->mirrorType = VERTICAL;
8000654e:	8f 19       	st.w	r7[0x4],r9
80006550:	c8 2b       	rjmp	80006454 <cartridge_init+0x90>
80006552:	4b 19       	lddpc	r9,80006614 <cartridge_init+0x250>
  //usart_write_line(&AVR32_USART0,"parsing Bak5");
  int i;
//  Byte bytes[BYTES_PER_CHARACTER_BANK];
  for (i=0; i < cartridge1->numCharacterBanks; i++) {
    CharacterBank characterBank1 = malloc(sizeof(struct characterBank));
    assert(characterBank1 != NULL);
80006554:	4b 1a       	lddpc	r10,80006618 <cartridge_init+0x254>
80006556:	e0 6b 00 d8 	mov	r11,216
8000655a:	4b 1c       	lddpc	r12,8000661c <cartridge_init+0x258>
8000655c:	e0 a0 4c a2 	rcall	8000fea0 <__assert_func>
80006560:	4b 09       	lddpc	r9,80006620 <cartridge_init+0x25c>
  int i;
 // Byte bytes[BYTES_PER_PROGRAM_BANK];
  for (i=0; i < cartridge1->numProgramBanks; i++) {
    ProgramBank programBank1 = malloc(sizeof(struct programBank));
    
	assert(programBank1 != NULL);
80006562:	4b 1a       	lddpc	r10,80006624 <cartridge_init+0x260>
80006564:	e0 6b 00 c1 	mov	r11,193
80006568:	4a dc       	lddpc	r12,8000661c <cartridge_init+0x258>
8000656a:	e0 a0 4c 9b 	rcall	8000fea0 <__assert_func>
8000656e:	4a f9       	lddpc	r9,80006628 <cartridge_init+0x264>
    cartridge1->hasTrainer = 0;
  }
  cartridge1->mmuNumber = (header1->controlByte1 & (MASK_BIT4 | MASK_BIT5 | MASK_BIT6 |MASK_BIT7)) >> 4;
  cartridge1->mmuNumber += header1->controlByte2 & (MASK_BIT4 | MASK_BIT5 | MASK_BIT6 |MASK_BIT7);
  assert((header1->controlByte2 & MASK_BIT0) == 0);
  assert((header1->controlByte2 & MASK_BIT1) == 0);
80006570:	4a fa       	lddpc	r10,8000662c <cartridge_init+0x268>
80006572:	e0 6b 00 9f 	mov	r11,159
80006576:	4a ac       	lddpc	r12,8000661c <cartridge_init+0x258>
80006578:	e0 a0 4c 94 	rcall	8000fea0 <__assert_func>
8000657c:	4a d9       	lddpc	r9,80006630 <cartridge_init+0x26c>
  } else {
    cartridge1->hasTrainer = 0;
  }
  cartridge1->mmuNumber = (header1->controlByte1 & (MASK_BIT4 | MASK_BIT5 | MASK_BIT6 |MASK_BIT7)) >> 4;
  cartridge1->mmuNumber += header1->controlByte2 & (MASK_BIT4 | MASK_BIT5 | MASK_BIT6 |MASK_BIT7);
  assert((header1->controlByte2 & MASK_BIT0) == 0);
8000657e:	4a ca       	lddpc	r10,8000662c <cartridge_init+0x268>
80006580:	e0 6b 00 9e 	mov	r11,158
80006584:	4a 6c       	lddpc	r12,8000661c <cartridge_init+0x258>
80006586:	e0 a0 4c 8d 	rcall	8000fea0 <__assert_func>
8000658a:	4a b9       	lddpc	r9,80006634 <cartridge_init+0x270>
  assert(header1->magicLabel[2] == 'S');
  //usart_write_line(&AVR32_USART0,"parsing Header2");
  assert(header1->magicValue == 0x1A);
  //usart_write_line(&AVR32_USART0,"parsing Header3");
  cartridge1->numProgramBanks = header1->numProgramBanks;
  assert(cartridge1->numProgramBanks > 0);
8000658c:	4a 8a       	lddpc	r10,8000662c <cartridge_init+0x268>
8000658e:	e0 6b 00 85 	mov	r11,133
80006592:	4a 3c       	lddpc	r12,8000661c <cartridge_init+0x258>
80006594:	e0 a0 4c 86 	rcall	8000fea0 <__assert_func>
80006598:	4a 89       	lddpc	r9,80006638 <cartridge_init+0x274>
static void parseProgramBanks(Cartridge cartridge1) {
  assert(cartridge1 != NULL);
  //usart_write_line(&AVR32_USART0,"parse BANK1");
  //assert(file != NULL);
  cartridge1->programBanks = (ProgramBank*) malloc(sizeof(ProgramBank) * cartridge1->numProgramBanks);
  assert(cartridge1->programBanks != NULL);
8000659a:	4a 3a       	lddpc	r10,80006624 <cartridge_init+0x260>
8000659c:	e0 6b 00 ba 	mov	r11,186
800065a0:	49 fc       	lddpc	r12,8000661c <cartridge_init+0x258>
800065a2:	e0 a0 4c 7f 	rcall	8000fea0 <__assert_func>
800065a6:	4a 69       	lddpc	r9,8000663c <cartridge_init+0x278>
  }
  cartridge1->mmuNumber = (header1->controlByte1 & (MASK_BIT4 | MASK_BIT5 | MASK_BIT6 |MASK_BIT7)) >> 4;
  cartridge1->mmuNumber += header1->controlByte2 & (MASK_BIT4 | MASK_BIT5 | MASK_BIT6 |MASK_BIT7);
  assert((header1->controlByte2 & MASK_BIT0) == 0);
  assert((header1->controlByte2 & MASK_BIT1) == 0);
  assert((header1->controlByte2 & MASK_BIT2) == 0);
800065a8:	4a 1a       	lddpc	r10,8000662c <cartridge_init+0x268>
800065aa:	e0 6b 00 a0 	mov	r11,160
800065ae:	49 cc       	lddpc	r12,8000661c <cartridge_init+0x258>
800065b0:	e0 a0 4c 78 	rcall	8000fea0 <__assert_func>
800065b4:	4a 39       	lddpc	r9,80006640 <cartridge_init+0x27c>
 // file_read_buf( header,sizeof(struct header));
  //memcpy(&rawData[0],&header,sizeof(struct header));
  
  initHeader(header1);
  //usart_write_line(&AVR32_USART0,"parsing Header");
  assert(header1->magicLabel[0] == 'N');
800065b6:	49 ea       	lddpc	r10,8000662c <cartridge_init+0x268>
800065b8:	37 eb       	mov	r11,126
800065ba:	49 9c       	lddpc	r12,8000661c <cartridge_init+0x258>
800065bc:	e0 a0 4c 72 	rcall	8000fea0 <__assert_func>
800065c0:	4a 19       	lddpc	r9,80006644 <cartridge_init+0x280>
  assert(header1->magicLabel[1] == 'E');
  assert(header1->magicLabel[2] == 'S');
800065c2:	49 ba       	lddpc	r10,8000662c <cartridge_init+0x268>
800065c4:	e0 6b 00 80 	mov	r11,128
800065c8:	49 5c       	lddpc	r12,8000661c <cartridge_init+0x258>
800065ca:	e0 a0 4c 6b 	rcall	8000fea0 <__assert_func>
800065ce:	49 f9       	lddpc	r9,80006648 <cartridge_init+0x284>
  //memcpy(&rawData[0],&header,sizeof(struct header));
  
  initHeader(header1);
  //usart_write_line(&AVR32_USART0,"parsing Header");
  assert(header1->magicLabel[0] == 'N');
  assert(header1->magicLabel[1] == 'E');
800065d0:	49 7a       	lddpc	r10,8000662c <cartridge_init+0x268>
800065d2:	37 fb       	mov	r11,127
800065d4:	49 2c       	lddpc	r12,8000661c <cartridge_init+0x258>
800065d6:	e0 a0 4c 65 	rcall	8000fea0 <__assert_func>
800065da:	49 d9       	lddpc	r9,8000664c <cartridge_init+0x288>
  cartridge1->mmuNumber = (header1->controlByte1 & (MASK_BIT4 | MASK_BIT5 | MASK_BIT6 |MASK_BIT7)) >> 4;
  cartridge1->mmuNumber += header1->controlByte2 & (MASK_BIT4 | MASK_BIT5 | MASK_BIT6 |MASK_BIT7);
  assert((header1->controlByte2 & MASK_BIT0) == 0);
  assert((header1->controlByte2 & MASK_BIT1) == 0);
  assert((header1->controlByte2 & MASK_BIT2) == 0);
  assert((header1->controlByte2 & MASK_BIT3) == 0);
800065dc:	49 4a       	lddpc	r10,8000662c <cartridge_init+0x268>
800065de:	e0 6b 00 a1 	mov	r11,161
800065e2:	48 fc       	lddpc	r12,8000661c <cartridge_init+0x258>
800065e4:	e0 a0 4c 5e 	rcall	8000fea0 <__assert_func>
800065e8:	49 a9       	lddpc	r9,80006650 <cartridge_init+0x28c>
static void parseCharacterBanks(Cartridge cartridge1) {
  assert(cartridge1 != NULL);
  //usart_write_line(&AVR32_USART0,"parsing Bak4");
 // assert(file != NULL);
  cartridge1->characterBanks = (CharacterBank*) malloc(sizeof(struct characterBank) * cartridge1->numCharacterBanks);
  assert(cartridge1->characterBanks != NULL);
800065ea:	48 ca       	lddpc	r10,80006618 <cartridge_init+0x254>
800065ec:	e0 6b 00 d2 	mov	r11,210
800065f0:	48 bc       	lddpc	r12,8000661c <cartridge_init+0x258>
800065f2:	e0 a0 4c 57 	rcall	8000fea0 <__assert_func>
800065f6:	49 89       	lddpc	r9,80006654 <cartridge_init+0x290>
 // assert(cartridge1 != NULL);
  //fread(cartridge->title, sizeof(Byte), 128, file);
}
Cartridge cartridge_init( int filename) {
  Cartridge cartridge1 = malloc(sizeof(struct cartridge));
  assert(cartridge1 != NULL);
800065f8:	49 8a       	lddpc	r10,80006658 <cartridge_init+0x294>
800065fa:	e0 6b 00 e9 	mov	r11,233
800065fe:	48 8c       	lddpc	r12,8000661c <cartridge_init+0x258>
80006600:	e0 a0 4c 50 	rcall	8000fea0 <__assert_func>
80006604:	49 69       	lddpc	r9,8000665c <cartridge_init+0x298>
  //usart_write_line(&AVR32_USART0,"parsing Header");
  assert(header1->magicLabel[0] == 'N');
  assert(header1->magicLabel[1] == 'E');
  assert(header1->magicLabel[2] == 'S');
  //usart_write_line(&AVR32_USART0,"parsing Header2");
  assert(header1->magicValue == 0x1A);
80006606:	48 aa       	lddpc	r10,8000662c <cartridge_init+0x268>
80006608:	e0 6b 00 82 	mov	r11,130
8000660c:	48 4c       	lddpc	r12,8000661c <cartridge_init+0x258>
8000660e:	e0 a0 4c 49 	rcall	8000fea0 <__assert_func>
80006612:	d7 03       	nop
80006614:	80 01       	ld.sh	r1,r0[0x0]
80006616:	74 58       	ld.w	r8,r10[0x14]
80006618:	80 01       	ld.sh	r1,r0[0x0]
8000661a:	74 70       	ld.w	r0,r10[0x1c]
8000661c:	80 01       	ld.sh	r1,r0[0x0]
8000661e:	72 90       	ld.w	r0,r9[0x24]
80006620:	80 01       	ld.sh	r1,r0[0x0]
80006622:	74 1c       	ld.w	r12,r10[0x4]
80006624:	80 01       	ld.sh	r1,r0[0x0]
80006626:	72 58       	ld.w	r8,r9[0x14]
80006628:	80 01       	ld.sh	r1,r0[0x0]
8000662a:	73 74       	ld.w	r4,r9[0x5c]
8000662c:	80 01       	ld.sh	r1,r0[0x0]
8000662e:	72 4c       	ld.w	r12,r9[0x10]
80006630:	80 01       	ld.sh	r1,r0[0x0]
80006632:	73 48       	ld.w	r8,r9[0x50]
80006634:	80 01       	ld.sh	r1,r0[0x0]
80006636:	73 28       	ld.w	r8,r9[0x48]
80006638:	80 01       	ld.sh	r1,r0[0x0]
8000663a:	73 f8       	ld.w	r8,r9[0x7c]
8000663c:	80 01       	ld.sh	r1,r0[0x0]
8000663e:	73 a0       	ld.w	r0,r9[0x68]
80006640:	80 01       	ld.sh	r1,r0[0x0]
80006642:	72 ac       	ld.w	r12,r9[0x28]
80006644:	80 01       	ld.sh	r1,r0[0x0]
80006646:	72 ec       	ld.w	r12,r9[0x38]
80006648:	80 01       	ld.sh	r1,r0[0x0]
8000664a:	72 cc       	ld.w	r12,r9[0x30]
8000664c:	80 01       	ld.sh	r1,r0[0x0]
8000664e:	73 cc       	ld.w	r12,r9[0x70]
80006650:	80 01       	ld.sh	r1,r0[0x0]
80006652:	74 34       	ld.w	r4,r10[0xc]
80006654:	80 01       	ld.sh	r1,r0[0x0]
80006656:	72 7c       	ld.w	r12,r9[0x1c]
80006658:	80 01       	ld.sh	r1,r0[0x0]
8000665a:	72 6c       	ld.w	r12,r9[0x18]
8000665c:	80 01       	ld.sh	r1,r0[0x0]
8000665e:	73 0c       	ld.w	r12,r9[0x40]

80006660 <colour_getRed>:
  colour->blue = blue;
}
inline Byte colour_getRed(Colour colour) {
 // assert(colour != NULL);
  return colour->red;
}
80006660:	19 8c       	ld.ub	r12,r12[0x0]
80006662:	5e fc       	retal	r12

80006664 <colour_getGreen>:
inline Byte colour_getGreen(Colour colour) {
 // assert(colour != NULL);
  return colour->green;
}
80006664:	19 9c       	ld.ub	r12,r12[0x1]
80006666:	5e fc       	retal	r12

80006668 <colour_getBlue>:
inline Byte colour_getBlue(Colour colour) {
 // assert(colour != NULL);
  return colour->blue;
}
80006668:	19 ac       	ld.ub	r12,r12[0x2]
8000666a:	5e fc       	retal	r12

8000666c <colour_destroy>:
  Colour colour = (Colour) malloc(sizeof(struct colour));
  //assert(colour != NULL);
  colour_setColour(colour, red, green, blue);
  return colour;
}
void colour_destroy(Colour colour) {
8000666c:	d4 01       	pushm	lr
  //assert(colour != NULL);
  free(colour);
8000666e:	e0 a0 4c 3f 	rcall	8000feec <free>
}
80006672:	d8 02       	popm	pc

80006674 <colour_init>:
80006674:	eb cd 40 e0 	pushm	r5-r7,lr
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include "globals.h"
#include "colour.h"
Colour colour_init(Byte red, Byte green, Byte blue) {
80006678:	18 97       	mov	r7,r12
8000667a:	16 96       	mov	r6,r11
8000667c:	14 95       	mov	r5,r10
  Colour colour = (Colour) malloc(sizeof(struct colour));
8000667e:	30 3c       	mov	r12,3
80006680:	e0 a0 4c 3e 	rcall	8000fefc <malloc>
}
inline void colour_setColour(Colour colour, Byte red, Byte green, Byte blue) {
  //assert(colour != NULL);
  colour->red = red;
  colour->green = green;
  colour->blue = blue;
80006684:	b8 a5       	st.b	r12[0x2],r5
 // assert(colour != NULL);
  return colour->blue;
}
inline void colour_setColour(Colour colour, Byte red, Byte green, Byte blue) {
  //assert(colour != NULL);
  colour->red = red;
80006686:	b8 87       	st.b	r12[0x0],r7
  colour->green = green;
80006688:	b8 96       	st.b	r12[0x1],r6
Colour colour_init(Byte red, Byte green, Byte blue) {
  Colour colour = (Colour) malloc(sizeof(struct colour));
  //assert(colour != NULL);
  colour_setColour(colour, red, green, blue);
  return colour;
}
8000668a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000668e:	d7 03       	nop

80006690 <cpu_getInterruptDisable>:
		cpu1->status |= MASK_STATUS_INTERRUPT_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_INTERRUPT_OFF;
	}
}
Bool cpu_getInterruptDisable(CPU cpu1) {
80006690:	19 bc       	ld.ub	r12,r12[0x3]
	if ((cpu1->status & MASK_STATUS_INTERRUPT_ON) == MASK_STATUS_INTERRUPT_ON) {
		return TRUE;
		} else {
		return FALSE;
	}
}
80006692:	f9 dc c0 41 	bfextu	r12,r12,0x2,0x1
80006696:	5e fc       	retal	r12

80006698 <cpu_LDA>:
		cpu_setNegative(cpu1, FALSE);
	}
}
// LDA - Load Accumulator
// Loads a byte of memory into the accumulator setting the zero and negative flags as appropriate.
static void cpu_LDA(NES nes, Address address) {
80006698:	eb cd 40 e0 	pushm	r5-r7,lr
8000669c:	16 95       	mov	r5,r11
8000669e:	18 96       	mov	r6,r12
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
800066a0:	e0 a0 0e 20 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"LDA\n");
	Byte data = nes_readCPUMemory(nes, address);
800066a4:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
}
// LDA - Load Accumulator
// Loads a byte of memory into the accumulator setting the zero and negative flags as appropriate.
static void cpu_LDA(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
800066a8:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"LDA\n");
	Byte data = nes_readCPUMemory(nes, address);
800066aa:	0c 9c       	mov	r12,r6
800066ac:	e0 a0 0f 2a 	rcall	80008500 <nes_readCPUMemory>
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
800066b0:	c0 a1       	brne	800066c4 <cpu_LDA+0x2c>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
800066b2:	0f b8       	ld.ub	r8,r7[0x3]
800066b4:	a1 b8       	sbr	r8,0x1
800066b6:	ae b8       	st.b	r7[0x3],r8
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
800066b8:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
	//assert(cpu1 != NULL);
	cpu1->indexY = indexY;
}
void inline cpu_setAccumulator(CPU cpu1, Byte accumulator) {
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
800066bc:	ae ec       	st.b	r7[0x6],r12
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
800066be:	ae b8       	st.b	r7[0x3],r8
	//usart_write_line(&AVR32_USART0,"LDA\n");
	Byte data = nes_readCPUMemory(nes, address);
	cpu_updateZero(cpu1, data);
	cpu_updateNegative(cpu1, data);
	cpu_setAccumulator(cpu1, data);
}
800066c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
800066c4:	0f b8       	ld.ub	r8,r7[0x3]
800066c6:	e2 18 00 fd 	andl	r8,0xfd,COH
800066ca:	ae b8       	st.b	r7[0x3],r8
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
800066cc:	30 09       	mov	r9,0
800066ce:	f2 0c 18 00 	cp.b	r12,r9
800066d2:	cf 34       	brge	800066b8 <cpu_LDA+0x20>
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
800066d4:	ea 18 ff ff 	orh	r8,0xffff
800066d8:	e8 18 ff 80 	orl	r8,0xff80
	//assert(cpu1 != NULL);
	cpu1->indexY = indexY;
}
void inline cpu_setAccumulator(CPU cpu1, Byte accumulator) {
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
800066dc:	ae ec       	st.b	r7[0x6],r12
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
800066de:	ae b8       	st.b	r7[0x3],r8
	//usart_write_line(&AVR32_USART0,"LDA\n");
	Byte data = nes_readCPUMemory(nes, address);
	cpu_updateZero(cpu1, data);
	cpu_updateNegative(cpu1, data);
	cpu_setAccumulator(cpu1, data);
}
800066e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

800066e4 <cpu_LDX>:
800066e4:	eb cd 40 e0 	pushm	r5-r7,lr
800066e8:	16 95       	mov	r5,r11
800066ea:	18 96       	mov	r6,r12
}
// LDX - Load X Register
// Loads a byte of memory into the X register setting the zero and negative flags as appropriate.
static void cpu_LDX(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
800066ec:	e0 a0 0d fa 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"LDX\n");
	Byte data = nes_readCPUMemory(nes, address);
800066f0:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
}
// LDX - Load X Register
// Loads a byte of memory into the X register setting the zero and negative flags as appropriate.
static void cpu_LDX(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
800066f4:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"LDX\n");
	Byte data = nes_readCPUMemory(nes, address);
800066f6:	0c 9c       	mov	r12,r6
800066f8:	e0 a0 0f 04 	rcall	80008500 <nes_readCPUMemory>
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
800066fc:	c0 a1       	brne	80006710 <cpu_LDX+0x2c>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
800066fe:	0f b8       	ld.ub	r8,r7[0x3]
80006700:	a1 b8       	sbr	r8,0x1
80006702:	ae b8       	st.b	r7[0x3],r8
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
80006704:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
	status |= MASK_BIT5;
	cpu1->status = status;
}
void cpu_setIndexX(CPU cpu1, Byte indexX) {
	//assert(cpu1 != NULL);
	cpu1->indexX = indexX;
80006708:	ae cc       	st.b	r7[0x4],r12
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
8000670a:	ae b8       	st.b	r7[0x3],r8
	//usart_write_line(&AVR32_USART0,"LDX\n");
	Byte data = nes_readCPUMemory(nes, address);
	cpu_updateZero(cpu1, data);
	cpu_updateNegative(cpu1, data);
	cpu_setIndexX(cpu1, data);
}
8000670c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
80006710:	0f b8       	ld.ub	r8,r7[0x3]
80006712:	e2 18 00 fd 	andl	r8,0xfd,COH
80006716:	ae b8       	st.b	r7[0x3],r8
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
80006718:	30 09       	mov	r9,0
8000671a:	f2 0c 18 00 	cp.b	r12,r9
8000671e:	cf 34       	brge	80006704 <cpu_LDX+0x20>
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
80006720:	ea 18 ff ff 	orh	r8,0xffff
80006724:	e8 18 ff 80 	orl	r8,0xff80
	status |= MASK_BIT5;
	cpu1->status = status;
}
void cpu_setIndexX(CPU cpu1, Byte indexX) {
	//assert(cpu1 != NULL);
	cpu1->indexX = indexX;
80006728:	ae cc       	st.b	r7[0x4],r12
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
8000672a:	ae b8       	st.b	r7[0x3],r8
	//usart_write_line(&AVR32_USART0,"LDX\n");
	Byte data = nes_readCPUMemory(nes, address);
	cpu_updateZero(cpu1, data);
	cpu_updateNegative(cpu1, data);
	cpu_setIndexX(cpu1, data);
}
8000672c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80006730 <cpu_LDY>:
80006730:	eb cd 40 e0 	pushm	r5-r7,lr
80006734:	16 95       	mov	r5,r11
80006736:	18 96       	mov	r6,r12
}
// LDY - Load Y Register
// Loads a byte of memory into the Y register setting the zero and negative flags as appropriate.
static void cpu_LDY(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006738:	e0 a0 0d d4 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"LDY\n");
	Byte data = nes_readCPUMemory(nes, address);
8000673c:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
}
// LDY - Load Y Register
// Loads a byte of memory into the Y register setting the zero and negative flags as appropriate.
static void cpu_LDY(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006740:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"LDY\n");
	Byte data = nes_readCPUMemory(nes, address);
80006742:	0c 9c       	mov	r12,r6
80006744:	e0 a0 0e de 	rcall	80008500 <nes_readCPUMemory>
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
80006748:	c0 a1       	brne	8000675c <cpu_LDY+0x2c>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
8000674a:	0f b8       	ld.ub	r8,r7[0x3]
8000674c:	a1 b8       	sbr	r8,0x1
8000674e:	ae b8       	st.b	r7[0x3],r8
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
80006750:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
	//assert(cpu1 != NULL);
	cpu1->indexX = indexX;
}
void cpu_setIndexY(CPU cpu1, Byte indexY) {
	//assert(cpu1 != NULL);
	cpu1->indexY = indexY;
80006754:	ae dc       	st.b	r7[0x5],r12
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
80006756:	ae b8       	st.b	r7[0x3],r8
	//usart_write_line(&AVR32_USART0,"LDY\n");
	Byte data = nes_readCPUMemory(nes, address);
	cpu_updateZero(cpu1, data);
	cpu_updateNegative(cpu1, data);
	cpu_setIndexY(cpu1, data);
}
80006758:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
8000675c:	0f b8       	ld.ub	r8,r7[0x3]
8000675e:	e2 18 00 fd 	andl	r8,0xfd,COH
80006762:	ae b8       	st.b	r7[0x3],r8
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
80006764:	30 09       	mov	r9,0
80006766:	f2 0c 18 00 	cp.b	r12,r9
8000676a:	cf 34       	brge	80006750 <cpu_LDY+0x20>
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
8000676c:	ea 18 ff ff 	orh	r8,0xffff
80006770:	e8 18 ff 80 	orl	r8,0xff80
	//assert(cpu1 != NULL);
	cpu1->indexX = indexX;
}
void cpu_setIndexY(CPU cpu1, Byte indexY) {
	//assert(cpu1 != NULL);
	cpu1->indexY = indexY;
80006774:	ae dc       	st.b	r7[0x5],r12
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
80006776:	ae b8       	st.b	r7[0x3],r8
	//usart_write_line(&AVR32_USART0,"LDY\n");
	Byte data = nes_readCPUMemory(nes, address);
	cpu_updateZero(cpu1, data);
	cpu_updateNegative(cpu1, data);
	cpu_setIndexY(cpu1, data);
}
80006778:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000677c <cpu_AND>:
8000677c:	eb cd 40 e0 	pushm	r5-r7,lr
80006780:	16 95       	mov	r5,r11
80006782:	18 96       	mov	r6,r12
}
// AND - Logical AND
// A logical AND is performed, bit by bit, on the accumulator contents using the contents of a byte of memory.
static void cpu_AND(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006784:	e0 a0 0d ae 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"AND\n");
	Byte data = nes_readCPUMemory(nes, address);
80006788:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
}
// AND - Logical AND
// A logical AND is performed, bit by bit, on the accumulator contents using the contents of a byte of memory.
static void cpu_AND(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
8000678c:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"AND\n");
	Byte data = nes_readCPUMemory(nes, address);
8000678e:	0c 9c       	mov	r12,r6
80006790:	e0 a0 0e b8 	rcall	80008500 <nes_readCPUMemory>
	cpu1->accumulator &= data;
80006794:	0f e8       	ld.ub	r8,r7[0x6]
80006796:	f9 e8 00 08 	and	r8,r12,r8
8000679a:	ae e8       	st.b	r7[0x6],r8
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
8000679c:	c0 91       	brne	800067ae <cpu_AND+0x32>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
8000679e:	0f b9       	ld.ub	r9,r7[0x3]
800067a0:	a1 b9       	sbr	r9,0x1
800067a2:	ae b9       	st.b	r7[0x3],r9
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
800067a4:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
800067a8:	ae b9       	st.b	r7[0x3],r9
800067aa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
800067ae:	0f b9       	ld.ub	r9,r7[0x3]
800067b0:	e2 19 00 fd 	andl	r9,0xfd,COH
800067b4:	ae b9       	st.b	r7[0x3],r9
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
800067b6:	30 0a       	mov	r10,0
800067b8:	f4 08 18 00 	cp.b	r8,r10
800067bc:	cf 44       	brge	800067a4 <cpu_AND+0x28>
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
800067be:	ea 19 ff ff 	orh	r9,0xffff
800067c2:	e8 19 ff 80 	orl	r9,0xff80
800067c6:	ae b9       	st.b	r7[0x3],r9
800067c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

800067cc <cpu_ORA>:
800067cc:	eb cd 40 e0 	pushm	r5-r7,lr
800067d0:	16 95       	mov	r5,r11
800067d2:	18 96       	mov	r6,r12
}
// ORA - Logical Inclusive OR
// An inclusive OR is performed, bit by bit, on the accumulator contents using the contents of a byte of memory.
static void cpu_ORA(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
800067d4:	e0 a0 0d 86 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"ORA\n");
	Byte data = nes_readCPUMemory(nes, address);
800067d8:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
}
// ORA - Logical Inclusive OR
// An inclusive OR is performed, bit by bit, on the accumulator contents using the contents of a byte of memory.
static void cpu_ORA(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
800067dc:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"ORA\n");
	Byte data = nes_readCPUMemory(nes, address);
800067de:	0c 9c       	mov	r12,r6
800067e0:	e0 a0 0e 90 	rcall	80008500 <nes_readCPUMemory>
	cpu1->accumulator |= data;
800067e4:	0f e8       	ld.ub	r8,r7[0x6]
800067e6:	f9 e8 10 08 	or	r8,r12,r8
800067ea:	5c 58       	castu.b	r8
800067ec:	ae e8       	st.b	r7[0x6],r8
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
800067ee:	c0 91       	brne	80006800 <cpu_ORA+0x34>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
800067f0:	0f b9       	ld.ub	r9,r7[0x3]
800067f2:	a1 b9       	sbr	r9,0x1
800067f4:	ae b9       	st.b	r7[0x3],r9
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
800067f6:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
800067fa:	ae b9       	st.b	r7[0x3],r9
800067fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
80006800:	0f b9       	ld.ub	r9,r7[0x3]
80006802:	e2 19 00 fd 	andl	r9,0xfd,COH
80006806:	ae b9       	st.b	r7[0x3],r9
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
80006808:	30 0a       	mov	r10,0
8000680a:	f4 08 18 00 	cp.b	r8,r10
8000680e:	cf 44       	brge	800067f6 <cpu_ORA+0x2a>
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
80006810:	ea 19 ff ff 	orh	r9,0xffff
80006814:	e8 19 ff 80 	orl	r9,0xff80
80006818:	ae b9       	st.b	r7[0x3],r9
8000681a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000681e:	d7 03       	nop

80006820 <cpu_EOR>:
80006820:	eb cd 40 e0 	pushm	r5-r7,lr
80006824:	16 95       	mov	r5,r11
80006826:	18 96       	mov	r6,r12
}
// EOR - Exclusive OR
// An exclusive OR is performed, bit by bit, on the accumulator contents using the ontents of a byte of memory.
static void cpu_EOR(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006828:	e0 a0 0d 5c 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"EOR\n");
	Byte data = nes_readCPUMemory(nes, address);
8000682c:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
}
// EOR - Exclusive OR
// An exclusive OR is performed, bit by bit, on the accumulator contents using the ontents of a byte of memory.
static void cpu_EOR(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006830:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"EOR\n");
	Byte data = nes_readCPUMemory(nes, address);
80006832:	0c 9c       	mov	r12,r6
80006834:	e0 a0 0e 66 	rcall	80008500 <nes_readCPUMemory>
	cpu1->accumulator ^= data;
80006838:	0f e8       	ld.ub	r8,r7[0x6]
8000683a:	f9 e8 20 08 	eor	r8,r12,r8
8000683e:	5c 58       	castu.b	r8
80006840:	ae e8       	st.b	r7[0x6],r8
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
80006842:	c0 91       	brne	80006854 <cpu_EOR+0x34>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
80006844:	0f b9       	ld.ub	r9,r7[0x3]
80006846:	a1 b9       	sbr	r9,0x1
80006848:	ae b9       	st.b	r7[0x3],r9
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
8000684a:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
8000684e:	ae b9       	st.b	r7[0x3],r9
80006850:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
80006854:	0f b9       	ld.ub	r9,r7[0x3]
80006856:	e2 19 00 fd 	andl	r9,0xfd,COH
8000685a:	ae b9       	st.b	r7[0x3],r9
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
8000685c:	30 0a       	mov	r10,0
8000685e:	f4 08 18 00 	cp.b	r8,r10
80006862:	cf 44       	brge	8000684a <cpu_EOR+0x2a>
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
80006864:	ea 19 ff ff 	orh	r9,0xffff
80006868:	e8 19 ff 80 	orl	r9,0xff80
8000686c:	ae b9       	st.b	r7[0x3],r9
8000686e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006872:	d7 03       	nop

80006874 <cpu_popStack>:
80006874:	eb cd 40 80 	pushm	r7,lr
80006878:	18 97       	mov	r7,r12
8000687a:	e0 a0 0d 33 	rcall	800082e0 <nes_getCPU>
	cpu1->stackPointer--;
	//VALIDATE_STACK_POINTER(cpu1->stackPointer);
}
static Byte cpu_popStack(NES nes) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
8000687e:	18 98       	mov	r8,r12
	//VALIDATE_STACK_POINTER(cpu1->stackPointer);
	cpu1->stackPointer++;
	//VALIDATE_STACK_POINTER(cpu1->stackPointer);
	Address stackAddress = GET_STACK_ADDRESS(cpu1->stackPointer);
	//VALIDATE_STACK_ADDRESS(stackAddress);
	Byte data = nes_readCPUMemory(nes, stackAddress);
80006880:	0e 9c       	mov	r12,r7
static Byte cpu_popStack(NES nes) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
	//assert(cpu1 != NULL);
	//VALIDATE_STACK_POINTER(cpu1->stackPointer);
	cpu1->stackPointer++;
80006882:	11 ab       	ld.ub	r11,r8[0x2]
80006884:	2f fb       	sub	r11,-1
80006886:	5c 5b       	castu.b	r11
80006888:	b0 ab       	st.b	r8[0x2],r11
	//VALIDATE_STACK_POINTER(cpu1->stackPointer);
	Address stackAddress = GET_STACK_ADDRESS(cpu1->stackPointer);
	//VALIDATE_STACK_ADDRESS(stackAddress);
	Byte data = nes_readCPUMemory(nes, stackAddress);
8000688a:	f6 cb ff 00 	sub	r11,r11,-256
8000688e:	e0 a0 0e 39 	rcall	80008500 <nes_readCPUMemory>
	return data;
}
80006892:	e3 cd 80 80 	ldm	sp++,r7,pc
80006896:	d7 03       	nop

80006898 <cpu_STA>:
80006898:	eb cd 40 c0 	pushm	r6-r7,lr
8000689c:	16 96       	mov	r6,r11
8000689e:	18 97       	mov	r7,r12
}
// STA - Store Accumulator
// Stores the contents of the accumulator into memory.
static void cpu_STA(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
800068a0:	e0 a0 0d 20 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"STA\n");
	nes_writeCPUMemory(nes, address, cpu1->accumulator);
800068a4:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800068a8:	19 ea       	ld.ub	r10,r12[0x6]
800068aa:	0e 9c       	mov	r12,r7
800068ac:	e0 a0 0d 3a 	rcall	80008320 <nes_writeCPUMemory>
}
800068b0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

800068b4 <cpu_STX>:
800068b4:	eb cd 40 c0 	pushm	r6-r7,lr
800068b8:	16 96       	mov	r6,r11
800068ba:	18 97       	mov	r7,r12
}
// STX - Store X Register
// Stores the contents of the X register into memory.
static void cpu_STX(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
800068bc:	e0 a0 0d 12 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"STX\n");
	nes_writeCPUMemory(nes, address, cpu1->indexX);
800068c0:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800068c4:	19 ca       	ld.ub	r10,r12[0x4]
800068c6:	0e 9c       	mov	r12,r7
800068c8:	e0 a0 0d 2c 	rcall	80008320 <nes_writeCPUMemory>
}
800068cc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

800068d0 <cpu_pushStack>:
800068d0:	eb cd 40 e0 	pushm	r5-r7,lr
800068d4:	16 95       	mov	r5,r11
800068d6:	18 96       	mov	r6,r12
// The stack pointer is an 8 bit register and holds the low 8 bits of the next freelocation on the stack.
// Pushing bytes to the stack causes the stack pointer to be decremented. Conversely pulling bytes causes it to be incremented.
// There is no detection of stack overflow and the stack pointer will just wrap around from $00 to $FF.
static void cpu_pushStack(NES nes, Byte data) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
800068d8:	e0 a0 0d 04 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	Address stackAddress = GET_STACK_ADDRESS(cpu1->stackPointer);
	//VALIDATE_STACK_ADDRESS(stackAddress);
	nes_writeCPUMemory(nes, stackAddress, data);
800068dc:	0a 9a       	mov	r10,r5
// The stack pointer is an 8 bit register and holds the low 8 bits of the next freelocation on the stack.
// Pushing bytes to the stack causes the stack pointer to be decremented. Conversely pulling bytes causes it to be incremented.
// There is no detection of stack overflow and the stack pointer will just wrap around from $00 to $FF.
static void cpu_pushStack(NES nes, Byte data) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
800068de:	18 97       	mov	r7,r12
	//assert(cpu1 != NULL);
	Address stackAddress = GET_STACK_ADDRESS(cpu1->stackPointer);
	//VALIDATE_STACK_ADDRESS(stackAddress);
	nes_writeCPUMemory(nes, stackAddress, data);
800068e0:	0c 9c       	mov	r12,r6
800068e2:	0f ab       	ld.ub	r11,r7[0x2]
800068e4:	f6 cb ff 00 	sub	r11,r11,-256
800068e8:	e0 a0 0d 1c 	rcall	80008320 <nes_writeCPUMemory>
	cpu1->stackPointer--;
800068ec:	0f a8       	ld.ub	r8,r7[0x2]
800068ee:	20 18       	sub	r8,1
800068f0:	ae a8       	st.b	r7[0x2],r8
	//VALIDATE_STACK_POINTER(cpu1->stackPointer);
}
800068f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800068f6:	d7 03       	nop

800068f8 <cpu_init>:
800068f8:	d4 01       	pushm	lr
800068fa:	30 8c       	mov	r12,8
800068fc:	e0 a0 4b 00 	rcall	8000fefc <malloc>
	Byte accumulator;
};
CPU cpu_init(void) {
	CPU cpu1 = (CPU) malloc(sizeof(struct cpu));
	//assert(cpu1 != NULL);
	cpu1->programCounter = 0;
80006900:	30 09       	mov	r9,0
	cpu1->status = CPU_STATUS_REGISTER_INITIAL_VALUE;
	cpu1->indexX = 0;
	cpu1->indexY = 0;
	cpu1->accumulator = 0;
80006902:	b8 e9       	st.b	r12[0x6],r9
	Byte accumulator;
};
CPU cpu_init(void) {
	CPU cpu1 = (CPU) malloc(sizeof(struct cpu));
	//assert(cpu1 != NULL);
	cpu1->programCounter = 0;
80006904:	b8 09       	st.h	r12[0x0],r9
	cpu1->status = CPU_STATUS_REGISTER_INITIAL_VALUE;
	cpu1->indexX = 0;
80006906:	b8 c9       	st.b	r12[0x4],r9
	cpu1->indexY = 0;
80006908:	b8 d9       	st.b	r12[0x5],r9
};
CPU cpu_init(void) {
	CPU cpu1 = (CPU) malloc(sizeof(struct cpu));
	//assert(cpu1 != NULL);
	cpu1->programCounter = 0;
	cpu1->status = CPU_STATUS_REGISTER_INITIAL_VALUE;
8000690a:	32 09       	mov	r9,32
8000690c:	b8 b9       	st.b	r12[0x3],r9
	cpu1->indexX = 0;
	cpu1->indexY = 0;
	cpu1->accumulator = 0;
	cpu1->stackPointer = CPU_STACK_POINTER_INITIAL_VALUE;
8000690e:	3f f9       	mov	r9,-1
80006910:	b8 a9       	st.b	r12[0x2],r9
	return cpu1;
}
80006912:	d8 02       	popm	pc

80006914 <cpu_handleInterrupt>:
80006914:	eb cd 40 f8 	pushm	r3-r7,lr
		return TRUE;
		} else {
		return FALSE;
	}
}
void cpu_handleInterrupt(NES nes, Address handlerLowByte, Bool fromBRK) {
80006918:	16 94       	mov	r4,r11
8000691a:	14 95       	mov	r5,r10
8000691c:	18 97       	mov	r7,r12
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
8000691e:	e0 a0 0c e1 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	usart_write_line(&AVR32_USART0,"handleInterrupt\n");
80006922:	4a ab       	lddpc	r11,800069c8 <cpu_handleInterrupt+0xb4>
		return FALSE;
	}
}
void cpu_handleInterrupt(NES nes, Address handlerLowByte, Bool fromBRK) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006924:	18 96       	mov	r6,r12
	//assert(cpu1 != NULL);
	usart_write_line(&AVR32_USART0,"handleInterrupt\n");
80006926:	fe 7c 14 00 	mov	r12,-60416
8000692a:	e0 a0 2a 34 	rcall	8000bd92 <usart_write_line>
	cpu_updateNegative(cpu1, cpu1->accumulator);
}
static void cpu_setInterruptDisable(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_INTERRUPT_ON;
8000692e:	0d b8       	ld.ub	r8,r6[0x3]
80006930:	a3 a8       	sbr	r8,0x2
80006932:	ac b8       	st.b	r6[0x3],r8
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
	//assert(cpu1 != NULL);
	usart_write_line(&AVR32_USART0,"handleInterrupt\n");
	cpu_setInterruptDisable(cpu1, TRUE);
	if (fromBRK == TRUE) {
80006934:	30 19       	mov	r9,1
80006936:	f2 05 18 00 	cp.b	r5,r9
8000693a:	c4 40       	breq	800069c2 <cpu_handleInterrupt+0xae>
static void cpu_setBreak(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_BREAK_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_BREAK_OFF;
8000693c:	a5 c8       	cbr	r8,0x4
8000693e:	ac b8       	st.b	r6[0x3],r8
	if (fromBRK == TRUE) {
		cpu_setBreak(cpu1, TRUE);
		} else {
		cpu_setBreak(cpu1, FALSE);
	}
	cpu_pushStack(nes, GET_ADDRESS_HIGH_BYTE(cpu1->programCounter));
80006940:	0d 83       	ld.ub	r3,r6[0x0]
// The stack pointer is an 8 bit register and holds the low 8 bits of the next freelocation on the stack.
// Pushing bytes to the stack causes the stack pointer to be decremented. Conversely pulling bytes causes it to be incremented.
// There is no detection of stack overflow and the stack pointer will just wrap around from $00 to $FF.
static void cpu_pushStack(NES nes, Byte data) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006942:	0e 9c       	mov	r12,r7
80006944:	e0 a0 0c ce 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	Address stackAddress = GET_STACK_ADDRESS(cpu1->stackPointer);
	//VALIDATE_STACK_ADDRESS(stackAddress);
	nes_writeCPUMemory(nes, stackAddress, data);
80006948:	06 9a       	mov	r10,r3
// The stack pointer is an 8 bit register and holds the low 8 bits of the next freelocation on the stack.
// Pushing bytes to the stack causes the stack pointer to be decremented. Conversely pulling bytes causes it to be incremented.
// There is no detection of stack overflow and the stack pointer will just wrap around from $00 to $FF.
static void cpu_pushStack(NES nes, Byte data) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
8000694a:	18 95       	mov	r5,r12
	//assert(cpu1 != NULL);
	Address stackAddress = GET_STACK_ADDRESS(cpu1->stackPointer);
	//VALIDATE_STACK_ADDRESS(stackAddress);
	nes_writeCPUMemory(nes, stackAddress, data);
8000694c:	19 ab       	ld.ub	r11,r12[0x2]
8000694e:	0e 9c       	mov	r12,r7
80006950:	f6 cb ff 00 	sub	r11,r11,-256
80006954:	e0 a0 0c e6 	rcall	80008320 <nes_writeCPUMemory>
	cpu1->stackPointer--;
80006958:	0b a8       	ld.ub	r8,r5[0x2]
8000695a:	20 18       	sub	r8,1
// The stack pointer is an 8 bit register and holds the low 8 bits of the next freelocation on the stack.
// Pushing bytes to the stack causes the stack pointer to be decremented. Conversely pulling bytes causes it to be incremented.
// There is no detection of stack overflow and the stack pointer will just wrap around from $00 to $FF.
static void cpu_pushStack(NES nes, Byte data) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
8000695c:	0e 9c       	mov	r12,r7
	//assert(cpu1 != NULL);
	Address stackAddress = GET_STACK_ADDRESS(cpu1->stackPointer);
	//VALIDATE_STACK_ADDRESS(stackAddress);
	nes_writeCPUMemory(nes, stackAddress, data);
	cpu1->stackPointer--;
8000695e:	aa a8       	st.b	r5[0x2],r8
		cpu_setBreak(cpu1, TRUE);
		} else {
		cpu_setBreak(cpu1, FALSE);
	}
	cpu_pushStack(nes, GET_ADDRESS_HIGH_BYTE(cpu1->programCounter));
	cpu_pushStack(nes, GET_ADDRESS_LOW_BYTE(cpu1->programCounter));
80006960:	0d 93       	ld.ub	r3,r6[0x1]
// The stack pointer is an 8 bit register and holds the low 8 bits of the next freelocation on the stack.
// Pushing bytes to the stack causes the stack pointer to be decremented. Conversely pulling bytes causes it to be incremented.
// There is no detection of stack overflow and the stack pointer will just wrap around from $00 to $FF.
static void cpu_pushStack(NES nes, Byte data) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006962:	e0 a0 0c bf 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	Address stackAddress = GET_STACK_ADDRESS(cpu1->stackPointer);
	//VALIDATE_STACK_ADDRESS(stackAddress);
	nes_writeCPUMemory(nes, stackAddress, data);
80006966:	06 9a       	mov	r10,r3
// The stack pointer is an 8 bit register and holds the low 8 bits of the next freelocation on the stack.
// Pushing bytes to the stack causes the stack pointer to be decremented. Conversely pulling bytes causes it to be incremented.
// There is no detection of stack overflow and the stack pointer will just wrap around from $00 to $FF.
static void cpu_pushStack(NES nes, Byte data) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006968:	18 95       	mov	r5,r12
	//assert(cpu1 != NULL);
	Address stackAddress = GET_STACK_ADDRESS(cpu1->stackPointer);
	//VALIDATE_STACK_ADDRESS(stackAddress);
	nes_writeCPUMemory(nes, stackAddress, data);
8000696a:	19 ab       	ld.ub	r11,r12[0x2]
8000696c:	0e 9c       	mov	r12,r7
8000696e:	f6 cb ff 00 	sub	r11,r11,-256
80006972:	e0 a0 0c d7 	rcall	80008320 <nes_writeCPUMemory>
	cpu1->stackPointer--;
80006976:	0b a8       	ld.ub	r8,r5[0x2]
80006978:	20 18       	sub	r8,1
8000697a:	aa a8       	st.b	r5[0x2],r8
// The stack pointer is an 8 bit register and holds the low 8 bits of the next freelocation on the stack.
// Pushing bytes to the stack causes the stack pointer to be decremented. Conversely pulling bytes causes it to be incremented.
// There is no detection of stack overflow and the stack pointer will just wrap around from $00 to $FF.
static void cpu_pushStack(NES nes, Byte data) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
8000697c:	0e 9c       	mov	r12,r7
		cpu_setBreak(cpu1, FALSE);
	}
	cpu_pushStack(nes, GET_ADDRESS_HIGH_BYTE(cpu1->programCounter));
	cpu_pushStack(nes, GET_ADDRESS_LOW_BYTE(cpu1->programCounter));
	// 1 at all times
	cpu1->status |= MASK_BIT5;
8000697e:	0d b3       	ld.ub	r3,r6[0x3]
80006980:	a5 b3       	sbr	r3,0x5
80006982:	ac b3       	st.b	r6[0x3],r3
// The stack pointer is an 8 bit register and holds the low 8 bits of the next freelocation on the stack.
// Pushing bytes to the stack causes the stack pointer to be decremented. Conversely pulling bytes causes it to be incremented.
// There is no detection of stack overflow and the stack pointer will just wrap around from $00 to $FF.
static void cpu_pushStack(NES nes, Byte data) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006984:	e0 a0 0c ae 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	Address stackAddress = GET_STACK_ADDRESS(cpu1->stackPointer);
	//VALIDATE_STACK_ADDRESS(stackAddress);
	nes_writeCPUMemory(nes, stackAddress, data);
80006988:	06 9a       	mov	r10,r3
// The stack pointer is an 8 bit register and holds the low 8 bits of the next freelocation on the stack.
// Pushing bytes to the stack causes the stack pointer to be decremented. Conversely pulling bytes causes it to be incremented.
// There is no detection of stack overflow and the stack pointer will just wrap around from $00 to $FF.
static void cpu_pushStack(NES nes, Byte data) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
8000698a:	18 95       	mov	r5,r12
	//assert(cpu1 != NULL);
	Address stackAddress = GET_STACK_ADDRESS(cpu1->stackPointer);
	//VALIDATE_STACK_ADDRESS(stackAddress);
	nes_writeCPUMemory(nes, stackAddress, data);
8000698c:	19 ab       	ld.ub	r11,r12[0x2]
8000698e:	0e 9c       	mov	r12,r7
80006990:	f6 cb ff 00 	sub	r11,r11,-256
80006994:	e0 a0 0c c6 	rcall	80008320 <nes_writeCPUMemory>
	cpu1->stackPointer--;
80006998:	0b a8       	ld.ub	r8,r5[0x2]
8000699a:	20 18       	sub	r8,1
	cpu_pushStack(nes, GET_ADDRESS_LOW_BYTE(cpu1->programCounter));
	// 1 at all times
	cpu1->status |= MASK_BIT5;
	cpu_pushStack(nes, cpu1->status);
	//0xFFFC para el reset
	Address address = nes_readCPUMemory(nes, handlerLowByte);
8000699c:	08 9b       	mov	r11,r4
	CPU cpu1 = nes_getCPU(nes);
	//assert(cpu1 != NULL);
	Address stackAddress = GET_STACK_ADDRESS(cpu1->stackPointer);
	//VALIDATE_STACK_ADDRESS(stackAddress);
	nes_writeCPUMemory(nes, stackAddress, data);
	cpu1->stackPointer--;
8000699e:	aa a8       	st.b	r5[0x2],r8
	cpu_pushStack(nes, GET_ADDRESS_LOW_BYTE(cpu1->programCounter));
	// 1 at all times
	cpu1->status |= MASK_BIT5;
	cpu_pushStack(nes, cpu1->status);
	//0xFFFC para el reset
	Address address = nes_readCPUMemory(nes, handlerLowByte);
800069a0:	5c 7b       	castu.h	r11
800069a2:	0e 9c       	mov	r12,r7
800069a4:	e0 a0 0d ae 	rcall	80008500 <nes_readCPUMemory>
	address += nes_readCPUMemory(nes, handlerLowByte+1) << BITS_PER_BYTE;
800069a8:	08 9b       	mov	r11,r4
	cpu_pushStack(nes, GET_ADDRESS_LOW_BYTE(cpu1->programCounter));
	// 1 at all times
	cpu1->status |= MASK_BIT5;
	cpu_pushStack(nes, cpu1->status);
	//0xFFFC para el reset
	Address address = nes_readCPUMemory(nes, handlerLowByte);
800069aa:	18 95       	mov	r5,r12
	address += nes_readCPUMemory(nes, handlerLowByte+1) << BITS_PER_BYTE;
800069ac:	2f fb       	sub	r11,-1
800069ae:	0e 9c       	mov	r12,r7
800069b0:	5c 7b       	castu.h	r11
800069b2:	e0 a0 0d a7 	rcall	80008500 <nes_readCPUMemory>
	
    //usart_write_line(&AVR32_USART0,address);
	cpu1->programCounter = address;
800069b6:	a9 6c       	lsl	r12,0x8
800069b8:	f8 05 00 05 	add	r5,r12,r5
800069bc:	ac 05       	st.h	r6[0x0],r5
}
800069be:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
	}
}
static void cpu_setBreak(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_BREAK_ON;
800069c2:	a5 a8       	sbr	r8,0x4
800069c4:	ac b8       	st.b	r6[0x3],r8
800069c6:	cb db       	rjmp	80006940 <cpu_handleInterrupt+0x2c>
800069c8:	80 01       	ld.sh	r1,r0[0x0]
800069ca:	7c 80       	ld.w	r0,lr[0x20]

800069cc <cpu_step>:
800069cc:	eb cd 40 fc 	pushm	r2-r7,lr
800069d0:	18 97       	mov	r7,r12
800069d2:	e0 a0 0c 87 	rcall	800082e0 <nes_getCPU>
800069d6:	18 94       	mov	r4,r12
800069d8:	0e 9c       	mov	r12,r7
800069da:	88 8b       	ld.uh	r11,r4[0x0]
	//assert(nes != NULL);
	//usart_write_line(&AVR32_USART0,"cpu_step\n");
	//gpio_toggle_pin(60);
	CPU cpu1 = nes_getCPU(nes);
	//assert(cpu1 != NULL);
	Byte instruction = nes_readCPUMemory(nes, cpu1->programCounter);
800069dc:	e0 a0 0d 92 	rcall	80008500 <nes_readCPUMemory>
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
800069e0:	88 06       	ld.sh	r6,r4[0x0]
800069e2:	2f f6       	sub	r6,-1
800069e4:	5c 86       	casts.h	r6
800069e6:	a8 06       	st.h	r4[0x0],r6
	//assert(nes != NULL);
	//usart_write_line(&AVR32_USART0,"cpu_step\n");
	//gpio_toggle_pin(60);
	CPU cpu1 = nes_getCPU(nes);
	//assert(cpu1 != NULL);
	Byte instruction = nes_readCPUMemory(nes, cpu1->programCounter);
800069e8:	18 93       	mov	r3,r12
	//usart_write_char(&AVR32_USART0,instruction);
	cpu_increaseProgramCounter(cpu1);
//	//usart_write_line(&AVR32_USART0,"Instruction: 0x%x\n", instruction);
	Address address = 0;
	
	if (instruction==0x4C)
800069ea:	34 c8       	mov	r8,76
800069ec:	f0 0c 18 00 	cp.b	r12,r8
800069f0:	e0 80 00 e3 	breq	80006bb6 <cpu_step+0x1ea>
		return;
	}
	
	
	
	switch(instruction) {
800069f4:	f8 c8 00 01 	sub	r8,r12,1
800069f8:	e0 48 00 fe 	cp.w	r8,254
800069fc:	e0 88 00 07 	brls	80006a0a <cpu_step+0x3e>
80006a00:	30 06       	mov	r6,0
		break;
		//printf("Instruction not implemented: 0x%x\n", instruction);
		////usart_write_line(&AVR32_USART0,"Instruction not implemented: 0x%x\n", instruction);
		//assert(FALSE);
	}
	switch(instruction) {
80006a02:	fe f8 10 32 	ld.w	r8,pc[4146]
80006a06:	f0 03 03 2f 	ld.w	pc,r8[r3<<0x2]
		return;
	}
	
	
	
	switch(instruction) {
80006a0a:	fe f9 10 2e 	ld.w	r9,pc[4142]
80006a0e:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006a12:	ec c8 ff ff 	sub	r8,r6,-1
80006a16:	a8 08       	st.h	r4[0x0],r8
80006a18:	cf 5b       	rjmp	80006a02 <cpu_step+0x36>
		case ROL_ZPAGEX:goto ZPAGEX;
		case ROR_ZPAGEX:goto ZPAGEX;
		case INC_ZPAGEX: ZPAGEX:
		case DEC_ZPAGEX:
		{
			Byte data = nes_readCPUMemory(nes, cpu1->programCounter);
80006a1a:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006a1e:	0e 9c       	mov	r12,r7
80006a20:	e0 a0 0d 70 	rcall	80008500 <nes_readCPUMemory>
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006a24:	88 08       	ld.sh	r8,r4[0x0]
		case DEC_ZPAGEX:
		{
			Byte data = nes_readCPUMemory(nes, cpu1->programCounter);
			cpu_increaseProgramCounter(cpu1);
			data += cpu1->indexX;
			address = data;
80006a26:	09 c6       	ld.ub	r6,r4[0x4]
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006a28:	2f f8       	sub	r8,-1
		case DEC_ZPAGEX:
		{
			Byte data = nes_readCPUMemory(nes, cpu1->programCounter);
			cpu_increaseProgramCounter(cpu1);
			data += cpu1->indexX;
			address = data;
80006a2a:	18 06       	add	r6,r12
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006a2c:	a8 08       	st.h	r4[0x0],r8
		case DEC_ZPAGEX:
		{
			Byte data = nes_readCPUMemory(nes, cpu1->programCounter);
			cpu_increaseProgramCounter(cpu1);
			data += cpu1->indexX;
			address = data;
80006a2e:	5c 56       	castu.b	r6
		}
		break;
80006a30:	ce 9b       	rjmp	80006a02 <cpu_step+0x36>
		case EOR_INDY:
		case CMP_INDY:
		case ADC_INDY:
		case SBC_INDY:
		{
			Byte data = nes_readCPUMemory(nes, cpu1->programCounter);
80006a32:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006a36:	0e 9c       	mov	r12,r7
80006a38:	e0 a0 0d 64 	rcall	80008500 <nes_readCPUMemory>
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006a3c:	88 08       	ld.sh	r8,r4[0x0]
80006a3e:	2f f8       	sub	r8,-1
		{
			Byte data = nes_readCPUMemory(nes, cpu1->programCounter);
			cpu_increaseProgramCounter(cpu1);
			Byte lowAddress = data;
			Byte highAddress = data+1;
			address = nes_readCPUMemory(nes, lowAddress);
80006a40:	18 9b       	mov	r11,r12
		case EOR_INDY:
		case CMP_INDY:
		case ADC_INDY:
		case SBC_INDY:
		{
			Byte data = nes_readCPUMemory(nes, cpu1->programCounter);
80006a42:	18 95       	mov	r5,r12
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006a44:	a8 08       	st.h	r4[0x0],r8
		{
			Byte data = nes_readCPUMemory(nes, cpu1->programCounter);
			cpu_increaseProgramCounter(cpu1);
			Byte lowAddress = data;
			Byte highAddress = data+1;
			address = nes_readCPUMemory(nes, lowAddress);
80006a46:	0e 9c       	mov	r12,r7
80006a48:	e0 a0 0d 5c 	rcall	80008500 <nes_readCPUMemory>
			address += nes_readCPUMemory(nes, highAddress) << BITS_PER_BYTE;    // is the +1 meant to wraparound to zero page as well?
80006a4c:	ea cb ff ff 	sub	r11,r5,-1
		{
			Byte data = nes_readCPUMemory(nes, cpu1->programCounter);
			cpu_increaseProgramCounter(cpu1);
			Byte lowAddress = data;
			Byte highAddress = data+1;
			address = nes_readCPUMemory(nes, lowAddress);
80006a50:	18 92       	mov	r2,r12
			address += nes_readCPUMemory(nes, highAddress) << BITS_PER_BYTE;    // is the +1 meant to wraparound to zero page as well?
80006a52:	5c 5b       	castu.b	r11
80006a54:	0e 9c       	mov	r12,r7
80006a56:	e0 a0 0d 55 	rcall	80008500 <nes_readCPUMemory>
80006a5a:	09 d6       	ld.ub	r6,r4[0x5]
			address += cpu1->indexY;
80006a5c:	a9 6c       	lsl	r12,0x8
			Byte data = nes_readCPUMemory(nes, cpu1->programCounter);
			cpu_increaseProgramCounter(cpu1);
			Byte lowAddress = data;
			Byte highAddress = data+1;
			address = nes_readCPUMemory(nes, lowAddress);
			address += nes_readCPUMemory(nes, highAddress) << BITS_PER_BYTE;    // is the +1 meant to wraparound to zero page as well?
80006a5e:	04 06       	add	r6,r2
			address += cpu1->indexY;
80006a60:	18 06       	add	r6,r12
80006a62:	5c 86       	casts.h	r6
		}
		break;
80006a64:	cc fb       	rjmp	80006a02 <cpu_step+0x36>
		case ROR_ABS:goto ABSOLUTE;
		case INC_ABS:goto ABSOLUTE;
		case DEC_ABS:goto ABSOLUTE;
		case JSR_ABS:goto ABSOLUTE;
		case JMP_ABS: ABSOLUTE:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
80006a66:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006a6a:	0e 9c       	mov	r12,r7
80006a6c:	e0 a0 0d 4a 	rcall	80008500 <nes_readCPUMemory>
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006a70:	88 0b       	ld.sh	r11,r4[0x0]
		case ROR_ABS:goto ABSOLUTE;
		case INC_ABS:goto ABSOLUTE;
		case DEC_ABS:goto ABSOLUTE;
		case JSR_ABS:goto ABSOLUTE;
		case JMP_ABS: ABSOLUTE:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
80006a72:	18 96       	mov	r6,r12
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006a74:	2f fb       	sub	r11,-1
		case DEC_ABS:goto ABSOLUTE;
		case JSR_ABS:goto ABSOLUTE;
		case JMP_ABS: ABSOLUTE:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
		cpu_increaseProgramCounter(cpu1);
		address += nes_readCPUMemory(nes, cpu1->programCounter) << BITS_PER_BYTE;
80006a76:	0e 9c       	mov	r12,r7
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006a78:	a8 0b       	st.h	r4[0x0],r11
		case DEC_ABS:goto ABSOLUTE;
		case JSR_ABS:goto ABSOLUTE;
		case JMP_ABS: ABSOLUTE:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
		cpu_increaseProgramCounter(cpu1);
		address += nes_readCPUMemory(nes, cpu1->programCounter) << BITS_PER_BYTE;
80006a7a:	5c 7b       	castu.h	r11
80006a7c:	e0 a0 0d 42 	rcall	80008500 <nes_readCPUMemory>
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006a80:	88 08       	ld.sh	r8,r4[0x0]
		case DEC_ABS:goto ABSOLUTE;
		case JSR_ABS:goto ABSOLUTE;
		case JMP_ABS: ABSOLUTE:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
		cpu_increaseProgramCounter(cpu1);
		address += nes_readCPUMemory(nes, cpu1->programCounter) << BITS_PER_BYTE;
80006a82:	a9 6c       	lsl	r12,0x8
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006a84:	2f f8       	sub	r8,-1
		case DEC_ABS:goto ABSOLUTE;
		case JSR_ABS:goto ABSOLUTE;
		case JMP_ABS: ABSOLUTE:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
		cpu_increaseProgramCounter(cpu1);
		address += nes_readCPUMemory(nes, cpu1->programCounter) << BITS_PER_BYTE;
80006a86:	f8 06 00 06 	add	r6,r12,r6
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006a8a:	a8 08       	st.h	r4[0x0],r8
		case DEC_ABS:goto ABSOLUTE;
		case JSR_ABS:goto ABSOLUTE;
		case JMP_ABS: ABSOLUTE:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
		cpu_increaseProgramCounter(cpu1);
		address += nes_readCPUMemory(nes, cpu1->programCounter) << BITS_PER_BYTE;
80006a8c:	5c 86       	casts.h	r6
80006a8e:	cb ab       	rjmp	80006a02 <cpu_step+0x36>
		}
		break;
		case LDX_ZPAGEY:
		case STX_ZPAGEY:
		{
			Byte data = nes_readCPUMemory(nes, cpu1->programCounter);
80006a90:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006a94:	0e 9c       	mov	r12,r7
80006a96:	e0 a0 0d 35 	rcall	80008500 <nes_readCPUMemory>
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006a9a:	88 08       	ld.sh	r8,r4[0x0]
		case STX_ZPAGEY:
		{
			Byte data = nes_readCPUMemory(nes, cpu1->programCounter);
			cpu_increaseProgramCounter(cpu1);
			data += cpu1->indexY;
			address = data;
80006a9c:	09 d6       	ld.ub	r6,r4[0x5]
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006a9e:	2f f8       	sub	r8,-1
		case STX_ZPAGEY:
		{
			Byte data = nes_readCPUMemory(nes, cpu1->programCounter);
			cpu_increaseProgramCounter(cpu1);
			data += cpu1->indexY;
			address = data;
80006aa0:	18 06       	add	r6,r12
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006aa2:	a8 08       	st.h	r4[0x0],r8
		case STX_ZPAGEY:
		{
			Byte data = nes_readCPUMemory(nes, cpu1->programCounter);
			cpu_increaseProgramCounter(cpu1);
			data += cpu1->indexY;
			address = data;
80006aa4:	5c 56       	castu.b	r6
		}
		break;
80006aa6:	ca eb       	rjmp	80006a02 <cpu_step+0x36>
		case LSR_ABSX:goto ABSOLUTEX;
		case ROL_ABSX:goto ABSOLUTEX;
		case ROR_ABSX:goto ABSOLUTEX;
		case INC_ABSX:goto ABSOLUTEX;
		case DEC_ABSX: ABSOLUTEX:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
80006aa8:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006aac:	0e 9c       	mov	r12,r7
80006aae:	e0 a0 0d 29 	rcall	80008500 <nes_readCPUMemory>
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006ab2:	88 0b       	ld.sh	r11,r4[0x0]
		case LSR_ABSX:goto ABSOLUTEX;
		case ROL_ABSX:goto ABSOLUTEX;
		case ROR_ABSX:goto ABSOLUTEX;
		case INC_ABSX:goto ABSOLUTEX;
		case DEC_ABSX: ABSOLUTEX:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
80006ab4:	18 92       	mov	r2,r12
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006ab6:	2f fb       	sub	r11,-1
		case ROR_ABSX:goto ABSOLUTEX;
		case INC_ABSX:goto ABSOLUTEX;
		case DEC_ABSX: ABSOLUTEX:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
		cpu_increaseProgramCounter(cpu1);
		address += nes_readCPUMemory(nes, cpu1->programCounter) << BITS_PER_BYTE;
80006ab8:	0e 9c       	mov	r12,r7
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006aba:	a8 0b       	st.h	r4[0x0],r11
		case ROR_ABSX:goto ABSOLUTEX;
		case INC_ABSX:goto ABSOLUTEX;
		case DEC_ABSX: ABSOLUTEX:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
		cpu_increaseProgramCounter(cpu1);
		address += nes_readCPUMemory(nes, cpu1->programCounter) << BITS_PER_BYTE;
80006abc:	5c 7b       	castu.h	r11
80006abe:	e0 a0 0d 21 	rcall	80008500 <nes_readCPUMemory>
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006ac2:	88 08       	ld.sh	r8,r4[0x0]
		case DEC_ABSX: ABSOLUTEX:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
		cpu_increaseProgramCounter(cpu1);
		address += nes_readCPUMemory(nes, cpu1->programCounter) << BITS_PER_BYTE;
		cpu_increaseProgramCounter(cpu1);
		address += cpu1->indexX;
80006ac4:	a9 6c       	lsl	r12,0x8
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006ac6:	2f f8       	sub	r8,-1
		case ROR_ABSX:goto ABSOLUTEX;
		case INC_ABSX:goto ABSOLUTEX;
		case DEC_ABSX: ABSOLUTEX:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
		cpu_increaseProgramCounter(cpu1);
		address += nes_readCPUMemory(nes, cpu1->programCounter) << BITS_PER_BYTE;
80006ac8:	09 c6       	ld.ub	r6,r4[0x4]
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006aca:	a8 08       	st.h	r4[0x0],r8
		case ROR_ABSX:goto ABSOLUTEX;
		case INC_ABSX:goto ABSOLUTEX;
		case DEC_ABSX: ABSOLUTEX:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
		cpu_increaseProgramCounter(cpu1);
		address += nes_readCPUMemory(nes, cpu1->programCounter) << BITS_PER_BYTE;
80006acc:	04 06       	add	r6,r2
		cpu_increaseProgramCounter(cpu1);
		address += cpu1->indexX;
80006ace:	18 06       	add	r6,r12
80006ad0:	5c 86       	casts.h	r6
		break;
80006ad2:	c9 8b       	rjmp	80006a02 <cpu_step+0x36>
		//nes_cpuCycled(nes);
		break;
		case JMP_INDIRECT_CODE1:
		case JMP_INDIRECT_CODE2:
		{
			Byte directAddressLow = nes_readCPUMemory(nes, cpu1->programCounter);
80006ad4:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006ad8:	0e 9c       	mov	r12,r7
80006ada:	e0 a0 0d 13 	rcall	80008500 <nes_readCPUMemory>
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006ade:	88 08       	ld.sh	r8,r4[0x0]
80006ae0:	2f f8       	sub	r8,-1
		//nes_cpuCycled(nes);
		break;
		case JMP_INDIRECT_CODE1:
		case JMP_INDIRECT_CODE2:
		{
			Byte directAddressLow = nes_readCPUMemory(nes, cpu1->programCounter);
80006ae2:	18 96       	mov	r6,r12
			cpu_increaseProgramCounter(cpu1);
			Byte directAddressHigh = nes_readCPUMemory(nes, cpu1->programCounter);
80006ae4:	f7 d8 c0 10 	bfextu	r11,r8,0x0,0x10
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006ae8:	a8 08       	st.h	r4[0x0],r8
		case JMP_INDIRECT_CODE1:
		case JMP_INDIRECT_CODE2:
		{
			Byte directAddressLow = nes_readCPUMemory(nes, cpu1->programCounter);
			cpu_increaseProgramCounter(cpu1);
			Byte directAddressHigh = nes_readCPUMemory(nes, cpu1->programCounter);
80006aea:	0e 9c       	mov	r12,r7
80006aec:	e0 a0 0d 0a 	rcall	80008500 <nes_readCPUMemory>
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006af0:	88 08       	ld.sh	r8,r4[0x0]
			Byte directAddressLow = nes_readCPUMemory(nes, cpu1->programCounter);
			cpu_increaseProgramCounter(cpu1);
			Byte directAddressHigh = nes_readCPUMemory(nes, cpu1->programCounter);
			cpu_increaseProgramCounter(cpu1);
			Address lowAddress = directAddressLow;
			lowAddress += directAddressHigh << BITS_PER_BYTE;
80006af2:	a9 6c       	lsl	r12,0x8
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006af4:	2f f8       	sub	r8,-1
			Byte directAddressLow = nes_readCPUMemory(nes, cpu1->programCounter);
			cpu_increaseProgramCounter(cpu1);
			Byte directAddressHigh = nes_readCPUMemory(nes, cpu1->programCounter);
			cpu_increaseProgramCounter(cpu1);
			Address lowAddress = directAddressLow;
			lowAddress += directAddressHigh << BITS_PER_BYTE;
80006af6:	eb dc b0 10 	bfexts	r5,r12,0x0,0x10
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006afa:	a8 08       	st.h	r4[0x0],r8
			Address lowAddress = directAddressLow;
			lowAddress += directAddressHigh << BITS_PER_BYTE;
			directAddressLow++;
			Address highAddress = directAddressLow;
			highAddress += directAddressHigh << BITS_PER_BYTE;
			address = nes_readCPUMemory(nes, lowAddress);
80006afc:	ea 06 00 0b 	add	r11,r5,r6
80006b00:	0e 9c       	mov	r12,r7
80006b02:	5c 7b       	castu.h	r11
			Byte directAddressHigh = nes_readCPUMemory(nes, cpu1->programCounter);
			cpu_increaseProgramCounter(cpu1);
			Address lowAddress = directAddressLow;
			lowAddress += directAddressHigh << BITS_PER_BYTE;
			directAddressLow++;
			Address highAddress = directAddressLow;
80006b04:	2f f6       	sub	r6,-1
			highAddress += directAddressHigh << BITS_PER_BYTE;
			address = nes_readCPUMemory(nes, lowAddress);
80006b06:	e0 a0 0c fd 	rcall	80008500 <nes_readCPUMemory>
			Byte directAddressHigh = nes_readCPUMemory(nes, cpu1->programCounter);
			cpu_increaseProgramCounter(cpu1);
			Address lowAddress = directAddressLow;
			lowAddress += directAddressHigh << BITS_PER_BYTE;
			directAddressLow++;
			Address highAddress = directAddressLow;
80006b0a:	e5 d6 c0 08 	bfextu	r2,r6,0x0,0x8
			highAddress += directAddressHigh << BITS_PER_BYTE;
			address = nes_readCPUMemory(nes, lowAddress);
80006b0e:	18 96       	mov	r6,r12
			address += nes_readCPUMemory(nes, highAddress) << BITS_PER_BYTE;
80006b10:	e4 05 00 05 	add	r5,r2,r5
80006b14:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
80006b18:	0e 9c       	mov	r12,r7
80006b1a:	e0 a0 0c f3 	rcall	80008500 <nes_readCPUMemory>
80006b1e:	a9 6c       	lsl	r12,0x8
80006b20:	f8 06 00 06 	add	r6,r12,r6
80006b24:	5c 86       	casts.h	r6
		}
		break;
80006b26:	c6 eb       	rjmp	80006a02 <cpu_step+0x36>
		case ROL_ZPAGE:goto ZPAGE;
		case ROR_ZPAGE:goto ZPAGE;
		case INC_ZPAGE:goto ZPAGE;
		case DEC_ZPAGE:
		ZPAGE:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
80006b28:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006b2c:	0e 9c       	mov	r12,r7
80006b2e:	e0 a0 0c e9 	rcall	80008500 <nes_readCPUMemory>
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006b32:	88 08       	ld.sh	r8,r4[0x0]
		case ROL_ZPAGE:goto ZPAGE;
		case ROR_ZPAGE:goto ZPAGE;
		case INC_ZPAGE:goto ZPAGE;
		case DEC_ZPAGE:
		ZPAGE:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
80006b34:	18 96       	mov	r6,r12
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006b36:	2f f8       	sub	r8,-1
80006b38:	a8 08       	st.h	r4[0x0],r8
80006b3a:	c6 4b       	rjmp	80006a02 <cpu_step+0x36>
		case EOR_INDX:
		case CMP_INDX:
		case ADC_INDX:
		case SBC_INDX:
		{
			Byte data = nes_readCPUMemory(nes, cpu1->programCounter);
80006b3c:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006b40:	0e 9c       	mov	r12,r7
80006b42:	e0 a0 0c df 	rcall	80008500 <nes_readCPUMemory>
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006b46:	88 08       	ld.sh	r8,r4[0x0]
80006b48:	2f f8       	sub	r8,-1
		case ADC_INDX:
		case SBC_INDX:
		{
			Byte data = nes_readCPUMemory(nes, cpu1->programCounter);
			cpu_increaseProgramCounter(cpu1);
			data += cpu1->indexX;
80006b4a:	09 c5       	ld.ub	r5,r4[0x4]
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006b4c:	a8 08       	st.h	r4[0x0],r8
		case ADC_INDX:
		case SBC_INDX:
		{
			Byte data = nes_readCPUMemory(nes, cpu1->programCounter);
			cpu_increaseProgramCounter(cpu1);
			data += cpu1->indexX;
80006b4e:	18 05       	add	r5,r12
			Byte lowAddress = data;
			Byte highAddress = data + 1;
			address = nes_readCPUMemory(nes, lowAddress);
80006b50:	0e 9c       	mov	r12,r7
		case ADC_INDX:
		case SBC_INDX:
		{
			Byte data = nes_readCPUMemory(nes, cpu1->programCounter);
			cpu_increaseProgramCounter(cpu1);
			data += cpu1->indexX;
80006b52:	5c 55       	castu.b	r5
			Byte lowAddress = data;
			Byte highAddress = data + 1;
			address = nes_readCPUMemory(nes, lowAddress);
80006b54:	0a 9b       	mov	r11,r5
80006b56:	e0 a0 0c d5 	rcall	80008500 <nes_readCPUMemory>
			address += nes_readCPUMemory(nes, highAddress) << BITS_PER_BYTE;
80006b5a:	ea cb ff ff 	sub	r11,r5,-1
			Byte data = nes_readCPUMemory(nes, cpu1->programCounter);
			cpu_increaseProgramCounter(cpu1);
			data += cpu1->indexX;
			Byte lowAddress = data;
			Byte highAddress = data + 1;
			address = nes_readCPUMemory(nes, lowAddress);
80006b5e:	18 96       	mov	r6,r12
			address += nes_readCPUMemory(nes, highAddress) << BITS_PER_BYTE;
80006b60:	5c 5b       	castu.b	r11
80006b62:	cd bb       	rjmp	80006b18 <cpu_step+0x14c>
		case ORA_ABSY:
		case EOR_ABSY:
		case CMP_ABSY:
		case ADC_ABSY:
		case SBC_ABSY:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
80006b64:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006b68:	0e 9c       	mov	r12,r7
80006b6a:	e0 a0 0c cb 	rcall	80008500 <nes_readCPUMemory>
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006b6e:	88 0b       	ld.sh	r11,r4[0x0]
		case ORA_ABSY:
		case EOR_ABSY:
		case CMP_ABSY:
		case ADC_ABSY:
		case SBC_ABSY:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
80006b70:	18 92       	mov	r2,r12
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006b72:	2f fb       	sub	r11,-1
		case CMP_ABSY:
		case ADC_ABSY:
		case SBC_ABSY:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
		cpu_increaseProgramCounter(cpu1);
		address += nes_readCPUMemory(nes, cpu1->programCounter) << BITS_PER_BYTE;
80006b74:	0e 9c       	mov	r12,r7
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006b76:	a8 0b       	st.h	r4[0x0],r11
		case CMP_ABSY:
		case ADC_ABSY:
		case SBC_ABSY:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
		cpu_increaseProgramCounter(cpu1);
		address += nes_readCPUMemory(nes, cpu1->programCounter) << BITS_PER_BYTE;
80006b78:	5c 7b       	castu.h	r11
80006b7a:	e0 a0 0c c3 	rcall	80008500 <nes_readCPUMemory>
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006b7e:	88 08       	ld.sh	r8,r4[0x0]
		case SBC_ABSY:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
		cpu_increaseProgramCounter(cpu1);
		address += nes_readCPUMemory(nes, cpu1->programCounter) << BITS_PER_BYTE;
		cpu_increaseProgramCounter(cpu1);
		address += cpu1->indexY;
80006b80:	a9 6c       	lsl	r12,0x8
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006b82:	2f f8       	sub	r8,-1
		case CMP_ABSY:
		case ADC_ABSY:
		case SBC_ABSY:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
		cpu_increaseProgramCounter(cpu1);
		address += nes_readCPUMemory(nes, cpu1->programCounter) << BITS_PER_BYTE;
80006b84:	09 d6       	ld.ub	r6,r4[0x5]
	//assert(cpu1 != NULL);
	cpu1->accumulator = accumulator;
}
static inline void cpu_increaseProgramCounter(CPU cpu1) {
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
80006b86:	a8 08       	st.h	r4[0x0],r8
		case CMP_ABSY:
		case ADC_ABSY:
		case SBC_ABSY:
		address = nes_readCPUMemory(nes, cpu1->programCounter);
		cpu_increaseProgramCounter(cpu1);
		address += nes_readCPUMemory(nes, cpu1->programCounter) << BITS_PER_BYTE;
80006b88:	04 06       	add	r6,r2
		cpu_increaseProgramCounter(cpu1);
		address += cpu1->indexY;
80006b8a:	18 06       	add	r6,r12
80006b8c:	5c 86       	casts.h	r6
		break;
80006b8e:	c3 ab       	rjmp	80006a02 <cpu_step+0x36>
}
// BVC - Branch if Overflow Clear
// If the overflow flag is clear then add the relative displacement to the program counter to cause a branch to a new location.
static void cpu_BVC(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006b90:	0e 9c       	mov	r12,r7
80006b92:	e0 a0 0b a7 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BVC\n");
	SignedByte data = nes_readCPUMemory(nes, address);
80006b96:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
}
// BVC - Branch if Overflow Clear
// If the overflow flag is clear then add the relative displacement to the program counter to cause a branch to a new location.
static void cpu_BVC(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006b9a:	18 95       	mov	r5,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BVC\n");
	SignedByte data = nes_readCPUMemory(nes, address);
80006b9c:	0e 9c       	mov	r12,r7
80006b9e:	e0 a0 0c b1 	rcall	80008500 <nes_readCPUMemory>
		cpu1->status &= MASK_STATUS_OVERFLOW_OFF;
	}
}
static Bool cpu_getOverflow(CPU cpu1) {
	//assert(cpu1 != NULL);
	if ((cpu1->status & MASK_STATUS_OVERFLOW_ON) == MASK_STATUS_OVERFLOW_ON) {
80006ba2:	0b b8       	ld.ub	r8,r5[0x3]
80006ba4:	ed b8 00 06 	bld	r8,0x6
80006ba8:	c0 50       	breq	80006bb2 <cpu_step+0x1e6>
	//usart_write_line(&AVR32_USART0,"BVC\n");
	SignedByte data = nes_readCPUMemory(nes, address);
	if (cpu_getOverflow(cpu1) == FALSE) {
		// +1 cycle if the branch succeeds
		//nes_cpuCycled(nes);
		cpu1->programCounter += data;
80006baa:	8a 08       	ld.sh	r8,r5[0x0]
80006bac:	5c 6c       	casts.b	r12
80006bae:	18 08       	add	r8,r12
80006bb0:	aa 08       	st.h	r5[0x0],r8
80006bb2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
	
	if (instruction==0x4C)
	{
		//usart_write_char(&AVR32_USART0,instruction);
		uint16_t add1,add2;
		add1 = nes_readCPUMemory(nes, cpu1->programCounter++);
80006bb6:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006bba:	0e 9c       	mov	r12,r7
80006bbc:	2f f6       	sub	r6,-1
80006bbe:	a8 06       	st.h	r4[0x0],r6
80006bc0:	e0 a0 0c a0 	rcall	80008500 <nes_readCPUMemory>
		//usart_write_char(&AVR32_USART0,add1);
		add2= nes_readCPUMemory(nes, cpu1->programCounter);
80006bc4:	88 8b       	ld.uh	r11,r4[0x0]
	
	if (instruction==0x4C)
	{
		//usart_write_char(&AVR32_USART0,instruction);
		uint16_t add1,add2;
		add1 = nes_readCPUMemory(nes, cpu1->programCounter++);
80006bc6:	18 96       	mov	r6,r12
		//usart_write_char(&AVR32_USART0,add1);
		add2= nes_readCPUMemory(nes, cpu1->programCounter);
80006bc8:	0e 9c       	mov	r12,r7
80006bca:	e0 a0 0c 9b 	rcall	80008500 <nes_readCPUMemory>
		//usart_write_char(&AVR32_USART0,add2);
		cpu1->programCounter = ((add2 <<8)+add1);
80006bce:	a9 6c       	lsl	r12,0x8
80006bd0:	f8 06 00 06 	add	r6,r12,r6
80006bd4:	a8 06       	st.h	r4[0x0],r6
		return;
80006bd6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
	}
}
static void cpu_setDecimal(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_DECIMAL_ON;
80006bda:	09 b8       	ld.ub	r8,r4[0x3]
80006bdc:	a3 b8       	sbr	r8,0x3
80006bde:	a8 b8       	st.b	r4[0x3],r8
		case TXS:
		cpu_TXS(cpu1);
		break;
		case SED:
		cpu_SED(cpu1);
		break;
80006be0:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// BEQ - Branch if Equal
// If the zero flag is set then add the relative displacement to the program counter to ause a branch to a new location.
static void cpu_BEQ(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006be4:	0e 9c       	mov	r12,r7
80006be6:	e0 a0 0b 7d 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BEQ\n");
	SignedByte data = nes_readCPUMemory(nes, address);
80006bea:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
}
// BEQ - Branch if Equal
// If the zero flag is set then add the relative displacement to the program counter to ause a branch to a new location.
static void cpu_BEQ(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006bee:	18 95       	mov	r5,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BEQ\n");
	SignedByte data = nes_readCPUMemory(nes, address);
80006bf0:	0e 9c       	mov	r12,r7
80006bf2:	e0 a0 0c 87 	rcall	80008500 <nes_readCPUMemory>
	//usart_write_line(&AVR32_USART0,"JMP\n");
	cpu1->programCounter = address;
}
static Bool cpu_getZero(CPU cpu1) {
	//assert(cpu1 != NULL);
	if ((cpu1->status & MASK_STATUS_ZERO_ON) == MASK_STATUS_ZERO_ON) {
80006bf6:	0b b8       	ld.ub	r8,r5[0x3]
80006bf8:	ed b8 00 01 	bld	r8,0x1
80006bfc:	cd b1       	brne	80006bb2 <cpu_step+0x1e6>
	//usart_write_line(&AVR32_USART0,"BEQ\n");
	SignedByte data = nes_readCPUMemory(nes, address);
	if (cpu_getZero(cpu1) == TRUE) {
		// +1 cycle if the branch succeeds
		//nes_cpuCycled(nes);
		cpu1->programCounter += data;
80006bfe:	8a 08       	ld.sh	r8,r5[0x0]
80006c00:	5c 6c       	casts.b	r12
80006c02:	18 08       	add	r8,r12
80006c04:	aa 08       	st.h	r5[0x0],r8
80006c06:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// INX - Increment X Register
// Adds one to the X register setting the zero and negative flags as appropriate.
static void cpu_INX(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"INX\n");
	cpu1->indexX++;
80006c0a:	09 c9       	ld.ub	r9,r4[0x4]
80006c0c:	2f f9       	sub	r9,-1
80006c0e:	5c 59       	castu.b	r9
80006c10:	a8 c9       	st.b	r4[0x4],r9
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
80006c12:	e0 81 06 5a 	brne	800078c6 <cpu_step+0xefa>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
80006c16:	09 b8       	ld.ub	r8,r4[0x3]
80006c18:	a1 b8       	sbr	r8,0x1
80006c1a:	a8 b8       	st.b	r4[0x3],r8
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
80006c1c:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
80006c20:	a8 b8       	st.b	r4[0x3],r8
80006c22:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// INC - Increment Memory
// Adds one to the value held at a specified memory location setting the zero and negative flags as appropriate.
static void cpu_INC(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006c26:	0e 9c       	mov	r12,r7
80006c28:	e0 a0 0b 5c 	rcall	800082e0 <nes_getCPU>
		break;
		case INC_ZPAGE:
		case INC_ZPAGEX:
		case INC_ABS:
		case INC_ABSX:
		cpu_INC(nes, address);
80006c2c:	5c 76       	castu.h	r6
}
// INC - Increment Memory
// Adds one to the value held at a specified memory location setting the zero and negative flags as appropriate.
static void cpu_INC(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006c2e:	18 95       	mov	r5,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"INC\n");
	Byte data = nes_readCPUMemory(nes, address);
80006c30:	0c 9b       	mov	r11,r6
80006c32:	0e 9c       	mov	r12,r7
80006c34:	e0 a0 0c 66 	rcall	80008500 <nes_readCPUMemory>
	// dummy write, cycle wasted here
	nes_writeCPUMemory(nes, address, data);
80006c38:	0c 9b       	mov	r11,r6
80006c3a:	18 9a       	mov	r10,r12
static void cpu_INC(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"INC\n");
	Byte data = nes_readCPUMemory(nes, address);
80006c3c:	18 94       	mov	r4,r12
	// dummy write, cycle wasted here
	nes_writeCPUMemory(nes, address, data);
80006c3e:	0e 9c       	mov	r12,r7
80006c40:	e0 a0 0b 70 	rcall	80008320 <nes_writeCPUMemory>
	data++;
80006c44:	08 9a       	mov	r10,r4
80006c46:	2f fa       	sub	r10,-1
80006c48:	5c 5a       	castu.b	r10
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
80006c4a:	e0 81 06 52 	brne	800078ee <cpu_step+0xf22>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
80006c4e:	0b b8       	ld.ub	r8,r5[0x3]
80006c50:	a1 b8       	sbr	r8,0x1
80006c52:	aa b8       	st.b	r5[0x3],r8
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
80006c54:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
80006c58:	aa b8       	st.b	r5[0x3],r8
	data++;
	// Z Zero Flag       Set if result is zero
	cpu_updateZero(cpu1, data);
	// N Negative Flag   Set if bit 7 of the result is set
	cpu_updateNegative(cpu1, data);
	nes_writeCPUMemory(nes, address, data);
80006c5a:	0c 9b       	mov	r11,r6
80006c5c:	0e 9c       	mov	r12,r7
80006c5e:	e0 a0 0b 61 	rcall	80008320 <nes_writeCPUMemory>
		case INC_ZPAGE:
		case INC_ZPAGEX:
		case INC_ABS:
		case INC_ABSX:
		cpu_INC(nes, address);
		break;
80006c62:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// SBC - Subtract with Carry
// This instruction subtracts the contents of a memory location to the accumulator together with the not of the carry bit.
// If overflow occurs the carry bit is clear, this enables multiple byte subtraction to be performed.
static void cpu_SBC(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006c66:	0e 9c       	mov	r12,r7
80006c68:	e0 a0 0b 3c 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"SBC\n");
	// A,Z,C,N = A-M-(1-C)
	Byte data = nes_readCPUMemory(nes, address);
80006c6c:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
// SBC - Subtract with Carry
// This instruction subtracts the contents of a memory location to the accumulator together with the not of the carry bit.
// If overflow occurs the carry bit is clear, this enables multiple byte subtraction to be performed.
static void cpu_SBC(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006c70:	18 95       	mov	r5,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"SBC\n");
	// A,Z,C,N = A-M-(1-C)
	Byte data = nes_readCPUMemory(nes, address);
80006c72:	0e 9c       	mov	r12,r7
80006c74:	e0 a0 0c 46 	rcall	80008500 <nes_readCPUMemory>
	Word result = cpu1->accumulator - data;
80006c78:	0b e8       	ld.ub	r8,r5[0x6]
		cpu1->status &= MASK_STATUS_CARRY_OFF;
	}
}
static Bool cpu_getCarry(CPU cpu1) {
	//assert(cpu1 != NULL);
	if ((cpu1->status & MASK_STATUS_CARRY_ON) == MASK_STATUS_CARRY_ON) {
80006c7a:	0b ba       	ld.ub	r10,r5[0x3]
	CPU cpu1 = nes_getCPU(nes);
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"SBC\n");
	// A,Z,C,N = A-M-(1-C)
	Byte data = nes_readCPUMemory(nes, address);
	Word result = cpu1->accumulator - data;
80006c7c:	18 18       	sub	r8,r12
80006c7e:	5c 88       	casts.h	r8
		cpu1->status &= MASK_STATUS_CARRY_OFF;
	}
}
static Bool cpu_getCarry(CPU cpu1) {
	//assert(cpu1 != NULL);
	if ((cpu1->status & MASK_STATUS_CARRY_ON) == MASK_STATUS_CARRY_ON) {
80006c80:	ed ba 00 00 	bld	r10,0x0
80006c84:	c0 30       	breq	80006c8a <cpu_step+0x2be>
	//usart_write_line(&AVR32_USART0,"SBC\n");
	// A,Z,C,N = A-M-(1-C)
	Byte data = nes_readCPUMemory(nes, address);
	Word result = cpu1->accumulator - data;
	if (cpu_getCarry(cpu1) == FALSE) {
		result--;
80006c86:	20 18       	sub	r8,1
80006c88:	5c 88       	casts.h	r8
	}
	// C         Carry Flag     Clear if overflow in bit 7
	if ((result & MASK_BIT8) == MASK_BIT8) {
80006c8a:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80006c8e:	ed b9 00 08 	bld	r9,0x8
80006c92:	e0 81 06 2a 	brne	800078e6 <cpu_step+0xf1a>
static void cpu_setCarry(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_CARRY_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_CARRY_OFF;
80006c96:	e2 1a 00 fe 	andl	r10,0xfe,COH
80006c9a:	aa ba       	st.b	r5[0x3],r10
		} else {
		cpu_setCarry(cpu1, TRUE);
	}
	// V Overflow Flag   Set if sign bit is incorrect
	// based on http://nesdev.parodius.com/6502.txt
	if (((cpu1->accumulator ^ result) & 0x80) && ((cpu1->accumulator ^ data) & 0x80)) {
80006c9c:	0b eb       	ld.ub	r11,r5[0x6]
80006c9e:	16 59       	eor	r9,r11
80006ca0:	ed b9 00 07 	bld	r9,0x7
80006ca4:	c0 81       	brne	80006cb4 <cpu_step+0x2e8>
80006ca6:	f9 eb 20 0b 	eor	r11,r12,r11
80006caa:	30 09       	mov	r9,0
80006cac:	f2 0b 18 00 	cp.b	r11,r9
80006cb0:	e0 85 06 bd 	brlt	80007a2a <cpu_step+0x105e>
static void cpu_setOverflow(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_OVERFLOW_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_OVERFLOW_OFF;
80006cb4:	a7 ca       	cbr	r10,0x6
80006cb6:	aa ba       	st.b	r5[0x3],r10
	if (((cpu1->accumulator ^ result) & 0x80) && ((cpu1->accumulator ^ data) & 0x80)) {
		cpu_setOverflow(cpu1, TRUE);
		} else {
		cpu_setOverflow(cpu1, FALSE);
	}
	cpu1->accumulator = result;
80006cb8:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80006cbc:	aa e9       	st.b	r5[0x6],r9
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
80006cbe:	e0 81 06 28 	brne	8000790e <cpu_step+0xf42>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
80006cc2:	0b b8       	ld.ub	r8,r5[0x3]
80006cc4:	a1 b8       	sbr	r8,0x1
80006cc6:	aa b8       	st.b	r5[0x3],r8
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
80006cc8:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
80006ccc:	aa b8       	st.b	r5[0x3],r8
80006cce:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
static void cpu_setDecimal(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_DECIMAL_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_DECIMAL_OFF;
80006cd2:	09 b8       	ld.ub	r8,r4[0x3]
80006cd4:	a3 d8       	cbr	r8,0x3
80006cd6:	a8 b8       	st.b	r4[0x3],r8
		case SED:
		cpu_SED(cpu1);
		break;
		case CLD:
		cpu_CLD(cpu1);
		break;
80006cd8:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// CPX - Compare X Register
// This instruction compares the contents of the X register with another memory held value and sets the zero and carry flags as appropriate.
static void cpu_CPX(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006cdc:	0e 9c       	mov	r12,r7
80006cde:	e0 a0 0b 01 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"CPX\n");
	Byte data = nes_readCPUMemory(nes, address);
80006ce2:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
}
// CPX - Compare X Register
// This instruction compares the contents of the X register with another memory held value and sets the zero and carry flags as appropriate.
static void cpu_CPX(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006ce6:	18 95       	mov	r5,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"CPX\n");
	Byte data = nes_readCPUMemory(nes, address);
80006ce8:	0e 9c       	mov	r12,r7
80006cea:	e0 a0 0c 0b 	rcall	80008500 <nes_readCPUMemory>
// set to 0 - if a borrow is required
// set to 1 - if no borrow is required.
static void cpu_updateCarry_subtract(CPU cpu1, Byte a, Byte b) {
	//assert(cpu1 != NULL);
	// add a 'borrow' bit to borrow from
	Word aa = a;
80006cee:	0b c9       	ld.ub	r9,r5[0x4]
	aa += MASK_BIT8;
	Word bb = b;
	Word result = aa-bb;
	if ((result & MASK_BIT8) == MASK_BIT8) {
80006cf0:	f2 c8 ff 00 	sub	r8,r9,-256
80006cf4:	18 18       	sub	r8,r12
80006cf6:	ed b8 00 08 	bld	r8,0x8
80006cfa:	e0 81 06 1f 	brne	80007938 <cpu_step+0xf6c>
	}
}
static void cpu_setCarry(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_CARRY_ON;
80006cfe:	0b b8       	ld.ub	r8,r5[0x3]
80006d00:	a1 a8       	sbr	r8,0x0
80006d02:	aa b8       	st.b	r5[0x3],r8
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
80006d04:	f8 09 18 00 	cp.b	r9,r12
80006d08:	e0 81 06 13 	brne	8000792e <cpu_step+0xf62>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
80006d0c:	a1 b8       	sbr	r8,0x1
80006d0e:	aa b8       	st.b	r5[0x3],r8
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
80006d10:	18 19       	sub	r9,r12
80006d12:	30 0a       	mov	r10,0
80006d14:	f4 09 18 00 	cp.b	r9,r10
80006d18:	e0 85 06 5c 	brlt	800079d0 <cpu_step+0x1004>
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
80006d1c:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
80006d20:	aa b8       	st.b	r5[0x3],r8
80006d22:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// BNE - Branch if Not Equal
// If the zero flag is clear then add the relative displacement to the program counter o cause a branch to a new location.
static void cpu_BNE(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006d26:	0e 9c       	mov	r12,r7
80006d28:	e0 a0 0a dc 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BNE\n");
	SignedByte data = nes_readCPUMemory(nes, address);
80006d2c:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
}
// BNE - Branch if Not Equal
// If the zero flag is clear then add the relative displacement to the program counter o cause a branch to a new location.
static void cpu_BNE(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006d30:	18 95       	mov	r5,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BNE\n");
	SignedByte data = nes_readCPUMemory(nes, address);
80006d32:	0e 9c       	mov	r12,r7
80006d34:	e0 a0 0b e6 	rcall	80008500 <nes_readCPUMemory>
	//usart_write_line(&AVR32_USART0,"JMP\n");
	cpu1->programCounter = address;
}
static Bool cpu_getZero(CPU cpu1) {
	//assert(cpu1 != NULL);
	if ((cpu1->status & MASK_STATUS_ZERO_ON) == MASK_STATUS_ZERO_ON) {
80006d38:	0b b8       	ld.ub	r8,r5[0x3]
80006d3a:	ed b8 00 01 	bld	r8,0x1
80006d3e:	fe 90 ff 3a 	breq	80006bb2 <cpu_step+0x1e6>
	//usart_write_line(&AVR32_USART0,"BNE\n");
	SignedByte data = nes_readCPUMemory(nes, address);
	if (cpu_getZero(cpu1) == FALSE) {
		// +1 cycle if the branch succeeds
		//nes_cpuCycled(nes);
		cpu1->programCounter += data;
80006d42:	8a 08       	ld.sh	r8,r5[0x0]
80006d44:	5c 6c       	casts.b	r12
80006d46:	18 08       	add	r8,r12
80006d48:	aa 08       	st.h	r5[0x0],r8
80006d4a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// DEX - Decrement X Register
// Subtracts one from the X register setting the zero and negative flags as appropriate.
static void cpu_DEX(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"DEX\n");
	cpu1->indexX--;
80006d4e:	09 c9       	ld.ub	r9,r4[0x4]
80006d50:	20 19       	sub	r9,1
80006d52:	5c 59       	castu.b	r9
80006d54:	a8 c9       	st.b	r4[0x4],r9
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
80006d56:	e0 81 06 22 	brne	8000799a <cpu_step+0xfce>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
80006d5a:	09 b8       	ld.ub	r8,r4[0x3]
80006d5c:	a1 b8       	sbr	r8,0x1
80006d5e:	a8 b8       	st.b	r4[0x3],r8
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
80006d60:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
80006d64:	a8 b8       	st.b	r4[0x3],r8
80006d66:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// INY - Increment Y Register
// Adds one to the Y register setting the zero and negative flags as appropriate.
static void cpu_INY(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"INY\n");
	cpu1->indexY++;
80006d6a:	09 d9       	ld.ub	r9,r4[0x5]
80006d6c:	2f f9       	sub	r9,-1
80006d6e:	5c 59       	castu.b	r9
80006d70:	a8 d9       	st.b	r4[0x5],r9
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
80006d72:	e0 81 05 e9 	brne	80007944 <cpu_step+0xf78>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
80006d76:	09 b8       	ld.ub	r8,r4[0x3]
80006d78:	a1 b8       	sbr	r8,0x1
80006d7a:	a8 b8       	st.b	r4[0x3],r8
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
80006d7c:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
80006d80:	a8 b8       	st.b	r4[0x3],r8
80006d82:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// DEC - Decrement Memory
// Subtracts one from the value held at a specified memory location setting the zero and negative flags as appropriate.
static void cpu_DEC(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006d86:	0e 9c       	mov	r12,r7
80006d88:	e0 a0 0a ac 	rcall	800082e0 <nes_getCPU>
		break;
		case DEC_ZPAGE:
		case DEC_ZPAGEX:
		case DEC_ABS:
		case DEC_ABSX:
		cpu_DEC(nes, address);
80006d8c:	5c 76       	castu.h	r6
}
// DEC - Decrement Memory
// Subtracts one from the value held at a specified memory location setting the zero and negative flags as appropriate.
static void cpu_DEC(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006d8e:	18 95       	mov	r5,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"DEC\n");
	Byte data = nes_readCPUMemory(nes, address);
80006d90:	0c 9b       	mov	r11,r6
80006d92:	0e 9c       	mov	r12,r7
80006d94:	e0 a0 0b b6 	rcall	80008500 <nes_readCPUMemory>
	// dummy write, cycle wasted here
	nes_writeCPUMemory(nes, address, data);
80006d98:	0c 9b       	mov	r11,r6
80006d9a:	18 9a       	mov	r10,r12
static void cpu_DEC(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"DEC\n");
	Byte data = nes_readCPUMemory(nes, address);
80006d9c:	18 94       	mov	r4,r12
	// dummy write, cycle wasted here
	nes_writeCPUMemory(nes, address, data);
80006d9e:	0e 9c       	mov	r12,r7
80006da0:	e0 a0 0a c0 	rcall	80008320 <nes_writeCPUMemory>
	data--;
80006da4:	08 9a       	mov	r10,r4
80006da6:	20 1a       	sub	r10,1
80006da8:	5c 5a       	castu.b	r10
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
80006daa:	e0 81 05 dd 	brne	80007964 <cpu_step+0xf98>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
80006dae:	0b b8       	ld.ub	r8,r5[0x3]
80006db0:	a1 b8       	sbr	r8,0x1
80006db2:	aa b8       	st.b	r5[0x3],r8
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
80006db4:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
80006db8:	aa b8       	st.b	r5[0x3],r8
	data--;
	// Z Zero Flag       Set if result is zero
	cpu_updateZero(cpu1, data);
	// N Negative Flag   Set if bit 7 of the result is set
	cpu_updateNegative(cpu1, data);
	nes_writeCPUMemory(nes, address, data);
80006dba:	0c 9b       	mov	r11,r6
80006dbc:	0e 9c       	mov	r12,r7
80006dbe:	e0 a0 0a b1 	rcall	80008320 <nes_writeCPUMemory>
		case DEC_ZPAGE:
		case DEC_ZPAGEX:
		case DEC_ABS:
		case DEC_ABSX:
		cpu_DEC(nes, address);
		break;
80006dc2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// CMP - Compare
// This instruction compares the contents of the accumulator with another memory held value and sets the zero and carry flags as appropriate.
static void cpu_CMP(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006dc6:	0e 9c       	mov	r12,r7
80006dc8:	e0 a0 0a 8c 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"CMP\n");
	Byte data = nes_readCPUMemory(nes, address);
80006dcc:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
}
// CMP - Compare
// This instruction compares the contents of the accumulator with another memory held value and sets the zero and carry flags as appropriate.
static void cpu_CMP(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006dd0:	18 95       	mov	r5,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"CMP\n");
	Byte data = nes_readCPUMemory(nes, address);
80006dd2:	0e 9c       	mov	r12,r7
80006dd4:	e0 a0 0b 96 	rcall	80008500 <nes_readCPUMemory>
// set to 0 - if a borrow is required
// set to 1 - if no borrow is required.
static void cpu_updateCarry_subtract(CPU cpu1, Byte a, Byte b) {
	//assert(cpu1 != NULL);
	// add a 'borrow' bit to borrow from
	Word aa = a;
80006dd8:	0b e9       	ld.ub	r9,r5[0x6]
	aa += MASK_BIT8;
	Word bb = b;
	Word result = aa-bb;
	if ((result & MASK_BIT8) == MASK_BIT8) {
80006dda:	f2 c8 ff 00 	sub	r8,r9,-256
80006dde:	18 18       	sub	r8,r12
80006de0:	ed b8 00 08 	bld	r8,0x8
80006de4:	e0 81 05 f0 	brne	800079c4 <cpu_step+0xff8>
	}
}
static void cpu_setCarry(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_CARRY_ON;
80006de8:	0b b8       	ld.ub	r8,r5[0x3]
80006dea:	a1 a8       	sbr	r8,0x0
80006dec:	aa b8       	st.b	r5[0x3],r8
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
80006dee:	f8 09 18 00 	cp.b	r9,r12
80006df2:	e0 81 05 e4 	brne	800079ba <cpu_step+0xfee>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
80006df6:	a1 b8       	sbr	r8,0x1
80006df8:	aa b8       	st.b	r5[0x3],r8
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
80006dfa:	18 19       	sub	r9,r12
80006dfc:	30 0a       	mov	r10,0
80006dfe:	f4 09 18 00 	cp.b	r9,r10
80006e02:	e0 85 05 ee 	brlt	800079de <cpu_step+0x1012>
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
80006e06:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
80006e0a:	aa b8       	st.b	r5[0x3],r8
80006e0c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// CPY - Compare Y Register
// This instruction compares the contents of the Y register with another memory held value and sets the zero and carry flags as appropriate.
static void cpu_CPY(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006e10:	0e 9c       	mov	r12,r7
80006e12:	e0 a0 0a 67 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"CPY\n");
	Byte data = nes_readCPUMemory(nes, address);
80006e16:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
}
// CPY - Compare Y Register
// This instruction compares the contents of the Y register with another memory held value and sets the zero and carry flags as appropriate.
static void cpu_CPY(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006e1a:	18 95       	mov	r5,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"CPY\n");
	Byte data = nes_readCPUMemory(nes, address);
80006e1c:	0e 9c       	mov	r12,r7
80006e1e:	e0 a0 0b 71 	rcall	80008500 <nes_readCPUMemory>
// set to 0 - if a borrow is required
// set to 1 - if no borrow is required.
static void cpu_updateCarry_subtract(CPU cpu1, Byte a, Byte b) {
	//assert(cpu1 != NULL);
	// add a 'borrow' bit to borrow from
	Word aa = a;
80006e22:	0b d9       	ld.ub	r9,r5[0x5]
	aa += MASK_BIT8;
	Word bb = b;
	Word result = aa-bb;
	if ((result & MASK_BIT8) == MASK_BIT8) {
80006e24:	f2 c8 ff 00 	sub	r8,r9,-256
80006e28:	18 18       	sub	r8,r12
80006e2a:	ed b8 00 08 	bld	r8,0x8
80006e2e:	e0 81 05 b0 	brne	8000798e <cpu_step+0xfc2>
	}
}
static void cpu_setCarry(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_CARRY_ON;
80006e32:	0b b8       	ld.ub	r8,r5[0x3]
80006e34:	a1 a8       	sbr	r8,0x0
80006e36:	aa b8       	st.b	r5[0x3],r8
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
80006e38:	f8 09 18 00 	cp.b	r9,r12
80006e3c:	e0 81 05 a4 	brne	80007984 <cpu_step+0xfb8>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
80006e40:	a1 b8       	sbr	r8,0x1
80006e42:	aa b8       	st.b	r5[0x3],r8
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
80006e44:	18 19       	sub	r9,r12
80006e46:	30 0a       	mov	r10,0
80006e48:	f4 09 18 00 	cp.b	r9,r10
80006e4c:	e0 85 05 d7 	brlt	800079fa <cpu_step+0x102e>
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
80006e50:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
80006e54:	aa b8       	st.b	r5[0x3],r8
80006e56:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case LDA_INDY: cpu_LDA(nes, address); break;
		case LDA_IMM:cpu_LDA(nes, address); break;
		case LDA_ZPAGE:cpu_LDA(nes, address); break;
		case LDA_ZPAGEX:cpu_LDA(nes, address); break;
		case LDA_ABS:cpu_LDA(nes, address); break;
		case LDA_ABSX:cpu_LDA(nes, address); break;
80006e5a:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006e5e:	0e 9c       	mov	r12,r7
80006e60:	fe b0 fc 1c 	rcall	80006698 <cpu_LDA>
80006e64:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		cpu_STA(nes, address);
		break;
		case LDX_IMM: cpu_LDX(nes, address); break;
		case LDX_ZPAGE:  cpu_LDX(nes, address); break; 
		case LDX_ABS: cpu_LDX(nes, address); break;
		case LDX_ABSY: cpu_LDX(nes, address); break;
80006e68:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006e6c:	0e 9c       	mov	r12,r7
80006e6e:	fe b0 fc 3b 	rcall	800066e4 <cpu_LDX>
80006e72:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case LDY_IMM: cpu_LDY(nes, address); break;
		case LDY_ZPAGE: cpu_LDY(nes, address); break;
		case LDY_ZPAGEX: cpu_LDY(nes, address); break;
		case LDY_ABS: cpu_LDY(nes, address); break;
		case LDY_ABSX:
		cpu_LDY(nes, address);
80006e76:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006e7a:	0e 9c       	mov	r12,r7
80006e7c:	fe b0 fc 5a 	rcall	80006730 <cpu_LDY>
		break;
80006e80:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// TSX - Transfer Stack Pointer to X
// Copies the current contents of the stack register into the X register and sets the zero and negative flags as appropriate.
static void cpu_TSX(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"TSX\n");
	cpu1->indexX = cpu1->stackPointer;
80006e84:	09 a9       	ld.ub	r9,r4[0x2]
80006e86:	a8 c9       	st.b	r4[0x4],r9
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
80006e88:	58 09       	cp.w	r9,0
80006e8a:	e0 81 04 94 	brne	800077b2 <cpu_step+0xde6>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
80006e8e:	09 b8       	ld.ub	r8,r4[0x3]
80006e90:	a1 b8       	sbr	r8,0x1
80006e92:	a8 b8       	st.b	r4[0x3],r8
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
80006e94:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
80006e98:	a8 b8       	st.b	r4[0x3],r8
80006e9a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case LDA_IMM:cpu_LDA(nes, address); break;
		case LDA_ZPAGE:cpu_LDA(nes, address); break;
		case LDA_ZPAGEX:cpu_LDA(nes, address); break;
		case LDA_ABS:cpu_LDA(nes, address); break;
		case LDA_ABSX:cpu_LDA(nes, address); break;
		case LDA_ABSY:cpu_LDA(nes, address); break;
80006e9e:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006ea2:	0e 9c       	mov	r12,r7
80006ea4:	fe b0 fb fa 	rcall	80006698 <cpu_LDA>
80006ea8:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case STA_INDX:
		cpu_STA(nes, address);
		break;
		case LDX_IMM: cpu_LDX(nes, address); break;
		case LDX_ZPAGE:  cpu_LDX(nes, address); break; 
		case LDX_ABS: cpu_LDX(nes, address); break;
80006eac:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006eb0:	0e 9c       	mov	r12,r7
80006eb2:	fe b0 fc 19 	rcall	800066e4 <cpu_LDX>
80006eb6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
	switch(instruction) {
		case LDA_INDY: cpu_LDA(nes, address); break;
		case LDA_IMM:cpu_LDA(nes, address); break;
		case LDA_ZPAGE:cpu_LDA(nes, address); break;
		case LDA_ZPAGEX:cpu_LDA(nes, address); break;
		case LDA_ABS:cpu_LDA(nes, address); break;
80006eba:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006ebe:	0e 9c       	mov	r12,r7
80006ec0:	fe b0 fb ec 	rcall	80006698 <cpu_LDA>
80006ec4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		cpu_STX(nes, address);
		break;
		case LDY_IMM: cpu_LDY(nes, address); break;
		case LDY_ZPAGE: cpu_LDY(nes, address); break;
		case LDY_ZPAGEX: cpu_LDY(nes, address); break;
		case LDY_ABS: cpu_LDY(nes, address); break;
80006ec8:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006ecc:	0e 9c       	mov	r12,r7
80006ece:	fe b0 fc 31 	rcall	80006730 <cpu_LDY>
80006ed2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// TAX - Transfer Accumulator to X
// Copies the current contents of the accumulator into the X register and sets the zero and negative flags as appropriate.
static void cpu_TAX(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"TAX\n");
	cpu1->indexX = cpu1->accumulator;
80006ed6:	09 e9       	ld.ub	r9,r4[0x6]
80006ed8:	a8 c9       	st.b	r4[0x4],r9
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
80006eda:	58 09       	cp.w	r9,0
80006edc:	e0 81 04 7b 	brne	800077d2 <cpu_step+0xe06>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
80006ee0:	09 b8       	ld.ub	r8,r4[0x3]
80006ee2:	a1 b8       	sbr	r8,0x1
80006ee4:	a8 b8       	st.b	r4[0x3],r8
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
80006ee6:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
80006eea:	a8 b8       	st.b	r4[0x3],r8
80006eec:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		////usart_write_line(&AVR32_USART0,"Instruction not implemented: 0x%x\n", instruction);
		//assert(FALSE);
	}
	switch(instruction) {
		case LDA_INDY: cpu_LDA(nes, address); break;
		case LDA_IMM:cpu_LDA(nes, address); break;
80006ef0:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006ef4:	0e 9c       	mov	r12,r7
80006ef6:	fe b0 fb d1 	rcall	80006698 <cpu_LDA>
80006efa:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case STA_ABSY:cpu_STA(nes, address); break;
		case STA_INDX:
		cpu_STA(nes, address);
		break;
		case LDX_IMM: cpu_LDX(nes, address); break;
		case LDX_ZPAGE:  cpu_LDX(nes, address); break; 
80006efe:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006f02:	0e 9c       	mov	r12,r7
80006f04:	fe b0 fb f0 	rcall	800066e4 <cpu_LDX>
80006f08:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		//assert(FALSE);
	}
	switch(instruction) {
		case LDA_INDY: cpu_LDA(nes, address); break;
		case LDA_IMM:cpu_LDA(nes, address); break;
		case LDA_ZPAGE:cpu_LDA(nes, address); break;
80006f0c:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006f10:	0e 9c       	mov	r12,r7
80006f12:	fe b0 fb c3 	rcall	80006698 <cpu_LDA>
80006f16:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// TAY - Transfer Accumulator to Y
// Copies the current contents of the accumulator into the Y register and sets the zero and negative flags as appropriate.
static void cpu_TAY(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"TAY\n");
	cpu1->indexY = cpu1->accumulator;
80006f1a:	09 e9       	ld.ub	r9,r4[0x6]
80006f1c:	a8 d9       	st.b	r4[0x5],r9
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
80006f1e:	58 09       	cp.w	r9,0
80006f20:	e0 81 04 69 	brne	800077f2 <cpu_step+0xe26>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
80006f24:	09 b8       	ld.ub	r8,r4[0x3]
80006f26:	a1 b8       	sbr	r8,0x1
80006f28:	a8 b8       	st.b	r4[0x3],r8
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
80006f2a:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
80006f2e:	a8 b8       	st.b	r4[0x3],r8
80006f30:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case STX_ABS: cpu_STX(nes, address); break;
		case STX_ZPAGEY: cpu_STX(nes, address); break;
		cpu_STX(nes, address);
		break;
		case LDY_IMM: cpu_LDY(nes, address); break;
		case LDY_ZPAGE: cpu_LDY(nes, address); break;
80006f34:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006f38:	0e 9c       	mov	r12,r7
80006f3a:	fe b0 fb fb 	rcall	80006730 <cpu_LDY>
80006f3e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
	}
	switch(instruction) {
		case LDA_INDY: cpu_LDA(nes, address); break;
		case LDA_IMM:cpu_LDA(nes, address); break;
		case LDA_ZPAGE:cpu_LDA(nes, address); break;
		case LDA_ZPAGEX:cpu_LDA(nes, address); break;
80006f42:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006f46:	0e 9c       	mov	r12,r7
80006f48:	fe b0 fb a8 	rcall	80006698 <cpu_LDA>
80006f4c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case STX_ZPAGEY: cpu_STX(nes, address); break;
		cpu_STX(nes, address);
		break;
		case LDY_IMM: cpu_LDY(nes, address); break;
		case LDY_ZPAGE: cpu_LDY(nes, address); break;
		case LDY_ZPAGEX: cpu_LDY(nes, address); break;
80006f50:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006f54:	0e 9c       	mov	r12,r7
80006f56:	fe b0 fb ed 	rcall	80006730 <cpu_LDY>
80006f5a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		//printf("Instruction not implemented: 0x%x\n", instruction);
		////usart_write_line(&AVR32_USART0,"Instruction not implemented: 0x%x\n", instruction);
		//assert(FALSE);
	}
	switch(instruction) {
		case LDA_INDY: cpu_LDA(nes, address); break;
80006f5e:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006f62:	0e 9c       	mov	r12,r7
80006f64:	fe b0 fb 9a 	rcall	80006698 <cpu_LDA>
80006f68:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// BCS - Branch if Carry Set
// If the carry flag is set then add the relative displacement to the program counter to cause a branch to a new location.
static void cpu_BCS(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006f6c:	0e 9c       	mov	r12,r7
80006f6e:	e0 a0 09 b9 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BCS\n");
	SignedByte data = nes_readCPUMemory(nes, address);
80006f72:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
}
// BCS - Branch if Carry Set
// If the carry flag is set then add the relative displacement to the program counter to cause a branch to a new location.
static void cpu_BCS(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80006f76:	18 95       	mov	r5,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BCS\n");
	SignedByte data = nes_readCPUMemory(nes, address);
80006f78:	0e 9c       	mov	r12,r7
80006f7a:	e0 a0 0a c3 	rcall	80008500 <nes_readCPUMemory>
		cpu1->status &= MASK_STATUS_CARRY_OFF;
	}
}
static Bool cpu_getCarry(CPU cpu1) {
	//assert(cpu1 != NULL);
	if ((cpu1->status & MASK_STATUS_CARRY_ON) == MASK_STATUS_CARRY_ON) {
80006f7e:	0b b8       	ld.ub	r8,r5[0x3]
80006f80:	ed b8 00 00 	bld	r8,0x0
80006f84:	fe 91 fe 17 	brne	80006bb2 <cpu_step+0x1e6>
	//usart_write_line(&AVR32_USART0,"BCS\n");
	SignedByte data = nes_readCPUMemory(nes, address);
	if (cpu_getCarry(cpu1) == TRUE) {
		// +1 cycle if the branch succeeds
		//nes_cpuCycled(nes);
		cpu1->programCounter += data;
80006f88:	8a 08       	ld.sh	r8,r5[0x0]
80006f8a:	5c 6c       	casts.b	r12
80006f8c:	18 08       	add	r8,r12
80006f8e:	aa 08       	st.h	r5[0x0],r8
80006f90:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
static void cpu_setOverflow(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_OVERFLOW_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_OVERFLOW_OFF;
80006f94:	09 b8       	ld.ub	r8,r4[0x3]
80006f96:	a7 c8       	cbr	r8,0x6
80006f98:	a8 b8       	st.b	r4[0x3],r8
		case CLC:
		cpu_CLC(cpu1);
		break;
		case CLV:
		cpu_CLV(cpu1);
		break;
80006f9a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case LDX_IMM: cpu_LDX(nes, address); break;
		case LDX_ZPAGE:  cpu_LDX(nes, address); break; 
		case LDX_ABS: cpu_LDX(nes, address); break;
		case LDX_ABSY: cpu_LDX(nes, address); break;
		case LDX_ZPAGEY:
		cpu_LDX(nes, address);
80006f9e:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006fa2:	0e 9c       	mov	r12,r7
80006fa4:	fe b0 fb a0 	rcall	800066e4 <cpu_LDX>
		break;
80006fa8:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		break;
		case STA_INDY: cpu_STA(nes, address); break;
		case STA_ZPAGE:cpu_STA(nes, address); break;
		case STA_ZPAGEX:cpu_STA(nes, address); break;
		case STA_ABS:cpu_STA(nes, address); break;
		case STA_ABSX:cpu_STA(nes, address); break;
80006fac:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006fb0:	0e 9c       	mov	r12,r7
80006fb2:	fe b0 fc 73 	rcall	80006898 <cpu_STA>
80006fb6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// TXS - Transfer X to Stack Pointer
// Copies the current contents of the X register into the stack register.
static void cpu_TXS(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"TXS\n");
	cpu1->stackPointer = cpu1->indexX;
80006fba:	09 c8       	ld.ub	r8,r4[0x4]
80006fbc:	a8 a8       	st.b	r4[0x2],r8
		case TSX:
		cpu_TSX(cpu1);
		break;
		case TXS:
		cpu_TXS(cpu1);
		break;
80006fbe:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case STA_INDY: cpu_STA(nes, address); break;
		case STA_ZPAGE:cpu_STA(nes, address); break;
		case STA_ZPAGEX:cpu_STA(nes, address); break;
		case STA_ABS:cpu_STA(nes, address); break;
		case STA_ABSX:cpu_STA(nes, address); break;
		case STA_ABSY:cpu_STA(nes, address); break;
80006fc2:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006fc6:	0e 9c       	mov	r12,r7
80006fc8:	fe b0 fc 68 	rcall	80006898 <cpu_STA>
80006fcc:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// TYA - Transfer Y to Accumulator
// Copies the current contents of the Y register into the accumulator and sets the zero and negative flags as appropriate.
static void cpu_TYA(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"TYA\n");
	cpu1->accumulator = cpu1->indexY;
80006fd0:	09 d9       	ld.ub	r9,r4[0x5]
80006fd2:	a8 e9       	st.b	r4[0x6],r9
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
80006fd4:	58 09       	cp.w	r9,0
80006fd6:	e0 81 03 ba 	brne	8000774a <cpu_step+0xd7e>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
80006fda:	09 b8       	ld.ub	r8,r4[0x3]
80006fdc:	a1 b8       	sbr	r8,0x1
80006fde:	a8 b8       	st.b	r4[0x3],r8
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
80006fe0:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
80006fe4:	a8 b8       	st.b	r4[0x3],r8
80006fe6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case LDA_ZPAGEX:cpu_LDA(nes, address); break;
		case LDA_ABS:cpu_LDA(nes, address); break;
		case LDA_ABSX:cpu_LDA(nes, address); break;
		case LDA_ABSY:cpu_LDA(nes, address); break;
		case LDA_INDX:
		cpu_LDA(nes, address);
80006fea:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006fee:	0e 9c       	mov	r12,r7
80006ff0:	fe b0 fb 54 	rcall	80006698 <cpu_LDA>
		break;
80006ff4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case STA_ABSX:cpu_STA(nes, address); break;
		case STA_ABSY:cpu_STA(nes, address); break;
		case STA_INDX:
		cpu_STA(nes, address);
		break;
		case LDX_IMM: cpu_LDX(nes, address); break;
80006ff8:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80006ffc:	0e 9c       	mov	r12,r7
80006ffe:	fe b0 fb 73 	rcall	800066e4 <cpu_LDX>
80007002:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case STX_ZPAGE: cpu_STX(nes, address); break;
		case STX_ABS: cpu_STX(nes, address); break;
		case STX_ZPAGEY: cpu_STX(nes, address); break;
		cpu_STX(nes, address);
		break;
		case LDY_IMM: cpu_LDY(nes, address); break;
80007006:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
8000700a:	0e 9c       	mov	r12,r7
8000700c:	fe b0 fb 92 	rcall	80006730 <cpu_LDY>
80007010:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case LDX_ZPAGEY:
		cpu_LDX(nes, address);
		break;
		case STX_ZPAGE: cpu_STX(nes, address); break;
		case STX_ABS: cpu_STX(nes, address); break;
		case STX_ZPAGEY: cpu_STX(nes, address); break;
80007014:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80007018:	0e 9c       	mov	r12,r7
8000701a:	fe b0 fc 4d 	rcall	800068b4 <cpu_STX>
8000701e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case LDA_INDX:
		cpu_LDA(nes, address);
		break;
		case STA_INDY: cpu_STA(nes, address); break;
		case STA_ZPAGE:cpu_STA(nes, address); break;
		case STA_ZPAGEX:cpu_STA(nes, address); break;
80007022:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80007026:	0e 9c       	mov	r12,r7
80007028:	fe b0 fc 38 	rcall	80006898 <cpu_STA>
8000702c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case LDA_ABSX:cpu_LDA(nes, address); break;
		case LDA_ABSY:cpu_LDA(nes, address); break;
		case LDA_INDX:
		cpu_LDA(nes, address);
		break;
		case STA_INDY: cpu_STA(nes, address); break;
80007030:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80007034:	0e 9c       	mov	r12,r7
80007036:	fe b0 fc 31 	rcall	80006898 <cpu_STA>
8000703a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// BCC - Branch if Carry Clear
// If the carry flag is clear then add the relative displacement to the program counter to cause a branch to a new location.
static void cpu_BCC(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
8000703e:	0e 9c       	mov	r12,r7
80007040:	e0 a0 09 50 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BCC\n");
	SignedByte data = nes_readCPUMemory(nes, address);
80007044:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
}
// BCC - Branch if Carry Clear
// If the carry flag is clear then add the relative displacement to the program counter to cause a branch to a new location.
static void cpu_BCC(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80007048:	18 95       	mov	r5,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BCC\n");
	SignedByte data = nes_readCPUMemory(nes, address);
8000704a:	0e 9c       	mov	r12,r7
8000704c:	e0 a0 0a 5a 	rcall	80008500 <nes_readCPUMemory>
		cpu1->status &= MASK_STATUS_CARRY_OFF;
	}
}
static Bool cpu_getCarry(CPU cpu1) {
	//assert(cpu1 != NULL);
	if ((cpu1->status & MASK_STATUS_CARRY_ON) == MASK_STATUS_CARRY_ON) {
80007050:	0b b8       	ld.ub	r8,r5[0x3]
80007052:	ed b8 00 00 	bld	r8,0x0
80007056:	fe 90 fd ae 	breq	80006bb2 <cpu_step+0x1e6>
	//usart_write_line(&AVR32_USART0,"BCC\n");
	SignedByte data = nes_readCPUMemory(nes, address);
	if (cpu_getCarry(cpu1) == FALSE) {
		// +1 cycle if the branch succeeds
		//nes_cpuCycled(nes);
		cpu1->programCounter += data;
8000705a:	8a 08       	ld.sh	r8,r5[0x0]
8000705c:	5c 6c       	casts.b	r12
8000705e:	18 08       	add	r8,r12
80007060:	aa 08       	st.h	r5[0x0],r8
80007062:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case LDX_ABSY: cpu_LDX(nes, address); break;
		case LDX_ZPAGEY:
		cpu_LDX(nes, address);
		break;
		case STX_ZPAGE: cpu_STX(nes, address); break;
		case STX_ABS: cpu_STX(nes, address); break;
80007066:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
8000706a:	0e 9c       	mov	r12,r7
8000706c:	fe b0 fc 24 	rcall	800068b4 <cpu_STX>
80007070:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		cpu_LDA(nes, address);
		break;
		case STA_INDY: cpu_STA(nes, address); break;
		case STA_ZPAGE:cpu_STA(nes, address); break;
		case STA_ZPAGEX:cpu_STA(nes, address); break;
		case STA_ABS:cpu_STA(nes, address); break;
80007074:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80007078:	0e 9c       	mov	r12,r7
8000707a:	fe b0 fc 0f 	rcall	80006898 <cpu_STA>
8000707e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// TXA - Transfer X to Accumulator
// Copies the current contents of the X register into the accumulator and sets the zero and negative flags as appropriate.
static void cpu_TXA(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"TXA\n");
	cpu1->accumulator = cpu1->indexX;
80007082:	09 c9       	ld.ub	r9,r4[0x4]
80007084:	a8 e9       	st.b	r4[0x6],r9
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
80007086:	58 09       	cp.w	r9,0
80007088:	e0 81 03 71 	brne	8000776a <cpu_step+0xd9e>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
8000708c:	09 b8       	ld.ub	r8,r4[0x3]
8000708e:	a1 b8       	sbr	r8,0x1
80007090:	a8 b8       	st.b	r4[0x3],r8
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
80007092:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
80007096:	a8 b8       	st.b	r4[0x3],r8
80007098:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// DEY - Decrement Y Register
// Subtracts one from the Y register setting the zero and negative flags as appropriate.
static void cpu_DEY(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"DEY\n");
	cpu1->indexY--;
8000709c:	09 d9       	ld.ub	r9,r4[0x5]
8000709e:	20 19       	sub	r9,1
800070a0:	5c 59       	castu.b	r9
800070a2:	a8 d9       	st.b	r4[0x5],r9
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
800070a4:	e0 81 03 33 	brne	8000770a <cpu_step+0xd3e>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
800070a8:	09 b8       	ld.ub	r8,r4[0x3]
800070aa:	a1 b8       	sbr	r8,0x1
800070ac:	a8 b8       	st.b	r4[0x3],r8
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
800070ae:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
800070b2:	a8 b8       	st.b	r4[0x3],r8
800070b4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case LDX_ABS: cpu_LDX(nes, address); break;
		case LDX_ABSY: cpu_LDX(nes, address); break;
		case LDX_ZPAGEY:
		cpu_LDX(nes, address);
		break;
		case STX_ZPAGE: cpu_STX(nes, address); break;
800070b8:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800070bc:	0e 9c       	mov	r12,r7
800070be:	fe b0 fb fb 	rcall	800068b4 <cpu_STX>
800070c2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
	cpu_updateNegative(cpu1, cpu1->accumulator);
}
static void cpu_setInterruptDisable(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_INTERRUPT_ON;
800070c6:	09 b8       	ld.ub	r8,r4[0x3]
800070c8:	a3 a8       	sbr	r8,0x2
800070ca:	a8 b8       	st.b	r4[0x3],r8
		case CLD:
		cpu_CLD(cpu1);
		break;
		case SEI:
		cpu_SEI(cpu1);
		break;
800070cc:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// BVS - Branch if Overflow Set
// If the overflow flag is set then add the relative displacement to the program counter to cause a branch to a new location.
static void cpu_BVS(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
800070d0:	0e 9c       	mov	r12,r7
800070d2:	e0 a0 09 07 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BVS\n");
	SignedByte data = nes_readCPUMemory(nes, address);
800070d6:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
}
// BVS - Branch if Overflow Set
// If the overflow flag is set then add the relative displacement to the program counter to cause a branch to a new location.
static void cpu_BVS(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
800070da:	18 95       	mov	r5,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BVS\n");
	SignedByte data = nes_readCPUMemory(nes, address);
800070dc:	0e 9c       	mov	r12,r7
800070de:	e0 a0 0a 11 	rcall	80008500 <nes_readCPUMemory>
		cpu1->status &= MASK_STATUS_OVERFLOW_OFF;
	}
}
static Bool cpu_getOverflow(CPU cpu1) {
	//assert(cpu1 != NULL);
	if ((cpu1->status & MASK_STATUS_OVERFLOW_ON) == MASK_STATUS_OVERFLOW_ON) {
800070e2:	0b b8       	ld.ub	r8,r5[0x3]
800070e4:	ed b8 00 06 	bld	r8,0x6
800070e8:	fe 91 fd 65 	brne	80006bb2 <cpu_step+0x1e6>
	//usart_write_line(&AVR32_USART0,"BVS\n");
	SignedByte data = nes_readCPUMemory(nes, address);
	if (cpu_getOverflow(cpu1) == TRUE) {
		// +1 cycle if the branch succeeds
		//nes_cpuCycled(nes);
		cpu1->programCounter += data;
800070ec:	8a 08       	ld.sh	r8,r5[0x0]
800070ee:	5c 6c       	casts.b	r12
800070f0:	18 08       	add	r8,r12
800070f2:	aa 08       	st.h	r5[0x0],r8
800070f4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
}
static inline void cpu_JMP(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
800070f8:	0e 9c       	mov	r12,r7
800070fa:	e0 a0 08 f3 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"JMP\n");
	cpu1->programCounter = address;
800070fe:	b8 06       	st.h	r12[0x0],r6
80007100:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// Move each of the bits in either A or M one place to the right.
// Bit 7 is filled with the current value of the carry flag whilst the old bit 0 becomes the new carry flag value.
static void cpu_ROR(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"ROR\n");
	Word result = cpu1->accumulator >> 1;
80007104:	09 ea       	ld.ub	r10,r4[0x6]
		cpu1->status &= MASK_STATUS_CARRY_OFF;
	}
}
static Bool cpu_getCarry(CPU cpu1) {
	//assert(cpu1 != NULL);
	if ((cpu1->status & MASK_STATUS_CARRY_ON) == MASK_STATUS_CARRY_ON) {
80007106:	09 b8       	ld.ub	r8,r4[0x3]
// Move each of the bits in either A or M one place to the right.
// Bit 7 is filled with the current value of the carry flag whilst the old bit 0 becomes the new carry flag value.
static void cpu_ROR(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"ROR\n");
	Word result = cpu1->accumulator >> 1;
80007108:	f4 09 16 01 	lsr	r9,r10,0x1
		cpu1->status &= MASK_STATUS_CARRY_OFF;
	}
}
static Bool cpu_getCarry(CPU cpu1) {
	//assert(cpu1 != NULL);
	if ((cpu1->status & MASK_STATUS_CARRY_ON) == MASK_STATUS_CARRY_ON) {
8000710c:	ed b8 00 00 	bld	r8,0x0
80007110:	c0 21       	brne	80007114 <cpu_step+0x748>
static void cpu_ROR(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"ROR\n");
	Word result = cpu1->accumulator >> 1;
	if (cpu_getCarry(cpu1) == TRUE) {
		result |= MASK_BIT7;
80007112:	a7 b9       	sbr	r9,0x7
	}
	// C         Carry Flag     Set to contents of old bit 0
	if ( (cpu1->accumulator & MASK_BIT0) == MASK_BIT0) {
80007114:	ed ba 00 00 	bld	r10,0x0
80007118:	e0 81 03 49 	brne	800077aa <cpu_step+0xdde>
	}
}
static void cpu_setCarry(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_CARRY_ON;
8000711c:	a1 a8       	sbr	r8,0x0
8000711e:	a8 b8       	st.b	r4[0x3],r8
	if ( (cpu1->accumulator & MASK_BIT0) == MASK_BIT0) {
		cpu_setCarry(cpu1, TRUE);
		} else {
		cpu_setCarry(cpu1, FALSE);
	}
	cpu1->accumulator = result;
80007120:	a8 e9       	st.b	r4[0x6],r9
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
80007122:	58 09       	cp.w	r9,0
80007124:	e0 81 03 33 	brne	8000778a <cpu_step+0xdbe>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
80007128:	09 b8       	ld.ub	r8,r4[0x3]
8000712a:	a1 b8       	sbr	r8,0x1
8000712c:	a8 b8       	st.b	r4[0x3],r8
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
8000712e:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
80007132:	a8 b8       	st.b	r4[0x3],r8
80007134:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// STY - Store Y Register
// Stores the contents of the Y register into memory.
static void cpu_STY(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80007138:	0e 9c       	mov	r12,r7
8000713a:	e0 a0 08 d3 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"STY\n");
	nes_writeCPUMemory(nes, address, cpu1->indexY);
8000713e:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80007142:	19 da       	ld.ub	r10,r12[0x5]
80007144:	0e 9c       	mov	r12,r7
80007146:	e0 a0 08 ed 	rcall	80008320 <nes_writeCPUMemory>
8000714a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case STA_ZPAGEX:cpu_STA(nes, address); break;
		case STA_ABS:cpu_STA(nes, address); break;
		case STA_ABSX:cpu_STA(nes, address); break;
		case STA_ABSY:cpu_STA(nes, address); break;
		case STA_INDX:
		cpu_STA(nes, address);
8000714e:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80007152:	0e 9c       	mov	r12,r7
80007154:	fe b0 fb a2 	rcall	80006898 <cpu_STA>
		break;
80007158:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case LDA_ABSY:cpu_LDA(nes, address); break;
		case LDA_INDX:
		cpu_LDA(nes, address);
		break;
		case STA_INDY: cpu_STA(nes, address); break;
		case STA_ZPAGE:cpu_STA(nes, address); break;
8000715c:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80007160:	0e 9c       	mov	r12,r7
80007162:	fe b0 fb 9b 	rcall	80006898 <cpu_STA>
80007166:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// PLA - Pull Accumulator
// Pulls an 8 bit value from the stack and into the accumulator.
// The zero and negative flags are set as appropriate.
static void cpu_PLA(NES nes) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
8000716a:	0e 9c       	mov	r12,r7
8000716c:	e0 a0 08 ba 	rcall	800082e0 <nes_getCPU>
80007170:	18 96       	mov	r6,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"PLA\n");
	// waste a cycle for the stack pointer increment that is about to happen in popStack
	//nes_cpuCycled(nes);
	cpu1->accumulator = cpu_popStack(nes);
80007172:	0e 9c       	mov	r12,r7
80007174:	fe b0 fb 80 	rcall	80006874 <cpu_popStack>
80007178:	ac ec       	st.b	r6[0x6],r12
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
8000717a:	e0 81 02 d8 	brne	8000772a <cpu_step+0xd5e>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
8000717e:	0d b8       	ld.ub	r8,r6[0x3]
80007180:	a1 b8       	sbr	r8,0x1
80007182:	ac b8       	st.b	r6[0x3],r8
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
80007184:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
80007188:	ac b8       	st.b	r6[0x3],r8
8000718a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// ROR - Rotate Right
// Move each of the bits in either A or M one place to the right.
// Bit 7 is filled with the current value of the carry flag whilst the old bit 0 becomes the new carry flag value.
static void cpu_ROR_memory(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
8000718e:	0e 9c       	mov	r12,r7
80007190:	e0 a0 08 a8 	rcall	800082e0 <nes_getCPU>
		break;
		case ROR_ZPAGE:
		case ROR_ZPAGEX:
		case ROR_ABS:
		case ROR_ABSX:
		cpu_ROR_memory(nes, address);
80007194:	5c 76       	castu.h	r6
// ROR - Rotate Right
// Move each of the bits in either A or M one place to the right.
// Bit 7 is filled with the current value of the carry flag whilst the old bit 0 becomes the new carry flag value.
static void cpu_ROR_memory(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80007196:	18 95       	mov	r5,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"ROR_memory\n");
	Byte data = nes_readCPUMemory(nes, address);
80007198:	0c 9b       	mov	r11,r6
8000719a:	0e 9c       	mov	r12,r7
8000719c:	e0 a0 09 b2 	rcall	80008500 <nes_readCPUMemory>
	// dummy write, cycle wasted here
	nes_writeCPUMemory(nes, address, data);
800071a0:	0c 9b       	mov	r11,r6
800071a2:	18 9a       	mov	r10,r12
static void cpu_ROR_memory(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"ROR_memory\n");
	Byte data = nes_readCPUMemory(nes, address);
800071a4:	18 94       	mov	r4,r12
	// dummy write, cycle wasted here
	nes_writeCPUMemory(nes, address, data);
800071a6:	0e 9c       	mov	r12,r7
800071a8:	e0 a0 08 bc 	rcall	80008320 <nes_writeCPUMemory>
		cpu1->status &= MASK_STATUS_CARRY_OFF;
	}
}
static Bool cpu_getCarry(CPU cpu1) {
	//assert(cpu1 != NULL);
	if ((cpu1->status & MASK_STATUS_CARRY_ON) == MASK_STATUS_CARRY_ON) {
800071ac:	0b b8       	ld.ub	r8,r5[0x3]
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"ROR_memory\n");
	Byte data = nes_readCPUMemory(nes, address);
	// dummy write, cycle wasted here
	nes_writeCPUMemory(nes, address, data);
	Word result = data >> 1;
800071ae:	f5 d4 c0 28 	bfextu	r10,r4,0x1,0x8
		cpu1->status &= MASK_STATUS_CARRY_OFF;
	}
}
static Bool cpu_getCarry(CPU cpu1) {
	//assert(cpu1 != NULL);
	if ((cpu1->status & MASK_STATUS_CARRY_ON) == MASK_STATUS_CARRY_ON) {
800071b2:	ed b8 00 00 	bld	r8,0x0
800071b6:	c0 21       	brne	800071ba <cpu_step+0x7ee>
	Byte data = nes_readCPUMemory(nes, address);
	// dummy write, cycle wasted here
	nes_writeCPUMemory(nes, address, data);
	Word result = data >> 1;
	if (cpu_getCarry(cpu1) == TRUE) {
		result |= MASK_BIT7;
800071b8:	a7 ba       	sbr	r10,0x7
	}
	// C         Carry Flag      Set to contents of old bit 0
	if ((data & MASK_BIT0) == MASK_BIT0) {
800071ba:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
800071be:	e0 80 03 5c 	breq	80007876 <cpu_step+0xeaa>
	}
}
static void cpu_setCarry(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_CARRY_ON;
800071c2:	a1 a8       	sbr	r8,0x0
800071c4:	aa b8       	st.b	r5[0x3],r8
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
800071c6:	58 0a       	cp.w	r10,0
800071c8:	e0 81 03 53 	brne	8000786e <cpu_step+0xea2>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
800071cc:	a1 b8       	sbr	r8,0x1
800071ce:	aa b8       	st.b	r5[0x3],r8
	}
	// Z Zero Flag       Set if A = 0
	cpu_updateZero(cpu1, result);
	// N Negative Flag   Set if bit 7 of the result is set
	cpu_updateZero(cpu1, result);
	nes_writeCPUMemory(nes, address, result);
800071d0:	0c 9b       	mov	r11,r6
800071d2:	0e 9c       	mov	r12,r7
800071d4:	e0 a0 08 a6 	rcall	80008320 <nes_writeCPUMemory>
		case ROR_ZPAGE:
		case ROR_ZPAGEX:
		case ROR_ABS:
		case ROR_ABSX:
		cpu_ROR_memory(nes, address);
		break;
800071d8:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case ORA_INDX:
		cpu_ORA(nes, address);
		break;
		case EOR_INDY: cpu_EOR(nes, address); break;
		case EOR_IMM:  cpu_EOR(nes, address); break;
		case EOR_ZPAGE:  cpu_EOR(nes, address); break;
800071dc:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800071e0:	0e 9c       	mov	r12,r7
800071e2:	fe b0 fb 1f 	rcall	80006820 <cpu_EOR>
800071e6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case EOR_ZPAGEX:  cpu_EOR(nes, address); break;
		case EOR_ABS:  cpu_EOR(nes, address); break;
		case EOR_ABSX:  cpu_EOR(nes, address); break;
		case EOR_ABSY:  cpu_EOR(nes, address); break;
		case EOR_INDX:
		cpu_EOR(nes, address);
800071ea:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800071ee:	0e 9c       	mov	r12,r7
800071f0:	fe b0 fb 18 	rcall	80006820 <cpu_EOR>
		break;
800071f4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case ORA_ABSX: cpu_ORA(nes, address); break;
		case ORA_ABSY: cpu_ORA(nes, address); break;
		case ORA_INDX:
		cpu_ORA(nes, address);
		break;
		case EOR_INDY: cpu_EOR(nes, address); break;
800071f8:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800071fc:	0e 9c       	mov	r12,r7
800071fe:	fe b0 fb 11 	rcall	80006820 <cpu_EOR>
80007202:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case EOR_IMM:  cpu_EOR(nes, address); break;
		case EOR_ZPAGE:  cpu_EOR(nes, address); break;
		case EOR_ZPAGEX:  cpu_EOR(nes, address); break;
		case EOR_ABS:  cpu_EOR(nes, address); break;
80007206:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
8000720a:	0e 9c       	mov	r12,r7
8000720c:	fe b0 fb 0a 	rcall	80006820 <cpu_EOR>
80007210:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
	//assert(cpu1 != NULL);
	cpu1->programCounter++;
}
static inline void cpu_JMP(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80007214:	0e 9c       	mov	r12,r7
80007216:	e0 a0 08 65 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"JMP\n");
	cpu1->programCounter = address;
8000721a:	b8 06       	st.h	r12[0x0],r6
8000721c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// Each of the bits in A is shift one place to the right.
// The bit that was in bit 0 is shifted into the carry flag. Bit 7 is set to zero.
static void cpu_LSR(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"LSR\n");
	Word result = cpu1->accumulator >> 1;
80007220:	09 e8       	ld.ub	r8,r4[0x6]
	// C         Carry Flag      Set to contents of old bit 0
	if ( (cpu1->accumulator & MASK_BIT0) == MASK_BIT0 ) {
80007222:	f3 d8 c0 01 	bfextu	r9,r8,0x0,0x1
// Each of the bits in A is shift one place to the right.
// The bit that was in bit 0 is shifted into the carry flag. Bit 7 is set to zero.
static void cpu_LSR(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"LSR\n");
	Word result = cpu1->accumulator >> 1;
80007226:	a1 98       	lsr	r8,0x1
	// C         Carry Flag      Set to contents of old bit 0
	if ( (cpu1->accumulator & MASK_BIT0) == MASK_BIT0 ) {
80007228:	58 09       	cp.w	r9,0
8000722a:	e0 80 03 09 	breq	8000783c <cpu_step+0xe70>
	}
}
static void cpu_setCarry(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_CARRY_ON;
8000722e:	09 b9       	ld.ub	r9,r4[0x3]
80007230:	a1 a9       	sbr	r9,0x0
80007232:	a8 b9       	st.b	r4[0x3],r9
	if ( (cpu1->accumulator & MASK_BIT0) == MASK_BIT0 ) {
		cpu_setCarry(cpu1, TRUE);
		} else {
		cpu_setCarry(cpu1, FALSE);
	}
	cpu1->accumulator = result;
80007234:	a8 e8       	st.b	r4[0x6],r8
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
80007236:	58 08       	cp.w	r8,0
80007238:	e0 81 02 fc 	brne	80007830 <cpu_step+0xe64>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
8000723c:	09 b8       	ld.ub	r8,r4[0x3]
8000723e:	a1 b8       	sbr	r8,0x1
80007240:	a8 b8       	st.b	r4[0x3],r8
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
80007242:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
80007246:	a8 b8       	st.b	r4[0x3],r8
80007248:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case ORA_ABSY: cpu_ORA(nes, address); break;
		case ORA_INDX:
		cpu_ORA(nes, address);
		break;
		case EOR_INDY: cpu_EOR(nes, address); break;
		case EOR_IMM:  cpu_EOR(nes, address); break;
8000724c:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80007250:	0e 9c       	mov	r12,r7
80007252:	fe b0 fa e7 	rcall	80006820 <cpu_EOR>
80007256:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// PHA - Push Accumulator
// Pushes a copy of the accumulator on to the stack.
static void cpu_PHA(NES nes) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
8000725a:	0e 9c       	mov	r12,r7
8000725c:	e0 a0 08 42 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"PHA\n");
	cpu_pushStack(nes, cpu1->accumulator);
80007260:	19 eb       	ld.ub	r11,r12[0x6]
80007262:	0e 9c       	mov	r12,r7
80007264:	fe b0 fb 36 	rcall	800068d0 <cpu_pushStack>
		case PLP:
		cpu_PLP(nes);
		break;
		case PHA:
		cpu_PHA(nes);
		break;
80007268:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// Each of the bits in A or M is shift one place to the right.
// The bit that was in bit 0 is shifted into the carry flag.
// Bit 7 is set to zero.
static void cpu_LSR_memory(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
8000726c:	0e 9c       	mov	r12,r7
8000726e:	e0 a0 08 39 	rcall	800082e0 <nes_getCPU>
		break;
		case LSR_ZPAGE:
		case LSR_ZPAGEX:
		case LSR_ABS:
		case LSR_ABSX:
		cpu_LSR_memory(nes, address);
80007272:	eb d6 c0 10 	bfextu	r5,r6,0x0,0x10
// Each of the bits in A or M is shift one place to the right.
// The bit that was in bit 0 is shifted into the carry flag.
// Bit 7 is set to zero.
static void cpu_LSR_memory(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80007276:	18 96       	mov	r6,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"LSR_memory\n");
	// A,C,Z,N = A/2 or M,C,Z,N = M/2
	Byte data = nes_readCPUMemory(nes, address);
80007278:	0a 9b       	mov	r11,r5
8000727a:	0e 9c       	mov	r12,r7
8000727c:	e0 a0 09 42 	rcall	80008500 <nes_readCPUMemory>
	// dummy write, cycle wasted here
	nes_writeCPUMemory(nes, address, data);
80007280:	0a 9b       	mov	r11,r5
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"LSR_memory\n");
	// A,C,Z,N = A/2 or M,C,Z,N = M/2
	Byte data = nes_readCPUMemory(nes, address);
80007282:	18 94       	mov	r4,r12
	// dummy write, cycle wasted here
	nes_writeCPUMemory(nes, address, data);
80007284:	18 9a       	mov	r10,r12
80007286:	0e 9c       	mov	r12,r7
80007288:	e0 a0 08 4c 	rcall	80008320 <nes_writeCPUMemory>
	Word result = data >> 1;
	// C         Carry Flag     Set to contents of old bit 0
	if ( (data & MASK_BIT0) == MASK_BIT0) {
8000728c:	f1 d4 c0 01 	bfextu	r8,r4,0x0,0x1
	//usart_write_line(&AVR32_USART0,"LSR_memory\n");
	// A,C,Z,N = A/2 or M,C,Z,N = M/2
	Byte data = nes_readCPUMemory(nes, address);
	// dummy write, cycle wasted here
	nes_writeCPUMemory(nes, address, data);
	Word result = data >> 1;
80007290:	f5 d4 c0 28 	bfextu	r10,r4,0x1,0x8
	// C         Carry Flag     Set to contents of old bit 0
	if ( (data & MASK_BIT0) == MASK_BIT0) {
80007294:	58 08       	cp.w	r8,0
80007296:	e0 80 02 21 	breq	800076d8 <cpu_step+0xd0c>
	}
}
static void cpu_setCarry(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_CARRY_ON;
8000729a:	0d b8       	ld.ub	r8,r6[0x3]
8000729c:	a1 a8       	sbr	r8,0x0
8000729e:	ac b8       	st.b	r6[0x3],r8
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
800072a0:	58 0a       	cp.w	r10,0
800072a2:	e0 81 02 0c 	brne	800076ba <cpu_step+0xcee>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
800072a6:	a1 b8       	sbr	r8,0x1
800072a8:	ac b8       	st.b	r6[0x3],r8
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
800072aa:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
800072ae:	ac b8       	st.b	r6[0x3],r8
	}
	// Z Zero Flag       Set if result = 0
	cpu_updateZero(cpu1, result);
	// N Negative Flag   Set if bit 7 of the result is set
	cpu_updateNegative(cpu1, result);
	nes_writeCPUMemory(nes, address, result);
800072b0:	0a 9b       	mov	r11,r5
800072b2:	0e 9c       	mov	r12,r7
800072b4:	e0 a0 08 36 	rcall	80008320 <nes_writeCPUMemory>
		case LSR_ZPAGE:
		case LSR_ZPAGEX:
		case LSR_ABS:
		case LSR_ABSX:
		cpu_LSR_memory(nes, address);
		break;
800072b8:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case EOR_INDY: cpu_EOR(nes, address); break;
		case EOR_IMM:  cpu_EOR(nes, address); break;
		case EOR_ZPAGE:  cpu_EOR(nes, address); break;
		case EOR_ZPAGEX:  cpu_EOR(nes, address); break;
		case EOR_ABS:  cpu_EOR(nes, address); break;
		case EOR_ABSX:  cpu_EOR(nes, address); break;
800072bc:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800072c0:	0e 9c       	mov	r12,r7
800072c2:	fe b0 fa af 	rcall	80006820 <cpu_EOR>
800072c6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case EOR_ABSY:  cpu_EOR(nes, address); break;
800072ca:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800072ce:	0e 9c       	mov	r12,r7
800072d0:	fe b0 fa a8 	rcall	80006820 <cpu_EOR>
800072d4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case AND_ZPAGEX: cpu_AND(nes, address); break;
		case AND_ABS: cpu_AND(nes, address); break;
		case AND_ABSX: cpu_AND(nes, address); break;
		case AND_ABSY: cpu_AND(nes, address); break;
		case AND_INDX:
		cpu_AND(nes, address);
800072d8:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800072dc:	0e 9c       	mov	r12,r7
800072de:	fe b0 fa 4f 	rcall	8000677c <cpu_AND>
		break;
800072e2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// JSR - Jump to Subroutine
// The JSR instruction pushes the address (minus one) of the return point on to the stack and then sets the program counter to the target memory address.
static void cpu_JSR(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
800072e6:	0e 9c       	mov	r12,r7
800072e8:	e0 a0 07 fc 	rcall	800082e0 <nes_getCPU>
800072ec:	18 95       	mov	r5,r12
	// (and, as such, before it can increment the PC past this point).
	// To compensate for this, the RTS opcode increments the program counter during its 6th instruction cycle.
	// JSR takes 6 cycles, waste a cycle here
	//nes_cpuCycled(nes);
	Address returnAddress = cpu1->programCounter - 1;
	cpu_pushStack(nes, GET_ADDRESS_HIGH_BYTE(returnAddress));
800072ee:	0e 9c       	mov	r12,r7
	// This is because it pushes the program counter onto the stack BEFORE it fetches the final byte of the opcode
	// (and, as such, before it can increment the PC past this point).
	// To compensate for this, the RTS opcode increments the program counter during its 6th instruction cycle.
	// JSR takes 6 cycles, waste a cycle here
	//nes_cpuCycled(nes);
	Address returnAddress = cpu1->programCounter - 1;
800072f0:	8a 04       	ld.sh	r4,r5[0x0]
800072f2:	20 14       	sub	r4,1
800072f4:	5c 84       	casts.h	r4
	cpu_pushStack(nes, GET_ADDRESS_HIGH_BYTE(returnAddress));
800072f6:	f7 d4 c1 08 	bfextu	r11,r4,0x8,0x8
800072fa:	fe b0 fa eb 	rcall	800068d0 <cpu_pushStack>
	cpu_pushStack(nes, GET_ADDRESS_LOW_BYTE(returnAddress));
800072fe:	08 9b       	mov	r11,r4
80007300:	0e 9c       	mov	r12,r7
80007302:	5c 5b       	castu.b	r11
80007304:	fe b0 fa e6 	rcall	800068d0 <cpu_pushStack>
	cpu1->programCounter = address;
80007308:	aa 06       	st.h	r5[0x0],r6
8000730a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case ORA_INDY: cpu_ORA(nes, address); break;
		case ORA_IMM: cpu_ORA(nes, address); break; 
		case ORA_ZPAGE: cpu_ORA(nes, address); break; 
		case ORA_ZPAGEX: cpu_ORA(nes, address); break;
		case ORA_ABS: cpu_ORA(nes, address); break;
		case ORA_ABSX: cpu_ORA(nes, address); break;
8000730e:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80007312:	0e 9c       	mov	r12,r7
80007314:	fe b0 fa 5c 	rcall	800067cc <cpu_ORA>
80007318:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case ORA_ABSY: cpu_ORA(nes, address); break;
8000731c:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80007320:	0e 9c       	mov	r12,r7
80007322:	fe b0 fa 55 	rcall	800067cc <cpu_ORA>
80007326:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
static void cpu_setCarry(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_CARRY_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_CARRY_OFF;
8000732a:	09 b8       	ld.ub	r8,r4[0x3]
8000732c:	a1 c8       	cbr	r8,0x0
8000732e:	a8 b8       	st.b	r4[0x3],r8
		case SEC:
		cpu_SEC(cpu1);
		break;
		case CLC:
		cpu_CLC(cpu1);
		break;
80007330:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		cpu_AND(nes, address);
		break;
		case ORA_INDY: cpu_ORA(nes, address); break;
		case ORA_IMM: cpu_ORA(nes, address); break; 
		case ORA_ZPAGE: cpu_ORA(nes, address); break; 
		case ORA_ZPAGEX: cpu_ORA(nes, address); break;
80007334:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80007338:	0e 9c       	mov	r12,r7
8000733a:	fe b0 fa 49 	rcall	800067cc <cpu_ORA>
8000733e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case AND_ABSX: cpu_AND(nes, address); break;
		case AND_ABSY: cpu_AND(nes, address); break;
		case AND_INDX:
		cpu_AND(nes, address);
		break;
		case ORA_INDY: cpu_ORA(nes, address); break;
80007342:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80007346:	0e 9c       	mov	r12,r7
80007348:	fe b0 fa 42 	rcall	800067cc <cpu_ORA>
8000734c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// BPL - Branch if Positive
// If the negative flag is clear then add the relative displacement to the program counter to cause a branch to a new location.
static void cpu_BPL(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80007350:	0e 9c       	mov	r12,r7
80007352:	e0 a0 07 c7 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BPL\n");
	SignedByte data = nes_readCPUMemory(nes, address);
80007356:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
}
// BPL - Branch if Positive
// If the negative flag is clear then add the relative displacement to the program counter to cause a branch to a new location.
static void cpu_BPL(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
8000735a:	18 95       	mov	r5,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BPL\n");
	SignedByte data = nes_readCPUMemory(nes, address);
8000735c:	0e 9c       	mov	r12,r7
8000735e:	e0 a0 08 d1 	rcall	80008500 <nes_readCPUMemory>
	//assert(cpu1 != NULL);
	cpu_setDecimal(cpu1, FALSE);
}
static Bool cpu_getNegative(CPU cpu1) {
	//assert(cpu1 != NULL);
	if ((cpu1->status & MASK_STATUS_NEGATIVE_ON) == MASK_STATUS_NEGATIVE_ON) {
80007362:	0b b9       	ld.ub	r9,r5[0x3]
80007364:	30 08       	mov	r8,0
80007366:	f0 09 18 00 	cp.b	r9,r8
8000736a:	e0 85 03 46 	brlt	800079f6 <cpu_step+0x102a>
	//usart_write_line(&AVR32_USART0,"BPL\n");
	SignedByte data = nes_readCPUMemory(nes, address);
	if (cpu_getNegative(cpu1) == FALSE) {
		// +1 cycle if the branch succeeds
		//nes_cpuCycled(nes);
		cpu1->programCounter += data;
8000736e:	8a 08       	ld.sh	r8,r5[0x0]
80007370:	5c 6c       	casts.b	r12
80007372:	18 08       	add	r8,r12
80007374:	aa 08       	st.h	r5[0x0],r8
80007376:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		break;
		case ORA_INDY: cpu_ORA(nes, address); break;
		case ORA_IMM: cpu_ORA(nes, address); break; 
		case ORA_ZPAGE: cpu_ORA(nes, address); break; 
		case ORA_ZPAGEX: cpu_ORA(nes, address); break;
		case ORA_ABS: cpu_ORA(nes, address); break;
8000737a:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
8000737e:	0e 9c       	mov	r12,r7
80007380:	fe b0 fa 26 	rcall	800067cc <cpu_ORA>
80007384:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// Bit 0 is set to 0 and bit 7 is placed in the carry flag.
// The effect of this operation is to multiply the memory contents by 2 (ignoring 2's complement considerations),
// setting the carry if the result will not fit in 8 bits.
static void cpu_ASL_memory(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80007388:	0e 9c       	mov	r12,r7
8000738a:	e0 a0 07 ab 	rcall	800082e0 <nes_getCPU>
		break;
		case ASL_ZPAGE:
		case ASL_ZPAGEX:
		case ASL_ABS:
		case ASL_ABSX:
		cpu_ASL_memory(nes, address);
8000738e:	eb d6 c0 10 	bfextu	r5,r6,0x0,0x10
// Bit 0 is set to 0 and bit 7 is placed in the carry flag.
// The effect of this operation is to multiply the memory contents by 2 (ignoring 2's complement considerations),
// setting the carry if the result will not fit in 8 bits.
static void cpu_ASL_memory(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80007392:	18 96       	mov	r6,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"ASL_memory\n");
	// A,Z,C,N = M*2 or M,Z,C,N = M*2
	Byte data = nes_readCPUMemory(nes, address);
80007394:	0a 9b       	mov	r11,r5
80007396:	0e 9c       	mov	r12,r7
80007398:	e0 a0 08 b4 	rcall	80008500 <nes_readCPUMemory>
	// dummy write, cycle wasted here
	nes_writeCPUMemory(nes, address, data);
8000739c:	0a 9b       	mov	r11,r5
8000739e:	18 9a       	mov	r10,r12
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"ASL_memory\n");
	// A,Z,C,N = M*2 or M,Z,C,N = M*2
	Byte data = nes_readCPUMemory(nes, address);
800073a0:	18 94       	mov	r4,r12
	// dummy write, cycle wasted here
	nes_writeCPUMemory(nes, address, data);
800073a2:	0e 9c       	mov	r12,r7
800073a4:	e0 a0 07 be 	rcall	80008320 <nes_writeCPUMemory>
	Word result = data << 1;
	// C Carry Flag      Set to contents of old bit 7
	if ( (data & MASK_BIT7) == MASK_BIT7) {
800073a8:	30 08       	mov	r8,0
800073aa:	f0 04 18 00 	cp.b	r4,r8
800073ae:	e0 85 03 2d 	brlt	80007a08 <cpu_step+0x103c>
static void cpu_setCarry(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_CARRY_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_CARRY_OFF;
800073b2:	0d b8       	ld.ub	r8,r6[0x3]
800073b4:	e2 18 00 fe 	andl	r8,0xfe,COH
800073b8:	ac b8       	st.b	r6[0x3],r8
		cpu_setCarry(cpu1, TRUE);
		} else {
		cpu_setCarry(cpu1, FALSE);
	}
	// Z Zero Flag       Set if A = 0
	cpu_updateZero(cpu1, result);
800073ba:	e8 0a 15 01 	lsl	r10,r4,0x1
800073be:	5c 5a       	castu.b	r10
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
800073c0:	e0 81 02 29 	brne	80007812 <cpu_step+0xe46>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
800073c4:	a1 b8       	sbr	r8,0x1
800073c6:	ac b8       	st.b	r6[0x3],r8
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
800073c8:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
800073cc:	ac b8       	st.b	r6[0x3],r8
	}
	// Z Zero Flag       Set if A = 0
	cpu_updateZero(cpu1, result);
	// N Negative Flag   Set if bit 7 of the result is set
	cpu_updateNegative(cpu1, result);
	nes_writeCPUMemory(nes, address, result);
800073ce:	0a 9b       	mov	r11,r5
800073d0:	0e 9c       	mov	r12,r7
800073d2:	e0 a0 07 a7 	rcall	80008320 <nes_writeCPUMemory>
		case ASL_ZPAGE:
		case ASL_ZPAGEX:
		case ASL_ABS:
		case ASL_ABSX:
		cpu_ASL_memory(nes, address);
		break;
800073d6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case AND_INDX:
		cpu_AND(nes, address);
		break;
		case ORA_INDY: cpu_ORA(nes, address); break;
		case ORA_IMM: cpu_ORA(nes, address); break; 
		case ORA_ZPAGE: cpu_ORA(nes, address); break; 
800073da:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800073de:	0e 9c       	mov	r12,r7
800073e0:	fe b0 f9 f6 	rcall	800067cc <cpu_ORA>
800073e4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case ORA_ZPAGEX: cpu_ORA(nes, address); break;
		case ORA_ABS: cpu_ORA(nes, address); break;
		case ORA_ABSX: cpu_ORA(nes, address); break;
		case ORA_ABSY: cpu_ORA(nes, address); break;
		case ORA_INDX:
		cpu_ORA(nes, address);
800073e8:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800073ec:	0e 9c       	mov	r12,r7
800073ee:	fe b0 f9 ef 	rcall	800067cc <cpu_ORA>
		break;
800073f2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// The program counter and processor status are pushed on the stack
// then the IRQ interrupt vector at $FFFE/F is loaded into the PC
// and the break flag in the status set to one.
static void cpu_BRK(NES nes) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
800073f6:	0e 9c       	mov	r12,r7
800073f8:	e0 a0 07 74 	rcall	800082e0 <nes_getCPU>
800073fc:	18 98       	mov	r8,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BRK\n");
	// the instruction has a "useless" second byte we need to skip
	// (added for debugging purposes apparently)
	cpu1->programCounter++;
800073fe:	90 09       	ld.sh	r9,r8[0x0]
80007400:	2f f9       	sub	r9,-1
	// B         Break Command          Set to 1
	cpu_handleInterrupt(nes, CPU_IRQ_VECTOR_LOWER_ADDRESS, TRUE);
80007402:	0e 9c       	mov	r12,r7
	CPU cpu1 = nes_getCPU(nes);
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BRK\n");
	// the instruction has a "useless" second byte we need to skip
	// (added for debugging purposes apparently)
	cpu1->programCounter++;
80007404:	b0 09       	st.h	r8[0x0],r9
	// B         Break Command          Set to 1
	cpu_handleInterrupt(nes, CPU_IRQ_VECTOR_LOWER_ADDRESS, TRUE);
80007406:	30 1a       	mov	r10,1
80007408:	e0 6b ff fe 	mov	r11,65534
8000740c:	fe b0 fa 84 	rcall	80006914 <cpu_handleInterrupt>
		case JMP_INDIRECT_CODE2:
		cpu_JMP(nes, address);
		break;
		case BRK:
		cpu_BRK(nes);
		break;
80007410:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case AND_ABSY: cpu_AND(nes, address); break;
		case AND_INDX:
		cpu_AND(nes, address);
		break;
		case ORA_INDY: cpu_ORA(nes, address); break;
		case ORA_IMM: cpu_ORA(nes, address); break; 
80007414:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80007418:	0e 9c       	mov	r12,r7
8000741a:	fe b0 f9 d9 	rcall	800067cc <cpu_ORA>
8000741e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// PHP - Push Processor Status
// Pushes a copy of the status flags on to the stack.
static void cpu_PHP(NES nes) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80007422:	0e 9c       	mov	r12,r7
80007424:	e0 a0 07 5e 	rcall	800082e0 <nes_getCPU>
80007428:	18 98       	mov	r8,r12
	// 1 at all times
	cpu1->status |= MASK_BIT5;
	Byte data = cpu1->status;
	data |= MASK_STATUS_BREAK_ON;
	//printf("PHP 0x%x 0x%x\n", cpu1->status, data);
	cpu_pushStack(nes, data);
8000742a:	0e 9c       	mov	r12,r7
	CPU cpu1 = nes_getCPU(nes);
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"PHP\n");
	// The status bits pushed on the stack by PHP have the breakpoint bit set.
	// 1 at all times
	cpu1->status |= MASK_BIT5;
8000742c:	11 bb       	ld.ub	r11,r8[0x3]
8000742e:	a5 bb       	sbr	r11,0x5
80007430:	b0 bb       	st.b	r8[0x3],r11
	Byte data = cpu1->status;
	data |= MASK_STATUS_BREAK_ON;
	//printf("PHP 0x%x 0x%x\n", cpu1->status, data);
	cpu_pushStack(nes, data);
80007432:	a5 ab       	sbr	r11,0x4
80007434:	fe b0 fa 4e 	rcall	800068d0 <cpu_pushStack>
		case RTI:
		cpu_RTI(nes);
		break;
		case PHP:
		cpu_PHP(nes);
		break;
80007438:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// The effect of this operation is to multiply the memory contents by 2
// (ignoring 2's complement considerations), setting the carry if the result will not fit in 8 bits.
static void cpu_ASL(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"ASL\n");
	Word result = cpu1->accumulator << 1;
8000743c:	09 e8       	ld.ub	r8,r4[0x6]
	// C         Carry Flag      Set to contents of old bit 7
	if ((cpu1->accumulator & MASK_BIT7) == MASK_BIT7) {
8000743e:	30 09       	mov	r9,0
80007440:	f2 08 18 00 	cp.b	r8,r9
80007444:	e0 85 02 d4 	brlt	800079ec <cpu_step+0x1020>
static void cpu_setCarry(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_CARRY_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_CARRY_OFF;
80007448:	09 b9       	ld.ub	r9,r4[0x3]
8000744a:	a1 c9       	cbr	r9,0x0
8000744c:	a8 b9       	st.b	r4[0x3],r9
	if ((cpu1->accumulator & MASK_BIT7) == MASK_BIT7) {
		cpu_setCarry(cpu1, TRUE);
		} else {
		cpu_setCarry(cpu1, FALSE);
	}
	cpu1->accumulator = result;
8000744e:	a1 78       	lsl	r8,0x1
80007450:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80007454:	a8 e9       	st.b	r4[0x6],r9
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
80007456:	e0 81 01 f8 	brne	80007846 <cpu_step+0xe7a>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
8000745a:	09 b8       	ld.ub	r8,r4[0x3]
8000745c:	a1 b8       	sbr	r8,0x1
8000745e:	a8 b8       	st.b	r4[0x3],r8
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
80007460:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
80007464:	a8 b8       	st.b	r4[0x3],r8
80007466:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
}
// BMI - Branch if Minus
// If the negative flag is set then add the relative displacement to the program counter to cause a branch to a new location.
static void cpu_BMI(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
8000746a:	0e 9c       	mov	r12,r7
8000746c:	e0 a0 07 3a 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BMI\n");
	SignedByte data = nes_readCPUMemory(nes, address);
80007470:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
}
// BMI - Branch if Minus
// If the negative flag is set then add the relative displacement to the program counter to cause a branch to a new location.
static void cpu_BMI(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80007474:	18 95       	mov	r5,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BMI\n");
	SignedByte data = nes_readCPUMemory(nes, address);
80007476:	0e 9c       	mov	r12,r7
80007478:	e0 a0 08 44 	rcall	80008500 <nes_readCPUMemory>
	//assert(cpu1 != NULL);
	cpu_setDecimal(cpu1, FALSE);
}
static Bool cpu_getNegative(CPU cpu1) {
	//assert(cpu1 != NULL);
	if ((cpu1->status & MASK_STATUS_NEGATIVE_ON) == MASK_STATUS_NEGATIVE_ON) {
8000747c:	0b b9       	ld.ub	r9,r5[0x3]
8000747e:	30 08       	mov	r8,0
80007480:	f0 09 18 00 	cp.b	r9,r8
80007484:	fe 94 fb 97 	brge	80006bb2 <cpu_step+0x1e6>
	//usart_write_line(&AVR32_USART0,"BMI\n");
	SignedByte data = nes_readCPUMemory(nes, address);
	if (cpu_getNegative(cpu1) == TRUE) {
		// +1 cycle if the branch succeeds
		//nes_cpuCycled(nes);
		cpu1->programCounter += data;
80007488:	8a 08       	ld.sh	r8,r5[0x0]
8000748a:	5c 6c       	casts.b	r12
8000748c:	18 08       	add	r8,r12
8000748e:	aa 08       	st.h	r5[0x0],r8
80007490:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		break;
		case AND_INDY: cpu_AND(nes, address); break;
		case AND_IMM: cpu_AND(nes, address); break;
		case AND_ZPAGE: cpu_AND(nes, address); break;
		case AND_ZPAGEX: cpu_AND(nes, address); break;
		case AND_ABS: cpu_AND(nes, address); break;
80007494:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80007498:	0e 9c       	mov	r12,r7
8000749a:	fe b0 f9 71 	rcall	8000677c <cpu_AND>
8000749e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case AND_ABSX: cpu_AND(nes, address); break;
		case AND_ABSY: cpu_AND(nes, address); break;
800074a2:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800074a6:	0e 9c       	mov	r12,r7
800074a8:	fe b0 f9 6a 	rcall	8000677c <cpu_AND>
800074ac:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
	}
}
static void cpu_setCarry(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_CARRY_ON;
800074b0:	09 b8       	ld.ub	r8,r4[0x3]
800074b2:	a1 a8       	sbr	r8,0x0
800074b4:	a8 b8       	st.b	r4[0x3],r8
		case CLI:
		cpu_CLI(cpu1);
		break;
		case SEC:
		cpu_SEC(cpu1);
		break;
800074b6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		cpu_STY(nes, address);
		break;
		case AND_INDY: cpu_AND(nes, address); break;
		case AND_IMM: cpu_AND(nes, address); break;
		case AND_ZPAGE: cpu_AND(nes, address); break;
		case AND_ZPAGEX: cpu_AND(nes, address); break;
800074ba:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800074be:	0e 9c       	mov	r12,r7
800074c0:	fe b0 f9 5e 	rcall	8000677c <cpu_AND>
800074c4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case STY_ZPAGE:
		case STY_ZPAGEX:
		case STY_ABS:
		cpu_STY(nes, address);
		break;
		case AND_INDY: cpu_AND(nes, address); break;
800074c8:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800074cc:	0e 9c       	mov	r12,r7
800074ce:	fe b0 f9 57 	rcall	8000677c <cpu_AND>
800074d2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// RTI - Return from Interrupt
// The RTI instruction is used at the end of an interrupt processing routine.
// It pulls the processor flags from the stack followed by the program counter.
static void cpu_RTI(NES nes) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
800074d6:	0e 9c       	mov	r12,r7
800074d8:	e0 a0 07 04 	rcall	800082e0 <nes_getCPU>
800074dc:	18 96       	mov	r6,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"RTI\n");
	// waste a cycle for the initial stack pointer increment that is about to happen in popStack
	//nes_cpuCycled(nes);
	cpu1->status = cpu_popStack(nes);
800074de:	0e 9c       	mov	r12,r7
800074e0:	fe b0 f9 ca 	rcall	80006874 <cpu_popStack>
	// 1 at all times
	cpu1->status |= MASK_BIT5;
800074e4:	a5 bc       	sbr	r12,0x5
800074e6:	ac bc       	st.b	r6[0x3],r12
	Address address = cpu_popStack(nes);
800074e8:	0e 9c       	mov	r12,r7
800074ea:	fe b0 f9 c5 	rcall	80006874 <cpu_popStack>
800074ee:	18 95       	mov	r5,r12
	address += cpu_popStack(nes) << BITS_PER_BYTE;
800074f0:	0e 9c       	mov	r12,r7
800074f2:	fe b0 f9 c1 	rcall	80006874 <cpu_popStack>
	cpu1->programCounter = address;
800074f6:	a9 6c       	lsl	r12,0x8
800074f8:	f8 05 00 05 	add	r5,r12,r5
800074fc:	ac 05       	st.h	r6[0x0],r5
		case RTS:
		cpu_RTS(nes);
		break;
		case RTI:
		cpu_RTI(nes);
		break;
800074fe:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case AND_INDY: cpu_AND(nes, address); break;
		case AND_IMM: cpu_AND(nes, address); break;
		case AND_ZPAGE: cpu_AND(nes, address); break;
		case AND_ZPAGEX: cpu_AND(nes, address); break;
		case AND_ABS: cpu_AND(nes, address); break;
		case AND_ABSX: cpu_AND(nes, address); break;
80007502:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80007506:	0e 9c       	mov	r12,r7
80007508:	fe b0 f9 3a 	rcall	8000677c <cpu_AND>
8000750c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// PLP - Pull Processor Status
// Pulls an 8 bit value from the stack and into the processor flags.
// The flags will take on new states as determined by the value pulled.
static void cpu_PLP(NES nes) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80007510:	0e 9c       	mov	r12,r7
80007512:	e0 a0 06 e7 	rcall	800082e0 <nes_getCPU>
80007516:	18 96       	mov	r6,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"PLP\n");
	// waste a cycle for the stack pointer increment that is about to happen in popStack
	//nes_cpuCycled(nes);
	Byte data = cpu_popStack(nes);
80007518:	0e 9c       	mov	r12,r7
8000751a:	fe b0 f9 ad 	rcall	80006874 <cpu_popStack>
	//printf("PLP 0x%x 0x%x\n", cpu1->status, data);
	cpu1->status = data;
	// 1 at all times
	cpu1->status |= MASK_BIT5;
8000751e:	a5 bc       	sbr	r12,0x5
80007520:	ac bc       	st.b	r6[0x3],r12
		case PHP:
		cpu_PHP(nes);
		break;
		case PLP:
		cpu_PLP(nes);
		break;
80007522:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// ROL - Rotate Left
// Move each of the bits in either A or M one place to the left.
// Bit 0 is filled with the current value of the carry flag whilst the old bit 7 becomes the new carry flag value.
static void cpu_ROL_memory(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80007526:	0e 9c       	mov	r12,r7
80007528:	e0 a0 06 dc 	rcall	800082e0 <nes_getCPU>
		break;
		case ROL_ZPAGE:
		case ROL_ZPAGEX:
		case ROL_ABS:
		case ROL_ABSX:
		cpu_ROL_memory(nes, address);
8000752c:	eb d6 c0 10 	bfextu	r5,r6,0x0,0x10
// ROL - Rotate Left
// Move each of the bits in either A or M one place to the left.
// Bit 0 is filled with the current value of the carry flag whilst the old bit 7 becomes the new carry flag value.
static void cpu_ROL_memory(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80007530:	18 96       	mov	r6,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"ROL_memory\n");
	Byte data = nes_readCPUMemory(nes, address);
80007532:	0a 9b       	mov	r11,r5
80007534:	0e 9c       	mov	r12,r7
80007536:	e0 a0 07 e5 	rcall	80008500 <nes_readCPUMemory>
	// dummy write, cycle wasted here
	nes_writeCPUMemory(nes, address, data);
8000753a:	0a 9b       	mov	r11,r5
8000753c:	18 9a       	mov	r10,r12
static void cpu_ROL_memory(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"ROL_memory\n");
	Byte data = nes_readCPUMemory(nes, address);
8000753e:	18 94       	mov	r4,r12
	// dummy write, cycle wasted here
	nes_writeCPUMemory(nes, address, data);
80007540:	0e 9c       	mov	r12,r7
80007542:	e0 a0 06 ef 	rcall	80008320 <nes_writeCPUMemory>
	Word result  = data << 1;
80007546:	e8 0a 15 01 	lsl	r10,r4,0x1
		cpu1->status &= MASK_STATUS_CARRY_OFF;
	}
}
static Bool cpu_getCarry(CPU cpu1) {
	//assert(cpu1 != NULL);
	if ((cpu1->status & MASK_STATUS_CARRY_ON) == MASK_STATUS_CARRY_ON) {
8000754a:	0d b8       	ld.ub	r8,r6[0x3]
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"ROL_memory\n");
	Byte data = nes_readCPUMemory(nes, address);
	// dummy write, cycle wasted here
	nes_writeCPUMemory(nes, address, data);
	Word result  = data << 1;
8000754c:	5c 8a       	casts.h	r10
		cpu1->status &= MASK_STATUS_CARRY_OFF;
	}
}
static Bool cpu_getCarry(CPU cpu1) {
	//assert(cpu1 != NULL);
	if ((cpu1->status & MASK_STATUS_CARRY_ON) == MASK_STATUS_CARRY_ON) {
8000754e:	ed b8 00 00 	bld	r8,0x0
80007552:	c0 21       	brne	80007556 <cpu_step+0xb8a>
	Byte data = nes_readCPUMemory(nes, address);
	// dummy write, cycle wasted here
	nes_writeCPUMemory(nes, address, data);
	Word result  = data << 1;
	if (cpu_getCarry(cpu1) == TRUE) {
		result |= MASK_BIT0;
80007554:	a1 aa       	sbr	r10,0x0
	}
	// C         Carry Flag     Set to contents of old bit 7
	if ((data & MASK_BIT7) == MASK_BIT7) {
80007556:	30 09       	mov	r9,0
80007558:	f2 04 18 00 	cp.b	r4,r9
8000755c:	e0 85 02 5b 	brlt	80007a12 <cpu_step+0x1046>
static void cpu_setCarry(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_CARRY_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_CARRY_OFF;
80007560:	e2 18 00 fe 	andl	r8,0xfe,COH
80007564:	ac b8       	st.b	r6[0x3],r8
		cpu_setCarry(cpu1, TRUE);
		} else {
		cpu_setCarry(cpu1, FALSE);
	}
	// Z Zero Flag       Set if A = 0
	cpu_updateZero(cpu1, result);
80007566:	5c 5a       	castu.b	r10
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
80007568:	e0 81 01 8c 	brne	80007880 <cpu_step+0xeb4>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
8000756c:	a1 b8       	sbr	r8,0x1
8000756e:	ac b8       	st.b	r6[0x3],r8
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
80007570:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
80007574:	ac b8       	st.b	r6[0x3],r8
	}
	// Z Zero Flag       Set if A = 0
	cpu_updateZero(cpu1, result);
	// N Negative Flag   Set if bit 7 of the result is set
	cpu_updateNegative(cpu1, result);
	nes_writeCPUMemory(nes, address, result);
80007576:	0a 9b       	mov	r11,r5
80007578:	0e 9c       	mov	r12,r7
8000757a:	e0 a0 06 d3 	rcall	80008320 <nes_writeCPUMemory>
		case ROL_ZPAGE:
		case ROL_ZPAGEX:
		case ROL_ABS:
		case ROL_ABSX:
		cpu_ROL_memory(nes, address);
		break;
8000757e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case STY_ABS:
		cpu_STY(nes, address);
		break;
		case AND_INDY: cpu_AND(nes, address); break;
		case AND_IMM: cpu_AND(nes, address); break;
		case AND_ZPAGE: cpu_AND(nes, address); break;
80007582:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80007586:	0e 9c       	mov	r12,r7
80007588:	fe b0 f8 fa 	rcall	8000677c <cpu_AND>
8000758c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// This instructions is used to test if one or more bits are set in a target memory location.
// The mask pattern in A is ANDed with the value in memory to set or clear the zero flag, but the result is not kept.
// Bits 7 and 6 of the value from memory are copied into the N and V flags.
static void cpu_BIT(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80007590:	0e 9c       	mov	r12,r7
80007592:	e0 a0 06 a7 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BIT\n");
	Byte data = nes_readCPUMemory(nes, address);
80007596:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
// This instructions is used to test if one or more bits are set in a target memory location.
// The mask pattern in A is ANDed with the value in memory to set or clear the zero flag, but the result is not kept.
// Bits 7 and 6 of the value from memory are copied into the N and V flags.
static void cpu_BIT(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
8000759a:	18 95       	mov	r5,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BIT\n");
	Byte data = nes_readCPUMemory(nes, address);
8000759c:	0e 9c       	mov	r12,r7
8000759e:	e0 a0 07 b1 	rcall	80008500 <nes_readCPUMemory>
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
800075a2:	0b e8       	ld.ub	r8,r5[0x6]
800075a4:	f9 e8 00 08 	and	r8,r12,r8
800075a8:	e0 81 01 7a 	brne	8000789c <cpu_step+0xed0>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
800075ac:	0b b8       	ld.ub	r8,r5[0x3]
800075ae:	a1 b8       	sbr	r8,0x1
800075b0:	aa b8       	st.b	r5[0x3],r8
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
800075b2:	30 09       	mov	r9,0
800075b4:	f2 0c 18 00 	cp.b	r12,r9
800075b8:	e0 85 02 31 	brlt	80007a1a <cpu_step+0x104e>
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
800075bc:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
800075c0:	aa b8       	st.b	r5[0x3],r8
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"BIT\n");
	Byte data = nes_readCPUMemory(nes, address);
	cpu_updateZero(cpu1, cpu1->accumulator & data);
	cpu_updateNegative(cpu1, data);
	if ((data & MASK_BIT6) == MASK_BIT6) {
800075c2:	ed bc 00 06 	bld	r12,0x6
800075c6:	e0 81 01 50 	brne	80007866 <cpu_step+0xe9a>
	cpu_updateNegative(cpu1, cpu1->accumulator);
}
static void cpu_setOverflow(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_OVERFLOW_ON;
800075ca:	a7 a8       	sbr	r8,0x6
800075cc:	aa b8       	st.b	r5[0x3],r8
800075ce:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// Move each of the bits in either A or M one place to the left.
// Bit 0 is filled with the current value of the carry flag whilst the old bit 7 becomes the new carry flag value.
static void cpu_ROL(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"ROL\n");
	Word result = cpu1->accumulator << 1;
800075d2:	09 ea       	ld.ub	r10,r4[0x6]
		cpu1->status &= MASK_STATUS_CARRY_OFF;
	}
}
static Bool cpu_getCarry(CPU cpu1) {
	//assert(cpu1 != NULL);
	if ((cpu1->status & MASK_STATUS_CARRY_ON) == MASK_STATUS_CARRY_ON) {
800075d4:	09 b8       	ld.ub	r8,r4[0x3]
// Move each of the bits in either A or M one place to the left.
// Bit 0 is filled with the current value of the carry flag whilst the old bit 7 becomes the new carry flag value.
static void cpu_ROL(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"ROL\n");
	Word result = cpu1->accumulator << 1;
800075d6:	f4 09 15 01 	lsl	r9,r10,0x1
		cpu1->status &= MASK_STATUS_CARRY_OFF;
	}
}
static Bool cpu_getCarry(CPU cpu1) {
	//assert(cpu1 != NULL);
	if ((cpu1->status & MASK_STATUS_CARRY_ON) == MASK_STATUS_CARRY_ON) {
800075da:	ed b8 00 00 	bld	r8,0x0
800075de:	c0 21       	brne	800075e2 <cpu_step+0xc16>
static void cpu_ROL(CPU cpu1) {
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"ROL\n");
	Word result = cpu1->accumulator << 1;
	if (cpu_getCarry(cpu1) == TRUE) {
		result |= MASK_BIT0;
800075e0:	a1 a9       	sbr	r9,0x0
	}
	if ( (cpu1->accumulator & MASK_BIT7) == MASK_BIT7) {
800075e2:	30 0b       	mov	r11,0
800075e4:	f6 0a 18 00 	cp.b	r10,r11
800075e8:	e0 85 02 1d 	brlt	80007a22 <cpu_step+0x1056>
static void cpu_setCarry(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_CARRY_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_CARRY_OFF;
800075ec:	a1 c8       	cbr	r8,0x0
800075ee:	a8 b8       	st.b	r4[0x3],r8
		cpu_setCarry(cpu1, TRUE);
		} else {
		cpu_setCarry(cpu1, FALSE);
	}
	// Z Zero Flag       Set if A = 0
	cpu1->accumulator = result;
800075f0:	5c 59       	castu.b	r9
800075f2:	a8 e9       	st.b	r4[0x6],r9
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
800075f4:	e0 81 01 59 	brne	800078a6 <cpu_step+0xeda>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
800075f8:	09 b8       	ld.ub	r8,r4[0x3]
800075fa:	a1 b8       	sbr	r8,0x1
800075fc:	a8 b8       	st.b	r4[0x3],r8
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
800075fe:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
80007602:	a8 b8       	st.b	r4[0x3],r8
80007604:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		case STY_ZPAGEX:
		case STY_ABS:
		cpu_STY(nes, address);
		break;
		case AND_INDY: cpu_AND(nes, address); break;
		case AND_IMM: cpu_AND(nes, address); break;
80007608:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
8000760c:	0e 9c       	mov	r12,r7
8000760e:	fe b0 f8 b7 	rcall	8000677c <cpu_AND>
80007612:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// ADC - Add with Carry
// This instruction adds the contents of a memory location to the accumulator together with the carry bit.
// If overflow occurs the carry bit is set, this enables multiple byte addition to be performed.
static void cpu_ADC(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80007616:	0e 9c       	mov	r12,r7
80007618:	e0 a0 06 64 	rcall	800082e0 <nes_getCPU>
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"ADC\n");
	// A + M + C
	Byte data = nes_readCPUMemory(nes, address);
8000761c:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
// ADC - Add with Carry
// This instruction adds the contents of a memory location to the accumulator together with the carry bit.
// If overflow occurs the carry bit is set, this enables multiple byte addition to be performed.
static void cpu_ADC(NES nes, Address address) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
80007620:	18 95       	mov	r5,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"ADC\n");
	// A + M + C
	Byte data = nes_readCPUMemory(nes, address);
80007622:	0e 9c       	mov	r12,r7
80007624:	e0 a0 07 6e 	rcall	80008500 <nes_readCPUMemory>
	Word result = cpu1->accumulator + data;
80007628:	0b e8       	ld.ub	r8,r5[0x6]
		cpu1->status &= MASK_STATUS_CARRY_OFF;
	}
}
static Bool cpu_getCarry(CPU cpu1) {
	//assert(cpu1 != NULL);
	if ((cpu1->status & MASK_STATUS_CARRY_ON) == MASK_STATUS_CARRY_ON) {
8000762a:	0b ba       	ld.ub	r10,r5[0x3]
	CPU cpu1 = nes_getCPU(nes);
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"ADC\n");
	// A + M + C
	Byte data = nes_readCPUMemory(nes, address);
	Word result = cpu1->accumulator + data;
8000762c:	18 08       	add	r8,r12
8000762e:	5c 88       	casts.h	r8
		cpu1->status &= MASK_STATUS_CARRY_OFF;
	}
}
static Bool cpu_getCarry(CPU cpu1) {
	//assert(cpu1 != NULL);
	if ((cpu1->status & MASK_STATUS_CARRY_ON) == MASK_STATUS_CARRY_ON) {
80007630:	ed ba 00 00 	bld	r10,0x0
80007634:	c0 31       	brne	8000763a <cpu_step+0xc6e>
	//usart_write_line(&AVR32_USART0,"ADC\n");
	// A + M + C
	Byte data = nes_readCPUMemory(nes, address);
	Word result = cpu1->accumulator + data;
	if (cpu_getCarry(cpu1) == TRUE) {
		result++;
80007636:	2f f8       	sub	r8,-1
80007638:	5c 88       	casts.h	r8
	}
	// C  Carry Flag     Set if overflow in bit 7
	if ((result & MASK_BIT8) == MASK_BIT8) {
8000763a:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
8000763e:	ed b9 00 08 	bld	r9,0x8
80007642:	c6 01       	brne	80007702 <cpu_step+0xd36>
	}
}
static void cpu_setCarry(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_CARRY_ON;
80007644:	a1 aa       	sbr	r10,0x0
80007646:	aa ba       	st.b	r5[0x3],r10
		} else {
		cpu_setCarry(cpu1, FALSE);
	}
	// V Overflow Flag   Set if sign bit is incorrect
	// based on http://nesdev.parodius.com/6502.txt
	if (((cpu1->accumulator ^ result) & 0x80) && !((cpu1->accumulator ^ data) & 0x80)) {
80007648:	0b eb       	ld.ub	r11,r5[0x6]
8000764a:	16 59       	eor	r9,r11
8000764c:	ed b9 00 07 	bld	r9,0x7
80007650:	c3 21       	brne	800076b4 <cpu_step+0xce8>
80007652:	f9 eb 20 0b 	eor	r11,r12,r11
80007656:	30 09       	mov	r9,0
80007658:	f2 0b 18 00 	cp.b	r11,r9
8000765c:	c2 c5       	brlt	800076b4 <cpu_step+0xce8>
	cpu_updateNegative(cpu1, cpu1->accumulator);
}
static void cpu_setOverflow(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_OVERFLOW_ON;
8000765e:	a7 aa       	sbr	r10,0x6
80007660:	aa ba       	st.b	r5[0x3],r10
	if (((cpu1->accumulator ^ result) & 0x80) && !((cpu1->accumulator ^ data) & 0x80)) {
		cpu_setOverflow(cpu1, TRUE);
		} else {
		cpu_setOverflow(cpu1, FALSE);
	}
	cpu1->accumulator = result;
80007662:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80007666:	aa e9       	st.b	r5[0x6],r9
	}
}
//Z     Zero Flag      Set if A = 0
static inline void cpu_updateZero(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if (data == 0) {
80007668:	c3 e1       	brne	800076e4 <cpu_step+0xd18>
	}
}
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
8000766a:	0b b8       	ld.ub	r8,r5[0x3]
8000766c:	a1 b8       	sbr	r8,0x1
8000766e:	aa b8       	st.b	r5[0x3],r8
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_NEGATIVE_OFF;
80007670:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
80007674:	aa b8       	st.b	r5[0x3],r8
80007676:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
// RTS - Return from Subroutine
// The RTS instruction is used at the end of a subroutine to return to the calling routine.
// It pulls the program counter (minus one) from the stack.
static void cpu_RTS(NES nes) {
	//assert(nes != NULL);
	CPU cpu1 = nes_getCPU(nes);
8000767a:	0e 9c       	mov	r12,r7
8000767c:	e0 a0 06 32 	rcall	800082e0 <nes_getCPU>
80007680:	18 96       	mov	r6,r12
	//assert(cpu1 != NULL);
	//usart_write_line(&AVR32_USART0,"RTS\n");
	// waste a cycle for the stack pointer increment that is about to happen in popStack
	//nes_cpuCycled(nes);
	Address address = cpu_popStack(nes);
80007682:	0e 9c       	mov	r12,r7
80007684:	fe b0 f8 f8 	rcall	80006874 <cpu_popStack>
80007688:	18 95       	mov	r5,r12
	address += cpu_popStack(nes) << BITS_PER_BYTE;
8000768a:	0e 9c       	mov	r12,r7
8000768c:	2f f5       	sub	r5,-1
8000768e:	fe b0 f8 f3 	rcall	80006874 <cpu_popStack>
	// waste a cycle to increment the program counter
	//nes_cpuCycled(nes);
	address++;
	cpu1->programCounter = address;
80007692:	a9 6c       	lsl	r12,0x8
80007694:	18 05       	add	r5,r12
80007696:	ac 05       	st.h	r6[0x0],r5
		case BRK:
		cpu_BRK(nes);
		break;
		case RTS:
		cpu_RTS(nes);
		break;
80007698:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
static void cpu_setInterruptDisable(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_INTERRUPT_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_INTERRUPT_OFF;
8000769c:	09 b8       	ld.ub	r8,r4[0x3]
8000769e:	a3 c8       	cbr	r8,0x2
800076a0:	a8 b8       	st.b	r4[0x3],r8
		case SEI:
		cpu_SEI(cpu1);
		break;
		case CLI:
		cpu_CLI(cpu1);
		break;
800076a2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		cpu_ORA(nes, address);
		break;
		case EOR_INDY: cpu_EOR(nes, address); break;
		case EOR_IMM:  cpu_EOR(nes, address); break;
		case EOR_ZPAGE:  cpu_EOR(nes, address); break;
		case EOR_ZPAGEX:  cpu_EOR(nes, address); break;
800076a6:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800076aa:	0e 9c       	mov	r12,r7
800076ac:	fe b0 f8 ba 	rcall	80006820 <cpu_EOR>
800076b0:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
static void cpu_setOverflow(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_OVERFLOW_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_OVERFLOW_OFF;
800076b4:	a7 ca       	cbr	r10,0x6
800076b6:	aa ba       	st.b	r5[0x3],r10
800076b8:	cd 5b       	rjmp	80007662 <cpu_step+0xc96>
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
800076ba:	e2 18 00 fd 	andl	r8,0xfd,COH
800076be:	ac b8       	st.b	r6[0x3],r8
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
800076c0:	30 09       	mov	r9,0
800076c2:	f2 0a 18 00 	cp.b	r10,r9
800076c6:	fe 94 fd f2 	brge	800072aa <cpu_step+0x8de>
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
800076ca:	ea 18 ff ff 	orh	r8,0xffff
800076ce:	e8 18 ff 80 	orl	r8,0xff80
800076d2:	ac b8       	st.b	r6[0x3],r8
800076d4:	fe 9f fd ee 	bral	800072b0 <cpu_step+0x8e4>
static void cpu_setCarry(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_CARRY_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_CARRY_OFF;
800076d8:	0d b8       	ld.ub	r8,r6[0x3]
800076da:	e2 18 00 fe 	andl	r8,0xfe,COH
800076de:	ac b8       	st.b	r6[0x3],r8
800076e0:	fe 9f fd e0 	bral	800072a0 <cpu_step+0x8d4>
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
800076e4:	0b b8       	ld.ub	r8,r5[0x3]
800076e6:	e2 18 00 fd 	andl	r8,0xfd,COH
800076ea:	aa b8       	st.b	r5[0x3],r8
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
800076ec:	30 0a       	mov	r10,0
800076ee:	f4 09 18 00 	cp.b	r9,r10
800076f2:	cb f4       	brge	80007670 <cpu_step+0xca4>
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
800076f4:	ea 18 ff ff 	orh	r8,0xffff
800076f8:	e8 18 ff 80 	orl	r8,0xff80
800076fc:	aa b8       	st.b	r5[0x3],r8
800076fe:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
static void cpu_setCarry(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_CARRY_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_CARRY_OFF;
80007702:	e2 1a 00 fe 	andl	r10,0xfe,COH
80007706:	aa ba       	st.b	r5[0x3],r10
80007708:	ca 0b       	rjmp	80007648 <cpu_step+0xc7c>
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
8000770a:	09 b8       	ld.ub	r8,r4[0x3]
8000770c:	e2 18 00 fd 	andl	r8,0xfd,COH
80007710:	a8 b8       	st.b	r4[0x3],r8
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
80007712:	30 0a       	mov	r10,0
80007714:	f4 09 18 00 	cp.b	r9,r10
80007718:	fe 94 fc cb 	brge	800070ae <cpu_step+0x6e2>
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
8000771c:	ea 18 ff ff 	orh	r8,0xffff
80007720:	e8 18 ff 80 	orl	r8,0xff80
80007724:	a8 b8       	st.b	r4[0x3],r8
80007726:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
8000772a:	0d b8       	ld.ub	r8,r6[0x3]
8000772c:	e2 18 00 fd 	andl	r8,0xfd,COH
80007730:	ac b8       	st.b	r6[0x3],r8
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
80007732:	30 09       	mov	r9,0
80007734:	f2 0c 18 00 	cp.b	r12,r9
80007738:	fe 94 fd 26 	brge	80007184 <cpu_step+0x7b8>
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
8000773c:	ea 18 ff ff 	orh	r8,0xffff
80007740:	e8 18 ff 80 	orl	r8,0xff80
80007744:	ac b8       	st.b	r6[0x3],r8
80007746:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
8000774a:	09 b8       	ld.ub	r8,r4[0x3]
8000774c:	e2 18 00 fd 	andl	r8,0xfd,COH
80007750:	a8 b8       	st.b	r4[0x3],r8
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
80007752:	30 0a       	mov	r10,0
80007754:	f4 09 18 00 	cp.b	r9,r10
80007758:	fe 94 fc 44 	brge	80006fe0 <cpu_step+0x614>
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
8000775c:	ea 18 ff ff 	orh	r8,0xffff
80007760:	e8 18 ff 80 	orl	r8,0xff80
80007764:	a8 b8       	st.b	r4[0x3],r8
80007766:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
8000776a:	09 b8       	ld.ub	r8,r4[0x3]
8000776c:	e2 18 00 fd 	andl	r8,0xfd,COH
80007770:	a8 b8       	st.b	r4[0x3],r8
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
80007772:	30 0a       	mov	r10,0
80007774:	f4 09 18 00 	cp.b	r9,r10
80007778:	fe 94 fc 8d 	brge	80007092 <cpu_step+0x6c6>
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
8000777c:	ea 18 ff ff 	orh	r8,0xffff
80007780:	e8 18 ff 80 	orl	r8,0xff80
80007784:	a8 b8       	st.b	r4[0x3],r8
80007786:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
8000778a:	09 b8       	ld.ub	r8,r4[0x3]
8000778c:	e2 18 00 fd 	andl	r8,0xfd,COH
80007790:	a8 b8       	st.b	r4[0x3],r8
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
80007792:	30 0a       	mov	r10,0
80007794:	f4 09 18 00 	cp.b	r9,r10
80007798:	fe 94 fc cb 	brge	8000712e <cpu_step+0x762>
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
8000779c:	ea 18 ff ff 	orh	r8,0xffff
800077a0:	e8 18 ff 80 	orl	r8,0xff80
800077a4:	a8 b8       	st.b	r4[0x3],r8
800077a6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
static void cpu_setCarry(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_CARRY_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_CARRY_OFF;
800077aa:	a1 c8       	cbr	r8,0x0
800077ac:	a8 b8       	st.b	r4[0x3],r8
800077ae:	fe 9f fc b9 	bral	80007120 <cpu_step+0x754>
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
800077b2:	09 b8       	ld.ub	r8,r4[0x3]
800077b4:	e2 18 00 fd 	andl	r8,0xfd,COH
800077b8:	a8 b8       	st.b	r4[0x3],r8
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
800077ba:	30 0a       	mov	r10,0
800077bc:	f4 09 18 00 	cp.b	r9,r10
800077c0:	fe 94 fb 6a 	brge	80006e94 <cpu_step+0x4c8>
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
800077c4:	ea 18 ff ff 	orh	r8,0xffff
800077c8:	e8 18 ff 80 	orl	r8,0xff80
800077cc:	a8 b8       	st.b	r4[0x3],r8
800077ce:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
800077d2:	09 b8       	ld.ub	r8,r4[0x3]
800077d4:	e2 18 00 fd 	andl	r8,0xfd,COH
800077d8:	a8 b8       	st.b	r4[0x3],r8
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
800077da:	30 0a       	mov	r10,0
800077dc:	f4 09 18 00 	cp.b	r9,r10
800077e0:	fe 94 fb 83 	brge	80006ee6 <cpu_step+0x51a>
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
800077e4:	ea 18 ff ff 	orh	r8,0xffff
800077e8:	e8 18 ff 80 	orl	r8,0xff80
800077ec:	a8 b8       	st.b	r4[0x3],r8
800077ee:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
800077f2:	09 b8       	ld.ub	r8,r4[0x3]
800077f4:	e2 18 00 fd 	andl	r8,0xfd,COH
800077f8:	a8 b8       	st.b	r4[0x3],r8
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
800077fa:	30 0a       	mov	r10,0
800077fc:	f4 09 18 00 	cp.b	r9,r10
80007800:	fe 94 fb 95 	brge	80006f2a <cpu_step+0x55e>
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
80007804:	ea 18 ff ff 	orh	r8,0xffff
80007808:	e8 18 ff 80 	orl	r8,0xff80
8000780c:	a8 b8       	st.b	r4[0x3],r8
8000780e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
80007812:	e2 18 00 fd 	andl	r8,0xfd,COH
80007816:	ac b8       	st.b	r6[0x3],r8
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
80007818:	30 09       	mov	r9,0
8000781a:	f2 0a 18 00 	cp.b	r10,r9
8000781e:	fe 94 fd d5 	brge	800073c8 <cpu_step+0x9fc>
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
80007822:	ea 18 ff ff 	orh	r8,0xffff
80007826:	e8 18 ff 80 	orl	r8,0xff80
8000782a:	ac b8       	st.b	r6[0x3],r8
8000782c:	fe 9f fd d1 	bral	800073ce <cpu_step+0xa02>
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
80007830:	09 b8       	ld.ub	r8,r4[0x3]
80007832:	e2 18 00 fd 	andl	r8,0xfd,COH
80007836:	a8 b8       	st.b	r4[0x3],r8
80007838:	fe 9f fd 05 	bral	80007242 <cpu_step+0x876>
static void cpu_setCarry(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_CARRY_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_CARRY_OFF;
8000783c:	09 b9       	ld.ub	r9,r4[0x3]
8000783e:	a1 c9       	cbr	r9,0x0
80007840:	a8 b9       	st.b	r4[0x3],r9
80007842:	fe 9f fc f9 	bral	80007234 <cpu_step+0x868>
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
80007846:	09 b8       	ld.ub	r8,r4[0x3]
80007848:	e2 18 00 fd 	andl	r8,0xfd,COH
8000784c:	a8 b8       	st.b	r4[0x3],r8
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
8000784e:	30 0a       	mov	r10,0
80007850:	f4 09 18 00 	cp.b	r9,r10
80007854:	fe 94 fe 06 	brge	80007460 <cpu_step+0xa94>
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
80007858:	ea 18 ff ff 	orh	r8,0xffff
8000785c:	e8 18 ff 80 	orl	r8,0xff80
80007860:	a8 b8       	st.b	r4[0x3],r8
80007862:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
static void cpu_setOverflow(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_OVERFLOW_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_OVERFLOW_OFF;
80007866:	a7 c8       	cbr	r8,0x6
80007868:	aa b8       	st.b	r5[0x3],r8
8000786a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
8000786e:	a1 d8       	cbr	r8,0x1
80007870:	aa b8       	st.b	r5[0x3],r8
80007872:	fe 9f fc af 	bral	800071d0 <cpu_step+0x804>
static void cpu_setCarry(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_CARRY_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_CARRY_OFF;
80007876:	e2 18 00 fe 	andl	r8,0xfe,COH
8000787a:	aa b8       	st.b	r5[0x3],r8
8000787c:	fe 9f fc a5 	bral	800071c6 <cpu_step+0x7fa>
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
80007880:	e2 18 00 fd 	andl	r8,0xfd,COH
80007884:	ac b8       	st.b	r6[0x3],r8
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
80007886:	30 09       	mov	r9,0
80007888:	f2 0a 18 00 	cp.b	r10,r9
8000788c:	fe 94 fe 72 	brge	80007570 <cpu_step+0xba4>
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
80007890:	ea 18 ff ff 	orh	r8,0xffff
80007894:	e8 18 ff 80 	orl	r8,0xff80
80007898:	ac b8       	st.b	r6[0x3],r8
8000789a:	c6 ea       	rjmp	80007576 <cpu_step+0xbaa>
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
8000789c:	0b b8       	ld.ub	r8,r5[0x3]
8000789e:	e2 18 00 fd 	andl	r8,0xfd,COH
800078a2:	aa b8       	st.b	r5[0x3],r8
800078a4:	c8 7a       	rjmp	800075b2 <cpu_step+0xbe6>
800078a6:	09 b8       	ld.ub	r8,r4[0x3]
800078a8:	e2 18 00 fd 	andl	r8,0xfd,COH
800078ac:	a8 b8       	st.b	r4[0x3],r8
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
800078ae:	30 0a       	mov	r10,0
800078b0:	f4 09 18 00 	cp.b	r9,r10
800078b4:	fe 94 fe a5 	brge	800075fe <cpu_step+0xc32>
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
800078b8:	ea 18 ff ff 	orh	r8,0xffff
800078bc:	e8 18 ff 80 	orl	r8,0xff80
800078c0:	a8 b8       	st.b	r4[0x3],r8
800078c2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
800078c6:	09 b8       	ld.ub	r8,r4[0x3]
800078c8:	e2 18 00 fd 	andl	r8,0xfd,COH
800078cc:	a8 b8       	st.b	r4[0x3],r8
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
800078ce:	30 0a       	mov	r10,0
800078d0:	f4 09 18 00 	cp.b	r9,r10
800078d4:	fe 94 f9 a4 	brge	80006c1c <cpu_step+0x250>
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
800078d8:	ea 18 ff ff 	orh	r8,0xffff
800078dc:	e8 18 ff 80 	orl	r8,0xff80
800078e0:	a8 b8       	st.b	r4[0x3],r8
800078e2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
	}
}
static void cpu_setCarry(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_CARRY_ON;
800078e6:	a1 aa       	sbr	r10,0x0
800078e8:	aa ba       	st.b	r5[0x3],r10
800078ea:	fe 9f f9 d9 	bral	80006c9c <cpu_step+0x2d0>
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
800078ee:	0b b8       	ld.ub	r8,r5[0x3]
800078f0:	e2 18 00 fd 	andl	r8,0xfd,COH
800078f4:	aa b8       	st.b	r5[0x3],r8
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
800078f6:	30 09       	mov	r9,0
800078f8:	f2 0a 18 00 	cp.b	r10,r9
800078fc:	fe 94 f9 ac 	brge	80006c54 <cpu_step+0x288>
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
80007900:	ea 18 ff ff 	orh	r8,0xffff
80007904:	e8 18 ff 80 	orl	r8,0xff80
80007908:	aa b8       	st.b	r5[0x3],r8
8000790a:	fe 9f f9 a8 	bral	80006c5a <cpu_step+0x28e>
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
8000790e:	0b b8       	ld.ub	r8,r5[0x3]
80007910:	e2 18 00 fd 	andl	r8,0xfd,COH
80007914:	aa b8       	st.b	r5[0x3],r8
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
80007916:	30 0a       	mov	r10,0
80007918:	f4 09 18 00 	cp.b	r9,r10
8000791c:	fe 94 f9 d6 	brge	80006cc8 <cpu_step+0x2fc>
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
80007920:	ea 18 ff ff 	orh	r8,0xffff
80007924:	e8 18 ff 80 	orl	r8,0xff80
80007928:	aa b8       	st.b	r5[0x3],r8
8000792a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
8000792e:	e2 18 00 fd 	andl	r8,0xfd,COH
80007932:	aa b8       	st.b	r5[0x3],r8
80007934:	fe 9f f9 ee 	bral	80006d10 <cpu_step+0x344>
static void cpu_setCarry(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_CARRY_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_CARRY_OFF;
80007938:	0b b8       	ld.ub	r8,r5[0x3]
8000793a:	e2 18 00 fe 	andl	r8,0xfe,COH
8000793e:	aa b8       	st.b	r5[0x3],r8
80007940:	fe 9f f9 e2 	bral	80006d04 <cpu_step+0x338>
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
80007944:	09 b8       	ld.ub	r8,r4[0x3]
80007946:	e2 18 00 fd 	andl	r8,0xfd,COH
8000794a:	a8 b8       	st.b	r4[0x3],r8
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
8000794c:	30 0a       	mov	r10,0
8000794e:	f4 09 18 00 	cp.b	r9,r10
80007952:	fe 94 fa 15 	brge	80006d7c <cpu_step+0x3b0>
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
80007956:	ea 18 ff ff 	orh	r8,0xffff
8000795a:	e8 18 ff 80 	orl	r8,0xff80
8000795e:	a8 b8       	st.b	r4[0x3],r8
80007960:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
80007964:	0b b8       	ld.ub	r8,r5[0x3]
80007966:	e2 18 00 fd 	andl	r8,0xfd,COH
8000796a:	aa b8       	st.b	r5[0x3],r8
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
8000796c:	30 09       	mov	r9,0
8000796e:	f2 0a 18 00 	cp.b	r10,r9
80007972:	fe 94 fa 21 	brge	80006db4 <cpu_step+0x3e8>
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
80007976:	ea 18 ff ff 	orh	r8,0xffff
8000797a:	e8 18 ff 80 	orl	r8,0xff80
8000797e:	aa b8       	st.b	r5[0x3],r8
80007980:	fe 9f fa 1d 	bral	80006dba <cpu_step+0x3ee>
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
80007984:	e2 18 00 fd 	andl	r8,0xfd,COH
80007988:	aa b8       	st.b	r5[0x3],r8
8000798a:	fe 9f fa 5d 	bral	80006e44 <cpu_step+0x478>
static void cpu_setCarry(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_CARRY_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_CARRY_OFF;
8000798e:	0b b8       	ld.ub	r8,r5[0x3]
80007990:	e2 18 00 fe 	andl	r8,0xfe,COH
80007994:	aa b8       	st.b	r5[0x3],r8
80007996:	fe 9f fa 51 	bral	80006e38 <cpu_step+0x46c>
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
8000799a:	09 b8       	ld.ub	r8,r4[0x3]
8000799c:	e2 18 00 fd 	andl	r8,0xfd,COH
800079a0:	a8 b8       	st.b	r4[0x3],r8
	}
}
//N     Negative Flag Set if bit 7 of A is set
static void cpu_updateNegative(CPU cpu1, Byte data) {
	//assert(cpu1 != NULL);
	if ((data & MASK_BIT7) == MASK_BIT7) {
800079a2:	30 0a       	mov	r10,0
800079a4:	f4 09 18 00 	cp.b	r9,r10
800079a8:	fe 94 f9 dc 	brge	80006d60 <cpu_step+0x394>
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
800079ac:	ea 18 ff ff 	orh	r8,0xffff
800079b0:	e8 18 ff 80 	orl	r8,0xff80
800079b4:	a8 b8       	st.b	r4[0x3],r8
800079b6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
static inline void cpu_setZero(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_ZERO_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_ZERO_OFF;
800079ba:	e2 18 00 fd 	andl	r8,0xfd,COH
800079be:	aa b8       	st.b	r5[0x3],r8
800079c0:	fe 9f fa 1d 	bral	80006dfa <cpu_step+0x42e>
static void cpu_setCarry(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_CARRY_ON;
		} else if (state == FALSE) {
		cpu1->status &= MASK_STATUS_CARRY_OFF;
800079c4:	0b b8       	ld.ub	r8,r5[0x3]
800079c6:	e2 18 00 fe 	andl	r8,0xfe,COH
800079ca:	aa b8       	st.b	r5[0x3],r8
800079cc:	fe 9f fa 11 	bral	80006dee <cpu_step+0x422>
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
800079d0:	ea 18 ff ff 	orh	r8,0xffff
800079d4:	e8 18 ff 80 	orl	r8,0xff80
800079d8:	aa b8       	st.b	r5[0x3],r8
800079da:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800079de:	ea 18 ff ff 	orh	r8,0xffff
800079e2:	e8 18 ff 80 	orl	r8,0xff80
800079e6:	aa b8       	st.b	r5[0x3],r8
800079e8:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
	}
}
static void cpu_setCarry(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_CARRY_ON;
800079ec:	09 b9       	ld.ub	r9,r4[0x3]
800079ee:	a1 a9       	sbr	r9,0x0
800079f0:	a8 b9       	st.b	r4[0x3],r9
800079f2:	fe 9f fd 2e 	bral	8000744e <cpu_step+0xa82>
800079f6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
800079fa:	ea 18 ff ff 	orh	r8,0xffff
800079fe:	e8 18 ff 80 	orl	r8,0xff80
80007a02:	aa b8       	st.b	r5[0x3],r8
80007a04:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
	}
}
static void cpu_setCarry(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_CARRY_ON;
80007a08:	0d b8       	ld.ub	r8,r6[0x3]
80007a0a:	a1 a8       	sbr	r8,0x0
80007a0c:	ac b8       	st.b	r6[0x3],r8
80007a0e:	fe 9f fc d6 	bral	800073ba <cpu_step+0x9ee>
80007a12:	a1 a8       	sbr	r8,0x0
80007a14:	ac b8       	st.b	r6[0x3],r8
80007a16:	fe 9f fd a8 	bral	80007566 <cpu_step+0xb9a>
	}
}
static void cpu_setNegative(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_NEGATIVE_ON;
80007a1a:	a7 b8       	sbr	r8,0x7
80007a1c:	aa b8       	st.b	r5[0x3],r8
80007a1e:	fe 9f fd d2 	bral	800075c2 <cpu_step+0xbf6>
	}
}
static void cpu_setCarry(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_CARRY_ON;
80007a22:	a1 a8       	sbr	r8,0x0
80007a24:	a8 b8       	st.b	r4[0x3],r8
80007a26:	fe 9f fd e5 	bral	800075f0 <cpu_step+0xc24>
	cpu_updateNegative(cpu1, cpu1->accumulator);
}
static void cpu_setOverflow(CPU cpu1, Bool state) {
	//assert(cpu1 != NULL);
	if (state == TRUE) {
		cpu1->status |= MASK_STATUS_OVERFLOW_ON;
80007a2a:	a7 aa       	sbr	r10,0x6
80007a2c:	aa ba       	st.b	r5[0x3],r10
80007a2e:	fe 9f f9 45 	bral	80006cb8 <cpu_step+0x2ec>
80007a32:	d7 03       	nop
80007a34:	80 01       	ld.sh	r1,r0[0x0]
80007a36:	74 84       	ld.w	r4,r10[0x20]
80007a38:	80 01       	ld.sh	r1,r0[0x0]
80007a3a:	78 84       	ld.w	r4,r12[0x20]

80007a3c <cpuMemory_ppuStatusRegister_writer>:
}
static void cpuMemory_ppuStatusRegister_writer(NES nes, Address address, Byte data) {
  //assert(nes != NULL);
  // not allowed to write this
  //assert(FALSE);
}
80007a3c:	5e fc       	retal	r12

80007a3e <cpuMemory_spriteDMARegister_reader>:
// #define CPU_SPRITE_DMA_REGISTER_ADDRESS                 0x4014 // write
#define CPU_DMA_ADDRESS_MULTIPLIER 0x0100
static Byte cpuMemory_spriteDMARegister_reader(NES nes, Address address) {
  //assert(nes != NULL);
  return 0;
}
80007a3e:	5e fd       	retal	0

80007a40 <cpuMemory_init>:
  //assert(currentJoypad >= 0);
  //assert(currentJoypad <= 3);
  nes_writeJoypad(nes, currentJoypad, data);
}

Memory cpuMemory_init(void) {
80007a40:	eb cd 40 c0 	pushm	r6-r7,lr
	usart_write_line(&AVR32_USART0,"CPU22");
80007a44:	4e bb       	lddpc	r11,80007bf0 <cpuMemory_init+0x1b0>
80007a46:	fe 7c 14 00 	mov	r12,-60416
80007a4a:	e0 a0 21 a4 	rcall	8000bd92 <usart_write_line>
  Memory memory1 = memory_init(CPU_TOTAL_MEMORY_ADDRESSES);
80007a4e:	e0 7c 00 00 	mov	r12,65536
80007a52:	e0 a0 02 d7 	rcall	80008000 <memory_init>
  //Memory memory1 = memory_init(0xFFFF);
  //assert(memory1 != NULL);
  usart_write_line(&AVR32_USART0,"CPU221");
80007a56:	4e 8b       	lddpc	r11,80007bf4 <cpuMemory_init+0x1b4>
  nes_writeJoypad(nes, currentJoypad, data);
}

Memory cpuMemory_init(void) {
	usart_write_line(&AVR32_USART0,"CPU22");
  Memory memory1 = memory_init(CPU_TOTAL_MEMORY_ADDRESSES);
80007a58:	18 96       	mov	r6,r12
  //Memory memory1 = memory_init(0xFFFF);
  //assert(memory1 != NULL);
  usart_write_line(&AVR32_USART0,"CPU221");
80007a5a:	fe 7c 14 00 	mov	r12,-60416
80007a5e:	e0 a0 21 9a 	rcall	8000bd92 <usart_write_line>
80007a62:	e0 67 08 00 	mov	r7,2048
  int address;
  //for (address=CPU_FIRST_RAM_MIRRORED_ADDRESS; address <=CPU_LAST_RAM_MIRRORED_ADDRESS; address++) {
	  
  for (address=CPU_RAM_MIRROR_FIRST_ADDRESS; address <= CPU_RAM_MIRROR_LAST_ADDRESS; address++) {
    memory_setWriteCallback(memory1, address, &cpuMemory_ramMirror_writer);
80007a66:	0e 9b       	mov	r11,r7
80007a68:	fe ca fd 58 	sub	r10,pc,-680
80007a6c:	0c 9c       	mov	r12,r6
80007a6e:	e0 a0 02 a0 	rcall	80007fae <memory_setWriteCallback>
    memory_setReadCallback(memory1, address, &cpuMemory_ramMirror_reader);
80007a72:	0e 9b       	mov	r11,r7
  //assert(memory1 != NULL);
  usart_write_line(&AVR32_USART0,"CPU221");
  int address;
  //for (address=CPU_FIRST_RAM_MIRRORED_ADDRESS; address <=CPU_LAST_RAM_MIRRORED_ADDRESS; address++) {
	  
  for (address=CPU_RAM_MIRROR_FIRST_ADDRESS; address <= CPU_RAM_MIRROR_LAST_ADDRESS; address++) {
80007a74:	fe ca fe 14 	sub	r10,pc,-492
    memory_setWriteCallback(memory1, address, &cpuMemory_ramMirror_writer);
    memory_setReadCallback(memory1, address, &cpuMemory_ramMirror_reader);
80007a78:	2f f7       	sub	r7,-1
80007a7a:	0c 9c       	mov	r12,r6
  //assert(memory1 != NULL);
  usart_write_line(&AVR32_USART0,"CPU221");
  int address;
  //for (address=CPU_FIRST_RAM_MIRRORED_ADDRESS; address <=CPU_LAST_RAM_MIRRORED_ADDRESS; address++) {
	  
  for (address=CPU_RAM_MIRROR_FIRST_ADDRESS; address <= CPU_RAM_MIRROR_LAST_ADDRESS; address++) {
80007a7c:	e0 a0 02 9e 	rcall	80007fb8 <memory_setReadCallback>
80007a80:	e0 47 20 00 	cp.w	r7,8192
    memory_setWriteCallback(memory1, address, &cpuMemory_ramMirror_writer);
    memory_setReadCallback(memory1, address, &cpuMemory_ramMirror_reader);
  }
  usart_write_line(&AVR32_USART0,"CPU2");
80007a84:	cf 11       	brne	80007a66 <cpuMemory_init+0x26>
80007a86:	4d db       	lddpc	r11,80007bf8 <cpuMemory_init+0x1b8>
80007a88:	fe 7c 14 00 	mov	r12,-60416
  // setup the ppu register redirectors
  
  memory_setReadCallback(memory1, CPU_PPU_CONTROL_REGISTER_ADDRESS, &cpuMemory_ppuControlRegister_reader);
80007a8c:	e0 a0 21 83 	rcall	8000bd92 <usart_write_line>
80007a90:	0e 9b       	mov	r11,r7
80007a92:	fe ca fc 5a 	sub	r10,pc,-934
  memory_setWriteCallback(memory1, CPU_PPU_CONTROL_REGISTER_ADDRESS, &cpuMemory_ppuControlRegister_writer);
80007a96:	0c 9c       	mov	r12,r6
80007a98:	e0 a0 02 90 	rcall	80007fb8 <memory_setReadCallback>
80007a9c:	0e 9b       	mov	r11,r7
80007a9e:	fe ca fc 7a 	sub	r10,pc,-902
  memory_setReadCallback(memory1, CPU_PPU_MASK_REGISTER_ADDRESS, &cpuMemory_ppuMaskRegister_reader);
80007aa2:	0c 9c       	mov	r12,r6
80007aa4:	e0 a0 02 85 	rcall	80007fae <memory_setWriteCallback>
80007aa8:	fe ca fc 90 	sub	r10,pc,-880
  memory_setWriteCallback(memory1, CPU_PPU_MASK_REGISTER_ADDRESS,&cpuMemory_ppuMaskRegister_writer);
80007aac:	e0 6b 20 01 	mov	r11,8193
80007ab0:	0c 9c       	mov	r12,r6
80007ab2:	e0 a0 02 83 	rcall	80007fb8 <memory_setReadCallback>
80007ab6:	fe ca fc b2 	sub	r10,pc,-846
  memory_setReadCallback(memory1, CPU_PPU_STATUS_REGISTER_ADDRESS,&cpuMemory_ppuStatusRegister_reader);
80007aba:	e0 6b 20 01 	mov	r11,8193
80007abe:	0c 9c       	mov	r12,r6
80007ac0:	e0 a0 02 77 	rcall	80007fae <memory_setWriteCallback>
  memory_setWriteCallback(memory1, CPU_PPU_STATUS_REGISTER_ADDRESS,&cpuMemory_ppuStatusRegister_writer);
80007ac4:	fe ca fc cc 	sub	r10,pc,-820
80007ac8:	e0 6b 20 02 	mov	r11,8194
80007acc:	0c 9c       	mov	r12,r6
80007ace:	e0 a0 02 75 	rcall	80007fb8 <memory_setReadCallback>
  memory_setReadCallback(memory1, CPU_PPU_SPRITE_ADDRESS_REGISTER_ADDRESS,&cpuMemory_ppuSpriteAddressRegister_reader);
80007ad2:	fe ca 00 96 	sub	r10,pc,150
80007ad6:	e0 6b 20 02 	mov	r11,8194
80007ada:	0c 9c       	mov	r12,r6
  memory_setWriteCallback(memory1, CPU_PPU_SPRITE_ADDRESS_REGISTER_ADDRESS,&cpuMemory_ppuSpriteAddressRegister_writer);
80007adc:	e0 a0 02 69 	rcall	80007fae <memory_setWriteCallback>
80007ae0:	fe ca fc f4 	sub	r10,pc,-780
80007ae4:	e0 6b 20 03 	mov	r11,8195
  memory_setReadCallback(memory1, CPU_PPU_SPRITE_DATA_REGISTER_ADDRESS,&cpuMemory_ppuSpriteDataRegister_reader);
80007ae8:	0c 9c       	mov	r12,r6
80007aea:	e0 a0 02 67 	rcall	80007fb8 <memory_setReadCallback>
80007aee:	fe ca fd 16 	sub	r10,pc,-746
80007af2:	e0 6b 20 03 	mov	r11,8195
  memory_setWriteCallback(memory1, CPU_PPU_SPRITE_DATA_REGISTER_ADDRESS,&cpuMemory_ppuSpriteDataRegister_writer);
80007af6:	0c 9c       	mov	r12,r6
80007af8:	e0 a0 02 5b 	rcall	80007fae <memory_setWriteCallback>
80007afc:	fe ca fd 38 	sub	r10,pc,-712
  memory_setReadCallback(memory1, CPU_PPU_SCROLL_REGISTER_ADDRESS,&cpuMemory_ppuScrollRegister_reader);
80007b00:	e0 6b 20 04 	mov	r11,8196
80007b04:	0c 9c       	mov	r12,r6
80007b06:	e0 a0 02 59 	rcall	80007fb8 <memory_setReadCallback>
80007b0a:	fe ca fd 5e 	sub	r10,pc,-674
  memory_setWriteCallback(memory1, CPU_PPU_SCROLL_REGISTER_ADDRESS,&cpuMemory_ppuScrollRegister_writer);
80007b0e:	e0 6b 20 04 	mov	r11,8196
80007b12:	0c 9c       	mov	r12,r6
80007b14:	e0 a0 02 4d 	rcall	80007fae <memory_setWriteCallback>
  memory_setReadCallback(memory1, CPU_PPUMEMORY_ADDRESS_REGISTER_ADDRESS,&cpuMemory_ppuMemoryAddressRegister_reader);
80007b18:	fe ca fd 78 	sub	r10,pc,-648
80007b1c:	e0 6b 20 05 	mov	r11,8197
80007b20:	0c 9c       	mov	r12,r6
80007b22:	e0 a0 02 4b 	rcall	80007fb8 <memory_setReadCallback>
  memory_setWriteCallback(memory1, CPU_PPUMEMORY_ADDRESS_REGISTER_ADDRESS,&cpuMemory_ppuMemoryAddressRegister_writer);
80007b26:	fe ca fd 9a 	sub	r10,pc,-614
80007b2a:	e0 6b 20 05 	mov	r11,8197
80007b2e:	0c 9c       	mov	r12,r6
  memory_setReadCallback(memory1, CPU_PPUMEMORY_DATA_REGISTER_ADDRESS,&cpuMemory_ppuMemoryDataRegister_reader);
80007b30:	e0 a0 02 3f 	rcall	80007fae <memory_setWriteCallback>
80007b34:	fe ca fd b4 	sub	r10,pc,-588
80007b38:	e0 6b 20 06 	mov	r11,8198
  memory_setWriteCallback(memory1, CPU_PPUMEMORY_DATA_REGISTER_ADDRESS,&cpuMemory_ppuMemoryDataRegister_writer);
80007b3c:	0c 9c       	mov	r12,r6
80007b3e:	e0 a0 02 3d 	rcall	80007fb8 <memory_setReadCallback>
80007b42:	fe ca fd d6 	sub	r10,pc,-554
80007b46:	e0 6b 20 06 	mov	r11,8198
80007b4a:	0c 9c       	mov	r12,r6
  // now setup their mirrors
  for (address=CPU_PPU_MIRROR_FIRST_ADDRESS; address <= CPU_PPU_MIRROR_LAST_ADDRESS; address++) {
    memory_setWriteCallback(memory1, address, &cpuMemory_ppuMirror_writer);
80007b4c:	e0 a0 02 31 	rcall	80007fae <memory_setWriteCallback>
80007b50:	fe ca fd f8 	sub	r10,pc,-520
80007b54:	e0 6b 20 07 	mov	r11,8199
    memory_setReadCallback(memory1, address, &cpuMemory_ppuMirror_reader);
80007b58:	0c 9c       	mov	r12,r6
  memory_setReadCallback(memory1, CPU_PPUMEMORY_ADDRESS_REGISTER_ADDRESS,&cpuMemory_ppuMemoryAddressRegister_reader);
  memory_setWriteCallback(memory1, CPU_PPUMEMORY_ADDRESS_REGISTER_ADDRESS,&cpuMemory_ppuMemoryAddressRegister_writer);
  memory_setReadCallback(memory1, CPU_PPUMEMORY_DATA_REGISTER_ADDRESS,&cpuMemory_ppuMemoryDataRegister_reader);
  memory_setWriteCallback(memory1, CPU_PPUMEMORY_DATA_REGISTER_ADDRESS,&cpuMemory_ppuMemoryDataRegister_writer);
  // now setup their mirrors
  for (address=CPU_PPU_MIRROR_FIRST_ADDRESS; address <= CPU_PPU_MIRROR_LAST_ADDRESS; address++) {
80007b5a:	e0 a0 02 2f 	rcall	80007fb8 <memory_setReadCallback>
    memory_setWriteCallback(memory1, address, &cpuMemory_ppuMirror_writer);
    memory_setReadCallback(memory1, address, &cpuMemory_ppuMirror_reader);
80007b5e:	fe ca fe 1e 	sub	r10,pc,-482
  memory_setReadCallback(memory1, CPU_PPUMEMORY_ADDRESS_REGISTER_ADDRESS,&cpuMemory_ppuMemoryAddressRegister_reader);
  memory_setWriteCallback(memory1, CPU_PPUMEMORY_ADDRESS_REGISTER_ADDRESS,&cpuMemory_ppuMemoryAddressRegister_writer);
  memory_setReadCallback(memory1, CPU_PPUMEMORY_DATA_REGISTER_ADDRESS,&cpuMemory_ppuMemoryDataRegister_reader);
  memory_setWriteCallback(memory1, CPU_PPUMEMORY_DATA_REGISTER_ADDRESS,&cpuMemory_ppuMemoryDataRegister_writer);
  // now setup their mirrors
  for (address=CPU_PPU_MIRROR_FIRST_ADDRESS; address <= CPU_PPU_MIRROR_LAST_ADDRESS; address++) {
80007b62:	e0 6b 20 07 	mov	r11,8199
80007b66:	0c 9c       	mov	r12,r6
    memory_setWriteCallback(memory1, address, &cpuMemory_ppuMirror_writer);
    memory_setReadCallback(memory1, address, &cpuMemory_ppuMirror_reader);
  }
  memory_setReadCallback(memory1, CPU_SPRITE_DMA_REGISTER_ADDRESS,&cpuMemory_spriteDMARegister_reader);
80007b68:	e0 a0 02 23 	rcall	80007fae <memory_setWriteCallback>
80007b6c:	e0 67 20 08 	mov	r7,8200
80007b70:	0e 9b       	mov	r11,r7
80007b72:	fe ca fe a6 	sub	r10,pc,-346
  memory_setWriteCallback(memory1, CPU_SPRITE_DMA_REGISTER_ADDRESS,&cpuMemory_spriteDMARegister_writer);
80007b76:	0c 9c       	mov	r12,r6
80007b78:	e0 a0 02 1b 	rcall	80007fae <memory_setWriteCallback>
80007b7c:	0e 9b       	mov	r11,r7
80007b7e:	fe ca ff 5e 	sub	r10,pc,-162
  memory_setReadCallback(memory1, CPU_JOYPAD_0_ADDRESS, &cpuMemory_joypad_reader);
80007b82:	2f f7       	sub	r7,-1
80007b84:	0c 9c       	mov	r12,r6
80007b86:	e0 a0 02 19 	rcall	80007fb8 <memory_setReadCallback>
80007b8a:	e0 47 40 00 	cp.w	r7,16384
  memory_setWriteCallback(memory1, CPU_JOYPAD_0_ADDRESS, &cpuMemory_joypad_writer);
80007b8e:	cf 11       	brne	80007b70 <cpuMemory_init+0x130>
80007b90:	0c 9c       	mov	r12,r6
80007b92:	fe ca 01 54 	sub	r10,pc,340
80007b96:	e0 6b 40 14 	mov	r11,16404
  memory_setReadCallback(memory1, CPU_JOYPAD_1_ADDRESS, &cpuMemory_joypad_reader);
80007b9a:	e0 a0 02 0f 	rcall	80007fb8 <memory_setReadCallback>
80007b9e:	0c 9c       	mov	r12,r6
80007ba0:	fe ca ff 14 	sub	r10,pc,-236
  memory_setWriteCallback(memory1, CPU_JOYPAD_1_ADDRESS, &cpuMemory_joypad_writer);
80007ba4:	e0 6b 40 14 	mov	r11,16404
80007ba8:	e0 a0 02 03 	rcall	80007fae <memory_setWriteCallback>
80007bac:	0c 9c       	mov	r12,r6
80007bae:	fe ca ff 9e 	sub	r10,pc,-98
  
  usart_write_line(&AVR32_USART0,"CPU21");
80007bb2:	e0 6b 40 16 	mov	r11,16406
80007bb6:	e0 a0 02 01 	rcall	80007fb8 <memory_setReadCallback>
  return memory1;
}
80007bba:	0c 9c       	mov	r12,r6
80007bbc:	fe ca ff bc 	sub	r10,pc,-68
80007bc0:	e0 6b 40 16 	mov	r11,16406
80007bc4:	cf 5d       	rcall	80007fae <memory_setWriteCallback>
80007bc6:	0c 9c       	mov	r12,r6
80007bc8:	fe ca ff b8 	sub	r10,pc,-72
80007bcc:	e0 6b 40 17 	mov	r11,16407
80007bd0:	cf 4d       	rcall	80007fb8 <memory_setReadCallback>
80007bd2:	fe ca ff d2 	sub	r10,pc,-46
80007bd6:	0c 9c       	mov	r12,r6
80007bd8:	e0 6b 40 17 	mov	r11,16407
80007bdc:	ce 9d       	rcall	80007fae <memory_setWriteCallback>
80007bde:	48 8b       	lddpc	r11,80007bfc <cpuMemory_init+0x1bc>
80007be0:	fe 7c 14 00 	mov	r12,-60416
80007be4:	e0 a0 20 d7 	rcall	8000bd92 <usart_write_line>
80007be8:	0c 9c       	mov	r12,r6
80007bea:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007bee:	d7 03       	nop
80007bf0:	80 01       	ld.sh	r1,r0[0x0]
80007bf2:	7c 94       	ld.w	r4,lr[0x24]
80007bf4:	80 01       	ld.sh	r1,r0[0x0]
80007bf6:	7c 9c       	ld.w	r12,lr[0x24]
80007bf8:	80 01       	ld.sh	r1,r0[0x0]
80007bfa:	7c a4       	ld.w	r4,lr[0x28]
80007bfc:	80 01       	ld.sh	r1,r0[0x0]
80007bfe:	7c ac       	ld.w	r12,lr[0x28]

80007c00 <cpuMemory_joypad_writer>:
80007c00:	d4 01       	pushm	lr
80007c02:	5c 7b       	castu.h	r11
80007c04:	f6 cb 40 16 	sub	r11,r11,16406
80007c08:	e0 a0 03 fc 	rcall	80008400 <nes_writeJoypad>
80007c0c:	d8 02       	popm	pc
80007c0e:	d7 03       	nop

80007c10 <cpuMemory_joypad_reader>:
80007c10:	d4 01       	pushm	lr
80007c12:	5c 7b       	castu.h	r11
80007c14:	f6 cb 40 16 	sub	r11,r11,16406
80007c18:	e0 a0 04 0a 	rcall	8000842c <nes_readJoypad>
80007c1c:	d8 02       	popm	pc
80007c1e:	d7 03       	nop

80007c20 <cpuMemory_ppuMirror_reader>:
80007c20:	eb cd 40 c0 	pushm	r6-r7,lr
80007c24:	e0 68 20 07 	mov	r8,8199
80007c28:	18 97       	mov	r7,r12
80007c2a:	16 96       	mov	r6,r11
80007c2c:	f0 0b 19 00 	cp.h	r11,r8
80007c30:	e0 88 00 0d 	brls	80007c4a <cpuMemory_ppuMirror_reader+0x2a>
80007c34:	f6 c8 00 08 	sub	r8,r11,8
80007c38:	f6 c6 20 08 	sub	r6,r11,8200
80007c3c:	ed d6 c0 6d 	bfextu	r6,r6,0x3,0xd
  address = cpuMemory_ppuMirror_getLowestAddress(address);
  Memory cpuMemory = nes_getCPUMemory(nes);
  //assert(cpuMemory != NULL);
  memory_write_callback(nes, cpuMemory, address, data);
}
static Byte cpuMemory_ppuMirror_reader(NES nes, Address address) {
80007c40:	ec 06 10 f8 	mul	r6,r6,-8
80007c44:	f0 06 00 06 	add	r6,r8,r6
80007c48:	5c 86       	casts.h	r6
  address = cpuMemory_ppuMirror_getLowestAddress(address);
  Memory cpuMemory = nes_getCPUMemory(nes);
80007c4a:	0e 9c       	mov	r12,r7
80007c4c:	e0 a0 03 46 	rcall	800082d8 <nes_getCPUMemory>
  //assert(cpuMemory != NULL);
  Byte data = memory_read_callback(nes, cpuMemory, address);
80007c50:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80007c54:	18 9b       	mov	r11,r12
80007c56:	0e 9c       	mov	r12,r7
80007c58:	cc 5d       	rcall	80007fe2 <memory_read_callback>
80007c5a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
  return data;
}
80007c5e:	d7 03       	nop

80007c60 <cpuMemory_ramMirror_reader>:
80007c60:	eb cd 40 c0 	pushm	r6-r7,lr
80007c64:	e0 68 07 ff 	mov	r8,2047
  address = cpuMemory_ramMirror_getLowestAddress(address);
  Memory cpuMemory = nes_getCPUMemory(nes);
  //assert(cpuMemory != NULL);
  memory_write_callback(nes, cpuMemory, address, data);
}
static Byte cpuMemory_ramMirror_reader(NES nes, Address address) {
80007c68:	18 97       	mov	r7,r12
80007c6a:	16 96       	mov	r6,r11
#include "objectAttributeMemory.h"
#include "usart.h"
////////////////////////////////////////////////////////////////////////////////////////
//
static Address cpuMemory_ramMirror_getLowestAddress(Address address) {
  while(address > CPU_GENUINE_RAM_LAST_ADDRESS) {
80007c6c:	f0 0b 19 00 	cp.h	r11,r8
80007c70:	e0 88 00 04 	brls	80007c78 <cpuMemory_ramMirror_reader+0x18>
  address = cpuMemory_ramMirror_getLowestAddress(address);
  Memory cpuMemory = nes_getCPUMemory(nes);
  //assert(cpuMemory != NULL);
  memory_write_callback(nes, cpuMemory, address, data);
}
static Byte cpuMemory_ramMirror_reader(NES nes, Address address) {
80007c74:	ed db c0 0b 	bfextu	r6,r11,0x0,0xb
  // Memory locations $0000-$07FF are mirrored three times at $0800-$1FFF.
  // This means that, for example, any data written to $0000 will also be written to$0800, $1000 and $1800.
  address = cpuMemory_ramMirror_getLowestAddress(address);
  Memory cpuMemory = nes_getCPUMemory(nes);
80007c78:	0e 9c       	mov	r12,r7
80007c7a:	e0 a0 03 2f 	rcall	800082d8 <nes_getCPUMemory>
  //assert(cpuMemory != NULL);
  Byte data = memory_read_callback(nes, cpuMemory, address);
80007c7e:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80007c82:	18 9b       	mov	r11,r12
80007c84:	0e 9c       	mov	r12,r7
80007c86:	ca ed       	rcall	80007fe2 <memory_read_callback>
80007c88:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80007c8c <cpuMemory_spriteDMARegister_writer>:
  return data;
}
80007c8c:	eb cd 40 f8 	pushm	r3-r7,lr
80007c90:	a9 6a       	lsl	r10,0x8
80007c92:	18 96       	mov	r6,r12
80007c94:	e9 da b0 10 	bfexts	r4,r10,0x0,0x10
  //assert(nes != NULL);
  Address readAddress = data * CPU_DMA_ADDRESS_MULTIPLIER;
  Address offset;
  Memory cpuMemory = nes_getCPUMemory(nes);
  //assert(cpuMemory != NULL);
  Memory objectAttributeMemory = nes_getObjectAttributeMemory(nes);
80007c98:	30 07       	mov	r7,0
}
static void cpuMemory_spriteDMARegister_writer(NES nes, Address address, Byte data) {
  //assert(nes != NULL);
  Address readAddress = data * CPU_DMA_ADDRESS_MULTIPLIER;
  Address offset;
  Memory cpuMemory = nes_getCPUMemory(nes);
80007c9a:	e0 a0 03 1f 	rcall	800082d8 <nes_getCPUMemory>
80007c9e:	18 95       	mov	r5,r12
  //assert(cpuMemory != NULL);
  Memory objectAttributeMemory = nes_getObjectAttributeMemory(nes);
80007ca0:	0c 9c       	mov	r12,r6
80007ca2:	e0 a0 03 17 	rcall	800082d0 <nes_getObjectAttributeMemory>
80007ca6:	18 93       	mov	r3,r12
  //assert(objectAttributeMemory != NULL);
  for (offset=0; offset < OAM_NUM_ADDRESSES; offset++) {
    register Byte data = memory_read_callback(nes, cpuMemory, readAddress + offset);
80007ca8:	0e 9a       	mov	r10,r7
80007caa:	0a 9b       	mov	r11,r5
80007cac:	08 0a       	add	r10,r4
80007cae:	0c 9c       	mov	r12,r6
80007cb0:	5c 7a       	castu.h	r10
80007cb2:	c9 8d       	rcall	80007fe2 <memory_read_callback>
80007cb4:	0e 9a       	mov	r10,r7
    //nes_cpuCycled(nes);
    memory_write_callback(nes, objectAttributeMemory, offset, data);
80007cb6:	18 99       	mov	r9,r12
80007cb8:	06 9b       	mov	r11,r3
80007cba:	0c 9c       	mov	r12,r6
80007cbc:	c8 3d       	rcall	80007fc2 <memory_write_callback>
80007cbe:	2f f7       	sub	r7,-1
80007cc0:	e0 47 01 00 	cp.w	r7,256
  Address offset;
  Memory cpuMemory = nes_getCPUMemory(nes);
  //assert(cpuMemory != NULL);
  Memory objectAttributeMemory = nes_getObjectAttributeMemory(nes);
  //assert(objectAttributeMemory != NULL);
  for (offset=0; offset < OAM_NUM_ADDRESSES; offset++) {
80007cc4:	cf 21       	brne	80007ca8 <cpuMemory_spriteDMARegister_writer+0x1c>
80007cc6:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
    register Byte data = memory_read_callback(nes, cpuMemory, readAddress + offset);
    //nes_cpuCycled(nes);
    memory_write_callback(nes, objectAttributeMemory, offset, data);
   // nes_cpuCycled(nes);
  }
}
80007cca:	d7 03       	nop

80007ccc <cpuMemory_ppuMirror_writer>:
80007ccc:	eb cd 40 e0 	pushm	r5-r7,lr
80007cd0:	e0 68 20 07 	mov	r8,8199
80007cd4:	18 96       	mov	r6,r12
80007cd6:	16 97       	mov	r7,r11
80007cd8:	14 95       	mov	r5,r10
80007cda:	f0 0b 19 00 	cp.h	r11,r8
80007cde:	e0 88 00 0e 	brls	80007cfa <cpuMemory_ppuMirror_writer+0x2e>
    address -= CPU_PPU_MIRRORED_SIZE;
  }
  //assert(address <= CPU_GENUINE_PPU_LAST_ADDRESS);
  return address;
}
static void cpuMemory_ppuMirror_writer(NES nes, Address address, Byte data) {
80007ce2:	f6 c7 20 08 	sub	r7,r11,8200
80007ce6:	16 98       	mov	r8,r11
80007ce8:	0e 99       	mov	r9,r7
80007cea:	20 88       	sub	r8,8
80007cec:	ef d9 c0 6d 	bfextu	r7,r9,0x3,0xd
80007cf0:	ee 07 10 f8 	mul	r7,r7,-8
80007cf4:	f0 07 00 07 	add	r7,r8,r7
80007cf8:	5c 87       	casts.h	r7
  address = cpuMemory_ppuMirror_getLowestAddress(address);
  Memory cpuMemory = nes_getCPUMemory(nes);
80007cfa:	0c 9c       	mov	r12,r6
80007cfc:	e0 a0 02 ee 	rcall	800082d8 <nes_getCPUMemory>
  //assert(cpuMemory != NULL);
  memory_write_callback(nes, cpuMemory, address, data);
80007d00:	0e 9a       	mov	r10,r7
80007d02:	18 9b       	mov	r11,r12
80007d04:	0a 99       	mov	r9,r5
80007d06:	5c 7a       	castu.h	r10
80007d08:	0c 9c       	mov	r12,r6
80007d0a:	c5 cd       	rcall	80007fc2 <memory_write_callback>
80007d0c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80007d10 <cpuMemory_ramMirror_writer>:
}
80007d10:	eb cd 40 e0 	pushm	r5-r7,lr
80007d14:	e0 68 07 ff 	mov	r8,2047
80007d18:	18 96       	mov	r6,r12
80007d1a:	16 97       	mov	r7,r11
    address -= CPU_RAM_MIRRORED_SIZE;
  }
 // //assert(address <= CPU_GENUINE_RAM_LAST_ADDRESS);
  return address;
}
static void cpuMemory_ramMirror_writer(NES nes, Address address, Byte data) {
80007d1c:	14 95       	mov	r5,r10
#include "objectAttributeMemory.h"
#include "usart.h"
////////////////////////////////////////////////////////////////////////////////////////
//
static Address cpuMemory_ramMirror_getLowestAddress(Address address) {
  while(address > CPU_GENUINE_RAM_LAST_ADDRESS) {
80007d1e:	f0 0b 19 00 	cp.h	r11,r8
80007d22:	e0 88 00 04 	brls	80007d2a <cpuMemory_ramMirror_writer+0x1a>
    address -= CPU_RAM_MIRRORED_SIZE;
  }
 // //assert(address <= CPU_GENUINE_RAM_LAST_ADDRESS);
  return address;
}
static void cpuMemory_ramMirror_writer(NES nes, Address address, Byte data) {
80007d26:	ef db c0 0b 	bfextu	r7,r11,0x0,0xb
  // Memory locations $0000-$07FF are mirrored three times at $0800-$1FFF.
  // This means that, for example, any data written to $0000 will also be written to$0800, $1000 and $1800.
  address = cpuMemory_ramMirror_getLowestAddress(address);
  Memory cpuMemory = nes_getCPUMemory(nes);
80007d2a:	0c 9c       	mov	r12,r6
80007d2c:	e0 a0 02 d6 	rcall	800082d8 <nes_getCPUMemory>
  //assert(cpuMemory != NULL);
  memory_write_callback(nes, cpuMemory, address, data);
80007d30:	0e 9a       	mov	r10,r7
80007d32:	18 9b       	mov	r11,r12
80007d34:	0a 99       	mov	r9,r5
80007d36:	5c 7a       	castu.h	r10
80007d38:	0c 9c       	mov	r12,r6
80007d3a:	c4 4d       	rcall	80007fc2 <memory_write_callback>
80007d3c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80007d40 <cpuMemory_ppuMemoryDataRegister_writer>:
}
80007d40:	eb cd 40 c0 	pushm	r6-r7,lr
80007d44:	14 96       	mov	r6,r10
80007d46:	18 97       	mov	r7,r12
80007d48:	e0 a0 02 ce 	rcall	800082e4 <nes_getPPU>
static void cpuMemory_ppuMemoryDataRegister_writer(NES nes, Address address, Byte data)
{
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
  //assert(ppu != NULL);
  ppu_setPPUMemoryDataRegister(nes, data);
80007d4c:	0c 9b       	mov	r11,r6
80007d4e:	0e 9c       	mov	r12,r7
80007d50:	e0 a0 04 c0 	rcall	800086d0 <ppu_setPPUMemoryDataRegister>
}
80007d54:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80007d58 <cpuMemory_ppuMemoryDataRegister_reader>:
80007d58:	eb cd 40 80 	pushm	r7,lr
80007d5c:	18 97       	mov	r7,r12
80007d5e:	e0 a0 02 c3 	rcall	800082e4 <nes_getPPU>
// #define CPU_PPUMEMORY_DATA_REGISTER_ADDRESS             0x2007 // read/write
static Byte cpuMemory_ppuMemoryDataRegister_reader(NES nes, Address address) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
  //assert(ppu != NULL);
  return ppu_getPPUMemoryDataRegister(nes);
80007d62:	0e 9c       	mov	r12,r7
80007d64:	e0 a0 04 78 	rcall	80008654 <ppu_getPPUMemoryDataRegister>
}
80007d68:	e3 cd 80 80 	ldm	sp++,r7,pc

80007d6c <cpuMemory_ppuMemoryAddressRegister_writer>:
80007d6c:	eb cd 40 80 	pushm	r7,lr
80007d70:	14 97       	mov	r7,r10
80007d72:	e0 a0 02 b9 	rcall	800082e4 <nes_getPPU>
static void cpuMemory_ppuMemoryAddressRegister_writer(NES nes, Address address, Byte
data) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
  //assert(ppu != NULL);
  ppu_setPPUMemoryAddressRegister(ppu, data);
80007d76:	0e 9b       	mov	r11,r7
80007d78:	e0 a0 04 5d 	rcall	80008632 <ppu_setPPUMemoryAddressRegister>
}
80007d7c:	e3 cd 80 80 	ldm	sp++,r7,pc

80007d80 <cpuMemory_ppuMemoryAddressRegister_reader>:
80007d80:	d4 01       	pushm	lr
80007d82:	e0 a0 02 b1 	rcall	800082e4 <nes_getPPU>
80007d86:	e0 a0 04 3d 	rcall	80008600 <ppu_getPPUMemoryAddressRegister>
static Byte cpuMemory_ppuMemoryAddressRegister_reader(NES nes, Address address) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
  //assert(ppu != NULL);
  return ppu_getPPUMemoryAddressRegister(ppu);
}
80007d8a:	d8 02       	popm	pc

80007d8c <cpuMemory_ppuScrollRegister_writer>:
80007d8c:	eb cd 40 80 	pushm	r7,lr
80007d90:	14 97       	mov	r7,r10
80007d92:	e0 a0 02 a9 	rcall	800082e4 <nes_getPPU>
}
static void cpuMemory_ppuScrollRegister_writer(NES nes, Address address, Byte data) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
  //assert(ppu != NULL);
  ppu_setScrollRegister(ppu, data);
80007d96:	0e 9b       	mov	r11,r7
80007d98:	e0 a0 04 3c 	rcall	80008610 <ppu_setScrollRegister>
}
80007d9c:	e3 cd 80 80 	ldm	sp++,r7,pc

80007da0 <cpuMemory_ppuScrollRegister_reader>:
80007da0:	d4 01       	pushm	lr
80007da2:	e0 a0 02 a1 	rcall	800082e4 <nes_getPPU>
80007da6:	e0 a0 04 2b 	rcall	800085fc <ppu_getScrollRegister>
static Byte cpuMemory_ppuScrollRegister_reader(NES nes, Address address) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
  //assert(ppu != NULL);
  return ppu_getScrollRegister(ppu);
}
80007daa:	d8 02       	popm	pc

80007dac <cpuMemory_ppuSpriteDataRegister_writer>:
80007dac:	eb cd 40 c0 	pushm	r6-r7,lr
80007db0:	14 96       	mov	r6,r10
80007db2:	18 97       	mov	r7,r12
  return ppu_getSpriteDataRegister(nes);
}
static void cpuMemory_ppuSpriteDataRegister_writer(NES nes, Address address, Byte data)
{
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
80007db4:	e0 a0 02 98 	rcall	800082e4 <nes_getPPU>
  //assert(ppu != NULL);
  ppu_setSpriteDataRegister(nes, data);
80007db8:	0c 9b       	mov	r11,r6
80007dba:	0e 9c       	mov	r12,r7
80007dbc:	e0 a0 04 bc 	rcall	80008734 <ppu_setSpriteDataRegister>
}
80007dc0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80007dc4 <cpuMemory_ppuSpriteDataRegister_reader>:
80007dc4:	eb cd 40 80 	pushm	r7,lr
80007dc8:	18 97       	mov	r7,r12
80007dca:	e0 a0 02 8d 	rcall	800082e4 <nes_getPPU>
// #define CPU_PPU_SPRITE_DATA_REGISTER_ADDRESS            0x2004 // write
static Byte cpuMemory_ppuSpriteDataRegister_reader(NES nes, Address address) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
  //assert(ppu != NULL);
  return ppu_getSpriteDataRegister(nes);
80007dce:	0e 9c       	mov	r12,r7
80007dd0:	e0 a0 04 c4 	rcall	80008758 <ppu_getSpriteDataRegister>
}
80007dd4:	e3 cd 80 80 	ldm	sp++,r7,pc

80007dd8 <cpuMemory_ppuSpriteAddressRegister_writer>:
80007dd8:	eb cd 40 80 	pushm	r7,lr
80007ddc:	14 97       	mov	r7,r10
80007dde:	e0 a0 02 83 	rcall	800082e4 <nes_getPPU>
static void cpuMemory_ppuSpriteAddressRegister_writer(NES nes, Address address, Byte
data) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
  //assert(ppu != NULL);
  ppu_setSpriteAddressRegister(ppu, data);
80007de2:	0e 9b       	mov	r11,r7
80007de4:	e0 a0 04 14 	rcall	8000860c <ppu_setSpriteAddressRegister>
}
80007de8:	e3 cd 80 80 	ldm	sp++,r7,pc

80007dec <cpuMemory_ppuSpriteAddressRegister_reader>:
80007dec:	d4 01       	pushm	lr
80007dee:	e0 a0 02 7b 	rcall	800082e4 <nes_getPPU>
80007df2:	e0 a0 04 03 	rcall	800085f8 <ppu_getSpriteAddressRegister>
static Byte cpuMemory_ppuSpriteAddressRegister_reader(NES nes, Address address) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
  //assert(ppu != NULL);
  return ppu_getSpriteAddressRegister(ppu);
}
80007df6:	d8 02       	popm	pc

80007df8 <cpuMemory_ppuStatusRegister_reader>:
80007df8:	d4 01       	pushm	lr
80007dfa:	e0 a0 02 75 	rcall	800082e4 <nes_getPPU>
80007dfe:	e0 a0 03 f3 	rcall	800085e4 <ppu_getStatusRegister>
static Byte cpuMemory_ppuStatusRegister_reader(NES nes, Address address) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
  //assert(ppu != NULL);
  return ppu_getStatusRegister(ppu);
}
80007e02:	d8 02       	popm	pc

80007e04 <cpuMemory_ppuMaskRegister_writer>:
80007e04:	eb cd 40 80 	pushm	r7,lr
80007e08:	14 97       	mov	r7,r10
80007e0a:	e0 a0 02 6d 	rcall	800082e4 <nes_getPPU>
}
static void cpuMemory_ppuMaskRegister_writer(NES nes, Address address, Byte data) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
  //assert(ppu != NULL);
  ppu_setMaskRegister(ppu, data);
80007e0e:	0e 9b       	mov	r11,r7
80007e10:	e0 a0 03 fc 	rcall	80008608 <ppu_setMaskRegister>
}
80007e14:	e3 cd 80 80 	ldm	sp++,r7,pc

80007e18 <cpuMemory_ppuMaskRegister_reader>:
80007e18:	d4 01       	pushm	lr
80007e1a:	e0 a0 02 65 	rcall	800082e4 <nes_getPPU>
80007e1e:	e0 a0 03 e1 	rcall	800085e0 <ppu_getMaskRegister>
  // not allowed to read this
  // //assert(FALSE);
  PPU ppu = nes_getPPU(nes);
  //assert(ppu != NULL);
  return ppu_getMaskRegister(ppu);
}
80007e22:	d8 02       	popm	pc

80007e24 <cpuMemory_ppuControlRegister_writer>:
80007e24:	eb cd 40 80 	pushm	r7,lr
80007e28:	14 97       	mov	r7,r10
80007e2a:	e0 a0 02 5d 	rcall	800082e4 <nes_getPPU>
}
static void cpuMemory_ppuControlRegister_writer(NES nes, Address address, Byte data) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
  //assert(ppu != NULL);
  ppu_setControlRegister(ppu, data);
80007e2e:	0e 9b       	mov	r11,r7
80007e30:	e0 a0 03 ea 	rcall	80008604 <ppu_setControlRegister>
}
80007e34:	e3 cd 80 80 	ldm	sp++,r7,pc

80007e38 <cpuMemory_ppuControlRegister_reader>:
80007e38:	d4 01       	pushm	lr
80007e3a:	e0 a0 02 55 	rcall	800082e4 <nes_getPPU>
80007e3e:	e0 a0 03 cf 	rcall	800085dc <ppu_getControlRegister>
  // not allowed to read this
  // //assert(FALSE);
  PPU ppu = nes_getPPU(nes);
  //assert(ppu != NULL);
  return ppu_getControlRegister(ppu);
}
80007e42:	d8 02       	popm	pc

80007e44 <gui_isButtonPressed>:
   gui->buttonState[0][JOYPAD_BUTTON_LEFT] = ( gpio_get_pin_value(QT1081_TOUCH_SENSOR_LEFT));
  
 
  
}
Bool gui_isButtonPressed(GUI gui, int joypad, Button button) {
80007e44:	f8 0b 00 3b 	add	r11,r12,r11<<0x3
80007e48:	f6 0a 00 0a 	add	r10,r11,r10
  //assert(joypad >= 0);
 // assert(joypad <= GUI_MAX_JOYPADS);
  //assert(button >= 0);
  //assert(button <= JOYPAD_NUM_BUTTONS);
  return gui->buttonState[joypad][button];
80007e4c:	f5 3c 00 0c 	ld.ub	r12,r10[12]
80007e50:	5e fc       	retal	r12
80007e52:	d7 03       	nop

80007e54 <gui_queryInput>:
}
void gui_destroy(GUI gui) {
  assert(gui != NULL);
  free(gui);
}
void gui_queryInput(GUI gui) {
80007e54:	eb cd 40 80 	pushm	r7,lr
  //assert(gui != NULL);
  int joypad;
  for (joypad=0; joypad < GUI_MAX_JOYPADS; joypad++) {
    int button;
    for (button=0; button < JOYPAD_NUM_BUTTONS; button++) {
      gui->buttonState[joypad][button] = 0;
80007e58:	49 18       	lddpc	r8,80007e9c <gui_queryInput+0x48>
80007e5a:	f8 c9 ff dc 	sub	r9,r12,-36
80007e5e:	99 38       	st.w	r12[0xc],r8
80007e60:	99 48       	st.w	r12[0x10],r8
80007e62:	99 58       	st.w	r12[0x14],r8
80007e64:	99 68       	st.w	r12[0x18],r8
80007e66:	99 78       	st.w	r12[0x1c],r8
80007e68:	99 88       	st.w	r12[0x20],r8
}
void gui_destroy(GUI gui) {
  assert(gui != NULL);
  free(gui);
}
void gui_queryInput(GUI gui) {
80007e6a:	18 97       	mov	r7,r12
  //assert(gui != NULL);
  int joypad;
  for (joypad=0; joypad < GUI_MAX_JOYPADS; joypad++) {
    int button;
    for (button=0; button < JOYPAD_NUM_BUTTONS; button++) {
      gui->buttonState[joypad][button] = 0;
80007e6c:	93 18       	st.w	r9[0x4],r8
80007e6e:	93 08       	st.w	r9[0x0],r8
          break;
      }
    }
  }
  */
  gui->buttonState[0][JOYPAD_BUTTON_START] = ( gpio_get_pin_value(QT1081_TOUCH_SENSOR_ENTER));
80007e70:	33 ac       	mov	r12,58
80007e72:	e0 a0 1c 3f 	rcall	8000b6f0 <gpio_get_pin_value>
80007e76:	ef 6c 00 0f 	st.b	r7[15],r12
  gui->buttonState[0][JOYPAD_BUTTON_SELECT] = (gpio_get_pin_value(QT1081_TOUCH_SENSOR_UP));
80007e7a:	33 6c       	mov	r12,54
80007e7c:	e0 a0 1c 3a 	rcall	8000b6f0 <gpio_get_pin_value>
80007e80:	ef 6c 00 0e 	st.b	r7[14],r12
   gui->buttonState[0][JOYPAD_BUTTON_RIGHT] = ( gpio_get_pin_value(QT1081_TOUCH_SENSOR_RIGHT));
80007e84:	33 8c       	mov	r12,56
80007e86:	e0 a0 1c 35 	rcall	8000b6f0 <gpio_get_pin_value>
80007e8a:	ef 6c 00 13 	st.b	r7[19],r12
   gui->buttonState[0][JOYPAD_BUTTON_LEFT] = ( gpio_get_pin_value(QT1081_TOUCH_SENSOR_LEFT));
80007e8e:	33 9c       	mov	r12,57
80007e90:	e0 a0 1c 30 	rcall	8000b6f0 <gpio_get_pin_value>
80007e94:	ef 6c 00 12 	st.b	r7[18],r12
  
 
  
}
80007e98:	e3 cd 80 80 	ldm	sp++,r7,pc
80007e9c:	00 00       	add	r0,r0
	...

80007ea0 <gui_init>:
80007ea0:	eb cd 40 c0 	pushm	r6-r7,lr
    for (button=0; button < JOYPAD_NUM_BUTTONS; button++) {
      gui->buttonState[joypad][button] = 0;
    }
  }
}
GUI gui_init(int width, int height) {
80007ea4:	18 97       	mov	r7,r12
80007ea6:	16 96       	mov	r6,r11
  GUI gui = (GUI) malloc(sizeof(struct gui));
80007ea8:	33 0c       	mov	r12,48
80007eaa:	e0 a0 40 29 	rcall	8000fefc <malloc>
80007eae:	18 98       	mov	r8,r12
  assert(gui != NULL);
80007eb0:	c1 30       	breq	80007ed6 <gui_init+0x36>
  //assert(gui != NULL);
  int joypad;
  for (joypad=0; joypad < GUI_MAX_JOYPADS; joypad++) {
    int button;
    for (button=0; button < JOYPAD_NUM_BUTTONS; button++) {
      gui->buttonState[joypad][button] = 0;
80007eb2:	49 09       	lddpc	r9,80007ef0 <gui_init+0x50>
  //atexit(SDL_Quit);
  /*gui->screen=SDL_SetVideoMode(width * GUI_IMAGE_SCALE,height *
GUI_IMAGE_SCALE,32,SDL_HWSURFACE|SDL_DOUBLEBUF); //|SDL_FULLSCREEN);
  assert(gui->screen != NULL);
  */
  gui->width = width;
80007eb4:	99 07       	st.w	r12[0x0],r7
  gui->height = height;
80007eb6:	99 16       	st.w	r12[0x4],r6
  //assert(gui != NULL);
  int joypad;
  for (joypad=0; joypad < GUI_MAX_JOYPADS; joypad++) {
    int button;
    for (button=0; button < JOYPAD_NUM_BUTTONS; button++) {
      gui->buttonState[joypad][button] = 0;
80007eb8:	99 39       	st.w	r12[0xc],r9
80007eba:	99 49       	st.w	r12[0x10],r9
80007ebc:	99 59       	st.w	r12[0x14],r9
80007ebe:	99 69       	st.w	r12[0x18],r9
80007ec0:	99 79       	st.w	r12[0x1c],r9
80007ec2:	99 89       	st.w	r12[0x20],r9
GUI_IMAGE_SCALE,32,SDL_HWSURFACE|SDL_DOUBLEBUF); //|SDL_FULLSCREEN);
  assert(gui->screen != NULL);
  */
  gui->width = width;
  gui->height = height;
  gui->currentFrame = 0;
80007ec4:	30 0a       	mov	r10,0
  gui->receivedTerminationRequest = FALSE;
80007ec6:	f9 6a 00 2c 	st.b	r12[44],r10
GUI_IMAGE_SCALE,32,SDL_HWSURFACE|SDL_DOUBLEBUF); //|SDL_FULLSCREEN);
  assert(gui->screen != NULL);
  */
  gui->width = width;
  gui->height = height;
  gui->currentFrame = 0;
80007eca:	99 2a       	st.w	r12[0x8],r10
  //assert(gui != NULL);
  int joypad;
  for (joypad=0; joypad < GUI_MAX_JOYPADS; joypad++) {
    int button;
    for (button=0; button < JOYPAD_NUM_BUTTONS; button++) {
      gui->buttonState[joypad][button] = 0;
80007ecc:	2d c8       	sub	r8,-36
80007ece:	91 19       	st.w	r8[0x4],r9
80007ed0:	91 09       	st.w	r8[0x0],r9
  gui->height = height;
  gui->currentFrame = 0;
  gui->receivedTerminationRequest = FALSE;
  gui_resetButtonState(gui);
  return gui;
}
80007ed2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
    }
  }
}
GUI gui_init(int width, int height) {
  GUI gui = (GUI) malloc(sizeof(struct gui));
  assert(gui != NULL);
80007ed6:	48 49       	lddpc	r9,80007ee4 <gui_init+0x44>
80007ed8:	48 4a       	lddpc	r10,80007ee8 <gui_init+0x48>
80007eda:	35 6b       	mov	r11,86
80007edc:	48 4c       	lddpc	r12,80007eec <gui_init+0x4c>
80007ede:	e0 a0 3f e1 	rcall	8000fea0 <__assert_func>
80007ee2:	d7 03       	nop
80007ee4:	80 01       	ld.sh	r1,r0[0x0]
80007ee6:	7c c0       	ld.w	r0,lr[0x30]
80007ee8:	80 01       	ld.sh	r1,r0[0x0]
80007eea:	7c b4       	ld.w	r4,lr[0x2c]
80007eec:	80 01       	ld.sh	r1,r0[0x0]
80007eee:	7c cc       	ld.w	r12,lr[0x30]
80007ef0:	00 00       	add	r0,r0
	...

80007ef4 <gui_drawPixel>:
80007ef4:	d4 01       	pushm	lr
80007ef6:	f3 d9 c0 68 	bfextu	r9,r9,0x3,0x8
80007efa:	f1 d8 c0 48 	bfextu	r8,r8,0x2,0x8
}
int gui_getHeight(GUI gui) {
  //assert(gui != NULL);
  return gui->height;
}
inline void gui_drawPixel(GUI gui, Byte x, Byte y, Byte red, Byte green, Byte blue) {
80007efe:	16 9c       	mov	r12,r11
80007f00:	14 9b       	mov	r11,r10
80007f02:	40 1a       	lddsp	r10,sp[0x4]
  //assert(gui != NULL);
  //assert(gui->screen != NULL);
 // assert(x < gui->width);    // Byte type is unsigned
 // assert(y < gui->height);   // Byte type is unsigned
 // et024006_DrawQuickPixel(x,y,RGB(red,green,blue));
  et024006_DrawQuickPixel(x,y,RGB2(red,green,blue));
80007f04:	f5 da c0 68 	bfextu	r10,r10,0x3,0x8
80007f08:	f5 e9 10 ba 	or	r10,r10,r9<<0xb
80007f0c:	f5 e8 10 5a 	or	r10,r10,r8<<0x5
80007f10:	5c 7a       	castu.h	r10
80007f12:	e0 a0 09 d9 	rcall	800092c4 <et024006_DrawQuickPixel>
(actualX);
  *bufp = color;
  bufp = (Uint32 *)gui->screen->pixels + (((actualY)+1)*gui->screen->pitch/4) +
(actualX) + 1;
  *bufp = color;*/
}
80007f16:	d8 02       	popm	pc

80007f18 <interrupts_getIRQ>:
  free(interrupts);
}
Bool interrupts_getIRQ(Interrupts interrupts) {
  //assert(interrupts != NULL);
  return interrupts->IRQ;
}
80007f18:	19 8c       	ld.ub	r12,r12[0x0]
80007f1a:	5e fc       	retal	r12

80007f1c <interrupts_getNMI>:
Bool interrupts_getNMI(Interrupts interrupts) {
  //assert(interrupts != NULL);
  return interrupts->NMI;
}
80007f1c:	19 9c       	ld.ub	r12,r12[0x1]
80007f1e:	5e fc       	retal	r12

80007f20 <interrupts_getRESET>:
Bool interrupts_getRESET(Interrupts interrupts) {
  //assert(interrupts != NULL);
  return interrupts->RESET;
}
80007f20:	19 ac       	ld.ub	r12,r12[0x2]
80007f22:	5e fc       	retal	r12

80007f24 <interrupts_setIRQ>:
void interrupts_setIRQ(Interrupts interrupts, Bool IRQ) {
  //assert(interrupts != NULL);
  interrupts->IRQ = IRQ;
80007f24:	b8 8b       	st.b	r12[0x0],r11
}
80007f26:	5e fc       	retal	r12

80007f28 <interrupts_setNMI>:
void interrupts_setNMI(Interrupts interrupts, Bool NMI) {
  //assert(interrupts != NULL);
  interrupts->NMI = NMI;
80007f28:	b8 9b       	st.b	r12[0x1],r11
}
80007f2a:	5e fc       	retal	r12

80007f2c <interrupts_setRESET>:
void interrupts_setRESET(Interrupts interrupts, Bool RESET) {
  //assert(interrupts != NULL);
  interrupts->RESET = RESET;
80007f2c:	b8 ab       	st.b	r12[0x2],r11
80007f2e:	5e fc       	retal	r12

80007f30 <interrupts_init>:
struct interrupts {
  Bool IRQ;
  Bool NMI;
  Bool RESET;
};
Interrupts interrupts_init(void) {
80007f30:	d4 01       	pushm	lr
  Interrupts interrupts = (Interrupts) malloc(sizeof(struct interrupts));
80007f32:	30 3c       	mov	r12,3
80007f34:	e0 a0 3f e4 	rcall	8000fefc <malloc>
  //assert(interrupts != NULL);
  interrupts->IRQ = FALSE;
80007f38:	30 09       	mov	r9,0
  interrupts->NMI = FALSE;
  interrupts->RESET = FALSE;
80007f3a:	b8 a9       	st.b	r12[0x2],r9
  Bool RESET;
};
Interrupts interrupts_init(void) {
  Interrupts interrupts = (Interrupts) malloc(sizeof(struct interrupts));
  //assert(interrupts != NULL);
  interrupts->IRQ = FALSE;
80007f3c:	b8 89       	st.b	r12[0x0],r9
  interrupts->NMI = FALSE;
80007f3e:	b8 99       	st.b	r12[0x1],r9
  interrupts->RESET = FALSE;
  return interrupts;
}
80007f40:	d8 02       	popm	pc
80007f42:	d7 03       	nop

80007f44 <joypad_resetCurrentButton>:
  joypad->currentButton = 0;
  return joypad;
}
void joypad_resetCurrentButton(Joypad joypad) {
  //assert(joypad != NULL);
  joypad->currentButton = 0;
80007f44:	30 08       	mov	r8,0
80007f46:	99 18       	st.w	r12[0x4],r8
}
80007f48:	5e fc       	retal	r12
80007f4a:	d7 03       	nop

80007f4c <joypad_readByte>:
Byte joypad_readByte(NES nes, Joypad joypad) {
80007f4c:	eb cd 40 80 	pushm	r7,lr
80007f50:	16 97       	mov	r7,r11
  //assert(nes != NULL);
 // assert(joypad != NULL);
  GUI gui = nes_getGUI(nes);
80007f52:	cc 1d       	rcall	800082d4 <nes_getGUI>
80007f54:	6e 1a       	ld.w	r10,r7[0x4]
 // assert(gui != NULL);
  Byte data = 0;
  if (joypad->currentButton < JOYPAD_NUM_BUTTONS) {
80007f56:	58 7a       	cp.w	r10,7
80007f58:	e0 88 00 08 	brls	80007f68 <joypad_readByte+0x1c>
80007f5c:	58 fa       	cp.w	r10,15
    if (gui_isButtonPressed(gui, joypad->joypadNumber, joypad->currentButton) == TRUE) {
      data = 1;
    }
  } else if (joypad->currentButton < (JOYPAD_NUM_BUTTONS * 2)) {
80007f5e:	5f bc       	srhi	r12
80007f60:	2f fa       	sub	r10,-1
    data = 0; // player 0/2 1/3
  } else {
    data = 1;
  }
  joypad->currentButton++;
80007f62:	8f 1a       	st.w	r7[0x4],r10
80007f64:	e3 cd 80 80 	ldm	sp++,r7,pc
  return data;
}
80007f68:	6e 0b       	ld.w	r11,r7[0x0]
 // assert(joypad != NULL);
  GUI gui = nes_getGUI(nes);
 // assert(gui != NULL);
  Byte data = 0;
  if (joypad->currentButton < JOYPAD_NUM_BUTTONS) {
    if (gui_isButtonPressed(gui, joypad->joypadNumber, joypad->currentButton) == TRUE) {
80007f6a:	c6 df       	rcall	80007e44 <gui_isButtonPressed>
80007f6c:	30 18       	mov	r8,1
80007f6e:	f0 0c 18 00 	cp.b	r12,r8
80007f72:	ef fa 10 01 	ld.wne	r10,r7[0x4]
80007f76:	f9 bc 01 00 	movne	r12,0
80007f7a:	ef fa 00 01 	ld.weq	r10,r7[0x4]
80007f7e:	f9 bc 00 01 	moveq	r12,1
80007f82:	2f fa       	sub	r10,-1
80007f84:	8f 1a       	st.w	r7[0x4],r10
  } else if (joypad->currentButton < (JOYPAD_NUM_BUTTONS * 2)) {
    data = 0; // player 0/2 1/3
  } else {
    data = 1;
  }
  joypad->currentButton++;
80007f86:	e3 cd 80 80 	ldm	sp++,r7,pc
  return data;
}
80007f8a:	d7 03       	nop

80007f8c <joypad_init>:
80007f8c:	eb cd 40 80 	pushm	r7,lr
80007f90:	18 97       	mov	r7,r12
80007f92:	30 8c       	mov	r12,8
80007f94:	e0 a0 3f b4 	rcall	8000fefc <malloc>
};
Joypad joypad_init(int joypadNumber) {
  Joypad joypad = (Joypad) malloc(sizeof(struct joypad));
  //assert(joypad != NULL);
  joypad->joypadNumber = joypadNumber;
  joypad->currentButton = 0;
80007f98:	30 09       	mov	r9,0
  Button currentButton;
};
Joypad joypad_init(int joypadNumber) {
  Joypad joypad = (Joypad) malloc(sizeof(struct joypad));
  //assert(joypad != NULL);
  joypad->joypadNumber = joypadNumber;
80007f9a:	99 07       	st.w	r12[0x0],r7
  joypad->currentButton = 0;
80007f9c:	99 19       	st.w	r12[0x4],r9
  return joypad;
}
80007f9e:	e3 cd 80 80 	ldm	sp++,r7,pc
80007fa2:	d7 03       	nop

80007fa4 <memory_read_direct>:
void memory_write_direct(Memory memory, Address address, Byte data) {
  //assert(memory != NULL);
  //assert(address < memory->numAddresses);
  memory->memoryU[address] = data;
}
Byte memory_read_direct(Memory memory, Address address) {
80007fa4:	5c 7b       	castu.h	r11
80007fa6:	78 18       	ld.w	r8,r12[0x4]
  //assert(memory != NULL);
  //assert(address < memory->numAddresses);
  return memory->memoryU[address];
}
80007fa8:	f0 0b 07 0c 	ld.ub	r12,r8[r11]
80007fac:	5e fc       	retal	r12

80007fae <memory_setWriteCallback>:
  //assert(memory != NULL);
  return memory->numAddresses;
}
void memory_setWriteCallback(Memory memory, Address address, NES_WriteCallback writeCallback) {
  //assert(memory != NULL);
  memory->writeCallbacks[address] = writeCallback;
80007fae:	5c 7b       	castu.h	r11
80007fb0:	78 28       	ld.w	r8,r12[0x8]
80007fb2:	f0 0b 09 2a 	st.w	r8[r11<<0x2],r10
}
80007fb6:	5e fc       	retal	r12

80007fb8 <memory_setReadCallback>:
void memory_setReadCallback(Memory memory, Address address, NES_ReadCallback readCallback) {
  //assert(memory != NULL);
  memory->readCallbacks[address] = readCallback;
80007fb8:	5c 7b       	castu.h	r11
80007fba:	78 38       	ld.w	r8,r12[0xc]
80007fbc:	f0 0b 09 2a 	st.w	r8[r11<<0x2],r10
}
80007fc0:	5e fc       	retal	r12

80007fc2 <memory_write_callback>:
void memory_write_callback(NES nes, Memory memory1, Address address, Byte data) {
80007fc2:	d4 01       	pushm	lr
  //assert(memory != NULL);
  if (memory1->writeCallbacks[address] == NULL) {
80007fc4:	fd da c0 10 	bfextu	lr,r10,0x0,0x10
80007fc8:	76 28       	ld.w	r8,r11[0x8]
80007fca:	f0 0e 03 28 	ld.w	r8,r8[lr<<0x2]
80007fce:	58 08       	cp.w	r8,0
80007fd0:	c0 50       	breq	80007fda <memory_write_callback+0x18>
    memory_write_direct(memory1, address, data);
  } else {
    memory1->writeCallbacks[address](nes, address, data);
80007fd2:	12 9a       	mov	r10,r9
80007fd4:	1c 9b       	mov	r11,lr
80007fd6:	5d 18       	icall	r8
80007fd8:	d8 02       	popm	pc
  free(memory);
}
void memory_write_direct(Memory memory, Address address, Byte data) {
  //assert(memory != NULL);
  //assert(address < memory->numAddresses);
  memory->memoryU[address] = data;
80007fda:	76 18       	ld.w	r8,r11[0x4]
80007fdc:	f0 0e 0b 09 	st.b	r8[lr],r9
80007fe0:	d8 02       	popm	pc

80007fe2 <memory_read_callback>:
    memory_write_direct(memory1, address, data);
  } else {
    memory1->writeCallbacks[address](nes, address, data);
  }
}
Byte memory_read_callback(NES nes, Memory memory1, Address address) {
80007fe2:	d4 01       	pushm	lr
  //assert(memory1 != NULL);
  //usart_write_line(&AVR32_USART0,"readCallback\n");
  if (memory1->readCallbacks[address] == NULL) {
80007fe4:	5c 7a       	castu.h	r10
80007fe6:	76 38       	ld.w	r8,r11[0xc]
80007fe8:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
80007fec:	58 08       	cp.w	r8,0
80007fee:	c0 40       	breq	80007ff6 <memory_read_callback+0x14>
	  //usart_write_line(&AVR32_USART0,"readCallback1_1\n");
    return memory_read_direct(memory1, address);
  } else {
	  //usart_write_line(&AVR32_USART0,"readCallback1_2\n");
    return memory1->readCallbacks[address](nes,address);
80007ff0:	14 9b       	mov	r11,r10
80007ff2:	5d 18       	icall	r8
	//return memory_read_direct(memory1, address);
  }
  
80007ff4:	d8 02       	popm	pc
  memory->memoryU[address] = data;
}
Byte memory_read_direct(Memory memory, Address address) {
  //assert(memory != NULL);
  //assert(address < memory->numAddresses);
  return memory->memoryU[address];
80007ff6:	76 18       	ld.w	r8,r11[0x4]
80007ff8:	f0 0a 07 0c 	ld.ub	r12,r8[r10]
Byte memory_read_callback(NES nes, Memory memory1, Address address) {
  //assert(memory1 != NULL);
  //usart_write_line(&AVR32_USART0,"readCallback\n");
  if (memory1->readCallbacks[address] == NULL) {
	  //usart_write_line(&AVR32_USART0,"readCallback1_1\n");
    return memory_read_direct(memory1, address);
80007ffc:	d8 02       	popm	pc
80007ffe:	d7 03       	nop

80008000 <memory_init>:
  uint32_t numAddresses;
  Byte *memoryU;
  NES_WriteCallback *writeCallbacks;
  NES_ReadCallback *readCallbacks;
};
Memory memory_init(uint32_t numAddresses) {
80008000:	d4 21       	pushm	r4-r7,lr
80008002:	18 97       	mov	r7,r12
  Memory memory1 = malloc(sizeof(struct memory));
80008004:	31 0c       	mov	r12,16
80008006:	e0 a0 3f 7b 	rcall	8000fefc <malloc>
8000800a:	18 96       	mov	r6,r12
  //assert(memory1 != NULL);
  memory1->memoryU = (Byte*) malloc(sizeof(Byte) * numAddresses);
8000800c:	0e 9c       	mov	r12,r7
8000800e:	e0 a0 3f 77 	rcall	8000fefc <malloc>
 //assert(memory1->memoryU != NULL);
 usart_write_line(&AVR32_USART0,"CPU33");
80008012:	4a 2b       	lddpc	r11,80008098 <memory_init+0x98>
  NES_ReadCallback *readCallbacks;
};
Memory memory_init(uint32_t numAddresses) {
  Memory memory1 = malloc(sizeof(struct memory));
  //assert(memory1 != NULL);
  memory1->memoryU = (Byte*) malloc(sizeof(Byte) * numAddresses);
80008014:	8d 1c       	st.w	r6[0x4],r12
 //assert(memory1->memoryU != NULL);
 usart_write_line(&AVR32_USART0,"CPU33");
80008016:	fe 7c 14 00 	mov	r12,-60416
8000801a:	e0 a0 1e bc 	rcall	8000bd92 <usart_write_line>
 
  int i;
  
  for (i=0; i < numAddresses; i++) {
8000801e:	58 07       	cp.w	r7,0
80008020:	c3 20       	breq	80008084 <memory_init+0x84>
  uint32_t numAddresses;
  Byte *memoryU;
  NES_WriteCallback *writeCallbacks;
  NES_ReadCallback *readCallbacks;
};
Memory memory_init(uint32_t numAddresses) {
80008022:	30 09       	mov	r9,0
80008024:	12 98       	mov	r8,r9
 usart_write_line(&AVR32_USART0,"CPU33");
 
  int i;
  
  for (i=0; i < numAddresses; i++) {
    memory1->memoryU[i] = 0;
80008026:	12 9b       	mov	r11,r9
80008028:	6c 1a       	ld.w	r10,r6[0x4]
8000802a:	f4 09 0b 0b 	st.b	r10[r9],r11
 //assert(memory1->memoryU != NULL);
 usart_write_line(&AVR32_USART0,"CPU33");
 
  int i;
  
  for (i=0; i < numAddresses; i++) {
8000802e:	2f f8       	sub	r8,-1
80008030:	10 99       	mov	r9,r8
80008032:	0e 38       	cp.w	r8,r7
80008034:	cf a1       	brne	80008028 <memory_init+0x28>
    memory1->memoryU[i] = 0;
  }
  
  memory1->writeCallbacks = (NES_WriteCallback*) malloc(sizeof(NES_WriteCallback) * numAddresses);
80008036:	ee 04 15 02 	lsl	r4,r7,0x2
8000803a:	08 9c       	mov	r12,r4
8000803c:	e0 a0 3f 60 	rcall	8000fefc <malloc>
80008040:	30 09       	mov	r9,0
80008042:	8d 2c       	st.w	r6[0x8],r12
80008044:	12 98       	mov	r8,r9
  //assert(memory1->writeCallbacks != NULL);
  for (i=0; i < numAddresses; i++) {
    memory1->writeCallbacks[i] = NULL;
80008046:	12 95       	mov	r5,r9
80008048:	c0 28       	rjmp	8000804c <memory_init+0x4c>
    memory1->memoryU[i] = 0;
  }
  
  memory1->writeCallbacks = (NES_WriteCallback*) malloc(sizeof(NES_WriteCallback) * numAddresses);
  //assert(memory1->writeCallbacks != NULL);
  for (i=0; i < numAddresses; i++) {
8000804a:	6c 2c       	ld.w	r12,r6[0x8]
    memory1->writeCallbacks[i] = NULL;
8000804c:	f8 09 09 25 	st.w	r12[r9<<0x2],r5
    memory1->memoryU[i] = 0;
  }
  
  memory1->writeCallbacks = (NES_WriteCallback*) malloc(sizeof(NES_WriteCallback) * numAddresses);
  //assert(memory1->writeCallbacks != NULL);
  for (i=0; i < numAddresses; i++) {
80008050:	2f f8       	sub	r8,-1
80008052:	10 99       	mov	r9,r8
80008054:	0e 38       	cp.w	r8,r7
80008056:	cf a1       	brne	8000804a <memory_init+0x4a>
    memory1->writeCallbacks[i] = NULL;
  }
  memory1->readCallbacks = (NES_ReadCallback*) malloc(sizeof(NES_ReadCallback) * numAddresses);
80008058:	08 9c       	mov	r12,r4
8000805a:	e0 a0 3f 51 	rcall	8000fefc <malloc>
8000805e:	0a 98       	mov	r8,r5
80008060:	8d 3c       	st.w	r6[0xc],r12
  //assert(memory1->readCallbacks != NULL);
  for (i=0; i < numAddresses; i++) {
    memory1->readCallbacks[i] = NULL;
80008062:	0a 99       	mov	r9,r5
80008064:	c0 28       	rjmp	80008068 <memory_init+0x68>
  for (i=0; i < numAddresses; i++) {
    memory1->writeCallbacks[i] = NULL;
  }
  memory1->readCallbacks = (NES_ReadCallback*) malloc(sizeof(NES_ReadCallback) * numAddresses);
  //assert(memory1->readCallbacks != NULL);
  for (i=0; i < numAddresses; i++) {
80008066:	6c 3c       	ld.w	r12,r6[0xc]
    memory1->readCallbacks[i] = NULL;
80008068:	f8 05 09 29 	st.w	r12[r5<<0x2],r9
  for (i=0; i < numAddresses; i++) {
    memory1->writeCallbacks[i] = NULL;
  }
  memory1->readCallbacks = (NES_ReadCallback*) malloc(sizeof(NES_ReadCallback) * numAddresses);
  //assert(memory1->readCallbacks != NULL);
  for (i=0; i < numAddresses; i++) {
8000806c:	2f f8       	sub	r8,-1
8000806e:	10 95       	mov	r5,r8
80008070:	0e 38       	cp.w	r8,r7
80008072:	cf a1       	brne	80008066 <memory_init+0x66>
    memory1->readCallbacks[i] = NULL;
  }
  usart_write_line(&AVR32_USART0,"CPU43");
80008074:	fe 7c 14 00 	mov	r12,-60416
80008078:	48 9b       	lddpc	r11,8000809c <memory_init+0x9c>
8000807a:	e0 a0 1e 8c 	rcall	8000bd92 <usart_write_line>
  memory1->numAddresses = numAddresses;
  return memory1;
}
8000807e:	0c 9c       	mov	r12,r6
  //assert(memory1->readCallbacks != NULL);
  for (i=0; i < numAddresses; i++) {
    memory1->readCallbacks[i] = NULL;
  }
  usart_write_line(&AVR32_USART0,"CPU43");
  memory1->numAddresses = numAddresses;
80008080:	8d 07       	st.w	r6[0x0],r7
  return memory1;
}
80008082:	d8 22       	popm	r4-r7,pc
  
  for (i=0; i < numAddresses; i++) {
    memory1->memoryU[i] = 0;
  }
  
  memory1->writeCallbacks = (NES_WriteCallback*) malloc(sizeof(NES_WriteCallback) * numAddresses);
80008084:	0e 9c       	mov	r12,r7
80008086:	e0 a0 3f 3b 	rcall	8000fefc <malloc>
8000808a:	8d 2c       	st.w	r6[0x8],r12
  //assert(memory1->writeCallbacks != NULL);
  for (i=0; i < numAddresses; i++) {
    memory1->writeCallbacks[i] = NULL;
  }
  memory1->readCallbacks = (NES_ReadCallback*) malloc(sizeof(NES_ReadCallback) * numAddresses);
8000808c:	0e 9c       	mov	r12,r7
8000808e:	e0 a0 3f 37 	rcall	8000fefc <malloc>
80008092:	8d 3c       	st.w	r6[0xc],r12
80008094:	cf 0b       	rjmp	80008074 <memory_init+0x74>
80008096:	d7 03       	nop
80008098:	80 01       	ld.sh	r1,r0[0x0]
8000809a:	7c e0       	ld.w	r0,lr[0x38]
8000809c:	80 01       	ld.sh	r1,r0[0x0]
8000809e:	7c e8       	ld.w	r8,lr[0x38]

800080a0 <mmu_ppuMemory_writeVerticalMirror>:
  //assert(ppuMemory != NULL);
  address -= PPU_NAME_TABLE_SIZE;
  address -= PPU_NAME_TABLE_SIZE;
  return memory_read_callback(nes, ppuMemory, address);
}
void mmu_ppuMemory_writeVerticalMirror(NES nes, Address address, Byte byte) {
800080a0:	eb cd 40 e0 	pushm	r5-r7,lr
800080a4:	16 96       	mov	r6,r11
800080a6:	14 95       	mov	r5,r10
800080a8:	18 97       	mov	r7,r12
  //assert(nes != NULL);
  Memory ppuMemory = nes_getPPUMemory(nes);
800080aa:	c1 9d       	rcall	800082dc <nes_getPPUMemory>
800080ac:	ec ca 08 00 	sub	r10,r6,2048
  //assert(ppuMemory != NULL);
  address -= PPU_NAME_TABLE_SIZE;
  address -= PPU_NAME_TABLE_SIZE;
  memory_write_callback(nes, ppuMemory, address, byte);
800080b0:	18 9b       	mov	r11,r12
800080b2:	0a 99       	mov	r9,r5
800080b4:	5c 7a       	castu.h	r10
800080b6:	0e 9c       	mov	r12,r7
800080b8:	c8 5f       	rcall	80007fc2 <memory_write_callback>
800080ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
}
800080be:	d7 03       	nop

800080c0 <mmu_ppuMemory_writeHorizontalMirror>:
800080c0:	eb cd 40 e0 	pushm	r5-r7,lr
800080c4:	16 96       	mov	r6,r11
800080c6:	14 95       	mov	r5,r10
800080c8:	18 97       	mov	r7,r12
800080ca:	c0 9d       	rcall	800082dc <nes_getPPUMemory>
  address -= PPU_NAME_TABLE_SIZE;
  return memory_read_callback(nes, ppuMemory, address);
}
void mmu_ppuMemory_writeHorizontalMirror(NES nes, Address address, Byte byte) {
  //assert(nes != NULL);
  Memory ppuMemory = nes_getPPUMemory(nes);
800080cc:	ec ca 04 00 	sub	r10,r6,1024
  //assert(ppuMemory != NULL);
  address -= PPU_NAME_TABLE_SIZE;
  memory_write_callback(nes, ppuMemory, address, byte);
800080d0:	18 9b       	mov	r11,r12
800080d2:	0a 99       	mov	r9,r5
800080d4:	5c 7a       	castu.h	r10
800080d6:	0e 9c       	mov	r12,r7
800080d8:	c7 5f       	rcall	80007fc2 <memory_write_callback>
800080da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
}
800080de:	d7 03       	nop

800080e0 <mmu_ppuMemory_readVerticalMirror>:
800080e0:	eb cd 40 c0 	pushm	r6-r7,lr
800080e4:	16 96       	mov	r6,r11
800080e6:	18 97       	mov	r7,r12
800080e8:	cf ac       	rcall	800082dc <nes_getPPUMemory>
800080ea:	ec ca 08 00 	sub	r10,r6,2048
  //assert(nes != NULL);
  Memory ppuMemory = nes_getPPUMemory(nes);
  //assert(ppuMemory != NULL);
  address -= PPU_NAME_TABLE_SIZE;
  address -= PPU_NAME_TABLE_SIZE;
  return memory_read_callback(nes, ppuMemory, address);
800080ee:	18 9b       	mov	r11,r12
800080f0:	5c 7a       	castu.h	r10
800080f2:	0e 9c       	mov	r12,r7
800080f4:	c7 7f       	rcall	80007fe2 <memory_read_callback>
800080f6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
}
800080fa:	d7 03       	nop

800080fc <mmu_ppuMemory_readHorizontalMirror>:
800080fc:	eb cd 40 c0 	pushm	r6-r7,lr
80008100:	16 96       	mov	r6,r11
80008102:	18 97       	mov	r7,r12
80008104:	ce cc       	rcall	800082dc <nes_getPPUMemory>
80008106:	ec ca 04 00 	sub	r10,r6,1024
Byte mmu_ppuMemory_readHorizontalMirror(NES nes, Address address) {
  //assert(nes != NULL);
  Memory ppuMemory = nes_getPPUMemory(nes);
  //assert(ppuMemory != NULL);
  address -= PPU_NAME_TABLE_SIZE;
  return memory_read_callback(nes, ppuMemory, address);
8000810a:	18 9b       	mov	r11,r12
8000810c:	5c 7a       	castu.h	r10
8000810e:	0e 9c       	mov	r12,r7
80008110:	c6 9f       	rcall	80007fe2 <memory_read_callback>
80008112:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
}
80008116:	d7 03       	nop

80008118 <mmu_init>:
80008118:	eb cd 40 c0 	pushm	r6-r7,lr
8000811c:	18 96       	mov	r6,r12
8000811e:	30 3c       	mov	r12,3
80008120:	e0 a0 3e ee 	rcall	8000fefc <malloc>
};
MMU mmu_init(NES nes) {
  //assert(nes != NULL);
  MMU mmu = (MMU) malloc(sizeof(struct mmu));
  //assert(mmu != NULL);
  mmu->activeProgramBank_lower = 0;
80008124:	30 08       	mov	r8,0
  Byte activeProgramBank_upper;
  Byte activeCharacterBank;
};
MMU mmu_init(NES nes) {
  //assert(nes != NULL);
  MMU mmu = (MMU) malloc(sizeof(struct mmu));
80008126:	18 97       	mov	r7,r12
  //assert(mmu != NULL);
  mmu->activeProgramBank_lower = 0;
  mmu->activeProgramBank_upper = 0;
  mmu->activeCharacterBank = 0;
80008128:	b8 a8       	st.b	r12[0x2],r8
};
MMU mmu_init(NES nes) {
  //assert(nes != NULL);
  MMU mmu = (MMU) malloc(sizeof(struct mmu));
  //assert(mmu != NULL);
  mmu->activeProgramBank_lower = 0;
8000812a:	b8 88       	st.b	r12[0x0],r8
  mmu->activeProgramBank_upper = 0;
8000812c:	b8 98       	st.b	r12[0x1],r8
  mmu->activeCharacterBank = 0;
  Cartridge cartridge = nes_getCartridge(nes);
8000812e:	0c 9c       	mov	r12,r6
80008130:	cd cc       	rcall	800082e8 <nes_getCartridge>
80008132:	fe b0 f0 fd 	rcall	8000632c <cartridge_getMMUNumber>
  //assert(cartridge != NULL);
  Byte mmuNumber = cartridge_getMMUNumber(cartridge);
80008136:	0e 9b       	mov	r11,r7
  //assert(mmuNumber < num_mmu_callbackCreators);
  MMU_CallbackCreator mmu_callbackCreator = mmu_callbackCreators[mmuNumber];
 // MMU_CallbackCreator mmu_callbackCreator = mmu_callbackCreators[0];
  //assert(mmu_callbackCreator != NULL);
  mmu_callbackCreator(nes, mmu);
80008138:	30 88       	mov	r8,8
8000813a:	f0 0c 03 28 	ld.w	r8,r8[r12<<0x2]
8000813e:	0c 9c       	mov	r12,r6
80008140:	5d 18       	icall	r8
80008142:	0e 9c       	mov	r12,r7
  return mmu;
}
80008144:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80008148 <mmu0_ppuMemory_writePattern>:
  return cartridge_readCharacterBank(cartridge, 0, address);
}
static void mmu0_ppuMemory_writePattern(NES nes, Address address, Byte byte) {
  //assert(nes != NULL);
  ////assert(FALSE); // can't write to ROM
}
80008148:	5e fc       	retal	r12
8000814a:	d7 03       	nop

8000814c <mmu0_callbackCreator>:
////////////////////////////////////////////////////////////////////////////////////////
////////////
void mmu0_callbackCreator(NES nes, MMU mmu) {
8000814c:	d4 21       	pushm	r4-r7,lr
  //assert(nes != NULL);
  //assert(mmu != NULL);
  usart_write_line(&AVR32_USART0,"mmu0_callbackCreator\n");
8000814e:	4c db       	lddpc	r11,80008280 <mmu0_callbackCreator+0x134>
  //assert(nes != NULL);
  ////assert(FALSE); // can't write to ROM
}
////////////////////////////////////////////////////////////////////////////////////////
////////////
void mmu0_callbackCreator(NES nes, MMU mmu) {
80008150:	18 95       	mov	r5,r12
  //assert(nes != NULL);
  //assert(mmu != NULL);
  usart_write_line(&AVR32_USART0,"mmu0_callbackCreator\n");
  Memory cpuMemory = nes_getCPUMemory(nes);
80008152:	e0 67 80 00 	mov	r7,32768
////////////////////////////////////////////////////////////////////////////////////////
////////////
void mmu0_callbackCreator(NES nes, MMU mmu) {
  //assert(nes != NULL);
  //assert(mmu != NULL);
  usart_write_line(&AVR32_USART0,"mmu0_callbackCreator\n");
80008156:	fe 7c 14 00 	mov	r12,-60416
8000815a:	e0 a0 1e 1c 	rcall	8000bd92 <usart_write_line>
  Memory cpuMemory = nes_getCPUMemory(nes);
8000815e:	0a 9c       	mov	r12,r5
80008160:	cb cc       	rcall	800082d8 <nes_getCPUMemory>
80008162:	18 96       	mov	r6,r12
80008164:	0e 9b       	mov	r11,r7
  //assert(cpuMemory != NULL);
  int i;
  for (i = MMU_PROGRAM_BANK_LOWER_FIRST_ADDRESS; i <=MMU_PROGRAM_BANK_LOWER_LAST_ADDRESS; i++) {
    //memory_setWriteCallback(cpuMemory, i, &mmu0_cpuMemory_writeProgramBank0);
    memory_setReadCallback(cpuMemory, i, &mmu0_cpuMemory_readProgramBank0);
80008166:	fe ca fe b2 	sub	r10,pc,-334
  //assert(mmu != NULL);
  usart_write_line(&AVR32_USART0,"mmu0_callbackCreator\n");
  Memory cpuMemory = nes_getCPUMemory(nes);
  //assert(cpuMemory != NULL);
  int i;
  for (i = MMU_PROGRAM_BANK_LOWER_FIRST_ADDRESS; i <=MMU_PROGRAM_BANK_LOWER_LAST_ADDRESS; i++) {
8000816a:	2f f7       	sub	r7,-1
    //memory_setWriteCallback(cpuMemory, i, &mmu0_cpuMemory_writeProgramBank0);
    memory_setReadCallback(cpuMemory, i, &mmu0_cpuMemory_readProgramBank0);
8000816c:	0c 9c       	mov	r12,r6
8000816e:	c2 5f       	rcall	80007fb8 <memory_setReadCallback>
80008170:	e0 47 c0 00 	cp.w	r7,49152
  //assert(mmu != NULL);
  usart_write_line(&AVR32_USART0,"mmu0_callbackCreator\n");
  Memory cpuMemory = nes_getCPUMemory(nes);
  //assert(cpuMemory != NULL);
  int i;
  for (i = MMU_PROGRAM_BANK_LOWER_FIRST_ADDRESS; i <=MMU_PROGRAM_BANK_LOWER_LAST_ADDRESS; i++) {
80008174:	cf 81       	brne	80008164 <mmu0_callbackCreator+0x18>
80008176:	0a 9c       	mov	r12,r5
    //memory_setWriteCallback(cpuMemory, i, &mmu0_cpuMemory_writeProgramBank0);
    memory_setReadCallback(cpuMemory, i, &mmu0_cpuMemory_readProgramBank0);
  }
  Cartridge cartridge = nes_getCartridge(nes);
80008178:	cb 8c       	rcall	800082e8 <nes_getCartridge>
8000817a:	18 94       	mov	r4,r12
8000817c:	fe b0 f0 c8 	rcall	8000630c <cartridge_getNumProgramBanks>
  //assert(cartridge != NULL);
  Byte numProgramBanks = cartridge_getNumProgramBanks(cartridge);
80008180:	30 18       	mov	r8,1
80008182:	f0 0c 18 00 	cp.b	r12,r8
  //usart_write_char(&AVR32_USART0,numProgramBanks+0x30);
  // mmu0 only supports 1 or 2 program banks on the cartridge
  //assert(numProgramBanks >= 1);
  //assert(numProgramBanks <= 2);
  if (numProgramBanks == 1) {
80008186:	c3 50       	breq	800081f0 <mmu0_callbackCreator+0xa4>
80008188:	30 28       	mov	r8,2
8000818a:	f0 0c 18 00 	cp.b	r12,r8
    for (i = MMU_PROGRAM_BANK_UPPER_FIRST_ADDRESS; i <=
MMU_PROGRAM_BANK_UPPER_LAST_ADDRESS; i++) {
     // memory_setWriteCallback(cpuMemory, i, &mmu0_cpuMemory_writeProgramBank0);
      memory_setReadCallback(cpuMemory, i, &mmu0_cpuMemory_readProgramBank0);
    }
  } else if (numProgramBanks == 2) {
8000818e:	c3 c0       	breq	80008206 <mmu0_callbackCreator+0xba>
80008190:	08 9c       	mov	r12,r4
80008192:	fe b0 f0 d0 	rcall	80006332 <cartridge_getNumCharacterBanks>
    for (i = MMU_PROGRAM_BANK_UPPER_FIRST_ADDRESS; i <=MMU_PROGRAM_BANK_UPPER_LAST_ADDRESS; i++) {
      //memory_setWriteCallback(cpuMemory, i, &mmu0_cpuMemory_writeProgramBank1);
      memory_setReadCallback(cpuMemory, i, &mmu0_cpuMemory_readProgramBank1);
    }
  }
  Byte numCharacterBanks = cartridge_getNumCharacterBanks(cartridge);
80008196:	18 96       	mov	r6,r12
80008198:	0a 9c       	mov	r12,r5
8000819a:	ca 1c       	rcall	800082dc <nes_getPPUMemory>
  //assert(numCharacterBanks <= 1);
  Memory ppuMemory = nes_getPPUMemory(nes);
8000819c:	30 18       	mov	r8,1
8000819e:	18 97       	mov	r7,r12
800081a0:	f0 06 18 00 	cp.b	r6,r8
800081a4:	c3 f0       	breq	80008222 <mmu0_callbackCreator+0xd6>
  //assert(ppuMemory != NULL);
  if (numCharacterBanks == 1) {
800081a6:	08 9c       	mov	r12,r4
800081a8:	fe b0 f0 c7 	rcall	80006336 <cartridge_getMirrorType>
i++) {
      memory_setWriteCallback(ppuMemory, i, &mmu0_ppuMemory_writePattern);
      memory_setReadCallback(ppuMemory, i, &mmu0_ppuMemory_readPattern);
    }
  }
  MirrorType mirrorType = cartridge_getMirrorType(cartridge);
800081ac:	c3 81       	brne	8000821c <mmu0_callbackCreator+0xd0>
800081ae:	e0 66 24 00 	mov	r6,9216
  if (mirrorType == HORIZONTAL) {
800081b2:	0c 9b       	mov	r11,r6
800081b4:	fe ca 00 f4 	sub	r10,pc,244
    for (i = PPU_NAME_TABLE_1_FIRST_ADDRESS; i <= PPU_NAME_TABLE_1_LAST_ADDRESS; i++) {
      // map it back to table 0
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeHorizontalMirror);
800081b8:	0e 9c       	mov	r12,r7
800081ba:	cf ae       	rcall	80007fae <memory_setWriteCallback>
800081bc:	0c 9b       	mov	r11,r6
800081be:	fe ca 00 c2 	sub	r10,pc,194
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readHorizontalMirror);
800081c2:	2f f6       	sub	r6,-1
800081c4:	0e 9c       	mov	r12,r7
      memory_setReadCallback(ppuMemory, i, &mmu0_ppuMemory_readPattern);
    }
  }
  MirrorType mirrorType = cartridge_getMirrorType(cartridge);
  if (mirrorType == HORIZONTAL) {
    for (i = PPU_NAME_TABLE_1_FIRST_ADDRESS; i <= PPU_NAME_TABLE_1_LAST_ADDRESS; i++) {
800081c6:	cf 9e       	rcall	80007fb8 <memory_setReadCallback>
      // map it back to table 0
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeHorizontalMirror);
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readHorizontalMirror);
800081c8:	e0 46 28 00 	cp.w	r6,10240
800081cc:	cf 31       	brne	800081b2 <mmu0_callbackCreator+0x66>
      memory_setReadCallback(ppuMemory, i, &mmu0_ppuMemory_readPattern);
    }
  }
  MirrorType mirrorType = cartridge_getMirrorType(cartridge);
  if (mirrorType == HORIZONTAL) {
    for (i = PPU_NAME_TABLE_1_FIRST_ADDRESS; i <= PPU_NAME_TABLE_1_LAST_ADDRESS; i++) {
800081ce:	e0 66 2c 00 	mov	r6,11264
800081d2:	0c 9b       	mov	r11,r6
800081d4:	fe ca 01 14 	sub	r10,pc,276
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeHorizontalMirror);
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readHorizontalMirror);
    }
    for (i = PPU_NAME_TABLE_3_FIRST_ADDRESS; i <= PPU_NAME_TABLE_3_LAST_ADDRESS; i++) {
      // map it back to table 2
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeHorizontalMirror);
800081d8:	0e 9c       	mov	r12,r7
800081da:	ce ae       	rcall	80007fae <memory_setWriteCallback>
800081dc:	0c 9b       	mov	r11,r6
800081de:	fe ca 00 e2 	sub	r10,pc,226
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readHorizontalMirror);
800081e2:	2f f6       	sub	r6,-1
800081e4:	0e 9c       	mov	r12,r7
    for (i = PPU_NAME_TABLE_1_FIRST_ADDRESS; i <= PPU_NAME_TABLE_1_LAST_ADDRESS; i++) {
      // map it back to table 0
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeHorizontalMirror);
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readHorizontalMirror);
    }
    for (i = PPU_NAME_TABLE_3_FIRST_ADDRESS; i <= PPU_NAME_TABLE_3_LAST_ADDRESS; i++) {
800081e6:	ce 9e       	rcall	80007fb8 <memory_setReadCallback>
      // map it back to table 2
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeHorizontalMirror);
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readHorizontalMirror);
800081e8:	e0 46 30 00 	cp.w	r6,12288
800081ec:	cf 31       	brne	800081d2 <mmu0_callbackCreator+0x86>
    for (i = PPU_NAME_TABLE_1_FIRST_ADDRESS; i <= PPU_NAME_TABLE_1_LAST_ADDRESS; i++) {
      // map it back to table 0
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeHorizontalMirror);
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readHorizontalMirror);
    }
    for (i = PPU_NAME_TABLE_3_FIRST_ADDRESS; i <= PPU_NAME_TABLE_3_LAST_ADDRESS; i++) {
800081ee:	d8 22       	popm	r4-r7,pc
800081f0:	0e 9b       	mov	r11,r7
800081f2:	fe ca ff 3e 	sub	r10,pc,-194
  if (numProgramBanks == 1) {
    // mirror the first bank if there is only one
    for (i = MMU_PROGRAM_BANK_UPPER_FIRST_ADDRESS; i <=
MMU_PROGRAM_BANK_UPPER_LAST_ADDRESS; i++) {
     // memory_setWriteCallback(cpuMemory, i, &mmu0_cpuMemory_writeProgramBank0);
      memory_setReadCallback(cpuMemory, i, &mmu0_cpuMemory_readProgramBank0);
800081f6:	2f f7       	sub	r7,-1
800081f8:	5c 7b       	castu.h	r11
  //assert(numProgramBanks >= 1);
  //assert(numProgramBanks <= 2);
  if (numProgramBanks == 1) {
    // mirror the first bank if there is only one
    for (i = MMU_PROGRAM_BANK_UPPER_FIRST_ADDRESS; i <=
MMU_PROGRAM_BANK_UPPER_LAST_ADDRESS; i++) {
800081fa:	0c 9c       	mov	r12,r6
     // memory_setWriteCallback(cpuMemory, i, &mmu0_cpuMemory_writeProgramBank0);
      memory_setReadCallback(cpuMemory, i, &mmu0_cpuMemory_readProgramBank0);
800081fc:	cd ee       	rcall	80007fb8 <memory_setReadCallback>
800081fe:	e0 57 00 00 	cp.w	r7,65536
80008202:	cf 71       	brne	800081f0 <mmu0_callbackCreator+0xa4>
  // mmu0 only supports 1 or 2 program banks on the cartridge
  //assert(numProgramBanks >= 1);
  //assert(numProgramBanks <= 2);
  if (numProgramBanks == 1) {
    // mirror the first bank if there is only one
    for (i = MMU_PROGRAM_BANK_UPPER_FIRST_ADDRESS; i <=
80008204:	cc 6b       	rjmp	80008190 <mmu0_callbackCreator+0x44>
80008206:	0e 9b       	mov	r11,r7
80008208:	fe ca ff 6c 	sub	r10,pc,-148
      memory_setReadCallback(cpuMemory, i, &mmu0_cpuMemory_readProgramBank0);
    }
  } else if (numProgramBanks == 2) {
    for (i = MMU_PROGRAM_BANK_UPPER_FIRST_ADDRESS; i <=MMU_PROGRAM_BANK_UPPER_LAST_ADDRESS; i++) {
      //memory_setWriteCallback(cpuMemory, i, &mmu0_cpuMemory_writeProgramBank1);
      memory_setReadCallback(cpuMemory, i, &mmu0_cpuMemory_readProgramBank1);
8000820c:	2f f7       	sub	r7,-1
8000820e:	5c 7b       	castu.h	r11
MMU_PROGRAM_BANK_UPPER_LAST_ADDRESS; i++) {
     // memory_setWriteCallback(cpuMemory, i, &mmu0_cpuMemory_writeProgramBank0);
      memory_setReadCallback(cpuMemory, i, &mmu0_cpuMemory_readProgramBank0);
    }
  } else if (numProgramBanks == 2) {
    for (i = MMU_PROGRAM_BANK_UPPER_FIRST_ADDRESS; i <=MMU_PROGRAM_BANK_UPPER_LAST_ADDRESS; i++) {
80008210:	0c 9c       	mov	r12,r6
      //memory_setWriteCallback(cpuMemory, i, &mmu0_cpuMemory_writeProgramBank1);
      memory_setReadCallback(cpuMemory, i, &mmu0_cpuMemory_readProgramBank1);
80008212:	cd 3e       	rcall	80007fb8 <memory_setReadCallback>
80008214:	e0 57 00 00 	cp.w	r7,65536
80008218:	cf 71       	brne	80008206 <mmu0_callbackCreator+0xba>
MMU_PROGRAM_BANK_UPPER_LAST_ADDRESS; i++) {
     // memory_setWriteCallback(cpuMemory, i, &mmu0_cpuMemory_writeProgramBank0);
      memory_setReadCallback(cpuMemory, i, &mmu0_cpuMemory_readProgramBank0);
    }
  } else if (numProgramBanks == 2) {
    for (i = MMU_PROGRAM_BANK_UPPER_FIRST_ADDRESS; i <=MMU_PROGRAM_BANK_UPPER_LAST_ADDRESS; i++) {
8000821a:	cb bb       	rjmp	80008190 <mmu0_callbackCreator+0x44>
8000821c:	58 1c       	cp.w	r12,1
8000821e:	c1 20       	breq	80008242 <mmu0_callbackCreator+0xf6>
80008220:	d8 22       	popm	r4-r7,pc
    for (i = PPU_NAME_TABLE_3_FIRST_ADDRESS; i <= PPU_NAME_TABLE_3_LAST_ADDRESS; i++) {
      // map it back to table 2
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeHorizontalMirror);
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readHorizontalMirror);
    }
  } else if (mirrorType == VERTICAL) {
80008222:	30 06       	mov	r6,0
80008224:	0c 9b       	mov	r11,r6
80008226:	fe ca 00 de 	sub	r10,pc,222
  //assert(ppuMemory != NULL);
  if (numCharacterBanks == 1) {
    // dump it in the lower space of ppu memory
    for (i = PPU_PATTERN_TABLE_0_FIRST_ADDRESS; i <= PPU_PATTERN_TABLE_1_LAST_ADDRESS;
i++) {
      memory_setWriteCallback(ppuMemory, i, &mmu0_ppuMemory_writePattern);
8000822a:	0e 9c       	mov	r12,r7
8000822c:	cc 1e       	rcall	80007fae <memory_setWriteCallback>
8000822e:	0c 9b       	mov	r11,r6
80008230:	fe ca ff ac 	sub	r10,pc,-84
      memory_setReadCallback(ppuMemory, i, &mmu0_ppuMemory_readPattern);
80008234:	2f f6       	sub	r6,-1
80008236:	0e 9c       	mov	r12,r7
  Memory ppuMemory = nes_getPPUMemory(nes);
  //assert(ppuMemory != NULL);
  if (numCharacterBanks == 1) {
    // dump it in the lower space of ppu memory
    for (i = PPU_PATTERN_TABLE_0_FIRST_ADDRESS; i <= PPU_PATTERN_TABLE_1_LAST_ADDRESS;
i++) {
80008238:	cc 0e       	rcall	80007fb8 <memory_setReadCallback>
      memory_setWriteCallback(ppuMemory, i, &mmu0_ppuMemory_writePattern);
      memory_setReadCallback(ppuMemory, i, &mmu0_ppuMemory_readPattern);
8000823a:	e0 46 20 00 	cp.w	r6,8192
8000823e:	cf 31       	brne	80008224 <mmu0_callbackCreator+0xd8>
  //assert(numCharacterBanks <= 1);
  Memory ppuMemory = nes_getPPUMemory(nes);
  //assert(ppuMemory != NULL);
  if (numCharacterBanks == 1) {
    // dump it in the lower space of ppu memory
    for (i = PPU_PATTERN_TABLE_0_FIRST_ADDRESS; i <= PPU_PATTERN_TABLE_1_LAST_ADDRESS;
80008240:	cb 3b       	rjmp	800081a6 <mmu0_callbackCreator+0x5a>
80008242:	e0 66 28 00 	mov	r6,10240
80008246:	0c 9b       	mov	r11,r6
    for (i = PPU_NAME_TABLE_3_FIRST_ADDRESS; i <= PPU_NAME_TABLE_3_LAST_ADDRESS; i++) {
      // map it back to table 2
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeHorizontalMirror);
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readHorizontalMirror);
    }
  } else if (mirrorType == VERTICAL) {
80008248:	fe ca 01 a8 	sub	r10,pc,424
    // Vertical mirroring: $2000 equals $2800 and $2400 equals $2C00 (e.g. Super MarioBros.)
    for (i = PPU_NAME_TABLE_2_FIRST_ADDRESS; i <= PPU_NAME_TABLE_2_LAST_ADDRESS; i++) {
      // map it back to table 0
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeVerticalMirror);
8000824c:	0e 9c       	mov	r12,r7
8000824e:	cb 0e       	rcall	80007fae <memory_setWriteCallback>
80008250:	0c 9b       	mov	r11,r6
80008252:	fe ca 01 72 	sub	r10,pc,370
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readVerticalMirror);
80008256:	2f f6       	sub	r6,-1
80008258:	0e 9c       	mov	r12,r7
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeHorizontalMirror);
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readHorizontalMirror);
    }
  } else if (mirrorType == VERTICAL) {
    // Vertical mirroring: $2000 equals $2800 and $2400 equals $2C00 (e.g. Super MarioBros.)
    for (i = PPU_NAME_TABLE_2_FIRST_ADDRESS; i <= PPU_NAME_TABLE_2_LAST_ADDRESS; i++) {
8000825a:	ca fe       	rcall	80007fb8 <memory_setReadCallback>
      // map it back to table 0
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeVerticalMirror);
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readVerticalMirror);
8000825c:	e0 46 2c 00 	cp.w	r6,11264
80008260:	cf 31       	brne	80008246 <mmu0_callbackCreator+0xfa>
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeHorizontalMirror);
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readHorizontalMirror);
    }
  } else if (mirrorType == VERTICAL) {
    // Vertical mirroring: $2000 equals $2800 and $2400 equals $2C00 (e.g. Super MarioBros.)
    for (i = PPU_NAME_TABLE_2_FIRST_ADDRESS; i <= PPU_NAME_TABLE_2_LAST_ADDRESS; i++) {
80008262:	0c 9b       	mov	r11,r6
80008264:	fe ca 01 c4 	sub	r10,pc,452
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeVerticalMirror);
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readVerticalMirror);
    }
    for (i = PPU_NAME_TABLE_3_FIRST_ADDRESS; i <= PPU_NAME_TABLE_3_LAST_ADDRESS; i++) {
      // map it back to table 1
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeVerticalMirror);
80008268:	0e 9c       	mov	r12,r7
8000826a:	ca 2e       	rcall	80007fae <memory_setWriteCallback>
8000826c:	0c 9b       	mov	r11,r6
8000826e:	fe ca 01 8e 	sub	r10,pc,398
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readVerticalMirror);
80008272:	2f f6       	sub	r6,-1
80008274:	0e 9c       	mov	r12,r7
    for (i = PPU_NAME_TABLE_2_FIRST_ADDRESS; i <= PPU_NAME_TABLE_2_LAST_ADDRESS; i++) {
      // map it back to table 0
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeVerticalMirror);
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readVerticalMirror);
    }
    for (i = PPU_NAME_TABLE_3_FIRST_ADDRESS; i <= PPU_NAME_TABLE_3_LAST_ADDRESS; i++) {
80008276:	ca 1e       	rcall	80007fb8 <memory_setReadCallback>
      // map it back to table 1
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeVerticalMirror);
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readVerticalMirror);
80008278:	e0 46 30 00 	cp.w	r6,12288
8000827c:	cf 31       	brne	80008262 <mmu0_callbackCreator+0x116>
    for (i = PPU_NAME_TABLE_2_FIRST_ADDRESS; i <= PPU_NAME_TABLE_2_LAST_ADDRESS; i++) {
      // map it back to table 0
      memory_setWriteCallback(ppuMemory, i, &mmu_ppuMemory_writeVerticalMirror);
      memory_setReadCallback(ppuMemory, i, &mmu_ppuMemory_readVerticalMirror);
    }
    for (i = PPU_NAME_TABLE_3_FIRST_ADDRESS; i <= PPU_NAME_TABLE_3_LAST_ADDRESS; i++) {
8000827e:	cd 1b       	rjmp	80008220 <mmu0_callbackCreator+0xd4>
80008280:	80 01       	ld.sh	r1,r0[0x0]
80008282:	7c f0       	ld.w	r0,lr[0x3c]

80008284 <mmu0_ppuMemory_readPattern>:
80008284:	eb cd 40 80 	pushm	r7,lr
80008288:	16 97       	mov	r7,r11
8000828a:	c2 fc       	rcall	800082e8 <nes_getCartridge>
8000828c:	0e 9a       	mov	r10,r7
8000828e:	30 0b       	mov	r11,0
80008290:	5c 7a       	castu.h	r10
80008292:	fe b0 f0 46 	rcall	8000631e <cartridge_readCharacterBank>
80008296:	e3 cd 80 80 	ldm	sp++,r7,pc
8000829a:	d7 03       	nop

8000829c <mmu0_cpuMemory_readProgramBank1>:
8000829c:	eb cd 40 80 	pushm	r7,lr
800082a0:	16 97       	mov	r7,r11
800082a2:	c2 3c       	rcall	800082e8 <nes_getCartridge>
800082a4:	ee ca c0 00 	sub	r10,r7,-16384
800082a8:	30 1b       	mov	r11,1
800082aa:	5c 7a       	castu.h	r10
800082ac:	fe b0 f0 32 	rcall	80006310 <cartridge_readProgramBank>
800082b0:	e3 cd 80 80 	ldm	sp++,r7,pc

800082b4 <mmu0_cpuMemory_readProgramBank0>:
800082b4:	eb cd 40 80 	pushm	r7,lr
800082b8:	16 97       	mov	r7,r11
800082ba:	c1 7c       	rcall	800082e8 <nes_getCartridge>
800082bc:	0e 9a       	mov	r10,r7
800082be:	30 0b       	mov	r11,0
800082c0:	e0 2a 80 00 	sub	r10,32768
800082c4:	5c 7a       	castu.h	r10
800082c6:	fe b0 f0 25 	rcall	80006310 <cartridge_readProgramBank>
800082ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800082ce:	d7 03       	nop

800082d0 <nes_getObjectAttributeMemory>:
}
Memory nes_getObjectAttributeMemory(NES nes) {
  //assert(nes != NULL);
  //assert(nes->objectAttributeMemory != NULL);
  return nes->objectAttributeMemory;
}
800082d0:	78 2c       	ld.w	r12,r12[0x8]
800082d2:	5e fc       	retal	r12

800082d4 <nes_getGUI>:
}
GUI nes_getGUI(NES nes) {
  //assert(nes != NULL);
  //assert(nes->gui != NULL);
  return nes->gui;
}
800082d4:	78 ac       	ld.w	r12,r12[0x28]
800082d6:	5e fc       	retal	r12

800082d8 <nes_getCPUMemory>:
Memory nes_getCPUMemory(NES nes) {
  //assert(nes != NULL);
  return nes->cpuMemory;
}
800082d8:	78 0c       	ld.w	r12,r12[0x0]
800082da:	5e fc       	retal	r12

800082dc <nes_getPPUMemory>:
Memory nes_getPPUMemory(NES nes) {
  //assert(nes != NULL);
  return nes->ppuMemory;
}
800082dc:	78 1c       	ld.w	r12,r12[0x4]
800082de:	5e fc       	retal	r12

800082e0 <nes_getCPU>:
CPU nes_getCPU(NES nes) {
  //assert(nes != NULL);
  return nes->cpu1;
}
800082e0:	78 3c       	ld.w	r12,r12[0xc]
800082e2:	5e fc       	retal	r12

800082e4 <nes_getPPU>:
PPU nes_getPPU(NES nes) {
  //assert(nes != NULL);
  return nes->ppu;
}
800082e4:	78 4c       	ld.w	r12,r12[0x10]
800082e6:	5e fc       	retal	r12

800082e8 <nes_getCartridge>:
Cartridge nes_getCartridge(NES nes) {
 // //assert(nes != NULL);
  return nes->cartridge;
}
800082e8:	78 6c       	ld.w	r12,r12[0x18]
800082ea:	5e fc       	retal	r12

800082ec <nes_writePPUMemory>:
Byte nes_readPPUMemory(NES nes, Address address) {
  //assert(nes != NULL);
  address = nes_getLowPPUAddress(address);
  return memory_read_callback(nes, nes_getPPUMemory(nes), address);
}
void nes_writePPUMemory(NES nes, Address address, Byte data) {
800082ec:	d4 01       	pushm	lr
800082ee:	14 99       	mov	r9,r10
800082f0:	18 98       	mov	r8,r12
}
// the PPU has 64kb of address space but can only access 16kb of it
// we handle the "big picture" ppu mirrors here (the four 16kb mirrors)
// and we handle the smaller mirrors (mirrors within mirrors) with callbacks
static Address nes_getLowPPUAddress(Address address) {
  while(address > PPU_LAST_REAL_ADDRESS) {
800082f2:	e0 6a 3f ff 	mov	r10,16383
800082f6:	f4 0b 19 00 	cp.h	r11,r10
800082fa:	e0 88 00 04 	brls	80008302 <nes_writePPUMemory+0x16>
Byte nes_readPPUMemory(NES nes, Address address) {
  //assert(nes != NULL);
  address = nes_getLowPPUAddress(address);
  return memory_read_callback(nes, nes_getPPUMemory(nes), address);
}
void nes_writePPUMemory(NES nes, Address address, Byte data) {
800082fe:	f7 db c0 0e 	bfextu	r11,r11,0x0,0xe
  //assert(nes != NULL);
  address = nes_getLowPPUAddress(address);
  memory_write_callback(nes, nes_getPPUMemory(nes), address, data);
80008302:	f5 db c0 10 	bfextu	r10,r11,0x0,0x10
80008306:	10 9c       	mov	r12,r8
80008308:	70 1b       	ld.w	r11,r8[0x4]
8000830a:	c5 ce       	rcall	80007fc2 <memory_write_callback>
8000830c:	d8 02       	popm	pc
}
8000830e:	d7 03       	nop

80008310 <nes_writeObjectAttributeMemory>:
80008310:	d4 01       	pushm	lr
80008312:	14 99       	mov	r9,r10
  return memory_read_callback(nes, nes->objectAttributeMemory, address);
}
void nes_writeObjectAttributeMemory(NES nes, Address address, Byte data) {
  //assert(nes != NULL);
  //assert(nes->objectAttributeMemory != NULL);
  memory_write_callback(nes, nes->objectAttributeMemory, address, data);
80008314:	f5 db c0 10 	bfextu	r10,r11,0x0,0x10
80008318:	78 2b       	ld.w	r11,r12[0x8]
8000831a:	c5 4e       	rcall	80007fc2 <memory_write_callback>
8000831c:	d8 02       	popm	pc
}
8000831e:	d7 03       	nop

80008320 <nes_writeCPUMemory>:
80008320:	d4 01       	pushm	lr
80008322:	14 99       	mov	r9,r10
  return data;
}
void nes_writeCPUMemory(NES nes, Address address, Byte data) {
  //assert(nes != NULL);
  //assert(nes->cpuMemory != NULL);
  memory_write_callback(nes, nes->cpuMemory, address, data);
80008324:	f5 db c0 10 	bfextu	r10,r11,0x0,0x10
80008328:	78 0b       	ld.w	r11,r12[0x0]
8000832a:	c4 ce       	rcall	80007fc2 <memory_write_callback>
8000832c:	d8 02       	popm	pc
  //nes_cpuCycled(nes);
}
8000832e:	d7 03       	nop

80008330 <nes_readPPUMemory>:
80008330:	d4 01       	pushm	lr
80008332:	e0 69 3f ff 	mov	r9,16383
    address -= PPU_NUM_REAL_ADDRESSES;
  }
  //assert(address <= PPU_LAST_REAL_ADDRESS);
  return address;
}
Byte nes_readPPUMemory(NES nes, Address address) {
80008336:	18 98       	mov	r8,r12
}
// the PPU has 64kb of address space but can only access 16kb of it
// we handle the "big picture" ppu mirrors here (the four 16kb mirrors)
// and we handle the smaller mirrors (mirrors within mirrors) with callbacks
static Address nes_getLowPPUAddress(Address address) {
  while(address > PPU_LAST_REAL_ADDRESS) {
80008338:	f2 0b 19 00 	cp.h	r11,r9
8000833c:	e0 88 00 04 	brls	80008344 <nes_readPPUMemory+0x14>
    address -= PPU_NUM_REAL_ADDRESSES;
  }
  //assert(address <= PPU_LAST_REAL_ADDRESS);
  return address;
}
Byte nes_readPPUMemory(NES nes, Address address) {
80008340:	f7 db c0 0e 	bfextu	r11,r11,0x0,0xe
  //assert(nes != NULL);
  address = nes_getLowPPUAddress(address);
  return memory_read_callback(nes, nes_getPPUMemory(nes), address);
80008344:	f5 db c0 10 	bfextu	r10,r11,0x0,0x10
80008348:	10 9c       	mov	r12,r8
8000834a:	70 1b       	ld.w	r11,r8[0x4]
8000834c:	c4 be       	rcall	80007fe2 <memory_read_callback>
8000834e:	d8 02       	popm	pc

80008350 <nes_readObjectAttributeMemory>:
}
80008350:	d4 01       	pushm	lr
80008352:	f5 db c0 10 	bfextu	r10,r11,0x0,0x10
80008356:	78 2b       	ld.w	r11,r12[0x8]
  //nes_cpuCycled(nes);
}
Byte nes_readObjectAttributeMemory(NES nes, Address address) {
  //assert(nes != NULL);
  //assert(nes->objectAttributeMemory != NULL);
  return memory_read_callback(nes, nes->objectAttributeMemory, address);
80008358:	c4 5e       	rcall	80007fe2 <memory_read_callback>
8000835a:	d8 02       	popm	pc

8000835c <nes_generateNMI>:
}
8000835c:	d4 01       	pushm	lr
8000835e:	30 1b       	mov	r11,1
80008360:	78 7c       	ld.w	r12,r12[0x1c]
80008362:	fe b0 fd e3 	rcall	80007f28 <interrupts_setNMI>
}
void nes_generateNMI(NES nes) {
  //assert(nes != NULL);
  //usart_write_line(&AVR32_USART0,"generateNMI\n");
  interrupts_setNMI(nes->interrupts, TRUE);
}
80008366:	d8 02       	popm	pc

80008368 <nes_run>:
80008368:	eb cd 40 e0 	pushm	r5-r7,lr
  //assert(nes != NULL);
  nes->isRunning = !gui_receivedTerminationRequest(nes->gui);
}
void nes_run(NES nes) {
  ////assert(nes != NULL);
  while(nes->isRunning == TRUE) {
8000836c:	30 18       	mov	r8,1
}
static void nes_checkKeyboard(NES nes) {
  //assert(nes != NULL);
  nes->isRunning = !gui_receivedTerminationRequest(nes->gui);
}
void nes_run(NES nes) {
8000836e:	18 97       	mov	r7,r12
  ////assert(nes != NULL);
  while(nes->isRunning == TRUE) {
80008370:	f9 36 00 24 	ld.ub	r6,r12[36]
80008374:	f0 06 18 00 	cp.b	r6,r8
80008378:	c1 50       	breq	800083a2 <nes_run+0x3a>
8000837a:	c4 18       	rjmp	800083fc <nes_run+0x94>
   // usart_write_line(&AVR32_USART0,"nes_run\n");
    if (interrupts_getRESET(nes->interrupts) == TRUE) {
     // usart_write_line(&AVR32_USART0,"RESET\n");
      interrupts_setRESET(nes->interrupts, FALSE);
      cpu_handleInterrupt(nes, CPU_RESET_VECTOR_LOWER_ADDRESS, FALSE);
    } else if (interrupts_getNMI(nes->interrupts) == TRUE) {
8000837c:	6e 7c       	ld.w	r12,r7[0x1c]
8000837e:	fe b0 fd cf 	rcall	80007f1c <interrupts_getNMI>
80008382:	ec 0c 18 00 	cp.b	r12,r6
80008386:	c1 f0       	breq	800083c4 <nes_run+0x5c>
      //usart_write_line(&AVR32_USART0,"NMI\n");
      interrupts_setNMI(nes->interrupts, FALSE);
      cpu_handleInterrupt(nes, CPU_NMI_VECTOR_LOWER_ADDRESS, FALSE);
    } else if ((cpu_getInterruptDisable(nes->cpu1) == FALSE) && (interrupts_getIRQ(nes->interrupts) == TRUE)) {
80008388:	6e 3c       	ld.w	r12,r7[0xc]
8000838a:	fe b0 f1 83 	rcall	80006690 <cpu_getInterruptDisable>
8000838e:	18 95       	mov	r5,r12
80008390:	c2 50       	breq	800083da <nes_run+0x72>
      //usart_write_line(&AVR32_USART0,"IRQ\n");
      interrupts_setIRQ(nes->interrupts, FALSE);
      cpu_handleInterrupt(nes, CPU_IRQ_VECTOR_LOWER_ADDRESS, FALSE);
    }
	//usart_write_line(&AVR32_USART0,"step");
    cpu_step(nes);
80008392:	0e 9c       	mov	r12,r7
80008394:	fe b0 f3 1c 	rcall	800069cc <cpu_step>
  //assert(nes != NULL);
  nes->isRunning = !gui_receivedTerminationRequest(nes->gui);
}
void nes_run(NES nes) {
  ////assert(nes != NULL);
  while(nes->isRunning == TRUE) {
80008398:	ef 38 00 24 	ld.ub	r8,r7[36]
8000839c:	ec 08 18 00 	cp.b	r8,r6
800083a0:	c2 e1       	brne	800083fc <nes_run+0x94>
   // usart_write_line(&AVR32_USART0,"nes_run\n");
    if (interrupts_getRESET(nes->interrupts) == TRUE) {
800083a2:	6e 7c       	ld.w	r12,r7[0x1c]
800083a4:	fe b0 fd be 	rcall	80007f20 <interrupts_getRESET>
800083a8:	ec 0c 18 00 	cp.b	r12,r6
800083ac:	ce 81       	brne	8000837c <nes_run+0x14>
     // usart_write_line(&AVR32_USART0,"RESET\n");
      interrupts_setRESET(nes->interrupts, FALSE);
800083ae:	6e 7c       	ld.w	r12,r7[0x1c]
800083b0:	30 0b       	mov	r11,0
800083b2:	fe b0 fd bd 	rcall	80007f2c <interrupts_setRESET>
      cpu_handleInterrupt(nes, CPU_RESET_VECTOR_LOWER_ADDRESS, FALSE);
800083b6:	30 0a       	mov	r10,0
800083b8:	e0 6b ff fc 	mov	r11,65532
800083bc:	0e 9c       	mov	r12,r7
800083be:	fe b0 f2 ab 	rcall	80006914 <cpu_handleInterrupt>
800083c2:	ce 8b       	rjmp	80008392 <nes_run+0x2a>
    } else if (interrupts_getNMI(nes->interrupts) == TRUE) {
      //usart_write_line(&AVR32_USART0,"NMI\n");
      interrupts_setNMI(nes->interrupts, FALSE);
800083c4:	6e 7c       	ld.w	r12,r7[0x1c]
800083c6:	30 0b       	mov	r11,0
800083c8:	fe b0 fd b0 	rcall	80007f28 <interrupts_setNMI>
      cpu_handleInterrupt(nes, CPU_NMI_VECTOR_LOWER_ADDRESS, FALSE);
800083cc:	30 0a       	mov	r10,0
800083ce:	e0 6b ff fa 	mov	r11,65530
800083d2:	0e 9c       	mov	r12,r7
800083d4:	fe b0 f2 a0 	rcall	80006914 <cpu_handleInterrupt>
800083d8:	cd db       	rjmp	80008392 <nes_run+0x2a>
    } else if ((cpu_getInterruptDisable(nes->cpu1) == FALSE) && (interrupts_getIRQ(nes->interrupts) == TRUE)) {
800083da:	6e 7c       	ld.w	r12,r7[0x1c]
800083dc:	fe b0 fd 9e 	rcall	80007f18 <interrupts_getIRQ>
800083e0:	ec 0c 18 00 	cp.b	r12,r6
800083e4:	cd 71       	brne	80008392 <nes_run+0x2a>
      //usart_write_line(&AVR32_USART0,"IRQ\n");
      interrupts_setIRQ(nes->interrupts, FALSE);
800083e6:	0a 9b       	mov	r11,r5
800083e8:	6e 7c       	ld.w	r12,r7[0x1c]
800083ea:	fe b0 fd 9d 	rcall	80007f24 <interrupts_setIRQ>
      cpu_handleInterrupt(nes, CPU_IRQ_VECTOR_LOWER_ADDRESS, FALSE);
800083ee:	0a 9a       	mov	r10,r5
800083f0:	e0 6b ff fe 	mov	r11,65534
800083f4:	0e 9c       	mov	r12,r7
800083f6:	fe b0 f2 8f 	rcall	80006914 <cpu_handleInterrupt>
800083fa:	cc cb       	rjmp	80008392 <nes_run+0x2a>
800083fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80008400 <nes_writeJoypad>:
80008400:	eb cd 40 80 	pushm	r7,lr
80008404:	18 97       	mov	r7,r12
80008406:	58 0b       	cp.w	r11,0
80008408:	c0 f1       	brne	80008426 <nes_writeJoypad+0x26>
8000840a:	ed ba 00 00 	bld	r10,0x0
8000840e:	c0 90       	breq	80008420 <nes_writeJoypad+0x20>
80008410:	78 bc       	ld.w	r12,r12[0x2c]
80008412:	fe b0 fd 99 	rcall	80007f44 <joypad_resetCurrentButton>
80008416:	6e cc       	ld.w	r12,r7[0x30]
80008418:	fe b0 fd 96 	rcall	80007f44 <joypad_resetCurrentButton>
8000841c:	e3 cd 80 80 	ldm	sp++,r7,pc
80008420:	78 ac       	ld.w	r12,r12[0x28]
80008422:	fe b0 fd 19 	rcall	80007e54 <gui_queryInput>
void nes_writeJoypad(NES nes, int joypadNumber, Byte data) {
  //assert(nes != NULL);
  //assert(joypadNumber < NES_NUM_JOYPADS);
  if (joypadNumber == 0) {
    if ((data & MASK_BIT0) == MASK_BIT0) {
      gui_queryInput(nes->gui);
80008426:	e3 cd 80 80 	ldm	sp++,r7,pc
8000842a:	d7 03       	nop

8000842c <nes_readJoypad>:
8000842c:	d4 01       	pushm	lr
8000842e:	2f 5b       	sub	r11,-11
80008430:	f8 0b 03 2b 	ld.w	r11,r12[r11<<0x2]
  return nes;
}
Byte nes_readJoypad(NES nes, int joypadNumber) {
  //assert(nes != NULL);
  //assert(joypadNumber < NES_NUM_JOYPADS);
  return joypad_readByte(nes, nes->joypads[joypadNumber]);
80008434:	fe b0 fd 8c 	rcall	80007f4c <joypad_readByte>
}
80008438:	d8 02       	popm	pc
8000843a:	d7 03       	nop

8000843c <nes_init>:
8000843c:	eb cd 40 f8 	pushm	r3-r7,lr
  for (i=0; i < NES_NUM_JOYPADS; i++) {
    nes->joypads[i] = joypad_init(i);
    //assert(nes->joypads[i] != NULL);
  }
}
NES nes_init(int filename, int width, int height) {
80008440:	14 94       	mov	r4,r10
80008442:	16 95       	mov	r5,r11
80008444:	18 93       	mov	r3,r12
  NES nes = (NES) malloc(sizeof(struct nes));
80008446:	33 4c       	mov	r12,52
80008448:	e0 a0 3d 5a 	rcall	8000fefc <malloc>
  //assert(nes != NULL);
  nes->cartridge = NULL;
8000844c:	30 06       	mov	r6,0
    nes->joypads[i] = joypad_init(i);
    //assert(nes->joypads[i] != NULL);
  }
}
NES nes_init(int filename, int width, int height) {
  NES nes = (NES) malloc(sizeof(struct nes));
8000844e:	18 97       	mov	r7,r12
  //assert(nes != NULL);
  nes->cartridge = NULL;
80008450:	99 66       	st.w	r12[0x18],r6
  nes->ppuMemory = NULL;
80008452:	99 16       	st.w	r12[0x4],r6
  nes->cpuMemory = NULL;
80008454:	99 06       	st.w	r12[0x0],r6
  nes->ppu = NULL;
80008456:	99 46       	st.w	r12[0x10],r6
  nes->cpu1 = NULL;
80008458:	99 36       	st.w	r12[0xc],r6
  nes->apu = NULL;
8000845a:	99 56       	st.w	r12[0x14],r6
  nes->interrupts = NULL;
8000845c:	99 76       	st.w	r12[0x1c],r6
  nes->mmu = NULL;
8000845e:	99 86       	st.w	r12[0x20],r6
  nes->objectAttributeMemory = NULL;
80008460:	99 26       	st.w	r12[0x8],r6
  nes->gui = NULL;
80008462:	99 a6       	st.w	r12[0x28],r6
  usart_write_line(&AVR32_USART0,"Initial cpuMemory1\n");
80008464:	4a 3b       	lddpc	r11,800084f0 <nes_init+0xb4>
80008466:	fe 7c 14 00 	mov	r12,-60416
8000846a:	e0 a0 1c 94 	rcall	8000bd92 <usart_write_line>
  ////assert(nes->ppuMemory != NULL);
}
static void nes_init_cpuMemory(NES nes) {
 //assert(nes != NULL);
 //assert(nes->cpuMemory == NULL);
  nes->cpuMemory = cpuMemory_init();
8000846e:	fe b0 fa e9 	rcall	80007a40 <cpuMemory_init>
  nes->mmu = NULL;
  nes->objectAttributeMemory = NULL;
  nes->gui = NULL;
  usart_write_line(&AVR32_USART0,"Initial cpuMemory1\n");
  nes_init_cpuMemory(nes);
   usart_write_line(&AVR32_USART0,"Initial cpuMemory2\n");
80008472:	4a 1b       	lddpc	r11,800084f4 <nes_init+0xb8>
  ////assert(nes->ppuMemory != NULL);
}
static void nes_init_cpuMemory(NES nes) {
 //assert(nes != NULL);
 //assert(nes->cpuMemory == NULL);
  nes->cpuMemory = cpuMemory_init();
80008474:	8f 0c       	st.w	r7[0x0],r12
  nes->mmu = NULL;
  nes->objectAttributeMemory = NULL;
  nes->gui = NULL;
  usart_write_line(&AVR32_USART0,"Initial cpuMemory1\n");
  nes_init_cpuMemory(nes);
   usart_write_line(&AVR32_USART0,"Initial cpuMemory2\n");
80008476:	fe 7c 14 00 	mov	r12,-60416
8000847a:	e0 a0 1c 8c 	rcall	8000bd92 <usart_write_line>
  //assert(nes->cartridge != NULL);
}
static void nes_init_ppuMemory(NES nes) {
  ////assert(nes != NULL);
  ////assert(nes->ppuMemory == NULL);
  nes->ppuMemory = ppuMemory_init();
8000847e:	e0 a0 06 07 	rcall	8000908c <ppuMemory_init>
  nes->gui = NULL;
  usart_write_line(&AVR32_USART0,"Initial cpuMemory1\n");
  nes_init_cpuMemory(nes);
   usart_write_line(&AVR32_USART0,"Initial cpuMemory2\n");
  nes_init_ppuMemory(nes);
   usart_write_line(&AVR32_USART0,"Initial cpuMemory3\n");
80008482:	49 eb       	lddpc	r11,800084f8 <nes_init+0xbc>
  //assert(nes->cartridge != NULL);
}
static void nes_init_ppuMemory(NES nes) {
  ////assert(nes != NULL);
  ////assert(nes->ppuMemory == NULL);
  nes->ppuMemory = ppuMemory_init();
80008484:	8f 1c       	st.w	r7[0x4],r12
  nes->gui = NULL;
  usart_write_line(&AVR32_USART0,"Initial cpuMemory1\n");
  nes_init_cpuMemory(nes);
   usart_write_line(&AVR32_USART0,"Initial cpuMemory2\n");
  nes_init_ppuMemory(nes);
   usart_write_line(&AVR32_USART0,"Initial cpuMemory3\n");
80008486:	fe 7c 14 00 	mov	r12,-60416
8000848a:	e0 a0 1c 84 	rcall	8000bd92 <usart_write_line>
  //assert(nes->apu != NULL);
}
static void nes_init_cartridge(NES nes, int filename) {
  //assert(nes != NULL);
  //assert(nes->cartridge == NULL);
  nes->cartridge = cartridge_init(filename);
8000848e:	06 9c       	mov	r12,r3
80008490:	fe b0 ef 9a 	rcall	800063c4 <cartridge_init>
80008494:	8f 6c       	st.w	r7[0x18],r12
  //assert(nes->ppu != NULL);
}
static void nes_init_apu(NES nes) {
  //assert(nes != NULL);
  //assert(nes->apu == NULL);
  nes->apu = apu_init();
80008496:	fe b0 ef 09 	rcall	800062a8 <apu_init>
8000849a:	8f 5c       	st.w	r7[0x14],r12
}

static void nes_init_cpu(NES nes) {
  //assert(nes != NULL);
  //assert(nes->cpu1 == NULL);
  nes->cpu1 = cpu_init();
8000849c:	fe b0 f2 2e 	rcall	800068f8 <cpu_init>
800084a0:	8f 3c       	st.w	r7[0xc],r12
  //assert(nes->cpu1 != NULL);
}
static void nes_init_ppu(NES nes) {
  //assert(nes != NULL);
  //assert(nes->ppu == NULL);
  nes->ppu = ppu_init();
800084a2:	e0 a0 03 bd 	rcall	80008c1c <ppu_init>
800084a6:	8f 4c       	st.w	r7[0x10],r12
  Joypad joypads[NES_NUM_JOYPADS];
};
static void nes_init_interrupts(NES nes) {
  //assert(nes != NULL);
  //assert(nes->interrupts == NULL);
  nes->interrupts = interrupts_init();
800084a8:	fe b0 fd 44 	rcall	80007f30 <interrupts_init>
  //assert(nes->interrupts != NULL);
  interrupts_setRESET(nes->interrupts, TRUE);
800084ac:	30 1b       	mov	r11,1
  Joypad joypads[NES_NUM_JOYPADS];
};
static void nes_init_interrupts(NES nes) {
  //assert(nes != NULL);
  //assert(nes->interrupts == NULL);
  nes->interrupts = interrupts_init();
800084ae:	8f 7c       	st.w	r7[0x1c],r12
  //assert(nes->interrupts != NULL);
  interrupts_setRESET(nes->interrupts, TRUE);
800084b0:	fe b0 fd 3e 	rcall	80007f2c <interrupts_setRESET>
  //assert(nes->mmu != NULL);
}
static void nes_init_objectAttributeMemory(NES nes) {
  //assert(nes != NULL);
  //assert(nes->objectAttributeMemory == NULL);
  nes->objectAttributeMemory = objectAttributeMemory_init();
800084b4:	c6 4c       	rcall	8000857c <objectAttributeMemory_init>
800084b6:	08 9b       	mov	r11,r4
  interrupts_setNMI(nes->interrupts, TRUE);
}
static void nes_init_gui(NES nes, int width, int height) {
  //assert(nes != NULL);
  //assert(nes->gui == NULL);
  nes->gui = gui_init(width, height);
800084b8:	8f 2c       	st.w	r7[0x8],r12
  //assert(nes->mmu != NULL);
}
static void nes_init_objectAttributeMemory(NES nes) {
  //assert(nes != NULL);
  //assert(nes->objectAttributeMemory == NULL);
  nes->objectAttributeMemory = objectAttributeMemory_init();
800084ba:	0a 9c       	mov	r12,r5
  interrupts_setNMI(nes->interrupts, TRUE);
}
static void nes_init_gui(NES nes, int width, int height) {
  //assert(nes != NULL);
  //assert(nes->gui == NULL);
  nes->gui = gui_init(width, height);
800084bc:	fe b0 fc f2 	rcall	80007ea0 <gui_init>
800084c0:	8f ac       	st.w	r7[0x28],r12
800084c2:	0c 9c       	mov	r12,r6
}
static void nes_init_joypads(NES nes) {
  //assert(nes != NULL);
  int i;
  for (i=0; i < NES_NUM_JOYPADS; i++) {
    nes->joypads[i] = joypad_init(i);
800084c4:	fe b0 fd 64 	rcall	80007f8c <joypad_init>
800084c8:	8f bc       	st.w	r7[0x2c],r12
800084ca:	30 1c       	mov	r12,1
800084cc:	fe b0 fd 60 	rcall	80007f8c <joypad_init>
800084d0:	8f cc       	st.w	r7[0x30],r12
800084d2:	0e 9c       	mov	r12,r7
 //assert(nes->cpuMemory != NULL);
}
static void nes_init_mmu(NES nes) {
  //assert(nes != NULL);
  //assert(nes->mmu == NULL);
  nes->mmu = mmu_init(nes);
800084d4:	c2 2e       	rcall	80008118 <mmu_init>
800084d6:	48 ab       	lddpc	r11,800084fc <nes_init+0xc0>
800084d8:	8f 8c       	st.w	r7[0x20],r12
 // memory_print(nes, nes->cpuMemory);
  //usart_write_line(&AVR32_USART0,"\n");
  //usart_write_line(&AVR32_USART0,"Initial ppuMemory\n");
 // memory_print(nes, nes->ppuMemory);
  //usart_write_line(&AVR32_USART0,"\n");
  usart_write_line(&AVR32_USART0,"Initial objectAttributeMemory\n");
800084da:	fe 7c 14 00 	mov	r12,-60416
800084de:	e0 a0 1c 5a 	rcall	8000bd92 <usart_write_line>
800084e2:	30 18       	mov	r8,1
800084e4:	0e 9c       	mov	r12,r7
  //memory_print(nes, nes->objectAttributeMemory);
  nes->isRunning = TRUE;
800084e6:	ef 68 00 24 	st.b	r7[36],r8
800084ea:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
  return nes;
}
800084ee:	d7 03       	nop
800084f0:	80 01       	ld.sh	r1,r0[0x0]
800084f2:	7d 08       	ld.w	r8,lr[0x40]
800084f4:	80 01       	ld.sh	r1,r0[0x0]
800084f6:	7d 1c       	ld.w	r12,lr[0x44]
800084f8:	80 01       	ld.sh	r1,r0[0x0]
800084fa:	7d 30       	ld.w	r0,lr[0x4c]
800084fc:	80 01       	ld.sh	r1,r0[0x0]
800084fe:	7d 44       	ld.w	r4,lr[0x50]

80008500 <nes_readCPUMemory>:
80008500:	eb cd 40 c0 	pushm	r6-r7,lr
80008504:	18 97       	mov	r7,r12
80008506:	f5 db c0 10 	bfextu	r10,r11,0x0,0x10
8000850a:	78 0b       	ld.w	r11,r12[0x0]
8000850c:	fe b0 fd 6b 	rcall	80007fe2 <memory_read_callback>
80008510:	18 96       	mov	r6,r12
80008512:	0e 9c       	mov	r12,r7
80008514:	e0 a0 03 bc 	rcall	80008c8c <ppu_step>
80008518:	0e 9c       	mov	r12,r7
8000851a:	e0 a0 03 b9 	rcall	80008c8c <ppu_step>
8000851e:	0e 9c       	mov	r12,r7
80008520:	e0 a0 03 b6 	rcall	80008c8c <ppu_step>
80008524:	0c 9c       	mov	r12,r6
80008526:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000852a:	d7 03       	nop

8000852c <objectAttributeMemory_getX>:
    return FALSE;
  }
}
// byte 3
// 3    -      scanline pixel coordite of most left-hand side of object.
Byte objectAttributeMemory_getX(Memory memory, int spriteIndex) {
8000852c:	d4 01       	pushm	lr
  //assert(memory != NULL);
  Byte address = (OAM_BYTES_PER_SPRITE * spriteIndex) + OAM_X_BYTE_OFFSET;
  return memory_read_direct(memory, address);
8000852e:	a3 6b       	lsl	r11,0x2
80008530:	2f db       	sub	r11,-3
80008532:	5c 5b       	castu.b	r11
80008534:	fe b0 fd 38 	rcall	80007fa4 <memory_read_direct>
80008538:	d8 02       	popm	pc
8000853a:	d7 03       	nop

8000853c <objectAttributeMemory_getTileNumber>:
8000853c:	eb cd 40 80 	pushm	r7,lr
}
Byte objectAttributeMemory_getTileNumber(Memory memory, int spriteIndex, Bool
using8x16) {
  //assert(memory != NULL);
  Byte address = (OAM_BYTES_PER_SPRITE * spriteIndex) + OAM_TILE_BYTE_OFFSET;
  Byte data = memory_read_direct(memory, address);
80008540:	a3 6b       	lsl	r11,0x2
  } else {
    return 0;
  }
}
Byte objectAttributeMemory_getTileNumber(Memory memory, int spriteIndex, Bool
using8x16) {
80008542:	14 97       	mov	r7,r10
  //assert(memory != NULL);
  Byte address = (OAM_BYTES_PER_SPRITE * spriteIndex) + OAM_TILE_BYTE_OFFSET;
  Byte data = memory_read_direct(memory, address);
80008544:	2f fb       	sub	r11,-1
80008546:	5c 5b       	castu.b	r11
80008548:	fe b0 fd 2e 	rcall	80007fa4 <memory_read_direct>
  if (using8x16 == FALSE) {
8000854c:	58 07       	cp.w	r7,0
8000854e:	c0 30       	breq	80008554 <objectAttributeMemory_getTileNumber+0x18>
    return data;
  } else {
    // lose the 0th bit
    return (data >> 1) << 1;
80008550:	e2 1c 00 fe 	andl	r12,0xfe,COH
  }
}
80008554:	e3 cd 80 80 	ldm	sp++,r7,pc

80008558 <objectAttributeMemory_getBankNumber>:
80008558:	d4 01       	pushm	lr
8000855a:	a3 6b       	lsl	r11,0x2
// byte 1
// only valid for 8x16 sprites
Byte objectAttributeMemory_getBankNumber(Memory memory, int spriteIndex) {
  //assert(memory != NULL);
  Byte address = (OAM_BYTES_PER_SPRITE * spriteIndex) + OAM_TILE_BYTE_OFFSET;
  Byte data = memory_read_direct(memory, address);
8000855c:	2f fb       	sub	r11,-1
8000855e:	5c 5b       	castu.b	r11
80008560:	fe b0 fd 22 	rcall	80007fa4 <memory_read_direct>
  if ( (data & MASK_OAM_BANK_NUMBER_ON) == MASK_OAM_BANK_NUMBER_ON) {
    return 1;
  } else {
    return 0;
  }
}
80008564:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80008568:	d8 02       	popm	pc
8000856a:	d7 03       	nop

8000856c <objectAttributeMemory_getY>:
8000856c:	d4 01       	pushm	lr
8000856e:	a3 6b       	lsl	r11,0x2
// byte 0
// 0    -       scanline coordinate minus one of object's top pixel row.
Byte objectAttributeMemory_getY(Memory memory, int spriteIndex) {
  //assert(memory != NULL);
  Byte address = (OAM_BYTES_PER_SPRITE * spriteIndex) + OAM_Y_BYTE_OFFSET;
  return memory_read_direct(memory, address);
80008570:	e2 1b 00 fc 	andl	r11,0xfc,COH
80008574:	fe b0 fd 18 	rcall	80007fa4 <memory_read_direct>
}
80008578:	d8 02       	popm	pc
8000857a:	d7 03       	nop

8000857c <objectAttributeMemory_init>:
8000857c:	d4 01       	pushm	lr
8000857e:	e0 6c 01 00 	mov	r12,256
the NES registers, or also can be loaded via DMA transfer through another
register.
*/
// assumption: not using callbacks within sprite memory?
Memory objectAttributeMemory_init(void) {
  Memory memory = memory_init(OAM_NUM_ADDRESSES);
80008582:	fe b0 fd 3f 	rcall	80008000 <memory_init>
  //assert(memory != NULL);
  return memory;
}
80008586:	d8 02       	popm	pc

80008588 <objectAttributeMemory_getPalette>:
80008588:	d4 01       	pushm	lr
8000858a:	a3 6b       	lsl	r11,0x2
}
// byte 2
Byte objectAttributeMemory_getAttributes(Memory memory, int spriteIndex) {
  //assert(memory != NULL);
  Byte address = (OAM_BYTES_PER_SPRITE * spriteIndex) + OAM_ATTRIBUTES_BYTE_OFFSET;
  return memory_read_direct(memory, address);
8000858c:	2f eb       	sub	r11,-2
8000858e:	e2 1b 00 fe 	andl	r11,0xfe,COH
80008592:	fe b0 fd 09 	rcall	80007fa4 <memory_read_direct>
// Palette (4 to 7) of sprite
Byte objectAttributeMemory_getPalette(Memory memory, int spriteIndex) {
  //assert(memory != NULL);
  Byte attributes = objectAttributeMemory_getAttributes(memory, spriteIndex);
  // lose the 765432 bits
  attributes = (attributes << 6) >> 4;
80008596:	a3 6c       	lsl	r12,0x2
  return attributes; // + 4;
}
80008598:	e2 1c 00 fc 	andl	r12,0xfc,COH
8000859c:	d8 02       	popm	pc
8000859e:	d7 03       	nop

800085a0 <objectAttributeMemory_isFlippedVertical>:
800085a0:	d4 01       	pushm	lr
800085a2:	a3 6b       	lsl	r11,0x2
}
// byte 2
Byte objectAttributeMemory_getAttributes(Memory memory, int spriteIndex) {
  //assert(memory != NULL);
  Byte address = (OAM_BYTES_PER_SPRITE * spriteIndex) + OAM_ATTRIBUTES_BYTE_OFFSET;
  return memory_read_direct(memory, address);
800085a4:	2f eb       	sub	r11,-2
800085a6:	e2 1b 00 fe 	andl	r11,0xfe,COH
800085aa:	fe b0 fc fd 	rcall	80007fa4 <memory_read_direct>
  if ( (attributes & MASK_OAM_FLIP_VERTICAL_ON) == MASK_OAM_FLIP_VERTICAL_ON) {
    return TRUE;
  } else {
    return FALSE;
  }
}
800085ae:	f9 dc c0 e8 	bfextu	r12,r12,0x7,0x8
800085b2:	d8 02       	popm	pc

800085b4 <objectAttributeMemory_isFlippedHorizontal>:
800085b4:	d4 01       	pushm	lr
800085b6:	a3 6b       	lsl	r11,0x2
}
// byte 2
Byte objectAttributeMemory_getAttributes(Memory memory, int spriteIndex) {
  //assert(memory != NULL);
  Byte address = (OAM_BYTES_PER_SPRITE * spriteIndex) + OAM_ATTRIBUTES_BYTE_OFFSET;
  return memory_read_direct(memory, address);
800085b8:	2f eb       	sub	r11,-2
800085ba:	e2 1b 00 fe 	andl	r11,0xfe,COH
800085be:	fe b0 fc f3 	rcall	80007fa4 <memory_read_direct>
  if ( (attributes & MASK_OAM_FLIP_HORIZONTAL_ON) == MASK_OAM_FLIP_HORIZONTAL_ON) {
    return TRUE;
  } else {
    return FALSE;
  }
}
800085c2:	f9 dc c0 c1 	bfextu	r12,r12,0x6,0x1
800085c6:	d8 02       	popm	pc

800085c8 <objectAttributeMemory_isBehindBackground>:
800085c8:	d4 01       	pushm	lr
800085ca:	a3 6b       	lsl	r11,0x2
}
// byte 2
Byte objectAttributeMemory_getAttributes(Memory memory, int spriteIndex) {
  //assert(memory != NULL);
  Byte address = (OAM_BYTES_PER_SPRITE * spriteIndex) + OAM_ATTRIBUTES_BYTE_OFFSET;
  return memory_read_direct(memory, address);
800085cc:	2f eb       	sub	r11,-2
800085ce:	e2 1b 00 fe 	andl	r11,0xfe,COH
800085d2:	fe b0 fc e9 	rcall	80007fa4 <memory_read_direct>
  if ( (attributes & MASK_OAM_BEHIND_BACKGROUND_ON) == MASK_OAM_BEHIND_BACKGROUND_ON) {
    return TRUE;
  } else {
    return FALSE;
  }
}
800085d6:	f9 dc c0 a1 	bfextu	r12,r12,0x5,0x1
800085da:	d8 02       	popm	pc

800085dc <ppu_getControlRegister>:
  }
}
Byte ppu_getControlRegister(PPU ppu) {
  //assert(ppu != NULL);
  return ppu->controlRegister;
}
800085dc:	19 8c       	ld.ub	r12,r12[0x0]
800085de:	5e fc       	retal	r12

800085e0 <ppu_getMaskRegister>:
Byte ppu_getMaskRegister(PPU ppu) {
  //assert(ppu != NULL);
  return ppu->maskRegister;
}
800085e0:	19 9c       	ld.ub	r12,r12[0x1]
800085e2:	5e fc       	retal	r12

800085e4 <ppu_getStatusRegister>:
Byte ppu_getStatusRegister(PPU ppu) {
  //assert(ppu != NULL);
  Byte status = ppu->statusRegister;
  // cleared on read
  ppu_setStatusVerticalBlank(ppu, FALSE);
  ppu->hasPartial = FALSE;
800085e4:	30 09       	mov	r9,0
800085e6:	f9 69 00 0b 	st.b	r12[11],r9
}
Byte ppu_getMaskRegister(PPU ppu) {
  //assert(ppu != NULL);
  return ppu->maskRegister;
}
Byte ppu_getStatusRegister(PPU ppu) {
800085ea:	18 98       	mov	r8,r12
  //assert(ppu != NULL);
  Byte status = ppu->statusRegister;
800085ec:	19 a9       	ld.ub	r9,r12[0x2]
  // cleared on read
  ppu_setStatusVerticalBlank(ppu, FALSE);
  ppu->hasPartial = FALSE;
  return status;
}
800085ee:	12 9c       	mov	r12,r9
static void ppu_setStatusVerticalBlank(PPU ppu, Bool state) {
  //assert(ppu != NULL);
  if (state == TRUE) {
    ppu->statusRegister |= MASK_STATUS_VBLANK_ON;
  } else if (state == FALSE) {
    ppu->statusRegister &= MASK_STATUS_VBLANK_OFF;
800085f0:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
800085f4:	b0 a9       	st.b	r8[0x2],r9
  Byte status = ppu->statusRegister;
  // cleared on read
  ppu_setStatusVerticalBlank(ppu, FALSE);
  ppu->hasPartial = FALSE;
  return status;
}
800085f6:	5e fc       	retal	r12

800085f8 <ppu_getSpriteAddressRegister>:
Byte ppu_getSpriteAddressRegister(PPU ppu) {
  //assert(ppu != NULL);
  return ppu->spriteAddressRegister;
}
800085f8:	19 bc       	ld.ub	r12,r12[0x3]
800085fa:	5e fc       	retal	r12

800085fc <ppu_getScrollRegister>:
  ppu->spriteAddressRegister++;
}
Byte ppu_getScrollRegister(PPU ppu) {
  //assert(ppu != NULL);
  return ppu->scrollRegister;
}
800085fc:	19 dc       	ld.ub	r12,r12[0x5]
800085fe:	5e fc       	retal	r12

80008600 <ppu_getPPUMemoryAddressRegister>:
Byte ppu_getPPUMemoryAddressRegister(PPU ppu) {
  //assert(ppu != NULL);
  return ppu->ppuMemoryAddressRegister;
}
80008600:	19 ec       	ld.ub	r12,r12[0x6]
80008602:	5e fc       	retal	r12

80008604 <ppu_setControlRegister>:
void ppu_setControlRegister(PPU ppu, Byte controlRegister) {
  //assert(ppu != NULL);
  ppu->controlRegister = controlRegister;
80008604:	b8 8b       	st.b	r12[0x0],r11
}
80008606:	5e fc       	retal	r12

80008608 <ppu_setMaskRegister>:
void ppu_setMaskRegister(PPU ppu, Byte maskRegister) {
  //assert(ppu != NULL);
  ppu->maskRegister = maskRegister;
80008608:	b8 9b       	st.b	r12[0x1],r11
}
8000860a:	5e fc       	retal	r12

8000860c <ppu_setSpriteAddressRegister>:
  //assert(ppu != NULL);
  ppu->statusRegister = statusRegister;
}
void ppu_setSpriteAddressRegister(PPU ppu, Byte spriteAddressRegister) {
  //assert(ppu != NULL);
  ppu->spriteAddressRegister = spriteAddressRegister;
8000860c:	b8 bb       	st.b	r12[0x3],r11
}
8000860e:	5e fc       	retal	r12

80008610 <ppu_setScrollRegister>:
void ppu_setScrollRegister(PPU ppu, Byte scrollRegister) {
  //assert(ppu != NULL);
  if (ppu->hasPartial == FALSE) {
80008610:	f9 39 00 0b 	ld.ub	r9,r12[11]
80008614:	30 08       	mov	r8,0
  } else {
    // we have a partial scroll
    ppu->verticalScroll = scrollRegister;
    ppu->hasPartial = FALSE;
  }
  ppu->scrollRegister = scrollRegister;
80008616:	b8 db       	st.b	r12[0x5],r11
  ppu->spriteAddressRegister = spriteAddressRegister;
}
void ppu_setScrollRegister(PPU ppu, Byte scrollRegister) {
  //assert(ppu != NULL);
  if (ppu->hasPartial == FALSE) {
    ppu->horizontalScroll = scrollRegister;
80008618:	f0 09 18 00 	cp.b	r9,r8
8000861c:	f9 fb 0e 0a 	st.beq	r12[0xa],r11
    ppu->hasPartial = TRUE;
80008620:	f9 b8 00 01 	moveq	r8,1
80008624:	f9 f8 0e 0b 	st.beq	r12[0xb],r8
  } else {
    // we have a partial scroll
    ppu->verticalScroll = scrollRegister;
    ppu->hasPartial = FALSE;
80008628:	f9 f8 1e 0b 	st.bne	r12[0xb],r8
  if (ppu->hasPartial == FALSE) {
    ppu->horizontalScroll = scrollRegister;
    ppu->hasPartial = TRUE;
  } else {
    // we have a partial scroll
    ppu->verticalScroll = scrollRegister;
8000862c:	f9 fb 1e 09 	st.bne	r12[0x9],r11
    ppu->hasPartial = FALSE;
  }
  ppu->scrollRegister = scrollRegister;
}
80008630:	5e fc       	retal	r12

80008632 <ppu_setPPUMemoryAddressRegister>:
void ppu_setPPUMemoryAddressRegister(PPU ppu, Byte ppuMemoryAddressRegister) {
  //assert(ppu != NULL);
  if (ppu->hasPartial == FALSE) {
80008632:	f9 39 00 0b 	ld.ub	r9,r12[11]
80008636:	30 08       	mov	r8,0
  } else {
    // we have a partial address
    ppu->ppuAddressLow = ppuMemoryAddressRegister;
    ppu->hasPartial = FALSE;
  }
  ppu->ppuMemoryAddressRegister = ppuMemoryAddressRegister;
80008638:	b8 eb       	st.b	r12[0x6],r11
  ppu->scrollRegister = scrollRegister;
}
void ppu_setPPUMemoryAddressRegister(PPU ppu, Byte ppuMemoryAddressRegister) {
  //assert(ppu != NULL);
  if (ppu->hasPartial == FALSE) {
    ppu->ppuAddressHigh = ppuMemoryAddressRegister;
8000863a:	f0 09 18 00 	cp.b	r9,r8
8000863e:	f9 fb 0e 0d 	st.beq	r12[0xd],r11
    ppu->hasPartial = TRUE;
80008642:	f9 b8 00 01 	moveq	r8,1
80008646:	f9 f8 0e 0b 	st.beq	r12[0xb],r8
  } else {
    // we have a partial address
    ppu->ppuAddressLow = ppuMemoryAddressRegister;
    ppu->hasPartial = FALSE;
8000864a:	f9 f8 1e 0b 	st.bne	r12[0xb],r8
  if (ppu->hasPartial == FALSE) {
    ppu->ppuAddressHigh = ppuMemoryAddressRegister;
    ppu->hasPartial = TRUE;
  } else {
    // we have a partial address
    ppu->ppuAddressLow = ppuMemoryAddressRegister;
8000864e:	f9 fb 1e 0c 	st.bne	r12[0xc],r11
    ppu->hasPartial = FALSE;
  }
  ppu->ppuMemoryAddressRegister = ppuMemoryAddressRegister;
}
80008652:	5e fc       	retal	r12

80008654 <ppu_getPPUMemoryDataRegister>:
  nes_writePPUMemory(nes, address, ppuMemoryDataRegister);
  //ppu->ppuMemoryDataRegister = ppuMemoryDataRegister;
  ppu_increasePPUMemoryAddress(ppu);
}
// one buffer pipeline
Byte ppu_getPPUMemoryDataRegister(NES nes) {
80008654:	eb cd 40 e0 	pushm	r5-r7,lr
80008658:	18 96       	mov	r6,r12
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
8000865a:	c4 5e       	rcall	800082e4 <nes_getPPU>
8000865c:	18 97       	mov	r7,r12
8000865e:	ef 38 00 0c 	ld.ub	r8,r7[12]
  //assert(ppu != NULL);
  Byte data = ppu->ppuMemoryReadBuffer;
  Address address = ppu->ppuAddressLow;
80008662:	0c 9c       	mov	r12,r6
  address += ppu->ppuAddressHigh << BITS_PER_BYTE;
  ppu->ppuMemoryReadBuffer = nes_readPPUMemory(nes, address);
80008664:	ef 35 00 08 	ld.ub	r5,r7[8]
// one buffer pipeline
Byte ppu_getPPUMemoryDataRegister(NES nes) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
  //assert(ppu != NULL);
  Byte data = ppu->ppuMemoryReadBuffer;
80008668:	ef 36 00 0d 	ld.ub	r6,r7[13]
  Address address = ppu->ppuAddressLow;
  address += ppu->ppuAddressHigh << BITS_PER_BYTE;
8000866c:	a9 66       	lsl	r6,0x8
8000866e:	10 06       	add	r6,r8
80008670:	5c 86       	casts.h	r6
80008672:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
  ppu->ppuMemoryReadBuffer = nes_readPPUMemory(nes, address);
80008676:	c5 de       	rcall	80008330 <nes_readPPUMemory>
80008678:	ef 6c 00 08 	st.b	r7[8],r12
8000867c:	e0 68 3f ff 	mov	r8,16383
  while (address > PPU_LAST_REAL_ADDRESS) {
80008680:	f0 06 19 00 	cp.h	r6,r8
80008684:	e0 88 00 04 	brls	8000868c <ppu_getPPUMemoryDataRegister+0x38>
80008688:	ed d6 c0 0e 	bfextu	r6,r6,0x0,0xe
  nes_writePPUMemory(nes, address, ppuMemoryDataRegister);
  //ppu->ppuMemoryDataRegister = ppuMemoryDataRegister;
  ppu_increasePPUMemoryAddress(ppu);
}
// one buffer pipeline
Byte ppu_getPPUMemoryDataRegister(NES nes) {
8000868c:	e0 68 3e ff 	mov	r8,16127
  while (address > PPU_LAST_REAL_ADDRESS) {
    address -= PPU_NUM_REAL_ADDRESSES;
  }
  //assert(address <= PPU_LAST_REAL_ADDRESS);
  // palette reads are not buffered
  if (address >= PPU_BACKGROUND_PALETTE_FIRST_ADDRESS) {
80008690:	ec 08 19 00 	cp.h	r8,r6
80008694:	f8 05 17 30 	movlo	r5,r12
80008698:	ef 38 00 0c 	ld.ub	r8,r7[12]
  }
  ppu->ppuMemoryAddressRegister = ppuMemoryAddressRegister;
}
static void ppu_increasePPUMemoryAddress(PPU ppu) {
  ////assert(ppu->hasPartial == FALSE);
  Address address = ppu->ppuAddressLow;
8000869c:	ef 39 00 0d 	ld.ub	r9,r7[13]
  address += ppu->ppuAddressHigh << BITS_PER_BYTE;
800086a0:	a9 69       	lsl	r9,0x8
800086a2:	10 09       	add	r9,r8
800086a4:	0f 88       	ld.ub	r8,r7[0x0]
800086a6:	5c 89       	casts.h	r9
    ppu->controlRegister &= MASK_CONTROL_PPU_ADDRESS_INCREMENT_OFF;
  }
}
static Bool ppu_getControlPPUAddressIncrement(PPU ppu) {
  //assert(ppu != NULL);
  if ((ppu->controlRegister & MASK_CONTROL_PPU_ADDRESS_INCREMENT_ON) ==
800086a8:	ed b8 00 02 	bld	r8,0x2
800086ac:	c0 d1       	brne	800086c6 <ppu_getPPUMemoryDataRegister+0x72>
800086ae:	f2 c8 ff e0 	sub	r8,r9,-32
static void ppu_increasePPUMemoryAddress(PPU ppu) {
  ////assert(ppu->hasPartial == FALSE);
  Address address = ppu->ppuAddressLow;
  address += ppu->ppuAddressHigh << BITS_PER_BYTE;
  if (ppu_getControlPPUAddressIncrement(ppu) == TRUE) {
    address += PPU_CONTROL_ADDRESS_VERTICAL_INCREMENT;
800086b2:	5c 88       	casts.h	r8
800086b4:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
  } else {
    address += PPU_CONTROL_ADDRESS_HORIZONTAL_INCREMENT;
  }
  ppu->ppuAddressLow = GET_ADDRESS_LOW_BYTE(address);
  ppu->ppuAddressHigh = GET_ADDRESS_HIGH_BYTE(address);
800086b8:	ef 68 00 0c 	st.b	r7[12],r8
  if (ppu_getControlPPUAddressIncrement(ppu) == TRUE) {
    address += PPU_CONTROL_ADDRESS_VERTICAL_INCREMENT;
  } else {
    address += PPU_CONTROL_ADDRESS_HORIZONTAL_INCREMENT;
  }
  ppu->ppuAddressLow = GET_ADDRESS_LOW_BYTE(address);
800086bc:	ef 69 00 0d 	st.b	r7[13],r9
  ppu->ppuAddressHigh = GET_ADDRESS_HIGH_BYTE(address);
800086c0:	0a 9c       	mov	r12,r5
800086c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
  if (address >= PPU_BACKGROUND_PALETTE_FIRST_ADDRESS) {
    data = ppu->ppuMemoryReadBuffer;
  }
  ppu_increasePPUMemoryAddress(ppu);
  return data;
}
800086c6:	f2 c8 ff ff 	sub	r8,r9,-1
  Address address = ppu->ppuAddressLow;
  address += ppu->ppuAddressHigh << BITS_PER_BYTE;
  if (ppu_getControlPPUAddressIncrement(ppu) == TRUE) {
    address += PPU_CONTROL_ADDRESS_VERTICAL_INCREMENT;
  } else {
    address += PPU_CONTROL_ADDRESS_HORIZONTAL_INCREMENT;
800086ca:	5c 88       	casts.h	r8
800086cc:	cf 4b       	rjmp	800086b4 <ppu_getPPUMemoryDataRegister+0x60>
800086ce:	d7 03       	nop

800086d0 <ppu_setPPUMemoryDataRegister>:
800086d0:	eb cd 40 e0 	pushm	r5-r7,lr
800086d4:	16 95       	mov	r5,r11
800086d6:	18 96       	mov	r6,r12
800086d8:	c0 6e       	rcall	800082e4 <nes_getPPU>
800086da:	18 97       	mov	r7,r12
  ppu->ppuAddressLow = GET_ADDRESS_LOW_BYTE(address);
  ppu->ppuAddressHigh = GET_ADDRESS_HIGH_BYTE(address);
}
void ppu_setPPUMemoryDataRegister(NES nes, Byte ppuMemoryDataRegister) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
800086dc:	ef 38 00 0c 	ld.ub	r8,r7[12]
  //assert(ppu != NULL);
  Address address = ppu->ppuAddressLow;
800086e0:	ef 3b 00 0d 	ld.ub	r11,r7[13]
  address += ppu->ppuAddressHigh << BITS_PER_BYTE;
  nes_writePPUMemory(nes, address, ppuMemoryDataRegister);
800086e4:	0a 9a       	mov	r10,r5
800086e6:	0c 9c       	mov	r12,r6
800086e8:	a9 6b       	lsl	r11,0x8
800086ea:	10 0b       	add	r11,r8
800086ec:	5c 7b       	castu.h	r11
800086ee:	fe b0 fd ff 	rcall	800082ec <nes_writePPUMemory>
800086f2:	ef 38 00 0c 	ld.ub	r8,r7[12]
  }
  ppu->ppuMemoryAddressRegister = ppuMemoryAddressRegister;
}
static void ppu_increasePPUMemoryAddress(PPU ppu) {
  ////assert(ppu->hasPartial == FALSE);
  Address address = ppu->ppuAddressLow;
800086f6:	ef 39 00 0d 	ld.ub	r9,r7[13]
  address += ppu->ppuAddressHigh << BITS_PER_BYTE;
800086fa:	a9 69       	lsl	r9,0x8
800086fc:	10 09       	add	r9,r8
800086fe:	0f 88       	ld.ub	r8,r7[0x0]
    ppu->controlRegister &= MASK_CONTROL_PPU_ADDRESS_INCREMENT_OFF;
  }
}
static Bool ppu_getControlPPUAddressIncrement(PPU ppu) {
  //assert(ppu != NULL);
  if ((ppu->controlRegister & MASK_CONTROL_PPU_ADDRESS_INCREMENT_ON) ==
80008700:	5c 89       	casts.h	r9
  ppu->ppuMemoryAddressRegister = ppuMemoryAddressRegister;
}
static void ppu_increasePPUMemoryAddress(PPU ppu) {
  ////assert(ppu->hasPartial == FALSE);
  Address address = ppu->ppuAddressLow;
  address += ppu->ppuAddressHigh << BITS_PER_BYTE;
80008702:	ed b8 00 02 	bld	r8,0x2
    ppu->controlRegister &= MASK_CONTROL_PPU_ADDRESS_INCREMENT_OFF;
  }
}
static Bool ppu_getControlPPUAddressIncrement(PPU ppu) {
  //assert(ppu != NULL);
  if ((ppu->controlRegister & MASK_CONTROL_PPU_ADDRESS_INCREMENT_ON) ==
80008706:	c0 c1       	brne	8000871e <ppu_setPPUMemoryDataRegister+0x4e>
80008708:	f2 c8 ff e0 	sub	r8,r9,-32
static void ppu_increasePPUMemoryAddress(PPU ppu) {
  ////assert(ppu->hasPartial == FALSE);
  Address address = ppu->ppuAddressLow;
  address += ppu->ppuAddressHigh << BITS_PER_BYTE;
  if (ppu_getControlPPUAddressIncrement(ppu) == TRUE) {
    address += PPU_CONTROL_ADDRESS_VERTICAL_INCREMENT;
8000870c:	5c 88       	casts.h	r8
8000870e:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
  } else {
    address += PPU_CONTROL_ADDRESS_HORIZONTAL_INCREMENT;
  }
  ppu->ppuAddressLow = GET_ADDRESS_LOW_BYTE(address);
  ppu->ppuAddressHigh = GET_ADDRESS_HIGH_BYTE(address);
80008712:	ef 68 00 0c 	st.b	r7[12],r8
  if (ppu_getControlPPUAddressIncrement(ppu) == TRUE) {
    address += PPU_CONTROL_ADDRESS_VERTICAL_INCREMENT;
  } else {
    address += PPU_CONTROL_ADDRESS_HORIZONTAL_INCREMENT;
  }
  ppu->ppuAddressLow = GET_ADDRESS_LOW_BYTE(address);
80008716:	ef 69 00 0d 	st.b	r7[13],r9
  ppu->ppuAddressHigh = GET_ADDRESS_HIGH_BYTE(address);
8000871a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
  Address address = ppu->ppuAddressLow;
  address += ppu->ppuAddressHigh << BITS_PER_BYTE;
  nes_writePPUMemory(nes, address, ppuMemoryDataRegister);
  //ppu->ppuMemoryDataRegister = ppuMemoryDataRegister;
  ppu_increasePPUMemoryAddress(ppu);
}
8000871e:	f2 c8 ff ff 	sub	r8,r9,-1
  Address address = ppu->ppuAddressLow;
  address += ppu->ppuAddressHigh << BITS_PER_BYTE;
  if (ppu_getControlPPUAddressIncrement(ppu) == TRUE) {
    address += PPU_CONTROL_ADDRESS_VERTICAL_INCREMENT;
  } else {
    address += PPU_CONTROL_ADDRESS_HORIZONTAL_INCREMENT;
80008722:	5c 88       	casts.h	r8
80008724:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
  }
  ppu->ppuAddressLow = GET_ADDRESS_LOW_BYTE(address);
  ppu->ppuAddressHigh = GET_ADDRESS_HIGH_BYTE(address);
80008728:	ef 68 00 0c 	st.b	r7[12],r8
  if (ppu_getControlPPUAddressIncrement(ppu) == TRUE) {
    address += PPU_CONTROL_ADDRESS_VERTICAL_INCREMENT;
  } else {
    address += PPU_CONTROL_ADDRESS_HORIZONTAL_INCREMENT;
  }
  ppu->ppuAddressLow = GET_ADDRESS_LOW_BYTE(address);
8000872c:	ef 69 00 0d 	st.b	r7[13],r9
  ppu->ppuAddressHigh = GET_ADDRESS_HIGH_BYTE(address);
80008730:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80008734 <ppu_setSpriteDataRegister>:
  Address address = ppu->ppuAddressLow;
  address += ppu->ppuAddressHigh << BITS_PER_BYTE;
  nes_writePPUMemory(nes, address, ppuMemoryDataRegister);
  //ppu->ppuMemoryDataRegister = ppuMemoryDataRegister;
  ppu_increasePPUMemoryAddress(ppu);
}
80008734:	eb cd 40 e0 	pushm	r5-r7,lr
80008738:	16 95       	mov	r5,r11
8000873a:	18 96       	mov	r6,r12
8000873c:	fe b0 fd d4 	rcall	800082e4 <nes_getPPU>
}
void ppu_setSpriteDataRegister(NES nes, Byte spriteDataRegister) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
  //assert(ppu != NULL);
  nes_writeObjectAttributeMemory(nes, ppu->spriteAddressRegister, spriteDataRegister);
80008740:	0a 9a       	mov	r10,r5
  //ppu->spriteAddressRegister++;
  return data;
}
void ppu_setSpriteDataRegister(NES nes, Byte spriteDataRegister) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
80008742:	18 97       	mov	r7,r12
  //assert(ppu != NULL);
  nes_writeObjectAttributeMemory(nes, ppu->spriteAddressRegister, spriteDataRegister);
80008744:	0c 9c       	mov	r12,r6
80008746:	0f bb       	ld.ub	r11,r7[0x3]
80008748:	fe b0 fd e4 	rcall	80008310 <nes_writeObjectAttributeMemory>
  ppu->spriteAddressRegister++;
8000874c:	0f b8       	ld.ub	r8,r7[0x3]
8000874e:	2f f8       	sub	r8,-1
80008750:	ae b8       	st.b	r7[0x3],r8
}
80008752:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80008756:	d7 03       	nop

80008758 <ppu_getSpriteDataRegister>:
80008758:	eb cd 40 80 	pushm	r7,lr
8000875c:	18 97       	mov	r7,r12
8000875e:	fe b0 fd c3 	rcall	800082e4 <nes_getPPU>
}
Byte ppu_getSpriteDataRegister(NES nes) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
  //assert(ppu != NULL);
  Byte data = nes_readObjectAttributeMemory(nes, ppu->spriteAddressRegister);
80008762:	19 bb       	ld.ub	r11,r12[0x3]
80008764:	0e 9c       	mov	r12,r7
80008766:	fe b0 fd f5 	rcall	80008350 <nes_readObjectAttributeMemory>
  //reads don't increase this?
  //ppu->spriteAddressRegister++;
  return data;
}
8000876a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000876e:	d7 03       	nop

80008770 <ppu_updateScanlineSpriteColour8>:
80008770:	d4 31       	pushm	r0-r7,lr
80008772:	20 5d       	sub	sp,20
80008774:	16 97       	mov	r7,r11
80008776:	50 3a       	stdsp	sp[0xc],r10
  Address address = PPU_SPRITE_PALETTE_FIRST_ADDRESS;
  address += spriteColourIndex;
  Byte systemIndex = nes_readPPUMemory(nes, address);
  return systemIndex;
}
static void ppu_updateScanlineSpriteColour8(NES nes, Byte spriteIndex, Address basePatternAddress, Byte multiplier) {
80008778:	12 92       	mov	r2,r9
8000877a:	18 94       	mov	r4,r12
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
8000877c:	fe b0 fd b4 	rcall	800082e4 <nes_getPPU>
80008780:	18 95       	mov	r5,r12
  //assert(ppu != NULL);
  Memory objectAttributeMemory = nes_getObjectAttributeMemory(nes);
80008782:	08 9c       	mov	r12,r4
80008784:	fe b0 fd a6 	rcall	800082d0 <nes_getObjectAttributeMemory>
  //assert(objectAttributeMemory != NULL);
  Byte screenY = ppu_getCurrentY(ppu);
  Byte spriteLeftX = objectAttributeMemory_getX(objectAttributeMemory, spriteIndex);
80008788:	0e 9b       	mov	r11,r7
}
static void ppu_updateScanlineSpriteColour8(NES nes, Byte spriteIndex, Address basePatternAddress, Byte multiplier) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
  //assert(ppu != NULL);
  Memory objectAttributeMemory = nes_getObjectAttributeMemory(nes);
8000878a:	18 96       	mov	r6,r12
  //assert(ppu != NULL);
  return ppu->currentScanlineCycle;
}
static Byte ppu_getCurrentY(PPU ppu) {
  //assert(ppu != NULL);
  return ppu->currentScanline - PPU_WASTED_VBLANK_SCANLINES -
8000878c:	6a 51       	ld.w	r1,r5[0x14]
  PPU ppu = nes_getPPU(nes);
  //assert(ppu != NULL);
  Memory objectAttributeMemory = nes_getObjectAttributeMemory(nes);
  //assert(objectAttributeMemory != NULL);
  Byte screenY = ppu_getCurrentY(ppu);
  Byte spriteLeftX = objectAttributeMemory_getX(objectAttributeMemory, spriteIndex);
8000878e:	cc fe       	rcall	8000852c <objectAttributeMemory_getX>
80008790:	21 51       	sub	r1,21
  //assert(ppu != NULL);
  return ppu->currentScanlineCycle;
}
static Byte ppu_getCurrentY(PPU ppu) {
  //assert(ppu != NULL);
  return ppu->currentScanline - PPU_WASTED_VBLANK_SCANLINES -
80008792:	18 93       	mov	r3,r12
  PPU ppu = nes_getPPU(nes);
  //assert(ppu != NULL);
  Memory objectAttributeMemory = nes_getObjectAttributeMemory(nes);
  //assert(objectAttributeMemory != NULL);
  Byte screenY = ppu_getCurrentY(ppu);
  Byte spriteLeftX = objectAttributeMemory_getX(objectAttributeMemory, spriteIndex);
80008794:	0e 9b       	mov	r11,r7
  Byte spriteTopY = objectAttributeMemory_getY(objectAttributeMemory, spriteIndex) - 1;
80008796:	0c 9c       	mov	r12,r6
80008798:	5c 51       	castu.b	r1
  //assert(ppu != NULL);
  return ppu->currentScanlineCycle;
}
static Byte ppu_getCurrentY(PPU ppu) {
  //assert(ppu != NULL);
  return ppu->currentScanline - PPU_WASTED_VBLANK_SCANLINES -
8000879a:	ce 9e       	rcall	8000856c <objectAttributeMemory_getY>
  //assert(ppu != NULL);
  Memory objectAttributeMemory = nes_getObjectAttributeMemory(nes);
  //assert(objectAttributeMemory != NULL);
  Byte screenY = ppu_getCurrentY(ppu);
  Byte spriteLeftX = objectAttributeMemory_getX(objectAttributeMemory, spriteIndex);
  Byte spriteTopY = objectAttributeMemory_getY(objectAttributeMemory, spriteIndex) - 1;
8000879c:	f8 c8 00 01 	sub	r8,r12,1
800087a0:	5c 58       	castu.b	r8
800087a2:	e2 08 18 00 	cp.b	r8,r1
  int yOffset = 0;
  Bool inRange = FALSE;
  if (screenY >= spriteTopY) {
800087a6:	e0 8b 00 29 	brhi	800087f8 <ppu_updateScanlineSpriteColour8+0x88>
800087aa:	e2 08 01 08 	sub	r8,r1,r8
    yOffset = screenY - spriteTopY;
800087ae:	a3 72       	lsl	r2,0x3
800087b0:	50 08       	stdsp	sp[0x0],r8
800087b2:	10 32       	cp.w	r2,r8
    if (yOffset < (PPU_VERTICAL_PIXELS_PER_TILE*multiplier)) {
      inRange = TRUE;
    }
  }
  Byte y = yOffset;
  Byte patternTileNumber = objectAttributeMemory_getTileNumber(objectAttributeMemory,
800087b4:	5f 92       	srgt	r2
  Byte spriteLeftX = objectAttributeMemory_getX(objectAttributeMemory, spriteIndex);
  Byte spriteTopY = objectAttributeMemory_getY(objectAttributeMemory, spriteIndex) - 1;
  int yOffset = 0;
  Bool inRange = FALSE;
  if (screenY >= spriteTopY) {
    yOffset = screenY - spriteTopY;
800087b6:	30 0a       	mov	r10,0
800087b8:	0e 9b       	mov	r11,r7
    if (yOffset < (PPU_VERTICAL_PIXELS_PER_TILE*multiplier)) {
      inRange = TRUE;
    }
  }
  Byte y = yOffset;
  Byte patternTileNumber = objectAttributeMemory_getTileNumber(objectAttributeMemory,
800087ba:	0c 9c       	mov	r12,r6
800087bc:	cc 0e       	rcall	8000853c <objectAttributeMemory_getTileNumber>
800087be:	40 08       	lddsp	r8,sp[0x0]
800087c0:	18 90       	mov	r0,r12
800087c2:	e3 d8 c0 08 	bfextu	r1,r8,0x0,0x8
800087c6:	58 78       	cp.w	r8,7
    yOffset = screenY - spriteTopY;
    if (yOffset < (PPU_VERTICAL_PIXELS_PER_TILE*multiplier)) {
      inRange = TRUE;
    }
  }
  Byte y = yOffset;
800087c8:	e0 8a 00 06 	brle	800087d4 <ppu_updateScanlineSpriteColour8+0x64>
  Byte patternTileNumber = objectAttributeMemory_getTileNumber(objectAttributeMemory,
spriteIndex, FALSE);
  if (yOffset >= 8) {
800087cc:	20 81       	sub	r1,8
800087ce:	2f f0       	sub	r0,-1
800087d0:	5c 51       	castu.b	r1
    y = yOffset - 8;
800087d2:	5c 50       	castu.b	r0
    patternTileNumber++;
800087d4:	0e 9b       	mov	r11,r7
  }
  Byte y = yOffset;
  Byte patternTileNumber = objectAttributeMemory_getTileNumber(objectAttributeMemory,
spriteIndex, FALSE);
  if (yOffset >= 8) {
    y = yOffset - 8;
800087d6:	0c 9c       	mov	r12,r6
    patternTileNumber++;
800087d8:	ce 4e       	rcall	800085a0 <objectAttributeMemory_isFlippedVertical>
  }
  if (objectAttributeMemory_isFlippedVertical(objectAttributeMemory, spriteIndex) ==
800087da:	30 18       	mov	r8,1
800087dc:	f0 0c 18 00 	cp.b	r12,r8
800087e0:	e0 80 00 a0 	breq	80008920 <ppu_updateScanlineSpriteColour8+0x1b0>
800087e4:	0e 9b       	mov	r11,r7
800087e6:	0c 9c       	mov	r12,r6
800087e8:	cd 0e       	rcall	80008588 <objectAttributeMemory_getPalette>
800087ea:	50 4c       	stdsp	sp[0x10],r12
TRUE) {
    y = PPU_VERTICAL_PIXELS_PER_TILE - y - 1;
  }
  Byte attributeIndex = objectAttributeMemory_getPalette(objectAttributeMemory,
800087ec:	30 1a       	mov	r10,1
800087ee:	f4 02 18 00 	cp.b	r2,r10
800087f2:	c0 b0       	breq	80008808 <ppu_updateScanlineSpriteColour8+0x98>
800087f4:	2f bd       	sub	sp,-20
spriteIndex);
  if (inRange == TRUE) {
800087f6:	d8 32       	popm	r0-r7,pc
800087f8:	30 0a       	mov	r10,0
800087fa:	0e 9b       	mov	r11,r7
800087fc:	0c 9c       	mov	r12,r6
objectAttributeMemory_isBehindBackground(objectAttributeMemory, spriteIndex);
        }
      }
    }
  }
}
800087fe:	30 02       	mov	r2,0
80008800:	c9 ee       	rcall	8000853c <objectAttributeMemory_getTileNumber>
    if (yOffset < (PPU_VERTICAL_PIXELS_PER_TILE*multiplier)) {
      inRange = TRUE;
    }
  }
  Byte y = yOffset;
  Byte patternTileNumber = objectAttributeMemory_getTileNumber(objectAttributeMemory,
80008802:	04 91       	mov	r1,r2
80008804:	18 90       	mov	r0,r12
80008806:	ce 7b       	rjmp	800087d4 <ppu_updateScanlineSpriteColour8+0x64>
80008808:	40 39       	lddsp	r9,sp[0xc]
8000880a:	a5 60       	lsl	r0,0x4
8000880c:	12 00       	add	r0,r9
8000880e:	e3 d1 c0 03 	bfextu	r1,r1,0x0,0x3
80008812:	ea 03 00 08 	add	r8,r5,r3
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
  //assert(ppu != NULL);
  Word horizontalOffset = patternTileNumber * PPU_PATTERN_BYTES_PER_TILE;
  Word verticalOffset = (y % PPU_VERTICAL_PIXELS_PER_TILE);
  Address pattern1Address = basePatternAddress + horizontalOffset + verticalOffset;
80008816:	e0 01 00 01 	add	r1,r0,r1
8000881a:	f1 3a 01 20 	ld.ub	r10,r8[288]
  Byte attributeIndex = objectAttributeMemory_getPalette(objectAttributeMemory,
spriteIndex);
  if (inRange == TRUE) {
    int i;
    for (i=0; i < PPU_HORIZONTAL_PIXELS_PER_TILE; i++) {
      if (ppu->spriteColoursForScanlineSet[spriteLeftX+i] == FALSE) {
8000881e:	30 09       	mov	r9,0
80008820:	e2 c0 ff f8 	sub	r0,r1,-8
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
  //assert(ppu != NULL);
  Word horizontalOffset = patternTileNumber * PPU_PATTERN_BYTES_PER_TILE;
  Word verticalOffset = (y % PPU_VERTICAL_PIXELS_PER_TILE);
  Address pattern1Address = basePatternAddress + horizontalOffset + verticalOffset;
80008824:	5c 71       	castu.h	r1
  Byte attributeIndex = objectAttributeMemory_getPalette(objectAttributeMemory,
spriteIndex);
  if (inRange == TRUE) {
    int i;
    for (i=0; i < PPU_HORIZONTAL_PIXELS_PER_TILE; i++) {
      if (ppu->spriteColoursForScanlineSet[spriteLeftX+i] == FALSE) {
80008826:	5c 70       	castu.h	r0
80008828:	f2 0a 18 00 	cp.b	r10,r9
  Word horizontalOffset = patternTileNumber * PPU_PATTERN_BYTES_PER_TILE;
  Word verticalOffset = (y % PPU_VERTICAL_PIXELS_PER_TILE);
  Address pattern1Address = basePatternAddress + horizontalOffset + verticalOffset;
  Address pattern2Address = pattern1Address + 8;
  Byte pattern1 = nes_readPPUMemory(nes, pattern1Address);
  Byte pattern2 = nes_readPPUMemory(nes, pattern2Address);
8000882c:	e0 80 01 bf 	breq	80008baa <ppu_updateScanlineSpriteColour8+0x43a>
  //assert(ppu != NULL);
  Word horizontalOffset = patternTileNumber * PPU_PATTERN_BYTES_PER_TILE;
  Word verticalOffset = (y % PPU_VERTICAL_PIXELS_PER_TILE);
  Address pattern1Address = basePatternAddress + horizontalOffset + verticalOffset;
  Address pattern2Address = pattern1Address + 8;
  Byte pattern1 = nes_readPPUMemory(nes, pattern1Address);
80008830:	e6 c2 ff ff 	sub	r2,r3,-1
  Byte attributeIndex = objectAttributeMemory_getPalette(objectAttributeMemory,
spriteIndex);
  if (inRange == TRUE) {
    int i;
    for (i=0; i < PPU_HORIZONTAL_PIXELS_PER_TILE; i++) {
      if (ppu->spriteColoursForScanlineSet[spriteLeftX+i] == FALSE) {
80008834:	30 08       	mov	r8,0
80008836:	ea 02 00 02 	add	r2,r5,r2
8000883a:	e5 39 01 20 	ld.ub	r9,r2[288]
8000883e:	f0 09 18 00 	cp.b	r9,r8
80008842:	e0 80 01 7d 	breq	80008b3c <ppu_updateScanlineSpriteColour8+0x3cc>
80008846:	e6 c2 ff fe 	sub	r2,r3,-2
8000884a:	30 08       	mov	r8,0
8000884c:	ea 02 00 02 	add	r2,r5,r2
80008850:	e5 39 01 20 	ld.ub	r9,r2[288]
80008854:	f0 09 18 00 	cp.b	r9,r8
80008858:	e0 80 01 3c 	breq	80008ad0 <ppu_updateScanlineSpriteColour8+0x360>
8000885c:	e6 c2 ff fd 	sub	r2,r3,-3
80008860:	30 08       	mov	r8,0
80008862:	ea 02 00 02 	add	r2,r5,r2
80008866:	e5 39 01 20 	ld.ub	r9,r2[288]
8000886a:	f0 09 18 00 	cp.b	r9,r8
8000886e:	e0 80 00 fb 	breq	80008a64 <ppu_updateScanlineSpriteColour8+0x2f4>
80008872:	e6 c2 ff fc 	sub	r2,r3,-4
80008876:	30 08       	mov	r8,0
80008878:	ea 02 00 02 	add	r2,r5,r2
8000887c:	e5 39 01 20 	ld.ub	r9,r2[288]
80008880:	f0 09 18 00 	cp.b	r9,r8
80008884:	e0 80 00 ba 	breq	800089f8 <ppu_updateScanlineSpriteColour8+0x288>
80008888:	e6 c2 ff fb 	sub	r2,r3,-5
8000888c:	30 08       	mov	r8,0
8000888e:	ea 02 00 02 	add	r2,r5,r2
80008892:	e5 39 01 20 	ld.ub	r9,r2[288]
80008896:	f0 09 18 00 	cp.b	r9,r8
8000889a:	c7 a0       	breq	8000898e <ppu_updateScanlineSpriteColour8+0x21e>
8000889c:	e6 c2 ff fa 	sub	r2,r3,-6
800088a0:	30 08       	mov	r8,0
800088a2:	ea 02 00 02 	add	r2,r5,r2
800088a6:	e5 39 01 20 	ld.ub	r9,r2[288]
800088aa:	f0 09 18 00 	cp.b	r9,r8
800088ae:	c3 d0       	breq	80008928 <ppu_updateScanlineSpriteColour8+0x1b8>
800088b0:	2f 93       	sub	r3,-7
800088b2:	30 08       	mov	r8,0
800088b4:	06 05       	add	r5,r3
800088b6:	eb 39 01 20 	ld.ub	r9,r5[288]
800088ba:	f0 09 18 00 	cp.b	r9,r8
800088be:	c9 b1       	brne	800087f4 <ppu_updateScanlineSpriteColour8+0x84>
800088c0:	0e 9b       	mov	r11,r7
800088c2:	0c 9c       	mov	r12,r6
800088c4:	30 13       	mov	r3,1
800088c6:	c7 7e       	rcall	800085b4 <objectAttributeMemory_isFlippedHorizontal>
800088c8:	f8 03 18 00 	cp.b	r3,r12
        Byte x = i;
        if (objectAttributeMemory_isFlippedHorizontal(objectAttributeMemory,
800088cc:	f9 b8 01 07 	movne	r8,7
800088d0:	f9 b8 00 00 	moveq	r8,0
800088d4:	08 9c       	mov	r12,r4
800088d6:	50 08       	stdsp	sp[0x0],r8
800088d8:	fe b0 fd 06 	rcall	800082e4 <nes_getPPU>
800088dc:	02 9b       	mov	r11,r1
800088de:	08 9c       	mov	r12,r4
800088e0:	fe b0 fd 28 	rcall	80008330 <nes_readPPUMemory>
  //assert(patternIndex <= 3);
  return patternIndex;
}
static Byte ppu_getPatternColourIndex(NES nes, Address basePatternAddress, Byte patternTileNumber, Byte x, Byte y) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
800088e4:	00 9b       	mov	r11,r0
800088e6:	18 92       	mov	r2,r12
800088e8:	08 9c       	mov	r12,r4
  //assert(ppu != NULL);
  Word horizontalOffset = patternTileNumber * PPU_PATTERN_BYTES_PER_TILE;
  Word verticalOffset = (y % PPU_VERTICAL_PIXELS_PER_TILE);
  Address pattern1Address = basePatternAddress + horizontalOffset + verticalOffset;
  Address pattern2Address = pattern1Address + 8;
  Byte pattern1 = nes_readPPUMemory(nes, pattern1Address);
800088ea:	fe b0 fd 23 	rcall	80008330 <nes_readPPUMemory>
800088ee:	40 08       	lddsp	r8,sp[0x0]
800088f0:	f8 08 09 49 	lsl	r9,r12,r8
800088f4:	e4 08 09 48 	lsl	r8,r2,r8
  Byte pattern2 = nes_readPPUMemory(nes, pattern2Address);
800088f8:	f3 d9 c0 e1 	bfextu	r9,r9,0x7,0x1
  return nes_readPPUMemory(nes,nametableByteAddress);
}
static Byte ppu_combinePatternBytes(PPU ppu, Byte pattern1, Byte pattern2, Byte x) {
  //assert(ppu != NULL);
  x %= PPU_HORIZONTAL_PIXELS_PER_TILE;
  pattern1 = pattern1 << x;
800088fc:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
  pattern1 = pattern1 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
  pattern2 = pattern2 << x;
80008900:	f0 09 00 18 	add	r8,r8,r9<<0x1
  return nes_readPPUMemory(nes,nametableByteAddress);
}
static Byte ppu_combinePatternBytes(PPU ppu, Byte pattern1, Byte pattern2, Byte x) {
  //assert(ppu != NULL);
  x %= PPU_HORIZONTAL_PIXELS_PER_TILE;
  pattern1 = pattern1 << x;
80008904:	fe 90 ff 78 	breq	800087f4 <ppu_updateScanlineSpriteColour8+0x84>
  pattern1 = pattern1 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
  pattern2 = pattern2 << x;
  pattern2 = pattern2 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
80008908:	40 49       	lddsp	r9,sp[0x10]
  pattern2 = pattern2 << 1;
  Byte patternIndex = pattern1 + pattern2;
8000890a:	12 08       	add	r8,r9
8000890c:	eb 63 01 20 	st.b	r5[288],r3
80008910:	eb 68 00 20 	st.b	r5[32],r8
spriteIndex) == TRUE) {
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
80008914:	0e 9b       	mov	r11,r7
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
80008916:	0c 9c       	mov	r12,r6
80008918:	c5 8e       	rcall	800085c8 <objectAttributeMemory_isBehindBackground>
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
8000891a:	eb 6c 02 20 	st.b	r5[544],r12
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
8000891e:	c6 bb       	rjmp	800087f4 <ppu_updateScanlineSpriteColour8+0x84>
80008920:	e2 01 11 07 	rsub	r1,r1,7
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
          ppu->spriteColoursForScanlineIsBehindBackground[spriteLeftX +i] =
objectAttributeMemory_isBehindBackground(objectAttributeMemory, spriteIndex);
80008924:	5c 51       	castu.b	r1
80008926:	c5 fb       	rjmp	800087e4 <ppu_updateScanlineSpriteColour8+0x74>
80008928:	0e 9b       	mov	r11,r7
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
          ppu->spriteColoursForScanlineIsBehindBackground[spriteLeftX +i] =
8000892a:	0c 9c       	mov	r12,r6
8000892c:	c4 4e       	rcall	800085b4 <objectAttributeMemory_isFlippedHorizontal>
8000892e:	30 18       	mov	r8,1
    y = yOffset - 8;
    patternTileNumber++;
  }
  if (objectAttributeMemory_isFlippedVertical(objectAttributeMemory, spriteIndex) ==
TRUE) {
    y = PPU_VERTICAL_PIXELS_PER_TILE - y - 1;
80008930:	f8 08 18 00 	cp.b	r8,r12
80008934:	f9 b9 00 01 	moveq	r9,1
  if (inRange == TRUE) {
    int i;
    for (i=0; i < PPU_HORIZONTAL_PIXELS_PER_TILE; i++) {
      if (ppu->spriteColoursForScanlineSet[spriteLeftX+i] == FALSE) {
        Byte x = i;
        if (objectAttributeMemory_isFlippedHorizontal(objectAttributeMemory,
80008938:	f9 b9 01 06 	movne	r9,6
8000893c:	50 08       	stdsp	sp[0x0],r8
8000893e:	50 19       	stdsp	sp[0x4],r9
80008940:	08 9c       	mov	r12,r4
80008942:	fe b0 fc d1 	rcall	800082e4 <nes_getPPU>
80008946:	02 9b       	mov	r11,r1
80008948:	08 9c       	mov	r12,r4
8000894a:	fe b0 fc f3 	rcall	80008330 <nes_readPPUMemory>
  //assert(patternIndex <= 3);
  return patternIndex;
}
static Byte ppu_getPatternColourIndex(NES nes, Address basePatternAddress, Byte patternTileNumber, Byte x, Byte y) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
8000894e:	18 9a       	mov	r10,r12
80008950:	00 9b       	mov	r11,r0
80008952:	50 2a       	stdsp	sp[0x8],r10
80008954:	08 9c       	mov	r12,r4
80008956:	fe b0 fc ed 	rcall	80008330 <nes_readPPUMemory>
  //assert(ppu != NULL);
  Word horizontalOffset = patternTileNumber * PPU_PATTERN_BYTES_PER_TILE;
  Word verticalOffset = (y % PPU_VERTICAL_PIXELS_PER_TILE);
  Address pattern1Address = basePatternAddress + horizontalOffset + verticalOffset;
  Address pattern2Address = pattern1Address + 8;
  Byte pattern1 = nes_readPPUMemory(nes, pattern1Address);
8000895a:	40 19       	lddsp	r9,sp[0x4]
8000895c:	40 2a       	lddsp	r10,sp[0x8]
8000895e:	f8 09 09 4b 	lsl	r11,r12,r9
  Byte pattern2 = nes_readPPUMemory(nes, pattern2Address);
80008962:	40 08       	lddsp	r8,sp[0x0]
80008964:	f4 09 09 49 	lsl	r9,r10,r9
80008968:	f7 db c0 e1 	bfextu	r11,r11,0x7,0x1
  return nes_readPPUMemory(nes,nametableByteAddress);
}
static Byte ppu_combinePatternBytes(PPU ppu, Byte pattern1, Byte pattern2, Byte x) {
  //assert(ppu != NULL);
  x %= PPU_HORIZONTAL_PIXELS_PER_TILE;
  pattern1 = pattern1 << x;
8000896c:	f3 d9 c0 e1 	bfextu	r9,r9,0x7,0x1
  pattern1 = pattern1 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
  pattern2 = pattern2 << x;
80008970:	f2 0b 00 19 	add	r9,r9,r11<<0x1
spriteIndex) == TRUE) {
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
80008974:	c9 e0       	breq	800088b0 <ppu_updateScanlineSpriteColour8+0x140>
  return nes_readPPUMemory(nes,nametableByteAddress);
}
static Byte ppu_combinePatternBytes(PPU ppu, Byte pattern1, Byte pattern2, Byte x) {
  //assert(ppu != NULL);
  x %= PPU_HORIZONTAL_PIXELS_PER_TILE;
  pattern1 = pattern1 << x;
80008976:	e5 68 01 20 	st.b	r2[288],r8
  pattern1 = pattern1 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
  pattern2 = pattern2 << x;
  pattern2 = pattern2 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
8000897a:	40 4a       	lddsp	r10,sp[0x10]
8000897c:	14 09       	add	r9,r10
  pattern2 = pattern2 << 1;
  Byte patternIndex = pattern1 + pattern2;
8000897e:	0e 9b       	mov	r11,r7
80008980:	e5 69 00 20 	st.b	r2[32],r9
80008984:	0c 9c       	mov	r12,r6
spriteIndex) == TRUE) {
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
80008986:	c2 1e       	rcall	800085c8 <objectAttributeMemory_isBehindBackground>
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
80008988:	e5 6c 02 20 	st.b	r2[544],r12
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
8000898c:	c9 2b       	rjmp	800088b0 <ppu_updateScanlineSpriteColour8+0x140>
8000898e:	0e 9b       	mov	r11,r7
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
          ppu->spriteColoursForScanlineIsBehindBackground[spriteLeftX +i] =
objectAttributeMemory_isBehindBackground(objectAttributeMemory, spriteIndex);
80008990:	0c 9c       	mov	r12,r6
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
80008992:	c1 1e       	rcall	800085b4 <objectAttributeMemory_isFlippedHorizontal>
80008994:	30 18       	mov	r8,1
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
          ppu->spriteColoursForScanlineIsBehindBackground[spriteLeftX +i] =
objectAttributeMemory_isBehindBackground(objectAttributeMemory, spriteIndex);
80008996:	f8 08 18 00 	cp.b	r8,r12
8000899a:	f9 b9 00 02 	moveq	r9,2
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
          ppu->spriteColoursForScanlineIsBehindBackground[spriteLeftX +i] =
8000899e:	f9 b9 01 05 	movne	r9,5
  if (inRange == TRUE) {
    int i;
    for (i=0; i < PPU_HORIZONTAL_PIXELS_PER_TILE; i++) {
      if (ppu->spriteColoursForScanlineSet[spriteLeftX+i] == FALSE) {
        Byte x = i;
        if (objectAttributeMemory_isFlippedHorizontal(objectAttributeMemory,
800089a2:	50 08       	stdsp	sp[0x0],r8
800089a4:	50 19       	stdsp	sp[0x4],r9
800089a6:	08 9c       	mov	r12,r4
800089a8:	fe b0 fc 9e 	rcall	800082e4 <nes_getPPU>
800089ac:	02 9b       	mov	r11,r1
800089ae:	08 9c       	mov	r12,r4
800089b0:	fe b0 fc c0 	rcall	80008330 <nes_readPPUMemory>
800089b4:	18 9a       	mov	r10,r12
800089b6:	00 9b       	mov	r11,r0
  //assert(patternIndex <= 3);
  return patternIndex;
}
static Byte ppu_getPatternColourIndex(NES nes, Address basePatternAddress, Byte patternTileNumber, Byte x, Byte y) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
800089b8:	50 2a       	stdsp	sp[0x8],r10
800089ba:	08 9c       	mov	r12,r4
800089bc:	fe b0 fc ba 	rcall	80008330 <nes_readPPUMemory>
800089c0:	40 19       	lddsp	r9,sp[0x4]
  //assert(ppu != NULL);
  Word horizontalOffset = patternTileNumber * PPU_PATTERN_BYTES_PER_TILE;
  Word verticalOffset = (y % PPU_VERTICAL_PIXELS_PER_TILE);
  Address pattern1Address = basePatternAddress + horizontalOffset + verticalOffset;
  Address pattern2Address = pattern1Address + 8;
  Byte pattern1 = nes_readPPUMemory(nes, pattern1Address);
800089c2:	40 2a       	lddsp	r10,sp[0x8]
800089c4:	f8 09 09 4b 	lsl	r11,r12,r9
800089c8:	40 08       	lddsp	r8,sp[0x0]
800089ca:	f4 09 09 49 	lsl	r9,r10,r9
  Byte pattern2 = nes_readPPUMemory(nes, pattern2Address);
800089ce:	f7 db c0 e1 	bfextu	r11,r11,0x7,0x1
800089d2:	f3 d9 c0 e1 	bfextu	r9,r9,0x7,0x1
  return nes_readPPUMemory(nes,nametableByteAddress);
}
static Byte ppu_combinePatternBytes(PPU ppu, Byte pattern1, Byte pattern2, Byte x) {
  //assert(ppu != NULL);
  x %= PPU_HORIZONTAL_PIXELS_PER_TILE;
  pattern1 = pattern1 << x;
800089d6:	f2 0b 00 19 	add	r9,r9,r11<<0x1
  pattern1 = pattern1 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
  pattern2 = pattern2 << x;
800089da:	fe 90 ff 61 	breq	8000889c <ppu_updateScanlineSpriteColour8+0x12c>
spriteIndex) == TRUE) {
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
800089de:	e5 68 01 20 	st.b	r2[288],r8
  return nes_readPPUMemory(nes,nametableByteAddress);
}
static Byte ppu_combinePatternBytes(PPU ppu, Byte pattern1, Byte pattern2, Byte x) {
  //assert(ppu != NULL);
  x %= PPU_HORIZONTAL_PIXELS_PER_TILE;
  pattern1 = pattern1 << x;
800089e2:	40 48       	lddsp	r8,sp[0x10]
  pattern1 = pattern1 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
  pattern2 = pattern2 << x;
  pattern2 = pattern2 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
800089e4:	10 09       	add	r9,r8
800089e6:	0e 9b       	mov	r11,r7
  pattern2 = pattern2 << 1;
  Byte patternIndex = pattern1 + pattern2;
800089e8:	e5 69 00 20 	st.b	r2[32],r9
800089ec:	0c 9c       	mov	r12,r6
800089ee:	fe b0 fd ed 	rcall	800085c8 <objectAttributeMemory_isBehindBackground>
spriteIndex) == TRUE) {
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
800089f2:	e5 6c 02 20 	st.b	r2[544],r12
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
800089f6:	c5 3b       	rjmp	8000889c <ppu_updateScanlineSpriteColour8+0x12c>
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
800089f8:	0e 9b       	mov	r11,r7
800089fa:	0c 9c       	mov	r12,r6
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
          ppu->spriteColoursForScanlineIsBehindBackground[spriteLeftX +i] =
objectAttributeMemory_isBehindBackground(objectAttributeMemory, spriteIndex);
800089fc:	fe b0 fd dc 	rcall	800085b4 <objectAttributeMemory_isFlippedHorizontal>
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
80008a00:	30 18       	mov	r8,1
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
          ppu->spriteColoursForScanlineIsBehindBackground[spriteLeftX +i] =
objectAttributeMemory_isBehindBackground(objectAttributeMemory, spriteIndex);
80008a02:	f8 08 18 00 	cp.b	r8,r12
80008a06:	f9 b9 00 03 	moveq	r9,3
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
          ppu->spriteColoursForScanlineIsBehindBackground[spriteLeftX +i] =
80008a0a:	f9 b9 01 04 	movne	r9,4
  if (inRange == TRUE) {
    int i;
    for (i=0; i < PPU_HORIZONTAL_PIXELS_PER_TILE; i++) {
      if (ppu->spriteColoursForScanlineSet[spriteLeftX+i] == FALSE) {
        Byte x = i;
        if (objectAttributeMemory_isFlippedHorizontal(objectAttributeMemory,
80008a0e:	50 08       	stdsp	sp[0x0],r8
80008a10:	50 19       	stdsp	sp[0x4],r9
80008a12:	08 9c       	mov	r12,r4
80008a14:	fe b0 fc 68 	rcall	800082e4 <nes_getPPU>
80008a18:	02 9b       	mov	r11,r1
80008a1a:	08 9c       	mov	r12,r4
80008a1c:	fe b0 fc 8a 	rcall	80008330 <nes_readPPUMemory>
80008a20:	18 9a       	mov	r10,r12
80008a22:	00 9b       	mov	r11,r0
  //assert(patternIndex <= 3);
  return patternIndex;
}
static Byte ppu_getPatternColourIndex(NES nes, Address basePatternAddress, Byte patternTileNumber, Byte x, Byte y) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
80008a24:	50 2a       	stdsp	sp[0x8],r10
80008a26:	08 9c       	mov	r12,r4
80008a28:	fe b0 fc 84 	rcall	80008330 <nes_readPPUMemory>
80008a2c:	40 19       	lddsp	r9,sp[0x4]
  //assert(ppu != NULL);
  Word horizontalOffset = patternTileNumber * PPU_PATTERN_BYTES_PER_TILE;
  Word verticalOffset = (y % PPU_VERTICAL_PIXELS_PER_TILE);
  Address pattern1Address = basePatternAddress + horizontalOffset + verticalOffset;
  Address pattern2Address = pattern1Address + 8;
  Byte pattern1 = nes_readPPUMemory(nes, pattern1Address);
80008a2e:	40 2a       	lddsp	r10,sp[0x8]
80008a30:	f8 09 09 4b 	lsl	r11,r12,r9
80008a34:	40 08       	lddsp	r8,sp[0x0]
80008a36:	f4 09 09 49 	lsl	r9,r10,r9
  Byte pattern2 = nes_readPPUMemory(nes, pattern2Address);
80008a3a:	f7 db c0 e1 	bfextu	r11,r11,0x7,0x1
80008a3e:	f3 d9 c0 e1 	bfextu	r9,r9,0x7,0x1
  return nes_readPPUMemory(nes,nametableByteAddress);
}
static Byte ppu_combinePatternBytes(PPU ppu, Byte pattern1, Byte pattern2, Byte x) {
  //assert(ppu != NULL);
  x %= PPU_HORIZONTAL_PIXELS_PER_TILE;
  pattern1 = pattern1 << x;
80008a42:	f2 0b 00 19 	add	r9,r9,r11<<0x1
  pattern1 = pattern1 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
  pattern2 = pattern2 << x;
80008a46:	fe 90 ff 21 	breq	80008888 <ppu_updateScanlineSpriteColour8+0x118>
spriteIndex) == TRUE) {
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
80008a4a:	e5 68 01 20 	st.b	r2[288],r8
  return nes_readPPUMemory(nes,nametableByteAddress);
}
static Byte ppu_combinePatternBytes(PPU ppu, Byte pattern1, Byte pattern2, Byte x) {
  //assert(ppu != NULL);
  x %= PPU_HORIZONTAL_PIXELS_PER_TILE;
  pattern1 = pattern1 << x;
80008a4e:	40 4a       	lddsp	r10,sp[0x10]
  pattern1 = pattern1 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
  pattern2 = pattern2 << x;
  pattern2 = pattern2 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
80008a50:	14 09       	add	r9,r10
80008a52:	0e 9b       	mov	r11,r7
  pattern2 = pattern2 << 1;
  Byte patternIndex = pattern1 + pattern2;
80008a54:	e5 69 00 20 	st.b	r2[32],r9
80008a58:	0c 9c       	mov	r12,r6
80008a5a:	fe b0 fd b7 	rcall	800085c8 <objectAttributeMemory_isBehindBackground>
spriteIndex) == TRUE) {
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
80008a5e:	e5 6c 02 20 	st.b	r2[544],r12
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
80008a62:	c1 3b       	rjmp	80008888 <ppu_updateScanlineSpriteColour8+0x118>
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
80008a64:	0e 9b       	mov	r11,r7
80008a66:	0c 9c       	mov	r12,r6
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
          ppu->spriteColoursForScanlineIsBehindBackground[spriteLeftX +i] =
objectAttributeMemory_isBehindBackground(objectAttributeMemory, spriteIndex);
80008a68:	fe b0 fd a6 	rcall	800085b4 <objectAttributeMemory_isFlippedHorizontal>
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
80008a6c:	30 18       	mov	r8,1
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
          ppu->spriteColoursForScanlineIsBehindBackground[spriteLeftX +i] =
objectAttributeMemory_isBehindBackground(objectAttributeMemory, spriteIndex);
80008a6e:	f8 08 18 00 	cp.b	r8,r12
80008a72:	f9 b9 00 04 	moveq	r9,4
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
          ppu->spriteColoursForScanlineIsBehindBackground[spriteLeftX +i] =
80008a76:	f9 b9 01 03 	movne	r9,3
  if (inRange == TRUE) {
    int i;
    for (i=0; i < PPU_HORIZONTAL_PIXELS_PER_TILE; i++) {
      if (ppu->spriteColoursForScanlineSet[spriteLeftX+i] == FALSE) {
        Byte x = i;
        if (objectAttributeMemory_isFlippedHorizontal(objectAttributeMemory,
80008a7a:	50 08       	stdsp	sp[0x0],r8
80008a7c:	50 19       	stdsp	sp[0x4],r9
80008a7e:	08 9c       	mov	r12,r4
80008a80:	fe b0 fc 32 	rcall	800082e4 <nes_getPPU>
80008a84:	02 9b       	mov	r11,r1
80008a86:	08 9c       	mov	r12,r4
80008a88:	fe b0 fc 54 	rcall	80008330 <nes_readPPUMemory>
80008a8c:	18 9a       	mov	r10,r12
80008a8e:	00 9b       	mov	r11,r0
  //assert(patternIndex <= 3);
  return patternIndex;
}
static Byte ppu_getPatternColourIndex(NES nes, Address basePatternAddress, Byte patternTileNumber, Byte x, Byte y) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
80008a90:	50 2a       	stdsp	sp[0x8],r10
80008a92:	08 9c       	mov	r12,r4
80008a94:	fe b0 fc 4e 	rcall	80008330 <nes_readPPUMemory>
80008a98:	40 19       	lddsp	r9,sp[0x4]
  //assert(ppu != NULL);
  Word horizontalOffset = patternTileNumber * PPU_PATTERN_BYTES_PER_TILE;
  Word verticalOffset = (y % PPU_VERTICAL_PIXELS_PER_TILE);
  Address pattern1Address = basePatternAddress + horizontalOffset + verticalOffset;
  Address pattern2Address = pattern1Address + 8;
  Byte pattern1 = nes_readPPUMemory(nes, pattern1Address);
80008a9a:	40 2a       	lddsp	r10,sp[0x8]
80008a9c:	f8 09 09 4b 	lsl	r11,r12,r9
80008aa0:	40 08       	lddsp	r8,sp[0x0]
80008aa2:	f4 09 09 49 	lsl	r9,r10,r9
  Byte pattern2 = nes_readPPUMemory(nes, pattern2Address);
80008aa6:	f7 db c0 e1 	bfextu	r11,r11,0x7,0x1
80008aaa:	f3 d9 c0 e1 	bfextu	r9,r9,0x7,0x1
  return nes_readPPUMemory(nes,nametableByteAddress);
}
static Byte ppu_combinePatternBytes(PPU ppu, Byte pattern1, Byte pattern2, Byte x) {
  //assert(ppu != NULL);
  x %= PPU_HORIZONTAL_PIXELS_PER_TILE;
  pattern1 = pattern1 << x;
80008aae:	f2 0b 00 19 	add	r9,r9,r11<<0x1
  pattern1 = pattern1 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
  pattern2 = pattern2 << x;
80008ab2:	fe 90 fe e0 	breq	80008872 <ppu_updateScanlineSpriteColour8+0x102>
spriteIndex) == TRUE) {
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
80008ab6:	e5 68 01 20 	st.b	r2[288],r8
  return nes_readPPUMemory(nes,nametableByteAddress);
}
static Byte ppu_combinePatternBytes(PPU ppu, Byte pattern1, Byte pattern2, Byte x) {
  //assert(ppu != NULL);
  x %= PPU_HORIZONTAL_PIXELS_PER_TILE;
  pattern1 = pattern1 << x;
80008aba:	40 48       	lddsp	r8,sp[0x10]
  pattern1 = pattern1 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
  pattern2 = pattern2 << x;
  pattern2 = pattern2 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
80008abc:	10 09       	add	r9,r8
80008abe:	0e 9b       	mov	r11,r7
  pattern2 = pattern2 << 1;
  Byte patternIndex = pattern1 + pattern2;
80008ac0:	e5 69 00 20 	st.b	r2[32],r9
80008ac4:	0c 9c       	mov	r12,r6
80008ac6:	fe b0 fd 81 	rcall	800085c8 <objectAttributeMemory_isBehindBackground>
spriteIndex) == TRUE) {
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
80008aca:	e5 6c 02 20 	st.b	r2[544],r12
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
80008ace:	cd 2a       	rjmp	80008872 <ppu_updateScanlineSpriteColour8+0x102>
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
80008ad0:	0e 9b       	mov	r11,r7
80008ad2:	0c 9c       	mov	r12,r6
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
          ppu->spriteColoursForScanlineIsBehindBackground[spriteLeftX +i] =
objectAttributeMemory_isBehindBackground(objectAttributeMemory, spriteIndex);
80008ad4:	fe b0 fd 70 	rcall	800085b4 <objectAttributeMemory_isFlippedHorizontal>
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
80008ad8:	30 18       	mov	r8,1
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
          ppu->spriteColoursForScanlineIsBehindBackground[spriteLeftX +i] =
objectAttributeMemory_isBehindBackground(objectAttributeMemory, spriteIndex);
80008ada:	f8 08 18 00 	cp.b	r8,r12
80008ade:	f9 b9 00 05 	moveq	r9,5
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
          ppu->spriteColoursForScanlineIsBehindBackground[spriteLeftX +i] =
80008ae2:	f9 b9 01 02 	movne	r9,2
  if (inRange == TRUE) {
    int i;
    for (i=0; i < PPU_HORIZONTAL_PIXELS_PER_TILE; i++) {
      if (ppu->spriteColoursForScanlineSet[spriteLeftX+i] == FALSE) {
        Byte x = i;
        if (objectAttributeMemory_isFlippedHorizontal(objectAttributeMemory,
80008ae6:	50 08       	stdsp	sp[0x0],r8
80008ae8:	50 19       	stdsp	sp[0x4],r9
80008aea:	08 9c       	mov	r12,r4
80008aec:	fe b0 fb fc 	rcall	800082e4 <nes_getPPU>
80008af0:	02 9b       	mov	r11,r1
80008af2:	08 9c       	mov	r12,r4
80008af4:	fe b0 fc 1e 	rcall	80008330 <nes_readPPUMemory>
80008af8:	18 9a       	mov	r10,r12
80008afa:	00 9b       	mov	r11,r0
  //assert(patternIndex <= 3);
  return patternIndex;
}
static Byte ppu_getPatternColourIndex(NES nes, Address basePatternAddress, Byte patternTileNumber, Byte x, Byte y) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
80008afc:	50 2a       	stdsp	sp[0x8],r10
80008afe:	08 9c       	mov	r12,r4
80008b00:	fe b0 fc 18 	rcall	80008330 <nes_readPPUMemory>
80008b04:	40 19       	lddsp	r9,sp[0x4]
  //assert(ppu != NULL);
  Word horizontalOffset = patternTileNumber * PPU_PATTERN_BYTES_PER_TILE;
  Word verticalOffset = (y % PPU_VERTICAL_PIXELS_PER_TILE);
  Address pattern1Address = basePatternAddress + horizontalOffset + verticalOffset;
  Address pattern2Address = pattern1Address + 8;
  Byte pattern1 = nes_readPPUMemory(nes, pattern1Address);
80008b06:	40 2a       	lddsp	r10,sp[0x8]
80008b08:	f8 09 09 4b 	lsl	r11,r12,r9
80008b0c:	40 08       	lddsp	r8,sp[0x0]
80008b0e:	f4 09 09 49 	lsl	r9,r10,r9
  Byte pattern2 = nes_readPPUMemory(nes, pattern2Address);
80008b12:	f7 db c0 e1 	bfextu	r11,r11,0x7,0x1
80008b16:	f3 d9 c0 e1 	bfextu	r9,r9,0x7,0x1
  return nes_readPPUMemory(nes,nametableByteAddress);
}
static Byte ppu_combinePatternBytes(PPU ppu, Byte pattern1, Byte pattern2, Byte x) {
  //assert(ppu != NULL);
  x %= PPU_HORIZONTAL_PIXELS_PER_TILE;
  pattern1 = pattern1 << x;
80008b1a:	f2 0b 00 19 	add	r9,r9,r11<<0x1
  pattern1 = pattern1 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
  pattern2 = pattern2 << x;
80008b1e:	fe 90 fe 9f 	breq	8000885c <ppu_updateScanlineSpriteColour8+0xec>
spriteIndex) == TRUE) {
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
80008b22:	e5 68 01 20 	st.b	r2[288],r8
  return nes_readPPUMemory(nes,nametableByteAddress);
}
static Byte ppu_combinePatternBytes(PPU ppu, Byte pattern1, Byte pattern2, Byte x) {
  //assert(ppu != NULL);
  x %= PPU_HORIZONTAL_PIXELS_PER_TILE;
  pattern1 = pattern1 << x;
80008b26:	40 4a       	lddsp	r10,sp[0x10]
  pattern1 = pattern1 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
  pattern2 = pattern2 << x;
  pattern2 = pattern2 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
80008b28:	14 09       	add	r9,r10
80008b2a:	0e 9b       	mov	r11,r7
  pattern2 = pattern2 << 1;
  Byte patternIndex = pattern1 + pattern2;
80008b2c:	e5 69 00 20 	st.b	r2[32],r9
80008b30:	0c 9c       	mov	r12,r6
80008b32:	fe b0 fd 4b 	rcall	800085c8 <objectAttributeMemory_isBehindBackground>
spriteIndex) == TRUE) {
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
80008b36:	e5 6c 02 20 	st.b	r2[544],r12
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
80008b3a:	c9 1a       	rjmp	8000885c <ppu_updateScanlineSpriteColour8+0xec>
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
80008b3c:	0e 9b       	mov	r11,r7
80008b3e:	0c 9c       	mov	r12,r6
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
          ppu->spriteColoursForScanlineIsBehindBackground[spriteLeftX +i] =
objectAttributeMemory_isBehindBackground(objectAttributeMemory, spriteIndex);
80008b40:	fe b0 fd 3a 	rcall	800085b4 <objectAttributeMemory_isFlippedHorizontal>
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
80008b44:	30 18       	mov	r8,1
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
          ppu->spriteColoursForScanlineIsBehindBackground[spriteLeftX +i] =
objectAttributeMemory_isBehindBackground(objectAttributeMemory, spriteIndex);
80008b46:	f8 08 18 00 	cp.b	r8,r12
80008b4a:	f9 b9 00 06 	moveq	r9,6
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
          ppu->spriteColoursForScanlineIsBehindBackground[spriteLeftX +i] =
80008b4e:	f9 b9 01 01 	movne	r9,1
  if (inRange == TRUE) {
    int i;
    for (i=0; i < PPU_HORIZONTAL_PIXELS_PER_TILE; i++) {
      if (ppu->spriteColoursForScanlineSet[spriteLeftX+i] == FALSE) {
        Byte x = i;
        if (objectAttributeMemory_isFlippedHorizontal(objectAttributeMemory,
80008b52:	50 08       	stdsp	sp[0x0],r8
80008b54:	50 19       	stdsp	sp[0x4],r9
80008b56:	08 9c       	mov	r12,r4
80008b58:	fe b0 fb c6 	rcall	800082e4 <nes_getPPU>
80008b5c:	02 9b       	mov	r11,r1
80008b5e:	08 9c       	mov	r12,r4
80008b60:	fe b0 fb e8 	rcall	80008330 <nes_readPPUMemory>
80008b64:	18 9a       	mov	r10,r12
80008b66:	00 9b       	mov	r11,r0
  //assert(patternIndex <= 3);
  return patternIndex;
}
static Byte ppu_getPatternColourIndex(NES nes, Address basePatternAddress, Byte patternTileNumber, Byte x, Byte y) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
80008b68:	50 2a       	stdsp	sp[0x8],r10
80008b6a:	08 9c       	mov	r12,r4
80008b6c:	fe b0 fb e2 	rcall	80008330 <nes_readPPUMemory>
80008b70:	40 19       	lddsp	r9,sp[0x4]
  //assert(ppu != NULL);
  Word horizontalOffset = patternTileNumber * PPU_PATTERN_BYTES_PER_TILE;
  Word verticalOffset = (y % PPU_VERTICAL_PIXELS_PER_TILE);
  Address pattern1Address = basePatternAddress + horizontalOffset + verticalOffset;
  Address pattern2Address = pattern1Address + 8;
  Byte pattern1 = nes_readPPUMemory(nes, pattern1Address);
80008b72:	40 2a       	lddsp	r10,sp[0x8]
80008b74:	f8 09 09 4b 	lsl	r11,r12,r9
80008b78:	40 08       	lddsp	r8,sp[0x0]
80008b7a:	f4 09 09 49 	lsl	r9,r10,r9
  Byte pattern2 = nes_readPPUMemory(nes, pattern2Address);
80008b7e:	f7 db c0 e1 	bfextu	r11,r11,0x7,0x1
80008b82:	f3 d9 c0 e1 	bfextu	r9,r9,0x7,0x1
  return nes_readPPUMemory(nes,nametableByteAddress);
}
static Byte ppu_combinePatternBytes(PPU ppu, Byte pattern1, Byte pattern2, Byte x) {
  //assert(ppu != NULL);
  x %= PPU_HORIZONTAL_PIXELS_PER_TILE;
  pattern1 = pattern1 << x;
80008b86:	f2 0b 00 19 	add	r9,r9,r11<<0x1
  pattern1 = pattern1 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
  pattern2 = pattern2 << x;
80008b8a:	fe 90 fe 5e 	breq	80008846 <ppu_updateScanlineSpriteColour8+0xd6>
spriteIndex) == TRUE) {
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
80008b8e:	e5 68 01 20 	st.b	r2[288],r8
  return nes_readPPUMemory(nes,nametableByteAddress);
}
static Byte ppu_combinePatternBytes(PPU ppu, Byte pattern1, Byte pattern2, Byte x) {
  //assert(ppu != NULL);
  x %= PPU_HORIZONTAL_PIXELS_PER_TILE;
  pattern1 = pattern1 << x;
80008b92:	40 48       	lddsp	r8,sp[0x10]
  pattern1 = pattern1 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
  pattern2 = pattern2 << x;
  pattern2 = pattern2 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
80008b94:	10 09       	add	r9,r8
80008b96:	0e 9b       	mov	r11,r7
  pattern2 = pattern2 << 1;
  Byte patternIndex = pattern1 + pattern2;
80008b98:	e5 69 00 20 	st.b	r2[32],r9
80008b9c:	0c 9c       	mov	r12,r6
80008b9e:	fe b0 fd 15 	rcall	800085c8 <objectAttributeMemory_isBehindBackground>
spriteIndex) == TRUE) {
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
80008ba2:	e5 6c 02 20 	st.b	r2[544],r12
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
80008ba6:	fe 9f fe 50 	bral	80008846 <ppu_updateScanlineSpriteColour8+0xd6>
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
80008baa:	50 08       	stdsp	sp[0x0],r8
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
          ppu->spriteColoursForScanlineIsBehindBackground[spriteLeftX +i] =
objectAttributeMemory_isBehindBackground(objectAttributeMemory, spriteIndex);
80008bac:	0e 9b       	mov	r11,r7
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
80008bae:	0c 9c       	mov	r12,r6
80008bb0:	fe b0 fd 02 	rcall	800085b4 <objectAttributeMemory_isFlippedHorizontal>
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
          ppu->spriteColoursForScanlineIsBehindBackground[spriteLeftX +i] =
objectAttributeMemory_isBehindBackground(objectAttributeMemory, spriteIndex);
80008bb4:	30 1a       	mov	r10,1
80008bb6:	f8 0a 18 00 	cp.b	r10,r12
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
          ppu->spriteColoursForScanlineIsBehindBackground[spriteLeftX +i] =
80008bba:	f9 b9 00 07 	moveq	r9,7
80008bbe:	f9 b9 01 00 	movne	r9,0
  if (inRange == TRUE) {
    int i;
    for (i=0; i < PPU_HORIZONTAL_PIXELS_PER_TILE; i++) {
      if (ppu->spriteColoursForScanlineSet[spriteLeftX+i] == FALSE) {
        Byte x = i;
        if (objectAttributeMemory_isFlippedHorizontal(objectAttributeMemory,
80008bc2:	08 9c       	mov	r12,r4
80008bc4:	50 19       	stdsp	sp[0x4],r9
80008bc6:	fe b0 fb 8f 	rcall	800082e4 <nes_getPPU>
80008bca:	02 9b       	mov	r11,r1
80008bcc:	08 9c       	mov	r12,r4
80008bce:	fe b0 fb b1 	rcall	80008330 <nes_readPPUMemory>
80008bd2:	18 9a       	mov	r10,r12
80008bd4:	00 9b       	mov	r11,r0
80008bd6:	50 2a       	stdsp	sp[0x8],r10
  //assert(patternIndex <= 3);
  return patternIndex;
}
static Byte ppu_getPatternColourIndex(NES nes, Address basePatternAddress, Byte patternTileNumber, Byte x, Byte y) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
80008bd8:	08 9c       	mov	r12,r4
80008bda:	fe b0 fb ab 	rcall	80008330 <nes_readPPUMemory>
80008bde:	40 19       	lddsp	r9,sp[0x4]
  //assert(ppu != NULL);
  Word horizontalOffset = patternTileNumber * PPU_PATTERN_BYTES_PER_TILE;
  Word verticalOffset = (y % PPU_VERTICAL_PIXELS_PER_TILE);
  Address pattern1Address = basePatternAddress + horizontalOffset + verticalOffset;
  Address pattern2Address = pattern1Address + 8;
  Byte pattern1 = nes_readPPUMemory(nes, pattern1Address);
80008be0:	40 2a       	lddsp	r10,sp[0x8]
80008be2:	f8 09 09 4b 	lsl	r11,r12,r9
80008be6:	40 08       	lddsp	r8,sp[0x0]
80008be8:	f4 09 09 49 	lsl	r9,r10,r9
  Byte pattern2 = nes_readPPUMemory(nes, pattern2Address);
80008bec:	f7 db c0 e1 	bfextu	r11,r11,0x7,0x1
80008bf0:	f3 d9 c0 e1 	bfextu	r9,r9,0x7,0x1
  return nes_readPPUMemory(nes,nametableByteAddress);
}
static Byte ppu_combinePatternBytes(PPU ppu, Byte pattern1, Byte pattern2, Byte x) {
  //assert(ppu != NULL);
  x %= PPU_HORIZONTAL_PIXELS_PER_TILE;
  pattern1 = pattern1 << x;
80008bf4:	f2 0b 00 19 	add	r9,r9,r11<<0x1
  pattern1 = pattern1 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
  pattern2 = pattern2 << x;
80008bf8:	fe 90 fe 1c 	breq	80008830 <ppu_updateScanlineSpriteColour8+0xc0>
spriteIndex) == TRUE) {
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
80008bfc:	f1 62 01 20 	st.b	r8[288],r2
  return nes_readPPUMemory(nes,nametableByteAddress);
}
static Byte ppu_combinePatternBytes(PPU ppu, Byte pattern1, Byte pattern2, Byte x) {
  //assert(ppu != NULL);
  x %= PPU_HORIZONTAL_PIXELS_PER_TILE;
  pattern1 = pattern1 << x;
80008c00:	40 4a       	lddsp	r10,sp[0x10]
  pattern1 = pattern1 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
  pattern2 = pattern2 << x;
  pattern2 = pattern2 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
80008c02:	14 09       	add	r9,r10
80008c04:	f1 69 00 20 	st.b	r8[32],r9
  pattern2 = pattern2 << 1;
  Byte patternIndex = pattern1 + pattern2;
80008c08:	50 08       	stdsp	sp[0x0],r8
80008c0a:	0e 9b       	mov	r11,r7
80008c0c:	0c 9c       	mov	r12,r6
spriteIndex) == TRUE) {
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
80008c0e:	fe b0 fc dd 	rcall	800085c8 <objectAttributeMemory_isBehindBackground>
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
80008c12:	40 08       	lddsp	r8,sp[0x0]
80008c14:	f1 6c 02 20 	st.b	r8[544],r12
          x = PPU_HORIZONTAL_PIXELS_PER_TILE - x - 1;
        }
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
80008c18:	fe 9f fe 0c 	bral	80008830 <ppu_updateScanlineSpriteColour8+0xc0>

80008c1c <ppu_init>:
80008c1c:	eb cd 40 e0 	pushm	r5-r7,lr
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
          ppu->spriteColoursForScanlineIsBehindBackground[spriteLeftX +i] =
objectAttributeMemory_isBehindBackground(objectAttributeMemory, spriteIndex);
80008c20:	e0 6c 03 20 	mov	r12,800
80008c24:	e0 a0 39 6c 	rcall	8000fefc <malloc>
        Byte patternIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
        if (patternIndex != 0) {
          ppu->spriteColoursForScanline[spriteLeftX +i] = patternIndex + attributeIndex;
          ppu->spriteColoursForScanlineSet[spriteLeftX+i] = TRUE;
          ppu->spriteColoursForScanlineIsBehindBackground[spriteLeftX +i] =
80008c28:	30 08       	mov	r8,0
80008c2a:	18 97       	mov	r7,r12
80008c2c:	30 06       	mov	r6,0
80008c2e:	b8 d8       	st.b	r12[0x5],r8
80008c30:	b8 88       	st.b	r12[0x0],r8
80008c32:	b8 98       	st.b	r12[0x1],r8
80008c34:	b8 a8       	st.b	r12[0x2],r8
80008c36:	b8 b8       	st.b	r12[0x3],r8
80008c38:	b8 c8       	st.b	r12[0x4],r8
80008c3a:	f9 68 00 0c 	st.b	r12[12],r8
80008c3e:	f9 68 00 0d 	st.b	r12[13],r8
80008c42:	b8 e8       	st.b	r12[0x6],r8
80008c44:	b8 f8       	st.b	r12[0x7],r8
80008c46:	f9 68 00 0b 	st.b	r12[11],r8
80008c4a:	f9 68 00 09 	st.b	r12[9],r8
80008c4e:	f9 68 00 0a 	st.b	r12[10],r8
80008c52:	e0 65 01 00 	mov	r5,256
80008c56:	99 46       	st.w	r12[0x10],r6
80008c58:	99 56       	st.w	r12[0x14],r6
80008c5a:	99 66       	st.w	r12[0x18],r6
};
static void ppu_resetSpriteColoursForScanline(PPU ppu) {
  //assert(ppu != NULL);
 // int i;
  
  memset(ppu->spriteColoursForScanline,0,PPU_SCREEN_WIDTH_IN_PIXELS);
80008c5c:	0c 9b       	mov	r11,r6
80008c5e:	0a 9a       	mov	r10,r5
80008c60:	2e 0c       	sub	r12,-32
80008c62:	e0 a0 3c 11 	rcall	80010484 <memset>
  memset(ppu->spriteColoursForScanlineSet,FALSE,PPU_SCREEN_WIDTH_IN_PIXELS);
80008c66:	0a 9a       	mov	r10,r5
80008c68:	0c 9b       	mov	r11,r6
80008c6a:	ee cc fe e0 	sub	r12,r7,-288
80008c6e:	e0 a0 3c 0b 	rcall	80010484 <memset>
  memset(ppu->spriteColoursForScanlineIsBehindBackground,FALSE,PPU_SCREEN_WIDTH_IN_PIXELS);
80008c72:	0a 9a       	mov	r10,r5
80008c74:	0c 9b       	mov	r11,r6
80008c76:	ee cc fd e0 	sub	r12,r7,-544
80008c7a:	e0 a0 3c 05 	rcall	80010484 <memset>
  ppu->currentScanlineCycle = 0;
  ppu_resetSpriteColoursForScanline(ppu);
  ppu->ppuMemoryReadBuffer = 0;
  ppu->currentFrame = 0;
  return ppu;
}
80008c7e:	0e 9c       	mov	r12,r7
  ppu->currentCycle = 0;
  ppu->currentScanline = 0;
  ppu->currentScanlineCycle = 0;
  ppu_resetSpriteColoursForScanline(ppu);
  ppu->ppuMemoryReadBuffer = 0;
  ppu->currentFrame = 0;
80008c80:	8f 76       	st.w	r7[0x1c],r6
  ppu->scrollRegister = 0;
  ppu->currentCycle = 0;
  ppu->currentScanline = 0;
  ppu->currentScanlineCycle = 0;
  ppu_resetSpriteColoursForScanline(ppu);
  ppu->ppuMemoryReadBuffer = 0;
80008c82:	ef 66 00 08 	st.b	r7[8],r6
  ppu->currentFrame = 0;
  return ppu;
}
80008c86:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80008c8a:	d7 03       	nop

80008c8c <ppu_step>:
80008c8c:	d4 31       	pushm	r0-r7,lr
80008c8e:	20 1d       	sub	sp,4
80008c90:	18 96       	mov	r6,r12
80008c92:	fe b0 fb 29 	rcall	800082e4 <nes_getPPU>
  //GUI gui = nes_getGUI(nes);
  //assert(gui != NULL);
  //debug_printf("ppu_step\n");
  PPU ppu = nes_getPPU(nes);
  //assert(ppu != NULL);
  if (ppu->currentCycle == 0) {
80008c96:	78 48       	ld.w	r8,r12[0x10]
    ppu->statusRegister = 0; // everything is cleared on line 0
80008c98:	58 08       	cp.w	r8,0
80008c9a:	f9 f8 0e 02 	st.beq	r12[0x2],r8
	 //gpio_toggle_pin(63);
  //assert(nes != NULL);
  //GUI gui = nes_getGUI(nes);
  //assert(gui != NULL);
  //debug_printf("ppu_step\n");
  PPU ppu = nes_getPPU(nes);
80008c9e:	18 97       	mov	r7,r12
  //assert(ppu != NULL);
  if (ppu->currentCycle == 0) {
    ppu->statusRegister = 0; // everything is cleared on line 0
  }
  if (ppu->currentScanline >=0 && ppu->currentScanline <= 19) {
80008ca0:	78 59       	ld.w	r9,r12[0x14]
80008ca2:	59 39       	cp.w	r9,19
80008ca4:	e0 8b 00 59 	brhi	80008d56 <ppu_step+0xca>
    // do nothing, we are in vblank
	ppu->currentScanline=20;
	ppu->currentScanlineCycle=0;
80008ca8:	30 09       	mov	r9,0
  if (ppu->currentCycle == 0) {
    ppu->statusRegister = 0; // everything is cleared on line 0
  }
  if (ppu->currentScanline >=0 && ppu->currentScanline <= 19) {
    // do nothing, we are in vblank
	ppu->currentScanline=20;
80008caa:	31 4a       	mov	r10,20
	ppu->currentScanlineCycle=0;
80008cac:	99 69       	st.w	r12[0x18],r9
  if (ppu->currentCycle == 0) {
    ppu->statusRegister = 0; // everything is cleared on line 0
  }
  if (ppu->currentScanline >=0 && ppu->currentScanline <= 19) {
    // do nothing, we are in vblank
	ppu->currentScanline=20;
80008cae:	99 5a       	st.w	r12[0x14],r10
    drawing lines starts all over again.
    
  } else {
    //assert(FALSE);
  }*/
  ppu->currentCycle++;
80008cb0:	2f f8       	sub	r8,-1
  ppu->currentScanlineCycle++;
  if (ppu->currentCycle % PPU_CYCLES_PER_SCANLINE == 0) {
80008cb2:	e0 6b 03 01 	mov	r11,769
80008cb6:	ea 1b 30 0c 	orh	r11,0x300c
80008cba:	f0 0b 04 4a 	muls.d	r10,r8,r11
    
  } else {
    //assert(FALSE);
  }*/
  ppu->currentCycle++;
  ppu->currentScanlineCycle++;
80008cbe:	2f f9       	sub	r9,-1
  if (ppu->currentCycle % PPU_CYCLES_PER_SCANLINE == 0) {
80008cc0:	f0 0a 14 1f 	asr	r10,r8,0x1f
    
  } else {
    //assert(FALSE);
  }*/
  ppu->currentCycle++;
  ppu->currentScanlineCycle++;
80008cc4:	8f 69       	st.w	r7[0x18],r9
    drawing lines starts all over again.
    
  } else {
    //assert(FALSE);
  }*/
  ppu->currentCycle++;
80008cc6:	8f 48       	st.w	r7[0x10],r8
  ppu->currentScanlineCycle++;
  if (ppu->currentCycle % PPU_CYCLES_PER_SCANLINE == 0) {
80008cc8:	f6 09 14 06 	asr	r9,r11,0x6
80008ccc:	14 19       	sub	r9,r10
80008cce:	e0 6a 01 55 	mov	r10,341
80008cd2:	b5 39       	mul	r9,r10
80008cd4:	f0 09 01 09 	sub	r9,r8,r9
80008cd8:	c3 d1       	brne	80008d52 <ppu_step+0xc6>
    ppu->currentScanline++;
80008cda:	6e 58       	ld.w	r8,r7[0x14]
    ppu->currentScanlineCycle = 0;
	
	
	if (ppu->currentScanline%20)
80008cdc:	e0 6b 66 67 	mov	r11,26215
80008ce0:	ea 1b 66 66 	orh	r11,0x6666
    //assert(FALSE);
  }*/
  ppu->currentCycle++;
  ppu->currentScanlineCycle++;
  if (ppu->currentCycle % PPU_CYCLES_PER_SCANLINE == 0) {
    ppu->currentScanline++;
80008ce4:	2f f8       	sub	r8,-1
    ppu->currentScanlineCycle = 0;
80008ce6:	8f 69       	st.w	r7[0x18],r9
	
	
	if (ppu->currentScanline%20)
80008ce8:	f0 0b 04 4a 	muls.d	r10,r8,r11
    //assert(FALSE);
  }*/
  ppu->currentCycle++;
  ppu->currentScanlineCycle++;
  if (ppu->currentCycle % PPU_CYCLES_PER_SCANLINE == 0) {
    ppu->currentScanline++;
80008cec:	8f 58       	st.w	r7[0x14],r8
    ppu->currentScanlineCycle = 0;
	
	
	if (ppu->currentScanline%20)
80008cee:	f6 0a 14 03 	asr	r10,r11,0x3
80008cf2:	f0 0b 14 1f 	asr	r11,r8,0x1f
80008cf6:	16 1a       	sub	r10,r11
80008cf8:	f4 0a 00 2a 	add	r10,r10,r10<<0x2
80008cfc:	f0 0a 01 2a 	sub	r10,r8,r10<<0x2
80008d00:	c0 60       	breq	80008d0c <ppu_step+0x80>
    ppu->controlRegister &= MASK_CONTROL_NMI_OFF;
  }
}
static Bool ppu_getControlNMI(PPU ppu) {
  //assert(ppu != NULL);
  if ((ppu->controlRegister & MASK_CONTROL_NMI_ON) == MASK_CONTROL_NMI_ON) {
80008d02:	0f 8a       	ld.ub	r10,r7[0x0]
80008d04:	f2 0a 18 00 	cp.b	r10,r9
80008d08:	e0 85 01 49 	brlt	80008f9a <ppu_step+0x30e>
			nes_generateNMI(nes);
		}
	}
	
	
    if (ppu->currentScanline == 20) {
80008d0c:	59 48       	cp.w	r8,20
80008d0e:	e0 80 01 40 	breq	80008f8e <ppu_step+0x302>
      // The VBL flag is cleared 6820 PPU clocks, or exactly 20 scanlines, after it isset.
      //assert(ppu->currentCycle == 6820);
      ppu_setStatusSpriteOverflow(ppu, FALSE);
      ppu_setStatusSpriteCollisionHit(ppu, FALSE);
      ppu_setStatusVerticalBlank(ppu, FALSE);
    } else if (ppu->currentScanline % PPU_SCANLINES_PER_FRAME == 0) {
80008d12:	e0 6b cb 3d 	mov	r11,52029
80008d16:	ea 1b 3e 88 	orh	r11,0x3e88
80008d1a:	f0 0b 04 4a 	muls.d	r10,r8,r11
80008d1e:	f0 0a 14 1f 	asr	r10,r8,0x1f
80008d22:	f6 09 14 06 	asr	r9,r11,0x6
80008d26:	14 19       	sub	r9,r10
80008d28:	e0 6a 01 06 	mov	r10,262
80008d2c:	b5 39       	mul	r9,r10
80008d2e:	12 18       	sub	r8,r9
80008d30:	c1 11       	brne	80008d52 <ppu_step+0xc6>
  }
}
static void ppu_setStatusVerticalBlank(PPU ppu, Bool state) {
  //assert(ppu != NULL);
  if (state == TRUE) {
    ppu->statusRegister |= MASK_STATUS_VBLANK_ON;
80008d32:	0f a9       	ld.ub	r9,r7[0x2]
80008d34:	ea 19 ff ff 	orh	r9,0xffff
80008d38:	e8 19 ff 80 	orl	r9,0xff80
      ppu_setStatusVerticalBlank(ppu, FALSE);
    } else if (ppu->currentScanline % PPU_SCANLINES_PER_FRAME == 0) {
      // $2002.5 and $2002.6 after being set, stay that way for the first 20
      // scanlines of the new frame, relative to the VINT.
      ppu_setStatusVerticalBlank(ppu, TRUE);
      ppu->currentCycle = 0;
80008d3c:	8f 48       	st.w	r7[0x10],r8
  }
}
static void ppu_setStatusVerticalBlank(PPU ppu, Bool state) {
  //assert(ppu != NULL);
  if (state == TRUE) {
    ppu->statusRegister |= MASK_STATUS_VBLANK_ON;
80008d3e:	ae a9       	st.b	r7[0x2],r9
    } else if (ppu->currentScanline % PPU_SCANLINES_PER_FRAME == 0) {
      // $2002.5 and $2002.6 after being set, stay that way for the first 20
      // scanlines of the new frame, relative to the VINT.
      ppu_setStatusVerticalBlank(ppu, TRUE);
      ppu->currentCycle = 0;
      ppu->currentScanline = 0;
80008d40:	8f 58       	st.w	r7[0x14],r8
      ppu->currentFrame++;
80008d42:	6e 79       	ld.w	r9,r7[0x1c]
80008d44:	2f f9       	sub	r9,-1
80008d46:	8f 79       	st.w	r7[0x1c],r9
    ppu->controlRegister &= MASK_CONTROL_NMI_OFF;
  }
}
static Bool ppu_getControlNMI(PPU ppu) {
  //assert(ppu != NULL);
  if ((ppu->controlRegister & MASK_CONTROL_NMI_ON) == MASK_CONTROL_NMI_ON) {
80008d48:	0f 89       	ld.ub	r9,r7[0x0]
80008d4a:	f0 09 18 00 	cp.b	r9,r8
80008d4e:	e0 85 01 2b 	brlt	80008fa4 <ppu_step+0x318>
      if (ppu_getControlNMI(ppu) == TRUE) {
        nes_generateNMI(nes);
      }
    }
  }
}
80008d52:	2f fd       	sub	sp,-4
80008d54:	d8 32       	popm	r0-r7,pc
  }
  if (ppu->currentScanline >=0 && ppu->currentScanline <= 19) {
    // do nothing, we are in vblank
	ppu->currentScanline=20;
	ppu->currentScanlineCycle=0;
  } else if (ppu->currentScanline == 20) {
80008d56:	59 49       	cp.w	r9,20
80008d58:	e0 80 01 19 	breq	80008f8a <ppu_step+0x2fe>
    scanline. Other than that, the operation of this scanline is identical to
    any other. The primary reason this scanline exists is to start the object
    render pipeline, since it takes 256 cc's worth of time to determine which
    objects are in range or not for any particular scanline.
    */
  } else if (ppu->currentScanline >= 21 && ppu->currentScanline <= 260) {
80008d5c:	21 59       	sub	r9,21
80008d5e:	e0 49 00 ef 	cp.w	r9,239
80008d62:	e0 8b 01 14 	brhi	80008f8a <ppu_step+0x2fe>
    /*
    21..260: after rendering 1 dummy scanline, the PPU starts to render the
    actual data to be displayed on the screen. This is done for 240 scanlines,
    of course.
    */
    if (ppu->currentScanlineCycle >=0 && ppu->currentScanlineCycle <PPU_SCREEN_WIDTH_IN_PIXELS) {
80008d66:	78 69       	ld.w	r9,r12[0x18]
80008d68:	e0 49 00 ff 	cp.w	r9,255
80008d6c:	fe 9b ff a2 	brhi	80008cb0 <ppu_step+0x24>
  //assert(systemColourIndex < PPU_NUM_SYSTEM_COLOURS);
  return systemColourIndex;
}
static void ppu_renderCurrentPixel(NES nes) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
80008d70:	0c 9c       	mov	r12,r6
80008d72:	fe b0 fa b9 	rcall	800082e4 <nes_getPPU>
80008d76:	18 92       	mov	r2,r12
  //assert(ppu != NULL);
  GUI gui = nes_getGUI(nes);
80008d78:	0c 9c       	mov	r12,r6
80008d7a:	fe b0 fa ad 	rcall	800082d4 <nes_getGUI>
  //assert(gui != NULL);
  if (ppu->currentScanlineCycle == 0) {
80008d7e:	64 65       	ld.w	r5,r2[0x18]
}
static void ppu_renderCurrentPixel(NES nes) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
  //assert(ppu != NULL);
  GUI gui = nes_getGUI(nes);
80008d80:	18 91       	mov	r1,r12
  //assert(gui != NULL);
  if (ppu->currentScanlineCycle == 0) {
80008d82:	58 05       	cp.w	r5,0
80008d84:	e0 80 01 1d 	breq	80008fbe <ppu_step+0x332>
  Byte systemIndex = nes_readPPUMemory(nes, address);
  return systemIndex;
}
static Byte ppu_getCurrentBackgroundColour(NES nes) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
80008d88:	0c 9c       	mov	r12,r6
80008d8a:	fe b0 fa ad 	rcall	800082e4 <nes_getPPU>
80008d8e:	18 95       	mov	r5,r12
  Word tileNumber = horizontalOffset + verticalOffset;
  return tileNumber;
}
static Byte ppu_getBackgroundNametableByte(NES nes) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
80008d90:	0c 9c       	mov	r12,r6
    ppu->controlRegister &= MASK_CONTROL_BACKGROUND_TILE_TABLE_OFF;
  }
}
static Bool ppu_getControlBackgroundTileTable(PPU ppu) {
  //assert(ppu != NULL);
  if ((ppu->controlRegister & MASK_CONTROL_BACKGROUND_TILE_TABLE_ON) ==
80008d92:	0b 84       	ld.ub	r4,r5[0x0]
    return FALSE;
  }
}
static Byte ppu_getCurrentX(PPU ppu) {
  //assert(ppu != NULL);
  return ppu->currentScanlineCycle;
80008d94:	6a 63       	ld.w	r3,r5[0x18]
}
static Byte ppu_getCurrentY(PPU ppu) {
  //assert(ppu != NULL);
  return ppu->currentScanline - PPU_WASTED_VBLANK_SCANLINES -
80008d96:	6a 50       	ld.w	r0,r5[0x14]
  Word tileNumber = horizontalOffset + verticalOffset;
  return tileNumber;
}
static Byte ppu_getBackgroundNametableByte(NES nes) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
80008d98:	fe b0 fa a6 	rcall	800082e4 <nes_getPPU>
  //assert(ppu != NULL);
  free(ppu);
}
static Bool ppu_getControlHorizontalScrollNametable(PPU ppu) {
  //assert(ppu != NULL);
  if ( (ppu->controlRegister & MASK_CONTROL_HORIZONTAL_SCROLL_NAME_TABLE_ON) ==
80008d9c:	e0 6b 2c 00 	mov	r11,11264
80008da0:	19 88       	ld.ub	r8,r12[0x0]
    ppu->controlRegister &= MASK_CONTROL_BACKGROUND_TILE_TABLE_OFF;
  }
}
static Bool ppu_getControlBackgroundTileTable(PPU ppu) {
  //assert(ppu != NULL);
  if ((ppu->controlRegister & MASK_CONTROL_BACKGROUND_TILE_TABLE_ON) ==
80008da2:	a9 64       	lsl	r4,0x8
    ppu->controlRegister &= MASK_CONTROL_HORIZONTAL_SCROLL_NAME_TABLE_OFF;
  }
}
static Bool ppu_getControlVerticalScrollNametable(PPU ppu) {
  //assert(ppu != NULL);
  if ( (ppu->controlRegister & MASK_CONTROL_VERTICAL_SCROLL_NAME_TABLE_ON) ==
80008da4:	10 9a       	mov	r10,r8
  //assert(ppu != NULL);
  free(ppu);
}
static Bool ppu_getControlHorizontalScrollNametable(PPU ppu) {
  //assert(ppu != NULL);
  if ( (ppu->controlRegister & MASK_CONTROL_HORIZONTAL_SCROLL_NAME_TABLE_ON) ==
80008da6:	e0 69 28 00 	mov	r9,10240
80008daa:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008dae:	e0 6e 24 00 	mov	lr,9216
80008db2:	f6 09 17 10 	movne	r9,r11
    ppu->controlRegister &= MASK_CONTROL_BACKGROUND_TILE_TABLE_OFF;
  }
}
static Bool ppu_getControlBackgroundTileTable(PPU ppu) {
  //assert(ppu != NULL);
  if ((ppu->controlRegister & MASK_CONTROL_BACKGROUND_TILE_TABLE_ON) ==
80008db6:	e2 14 10 00 	andl	r4,0x1000,COH
  //assert(ppu != NULL);
  free(ppu);
}
static Bool ppu_getControlHorizontalScrollNametable(PPU ppu) {
  //assert(ppu != NULL);
  if ( (ppu->controlRegister & MASK_CONTROL_HORIZONTAL_SCROLL_NAME_TABLE_ON) ==
80008dba:	e0 6b 20 00 	mov	r11,8192
    ppu->controlRegister &= MASK_CONTROL_HORIZONTAL_SCROLL_NAME_TABLE_OFF;
  }
}
static Bool ppu_getControlVerticalScrollNametable(PPU ppu) {
  //assert(ppu != NULL);
  if ( (ppu->controlRegister & MASK_CONTROL_VERTICAL_SCROLL_NAME_TABLE_ON) ==
80008dbe:	e2 1a 00 02 	andl	r10,0x2,COH
  //assert(ppu != NULL);
  free(ppu);
}
static Bool ppu_getControlHorizontalScrollNametable(PPU ppu) {
  //assert(ppu != NULL);
  if ( (ppu->controlRegister & MASK_CONTROL_HORIZONTAL_SCROLL_NAME_TABLE_ON) ==
80008dc2:	58 08       	cp.w	r8,0
80008dc4:	fc 08 17 10 	movne	r8,lr
80008dc8:	f6 08 17 00 	moveq	r8,r11
    ppu->controlRegister &= MASK_CONTROL_HORIZONTAL_SCROLL_NAME_TABLE_OFF;
  }
}
static Bool ppu_getControlVerticalScrollNametable(PPU ppu) {
  //assert(ppu != NULL);
  if ( (ppu->controlRegister & MASK_CONTROL_VERTICAL_SCROLL_NAME_TABLE_ON) ==
80008dcc:	58 0a       	cp.w	r10,0
80008dce:	e0 80 00 f5 	breq	80008fb8 <ppu_step+0x32c>
  Word x = ppu_getCurrentX(ppu);
  Word y = ppu_getCurrentY(ppu);
  Word tileNumber = ppu_getBackgroundTileNumber(x, y);
  Address nametableByteAddress = nametableStart + tileNumber;
  //VALIDATE_NAMETABLE_ADDRESS(nametableByteAddress);
  return nes_readPPUMemory(nes,nametableByteAddress);
80008dd2:	f9 3a 00 1b 	ld.ub	r10,r12[27]
80008dd6:	78 58       	ld.w	r8,r12[0x14]
80008dd8:	a3 9a       	lsr	r10,0x3
80008dda:	21 58       	sub	r8,21
80008ddc:	f1 d8 c0 65 	bfextu	r8,r8,0x3,0x5
80008de0:	a5 78       	lsl	r8,0x5
80008de2:	14 08       	add	r8,r10
80008de4:	f0 09 00 09 	add	r9,r8,r9
80008de8:	0c 9c       	mov	r12,r6
80008dea:	f7 d9 c0 0f 	bfextu	r11,r9,0x0,0xf
80008dee:	fe b0 fa a1 	rcall	80008330 <nes_readPPUMemory>
80008df2:	18 98       	mov	r8,r12
  //assert(patternIndex <= 3);
  return patternIndex;
}
static Byte ppu_getPatternColourIndex(NES nes, Address basePatternAddress, Byte patternTileNumber, Byte x, Byte y) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
80008df4:	0c 9c       	mov	r12,r6
80008df6:	50 08       	stdsp	sp[0x0],r8
80008df8:	fe b0 fa 76 	rcall	800082e4 <nes_getPPU>
  //assert(ppu != NULL);
  Word horizontalOffset = patternTileNumber * PPU_PATTERN_BYTES_PER_TILE;
  Word verticalOffset = (y % PPU_VERTICAL_PIXELS_PER_TILE);
  Address pattern1Address = basePatternAddress + horizontalOffset + verticalOffset;
80008dfc:	40 08       	lddsp	r8,sp[0x0]
80008dfe:	a5 68       	lsl	r8,0x4
80008e00:	21 50       	sub	r0,21
  Address pattern2Address = pattern1Address + 8;
  Byte pattern1 = nes_readPPUMemory(nes, pattern1Address);
80008e02:	0c 9c       	mov	r12,r6
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
  //assert(ppu != NULL);
  Word horizontalOffset = patternTileNumber * PPU_PATTERN_BYTES_PER_TILE;
  Word verticalOffset = (y % PPU_VERTICAL_PIXELS_PER_TILE);
  Address pattern1Address = basePatternAddress + horizontalOffset + verticalOffset;
80008e04:	e1 d0 c0 03 	bfextu	r0,r0,0x0,0x3
80008e08:	00 04       	add	r4,r0
80008e0a:	10 04       	add	r4,r8
  Address pattern2Address = pattern1Address + 8;
  Byte pattern1 = nes_readPPUMemory(nes, pattern1Address);
80008e0c:	08 9b       	mov	r11,r4
80008e0e:	5c 7b       	castu.h	r11
80008e10:	fe b0 fa 90 	rcall	80008330 <nes_readPPUMemory>
  Byte pattern2 = nes_readPPUMemory(nes, pattern2Address);
80008e14:	08 9b       	mov	r11,r4
  //assert(ppu != NULL);
  Word horizontalOffset = patternTileNumber * PPU_PATTERN_BYTES_PER_TILE;
  Word verticalOffset = (y % PPU_VERTICAL_PIXELS_PER_TILE);
  Address pattern1Address = basePatternAddress + horizontalOffset + verticalOffset;
  Address pattern2Address = pattern1Address + 8;
  Byte pattern1 = nes_readPPUMemory(nes, pattern1Address);
80008e16:	18 90       	mov	r0,r12
  Byte pattern2 = nes_readPPUMemory(nes, pattern2Address);
80008e18:	2f 8b       	sub	r11,-8
80008e1a:	0c 9c       	mov	r12,r6
80008e1c:	5c 7b       	castu.h	r11
80008e1e:	fe b0 fa 89 	rcall	80008330 <nes_readPPUMemory>
  return nes_readPPUMemory(nes,nametableByteAddress);
}
static Byte ppu_combinePatternBytes(PPU ppu, Byte pattern1, Byte pattern2, Byte x) {
  //assert(ppu != NULL);
  x %= PPU_HORIZONTAL_PIXELS_PER_TILE;
  pattern1 = pattern1 << x;
80008e22:	e7 d3 c0 03 	bfextu	r3,r3,0x0,0x3
  pattern1 = pattern1 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
  pattern2 = pattern2 << x;
80008e26:	f8 03 09 44 	lsl	r4,r12,r3
  return nes_readPPUMemory(nes,nametableByteAddress);
}
static Byte ppu_combinePatternBytes(PPU ppu, Byte pattern1, Byte pattern2, Byte x) {
  //assert(ppu != NULL);
  x %= PPU_HORIZONTAL_PIXELS_PER_TILE;
  pattern1 = pattern1 << x;
80008e2a:	e0 03 09 43 	lsl	r3,r0,r3
  Byte attributeByte = nes_readPPUMemory(nes,attributeByteAddress);
  return attributeByte;
}
static Byte ppu_getBackgroundAttributeColourIndex(NES nes) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
80008e2e:	0c 9c       	mov	r12,r6
  pattern1 = pattern1 << x;
  pattern1 = pattern1 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
  pattern2 = pattern2 << x;
  pattern2 = pattern2 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
  pattern2 = pattern2 << 1;
  Byte patternIndex = pattern1 + pattern2;
80008e30:	e7 d3 c0 e1 	bfextu	r3,r3,0x7,0x1
  Byte attributeByte = nes_readPPUMemory(nes,attributeByteAddress);
  return attributeByte;
}
static Byte ppu_getBackgroundAttributeColourIndex(NES nes) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
80008e34:	fe b0 fa 58 	rcall	800082e4 <nes_getPPU>
  //assert(ppu != NULL);
  x %= PPU_HORIZONTAL_PIXELS_PER_TILE;
  pattern1 = pattern1 << x;
  pattern1 = pattern1 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
  pattern2 = pattern2 << x;
  pattern2 = pattern2 >> (PPU_HORIZONTAL_PIXELS_PER_TILE - 1);
80008e38:	e9 d4 c0 e1 	bfextu	r4,r4,0x7,0x1
  pattern2 = pattern2 << 1;
  Byte patternIndex = pattern1 + pattern2;
80008e3c:	e6 04 00 14 	add	r4,r3,r4<<0x1
  Byte attributeByte = nes_readPPUMemory(nes,attributeByteAddress);
  return attributeByte;
}
static Byte ppu_getBackgroundAttributeColourIndex(NES nes) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
80008e40:	18 93       	mov	r3,r12
  Address patternIndex = ppu_combinePatternBytes(ppu, pattern1, pattern2, x);
  return patternIndex;
}
static Byte ppu_getBackgroundAttributeByte(NES nes) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
80008e42:	0c 9c       	mov	r12,r6
80008e44:	fe b0 fa 50 	rcall	800082e4 <nes_getPPU>
  //assert(ppu != NULL);
  free(ppu);
}
static Bool ppu_getControlHorizontalScrollNametable(PPU ppu) {
  //assert(ppu != NULL);
  if ( (ppu->controlRegister & MASK_CONTROL_HORIZONTAL_SCROLL_NAME_TABLE_ON) ==
80008e48:	e0 6b 2c 00 	mov	r11,11264
80008e4c:	19 88       	ld.ub	r8,r12[0x0]
80008e4e:	e0 69 28 00 	mov	r9,10240
    ppu->controlRegister &= MASK_CONTROL_HORIZONTAL_SCROLL_NAME_TABLE_OFF;
  }
}
static Bool ppu_getControlVerticalScrollNametable(PPU ppu) {
  //assert(ppu != NULL);
  if ( (ppu->controlRegister & MASK_CONTROL_VERTICAL_SCROLL_NAME_TABLE_ON) ==
80008e52:	10 9a       	mov	r10,r8
  //assert(ppu != NULL);
  free(ppu);
}
static Bool ppu_getControlHorizontalScrollNametable(PPU ppu) {
  //assert(ppu != NULL);
  if ( (ppu->controlRegister & MASK_CONTROL_HORIZONTAL_SCROLL_NAME_TABLE_ON) ==
80008e54:	e0 60 24 00 	mov	r0,9216
80008e58:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
    ppu->controlRegister &= MASK_CONTROL_HORIZONTAL_SCROLL_NAME_TABLE_OFF;
  }
}
static Bool ppu_getControlVerticalScrollNametable(PPU ppu) {
  //assert(ppu != NULL);
  if ( (ppu->controlRegister & MASK_CONTROL_VERTICAL_SCROLL_NAME_TABLE_ON) ==
80008e5c:	e2 1a 00 02 	andl	r10,0x2,COH
  //assert(ppu != NULL);
  free(ppu);
}
static Bool ppu_getControlHorizontalScrollNametable(PPU ppu) {
  //assert(ppu != NULL);
  if ( (ppu->controlRegister & MASK_CONTROL_HORIZONTAL_SCROLL_NAME_TABLE_ON) ==
80008e60:	58 08       	cp.w	r8,0
80008e62:	f6 09 17 10 	movne	r9,r11
80008e66:	e0 6b 20 00 	mov	r11,8192
80008e6a:	e0 08 17 10 	movne	r8,r0
80008e6e:	f6 08 17 00 	moveq	r8,r11
    ppu->controlRegister &= MASK_CONTROL_HORIZONTAL_SCROLL_NAME_TABLE_OFF;
  }
}
static Bool ppu_getControlVerticalScrollNametable(PPU ppu) {
  //assert(ppu != NULL);
  if ( (ppu->controlRegister & MASK_CONTROL_VERTICAL_SCROLL_NAME_TABLE_ON) ==
80008e72:	58 0a       	cp.w	r10,0
80008e74:	e0 80 00 9f 	breq	80008fb2 <ppu_step+0x326>
}
static Word ppu_getBackgroundTileNumber(Word x, Word y) {
  Word horizontalOffset = (x / PPU_HORIZONTAL_PIXELS_PER_TILE);
  Word verticalOffset = (y / PPU_VERTICAL_PIXELS_PER_TILE) *
PPU_BACKGROUND_TILES_PER_ROW;
  Word tileNumber = horizontalOffset + verticalOffset;
80008e78:	f9 3a 00 1b 	ld.ub	r10,r12[27]
80008e7c:	a3 9a       	lsr	r10,0x3
80008e7e:	78 58       	ld.w	r8,r12[0x14]
80008e80:	21 58       	sub	r8,21
80008e82:	f1 d8 c0 65 	bfextu	r8,r8,0x3,0x5
80008e86:	a5 78       	lsl	r8,0x5
80008e88:	14 08       	add	r8,r10
  Word verticalOffset = (tileRowNumber / PPU_VERTICAL_TILES_PER_ATTRIBUTE_BYTE) *
PPU_ATTRIBUTE_BYTES_PER_ROW;
  Address attributeByteAddress = attributetableStart + horizontalOffset +
verticalOffset;
  //VALIDATE_NAMETABLE_ADDRESS(attributeByteAddress);
  Byte attributeByte = nes_readPPUMemory(nes,attributeByteAddress);
80008e8a:	f0 0a 16 07 	lsr	r10,r8,0x7
80008e8e:	f1 d8 c0 43 	bfextu	r8,r8,0x2,0x3
80008e92:	a3 7a       	lsl	r10,0x3
80008e94:	f0 c8 fc 40 	sub	r8,r8,-960
80008e98:	14 08       	add	r8,r10
80008e9a:	f0 09 00 09 	add	r9,r8,r9
80008e9e:	0c 9c       	mov	r12,r6
80008ea0:	f7 d9 c0 0f 	bfextu	r11,r9,0x0,0xf
80008ea4:	fe b0 fa 46 	rcall	80008330 <nes_readPPUMemory>
}
static Word ppu_getBackgroundTileNumber(Word x, Word y) {
  Word horizontalOffset = (x / PPU_HORIZONTAL_PIXELS_PER_TILE);
  Word verticalOffset = (y / PPU_VERTICAL_PIXELS_PER_TILE) *
PPU_BACKGROUND_TILES_PER_ROW;
  Word tileNumber = horizontalOffset + verticalOffset;
80008ea8:	e7 39 00 1b 	ld.ub	r9,r3[27]
80008eac:	a3 99       	lsr	r9,0x3
80008eae:	66 58       	ld.w	r8,r3[0x14]
80008eb0:	21 58       	sub	r8,21
80008eb2:	f1 d8 c0 65 	bfextu	r8,r8,0x3,0x5
80008eb6:	a5 78       	lsl	r8,0x5
  Word horizontalOffset = (tileNumber % PPU_HORIZONTAL_TILES_PER_ATTRIBUTE_BYTE);
  Word tileRowNumber = (tileNumber / PPU_BACKGROUND_TILES_PER_ROW);
  Word verticalOffset = (tileRowNumber % PPU_VERTICAL_TILES_PER_ATTRIBUTE_BYTE);
  int attributeTileNumber = attributeTableLookup[verticalOffset][horizontalOffset];
  Byte attributeColourIndex = 0;
  switch(attributeTileNumber) {
80008eb8:	12 08       	add	r8,r9
80008eba:	f3 d8 c0 a2 	bfextu	r9,r8,0x5,0x2
80008ebe:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80008ec2:	f0 09 00 28 	add	r8,r8,r9<<0x2
80008ec6:	4e f9       	lddpc	r9,80009080 <ppu_step+0x3f4>
80008ec8:	f2 08 07 08 	ld.ub	r8,r9[r8]
80008ecc:	58 f8       	cp.w	r8,15
80008ece:	e0 88 00 6f 	brls	80008fac <ppu_step+0x320>
80008ed2:	30 0c       	mov	r12,0
  Byte patternColourIndex = ppu_getPatternColourIndex(nes, basePatternAddress,
patternTileNumber, x, y);
  Byte attributeColourIndex = ppu_getBackgroundAttributeColourIndex(nes);
  Byte backgroundColourIndex = 0;
  // if transparent, use the background colour
  if (patternColourIndex == 0) {
80008ed4:	58 04       	cp.w	r4,0
80008ed6:	c0 40       	breq	80008ede <ppu_step+0x252>
    backgroundColourIndex = 0;
  } else {
    backgroundColourIndex = patternColourIndex + attributeColourIndex ;
80008ed8:	f8 04 00 04 	add	r4,r12,r4
80008edc:	5c 54       	castu.b	r4
    ppu->maskRegister &= MASK_MASK_BACKGROUND_VISIBILITY_OFF;
  }
}
static Bool ppu_getMaskBackgroundVisibility (PPU ppu) {
  //assert(ppu != NULL);
  if ((ppu->maskRegister & MASK_MASK_BACKGROUND_VISIBILITY_ON) ==
80008ede:	0b 98       	ld.ub	r8,r5[0x1]
80008ee0:	e2 18 00 08 	andl	r8,0x8,COH
    }
  }
}
static Byte ppu_getCurrentSpriteColour(NES nes, Byte currentBackgroundColour) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
80008ee4:	0c 9c       	mov	r12,r6
    ppu->maskRegister &= MASK_MASK_BACKGROUND_VISIBILITY_OFF;
  }
}
static Bool ppu_getMaskBackgroundVisibility (PPU ppu) {
  //assert(ppu != NULL);
  if ((ppu->maskRegister & MASK_MASK_BACKGROUND_VISIBILITY_ON) ==
80008ee6:	f0 04 17 00 	moveq	r4,r8
80008eea:	e8 03 17 00 	moveq	r3,r4
80008eee:	e8 03 17 10 	movne	r3,r4
    }
  }
}
static Byte ppu_getCurrentSpriteColour(NES nes, Byte currentBackgroundColour) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
80008ef2:	fe b0 f9 f9 	rcall	800082e4 <nes_getPPU>
  //assert(ppu != NULL);
  Byte screenX = ppu_getCurrentX(ppu);
  Byte systemColourIndex = 0;
  if (ppu->spriteColoursForScanlineSet[screenX] == FALSE) {
80008ef6:	30 09       	mov	r9,0
80008ef8:	f9 38 00 1b 	ld.ub	r8,r12[27]
    }
  }
}
static Byte ppu_getCurrentSpriteColour(NES nes, Byte currentBackgroundColour) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
80008efc:	18 95       	mov	r5,r12
  //assert(ppu != NULL);
  Byte screenX = ppu_getCurrentX(ppu);
  Byte systemColourIndex = 0;
  if (ppu->spriteColoursForScanlineSet[screenX] == FALSE) {
80008efe:	f8 08 00 08 	add	r8,r12,r8
80008f02:	f1 3a 01 20 	ld.ub	r10,r8[288]
80008f06:	f2 0a 18 00 	cp.b	r10,r9
80008f0a:	e0 80 00 ab 	breq	80009060 <ppu_step+0x3d4>
    systemColourIndex = ppu_getSystemIndexFromBackgroundIndex(nes,
currentBackgroundColour);
             //one of the lower two bits set
  } else if ((ppu->spriteColoursForScanlineIsBehindBackground[screenX] == TRUE) &&
80008f0e:	f1 3a 02 20 	ld.ub	r10,r8[544]
80008f12:	30 19       	mov	r9,1
80008f14:	f2 0a 18 00 	cp.b	r10,r9
80008f18:	c0 51       	brne	80008f22 <ppu_step+0x296>
80008f1a:	e7 d3 c0 02 	bfextu	r3,r3,0x0,0x2
80008f1e:	e0 81 00 a7 	brne	8000906c <ppu_step+0x3e0>
  }
}
static void ppu_setStatusSpriteCollisionHit(PPU ppu, Bool state) {
  //assert(ppu != NULL);
  if (state == TRUE) {
    ppu->statusRegister |= MASK_STATUS_SPRITE_COLLISION_HIT_ON;
80008f22:	0b a9       	ld.ub	r9,r5[0x2]
80008f24:	a7 a9       	sbr	r9,0x6
}
static Byte ppu_getSystemIndexFromSpriteIndex(NES nes, Byte spriteColourIndex) {
  //assert(nes != NULL);
  Address address = PPU_SPRITE_PALETTE_FIRST_ADDRESS;
  address += spriteColourIndex;
  Byte systemIndex = nes_readPPUMemory(nes, address);
80008f26:	0c 9c       	mov	r12,r6
  }
}
static void ppu_setStatusSpriteCollisionHit(PPU ppu, Bool state) {
  //assert(ppu != NULL);
  if (state == TRUE) {
    ppu->statusRegister |= MASK_STATUS_SPRITE_COLLISION_HIT_ON;
80008f28:	aa a9       	st.b	r5[0x2],r9
}
static Byte ppu_getSystemIndexFromSpriteIndex(NES nes, Byte spriteColourIndex) {
  //assert(nes != NULL);
  Address address = PPU_SPRITE_PALETTE_FIRST_ADDRESS;
  address += spriteColourIndex;
  Byte systemIndex = nes_readPPUMemory(nes, address);
80008f2a:	f1 3b 00 20 	ld.ub	r11,r8[32]
80008f2e:	f6 cb c0 f0 	sub	r11,r11,-16144
80008f32:	fe b0 f9 ff 	rcall	80008330 <nes_readPPUMemory>
    ppu_calculateSpriteColoursForCurrentScanline(nes);
  }
  Byte currentBackgroundColour = ppu_getCurrentBackgroundColour(nes);
  Byte currentSpriteColour = ppu_getCurrentSpriteColour(nes, currentBackgroundColour);
  Colour colour =
colour_init(systemPalette[currentSpriteColour].red,systemPalette[currentSpriteColour].green,systemPalette[currentSpriteColour].blue);
80008f36:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80008f3a:	4d 38       	lddpc	r8,80009084 <ppu_step+0x3f8>
80008f3c:	18 08       	add	r8,r12
80008f3e:	11 aa       	ld.ub	r10,r8[0x2]
80008f40:	11 9b       	ld.ub	r11,r8[0x1]
80008f42:	11 8c       	ld.ub	r12,r8[0x0]
80008f44:	fe b0 eb 98 	rcall	80006674 <colour_init>
80008f48:	18 95       	mov	r5,r12
gui_drawPixel(gui,ppu_getCurrentX(ppu),ppu_getCurrentY(ppu),colour_getRed(colour),colour_getGreen(colour),colour_getBlue(colour));
80008f4a:	fe b0 eb 8f 	rcall	80006668 <colour_getBlue>
80008f4e:	18 94       	mov	r4,r12
80008f50:	0a 9c       	mov	r12,r5
80008f52:	fe b0 eb 89 	rcall	80006664 <colour_getGreen>
80008f56:	18 93       	mov	r3,r12
80008f58:	0a 9c       	mov	r12,r5
80008f5a:	fe b0 eb 83 	rcall	80006660 <colour_getRed>
80008f5e:	06 98       	mov	r8,r3
80008f60:	18 99       	mov	r9,r12
80008f62:	64 5a       	ld.w	r10,r2[0x14]
80008f64:	02 9c       	mov	r12,r1
80008f66:	1a d4       	st.w	--sp,r4
80008f68:	21 5a       	sub	r10,21
80008f6a:	e5 3b 00 1b 	ld.ub	r11,r2[27]
80008f6e:	5c 5a       	castu.b	r10
80008f70:	fe b0 f7 c2 	rcall	80007ef4 <gui_drawPixel>
  colour_destroy(colour);
80008f74:	0a 9c       	mov	r12,r5
80008f76:	fe b0 eb 7b 	rcall	8000666c <colour_destroy>
  }
}
static void ppu_setStatusVerticalBlank(PPU ppu, Bool state) {
  //assert(ppu != NULL);
  if (state == TRUE) {
    ppu->statusRegister |= MASK_STATUS_VBLANK_ON;
80008f7a:	0f a8       	ld.ub	r8,r7[0x2]
80008f7c:	ea 18 ff ff 	orh	r8,0xffff
80008f80:	e8 18 ff 80 	orl	r8,0xff80
80008f84:	2f fd       	sub	sp,-4
80008f86:	ae a8       	st.b	r7[0x2],r8
80008f88:	6e 48       	ld.w	r8,r7[0x10]
80008f8a:	6e 69       	ld.w	r9,r7[0x18]
80008f8c:	c9 2a       	rjmp	80008cb0 <ppu_step+0x24>
  } else if (state == FALSE) {
    ppu->statusRegister &= MASK_STATUS_VBLANK_OFF;
80008f8e:	0f a8       	ld.ub	r8,r7[0x2]
80008f90:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80008f94:	ae a8       	st.b	r7[0x2],r8
      if (ppu_getControlNMI(ppu) == TRUE) {
        nes_generateNMI(nes);
      }
    }
  }
}
80008f96:	2f fd       	sub	sp,-4
80008f98:	d8 32       	popm	r0-r7,pc
	
	
	if (ppu->currentScanline%20)
	{
		if (ppu_getControlNMI(ppu) == TRUE) {
			nes_generateNMI(nes);
80008f9a:	0c 9c       	mov	r12,r6
80008f9c:	fe b0 f9 e0 	rcall	8000835c <nes_generateNMI>
80008fa0:	6e 58       	ld.w	r8,r7[0x14]
80008fa2:	cb 5a       	rjmp	80008d0c <ppu_step+0x80>
      ppu->currentScanline = 0;
      ppu->currentFrame++;
    //  gui_refresh(gui);
     // printf("Frame: %d\n", ppu->currentFrame);
      if (ppu_getControlNMI(ppu) == TRUE) {
        nes_generateNMI(nes);
80008fa4:	0c 9c       	mov	r12,r6
80008fa6:	fe b0 f9 db 	rcall	8000835c <nes_generateNMI>
80008faa:	cd 4a       	rjmp	80008d52 <ppu_step+0xc6>
  Word horizontalOffset = (tileNumber % PPU_HORIZONTAL_TILES_PER_ATTRIBUTE_BYTE);
  Word tileRowNumber = (tileNumber / PPU_BACKGROUND_TILES_PER_ROW);
  Word verticalOffset = (tileRowNumber % PPU_VERTICAL_TILES_PER_ATTRIBUTE_BYTE);
  int attributeTileNumber = attributeTableLookup[verticalOffset][horizontalOffset];
  Byte attributeColourIndex = 0;
  switch(attributeTileNumber) {
80008fac:	4b 79       	lddpc	r9,80009088 <ppu_step+0x3fc>
80008fae:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
    ppu->controlRegister &= MASK_CONTROL_HORIZONTAL_SCROLL_NAME_TABLE_OFF;
  }
}
static Bool ppu_getControlVerticalScrollNametable(PPU ppu) {
  //assert(ppu != NULL);
  if ( (ppu->controlRegister & MASK_CONTROL_VERTICAL_SCROLL_NAME_TABLE_ON) ==
80008fb2:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80008fb6:	c6 1b       	rjmp	80008e78 <ppu_step+0x1ec>
80008fb8:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80008fbc:	c0 bb       	rjmp	80008dd2 <ppu_step+0x146>
spriteIndex);
  ppu_updateScanlineSpriteColour8(nes, spriteIndex, basePatternAddress, 2);
}
static void ppu_calculateSpriteColoursForCurrentScanline(NES nes) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
80008fbe:	0c 9c       	mov	r12,r6
80008fc0:	fe b0 f9 92 	rcall	800082e4 <nes_getPPU>
};
static void ppu_resetSpriteColoursForScanline(PPU ppu) {
  //assert(ppu != NULL);
 // int i;
  
  memset(ppu->spriteColoursForScanline,0,PPU_SCREEN_WIDTH_IN_PIXELS);
80008fc4:	e0 6a 01 00 	mov	r10,256
spriteIndex);
  ppu_updateScanlineSpriteColour8(nes, spriteIndex, basePatternAddress, 2);
}
static void ppu_calculateSpriteColoursForCurrentScanline(NES nes) {
  //assert(nes != NULL);
  PPU ppu = nes_getPPU(nes);
80008fc8:	18 94       	mov	r4,r12
};
static void ppu_resetSpriteColoursForScanline(PPU ppu) {
  //assert(ppu != NULL);
 // int i;
  
  memset(ppu->spriteColoursForScanline,0,PPU_SCREEN_WIDTH_IN_PIXELS);
80008fca:	0a 9b       	mov	r11,r5
80008fcc:	2e 0c       	sub	r12,-32
80008fce:	e0 a0 3a 5b 	rcall	80010484 <memset>
  memset(ppu->spriteColoursForScanlineSet,FALSE,PPU_SCREEN_WIDTH_IN_PIXELS);
80008fd2:	e0 6a 01 00 	mov	r10,256
80008fd6:	0a 9b       	mov	r11,r5
80008fd8:	e8 cc fe e0 	sub	r12,r4,-288
80008fdc:	e0 a0 3a 54 	rcall	80010484 <memset>
  memset(ppu->spriteColoursForScanlineIsBehindBackground,FALSE,PPU_SCREEN_WIDTH_IN_PIXELS);
80008fe0:	e0 6a 01 00 	mov	r10,256
80008fe4:	0a 9b       	mov	r11,r5
80008fe6:	e8 cc fd e0 	sub	r12,r4,-544
80008fea:	e0 a0 3a 4d 	rcall	80010484 <memset>
    ppu->maskRegister &= MASK_MASK_SPRITE_VISIBILITY_OFF;
  }
}
static Bool ppu_getMaskSpriteVisibility(PPU ppu) {
  //assert(ppu != NULL);
  if ((ppu->maskRegister & MASK_MASK_SPRITE_VISIBILITY_ON) ==
80008fee:	09 98       	ld.ub	r8,r4[0x1]
80008ff0:	ed b8 00 04 	bld	r8,0x4
80008ff4:	fe 91 fe ca 	brne	80008d88 <ppu_step+0xfc>
    ppu->controlRegister &= MASK_CONTROL_SPRITE_TILE_TABLE_OFF;
  }
}
static Bool ppu_getControlSpriteTileTable(PPU ppu) {
  //assert(ppu != NULL);
  if ((ppu->controlRegister & MASK_CONTROL_SPRITE_TILE_TABLE_ON) ==
80008ff8:	e0 63 10 00 	mov	r3,4096
80008ffc:	c1 18       	rjmp	8000901e <ppu_step+0x392>
}
// this is almost a copy paste of ppu_updateScanlineSpriteColour8
// think of a better way
static void ppu_updateScanlineSpriteColour16(NES nes, Byte spriteIndex) {
    //assert(nes != NULL);
  Memory objectAttributeMemory = nes_getObjectAttributeMemory(nes);
80008ffe:	fe b0 f9 69 	rcall	800082d0 <nes_getObjectAttributeMemory>
  //assert(objectAttributeMemory != NULL);
  Address basePatternAddress = objectAttributeMemory_getBankNumber(objectAttributeMemory,
80009002:	0a 9b       	mov	r11,r5
80009004:	fe b0 fa aa 	rcall	80008558 <objectAttributeMemory_getBankNumber>
spriteIndex);
  ppu_updateScanlineSpriteColour8(nes, spriteIndex, basePatternAddress, 2);
80009008:	0a 9b       	mov	r11,r5
8000900a:	18 9a       	mov	r10,r12
8000900c:	30 29       	mov	r9,2
8000900e:	0c 9c       	mov	r12,r6
80009010:	fe b0 fb b0 	rcall	80008770 <ppu_updateScanlineSpriteColour8>
80009014:	2f f5       	sub	r5,-1
  PPU ppu = nes_getPPU(nes);
  //assert(ppu != NULL);
  ppu_resetSpriteColoursForScanline(ppu);
  if ( ppu_getMaskSpriteVisibility(ppu) == TRUE) {
    Byte spriteIndex;
    for (spriteIndex = 0; spriteIndex < OAM_NUMBER_OF_SPRITES; spriteIndex++) {
80009016:	e0 45 00 40 	cp.w	r5,64
8000901a:	fe 90 fe b7 	breq	80008d88 <ppu_step+0xfc>
    ppu->controlRegister &= MASK_CONTROL_SPRITE_TILE_TABLE_OFF;
  }
}
static Bool ppu_getControlSpriteTileTable(PPU ppu) {
  //assert(ppu != NULL);
  if ((ppu->controlRegister & MASK_CONTROL_SPRITE_TILE_TABLE_ON) ==
8000901e:	09 8a       	ld.ub	r10,r4[0x0]
}
// this is almost a copy paste of ppu_updateScanlineSpriteColour8
// think of a better way
static void ppu_updateScanlineSpriteColour16(NES nes, Byte spriteIndex) {
    //assert(nes != NULL);
  Memory objectAttributeMemory = nes_getObjectAttributeMemory(nes);
80009020:	0c 9c       	mov	r12,r6
    ppu->controlRegister &= MASK_CONTROL_SPRITE_SIZE_OFF;
  }
}
static Bool ppu_getControlSpriteSize(PPU ppu) {
  //assert(ppu != NULL);
  if ((ppu->controlRegister & MASK_CONTROL_SPRITE_SIZE_ON) ==
80009022:	14 98       	mov	r8,r10
    ppu->controlRegister &= MASK_CONTROL_SPRITE_TILE_TABLE_OFF;
  }
}
static Bool ppu_getControlSpriteTileTable(PPU ppu) {
  //assert(ppu != NULL);
  if ((ppu->controlRegister & MASK_CONTROL_SPRITE_TILE_TABLE_ON) ==
80009024:	e2 1a 00 08 	andl	r10,0x8,COH
    ppu->controlRegister &= MASK_CONTROL_SPRITE_SIZE_OFF;
  }
}
static Bool ppu_getControlSpriteSize(PPU ppu) {
  //assert(ppu != NULL);
  if ((ppu->controlRegister & MASK_CONTROL_SPRITE_SIZE_ON) ==
80009028:	e2 18 00 20 	andl	r8,0x20,COH
    ppu->controlRegister &= MASK_CONTROL_SPRITE_TILE_TABLE_OFF;
  }
}
static Bool ppu_getControlSpriteTileTable(PPU ppu) {
  //assert(ppu != NULL);
  if ((ppu->controlRegister & MASK_CONTROL_SPRITE_TILE_TABLE_ON) ==
8000902c:	58 0a       	cp.w	r10,0
8000902e:	e6 0a 17 10 	movne	r10,r3
    ppu->controlRegister &= MASK_CONTROL_SPRITE_SIZE_OFF;
  }
}
static Bool ppu_getControlSpriteSize(PPU ppu) {
  //assert(ppu != NULL);
  if ((ppu->controlRegister & MASK_CONTROL_SPRITE_SIZE_ON) ==
80009032:	58 08       	cp.w	r8,0
80009034:	ce 51       	brne	80008ffe <ppu_step+0x372>
        basePatternAddress = PPU_PATTERN_TABLE_1_FIRST_ADDRESS;
      }
      if (ppu_getControlSpriteSize(ppu) == TRUE) {
        ppu_updateScanlineSpriteColour16(nes, spriteIndex);
      } else {
        ppu_updateScanlineSpriteColour8(nes, spriteIndex, basePatternAddress, 1);
80009036:	30 19       	mov	r9,1
80009038:	0a 9b       	mov	r11,r5
8000903a:	0c 9c       	mov	r12,r6
8000903c:	fe b0 fb 9a 	rcall	80008770 <ppu_updateScanlineSpriteColour8>
80009040:	ce ab       	rjmp	80009014 <ppu_step+0x388>
  Word horizontalOffset = (tileNumber % PPU_HORIZONTAL_TILES_PER_ATTRIBUTE_BYTE);
  Word tileRowNumber = (tileNumber / PPU_BACKGROUND_TILES_PER_ROW);
  Word verticalOffset = (tileRowNumber % PPU_VERTICAL_TILES_PER_ATTRIBUTE_BYTE);
  int attributeTileNumber = attributeTableLookup[verticalOffset][horizontalOffset];
  Byte attributeColourIndex = 0;
  switch(attributeTileNumber) {
80009042:	f9 dc c0 82 	bfextu	r12,r12,0x4,0x2
80009046:	a3 6c       	lsl	r12,0x2
80009048:	c4 6b       	rjmp	80008ed4 <ppu_step+0x248>
8000904a:	e2 1c 00 0c 	andl	r12,0xc,COH
8000904e:	c4 3b       	rjmp	80008ed4 <ppu_step+0x248>
80009050:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80009054:	a3 6c       	lsl	r12,0x2
80009056:	c3 fb       	rjmp	80008ed4 <ppu_step+0x248>
80009058:	a5 8c       	lsr	r12,0x4
8000905a:	e2 1c 00 fc 	andl	r12,0xfc,COH
8000905e:	c3 bb       	rjmp	80008ed4 <ppu_step+0x248>
}
static Byte ppu_getSystemIndexFromBackgroundIndex(NES nes, Byte backgroundColourIndex) {
  //assert(nes != NULL);
  Address address = PPU_BACKGROUND_PALETTE_FIRST_ADDRESS;
  address += backgroundColourIndex;
  Byte systemIndex = nes_readPPUMemory(nes, address);
80009060:	e8 cb c1 00 	sub	r11,r4,-16128
80009064:	0c 9c       	mov	r12,r6
80009066:	fe b0 f9 65 	rcall	80008330 <nes_readPPUMemory>
8000906a:	c6 6b       	rjmp	80008f36 <ppu_step+0x2aa>
8000906c:	e8 cb c1 00 	sub	r11,r4,-16128
80009070:	0c 9c       	mov	r12,r6
80009072:	fe b0 f9 5f 	rcall	80008330 <nes_readPPUMemory>
  }
}
static void ppu_setStatusSpriteCollisionHit(PPU ppu, Bool state) {
  //assert(ppu != NULL);
  if (state == TRUE) {
    ppu->statusRegister |= MASK_STATUS_SPRITE_COLLISION_HIT_ON;
80009076:	0b a8       	ld.ub	r8,r5[0x2]
80009078:	a7 a8       	sbr	r8,0x6
8000907a:	aa a8       	st.b	r5[0x2],r8
8000907c:	c5 db       	rjmp	80008f36 <ppu_step+0x2aa>
8000907e:	d7 03       	nop
80009080:	80 01       	ld.sh	r1,r0[0x0]
80009082:	7e 64       	ld.w	r4,pc[0x18]
80009084:	80 01       	ld.sh	r1,r0[0x0]
80009086:	7d a4       	ld.w	r4,lr[0x68]
80009088:	80 01       	ld.sh	r1,r0[0x0]
8000908a:	7d 64       	ld.w	r4,lr[0x58]

8000908c <ppuMemory_init>:
  Byte data = memory_read_callback(nes, ppuMemory, address);
  return data;
}
////////////////////////////////////////////////////////////////////////////////////////
//
Memory ppuMemory_init(void) {
8000908c:	eb cd 40 e0 	pushm	r5-r7,lr
  Memory memory = memory_init(PPU_NUM_REAL_ADDRESSES);
80009090:	e0 6c 40 00 	mov	r12,16384
80009094:	fe b0 f7 b6 	rcall	80008000 <memory_init>
  ////assert(memory != NULL);
  Address address;
  // first setup the name table mirror
 
  for (address = PPU_NAME_TABLE_MIRROR_FIRST_ADDRESS; address <=PPU_NAME_TABLE_MIRROR_FIRST_ADDRESS; address++) {
    memory_setWriteCallback(memory, address, &ppuMemory_nametableMirror_writer);
80009098:	fe ca fe 60 	sub	r10,pc,-416
8000909c:	18 95       	mov	r5,r12
8000909e:	e0 6b 30 00 	mov	r11,12288
800090a2:	fe b0 f7 86 	rcall	80007fae <memory_setWriteCallback>
    memory_setReadCallback(memory, address, &ppuMemory_nametableMirror_reader);
800090a6:	fe ca fe f6 	sub	r10,pc,-266
800090aa:	e0 6b 30 00 	mov	r11,12288
800090ae:	0a 9c       	mov	r12,r5
  }
  // setup the background mirrors for the first byte in each sub palette of the spritepalette
  memory_setWriteCallback(memory, PPU_SPRITE_PALETTE_0_FIRST_ADDRESS,
800090b0:	fe b0 f7 84 	rcall	80007fb8 <memory_setReadCallback>
800090b4:	fe ca fe a0 	sub	r10,pc,-352
800090b8:	e0 6b 3f 10 	mov	r11,16144
&ppuMemory_transparencyMirror_writer);
  memory_setReadCallback(memory, PPU_SPRITE_PALETTE_0_FIRST_ADDRESS,
800090bc:	0a 9c       	mov	r12,r5
800090be:	fe b0 f7 78 	rcall	80007fae <memory_setWriteCallback>
800090c2:	fe ca ff 32 	sub	r10,pc,-206
800090c6:	e0 6b 3f 10 	mov	r11,16144
&ppuMemory_transparencyMirror_reader);
  memory_setWriteCallback(memory, PPU_SPRITE_PALETTE_1_FIRST_ADDRESS,
800090ca:	0a 9c       	mov	r12,r5
800090cc:	fe b0 f7 76 	rcall	80007fb8 <memory_setReadCallback>
800090d0:	fe ca fe bc 	sub	r10,pc,-324
&ppuMemory_transparencyMirror_writer);
  memory_setReadCallback(memory, PPU_SPRITE_PALETTE_1_FIRST_ADDRESS,
800090d4:	e0 6b 3f 14 	mov	r11,16148
800090d8:	0a 9c       	mov	r12,r5
800090da:	fe b0 f7 6a 	rcall	80007fae <memory_setWriteCallback>
800090de:	fe ca ff 4e 	sub	r10,pc,-178
&ppuMemory_transparencyMirror_reader);
  memory_setWriteCallback(memory, PPU_SPRITE_PALETTE_2_FIRST_ADDRESS,
800090e2:	e0 6b 3f 14 	mov	r11,16148
800090e6:	0a 9c       	mov	r12,r5
800090e8:	fe b0 f7 68 	rcall	80007fb8 <memory_setReadCallback>
&ppuMemory_transparencyMirror_writer);
  memory_setReadCallback(memory, PPU_SPRITE_PALETTE_2_FIRST_ADDRESS,
800090ec:	fe ca fe d8 	sub	r10,pc,-296
800090f0:	e0 6b 3f 18 	mov	r11,16152
800090f4:	0a 9c       	mov	r12,r5
800090f6:	fe b0 f7 5c 	rcall	80007fae <memory_setWriteCallback>
&ppuMemory_transparencyMirror_reader);
  memory_setWriteCallback(memory, PPU_SPRITE_PALETTE_3_FIRST_ADDRESS,
800090fa:	fe ca ff 6a 	sub	r10,pc,-150
800090fe:	e0 6b 3f 18 	mov	r11,16152
80009102:	0a 9c       	mov	r12,r5
&ppuMemory_transparencyMirror_writer);
  memory_setReadCallback(memory, PPU_SPRITE_PALETTE_3_FIRST_ADDRESS,
80009104:	fe b0 f7 5a 	rcall	80007fb8 <memory_setReadCallback>
80009108:	fe ca fe f4 	sub	r10,pc,-268
8000910c:	e0 6b 3f 1c 	mov	r11,16156
80009110:	0a 9c       	mov	r12,r5
80009112:	fe b0 f7 4e 	rcall	80007fae <memory_setWriteCallback>
&ppuMemory_transparencyMirror_reader);
  // now setup the mirror proper
  for (address=PPU_PALETTE_MIRROR_FIRST_ADDRESS; address <=
PPU_PALETTE_MIRROR_LAST_ADDRESS; address++) {
    memory_setWriteCallback(memory, address, &ppuMemory_paletteMirror_writer);
80009116:	fe ca ff 86 	sub	r10,pc,-122
8000911a:	e0 6b 3f 1c 	mov	r11,16156
8000911e:	0a 9c       	mov	r12,r5
    memory_setReadCallback(memory, address, &ppuMemory_paletteMirror_reader);
80009120:	fe b0 f7 4c 	rcall	80007fb8 <memory_setReadCallback>
80009124:	30 07       	mov	r7,0
80009126:	ee c6 c0 e0 	sub	r6,r7,-16160
8000912a:	fe ca ff 5a 	sub	r10,pc,-166
  memory_setWriteCallback(memory, PPU_SPRITE_PALETTE_3_FIRST_ADDRESS,
&ppuMemory_transparencyMirror_writer);
  memory_setReadCallback(memory, PPU_SPRITE_PALETTE_3_FIRST_ADDRESS,
&ppuMemory_transparencyMirror_reader);
  // now setup the mirror proper
  for (address=PPU_PALETTE_MIRROR_FIRST_ADDRESS; address <=
8000912e:	0c 9b       	mov	r11,r6
80009130:	0a 9c       	mov	r12,r5
PPU_PALETTE_MIRROR_LAST_ADDRESS; address++) {
    memory_setWriteCallback(memory, address, &ppuMemory_paletteMirror_writer);
    memory_setReadCallback(memory, address, &ppuMemory_paletteMirror_reader);
  }
  return memory;
80009132:	fe b0 f7 3e 	rcall	80007fae <memory_setWriteCallback>
80009136:	0c 9b       	mov	r11,r6
80009138:	2f f7       	sub	r7,-1
8000913a:	fe ca ff ea 	sub	r10,pc,-22
8000913e:	0a 9c       	mov	r12,r5
80009140:	fe b0 f7 3c 	rcall	80007fb8 <memory_setReadCallback>
80009144:	e0 47 00 e0 	cp.w	r7,224
80009148:	ce f1       	brne	80009126 <ppuMemory_init+0x9a>
8000914a:	0a 9c       	mov	r12,r5
8000914c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80009150 <ppuMemory_paletteMirror_reader>:
80009150:	eb cd 40 c0 	pushm	r6-r7,lr
80009154:	16 96       	mov	r6,r11
80009156:	18 97       	mov	r7,r12
80009158:	fe b0 f8 c2 	rcall	800082dc <nes_getPPUMemory>
  return data;
}
////////////////////////////////////////////////////////////////////////////////////////
//
static Address ppuMemory_paletteMirror_getLowestAddress(Address address) {
  while(address > PPU_GENUINE_PALETTE_LAST_ADDRESS) {
8000915c:	e0 68 3f 1f 	mov	r8,16159
  //assert(ppuMemory != NULL);
  address = ppuMemory_paletteMirror_getLowestAddress(address);
  memory_write_callback(nes, ppuMemory, address, data);
}
static Byte ppuMemory_paletteMirror_reader(NES nes, Address address) {
  Memory ppuMemory = nes_getPPUMemory(nes);
80009160:	18 9b       	mov	r11,r12
  return data;
}
////////////////////////////////////////////////////////////////////////////////////////
//
static Address ppuMemory_paletteMirror_getLowestAddress(Address address) {
  while(address > PPU_GENUINE_PALETTE_LAST_ADDRESS) {
80009162:	f0 06 19 00 	cp.h	r6,r8
80009166:	e0 88 00 0d 	brls	80009180 <ppuMemory_paletteMirror_reader+0x30>
  Memory ppuMemory = nes_getPPUMemory(nes);
  //assert(ppuMemory != NULL);
  address = ppuMemory_paletteMirror_getLowestAddress(address);
  memory_write_callback(nes, ppuMemory, address, data);
}
static Byte ppuMemory_paletteMirror_reader(NES nes, Address address) {
8000916a:	ec c8 00 20 	sub	r8,r6,32
8000916e:	ec c6 3f 20 	sub	r6,r6,16160
80009172:	ed d6 c0 ab 	bfextu	r6,r6,0x5,0xb
80009176:	ec 06 10 e0 	mul	r6,r6,-32
8000917a:	f0 06 00 06 	add	r6,r8,r6
8000917e:	5c 86       	casts.h	r6
  Memory ppuMemory = nes_getPPUMemory(nes);
  //assert(ppuMemory != NULL);
  address = ppuMemory_paletteMirror_getLowestAddress(address);
  Byte data = memory_read_callback(nes, ppuMemory, address);
80009180:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80009184:	0e 9c       	mov	r12,r7
80009186:	fe b0 f7 2e 	rcall	80007fe2 <memory_read_callback>
  return data;
}
8000918a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000918e:	d7 03       	nop

80009190 <ppuMemory_transparencyMirror_reader>:
80009190:	eb cd 40 c0 	pushm	r6-r7,lr
80009194:	16 96       	mov	r6,r11
80009196:	18 97       	mov	r7,r12
  //assert(address >= PPU_BACKGROUND_PALETTE_FIRST_ADDRESS);
  //assert(address <= PPU_BACKGROUND_PALETTE_LAST_ADDRESS);
  memory_write_callback(nes, ppuMemory, address, data);
}
static Byte ppuMemory_transparencyMirror_reader(NES nes, Address address) {
  Memory ppuMemory = nes_getPPUMemory(nes);
80009198:	fe b0 f8 a2 	rcall	800082dc <nes_getPPUMemory>
  //assert(ppuMemory != NULL);
  address -= PPU_BACKGROUND_PALETTE_TOTAL_SIZE;
  //assert(address >= PPU_BACKGROUND_PALETTE_FIRST_ADDRESS);
  //assert(address <= PPU_BACKGROUND_PALETTE_LAST_ADDRESS);
  Byte data = memory_read_callback(nes, ppuMemory, address);
8000919c:	ec ca 00 10 	sub	r10,r6,16
800091a0:	18 9b       	mov	r11,r12
800091a2:	5c 7a       	castu.h	r10
800091a4:	0e 9c       	mov	r12,r7
800091a6:	fe b0 f7 1e 	rcall	80007fe2 <memory_read_callback>
  return data;
}
800091aa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800091ae:	d7 03       	nop

800091b0 <ppuMemory_nametableMirror_reader>:
800091b0:	eb cd 40 c0 	pushm	r6-r7,lr
800091b4:	16 96       	mov	r6,r11
800091b6:	18 97       	mov	r7,r12
  //assert(address >= PPU_NAME_TABLE_0_FIRST_ADDRESS);
  //assert(address <= PPU_NAME_TABLE_3_FIRST_ADDRESS);
  memory_write_callback(nes, ppuMemory, address, data);
}
static Byte ppuMemory_nametableMirror_reader(NES nes, Address address) {
  Memory ppuMemory = nes_getPPUMemory(nes);
800091b8:	fe b0 f8 92 	rcall	800082dc <nes_getPPUMemory>
  //assert(ppuMemory != NULL);
  address -= PPU_NAME_TABLE_TOTAL_SIZE;
  //assert(address >= PPU_NAME_TABLE_0_FIRST_ADDRESS);
  //assert(address <= PPU_NAME_TABLE_3_FIRST_ADDRESS);
  Byte data = memory_read_callback(nes, ppuMemory, address);
800091bc:	ec ca 10 00 	sub	r10,r6,4096
800091c0:	18 9b       	mov	r11,r12
800091c2:	5c 7a       	castu.h	r10
800091c4:	0e 9c       	mov	r12,r7
800091c6:	fe b0 f7 0e 	rcall	80007fe2 <memory_read_callback>
  return data;
}
800091ca:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800091ce:	d7 03       	nop

800091d0 <ppuMemory_paletteMirror_writer>:
800091d0:	eb cd 40 e0 	pushm	r5-r7,lr
800091d4:	16 96       	mov	r6,r11
800091d6:	14 95       	mov	r5,r10
  }
  //assert(address <= PPU_GENUINE_PALETTE_LAST_ADDRESS);
  return address;
}
// Both palettes are also mirrored to $3F20-$3FFF.
static void ppuMemory_paletteMirror_writer(NES nes, Address address, Byte data) {
800091d8:	18 97       	mov	r7,r12
  Memory ppuMemory = nes_getPPUMemory(nes);
800091da:	fe b0 f8 81 	rcall	800082dc <nes_getPPUMemory>
  return data;
}
////////////////////////////////////////////////////////////////////////////////////////
//
static Address ppuMemory_paletteMirror_getLowestAddress(Address address) {
  while(address > PPU_GENUINE_PALETTE_LAST_ADDRESS) {
800091de:	e0 68 3f 1f 	mov	r8,16159
  //assert(address <= PPU_GENUINE_PALETTE_LAST_ADDRESS);
  return address;
}
// Both palettes are also mirrored to $3F20-$3FFF.
static void ppuMemory_paletteMirror_writer(NES nes, Address address, Byte data) {
  Memory ppuMemory = nes_getPPUMemory(nes);
800091e2:	18 9b       	mov	r11,r12
  return data;
}
////////////////////////////////////////////////////////////////////////////////////////
//
static Address ppuMemory_paletteMirror_getLowestAddress(Address address) {
  while(address > PPU_GENUINE_PALETTE_LAST_ADDRESS) {
800091e4:	f0 06 19 00 	cp.h	r6,r8
800091e8:	e0 88 00 0d 	brls	80009202 <ppuMemory_paletteMirror_writer+0x32>
  }
  //assert(address <= PPU_GENUINE_PALETTE_LAST_ADDRESS);
  return address;
}
// Both palettes are also mirrored to $3F20-$3FFF.
static void ppuMemory_paletteMirror_writer(NES nes, Address address, Byte data) {
800091ec:	ec c8 00 20 	sub	r8,r6,32
800091f0:	ec c6 3f 20 	sub	r6,r6,16160
800091f4:	ed d6 c0 ab 	bfextu	r6,r6,0x5,0xb
800091f8:	ec 06 10 e0 	mul	r6,r6,-32
800091fc:	f0 06 00 06 	add	r6,r8,r6
80009200:	5c 86       	casts.h	r6
  Memory ppuMemory = nes_getPPUMemory(nes);
  //assert(ppuMemory != NULL);
  address = ppuMemory_paletteMirror_getLowestAddress(address);
  memory_write_callback(nes, ppuMemory, address, data);
80009202:	0a 99       	mov	r9,r5
80009204:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80009208:	0e 9c       	mov	r12,r7
8000920a:	fe b0 f6 dc 	rcall	80007fc2 <memory_write_callback>
}
8000920e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80009212:	d7 03       	nop

80009214 <ppuMemory_transparencyMirror_writer>:
80009214:	eb cd 40 e0 	pushm	r5-r7,lr
80009218:	16 96       	mov	r6,r11
8000921a:	14 95       	mov	r5,r10
#include "ppuMemory.h"
#include "nes.h"
////////////////////////////////////////////////////////////////////////////////////////
//
// Addresses $3F10/$3F14/$3F18/$3F1C are mirrors of $3F00/$3F04/$3F08/$3F0C.
static void ppuMemory_transparencyMirror_writer(NES nes, Address address, Byte data) {
8000921c:	18 97       	mov	r7,r12
  Memory ppuMemory = nes_getPPUMemory(nes);
8000921e:	fe b0 f8 5f 	rcall	800082dc <nes_getPPUMemory>
  //assert(ppuMemory != NULL);
  address -= PPU_BACKGROUND_PALETTE_TOTAL_SIZE;
  //assert(address >= PPU_BACKGROUND_PALETTE_FIRST_ADDRESS);
  //assert(address <= PPU_BACKGROUND_PALETTE_LAST_ADDRESS);
  memory_write_callback(nes, ppuMemory, address, data);
80009222:	ec ca 00 10 	sub	r10,r6,16
80009226:	18 9b       	mov	r11,r12
80009228:	0a 99       	mov	r9,r5
8000922a:	5c 7a       	castu.h	r10
8000922c:	0e 9c       	mov	r12,r7
8000922e:	fe b0 f6 ca 	rcall	80007fc2 <memory_write_callback>
}
80009232:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80009236:	d7 03       	nop

80009238 <ppuMemory_nametableMirror_writer>:
80009238:	eb cd 40 e0 	pushm	r5-r7,lr
8000923c:	16 96       	mov	r6,r11
8000923e:	14 95       	mov	r5,r10
  Byte data = memory_read_callback(nes, ppuMemory, address);
  return data;
}
////////////////////////////////////////////////////////////////////////////////////////
//
static void ppuMemory_nametableMirror_writer(NES nes, Address address, Byte data) {
80009240:	18 97       	mov	r7,r12
  Memory ppuMemory = nes_getPPUMemory(nes);
80009242:	fe b0 f8 4d 	rcall	800082dc <nes_getPPUMemory>
  //assert(ppuMemory != NULL);
  address -= PPU_NAME_TABLE_TOTAL_SIZE;
  //assert(address >= PPU_NAME_TABLE_0_FIRST_ADDRESS);
  //assert(address <= PPU_NAME_TABLE_3_FIRST_ADDRESS);
  memory_write_callback(nes, ppuMemory, address, data);
80009246:	ec ca 10 00 	sub	r10,r6,4096
8000924a:	18 9b       	mov	r11,r12
8000924c:	0a 99       	mov	r9,r5
8000924e:	5c 7a       	castu.h	r10
80009250:	0e 9c       	mov	r12,r7
80009252:	fe b0 f6 b8 	rcall	80007fc2 <memory_write_callback>
}
80009256:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000925a:	d7 03       	nop

8000925c <et024006_Color>:
 *  @param b Blue color value
 */
et024006_color_t et024006_Color( uint8_t r, uint8_t g, uint8_t b )
{
  uint16_t red = r >> 3;
  uint16_t green = g >> 2;
8000925c:	f5 da c0 68 	bfextu	r10,r10,0x3,0x8
 *  @param g Green color value
 *  @param b Blue color value
 */
et024006_color_t et024006_Color( uint8_t r, uint8_t g, uint8_t b )
{
  uint16_t red = r >> 3;
80009260:	f9 dc c0 68 	bfextu	r12,r12,0x3,0x8
  uint16_t green = g >> 2;
80009264:	f7 db c0 48 	bfextu	r11,r11,0x2,0x8
80009268:	f5 eb 10 5b 	or	r11,r10,r11<<0x5
8000926c:	f7 ec 10 bc 	or	r12,r11,r12<<0xb
  green <<= 5;

  et024006_color_t color = red | green | blue;
 // color = (color >> 8) | (color << 8); // Convert endianness.
  return color;
}
80009270:	5c 8c       	casts.h	r12
80009272:	5e fc       	retal	r12

80009274 <et024006_SetLimits>:
/*! \brief Sets the display limits according to the corner coordinates.
 *  Writing to the display will result in writing to the area specified through
 *  this function.
 */
void et024006_SetLimits( uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2 )
{
80009274:	eb cd 40 80 	pushm	r7,lr

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009278:	fc 18 c0 00 	movh	r8,0xc000
8000927c:	30 2e       	mov	lr,2
8000927e:	b0 0e       	st.h	r8[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009280:	ef dc c1 08 	bfextu	r7,r12,0x8,0x8
80009284:	fc 1e c0 20 	movh	lr,0xc020
80009288:	bc 07       	st.h	lr[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000928a:	30 37       	mov	r7,3
8000928c:	b0 07       	st.h	r8[0x0],r7
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000928e:	bc 0c       	st.h	lr[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009290:	30 4c       	mov	r12,4
80009292:	b0 0c       	st.h	r8[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009294:	f9 da c1 08 	bfextu	r12,r10,0x8,0x8
80009298:	bc 0c       	st.h	lr[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000929a:	30 5c       	mov	r12,5
8000929c:	b0 0c       	st.h	r8[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000929e:	bc 0a       	st.h	lr[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800092a0:	30 6a       	mov	r10,6
800092a2:	b0 0a       	st.h	r8[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800092a4:	f5 db c1 08 	bfextu	r10,r11,0x8,0x8
800092a8:	bc 0a       	st.h	lr[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800092aa:	30 7a       	mov	r10,7
800092ac:	b0 0a       	st.h	r8[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800092ae:	bc 0b       	st.h	lr[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800092b0:	30 8a       	mov	r10,8
800092b2:	b0 0a       	st.h	r8[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800092b4:	f5 d9 c1 08 	bfextu	r10,r9,0x8,0x8
800092b8:	bc 0a       	st.h	lr[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800092ba:	30 9a       	mov	r10,9
800092bc:	b0 0a       	st.h	r8[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800092be:	bc 09       	st.h	lr[0x0],r9
  et024006_WriteRegister( HIMAX_COL_ADDR_END1, (x2 & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START2, (y1 >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START1, (y1 & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_END2, (y2 >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_END1, (y2 & 0xff) );
}
800092c0:	e3 cd 80 80 	ldm	sp++,r7,pc

800092c4 <et024006_DrawQuickPixel>:
  et024006_WriteRegister( HIMAX_ROW_ADDR_END1, (y & 0xff) );
}


void et024006_DrawQuickPixel( uint16_t x, uint16_t y, et024006_color_t color )
{
800092c4:	d4 01       	pushm	lr

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800092c6:	fc 18 c0 00 	movh	r8,0xc000
800092ca:	30 29       	mov	r9,2
800092cc:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
800092ce:	fd dc c1 08 	bfextu	lr,r12,0x8,0x8
800092d2:	fc 19 c0 20 	movh	r9,0xc020
800092d6:	b2 0e       	st.h	r9[0x0],lr

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800092d8:	30 3e       	mov	lr,3
800092da:	b0 0e       	st.h	r8[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
800092dc:	b2 0c       	st.h	r9[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800092de:	30 6c       	mov	r12,6
800092e0:	b0 0c       	st.h	r8[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
800092e2:	f9 db c1 08 	bfextu	r12,r11,0x8,0x8
800092e6:	b2 0c       	st.h	r9[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800092e8:	30 7c       	mov	r12,7
800092ea:	b0 0c       	st.h	r8[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
800092ec:	b2 0b       	st.h	r9[0x0],r11
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800092ee:	32 2b       	mov	r11,34
800092f0:	b0 0b       	st.h	r8[0x0],r11
  et024006_SendSPI( color & 0xff );
  et024006_SendSPI( color >> 8 );
  et024006_DeselectSPI();
#endif
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  *ET024006_PARAM_ADDR = color;
800092f2:	b2 0a       	st.h	r9[0x0],r10
#endif

}
800092f4:	d8 02       	popm	pc
800092f6:	d7 03       	nop

800092f8 <et024006_Init>:
 *  @param cpu_hz CPU speed in Hz. This is needed for power up timings.
 *  @param hsb_hz HSB bus speed in Hz. This parameter is needed to set up the SMC.
 *  If SPI mode is used then this parameter is ignored.
 */
void et024006_Init( unsigned long cpu_hz, unsigned long hsb_hz )
{
800092f8:	d4 31       	pushm	r0-r7,lr
  tft_data.cpu_hz = cpu_hz;
800092fa:	e0 67 09 64 	mov	r7,2404
  tft_data.hsb_hz = hsb_hz;
800092fe:	8f 1b       	st.w	r7[0x4],r11
 *  @param hsb_hz HSB bus speed in Hz. This parameter is needed to set up the SMC.
 *  If SPI mode is used then this parameter is ignored.
 */
void et024006_Init( unsigned long cpu_hz, unsigned long hsb_hz )
{
  tft_data.cpu_hz = cpu_hz;
80009300:	8f 0c       	st.w	r7[0x0],r12

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_SPI)
  et024006_InitSPI();
#endif
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  smc_init(tft_data.hsb_hz);
80009302:	16 9c       	mov	r12,r11
80009304:	e0 a0 11 30 	rcall	8000b564 <smc_init>
static void et024006_SetupInterface( void )
{

  // et024006_TE (tearing sync) signal from display is input
  // without any pull resistors
  gpio_enable_gpio_pin(ET024006DHU_TE_PIN);
80009308:	35 5c       	mov	r12,85
8000930a:	e0 a0 11 e8 	rcall	8000b6da <gpio_enable_gpio_pin>

  // Backlight pin (PWM) for display is output
  gpio_enable_module_pin(ET024006DHU_BL_PIN, ET024006DHU_BL_FUNCTION);
8000930e:	30 2b       	mov	r11,2
80009310:	33 2c       	mov	r12,50
80009312:	e0 a0 11 bc 	rcall	8000b68a <gpio_enable_module_pin>
  // Turns backlight ON
  /*TODO Add backlight driver */

  // Reset pin for display is output
  gpio_set_gpio_pin(ET024006DHU_RESET_PIN);
80009316:	35 2c       	mov	r12,82
80009318:	e0 a0 11 f7 	rcall	8000b706 <gpio_set_gpio_pin>
/*! \brief Does a hard reset of the display.
 */
static void et024006_ResetDisplay( void )
{
  // clear reset line
  gpio_clr_gpio_pin(ET024006DHU_RESET_PIN);
8000931c:	35 2c       	mov	r12,82
8000931e:	e0 a0 12 01 	rcall	8000b720 <gpio_clr_gpio_pin>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
80009322:	30 09       	mov	r9,0
80009324:	33 2a       	mov	r10,50
80009326:	ee 78 42 40 	mov	r8,1000000
8000932a:	6e 05       	ld.w	r5,r7[0x0]
8000932c:	30 0b       	mov	r11,0
8000932e:	ea 0a 06 44 	mulu.d	r4,r5,r10
80009332:	ee 7a 42 3f 	mov	r10,999999
80009336:	e8 0a 00 0a 	add	r10,r4,r10
8000933a:	ea 0b 00 4b 	adc	r11,r5,r11
8000933e:	e0 a0 34 7e 	rcall	8000fc3a <__avr32_udiv64>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80009342:	e1 b9 00 42 	mfsr	r9,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80009346:	f2 0a 00 0a 	add	r10,r9,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000934a:	e1 b8 00 42 	mfsr	r8,0x108
8000934e:	14 39       	cp.w	r9,r10
80009350:	e0 8b 01 dc 	brhi	80009708 <et024006_Init+0x410>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80009354:	10 39       	cp.w	r9,r8
80009356:	e0 8b 00 05 	brhi	80009360 <et024006_Init+0x68>
8000935a:	10 3a       	cp.w	r10,r8
8000935c:	e0 82 02 26 	brhs	800097a8 <et024006_Init+0x4b0>
  // 50us delay
  cpu_delay_us( 50, tft_data.cpu_hz );

  gpio_set_gpio_pin(ET024006DHU_RESET_PIN);
80009360:	35 2c       	mov	r12,82
80009362:	e0 a0 11 d2 	rcall	8000b706 <gpio_set_gpio_pin>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80009366:	e0 68 03 e8 	mov	r8,1000
8000936a:	30 5a       	mov	r10,5
8000936c:	30 09       	mov	r9,0
8000936e:	6e 05       	ld.w	r5,r7[0x0]
80009370:	30 0b       	mov	r11,0
80009372:	ea 0a 06 44 	mulu.d	r4,r5,r10
80009376:	e0 6a 03 e7 	mov	r10,999
8000937a:	e8 0a 00 0a 	add	r10,r4,r10
8000937e:	ea 0b 00 4b 	adc	r11,r5,r11
80009382:	e0 a0 34 5c 	rcall	8000fc3a <__avr32_udiv64>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80009386:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000938a:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000938e:	e1 b9 00 42 	mfsr	r9,0x108
80009392:	14 38       	cp.w	r8,r10
80009394:	e0 8b 01 c3 	brhi	8000971a <et024006_Init+0x422>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80009398:	12 38       	cp.w	r8,r9
8000939a:	e0 8b 00 05 	brhi	800093a4 <et024006_Init+0xac>
8000939e:	12 3a       	cp.w	r10,r9
800093a0:	e0 82 02 08 	brhs	800097b0 <et024006_Init+0x4b8>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800093a4:	fc 19 c0 00 	movh	r9,0xc000
800093a8:	34 6a       	mov	r10,70
800093aa:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800093ac:	fc 18 c0 20 	movh	r8,0xc020
800093b0:	e0 6b 00 94 	mov	r11,148
800093b4:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800093b6:	34 7b       	mov	r11,71
800093b8:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800093ba:	34 11       	mov	r1,65
800093bc:	b0 01       	st.h	r8[0x0],r1

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800093be:	34 8b       	mov	r11,72
800093c0:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800093c2:	30 0c       	mov	r12,0
800093c4:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800093c6:	34 92       	mov	r2,73
800093c8:	b2 02       	st.h	r9[0x0],r2
  *ET024006_PARAM_ADDR = (uint16_t) value;
800093ca:	33 3b       	mov	r11,51
800093cc:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800093ce:	34 ab       	mov	r11,74
800093d0:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800093d2:	32 53       	mov	r3,37
800093d4:	b0 03       	st.h	r8[0x0],r3

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800093d6:	34 bb       	mov	r11,75
800093d8:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800093da:	34 5e       	mov	lr,69
800093dc:	b0 0e       	st.h	r8[0x0],lr

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800093de:	34 cb       	mov	r11,76
800093e0:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800093e2:	34 46       	mov	r6,68
800093e4:	b0 06       	st.h	r8[0x0],r6

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800093e6:	34 db       	mov	r11,77
800093e8:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800093ea:	37 7b       	mov	r11,119
800093ec:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800093ee:	34 eb       	mov	r11,78
800093f0:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800093f2:	31 25       	mov	r5,18
800093f4:	b0 05       	st.h	r8[0x0],r5

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800093f6:	34 fb       	mov	r11,79
800093f8:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800093fa:	e0 6b 00 cc 	mov	r11,204
800093fe:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009400:	35 0b       	mov	r11,80
80009402:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009404:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009406:	35 1a       	mov	r10,81
80009408:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000940a:	e0 6a 00 82 	mov	r10,130
8000940e:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009410:	30 1a       	mov	r10,1
80009412:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009414:	30 6b       	mov	r11,6
80009416:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009418:	33 ab       	mov	r11,58
8000941a:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000941c:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000941e:	33 bb       	mov	r11,59
80009420:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009422:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009424:	33 ca       	mov	r10,60
80009426:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009428:	e0 6a 00 f0 	mov	r10,240
8000942c:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000942e:	33 db       	mov	r11,61
80009430:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009432:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009434:	33 eb       	mov	r11,62
80009436:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009438:	33 8b       	mov	r11,56
8000943a:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000943c:	34 04       	mov	r4,64
8000943e:	b2 04       	st.h	r9[0x0],r4
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009440:	30 f0       	mov	r0,15
80009442:	b0 00       	st.h	r8[0x0],r0

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009444:	b2 01       	st.h	r9[0x0],r1
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009446:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009448:	32 7a       	mov	r10,39
8000944a:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000944c:	30 2a       	mov	r10,2
8000944e:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009450:	32 81       	mov	r1,40
80009452:	b2 01       	st.h	r9[0x0],r1
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009454:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009456:	32 91       	mov	r1,41
80009458:	b2 01       	st.h	r9[0x0],r1
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000945a:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000945c:	32 a1       	mov	r1,42
8000945e:	b2 01       	st.h	r9[0x0],r1
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009460:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009462:	32 c1       	mov	r1,44
80009464:	b2 01       	st.h	r9[0x0],r1
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009466:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009468:	32 d1       	mov	r1,45
8000946a:	b2 01       	st.h	r9[0x0],r1
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000946c:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000946e:	31 9a       	mov	r10,25
80009470:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009472:	b0 02       	st.h	r8[0x0],r2

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009474:	e0 6a 00 93 	mov	r10,147
80009478:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000947a:	30 8a       	mov	r10,8
8000947c:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000947e:	31 6a       	mov	r10,22
80009480:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009482:	36 8a       	mov	r10,104
80009484:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009486:	32 3a       	mov	r10,35
80009488:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000948a:	e0 6a 00 95 	mov	r10,149
8000948e:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009490:	32 42       	mov	r2,36
80009492:	b2 02       	st.h	r9[0x0],r2
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009494:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009496:	b2 03       	st.h	r9[0x0],r3
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009498:	e0 6a 00 ff 	mov	r10,255
8000949c:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000949e:	e0 6a 00 90 	mov	r10,144
800094a2:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800094a4:	37 fa       	mov	r10,127
800094a6:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800094a8:	33 5a       	mov	r10,53
800094aa:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800094ac:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800094ae:	33 6a       	mov	r10,54
800094b0:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800094b2:	37 8a       	mov	r10,120
800094b4:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800094b6:	31 da       	mov	r10,29
800094b8:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800094ba:	30 7a       	mov	r10,7
800094bc:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800094be:	31 ea       	mov	r10,30
800094c0:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800094c2:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800094c4:	31 fa       	mov	r10,31
800094c6:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800094c8:	30 4a       	mov	r10,4
800094ca:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800094cc:	32 0a       	mov	r10,32
800094ce:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800094d0:	b0 04       	st.h	r8[0x0],r4

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800094d2:	b2 06       	st.h	r9[0x0],r6
  *ET024006_PARAM_ADDR = (uint16_t) value;
800094d4:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800094d6:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
800094d8:	b0 05       	st.h	r8[0x0],r5
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800094da:	30 a8       	mov	r8,10
800094dc:	6e 0b       	ld.w	r11,r7[0x0]
800094de:	f6 08 06 4a 	mulu.d	r10,r11,r8
800094e2:	e0 68 03 e7 	mov	r8,999
800094e6:	30 09       	mov	r9,0
800094e8:	10 0a       	add	r10,r8
800094ea:	f6 09 00 4b 	adc	r11,r11,r9
800094ee:	e0 68 03 e8 	mov	r8,1000
800094f2:	30 09       	mov	r9,0
800094f4:	e0 a0 33 a3 	rcall	8000fc3a <__avr32_udiv64>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800094f8:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800094fc:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80009500:	e1 b9 00 42 	mfsr	r9,0x108
80009504:	14 38       	cp.w	r8,r10
80009506:	e0 8b 01 13 	brhi	8000972c <et024006_Init+0x434>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000950a:	12 38       	cp.w	r8,r9
8000950c:	e0 8b 00 05 	brhi	80009516 <et024006_Init+0x21e>
80009510:	12 3a       	cp.w	r10,r9
80009512:	e0 82 01 53 	brhs	800097b8 <et024006_Init+0x4c0>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009516:	fc 18 c0 00 	movh	r8,0xc000
8000951a:	31 c9       	mov	r9,28
8000951c:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000951e:	fc 18 c0 20 	movh	r8,0xc020
80009522:	30 49       	mov	r9,4
80009524:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80009526:	31 48       	mov	r8,20
80009528:	6e 0b       	ld.w	r11,r7[0x0]
8000952a:	f6 08 06 4a 	mulu.d	r10,r11,r8
8000952e:	e0 68 03 e7 	mov	r8,999
80009532:	30 09       	mov	r9,0
80009534:	10 0a       	add	r10,r8
80009536:	f6 09 00 4b 	adc	r11,r11,r9
8000953a:	e0 68 03 e8 	mov	r8,1000
8000953e:	30 09       	mov	r9,0
80009540:	e0 a0 33 7d 	rcall	8000fc3a <__avr32_udiv64>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80009544:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80009548:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000954c:	e1 b9 00 42 	mfsr	r9,0x108
80009550:	14 38       	cp.w	r8,r10
80009552:	e0 8b 00 f6 	brhi	8000973e <et024006_Init+0x446>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80009556:	12 38       	cp.w	r8,r9
80009558:	e0 8b 00 05 	brhi	80009562 <et024006_Init+0x26a>
8000955c:	12 3a       	cp.w	r10,r9
8000955e:	e0 82 01 30 	brhs	800097be <et024006_Init+0x4c6>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009562:	fc 18 c0 00 	movh	r8,0xc000
80009566:	34 39       	mov	r9,67
80009568:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000956a:	fc 18 c0 20 	movh	r8,0xc020
8000956e:	e0 69 00 80 	mov	r9,128
80009572:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80009574:	30 58       	mov	r8,5
80009576:	6e 0b       	ld.w	r11,r7[0x0]
80009578:	f6 08 06 4a 	mulu.d	r10,r11,r8
8000957c:	e0 68 03 e7 	mov	r8,999
80009580:	30 09       	mov	r9,0
80009582:	10 0a       	add	r10,r8
80009584:	f6 09 00 4b 	adc	r11,r11,r9
80009588:	e0 68 03 e8 	mov	r8,1000
8000958c:	30 09       	mov	r9,0
8000958e:	e0 a0 33 56 	rcall	8000fc3a <__avr32_udiv64>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80009592:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80009596:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000959a:	e1 b9 00 42 	mfsr	r9,0x108
8000959e:	14 38       	cp.w	r8,r10
800095a0:	e0 8b 00 d8 	brhi	80009750 <et024006_Init+0x458>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800095a4:	12 38       	cp.w	r8,r9
800095a6:	e0 8b 00 05 	brhi	800095b0 <et024006_Init+0x2b8>
800095aa:	12 3a       	cp.w	r10,r9
800095ac:	e0 82 01 0c 	brhs	800097c4 <et024006_Init+0x4cc>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800095b0:	fc 18 c0 00 	movh	r8,0xc000
800095b4:	31 b9       	mov	r9,27
800095b6:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
800095b8:	fc 18 c0 20 	movh	r8,0xc020
800095bc:	30 89       	mov	r9,8
800095be:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800095c0:	32 88       	mov	r8,40
800095c2:	6e 0b       	ld.w	r11,r7[0x0]
800095c4:	f6 08 06 4a 	mulu.d	r10,r11,r8
800095c8:	e0 68 03 e7 	mov	r8,999
800095cc:	30 09       	mov	r9,0
800095ce:	10 0a       	add	r10,r8
800095d0:	f6 09 00 4b 	adc	r11,r11,r9
800095d4:	e0 68 03 e8 	mov	r8,1000
800095d8:	30 09       	mov	r9,0
800095da:	e0 a0 33 30 	rcall	8000fc3a <__avr32_udiv64>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800095de:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800095e2:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800095e6:	e1 b9 00 42 	mfsr	r9,0x108
800095ea:	14 38       	cp.w	r8,r10
800095ec:	e0 8b 00 bb 	brhi	80009762 <et024006_Init+0x46a>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800095f0:	12 38       	cp.w	r8,r9
800095f2:	e0 8b 00 05 	brhi	800095fc <et024006_Init+0x304>
800095f6:	12 3a       	cp.w	r10,r9
800095f8:	e0 82 00 e9 	brhs	800097ca <et024006_Init+0x4d2>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800095fc:	fc 18 c0 00 	movh	r8,0xc000
80009600:	31 b9       	mov	r9,27
80009602:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009604:	fc 18 c0 20 	movh	r8,0xc020
80009608:	31 09       	mov	r9,16
8000960a:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000960c:	32 88       	mov	r8,40
8000960e:	6e 0b       	ld.w	r11,r7[0x0]
80009610:	f6 08 06 4a 	mulu.d	r10,r11,r8
80009614:	e0 68 03 e7 	mov	r8,999
80009618:	30 09       	mov	r9,0
8000961a:	10 0a       	add	r10,r8
8000961c:	f6 09 00 4b 	adc	r11,r11,r9
80009620:	e0 68 03 e8 	mov	r8,1000
80009624:	30 09       	mov	r9,0
80009626:	e0 a0 33 0a 	rcall	8000fc3a <__avr32_udiv64>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000962a:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000962e:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80009632:	e1 b9 00 42 	mfsr	r9,0x108
80009636:	14 38       	cp.w	r8,r10
80009638:	e0 8b 00 9e 	brhi	80009774 <et024006_Init+0x47c>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000963c:	12 38       	cp.w	r8,r9
8000963e:	e0 8b 00 05 	brhi	80009648 <et024006_Init+0x350>
80009642:	12 3a       	cp.w	r10,r9
80009644:	e0 82 00 c6 	brhs	800097d0 <et024006_Init+0x4d8>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009648:	fc 18 c0 00 	movh	r8,0xc000
8000964c:	32 69       	mov	r9,38
8000964e:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009650:	fc 18 c0 20 	movh	r8,0xc020
80009654:	30 49       	mov	r9,4
80009656:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80009658:	32 88       	mov	r8,40
8000965a:	6e 0b       	ld.w	r11,r7[0x0]
8000965c:	f6 08 06 4a 	mulu.d	r10,r11,r8
80009660:	e0 68 03 e7 	mov	r8,999
80009664:	30 09       	mov	r9,0
80009666:	10 0a       	add	r10,r8
80009668:	f6 09 00 4b 	adc	r11,r11,r9
8000966c:	e0 68 03 e8 	mov	r8,1000
80009670:	30 09       	mov	r9,0
80009672:	e0 a0 32 e4 	rcall	8000fc3a <__avr32_udiv64>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80009676:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000967a:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000967e:	e1 b9 00 42 	mfsr	r9,0x108
80009682:	14 38       	cp.w	r8,r10
80009684:	e0 8b 00 81 	brhi	80009786 <et024006_Init+0x48e>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80009688:	12 38       	cp.w	r8,r9
8000968a:	e0 8b 00 05 	brhi	80009694 <et024006_Init+0x39c>
8000968e:	12 3a       	cp.w	r10,r9
80009690:	e0 82 00 a3 	brhs	800097d6 <et024006_Init+0x4de>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009694:	fc 19 c0 00 	movh	r9,0xc000
80009698:	32 6a       	mov	r10,38
8000969a:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000969c:	fc 18 c0 20 	movh	r8,0xc020
800096a0:	32 4b       	mov	r11,36
800096a2:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800096a4:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800096a6:	32 c9       	mov	r9,44
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800096a8:	6e 0b       	ld.w	r11,r7[0x0]
800096aa:	b0 09       	st.h	r8[0x0],r9
800096ac:	32 88       	mov	r8,40
800096ae:	f6 08 06 4a 	mulu.d	r10,r11,r8
800096b2:	e0 68 03 e7 	mov	r8,999
800096b6:	30 09       	mov	r9,0
800096b8:	10 0a       	add	r10,r8
800096ba:	f6 09 00 4b 	adc	r11,r11,r9
800096be:	e0 68 03 e8 	mov	r8,1000
800096c2:	30 09       	mov	r9,0
800096c4:	e0 a0 32 bb 	rcall	8000fc3a <__avr32_udiv64>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800096c8:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800096cc:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800096d0:	e1 b9 00 42 	mfsr	r9,0x108
800096d4:	14 38       	cp.w	r8,r10
800096d6:	e0 8b 00 60 	brhi	80009796 <et024006_Init+0x49e>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800096da:	12 38       	cp.w	r8,r9
800096dc:	e0 8b 00 04 	brhi	800096e4 <et024006_Init+0x3ec>
800096e0:	12 3a       	cp.w	r10,r9
800096e2:	c6 02       	brcc	800097a2 <et024006_Init+0x4aa>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800096e4:	fc 1a c0 00 	movh	r10,0xc000
800096e8:	32 68       	mov	r8,38
800096ea:	b4 08       	st.h	r10[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
800096ec:	33 c9       	mov	r9,60
800096ee:	fc 18 c0 20 	movh	r8,0xc020
800096f2:	b0 09       	st.h	r8[0x0],r9
}

__always_inline static uint8_t et024006_ReadRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800096f4:	37 0b       	mov	r11,112
800096f6:	b4 0b       	st.h	r10[0x0],r11
  return *ET024006_PARAM_ADDR;
800096f8:	90 09       	ld.sh	r9,r8[0x0]

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800096fa:	b4 0b       	st.h	r10[0x0],r11
}

__always_inline static uint8_t et024006_ReadRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
  return *ET024006_PARAM_ADDR;
800096fc:	5c 59       	castu.b	r9
/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
  *ET024006_PARAM_ADDR = (uint16_t) value;
800096fe:	a3 b9       	sbr	r9,0x3
80009700:	b0 09       	st.h	r8[0x0],r9
  et024006_GeneralSettings();
  et024006_InterfaceSettings();
  et024006_PowerSettings();
  et024006_PowerUp();
  et024006_PowerOn();
}
80009702:	d8 32       	popm	r0-r7,pc
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80009704:	e1 b8 00 42 	mfsr	r8,0x108
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80009708:	10 39       	cp.w	r9,r8
8000970a:	fe 98 ff fd 	brls	80009704 <et024006_Init+0x40c>
8000970e:	10 3a       	cp.w	r10,r8
80009710:	fe 93 fe 28 	brlo	80009360 <et024006_Init+0x68>
80009714:	cf 8b       	rjmp	80009704 <et024006_Init+0x40c>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80009716:	e1 b9 00 42 	mfsr	r9,0x108
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000971a:	12 38       	cp.w	r8,r9
8000971c:	fe 98 ff fd 	brls	80009716 <et024006_Init+0x41e>
80009720:	12 3a       	cp.w	r10,r9
80009722:	fe 93 fe 41 	brlo	800093a4 <et024006_Init+0xac>
80009726:	cf 8b       	rjmp	80009716 <et024006_Init+0x41e>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80009728:	e1 b9 00 42 	mfsr	r9,0x108
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000972c:	12 38       	cp.w	r8,r9
8000972e:	fe 98 ff fd 	brls	80009728 <et024006_Init+0x430>
80009732:	12 3a       	cp.w	r10,r9
80009734:	fe 93 fe f1 	brlo	80009516 <et024006_Init+0x21e>
80009738:	cf 8b       	rjmp	80009728 <et024006_Init+0x430>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000973a:	e1 b9 00 42 	mfsr	r9,0x108
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000973e:	12 38       	cp.w	r8,r9
80009740:	fe 98 ff fd 	brls	8000973a <et024006_Init+0x442>
80009744:	12 3a       	cp.w	r10,r9
80009746:	fe 93 ff 0e 	brlo	80009562 <et024006_Init+0x26a>
8000974a:	cf 8b       	rjmp	8000973a <et024006_Init+0x442>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000974c:	e1 b9 00 42 	mfsr	r9,0x108
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80009750:	12 38       	cp.w	r8,r9
80009752:	fe 98 ff fd 	brls	8000974c <et024006_Init+0x454>
80009756:	12 3a       	cp.w	r10,r9
80009758:	fe 93 ff 2c 	brlo	800095b0 <et024006_Init+0x2b8>
8000975c:	cf 8b       	rjmp	8000974c <et024006_Init+0x454>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000975e:	e1 b9 00 42 	mfsr	r9,0x108
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80009762:	12 38       	cp.w	r8,r9
80009764:	fe 98 ff fd 	brls	8000975e <et024006_Init+0x466>
80009768:	12 3a       	cp.w	r10,r9
8000976a:	fe 93 ff 49 	brlo	800095fc <et024006_Init+0x304>
8000976e:	cf 8b       	rjmp	8000975e <et024006_Init+0x466>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80009770:	e1 b9 00 42 	mfsr	r9,0x108
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80009774:	12 38       	cp.w	r8,r9
80009776:	fe 98 ff fd 	brls	80009770 <et024006_Init+0x478>
8000977a:	12 3a       	cp.w	r10,r9
8000977c:	fe 93 ff 66 	brlo	80009648 <et024006_Init+0x350>
80009780:	cf 8b       	rjmp	80009770 <et024006_Init+0x478>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80009782:	e1 b9 00 42 	mfsr	r9,0x108
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80009786:	12 38       	cp.w	r8,r9
80009788:	fe 98 ff fd 	brls	80009782 <et024006_Init+0x48a>
8000978c:	12 3a       	cp.w	r10,r9
8000978e:	c8 33       	brcs	80009694 <et024006_Init+0x39c>
80009790:	cf 9b       	rjmp	80009782 <et024006_Init+0x48a>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80009792:	e1 b9 00 42 	mfsr	r9,0x108
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80009796:	12 38       	cp.w	r8,r9
80009798:	fe 98 ff fd 	brls	80009792 <et024006_Init+0x49a>
8000979c:	12 3a       	cp.w	r10,r9
8000979e:	ca 33       	brcs	800096e4 <et024006_Init+0x3ec>
800097a0:	cf 9b       	rjmp	80009792 <et024006_Init+0x49a>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800097a2:	e1 b9 00 42 	mfsr	r9,0x108
800097a6:	c9 ab       	rjmp	800096da <et024006_Init+0x3e2>
800097a8:	e1 b8 00 42 	mfsr	r8,0x108
800097ac:	fe 9f fd d4 	bral	80009354 <et024006_Init+0x5c>
800097b0:	e1 b9 00 42 	mfsr	r9,0x108
800097b4:	fe 9f fd f2 	bral	80009398 <et024006_Init+0xa0>
800097b8:	e1 b9 00 42 	mfsr	r9,0x108
800097bc:	ca 7a       	rjmp	8000950a <et024006_Init+0x212>
800097be:	e1 b9 00 42 	mfsr	r9,0x108
800097c2:	cc aa       	rjmp	80009556 <et024006_Init+0x25e>
800097c4:	e1 b9 00 42 	mfsr	r9,0x108
800097c8:	ce ea       	rjmp	800095a4 <et024006_Init+0x2ac>
800097ca:	e1 b9 00 42 	mfsr	r9,0x108
800097ce:	c1 1b       	rjmp	800095f0 <et024006_Init+0x2f8>
800097d0:	e1 b9 00 42 	mfsr	r9,0x108
800097d4:	c3 4b       	rjmp	8000963c <et024006_Init+0x344>
800097d6:	e1 b9 00 42 	mfsr	r9,0x108
800097da:	c5 7b       	rjmp	80009688 <et024006_Init+0x390>

800097dc <et024006_PrintString>:
800097dc:	d4 31       	pushm	r0-r7,lr
800097de:	21 1d       	sub	sp,68
800097e0:	50 9b       	stdsp	sp[0x24],r11
800097e2:	50 59       	stdsp	sp[0x14],r9
800097e4:	18 96       	mov	r6,r12
800097e6:	14 95       	mov	r5,r10
800097e8:	41 a4       	lddsp	r4,sp[0x68]
800097ea:	19 89       	ld.ub	r9,r12[0x0]
800097ec:	58 09       	cp.w	r9,0
800097ee:	e0 80 00 86 	breq	800098fa <et024006_PrintString+0x11e>
800097f2:	16 9a       	mov	r10,r11
800097f4:	15 37       	ld.ub	r7,r10++
800097f6:	15 9c       	ld.ub	r12,r10[0x1]
  data = font_style;  // point to the start of the font table
  xfont = *data;  // get font x width
  data++;
  yfont = *data;  // get font y length
  data++;
  font_size = *data;  // get data bytes per font
800097f8:	50 7c       	stdsp	sp[0x1c],r12
    return;

  data = font_style;  // point to the start of the font table
  xfont = *data;  // get font x width
  data++;
  yfont = *data;  // get font y length
800097fa:	15 8a       	ld.ub	r10,r10[0x0]
800097fc:	50 ea       	stdsp	sp[0x38],r10
  data++;
  font_size = *data;  // get data bytes per font

  // If transparent mode
  if(bcolor == -1)
800097fe:	5b f4       	cp.w	r4,-1
80009800:	c7 f0       	breq	800098fe <et024006_PrintString+0x122>
      // point to character data in font table
      data =  (font_style + font_size) +  // header offset
        (font_size * (int)(*lcd_string - 32)); // character select

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
80009802:	5c 85       	casts.h	r5
80009804:	14 90       	mov	r0,r10
80009806:	50 b5       	stdsp	sp[0x2c],r5
80009808:	0a 91       	mov	r1,r5
8000980a:	2f f6       	sub	r6,-1
          {
            *ET024006_PARAM_ADDR = fcolor;
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
8000980c:	5c 84       	casts.h	r4
/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000980e:	fc 1e c0 20 	movh	lr,0xc020
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
80009812:	30 05       	mov	r5,0
80009814:	c0 78       	rjmp	80009822 <et024006_PrintString+0x46>
        x = saved_x;
        y += yfont;
        lcd_string++;  // next character in string
        continue;
      } else if(*lcd_string =='\t') {
        x += xfont;
80009816:	0e 01       	add	r1,r7
80009818:	5c 81       	casts.h	r1
      }
      // move to next character start pixel
      x += xfont;
      lcd_string++;  // next character in string

    }while(*lcd_string !='\0');  // keep spitting chars out until end of string
8000981a:	0d 39       	ld.ub	r9,r6++
8000981c:	58 09       	cp.w	r9,0
8000981e:	c6 e0       	breq	800098fa <et024006_PrintString+0x11e>
80009820:	5c 81       	casts.h	r1
  }
  else
  {
    do
    {
      if(*lcd_string =='\n') {
80009822:	30 aa       	mov	r10,10
80009824:	f4 09 18 00 	cp.b	r9,r10
80009828:	c6 10       	breq	800098ea <et024006_PrintString+0x10e>
        x = saved_x;
        y += yfont;
        lcd_string++;  // next character in string
        continue;
      } else if(*lcd_string =='\t') {
8000982a:	30 9a       	mov	r10,9
8000982c:	f4 09 18 00 	cp.b	r9,r10
80009830:	cf 30       	breq	80009816 <et024006_PrintString+0x3a>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009832:	fc 1a c0 00 	movh	r10,0xc000
80009836:	30 2b       	mov	r11,2
80009838:	b4 0b       	st.h	r10[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000983a:	f7 d1 c1 08 	bfextu	r11,r1,0x8,0x8
8000983e:	bc 0b       	st.h	lr[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009840:	30 3b       	mov	r11,3
80009842:	b4 0b       	st.h	r10[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009844:	f7 d1 c0 08 	bfextu	r11,r1,0x0,0x8
80009848:	bc 0b       	st.h	lr[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000984a:	30 4b       	mov	r11,4
8000984c:	b4 0b       	st.h	r10[0x0],r11
      // point to character data in font table
      data =  (font_style + font_size) +  // header offset
        (font_size * (int)(*lcd_string - 32)); // character select

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
8000984e:	0e 01       	add	r1,r7
80009850:	5c 81       	casts.h	r1
80009852:	e2 cb 00 01 	sub	r11,r1,1
80009856:	5c 8b       	casts.h	r11
/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009858:	f9 db c1 08 	bfextu	r12,r11,0x8,0x8
8000985c:	bc 0c       	st.h	lr[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000985e:	30 5c       	mov	r12,5
80009860:	b4 0c       	st.h	r10[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009862:	bc 0b       	st.h	lr[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009864:	30 6b       	mov	r11,6
80009866:	b4 0b       	st.h	r10[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009868:	40 5c       	lddsp	r12,sp[0x14]
8000986a:	f7 dc c1 08 	bfextu	r11,r12,0x8,0x8
8000986e:	bc 0b       	st.h	lr[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009870:	30 7b       	mov	r11,7
80009872:	b4 0b       	st.h	r10[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009874:	18 9b       	mov	r11,r12
80009876:	bc 0b       	st.h	lr[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009878:	30 8b       	mov	r11,8
8000987a:	b4 0b       	st.h	r10[0x0],r11
      // point to character data in font table
      data =  (font_style + font_size) +  // header offset
        (font_size * (int)(*lcd_string - 32)); // character select

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
8000987c:	e0 cb 00 01 	sub	r11,r0,1
80009880:	18 0b       	add	r11,r12
80009882:	5c 8b       	casts.h	r11
/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009884:	f9 db c1 08 	bfextu	r12,r11,0x8,0x8
80009888:	bc 0c       	st.h	lr[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000988a:	30 9c       	mov	r12,9
8000988c:	b4 0c       	st.h	r10[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000988e:	bc 0b       	st.h	lr[0x0],r11
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009890:	32 2b       	mov	r11,34
80009892:	b4 0b       	st.h	r10[0x0],r11

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
80009894:	58 00       	cp.w	r0,0
80009896:	cc 20       	breq	8000981a <et024006_PrintString+0x3e>
        x += xfont;
        lcd_string++;  // next character in string
        continue;
      }
      // point to character data in font table
      data =  (font_style + font_size) +  // header offset
80009898:	40 7b       	lddsp	r11,sp[0x1c]
8000989a:	22 09       	sub	r9,32
8000989c:	40 9a       	lddsp	r10,sp[0x24]
8000989e:	f2 0b 02 42 	mul	r2,r9,r11
800098a2:	30 03       	mov	r3,0
800098a4:	16 02       	add	r2,r11
800098a6:	f4 02 00 02 	add	r2,r10,r2
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
800098aa:	58 07       	cp.w	r7,0
800098ac:	c1 70       	breq	800098da <et024006_PrintString+0xfe>
800098ae:	05 8c       	ld.ub	r12,r2[0x0]
800098b0:	e0 6a 00 80 	mov	r10,128
800098b4:	30 09       	mov	r9,0
800098b6:	c0 28       	rjmp	800098ba <et024006_PrintString+0xde>
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
          }
          mask >>= 1;
800098b8:	a1 9a       	lsr	r10,0x1
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
800098ba:	f5 ec 00 0b 	and	r11,r10,r12
          {
            *ET024006_PARAM_ADDR = fcolor;
800098be:	ea 0b 18 00 	cp.b	r11,r5
800098c2:	fd f8 1c 00 	st.hne	lr[0x0],r8
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
800098c6:	e8 0b 17 00 	moveq	r11,r4
800098ca:	fd fb 0c 00 	st.heq	lr[0x0],r11
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
800098ce:	2f f9       	sub	r9,-1
800098d0:	5c 89       	casts.h	r9
800098d2:	f2 07 19 00 	cp.h	r7,r9
800098d6:	fe 9b ff f1 	brhi	800098b8 <et024006_PrintString+0xdc>

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
800098da:	2f f3       	sub	r3,-1
800098dc:	5c 83       	casts.h	r3
800098de:	e6 00 19 00 	cp.h	r0,r3
800098e2:	fe 98 ff 9c 	brls	8000981a <et024006_PrintString+0x3e>
          }
          mask >>= 1;
        }

        // Next row data
        data++;
800098e6:	2f f2       	sub	r2,-1
800098e8:	ce 1b       	rjmp	800098aa <et024006_PrintString+0xce>
  {
    do
    {
      if(*lcd_string =='\n') {
        x = saved_x;
        y += yfont;
800098ea:	40 59       	lddsp	r9,sp[0x14]
800098ec:	00 09       	add	r9,r0
800098ee:	5c 89       	casts.h	r9
800098f0:	50 59       	stdsp	sp[0x14],r9
800098f2:	40 b1       	lddsp	r1,sp[0x2c]
      }
      // move to next character start pixel
      x += xfont;
      lcd_string++;  // next character in string

    }while(*lcd_string !='\0');  // keep spitting chars out until end of string
800098f4:	0d 39       	ld.ub	r9,r6++
800098f6:	58 09       	cp.w	r9,0
800098f8:	c9 41       	brne	80009820 <et024006_PrintString+0x44>
  }
}
800098fa:	2e fd       	sub	sp,-68
800098fc:	d8 32       	popm	r0-r7,pc

  // If transparent mode
  if(bcolor == -1)
  {
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );
800098fe:	30 0b       	mov	r11,0
80009900:	e0 69 00 ef 	mov	r9,239
80009904:	16 9c       	mov	r12,r11
80009906:	e0 6a 01 3f 	mov	r10,319
8000990a:	50 08       	stdsp	sp[0x0],r8
8000990c:	fe b0 fc b4 	rcall	80009274 <et024006_SetLimits>
        data =  (font_style + font_size) +  // header offset
          (font_size * (int)(*lcd_string - 32)); // character select
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;
80009910:	40 7b       	lddsp	r11,sp[0x1c]

  // If transparent mode
  if(bcolor == -1)
  {
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );
80009912:	50 d6       	stdsp	sp[0x34],r6
        data =  (font_style + font_size) +  // header offset
          (font_size * (int)(*lcd_string - 32)); // character select
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;
80009914:	f6 0b 00 19 	add	r9,r11,r11<<0x1
80009918:	a5 79       	lsl	r9,0x5
8000991a:	5c 85       	casts.h	r5

  // If transparent mode
  if(bcolor == -1)
  {
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );
8000991c:	0c 9c       	mov	r12,r6

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000991e:	40 08       	lddsp	r8,sp[0x0]
        data =  (font_style + font_size) +  // header offset
          (font_size * (int)(*lcd_string - 32)); // character select
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;
80009920:	50 b5       	stdsp	sp[0x2c],r5
80009922:	40 9a       	lddsp	r10,sp[0x24]
80009924:	12 0a       	add	r10,r9
80009926:	51 0a       	stdsp	sp[0x40],r10

  // If transparent mode
  if(bcolor == -1)
  {
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );
80009928:	19 39       	ld.ub	r9,r12++

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000992a:	50 28       	stdsp	sp[0x8],r8

  // If transparent mode
  if(bcolor == -1)
  {
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );
8000992c:	50 dc       	stdsp	sp[0x34],r12
        data =  (font_style + font_size) +  // header offset
          (font_size * (int)(*lcd_string - 32)); // character select
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;
8000992e:	50 c5       	stdsp	sp[0x30],r5

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009930:	50 f7       	stdsp	sp[0x3c],r7
      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
        {
          if (*data & mask) // if pixel data then put dot
80009932:	30 02       	mov	r2,0

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009934:	fc 1b c0 00 	movh	r11,0xc000
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );

    do
    {
      if(*lcd_string =='\n') {
80009938:	30 a8       	mov	r8,10
8000993a:	f0 09 18 00 	cp.b	r9,r8
8000993e:	c6 f0       	breq	80009a1c <et024006_PrintString+0x240>
        x = saved_x;
        y += yfont;
        lcd_string++;  // next character in string
        continue;
      } else if(*lcd_string =='\t') {
80009940:	30 98       	mov	r8,9
80009942:	f0 09 18 00 	cp.b	r9,r8
80009946:	c7 c0       	breq	80009a3e <et024006_PrintString+0x262>
        x += xfont;
        lcd_string++;  // next character in string
        continue;
      }
      // Checks if the character can be printed
      if (*lcd_string >= 32 && *lcd_string < (32 + 96))
80009948:	f2 ca 00 20 	sub	r10,r9,32
8000994c:	35 f8       	mov	r8,95
8000994e:	f0 0a 18 00 	cp.b	r10,r8
80009952:	e0 88 00 6d 	brls	80009a2c <et024006_PrintString+0x250>
80009956:	41 0a       	lddsp	r10,sp[0x40]
80009958:	50 4a       	stdsp	sp[0x10],r10
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
8000995a:	40 58       	lddsp	r8,sp[0x14]
8000995c:	40 ea       	lddsp	r10,sp[0x38]
8000995e:	5c 78       	castu.h	r8
80009960:	f0 0a 00 0a 	add	r10,r8,r10
80009964:	50 6a       	stdsp	sp[0x18],r10
80009966:	14 38       	cp.w	r8,r10
80009968:	c4 b4       	brge	800099fe <et024006_PrintString+0x222>
8000996a:	40 fc       	lddsp	r12,sp[0x3c]
/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000996c:	40 ca       	lddsp	r10,sp[0x30]
8000996e:	5c 8a       	casts.h	r10
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
80009970:	40 c9       	lddsp	r9,sp[0x30]
80009972:	40 58       	lddsp	r8,sp[0x14]
80009974:	5c 79       	castu.h	r9
80009976:	5c 88       	casts.h	r8
80009978:	12 96       	mov	r6,r9
/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000997a:	50 aa       	stdsp	sp[0x28],r10
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
8000997c:	18 06       	add	r6,r12
8000997e:	50 89       	stdsp	sp[0x20],r9
80009980:	50 38       	stdsp	sp[0xc],r8
/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009982:	fc 1a c0 20 	movh	r10,0xc020
80009986:	12 9c       	mov	r12,r9
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
80009988:	0c 3c       	cp.w	r12,r6
8000998a:	c2 d4       	brge	800099e4 <et024006_PrintString+0x208>
8000998c:	40 49       	lddsp	r9,sp[0x10]
/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000998e:	40 38       	lddsp	r8,sp[0xc]
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
80009990:	13 85       	ld.ub	r5,r9[0x0]
/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009992:	e1 d8 c1 08 	bfextu	r0,r8,0x8,0x8
80009996:	40 3c       	lddsp	r12,sp[0xc]
80009998:	40 a8       	lddsp	r8,sp[0x28]
8000999a:	5c 5c       	castu.b	r12
8000999c:	e0 69 00 80 	mov	r9,128

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800099a0:	30 31       	mov	r1,3
800099a2:	30 63       	mov	r3,6
800099a4:	30 74       	mov	r4,7
  *ET024006_PARAM_ADDR = (uint16_t) value;
800099a6:	50 1c       	stdsp	sp[0x4],r12
800099a8:	ef d8 c1 08 	bfextu	r7,r8,0x8,0x8
800099ac:	fd d8 c0 08 	bfextu	lr,r8,0x0,0x8
      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
        {
          if (*data & mask) // if pixel data then put dot
800099b0:	f3 e5 00 0c 	and	r12,r9,r5
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
800099b4:	2f f8       	sub	r8,-1
800099b6:	5c 88       	casts.h	r8
        {
          if (*data & mask) // if pixel data then put dot
800099b8:	e4 0c 18 00 	cp.b	r12,r2
800099bc:	c0 f0       	breq	800099da <et024006_PrintString+0x1fe>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800099be:	30 2c       	mov	r12,2
800099c0:	b6 0c       	st.h	r11[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
800099c2:	b4 07       	st.h	r10[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800099c4:	b6 01       	st.h	r11[0x0],r1
  *ET024006_PARAM_ADDR = (uint16_t) value;
800099c6:	b4 0e       	st.h	r10[0x0],lr

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800099c8:	b6 03       	st.h	r11[0x0],r3
  *ET024006_PARAM_ADDR = (uint16_t) value;
800099ca:	b4 00       	st.h	r10[0x0],r0

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800099cc:	b6 04       	st.h	r11[0x0],r4
  *ET024006_PARAM_ADDR = (uint16_t) value;
800099ce:	40 1c       	lddsp	r12,sp[0x4]
800099d0:	b4 0c       	st.h	r10[0x0],r12
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800099d2:	32 2c       	mov	r12,34
800099d4:	b6 0c       	st.h	r11[0x0],r12
  et024006_SendSPI( color & 0xff );
  et024006_SendSPI( color >> 8 );
  et024006_DeselectSPI();
#endif
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  *ET024006_PARAM_ADDR = color;
800099d6:	40 2c       	lddsp	r12,sp[0x8]
800099d8:	b4 0c       	st.h	r10[0x0],r12
        {
          if (*data & mask) // if pixel data then put dot
          {
            et024006_DrawQuickPixel( col, row, fcolor );
          }
          mask >>= 1;
800099da:	a1 99       	lsr	r9,0x1
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
800099dc:	f9 d8 c0 10 	bfextu	r12,r8,0x0,0x10
800099e0:	0c 3c       	cp.w	r12,r6
800099e2:	ce 35       	brlt	800099a8 <et024006_PrintString+0x1cc>
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
800099e4:	40 38       	lddsp	r8,sp[0xc]
800099e6:	2f f8       	sub	r8,-1
800099e8:	5c 88       	casts.h	r8
800099ea:	50 38       	stdsp	sp[0xc],r8
800099ec:	40 69       	lddsp	r9,sp[0x18]
800099ee:	5c 78       	castu.h	r8
800099f0:	12 38       	cp.w	r8,r9
800099f2:	c0 64       	brge	800099fe <et024006_PrintString+0x222>
            et024006_DrawQuickPixel( col, row, fcolor );
          }
          mask >>= 1;
        }
        // Next row data
        data++;
800099f4:	40 48       	lddsp	r8,sp[0x10]
800099f6:	40 8c       	lddsp	r12,sp[0x20]
800099f8:	2f f8       	sub	r8,-1
800099fa:	50 48       	stdsp	sp[0x10],r8
800099fc:	cc 6b       	rjmp	80009988 <et024006_PrintString+0x1ac>
      }
      // move to next character start pixel
      x += xfont;
800099fe:	40 c8       	lddsp	r8,sp[0x30]
80009a00:	40 fa       	lddsp	r10,sp[0x3c]
80009a02:	14 08       	add	r8,r10
80009a04:	5c 88       	casts.h	r8
80009a06:	50 c8       	stdsp	sp[0x30],r8
      lcd_string++;  // next character in string

    }while(*lcd_string !='\0');  // keep spitting chars out until end of string
80009a08:	40 d8       	lddsp	r8,sp[0x34]
80009a0a:	11 39       	ld.ub	r9,r8++
80009a0c:	50 d8       	stdsp	sp[0x34],r8
80009a0e:	58 09       	cp.w	r9,0
80009a10:	fe 90 ff 75 	breq	800098fa <et024006_PrintString+0x11e>
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );

    do
    {
      if(*lcd_string =='\n') {
80009a14:	30 a8       	mov	r8,10
80009a16:	f0 09 18 00 	cp.b	r9,r8
80009a1a:	c9 31       	brne	80009940 <et024006_PrintString+0x164>
        x = saved_x;
        y += yfont;
80009a1c:	40 58       	lddsp	r8,sp[0x14]
80009a1e:	40 ea       	lddsp	r10,sp[0x38]
80009a20:	40 b9       	lddsp	r9,sp[0x2c]
80009a22:	14 08       	add	r8,r10
80009a24:	50 c9       	stdsp	sp[0x30],r9
80009a26:	5c 88       	casts.h	r8
80009a28:	50 58       	stdsp	sp[0x14],r8
        lcd_string++;  // next character in string
        continue;
80009a2a:	ce fb       	rjmp	80009a08 <et024006_PrintString+0x22c>
      }
      // Checks if the character can be printed
      if (*lcd_string >= 32 && *lcd_string < (32 + 96))
      {
        // point to character data in font table
        data =  (font_style + font_size) +  // header offset
80009a2c:	f2 c8 00 20 	sub	r8,r9,32
80009a30:	40 9c       	lddsp	r12,sp[0x24]
80009a32:	40 79       	lddsp	r9,sp[0x1c]
80009a34:	b3 38       	mul	r8,r9
80009a36:	12 08       	add	r8,r9
80009a38:	10 0c       	add	r12,r8
80009a3a:	50 4c       	stdsp	sp[0x10],r12
80009a3c:	c8 fb       	rjmp	8000995a <et024006_PrintString+0x17e>
        x = saved_x;
        y += yfont;
        lcd_string++;  // next character in string
        continue;
      } else if(*lcd_string =='\t') {
        x += xfont;
80009a3e:	40 c8       	lddsp	r8,sp[0x30]
80009a40:	40 fc       	lddsp	r12,sp[0x3c]
80009a42:	18 08       	add	r8,r12
80009a44:	5c 88       	casts.h	r8
80009a46:	50 c8       	stdsp	sp[0x30],r8
        lcd_string++;  // next character in string
        continue;
80009a48:	ce 0b       	rjmp	80009a08 <et024006_PrintString+0x22c>
80009a4a:	d7 03       	nop

80009a4c <et024006_DrawFilledRect>:
80009a4c:	eb cd 40 c0 	pushm	r6-r7,lr

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009a50:	fc 1e c0 00 	movh	lr,0xc000
80009a54:	30 27       	mov	r7,2
80009a56:	bc 07       	st.h	lr[0x0],r7
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009a58:	ed dc c1 08 	bfextu	r6,r12,0x8,0x8
80009a5c:	fc 17 c0 20 	movh	r7,0xc020
80009a60:	ae 06       	st.h	r7[0x0],r6

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009a62:	30 36       	mov	r6,3
80009a64:	bc 06       	st.h	lr[0x0],r6
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009a66:	ed dc c0 08 	bfextu	r6,r12,0x0,0x8
80009a6a:	ae 06       	st.h	r7[0x0],r6

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009a6c:	30 46       	mov	r6,4
80009a6e:	bc 06       	st.h	lr[0x0],r6
  Assert( y < ET024006_HEIGHT );
  Assert( width > 0 );
  Assert( height > 0 );

  // Compute bottom right point.
  uint16_t x2 = x + width - 1;
80009a70:	20 1c       	sub	r12,1
80009a72:	14 0c       	add	r12,r10
80009a74:	5c 8c       	casts.h	r12
/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009a76:	ed dc c1 08 	bfextu	r6,r12,0x8,0x8
80009a7a:	ae 06       	st.h	r7[0x0],r6

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009a7c:	30 56       	mov	r6,5
80009a7e:	bc 06       	st.h	lr[0x0],r6
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009a80:	ae 0c       	st.h	r7[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009a82:	30 6c       	mov	r12,6
80009a84:	bc 0c       	st.h	lr[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009a86:	f9 db c1 08 	bfextu	r12,r11,0x8,0x8
80009a8a:	ae 0c       	st.h	r7[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009a8c:	30 7c       	mov	r12,7
80009a8e:	bc 0c       	st.h	lr[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009a90:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
80009a94:	ae 0c       	st.h	r7[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009a96:	30 8c       	mov	r12,8
80009a98:	bc 0c       	st.h	lr[0x0],r12
  Assert( width > 0 );
  Assert( height > 0 );

  // Compute bottom right point.
  uint16_t x2 = x + width - 1;
  uint16_t y2 = y + height - 1;
80009a9a:	20 1b       	sub	r11,1
80009a9c:	12 0b       	add	r11,r9
80009a9e:	5c 8b       	casts.h	r11
/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009aa0:	f9 db c1 08 	bfextu	r12,r11,0x8,0x8
80009aa4:	ae 0c       	st.h	r7[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009aa6:	30 9c       	mov	r12,9
80009aa8:	bc 0c       	st.h	lr[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009aaa:	ae 0b       	st.h	r7[0x0],r11
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009aac:	32 2b       	mov	r11,34
80009aae:	bc 0b       	st.h	lr[0x0],r11
  Assert( x2 < ET024006_WIDTH );
  Assert( y2 < ET024006_HEIGHT );

  // Set up draw area and copy pixel color until area is full.
  et024006_SetLimits( x, y, x2, y2 );
  uint32_t count = (uint32_t) width * height;
80009ab0:	5c 79       	castu.h	r9
80009ab2:	5c 7a       	castu.h	r10
80009ab4:	f2 0a 02 4a 	mul	r10,r9,r10
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  //uint8_t countLowByte = count;
  while (count >= 8) {
80009ab8:	58 7a       	cp.w	r10,7
80009aba:	e0 88 00 11 	brls	80009adc <et024006_DrawFilledRect+0x90>
80009abe:	14 99       	mov	r9,r10
    *ET024006_PARAM_ADDR = color;
80009ac0:	ae 08       	st.h	r7[0x0],r8
    *ET024006_PARAM_ADDR = color;
80009ac2:	ae 08       	st.h	r7[0x0],r8
    *ET024006_PARAM_ADDR = color;
80009ac4:	ae 08       	st.h	r7[0x0],r8
    *ET024006_PARAM_ADDR = color;
80009ac6:	ae 08       	st.h	r7[0x0],r8
    *ET024006_PARAM_ADDR = color;
80009ac8:	ae 08       	st.h	r7[0x0],r8
    *ET024006_PARAM_ADDR = color;
80009aca:	ae 08       	st.h	r7[0x0],r8
    *ET024006_PARAM_ADDR = color;
80009acc:	ae 08       	st.h	r7[0x0],r8
    *ET024006_PARAM_ADDR = color;
80009ace:	ae 08       	st.h	r7[0x0],r8
    count-=8;
80009ad0:	20 89       	sub	r9,8
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  //uint8_t countLowByte = count;
  while (count >= 8) {
80009ad2:	58 79       	cp.w	r9,7
80009ad4:	fe 9b ff f6 	brhi	80009ac0 <et024006_DrawFilledRect+0x74>
    }
  }
}


void et024006_DrawFilledRect( uint16_t x, uint16_t y, uint16_t width, uint16_t height, et024006_color_t color )
80009ad8:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    count-=8;
  }
  while (count > 0) {
80009adc:	58 0a       	cp.w	r10,0
80009ade:	c0 60       	breq	80009aea <et024006_DrawFilledRect+0x9e>
    *ET024006_PARAM_ADDR = color;
80009ae0:	fc 19 c0 20 	movh	r9,0xc020
80009ae4:	b2 08       	st.h	r9[0x0],r8
    --count;
80009ae6:	20 1a       	sub	r10,1
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    count-=8;
  }
  while (count > 0) {
80009ae8:	cf e1       	brne	80009ae4 <et024006_DrawFilledRect+0x98>
80009aea:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80009aee <et024006_PutPixmap>:
  uint16_t map_y,
  uint16_t x,
  uint16_t y,
  uint16_t width,
  uint16_t height )
{
80009aee:	eb cd 40 fc 	pushm	r2-r7,lr

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009af2:	fc 1e c0 00 	movh	lr,0xc000
  uint16_t map_y,
  uint16_t x,
  uint16_t y,
  uint16_t width,
  uint16_t height )
{
80009af6:	fa c4 ff e4 	sub	r4,sp,-28

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009afa:	30 25       	mov	r5,2
  uint16_t map_y,
  uint16_t x,
  uint16_t y,
  uint16_t width,
  uint16_t height )
{
80009afc:	68 07       	ld.w	r7,r4[0x0]
80009afe:	68 23       	ld.w	r3,r4[0x8]
80009b00:	68 16       	ld.w	r6,r4[0x4]

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009b02:	bc 05       	st.h	lr[0x0],r5
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009b04:	e9 d8 c1 08 	bfextu	r4,r8,0x8,0x8
80009b08:	fc 15 c0 20 	movh	r5,0xc020
80009b0c:	aa 04       	st.h	r5[0x0],r4

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009b0e:	30 34       	mov	r4,3
80009b10:	bc 04       	st.h	lr[0x0],r4
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009b12:	e9 d8 c0 08 	bfextu	r4,r8,0x0,0x8
80009b16:	aa 04       	st.h	r5[0x0],r4

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009b18:	30 44       	mov	r4,4
80009b1a:	bc 04       	st.h	lr[0x0],r4
  Assert( y < ET024006_HEIGHT );
  Assert( width > 0 );
  Assert( height > 0 );

  // Compute bottom right point.
  uint16_t x2 = x + width - 1;
80009b1c:	20 18       	sub	r8,1
80009b1e:	0c 08       	add	r8,r6
80009b20:	5c 88       	casts.h	r8
/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009b22:	e9 d8 c1 08 	bfextu	r4,r8,0x8,0x8
80009b26:	aa 04       	st.h	r5[0x0],r4

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009b28:	30 54       	mov	r4,5
80009b2a:	bc 04       	st.h	lr[0x0],r4
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009b2c:	aa 08       	st.h	r5[0x0],r8

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009b2e:	30 68       	mov	r8,6
80009b30:	bc 08       	st.h	lr[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009b32:	f1 d7 c1 08 	bfextu	r8,r7,0x8,0x8
80009b36:	aa 08       	st.h	r5[0x0],r8

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009b38:	30 78       	mov	r8,7
80009b3a:	bc 08       	st.h	lr[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009b3c:	0e 98       	mov	r8,r7
80009b3e:	aa 08       	st.h	r5[0x0],r8

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009b40:	30 88       	mov	r8,8
80009b42:	bc 08       	st.h	lr[0x0],r8
  Assert( width > 0 );
  Assert( height > 0 );

  // Compute bottom right point.
  uint16_t x2 = x + width - 1;
  uint16_t y2 = y + height - 1;
80009b44:	0e 98       	mov	r8,r7
80009b46:	20 18       	sub	r8,1
80009b48:	06 08       	add	r8,r3
80009b4a:	5c 88       	casts.h	r8
/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009b4c:	ef d8 c1 08 	bfextu	r7,r8,0x8,0x8
80009b50:	aa 07       	st.h	r5[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009b52:	30 97       	mov	r7,9
80009b54:	bc 07       	st.h	lr[0x0],r7
  *ET024006_PARAM_ADDR = (uint16_t) value;
80009b56:	aa 08       	st.h	r5[0x0],r8

  // Set up draw area.
  et024006_SetLimits( x, y, x2, y2 );

  // Offset into pixmap.
  pixmap += map_x;
80009b58:	f1 da c0 10 	bfextu	r8,r10,0x0,0x10
80009b5c:	f8 08 00 18 	add	r8,r12,r8<<0x1
  if (map_y > 0) {
80009b60:	58 09       	cp.w	r9,0
80009b62:	c0 70       	breq	80009b70 <et024006_PutPixmap+0x82>
    pixmap += (uint32_t) map_y * map_width;
80009b64:	5c 79       	castu.h	r9
80009b66:	f9 db c0 10 	bfextu	r12,r11,0x0,0x10
80009b6a:	a1 7c       	lsl	r12,0x1
80009b6c:	f8 09 03 48 	mac	r8,r12,r9
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009b70:	fc 17 c0 00 	movh	r7,0xc000
80009b74:	32 2c       	mov	r12,34
80009b76:	ae 0c       	st.h	r7[0x0],r12
  }
  // we need access to the display SRAM now
  et024006_SelectRegister( HIMAX_SRAMWRITE );

  // In case of no horizontal pixmap clipping, easier handling is possible.
  if ((map_width == width) && (map_x == 0)) {
80009b78:	ec 0b 19 00 	cp.h	r11,r6
80009b7c:	5f 0e       	sreq	lr
80009b7e:	30 09       	mov	r9,0
80009b80:	f2 0a 19 00 	cp.h	r10,r9
80009b84:	5f 0a       	sreq	r10
80009b86:	fd ea 00 0a 	and	r10,lr,r10
80009b8a:	f2 0a 18 00 	cp.b	r10,r9
80009b8e:	c4 21       	brne	80009c12 <et024006_PutPixmap+0x124>
    uint32_t count = (uint32_t) width * height;
    et024006_CopyPixelsToScreen( pixmap, count );
  } else {
    // Copy line by line to screen.
    uint16_t lines_left = height;
    while (lines_left > 0) {
80009b90:	58 03       	cp.w	r3,0
80009b92:	c7 50       	breq	80009c7c <et024006_PutPixmap+0x18e>
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009b94:	ae 0c       	st.h	r7[0x0],r12
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    count-=8;
  }
  while( count )
80009b96:	5c 7b       	castu.h	r11
80009b98:	5c 76       	castu.h	r6
80009b9a:	f6 04 15 01 	lsl	r4,r11,0x1
      --lines_left;
    }
  }
}

void et024006_PutPixmap(
80009b9e:	ec c2 00 08 	sub	r2,r6,8
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    count-=8;
  }
  while( count )
80009ba2:	5c 83       	casts.h	r3
      --lines_left;
    }
  }
}

void et024006_PutPixmap(
80009ba4:	e4 05 16 03 	lsr	r5,r2,0x3
  et024006_SelectRegister( HIMAX_SRAMWRITE );

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  while (count >= 8)
  {
    *ET024006_PARAM_ADDR = *pixels++;
80009ba8:	fc 1a c0 20 	movh	r10,0xc020
      --lines_left;
    }
  }
}

void et024006_PutPixmap(
80009bac:	e4 05 01 32 	sub	r2,r2,r5<<0x3
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  while (count >= 8)
80009bb0:	58 76       	cp.w	r6,7
80009bb2:	e0 88 00 2d 	brls	80009c0c <et024006_PutPixmap+0x11e>
80009bb6:	0c 9b       	mov	r11,r6
80009bb8:	10 99       	mov	r9,r8
  {
    *ET024006_PARAM_ADDR = *pixels++;
80009bba:	92 0e       	ld.sh	lr,r9[0x0]
80009bbc:	b4 0e       	st.h	r10[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
80009bbe:	92 1e       	ld.sh	lr,r9[0x2]
80009bc0:	b4 0e       	st.h	r10[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
80009bc2:	92 2e       	ld.sh	lr,r9[0x4]
80009bc4:	b4 0e       	st.h	r10[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
80009bc6:	92 3e       	ld.sh	lr,r9[0x6]
80009bc8:	b4 0e       	st.h	r10[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
80009bca:	92 4e       	ld.sh	lr,r9[0x8]
80009bcc:	b4 0e       	st.h	r10[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
80009bce:	92 5e       	ld.sh	lr,r9[0xa]
80009bd0:	b4 0e       	st.h	r10[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
80009bd2:	92 6e       	ld.sh	lr,r9[0xc]
80009bd4:	b4 0e       	st.h	r10[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
80009bd6:	92 7e       	ld.sh	lr,r9[0xe]
80009bd8:	b4 0e       	st.h	r10[0x0],lr
      --lines_left;
    }
  }
}

void et024006_PutPixmap(
80009bda:	2f 09       	sub	r9,-16
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    count-=8;
80009bdc:	20 8b       	sub	r11,8
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  while (count >= 8)
80009bde:	58 7b       	cp.w	r11,7
80009be0:	fe 9b ff ed 	brhi	80009bba <et024006_PutPixmap+0xcc>
      --lines_left;
    }
  }
}

void et024006_PutPixmap(
80009be4:	ea cb ff ff 	sub	r11,r5,-1
80009be8:	04 99       	mov	r9,r2
80009bea:	a5 6b       	lsl	r11,0x4
80009bec:	f0 0b 00 0b 	add	r11,r8,r11
80009bf0:	c0 48       	rjmp	80009bf8 <et024006_PutPixmap+0x10a>
    *ET024006_PARAM_ADDR = *pixels++;
    count-=8;
  }
  while( count )
  {
    *ET024006_PARAM_ADDR = *pixels;
80009bf2:	17 1e       	ld.sh	lr,r11++
    pixels++;
    count--;
80009bf4:	20 19       	sub	r9,1
    *ET024006_PARAM_ADDR = *pixels++;
    count-=8;
  }
  while( count )
  {
    *ET024006_PARAM_ADDR = *pixels;
80009bf6:	b4 0e       	st.h	r10[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    count-=8;
  }
  while( count )
80009bf8:	58 09       	cp.w	r9,0
80009bfa:	cf c1       	brne	80009bf2 <et024006_PutPixmap+0x104>
    // Copy line by line to screen.
    uint16_t lines_left = height;
    while (lines_left > 0) {
      et024006_CopyPixelsToScreen( pixmap, width );
      pixmap += map_width;
      --lines_left;
80009bfc:	20 13       	sub	r3,1
80009bfe:	5c 83       	casts.h	r3
    uint32_t count = (uint32_t) width * height;
    et024006_CopyPixelsToScreen( pixmap, count );
  } else {
    // Copy line by line to screen.
    uint16_t lines_left = height;
    while (lines_left > 0) {
80009c00:	c3 40       	breq	80009c68 <et024006_PutPixmap+0x17a>
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009c02:	ae 0c       	st.h	r7[0x0],r12
  } else {
    // Copy line by line to screen.
    uint16_t lines_left = height;
    while (lines_left > 0) {
      et024006_CopyPixelsToScreen( pixmap, width );
      pixmap += map_width;
80009c04:	08 08       	add	r8,r4
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  while (count >= 8)
80009c06:	58 76       	cp.w	r6,7
80009c08:	fe 9b ff d7 	brhi	80009bb6 <et024006_PutPixmap+0xc8>
80009c0c:	0c 99       	mov	r9,r6
80009c0e:	10 9b       	mov	r11,r8
80009c10:	cf 4b       	rjmp	80009bf8 <et024006_PutPixmap+0x10a>
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80009c12:	ae 0c       	st.h	r7[0x0],r12
  et024006_SelectRegister( HIMAX_SRAMWRITE );

  // In case of no horizontal pixmap clipping, easier handling is possible.
  if ((map_width == width) && (map_x == 0)) {
    // Compute pixel count and copy pixels to screen.
    uint32_t count = (uint32_t) width * height;
80009c14:	f7 d3 c0 10 	bfextu	r11,r3,0x0,0x10
80009c18:	5c 76       	castu.h	r6
80009c1a:	ad 3b       	mul	r11,r6
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  while (count >= 8)
80009c1c:	58 7b       	cp.w	r11,7
80009c1e:	e0 88 00 23 	brls	80009c64 <et024006_PutPixmap+0x176>
80009c22:	16 9c       	mov	r12,r11
80009c24:	10 99       	mov	r9,r8
  {
    *ET024006_PARAM_ADDR = *pixels++;
80009c26:	fc 1a c0 20 	movh	r10,0xc020
80009c2a:	92 0e       	ld.sh	lr,r9[0x0]
80009c2c:	b4 0e       	st.h	r10[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
80009c2e:	92 1e       	ld.sh	lr,r9[0x2]
80009c30:	b4 0e       	st.h	r10[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
80009c32:	92 2e       	ld.sh	lr,r9[0x4]
80009c34:	b4 0e       	st.h	r10[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
80009c36:	92 3e       	ld.sh	lr,r9[0x6]
80009c38:	b4 0e       	st.h	r10[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
80009c3a:	92 4e       	ld.sh	lr,r9[0x8]
80009c3c:	b4 0e       	st.h	r10[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
80009c3e:	92 5e       	ld.sh	lr,r9[0xa]
80009c40:	b4 0e       	st.h	r10[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
80009c42:	92 6e       	ld.sh	lr,r9[0xc]
80009c44:	b4 0e       	st.h	r10[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
80009c46:	92 7e       	ld.sh	lr,r9[0xe]
80009c48:	b4 0e       	st.h	r10[0x0],lr
      --lines_left;
    }
  }
}

void et024006_PutPixmap(
80009c4a:	2f 09       	sub	r9,-16
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    count-=8;
80009c4c:	20 8c       	sub	r12,8
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  while (count >= 8)
80009c4e:	58 7c       	cp.w	r12,7
80009c50:	fe 9b ff ed 	brhi	80009c2a <et024006_PutPixmap+0x13c>
      --lines_left;
    }
  }
}

void et024006_PutPixmap(
80009c54:	f6 c9 00 08 	sub	r9,r11,8
80009c58:	f7 d9 c0 03 	bfextu	r11,r9,0x0,0x3
80009c5c:	a3 99       	lsr	r9,0x3
80009c5e:	2f f9       	sub	r9,-1
80009c60:	a5 69       	lsl	r9,0x4
80009c62:	12 08       	add	r8,r9
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    count-=8;
  }
  while( count )
80009c64:	58 0b       	cp.w	r11,0
80009c66:	c0 31       	brne	80009c6c <et024006_PutPixmap+0x17e>
80009c68:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
  {
    *ET024006_PARAM_ADDR = *pixels;
80009c6c:	fc 1a c0 20 	movh	r10,0xc020
80009c70:	11 19       	ld.sh	r9,r8++
80009c72:	b4 09       	st.h	r10[0x0],r9
    pixels++;
    count--;
80009c74:	20 1b       	sub	r11,1
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    count-=8;
  }
  while( count )
80009c76:	cf d1       	brne	80009c70 <et024006_PutPixmap+0x182>
80009c78:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80009c7c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc

80009c80 <sd_mmc_spi_get_capacity>:
//!         [39]    == data[11] && 0x80
//!
//! @return bit
//!         true
void sd_mmc_spi_get_capacity(void)
{
80009c80:	eb cd 40 c0 	pushm	r6-r7,lr
  uint8_t  erase_grp_size;
  uint8_t  erase_grp_mult;

  // extract variables from CSD array
  read_bl_len = csd[5] & 0x0F;
  if (card_type == SD_CARD_2_SDHC) {
80009c84:	e0 69 0c d2 	mov	r9,3282
80009c88:	e0 68 0c d4 	mov	r8,3284
80009c8c:	13 8b       	ld.ub	r11,r9[0x0]
80009c8e:	11 dc       	ld.ub	r12,r8[0x5]
80009c90:	30 39       	mov	r9,3
80009c92:	f2 0b 18 00 	cp.b	r11,r9
    capacity_mult = (c_size >> 13) & 0x01FF;
    sd_mmc_spi_last_block_address = (capacity >> 9) + (capacity_mult << 23) - 1;
  } else {
    c_size      = ((csd[6] & 0x03) << 10) + (csd[7] << 2) + ((csd[8] & 0xC0) >> 6);
    c_size_mult = ((csd[9] & 0x03) << 1) + ((csd[10] & 0x80) >> 7);
    sd_mmc_spi_last_block_address = ((uint32_t)(c_size + 1) * (uint32_t)((1 << (c_size_mult + 2)))) - 1;
80009c96:	c4 60       	breq	80009d22 <sd_mmc_spi_get_capacity+0xa2>
80009c98:	11 fe       	ld.ub	lr,r8[0x7]
80009c9a:	f1 37 00 08 	ld.ub	r7,r8[8]
80009c9e:	a7 87       	lsr	r7,0x6
80009ca0:	ee 0e 00 27 	add	r7,r7,lr<<0x2
80009ca4:	11 ee       	ld.ub	lr,r8[0x6]
80009ca6:	fd de c0 02 	bfextu	lr,lr,0x0,0x2
    capacity = (uint64_t)c_size << 19;
    capacity_mult = (c_size >> 13) & 0x01FF;
    sd_mmc_spi_last_block_address = (capacity >> 9) + (capacity_mult << 23) - 1;
  } else {
    c_size      = ((csd[6] & 0x03) << 10) + (csd[7] << 2) + ((csd[8] & 0xC0) >> 6);
    c_size_mult = ((csd[9] & 0x03) << 1) + ((csd[10] & 0x80) >> 7);
80009caa:	ab 6e       	lsl	lr,0xa
    sd_mmc_spi_last_block_address = ((uint32_t)(c_size + 1) * (uint32_t)((1 << (c_size_mult + 2)))) - 1;
80009cac:	f1 39 00 0a 	ld.ub	r9,r8[10]
80009cb0:	1c 07       	add	r7,lr
80009cb2:	f2 06 16 07 	lsr	r6,r9,0x7
80009cb6:	2f f7       	sub	r7,-1
80009cb8:	f1 3e 00 09 	ld.ub	lr,r8[9]
80009cbc:	fd de c0 02 	bfextu	lr,lr,0x0,0x2
80009cc0:	ec 0e 00 1e 	add	lr,r6,lr<<0x1
80009cc4:	2f ee       	sub	lr,-2
80009cc6:	ee 0e 09 4e 	lsl	lr,r7,lr
  uint8_t  read_bl_len;
  uint8_t  erase_grp_size;
  uint8_t  erase_grp_mult;

  // extract variables from CSD array
  read_bl_len = csd[5] & 0x0F;
80009cca:	20 1e       	sub	lr,1
80009ccc:	e0 6a 0c cc 	mov	r10,3276
    sd_mmc_spi_last_block_address = (capacity >> 9) + (capacity_mult << 23) - 1;
  } else {
    c_size      = ((csd[6] & 0x03) << 10) + (csd[7] << 2) + ((csd[8] & 0xC0) >> 6);
    c_size_mult = ((csd[9] & 0x03) << 1) + ((csd[10] & 0x80) >> 7);
    sd_mmc_spi_last_block_address = ((uint32_t)(c_size + 1) * (uint32_t)((1 << (c_size_mult + 2)))) - 1;
    capacity = (1 << read_bl_len) * (sd_mmc_spi_last_block_address + 1);
80009cd0:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4
80009cd4:	95 0e       	st.w	r10[0x0],lr
80009cd6:	74 0e       	ld.w	lr,r10[0x0]
80009cd8:	2f fe       	sub	lr,-1
80009cda:	fc 0c 09 4e 	lsl	lr,lr,r12
80009cde:	1c 96       	mov	r6,lr
80009ce0:	30 0e       	mov	lr,0
80009ce2:	1c 97       	mov	r7,lr
    capacity_mult = 0;
80009ce4:	e0 6e 0c c0 	mov	lr,3264
80009ce8:	fc e7 00 00 	st.d	lr[0],r6
    if (read_bl_len > 9) {  // 9 means 2^9 = 512b
80009cec:	e0 67 0c c8 	mov	r7,3272
80009cf0:	30 0e       	mov	lr,0
80009cf2:	ae 0e       	st.h	r7[0x0],lr
      sd_mmc_spi_last_block_address <<= (read_bl_len - 9);
80009cf4:	30 97       	mov	r7,9
80009cf6:	ee 0c 18 00 	cp.b	r12,r7
80009cfa:	e0 88 00 07 	brls	80009d08 <sd_mmc_spi_get_capacity+0x88>
    }
  }
  if (card_type == MMC_CARD)
80009cfe:	74 0e       	ld.w	lr,r10[0x0]
80009d00:	20 9c       	sub	r12,9
  {
    erase_grp_size = ((csd[10] & 0x7C) >> 2);
80009d02:	fc 0c 09 4c 	lsl	r12,lr,r12
80009d06:	95 0c       	st.w	r10[0x0],r12
80009d08:	58 0b       	cp.w	r11,0
80009d0a:	c3 51       	brne	80009d74 <sd_mmc_spi_get_capacity+0xf4>
80009d0c:	f5 d9 c0 02 	bfextu	r10,r9,0x0,0x2
80009d10:	f1 38 00 0b 	ld.ub	r8,r8[11]
80009d14:	f3 d9 c0 45 	bfextu	r9,r9,0x2,0x5
  uint8_t  erase_grp_mult;

  // extract variables from CSD array
  read_bl_len = csd[5] & 0x0F;
  if (card_type == SD_CARD_2_SDHC) {
    c_size = ((csd[7] & 0x3F) << 16) | (csd[8] << 8) | csd[9];
80009d18:	a5 98       	lsr	r8,0x5
80009d1a:	f1 ea 10 38 	or	r8,r8,r10<<0x3
80009d1e:	2f f8       	sub	r8,-1
80009d20:	c3 28       	rjmp	80009d84 <sd_mmc_spi_get_capacity+0x104>
80009d22:	f1 3e 00 08 	ld.ub	lr,r8[8]
80009d26:	f1 39 00 09 	ld.ub	r9,r8[9]
80009d2a:	f3 ee 10 89 	or	r9,r9,lr<<0x8
    ++c_size;
80009d2e:	11 fe       	ld.ub	lr,r8[0x7]
    capacity = (uint64_t)c_size << 19;
80009d30:	fd de c0 06 	bfextu	lr,lr,0x0,0x6
80009d34:	f3 ee 11 0e 	or	lr,r9,lr<<0x10
80009d38:	2f fe       	sub	lr,-1
80009d3a:	fc 09 16 0d 	lsr	r9,lr,0xd
80009d3e:	fc 0a 15 13 	lsl	r10,lr,0x13
    capacity_mult = (c_size >> 13) & 0x01FF;
80009d42:	e0 6c 0c c0 	mov	r12,3264
80009d46:	12 9b       	mov	r11,r9
    sd_mmc_spi_last_block_address = (capacity >> 9) + (capacity_mult << 23) - 1;
80009d48:	f8 eb 00 00 	st.d	r12[0],r10
80009d4c:	f5 d9 c0 09 	bfextu	r10,r9,0x0,0x9
80009d50:	e0 69 0c c8 	mov	r9,3272
80009d54:	b2 0a       	st.h	r9[0x0],r10
80009d56:	f8 ea 00 00 	ld.d	r10,r12[0]
80009d5a:	92 0c       	ld.sh	r12,r9[0x0]
80009d5c:	f4 09 16 09 	lsr	r9,r10,0x9
80009d60:	b7 7c       	lsl	r12,0x17
80009d62:	f3 eb 11 79 	or	r9,r9,r11<<0x17
    erase_grp_size = ((csd[10] & 0x7C) >> 2);
    erase_grp_mult = ((csd[10] & 0x03) << 3) | ((csd[11] & 0xE0) >> 5);
  }
  else
  {
    erase_grp_size = ((csd[10] & 0x3F) << 1) + ((csd[11] & 0x80) >> 7);
80009d66:	20 19       	sub	r9,1
80009d68:	18 09       	add	r9,r12
80009d6a:	e0 6a 0c cc 	mov	r10,3276
80009d6e:	95 09       	st.w	r10[0x0],r9
80009d70:	f1 39 00 0a 	ld.ub	r9,r8[10]
    erase_grp_mult = 0;
  }
  erase_group_size = (erase_grp_size + 1) * (erase_grp_mult + 1);
80009d74:	f1 38 00 0b 	ld.ub	r8,r8[11]
80009d78:	a7 98       	lsr	r8,0x7
80009d7a:	f3 d9 c0 06 	bfextu	r9,r9,0x0,0x6
}
80009d7e:	f0 09 00 19 	add	r9,r8,r9<<0x1
80009d82:	30 18       	mov	r8,1
80009d84:	2f f9       	sub	r9,-1
80009d86:	b1 39       	mul	r9,r8
80009d88:	e0 68 0c ca 	mov	r8,3274
80009d8c:	b0 09       	st.h	r8[0x0],r9
80009d8e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009d92:	d7 03       	nop

80009d94 <sd_mmc_spi_write_close>:
80009d94:	5e fc       	retal	r12
80009d96:	d7 03       	nop

80009d98 <sd_mmc_spi_read_close_PDCA>:
//! Stop PDCA transfer
//! @brief This function closes a PDCA read transfer
//! page programming.
//!
void sd_mmc_spi_read_close_PDCA (void)
{
80009d98:	d4 01       	pushm	lr

  // load 16-bit CRC (ignored)
  spi_write(SD_MMC_SPI,0xFF);
80009d9a:	e0 6b 00 ff 	mov	r11,255
80009d9e:	fe 7c 24 00 	mov	r12,-56320
80009da2:	e0 a0 0f a0 	rcall	8000bce2 <spi_write>
  spi_write(SD_MMC_SPI,0xFF);
80009da6:	e0 6b 00 ff 	mov	r11,255
80009daa:	fe 7c 24 00 	mov	r12,-56320
80009dae:	e0 a0 0f 9a 	rcall	8000bce2 <spi_write>

  // continue delivering some clock cycles
  spi_write(SD_MMC_SPI,0xFF);
80009db2:	e0 6b 00 ff 	mov	r11,255
80009db6:	fe 7c 24 00 	mov	r12,-56320
80009dba:	e0 a0 0f 94 	rcall	8000bce2 <spi_write>
  spi_write(SD_MMC_SPI,0xFF);
80009dbe:	e0 6b 00 ff 	mov	r11,255
80009dc2:	fe 7c 24 00 	mov	r12,-56320
80009dc6:	e0 a0 0f 8e 	rcall	8000bce2 <spi_write>

  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80009dca:	30 1b       	mov	r11,1
80009dcc:	fe 7c 24 00 	mov	r12,-56320
80009dd0:	e0 a0 0f 1d 	rcall	8000bc0a <spi_unselectChip>

}
80009dd4:	d8 02       	popm	pc
80009dd6:	d7 03       	nop

80009dd8 <sd_mmc_spi_command>:
80009dd8:	eb cd 40 e0 	pushm	r5-r7,lr
80009ddc:	20 1d       	sub	sp,4
80009dde:	16 97       	mov	r7,r11
//! @param  arg       argument of the command
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF time out error)
uint8_t sd_mmc_spi_command(uint8_t command, uint32_t arg)
{
80009de0:	18 96       	mov	r6,r12
  uint8_t retry;

  spi_write(SD_MMC_SPI, 0xFF);            // write dummy byte
80009de2:	e0 6b 00 ff 	mov	r11,255
80009de6:	fe 7c 24 00 	mov	r12,-56320
80009dea:	e0 a0 0f 7c 	rcall	8000bce2 <spi_write>
  spi_write(SD_MMC_SPI, command | 0x40);  // send command
80009dee:	fe 7c 24 00 	mov	r12,-56320
80009df2:	0c 9b       	mov	r11,r6
80009df4:	a7 ab       	sbr	r11,0x6
80009df6:	5c 5b       	castu.b	r11
80009df8:	e0 a0 0f 75 	rcall	8000bce2 <spi_write>
  spi_write(SD_MMC_SPI, arg>>24);         // send parameter
80009dfc:	ee 0b 16 18 	lsr	r11,r7,0x18
80009e00:	fe 7c 24 00 	mov	r12,-56320
80009e04:	e0 a0 0f 6f 	rcall	8000bce2 <spi_write>
  spi_write(SD_MMC_SPI, arg>>16);
80009e08:	ee 0b 16 10 	lsr	r11,r7,0x10
80009e0c:	fe 7c 24 00 	mov	r12,-56320
80009e10:	e0 a0 0f 69 	rcall	8000bce2 <spi_write>
  spi_write(SD_MMC_SPI, arg>>8 );
80009e14:	f7 d7 c1 10 	bfextu	r11,r7,0x8,0x10
80009e18:	fe 7c 24 00 	mov	r12,-56320
80009e1c:	e0 a0 0f 63 	rcall	8000bce2 <spi_write>
  spi_write(SD_MMC_SPI, arg    );
80009e20:	0e 9b       	mov	r11,r7
80009e22:	fe 7c 24 00 	mov	r12,-56320
80009e26:	5c 7b       	castu.h	r11
80009e28:	e0 a0 0f 5d 	rcall	8000bce2 <spi_write>
  switch(command)
80009e2c:	30 08       	mov	r8,0
80009e2e:	f0 06 18 00 	cp.b	r6,r8
80009e32:	e0 80 00 ec 	breq	8000a00a <sd_mmc_spi_command+0x232>
80009e36:	30 88       	mov	r8,8
80009e38:	f0 06 18 00 	cp.b	r6,r8
80009e3c:	e0 80 00 ee 	breq	8000a018 <sd_mmc_spi_command+0x240>
         break;
      case MMC_SEND_IF_COND:
         spi_write(SD_MMC_SPI, 0x87);
         break;
      default:
         spi_write(SD_MMC_SPI, 0xff);
80009e40:	e0 6b 00 ff 	mov	r11,255
80009e44:	fe 7c 24 00 	mov	r12,-56320
80009e48:	e0 a0 0f 4d 	rcall	8000bce2 <spi_write>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80009e4c:	e0 6b 00 ff 	mov	r11,255

  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
80009e50:	e0 67 0c e4 	mov	r7,3300
80009e54:	3f f5       	mov	r5,-1
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80009e56:	fe 7c 24 00 	mov	r12,-56320

  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
80009e5a:	ae 85       	st.b	r7[0x0],r5
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80009e5c:	e0 a0 0f 43 	rcall	8000bce2 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80009e60:	fa c6 ff fe 	sub	r6,sp,-2
80009e64:	fe 7c 24 00 	mov	r12,-56320
80009e68:	0c 9b       	mov	r11,r6
80009e6a:	e0 a0 0f 4a 	rcall	8000bcfe <spi_read>
80009e6e:	58 1c       	cp.w	r12,1
80009e70:	e0 80 00 db 	breq	8000a026 <sd_mmc_spi_command+0x24e>
     return 0xFF;
   return data_read;
80009e74:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80009e76:	ae 8c       	st.b	r7[0x0],r12
80009e78:	ea 0c 18 00 	cp.b	r12,r5
80009e7c:	e0 81 00 c4 	brne	8000a004 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80009e80:	e0 6b 00 ff 	mov	r11,255
80009e84:	fe 7c 24 00 	mov	r12,-56320
80009e88:	e0 a0 0f 2d 	rcall	8000bce2 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80009e8c:	0c 9b       	mov	r11,r6
80009e8e:	fe 7c 24 00 	mov	r12,-56320
80009e92:	e0 a0 0f 36 	rcall	8000bcfe <spi_read>
80009e96:	58 1c       	cp.w	r12,1
80009e98:	e0 80 00 c9 	breq	8000a02a <sd_mmc_spi_command+0x252>
     return 0xFF;
   return data_read;
80009e9c:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80009e9e:	ae 8c       	st.b	r7[0x0],r12
80009ea0:	3f f8       	mov	r8,-1
80009ea2:	f0 0c 18 00 	cp.b	r12,r8
80009ea6:	e0 81 00 af 	brne	8000a004 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80009eaa:	e0 6b 00 ff 	mov	r11,255
80009eae:	fe 7c 24 00 	mov	r12,-56320
80009eb2:	e0 a0 0f 18 	rcall	8000bce2 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80009eb6:	0c 9b       	mov	r11,r6
80009eb8:	fe 7c 24 00 	mov	r12,-56320
80009ebc:	e0 a0 0f 21 	rcall	8000bcfe <spi_read>
80009ec0:	58 1c       	cp.w	r12,1
80009ec2:	e0 80 00 b7 	breq	8000a030 <sd_mmc_spi_command+0x258>
     return 0xFF;
   return data_read;
80009ec6:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80009ec8:	ae 8c       	st.b	r7[0x0],r12
80009eca:	3f f8       	mov	r8,-1
80009ecc:	f0 0c 18 00 	cp.b	r12,r8
80009ed0:	e0 81 00 9a 	brne	8000a004 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80009ed4:	e0 6b 00 ff 	mov	r11,255
80009ed8:	fe 7c 24 00 	mov	r12,-56320
80009edc:	e0 a0 0f 03 	rcall	8000bce2 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80009ee0:	0c 9b       	mov	r11,r6
80009ee2:	fe 7c 24 00 	mov	r12,-56320
80009ee6:	e0 a0 0f 0c 	rcall	8000bcfe <spi_read>
80009eea:	58 1c       	cp.w	r12,1
80009eec:	e0 80 00 a5 	breq	8000a036 <sd_mmc_spi_command+0x25e>
     return 0xFF;
   return data_read;
80009ef0:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80009ef2:	ae 8c       	st.b	r7[0x0],r12
80009ef4:	3f f8       	mov	r8,-1
80009ef6:	f0 0c 18 00 	cp.b	r12,r8
80009efa:	e0 81 00 85 	brne	8000a004 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80009efe:	e0 6b 00 ff 	mov	r11,255
80009f02:	fe 7c 24 00 	mov	r12,-56320
80009f06:	e0 a0 0e ee 	rcall	8000bce2 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80009f0a:	0c 9b       	mov	r11,r6
80009f0c:	fe 7c 24 00 	mov	r12,-56320
80009f10:	e0 a0 0e f7 	rcall	8000bcfe <spi_read>
80009f14:	58 1c       	cp.w	r12,1
80009f16:	e0 80 00 93 	breq	8000a03c <sd_mmc_spi_command+0x264>
     return 0xFF;
   return data_read;
80009f1a:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80009f1c:	ae 8c       	st.b	r7[0x0],r12
80009f1e:	3f f8       	mov	r8,-1
80009f20:	f0 0c 18 00 	cp.b	r12,r8
80009f24:	c7 01       	brne	8000a004 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80009f26:	e0 6b 00 ff 	mov	r11,255
80009f2a:	fe 7c 24 00 	mov	r12,-56320
80009f2e:	e0 a0 0e da 	rcall	8000bce2 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80009f32:	0c 9b       	mov	r11,r6
80009f34:	fe 7c 24 00 	mov	r12,-56320
80009f38:	e0 a0 0e e3 	rcall	8000bcfe <spi_read>
80009f3c:	58 1c       	cp.w	r12,1
80009f3e:	e0 80 00 82 	breq	8000a042 <sd_mmc_spi_command+0x26a>
     return 0xFF;
   return data_read;
80009f42:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80009f44:	ae 8c       	st.b	r7[0x0],r12
80009f46:	3f f8       	mov	r8,-1
80009f48:	f0 0c 18 00 	cp.b	r12,r8
80009f4c:	c5 c1       	brne	8000a004 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80009f4e:	e0 6b 00 ff 	mov	r11,255
80009f52:	fe 7c 24 00 	mov	r12,-56320
80009f56:	e0 a0 0e c6 	rcall	8000bce2 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80009f5a:	0c 9b       	mov	r11,r6
80009f5c:	fe 7c 24 00 	mov	r12,-56320
80009f60:	e0 a0 0e cf 	rcall	8000bcfe <spi_read>
80009f64:	58 1c       	cp.w	r12,1
80009f66:	c7 10       	breq	8000a048 <sd_mmc_spi_command+0x270>
     return 0xFF;
   return data_read;
80009f68:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80009f6a:	ae 8c       	st.b	r7[0x0],r12
80009f6c:	3f f8       	mov	r8,-1
80009f6e:	f0 0c 18 00 	cp.b	r12,r8
80009f72:	c4 91       	brne	8000a004 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80009f74:	e0 6b 00 ff 	mov	r11,255
80009f78:	fe 7c 24 00 	mov	r12,-56320
80009f7c:	e0 a0 0e b3 	rcall	8000bce2 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80009f80:	0c 9b       	mov	r11,r6
80009f82:	fe 7c 24 00 	mov	r12,-56320
80009f86:	e0 a0 0e bc 	rcall	8000bcfe <spi_read>
80009f8a:	58 1c       	cp.w	r12,1
80009f8c:	c6 10       	breq	8000a04e <sd_mmc_spi_command+0x276>
     return 0xFF;
   return data_read;
80009f8e:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80009f90:	ae 8c       	st.b	r7[0x0],r12
80009f92:	3f f8       	mov	r8,-1
80009f94:	f0 0c 18 00 	cp.b	r12,r8
80009f98:	c3 61       	brne	8000a004 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80009f9a:	e0 6b 00 ff 	mov	r11,255
80009f9e:	fe 7c 24 00 	mov	r12,-56320
80009fa2:	e0 a0 0e a0 	rcall	8000bce2 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80009fa6:	0c 9b       	mov	r11,r6
80009fa8:	fe 7c 24 00 	mov	r12,-56320
80009fac:	e0 a0 0e a9 	rcall	8000bcfe <spi_read>
80009fb0:	58 1c       	cp.w	r12,1
80009fb2:	c5 10       	breq	8000a054 <sd_mmc_spi_command+0x27c>
     return 0xFF;
   return data_read;
80009fb4:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80009fb6:	ae 8c       	st.b	r7[0x0],r12
80009fb8:	3f f8       	mov	r8,-1
80009fba:	f0 0c 18 00 	cp.b	r12,r8
80009fbe:	c2 31       	brne	8000a004 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80009fc0:	e0 6b 00 ff 	mov	r11,255
80009fc4:	fe 7c 24 00 	mov	r12,-56320
80009fc8:	e0 a0 0e 8d 	rcall	8000bce2 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80009fcc:	0c 9b       	mov	r11,r6
80009fce:	fe 7c 24 00 	mov	r12,-56320
80009fd2:	e0 a0 0e 96 	rcall	8000bcfe <spi_read>
80009fd6:	58 1c       	cp.w	r12,1
80009fd8:	c4 10       	breq	8000a05a <sd_mmc_spi_command+0x282>
     return 0xFF;
   return data_read;
80009fda:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80009fdc:	ae 8c       	st.b	r7[0x0],r12
80009fde:	3f f8       	mov	r8,-1
80009fe0:	f0 0c 18 00 	cp.b	r12,r8
80009fe4:	c1 01       	brne	8000a004 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80009fe6:	e0 6b 00 ff 	mov	r11,255
80009fea:	fe 7c 24 00 	mov	r12,-56320
80009fee:	e0 a0 0e 7a 	rcall	8000bce2 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80009ff2:	0c 9b       	mov	r11,r6
80009ff4:	fe 7c 24 00 	mov	r12,-56320
80009ff8:	e0 a0 0e 83 	rcall	8000bcfe <spi_read>
80009ffc:	58 1c       	cp.w	r12,1
80009ffe:	c3 10       	breq	8000a060 <sd_mmc_spi_command+0x288>
     return 0xFF;
   return data_read;
8000a000:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
8000a002:	ae 8c       	st.b	r7[0x0],r12
  {
    retry++;
    if(retry > 10) break;
  }
  return r1;
}
8000a004:	2f fd       	sub	sp,-4
8000a006:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
  spi_write(SD_MMC_SPI, arg>>8 );
  spi_write(SD_MMC_SPI, arg    );
  switch(command)
  {
      case MMC_GO_IDLE_STATE:
         spi_write(SD_MMC_SPI, 0x95);
8000a00a:	e0 6b 00 95 	mov	r11,149
8000a00e:	fe 7c 24 00 	mov	r12,-56320
8000a012:	e0 a0 0e 68 	rcall	8000bce2 <spi_write>
         break;
8000a016:	c1 bb       	rjmp	80009e4c <sd_mmc_spi_command+0x74>
      case MMC_SEND_IF_COND:
         spi_write(SD_MMC_SPI, 0x87);
8000a018:	e0 6b 00 87 	mov	r11,135
8000a01c:	fe 7c 24 00 	mov	r12,-56320
8000a020:	e0 a0 0e 61 	rcall	8000bce2 <spi_write>
         break;
8000a024:	c1 4b       	rjmp	80009e4c <sd_mmc_spi_command+0x74>
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
8000a026:	ae 85       	st.b	r7[0x0],r5
8000a028:	c2 cb       	rjmp	80009e80 <sd_mmc_spi_command+0xa8>
8000a02a:	3f f8       	mov	r8,-1
8000a02c:	ae 88       	st.b	r7[0x0],r8
8000a02e:	c3 eb       	rjmp	80009eaa <sd_mmc_spi_command+0xd2>
8000a030:	3f f8       	mov	r8,-1
8000a032:	ae 88       	st.b	r7[0x0],r8
8000a034:	c5 0b       	rjmp	80009ed4 <sd_mmc_spi_command+0xfc>
8000a036:	3f f8       	mov	r8,-1
8000a038:	ae 88       	st.b	r7[0x0],r8
8000a03a:	c6 2b       	rjmp	80009efe <sd_mmc_spi_command+0x126>
8000a03c:	3f f8       	mov	r8,-1
8000a03e:	ae 88       	st.b	r7[0x0],r8
8000a040:	c7 3b       	rjmp	80009f26 <sd_mmc_spi_command+0x14e>
8000a042:	3f f8       	mov	r8,-1
8000a044:	ae 88       	st.b	r7[0x0],r8
8000a046:	c8 4b       	rjmp	80009f4e <sd_mmc_spi_command+0x176>
8000a048:	3f f8       	mov	r8,-1
8000a04a:	ae 88       	st.b	r7[0x0],r8
8000a04c:	c9 4b       	rjmp	80009f74 <sd_mmc_spi_command+0x19c>
8000a04e:	3f f8       	mov	r8,-1
8000a050:	ae 88       	st.b	r7[0x0],r8
8000a052:	ca 4b       	rjmp	80009f9a <sd_mmc_spi_command+0x1c2>
8000a054:	3f f8       	mov	r8,-1
8000a056:	ae 88       	st.b	r7[0x0],r8
8000a058:	cb 4b       	rjmp	80009fc0 <sd_mmc_spi_command+0x1e8>
8000a05a:	3f f8       	mov	r8,-1
8000a05c:	ae 88       	st.b	r7[0x0],r8
8000a05e:	cc 4b       	rjmp	80009fe6 <sd_mmc_spi_command+0x20e>
8000a060:	3f f8       	mov	r8,-1
8000a062:	e0 6c 00 ff 	mov	r12,255
8000a066:	ae 88       	st.b	r7[0x0],r8
  {
    retry++;
    if(retry > 10) break;
  }
  return r1;
}
8000a068:	2f fd       	sub	sp,-4
8000a06a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000a06e:	d7 03       	nop

8000a070 <sd_mmc_spi_check_presence>:
8000a070:	eb cd 40 e0 	pushm	r5-r7,lr
8000a074:	e0 67 09 84 	mov	r7,2436
8000a078:	30 06       	mov	r6,0
8000a07a:	0f 88       	ld.ub	r8,r7[0x0]
bool sd_mmc_spi_check_presence(void)
{
  uint16_t retry;

  retry = 0;
  if (sd_mmc_spi_init_done == false)
8000a07c:	ec 08 18 00 	cp.b	r8,r6
8000a080:	e0 81 01 25 	brne	8000a2ca <sd_mmc_spi_check_presence+0x25a>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000a084:	30 1b       	mov	r11,1
8000a086:	fe 7c 24 00 	mov	r12,-56320
8000a08a:	e0 a0 0d 98 	rcall	8000bbba <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
8000a08e:	30 0b       	mov	r11,0
8000a090:	16 9c       	mov	r12,r11
8000a092:	ca 3e       	rcall	80009dd8 <sd_mmc_spi_command>
8000a094:	30 1b       	mov	r11,1
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a096:	e0 67 0c e4 	mov	r7,3300
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000a09a:	ae 8c       	st.b	r7[0x0],r12
8000a09c:	fe 7c 24 00 	mov	r12,-56320
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a0a0:	e0 a0 0d b5 	rcall	8000bc0a <spi_unselectChip>
8000a0a4:	0f 88       	ld.ub	r8,r7[0x0]
  return r1;
8000a0a6:	ae 88       	st.b	r7[0x0],r8
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
8000a0a8:	30 16       	mov	r6,1
8000a0aa:	ec 08 18 00 	cp.b	r8,r6
8000a0ae:	e0 80 01 23 	breq	8000a2f4 <sd_mmc_spi_check_presence+0x284>
8000a0b2:	e0 6b 00 ff 	mov	r11,255
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000a0b6:	fe 7c 24 00 	mov	r12,-56320
8000a0ba:	e0 a0 0e 14 	rcall	8000bce2 <spi_write>
8000a0be:	30 1b       	mov	r11,1
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000a0c0:	fe 7c 24 00 	mov	r12,-56320
8000a0c4:	e0 a0 0d 7b 	rcall	8000bbba <spi_selectChip>
8000a0c8:	30 0b       	mov	r11,0
  r1 = sd_mmc_spi_command(command, arg);
8000a0ca:	16 9c       	mov	r12,r11
8000a0cc:	c8 6e       	rcall	80009dd8 <sd_mmc_spi_command>
8000a0ce:	30 1b       	mov	r11,1
8000a0d0:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a0d2:	fe 7c 24 00 	mov	r12,-56320
8000a0d6:	e0 a0 0d 9a 	rcall	8000bc0a <spi_unselectChip>
8000a0da:	0f 88       	ld.ub	r8,r7[0x0]
8000a0dc:	ae 88       	st.b	r7[0x0],r8
  return r1;
8000a0de:	ec 08 18 00 	cp.b	r8,r6
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
8000a0e2:	e0 80 01 09 	breq	8000a2f4 <sd_mmc_spi_check_presence+0x284>
8000a0e6:	e0 6b 00 ff 	mov	r11,255
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000a0ea:	fe 7c 24 00 	mov	r12,-56320
8000a0ee:	e0 a0 0d fa 	rcall	8000bce2 <spi_write>
8000a0f2:	30 1b       	mov	r11,1
8000a0f4:	fe 7c 24 00 	mov	r12,-56320
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000a0f8:	e0 a0 0d 61 	rcall	8000bbba <spi_selectChip>
8000a0fc:	30 0b       	mov	r11,0
8000a0fe:	16 9c       	mov	r12,r11
  r1 = sd_mmc_spi_command(command, arg);
8000a100:	c6 ce       	rcall	80009dd8 <sd_mmc_spi_command>
8000a102:	30 1b       	mov	r11,1
8000a104:	ae 8c       	st.b	r7[0x0],r12
8000a106:	fe 7c 24 00 	mov	r12,-56320
8000a10a:	e0 a0 0d 80 	rcall	8000bc0a <spi_unselectChip>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a10e:	0f 88       	ld.ub	r8,r7[0x0]
8000a110:	ae 88       	st.b	r7[0x0],r8
8000a112:	ec 08 18 00 	cp.b	r8,r6
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
8000a116:	e0 80 00 ef 	breq	8000a2f4 <sd_mmc_spi_check_presence+0x284>
8000a11a:	e0 6b 00 ff 	mov	r11,255
8000a11e:	fe 7c 24 00 	mov	r12,-56320
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000a122:	e0 a0 0d e0 	rcall	8000bce2 <spi_write>
8000a126:	30 1b       	mov	r11,1
8000a128:	fe 7c 24 00 	mov	r12,-56320
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000a12c:	e0 a0 0d 47 	rcall	8000bbba <spi_selectChip>
8000a130:	30 0b       	mov	r11,0
8000a132:	16 9c       	mov	r12,r11
8000a134:	c5 2e       	rcall	80009dd8 <sd_mmc_spi_command>
  r1 = sd_mmc_spi_command(command, arg);
8000a136:	30 1b       	mov	r11,1
8000a138:	ae 8c       	st.b	r7[0x0],r12
8000a13a:	fe 7c 24 00 	mov	r12,-56320
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a13e:	e0 a0 0d 66 	rcall	8000bc0a <spi_unselectChip>
8000a142:	0f 88       	ld.ub	r8,r7[0x0]
8000a144:	ae 88       	st.b	r7[0x0],r8
8000a146:	ec 08 18 00 	cp.b	r8,r6
  return r1;
8000a14a:	e0 80 00 d5 	breq	8000a2f4 <sd_mmc_spi_check_presence+0x284>
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
8000a14e:	e0 6b 00 ff 	mov	r11,255
8000a152:	fe 7c 24 00 	mov	r12,-56320
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000a156:	e0 a0 0d c6 	rcall	8000bce2 <spi_write>
8000a15a:	30 1b       	mov	r11,1
8000a15c:	fe 7c 24 00 	mov	r12,-56320
8000a160:	e0 a0 0d 2d 	rcall	8000bbba <spi_selectChip>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000a164:	30 0b       	mov	r11,0
8000a166:	16 9c       	mov	r12,r11
8000a168:	c3 8e       	rcall	80009dd8 <sd_mmc_spi_command>
8000a16a:	30 1b       	mov	r11,1
  r1 = sd_mmc_spi_command(command, arg);
8000a16c:	ae 8c       	st.b	r7[0x0],r12
8000a16e:	fe 7c 24 00 	mov	r12,-56320
8000a172:	e0 a0 0d 4c 	rcall	8000bc0a <spi_unselectChip>
8000a176:	0f 88       	ld.ub	r8,r7[0x0]
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a178:	ae 88       	st.b	r7[0x0],r8
8000a17a:	ec 08 18 00 	cp.b	r8,r6
8000a17e:	e0 80 00 bb 	breq	8000a2f4 <sd_mmc_spi_check_presence+0x284>
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
8000a182:	e0 6b 00 ff 	mov	r11,255
8000a186:	fe 7c 24 00 	mov	r12,-56320
8000a18a:	e0 a0 0d ac 	rcall	8000bce2 <spi_write>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000a18e:	30 1b       	mov	r11,1
8000a190:	fe 7c 24 00 	mov	r12,-56320
8000a194:	e0 a0 0d 13 	rcall	8000bbba <spi_selectChip>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000a198:	30 0b       	mov	r11,0
8000a19a:	16 9c       	mov	r12,r11
8000a19c:	c1 ee       	rcall	80009dd8 <sd_mmc_spi_command>
8000a19e:	30 1b       	mov	r11,1
8000a1a0:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_command(command, arg);
8000a1a2:	fe 7c 24 00 	mov	r12,-56320
8000a1a6:	e0 a0 0d 32 	rcall	8000bc0a <spi_unselectChip>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a1aa:	0f 88       	ld.ub	r8,r7[0x0]
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000a1ac:	ae 88       	st.b	r7[0x0],r8
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a1ae:	ec 08 18 00 	cp.b	r8,r6
8000a1b2:	e0 80 00 a1 	breq	8000a2f4 <sd_mmc_spi_check_presence+0x284>
  return r1;
8000a1b6:	e0 6b 00 ff 	mov	r11,255
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
8000a1ba:	fe 7c 24 00 	mov	r12,-56320
8000a1be:	e0 a0 0d 92 	rcall	8000bce2 <spi_write>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000a1c2:	30 1b       	mov	r11,1
8000a1c4:	fe 7c 24 00 	mov	r12,-56320
8000a1c8:	e0 a0 0c f9 	rcall	8000bbba <spi_selectChip>
8000a1cc:	30 0b       	mov	r11,0
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000a1ce:	16 9c       	mov	r12,r11
8000a1d0:	c0 4e       	rcall	80009dd8 <sd_mmc_spi_command>
8000a1d2:	30 1b       	mov	r11,1
8000a1d4:	ae 8c       	st.b	r7[0x0],r12
8000a1d6:	fe 7c 24 00 	mov	r12,-56320
  r1 = sd_mmc_spi_command(command, arg);
8000a1da:	e0 a0 0d 18 	rcall	8000bc0a <spi_unselectChip>
8000a1de:	0f 88       	ld.ub	r8,r7[0x0]
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a1e0:	ae 88       	st.b	r7[0x0],r8
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000a1e2:	ec 08 18 00 	cp.b	r8,r6
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a1e6:	e0 80 00 87 	breq	8000a2f4 <sd_mmc_spi_check_presence+0x284>
8000a1ea:	e0 6b 00 ff 	mov	r11,255
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
8000a1ee:	fe 7c 24 00 	mov	r12,-56320
8000a1f2:	e0 a0 0d 78 	rcall	8000bce2 <spi_write>
8000a1f6:	30 1b       	mov	r11,1
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000a1f8:	fe 7c 24 00 	mov	r12,-56320
8000a1fc:	e0 a0 0c df 	rcall	8000bbba <spi_selectChip>
8000a200:	30 0b       	mov	r11,0
8000a202:	16 9c       	mov	r12,r11
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000a204:	fe b0 fd ea 	rcall	80009dd8 <sd_mmc_spi_command>
8000a208:	30 1b       	mov	r11,1
8000a20a:	ae 8c       	st.b	r7[0x0],r12
8000a20c:	fe 7c 24 00 	mov	r12,-56320
  r1 = sd_mmc_spi_command(command, arg);
8000a210:	e0 a0 0c fd 	rcall	8000bc0a <spi_unselectChip>
8000a214:	0f 88       	ld.ub	r8,r7[0x0]
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a216:	ae 88       	st.b	r7[0x0],r8
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000a218:	ec 08 18 00 	cp.b	r8,r6
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a21c:	c6 c0       	breq	8000a2f4 <sd_mmc_spi_check_presence+0x284>
8000a21e:	e0 6b 00 ff 	mov	r11,255
  return r1;
8000a222:	fe 7c 24 00 	mov	r12,-56320
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
8000a226:	e0 a0 0d 5e 	rcall	8000bce2 <spi_write>
8000a22a:	30 1b       	mov	r11,1
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000a22c:	fe 7c 24 00 	mov	r12,-56320
8000a230:	e0 a0 0c c5 	rcall	8000bbba <spi_selectChip>
8000a234:	30 0b       	mov	r11,0
8000a236:	16 9c       	mov	r12,r11
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000a238:	fe b0 fd d0 	rcall	80009dd8 <sd_mmc_spi_command>
8000a23c:	30 1b       	mov	r11,1
8000a23e:	ae 8c       	st.b	r7[0x0],r12
8000a240:	fe 7c 24 00 	mov	r12,-56320
  r1 = sd_mmc_spi_command(command, arg);
8000a244:	e0 a0 0c e3 	rcall	8000bc0a <spi_unselectChip>
8000a248:	0f 88       	ld.ub	r8,r7[0x0]
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a24a:	ae 88       	st.b	r7[0x0],r8
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000a24c:	ec 08 18 00 	cp.b	r8,r6
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a250:	c5 20       	breq	8000a2f4 <sd_mmc_spi_check_presence+0x284>
8000a252:	e0 6b 00 ff 	mov	r11,255
  return r1;
8000a256:	fe 7c 24 00 	mov	r12,-56320
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
8000a25a:	e0 a0 0d 44 	rcall	8000bce2 <spi_write>
8000a25e:	30 1b       	mov	r11,1
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000a260:	fe 7c 24 00 	mov	r12,-56320
8000a264:	e0 a0 0c ab 	rcall	8000bbba <spi_selectChip>
8000a268:	30 0b       	mov	r11,0
8000a26a:	16 9c       	mov	r12,r11
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000a26c:	fe b0 fd b6 	rcall	80009dd8 <sd_mmc_spi_command>
8000a270:	30 1b       	mov	r11,1
8000a272:	ae 8c       	st.b	r7[0x0],r12
8000a274:	fe 7c 24 00 	mov	r12,-56320
  r1 = sd_mmc_spi_command(command, arg);
8000a278:	e0 a0 0c c9 	rcall	8000bc0a <spi_unselectChip>
8000a27c:	0f 88       	ld.ub	r8,r7[0x0]
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a27e:	ae 88       	st.b	r7[0x0],r8
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000a280:	ec 08 18 00 	cp.b	r8,r6
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a284:	c3 80       	breq	8000a2f4 <sd_mmc_spi_check_presence+0x284>
8000a286:	e0 6b 00 ff 	mov	r11,255
  return r1;
8000a28a:	fe 7c 24 00 	mov	r12,-56320
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
8000a28e:	e0 a0 0d 2a 	rcall	8000bce2 <spi_write>
8000a292:	30 1b       	mov	r11,1
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000a294:	fe 7c 24 00 	mov	r12,-56320
8000a298:	e0 a0 0c 91 	rcall	8000bbba <spi_selectChip>
8000a29c:	30 0b       	mov	r11,0
8000a29e:	16 9c       	mov	r12,r11
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000a2a0:	fe b0 fd 9c 	rcall	80009dd8 <sd_mmc_spi_command>
8000a2a4:	30 1b       	mov	r11,1
8000a2a6:	ae 8c       	st.b	r7[0x0],r12
8000a2a8:	fe 7c 24 00 	mov	r12,-56320
  r1 = sd_mmc_spi_command(command, arg);
8000a2ac:	e0 a0 0c af 	rcall	8000bc0a <spi_unselectChip>
8000a2b0:	0f 88       	ld.ub	r8,r7[0x0]
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a2b2:	ae 88       	st.b	r7[0x0],r8
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000a2b4:	ec 08 18 00 	cp.b	r8,r6
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a2b8:	c1 e0       	breq	8000a2f4 <sd_mmc_spi_check_presence+0x284>
8000a2ba:	e0 6b 00 ff 	mov	r11,255
  return r1;
8000a2be:	fe 7c 24 00 	mov	r12,-56320
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
8000a2c2:	e0 a0 0d 10 	rcall	8000bce2 <spi_write>
8000a2c6:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000a2ca:	30 1b       	mov	r11,1
8000a2cc:	fe 7c 24 00 	mov	r12,-56320
8000a2d0:	e0 a0 0c 75 	rcall	8000bbba <spi_selectChip>
8000a2d4:	30 0b       	mov	r11,0
8000a2d6:	33 bc       	mov	r12,59
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000a2d8:	fe b0 fd 80 	rcall	80009dd8 <sd_mmc_spi_command>
8000a2dc:	e0 65 0c e4 	mov	r5,3300
8000a2e0:	30 1b       	mov	r11,1
  r1 = sd_mmc_spi_command(command, arg);
8000a2e2:	aa 8c       	st.b	r5[0x0],r12
8000a2e4:	fe 7c 24 00 	mov	r12,-56320
8000a2e8:	e0 a0 0c 91 	rcall	8000bc0a <spi_unselectChip>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a2ec:	0b 88       	ld.ub	r8,r5[0x0]
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000a2ee:	aa 88       	st.b	r5[0x0],r8
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a2f0:	58 08       	cp.w	r8,0
8000a2f2:	c0 31       	brne	8000a2f8 <sd_mmc_spi_check_presence+0x288>
8000a2f4:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
  return r1;
8000a2f8:	ae 86       	st.b	r7[0x0],r6
    return true;
  }
  else
  {
    // If memory already initialized, send a CRC command (CMD59) (supported only if card is initialized)
    if ((r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0)) == 0x00)
8000a2fa:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
8000a2fe:	d7 03       	nop

8000a300 <sd_mmc_spi_write_open>:
      return true;
    sd_mmc_spi_init_done = false;
    return false;
8000a300:	d4 21       	pushm	r4-r7,lr
8000a302:	20 1d       	sub	sp,4
  else
  {
    // If memory already initialized, send a CRC command (CMD59) (supported only if card is initialized)
    if ((r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0)) == 0x00)
      return true;
    sd_mmc_spi_init_done = false;
8000a304:	e0 68 09 6c 	mov	r8,2412
8000a308:	a9 7c       	lsl	r12,0x9
8000a30a:	30 1b       	mov	r11,1
8000a30c:	91 0c       	st.w	r8[0x0],r12
8000a30e:	fa c6 ff fe 	sub	r6,sp,-2
8000a312:	fe 7c 24 00 	mov	r12,-56320
8000a316:	e0 65 0c e4 	mov	r5,3300
8000a31a:	e0 a0 0c 50 	rcall	8000bbba <spi_selectChip>
8000a31e:	3f f4       	mov	r4,-1
8000a320:	30 07       	mov	r7,0
8000a322:	c0 98       	rjmp	8000a334 <sd_mmc_spi_write_open+0x34>
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
8000a324:	1b b8       	ld.ub	r8,sp[0x3]
8000a326:	aa 88       	st.b	r5[0x0],r8
8000a328:	e8 08 18 00 	cp.b	r8,r4
  {
    retry++;
    if (retry == 200000)
8000a32c:	c1 40       	breq	8000a354 <sd_mmc_spi_write_open+0x54>
8000a32e:	e2 57 0d 40 	cp.w	r7,200000
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000a332:	c1 80       	breq	8000a362 <sd_mmc_spi_write_open+0x62>
8000a334:	e0 6b 00 ff 	mov	r11,255
8000a338:	fe 7c 24 00 	mov	r12,-56320
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000a33c:	e0 a0 0c d3 	rcall	8000bce2 <spi_write>
8000a340:	0c 9b       	mov	r11,r6
8000a342:	2f f7       	sub	r7,-1
8000a344:	fe 7c 24 00 	mov	r12,-56320
8000a348:	e0 a0 0c db 	rcall	8000bcfe <spi_read>
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
8000a34c:	58 1c       	cp.w	r12,1
8000a34e:	ce b1       	brne	8000a324 <sd_mmc_spi_write_open+0x24>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
      return false;
    }
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000a350:	3f f8       	mov	r8,-1
8000a352:	aa 88       	st.b	r5[0x0],r8
8000a354:	30 1b       	mov	r11,1
8000a356:	fe 7c 24 00 	mov	r12,-56320
8000a35a:	e0 a0 0c 58 	rcall	8000bc0a <spi_unselectChip>
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
  {
    retry++;
    if (retry == 200000)
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000a35e:	2f fd       	sub	sp,-4
8000a360:	da 2a       	popm	r4-r7,pc,r12=1
8000a362:	30 1b       	mov	r11,1
8000a364:	fe 7c 24 00 	mov	r12,-56320
8000a368:	e0 a0 0c 51 	rcall	8000bc0a <spi_unselectChip>
8000a36c:	2f fd       	sub	sp,-4
8000a36e:	d8 2a       	popm	r4-r7,pc,r12=0

8000a370 <sd_mmc_spi_read_close>:
8000a370:	d4 21       	pushm	r4-r7,lr
8000a372:	20 1d       	sub	sp,4
8000a374:	30 1b       	mov	r11,1
8000a376:	fe 7c 24 00 	mov	r12,-56320
8000a37a:	fa c6 ff fe 	sub	r6,sp,-2
8000a37e:	e0 a0 0c 1e 	rcall	8000bbba <spi_selectChip>
8000a382:	e0 65 0c e4 	mov	r5,3300
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
8000a386:	30 07       	mov	r7,0
8000a388:	3f f4       	mov	r4,-1
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
     return 0xFF;
   return data_read;
8000a38a:	c0 98       	rjmp	8000a39c <sd_mmc_spi_read_close+0x2c>
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
8000a38c:	1b b8       	ld.ub	r8,sp[0x3]
8000a38e:	aa 88       	st.b	r5[0x0],r8
8000a390:	e8 08 18 00 	cp.b	r8,r4
  {
    retry++;
    if (retry == 200000)
8000a394:	c1 40       	breq	8000a3bc <sd_mmc_spi_read_close+0x4c>
8000a396:	e2 57 0d 40 	cp.w	r7,200000
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000a39a:	c1 80       	breq	8000a3ca <sd_mmc_spi_read_close+0x5a>
8000a39c:	e0 6b 00 ff 	mov	r11,255
8000a3a0:	fe 7c 24 00 	mov	r12,-56320
8000a3a4:	e0 a0 0c 9f 	rcall	8000bce2 <spi_write>
bool sd_mmc_spi_wait_not_busy(void)
{
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000a3a8:	0c 9b       	mov	r11,r6
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000a3aa:	2f f7       	sub	r7,-1
8000a3ac:	fe 7c 24 00 	mov	r12,-56320
8000a3b0:	e0 a0 0c a7 	rcall	8000bcfe <spi_read>
8000a3b4:	58 1c       	cp.w	r12,1
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
8000a3b6:	ce b1       	brne	8000a38c <sd_mmc_spi_read_close+0x1c>
8000a3b8:	3f f8       	mov	r8,-1
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
      return false;
    }
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000a3ba:	aa 88       	st.b	r5[0x0],r8
8000a3bc:	30 1b       	mov	r11,1
8000a3be:	fe 7c 24 00 	mov	r12,-56320
8000a3c2:	e0 a0 0c 24 	rcall	8000bc0a <spi_unselectChip>
8000a3c6:	2f fd       	sub	sp,-4
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
  {
    retry++;
    if (retry == 200000)
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000a3c8:	da 2a       	popm	r4-r7,pc,r12=1
8000a3ca:	30 1b       	mov	r11,1
8000a3cc:	fe 7c 24 00 	mov	r12,-56320
8000a3d0:	e0 a0 0c 1d 	rcall	8000bc0a <spi_unselectChip>
8000a3d4:	2f fd       	sub	sp,-4
8000a3d6:	d8 2a       	popm	r4-r7,pc,r12=0

8000a3d8 <sd_mmc_spi_read_open>:
8000a3d8:	d4 21       	pushm	r4-r7,lr
8000a3da:	20 1d       	sub	sp,4
8000a3dc:	e0 68 09 6c 	mov	r8,2412
8000a3e0:	a9 7c       	lsl	r12,0x9
8000a3e2:	30 1b       	mov	r11,1
8000a3e4:	91 0c       	st.w	r8[0x0],r12
8000a3e6:	fa c6 ff fe 	sub	r6,sp,-2
8000a3ea:	fe 7c 24 00 	mov	r12,-56320
bool sd_mmc_spi_wait_not_busy(void)
{
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000a3ee:	e0 65 0c e4 	mov	r5,3300
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
8000a3f2:	e0 a0 0b e4 	rcall	8000bbba <spi_selectChip>
bool sd_mmc_spi_wait_not_busy(void)
{
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000a3f6:	3f f4       	mov	r4,-1
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
     return 0xFF;
   return data_read;
8000a3f8:	30 07       	mov	r7,0
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
8000a3fa:	c0 98       	rjmp	8000a40c <sd_mmc_spi_read_open+0x34>
8000a3fc:	1b b8       	ld.ub	r8,sp[0x3]
8000a3fe:	aa 88       	st.b	r5[0x0],r8
8000a400:	e8 08 18 00 	cp.b	r8,r4
  {
    retry++;
    if (retry == 200000)
8000a404:	c1 40       	breq	8000a42c <sd_mmc_spi_read_open+0x54>
8000a406:	e2 57 0d 40 	cp.w	r7,200000
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000a40a:	c1 80       	breq	8000a43a <sd_mmc_spi_read_open+0x62>
8000a40c:	e0 6b 00 ff 	mov	r11,255
8000a410:	fe 7c 24 00 	mov	r12,-56320
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000a414:	e0 a0 0c 67 	rcall	8000bce2 <spi_write>
8000a418:	0c 9b       	mov	r11,r6
8000a41a:	2f f7       	sub	r7,-1
8000a41c:	fe 7c 24 00 	mov	r12,-56320
8000a420:	e0 a0 0c 6f 	rcall	8000bcfe <spi_read>
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
8000a424:	58 1c       	cp.w	r12,1
8000a426:	ce b1       	brne	8000a3fc <sd_mmc_spi_read_open+0x24>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
      return false;
    }
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000a428:	3f f8       	mov	r8,-1
8000a42a:	aa 88       	st.b	r5[0x0],r8
8000a42c:	30 1b       	mov	r11,1
8000a42e:	fe 7c 24 00 	mov	r12,-56320
8000a432:	e0 a0 0b ec 	rcall	8000bc0a <spi_unselectChip>
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
  {
    retry++;
    if (retry == 200000)
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000a436:	2f fd       	sub	sp,-4
8000a438:	da 2a       	popm	r4-r7,pc,r12=1
8000a43a:	30 1b       	mov	r11,1
8000a43c:	fe 7c 24 00 	mov	r12,-56320
8000a440:	e0 a0 0b e5 	rcall	8000bc0a <spi_unselectChip>
8000a444:	2f fd       	sub	sp,-4
8000a446:	d8 2a       	popm	r4-r7,pc,r12=0

8000a448 <sd_mmc_spi_read_sector_to_ram>:
8000a448:	eb cd 40 fe 	pushm	r1-r7,lr
8000a44c:	20 1d       	sub	sp,4
8000a44e:	30 1b       	mov	r11,1
8000a450:	18 91       	mov	r1,r12
8000a452:	1a 95       	mov	r5,sp
8000a454:	fe 7c 24 00 	mov	r12,-56320
8000a458:	e0 66 0c e4 	mov	r6,3300
bool sd_mmc_spi_wait_not_busy(void)
{
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000a45c:	e0 a0 0b af 	rcall	8000bbba <spi_selectChip>
8000a460:	3f f4       	mov	r4,-1
8000a462:	30 07       	mov	r7,0
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
     return 0xFF;
   return data_read;
8000a464:	c0 98       	rjmp	8000a476 <sd_mmc_spi_read_sector_to_ram+0x2e>
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
8000a466:	1b 98       	ld.ub	r8,sp[0x1]
8000a468:	ac 88       	st.b	r6[0x0],r8
8000a46a:	e8 08 18 00 	cp.b	r8,r4
  {
    retry++;
    if (retry == 200000)
8000a46e:	c1 40       	breq	8000a496 <sd_mmc_spi_read_sector_to_ram+0x4e>
8000a470:	e2 57 0d 40 	cp.w	r7,200000
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000a474:	c5 00       	breq	8000a514 <sd_mmc_spi_read_sector_to_ram+0xcc>
8000a476:	e0 6b 00 ff 	mov	r11,255
8000a47a:	fe 7c 24 00 	mov	r12,-56320
8000a47e:	e0 a0 0c 32 	rcall	8000bce2 <spi_write>
bool sd_mmc_spi_wait_not_busy(void)
{
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000a482:	1a 9b       	mov	r11,sp
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000a484:	2f f7       	sub	r7,-1
8000a486:	fe 7c 24 00 	mov	r12,-56320
8000a48a:	e0 a0 0c 3a 	rcall	8000bcfe <spi_read>
8000a48e:	58 1c       	cp.w	r12,1
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
8000a490:	ce b1       	brne	8000a466 <sd_mmc_spi_read_sector_to_ram+0x1e>
8000a492:	3f f8       	mov	r8,-1
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
      return false;
    }
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000a494:	ac 88       	st.b	r6[0x0],r8
8000a496:	30 1b       	mov	r11,1
8000a498:	fe 7c 24 00 	mov	r12,-56320
8000a49c:	e0 a0 0b b7 	rcall	8000bc0a <spi_unselectChip>
  unsigned short data_read;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000a4a0:	30 1b       	mov	r11,1
8000a4a2:	fe 7c 24 00 	mov	r12,-56320
8000a4a6:	e0 a0 0b 8a 	rcall	8000bbba <spi_selectChip>

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
8000a4aa:	e0 68 0c d2 	mov	r8,3282
8000a4ae:	11 89       	ld.ub	r9,r8[0x0]
8000a4b0:	30 38       	mov	r8,3
8000a4b2:	f0 09 18 00 	cp.b	r9,r8
    r1 = sd_mmc_spi_command(MMC_READ_SINGLE_BLOCK, gl_ptr_mem>>9);
  } else {
    r1 = sd_mmc_spi_command(MMC_READ_SINGLE_BLOCK, gl_ptr_mem);
8000a4b6:	c6 f0       	breq	8000a594 <sd_mmc_spi_read_sector_to_ram+0x14c>
8000a4b8:	e0 62 09 6c 	mov	r2,2412
8000a4bc:	31 1c       	mov	r12,17
8000a4be:	64 0b       	ld.w	r11,r2[0x0]
  }

  // check for valid response
  if (r1 != 0x00)
8000a4c0:	fe b0 fc 8c 	rcall	80009dd8 <sd_mmc_spi_command>
  {
     read_time_out--;
     if (read_time_out == 0)   // TIME-OUT
     {
       spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS); // unselect SD_MMC_SPI
       return false;
8000a4c4:	ac 8c       	st.b	r6[0x0],r12
    return false;
  }

  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
8000a4c6:	58 0c       	cp.w	r12,0
8000a4c8:	c2 61       	brne	8000a514 <sd_mmc_spi_read_sector_to_ram+0xcc>
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
     return 0xFF;
   return data_read;
8000a4ca:	18 94       	mov	r4,r12
    return false;
  }

  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
8000a4cc:	3f f3       	mov	r3,-1
8000a4ce:	c0 a8       	rjmp	8000a4e2 <sd_mmc_spi_read_sector_to_ram+0x9a>
8000a4d0:	1b 98       	ld.ub	r8,sp[0x1]
8000a4d2:	ac 88       	st.b	r6[0x0],r8

  // check for valid response
  if (r1 != 0x00)
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return false;
8000a4d4:	e6 08 18 00 	cp.b	r8,r3
  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
  {
     read_time_out--;
     if (read_time_out == 0)   // TIME-OUT
8000a4d8:	c1 41       	brne	8000a500 <sd_mmc_spi_read_sector_to_ram+0xb8>
8000a4da:	2f f4       	sub	r4,-1
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000a4dc:	e0 44 75 30 	cp.w	r4,30000
8000a4e0:	c1 a0       	breq	8000a514 <sd_mmc_spi_read_sector_to_ram+0xcc>
8000a4e2:	e0 6b 00 ff 	mov	r11,255
8000a4e6:	fe 7c 24 00 	mov	r12,-56320
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000a4ea:	e0 a0 0b fc 	rcall	8000bce2 <spi_write>
8000a4ee:	1a 9b       	mov	r11,sp
8000a4f0:	fe 7c 24 00 	mov	r12,-56320
8000a4f4:	e0 a0 0c 05 	rcall	8000bcfe <spi_read>
    return false;
  }

  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
8000a4f8:	58 1c       	cp.w	r12,1
       return false;
     }
  }

  // check token
  if (r1 != MMC_STARTBLOCK_READ)
8000a4fa:	ce b1       	brne	8000a4d0 <sd_mmc_spi_read_sector_to_ram+0x88>
8000a4fc:	ac 83       	st.b	r6[0x0],r3
8000a4fe:	ce eb       	rjmp	8000a4da <sd_mmc_spi_read_sector_to_ram+0x92>
8000a500:	3f e9       	mov	r9,-2
  {
    spi_write(SD_MMC_SPI,0xFF);
8000a502:	f2 08 18 00 	cp.b	r8,r9
8000a506:	c0 f0       	breq	8000a524 <sd_mmc_spi_read_sector_to_ram+0xdc>
8000a508:	e0 6b 00 ff 	mov	r11,255
8000a50c:	fe 7c 24 00 	mov	r12,-56320
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a510:	e0 a0 0b e9 	rcall	8000bce2 <spi_write>
8000a514:	30 1b       	mov	r11,1
8000a516:	fe 7c 24 00 	mov	r12,-56320
8000a51a:	e0 a0 0b 78 	rcall	8000bc0a <spi_unselectChip>
//!   The read succeeded   -> true
//!   The read failed (bad address, etc.)  -> false
//!/
bool sd_mmc_spi_read_sector_to_ram(void *ram)
{
  uint8_t *_ram = ram;
8000a51e:	2f fd       	sub	sp,-4
8000a520:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
//!
//! @return bit
//!   The read succeeded   -> true
//!   The read failed (bad address, etc.)  -> false
//!/
bool sd_mmc_spi_read_sector_to_ram(void *ram)
8000a524:	02 97       	mov	r7,r1
8000a526:	fa c5 ff fe 	sub	r5,sp,-2
  }

  // store datablock
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,0xFF);
8000a52a:	e2 c6 fe 00 	sub	r6,r1,-512
8000a52e:	e0 6b 00 ff 	mov	r11,255
8000a532:	fe 7c 24 00 	mov	r12,-56320
    spi_read(SD_MMC_SPI,&data_read);
8000a536:	e0 a0 0b d6 	rcall	8000bce2 <spi_write>
8000a53a:	0a 9b       	mov	r11,r5
8000a53c:	fe 7c 24 00 	mov	r12,-56320
    *_ram++=data_read;
8000a540:	e0 a0 0b df 	rcall	8000bcfe <spi_read>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return false;
  }

  // store datablock
  for(i=0;i<MMC_SECTOR_SIZE;i++)
8000a544:	9a 18       	ld.sh	r8,sp[0x2]
  {
    spi_write(SD_MMC_SPI,0xFF);
    spi_read(SD_MMC_SPI,&data_read);
    *_ram++=data_read;
  }
  gl_ptr_mem += 512;     // Update the memory pointer.
8000a546:	0e c8       	st.b	r7++,r8
8000a548:	0c 37       	cp.w	r7,r6
8000a54a:	cf 21       	brne	8000a52e <sd_mmc_spi_read_sector_to_ram+0xe6>

  // load 16-bit CRC (ignored)
  spi_write(SD_MMC_SPI,0xFF);
8000a54c:	64 08       	ld.w	r8,r2[0x0]
8000a54e:	f0 c8 fe 00 	sub	r8,r8,-512
8000a552:	e0 6b 00 ff 	mov	r11,255
8000a556:	85 08       	st.w	r2[0x0],r8
8000a558:	fe 7c 24 00 	mov	r12,-56320
  spi_write(SD_MMC_SPI,0xFF);
8000a55c:	e0 a0 0b c3 	rcall	8000bce2 <spi_write>
8000a560:	e0 6b 00 ff 	mov	r11,255
8000a564:	fe 7c 24 00 	mov	r12,-56320

  // continue delivering some clock cycles
  spi_write(SD_MMC_SPI,0xFF);
8000a568:	e0 a0 0b bd 	rcall	8000bce2 <spi_write>
8000a56c:	e0 6b 00 ff 	mov	r11,255
8000a570:	fe 7c 24 00 	mov	r12,-56320
  spi_write(SD_MMC_SPI,0xFF);
8000a574:	e0 a0 0b b7 	rcall	8000bce2 <spi_write>
8000a578:	e0 6b 00 ff 	mov	r11,255
8000a57c:	fe 7c 24 00 	mov	r12,-56320

  // release chip select
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a580:	e0 a0 0b b1 	rcall	8000bce2 <spi_write>
8000a584:	30 1b       	mov	r11,1
8000a586:	fe 7c 24 00 	mov	r12,-56320
8000a58a:	e0 a0 0b 40 	rcall	8000bc0a <spi_unselectChip>

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
    r1 = sd_mmc_spi_command(MMC_READ_SINGLE_BLOCK, gl_ptr_mem>>9);
8000a58e:	2f fd       	sub	sp,-4
8000a590:	e3 cf 90 fe 	ldm	sp++,r1-r7,pc,r12=1
8000a594:	e0 62 09 6c 	mov	r2,2412
8000a598:	31 1c       	mov	r12,17
8000a59a:	64 0b       	ld.w	r11,r2[0x0]
8000a59c:	a9 9b       	lsr	r11,0x9
8000a59e:	fe b0 fc 1d 	rcall	80009dd8 <sd_mmc_spi_command>
8000a5a2:	ac 8c       	st.b	r6[0x0],r12
8000a5a4:	c9 1b       	rjmp	8000a4c6 <sd_mmc_spi_read_sector_to_ram+0x7e>
8000a5a6:	d7 03       	nop

8000a5a8 <sd_mmc_spi_check_hc>:
8000a5a8:	d4 21       	pushm	r4-r7,lr
8000a5aa:	20 1d       	sub	sp,4
8000a5ac:	30 1b       	mov	r11,1
8000a5ae:	fe 7c 24 00 	mov	r12,-56320
8000a5b2:	fa c5 ff fe 	sub	r5,sp,-2
8000a5b6:	e0 a0 0b 02 	rcall	8000bbba <spi_selectChip>
8000a5ba:	e0 66 0c e4 	mov	r6,3300
8000a5be:	30 07       	mov	r7,0
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
8000a5c0:	3f f4       	mov	r4,-1
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
     return 0xFF;
   return data_read;
8000a5c2:	c0 98       	rjmp	8000a5d4 <sd_mmc_spi_check_hc+0x2c>
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
8000a5c4:	1b b8       	ld.ub	r8,sp[0x3]
8000a5c6:	ac 88       	st.b	r6[0x0],r8
8000a5c8:	e8 08 18 00 	cp.b	r8,r4
  {
    retry++;
    if (retry == 200000)
8000a5cc:	c1 40       	breq	8000a5f4 <sd_mmc_spi_check_hc+0x4c>
8000a5ce:	e2 57 0d 40 	cp.w	r7,200000
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000a5d2:	c6 80       	breq	8000a6a2 <sd_mmc_spi_check_hc+0xfa>
8000a5d4:	e0 6b 00 ff 	mov	r11,255
8000a5d8:	fe 7c 24 00 	mov	r12,-56320
8000a5dc:	e0 a0 0b 83 	rcall	8000bce2 <spi_write>
bool sd_mmc_spi_wait_not_busy(void)
{
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000a5e0:	0a 9b       	mov	r11,r5
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000a5e2:	2f f7       	sub	r7,-1
8000a5e4:	fe 7c 24 00 	mov	r12,-56320
8000a5e8:	e0 a0 0b 8b 	rcall	8000bcfe <spi_read>
8000a5ec:	58 1c       	cp.w	r12,1
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
8000a5ee:	ce b1       	brne	8000a5c4 <sd_mmc_spi_check_hc+0x1c>
8000a5f0:	3f f8       	mov	r8,-1
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
      return false;
    }
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000a5f2:	ac 88       	st.b	r6[0x0],r8
8000a5f4:	30 1b       	mov	r11,1
8000a5f6:	fe 7c 24 00 	mov	r12,-56320
8000a5fa:	e0 a0 0b 08 	rcall	8000bc0a <spi_unselectChip>
  unsigned char hc_bit;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
    return SD_FAILURE;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000a5fe:	30 1b       	mov	r11,1
8000a600:	fe 7c 24 00 	mov	r12,-56320
8000a604:	e0 a0 0a db 	rcall	8000bbba <spi_selectChip>
  r1 = sd_mmc_spi_command(SD_READ_OCR, 0);
8000a608:	30 0b       	mov	r11,0
8000a60a:	33 ac       	mov	r12,58
8000a60c:	fe b0 fb e6 	rcall	80009dd8 <sd_mmc_spi_command>
  // check for valid response
  if(r1 != 0) {
8000a610:	ac 8c       	st.b	r6[0x0],r12
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000a612:	c4 81       	brne	8000a6a2 <sd_mmc_spi_check_hc+0xfa>
8000a614:	e0 6b 00 ff 	mov	r11,255
8000a618:	fe 7c 24 00 	mov	r12,-56320
8000a61c:	e0 a0 0b 63 	rcall	8000bce2 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000a620:	0a 9b       	mov	r11,r5
8000a622:	fe 7c 24 00 	mov	r12,-56320
8000a626:	e0 a0 0b 6c 	rcall	8000bcfe <spi_read>
8000a62a:	58 1c       	cp.w	r12,1
8000a62c:	c3 90       	breq	8000a69e <sd_mmc_spi_check_hc+0xf6>
8000a62e:	1b b7       	ld.ub	r7,sp[0x3]
8000a630:	ef d7 c0 c1 	bfextu	r7,r7,0x6,0x1
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000a634:	e0 6b 00 ff 	mov	r11,255
8000a638:	fe 7c 24 00 	mov	r12,-56320
8000a63c:	e0 a0 0b 53 	rcall	8000bce2 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000a640:	0a 9b       	mov	r11,r5
8000a642:	fe 7c 24 00 	mov	r12,-56320
8000a646:	e0 a0 0b 5c 	rcall	8000bcfe <spi_read>
8000a64a:	58 1c       	cp.w	r12,1
     return 0xFF;
   return data_read;
8000a64c:	c3 40       	breq	8000a6b4 <sd_mmc_spi_check_hc+0x10c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000a64e:	1b b8       	ld.ub	r8,sp[0x3]
8000a650:	e0 6b 00 ff 	mov	r11,255
8000a654:	ac 88       	st.b	r6[0x0],r8
8000a656:	fe 7c 24 00 	mov	r12,-56320
8000a65a:	e0 a0 0b 44 	rcall	8000bce2 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000a65e:	0a 9b       	mov	r11,r5
8000a660:	fe 7c 24 00 	mov	r12,-56320
8000a664:	e0 a0 0b 4d 	rcall	8000bcfe <spi_read>
8000a668:	58 1c       	cp.w	r12,1
     return 0xFF;
   return data_read;
8000a66a:	c2 b0       	breq	8000a6c0 <sd_mmc_spi_check_hc+0x118>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000a66c:	1b b8       	ld.ub	r8,sp[0x3]
8000a66e:	e0 6b 00 ff 	mov	r11,255
8000a672:	ac 88       	st.b	r6[0x0],r8
8000a674:	fe 7c 24 00 	mov	r12,-56320
8000a678:	e0 a0 0b 35 	rcall	8000bce2 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000a67c:	0a 9b       	mov	r11,r5
8000a67e:	fe 7c 24 00 	mov	r12,-56320
8000a682:	e0 a0 0b 3e 	rcall	8000bcfe <spi_read>
8000a686:	58 1c       	cp.w	r12,1
     return 0xFF;
   return data_read;
8000a688:	c1 90       	breq	8000a6ba <sd_mmc_spi_check_hc+0x112>
    return SD_FAILURE;
  }
  hc_bit = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
8000a68a:	1b b8       	ld.ub	r8,sp[0x3]
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a68c:	ac 88       	st.b	r6[0x0],r8
8000a68e:	30 1b       	mov	r11,1
8000a690:	fe 7c 24 00 	mov	r12,-56320
8000a694:	e0 a0 0a bb 	rcall	8000bc0a <spi_unselectChip>
  if(hc_bit & 0x40) {
      return SDHC_CARD;
  }
  return 0;
}
8000a698:	0e 9c       	mov	r12,r7
8000a69a:	2f fd       	sub	sp,-4
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000a69c:	d8 22       	popm	r4-r7,pc
8000a69e:	18 97       	mov	r7,r12

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(SD_READ_OCR, 0);
  // check for valid response
  if(r1 != 0) {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a6a0:	cc ab       	rjmp	8000a634 <sd_mmc_spi_check_hc+0x8c>
8000a6a2:	30 1b       	mov	r11,1
8000a6a4:	fe 7c 24 00 	mov	r12,-56320
8000a6a8:	e0 a0 0a b1 	rcall	8000bc0a <spi_unselectChip>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
  if(hc_bit & 0x40) {
      return SDHC_CARD;
  }
  return 0;
}
8000a6ac:	3f f7       	mov	r7,-1
8000a6ae:	0e 9c       	mov	r12,r7
8000a6b0:	2f fd       	sub	sp,-4
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000a6b2:	d8 22       	popm	r4-r7,pc
8000a6b4:	e0 68 00 ff 	mov	r8,255
8000a6b8:	cc cb       	rjmp	8000a650 <sd_mmc_spi_check_hc+0xa8>
8000a6ba:	e0 68 00 ff 	mov	r8,255
8000a6be:	ce 7b       	rjmp	8000a68c <sd_mmc_spi_check_hc+0xe4>
8000a6c0:	e0 68 00 ff 	mov	r8,255
8000a6c4:	cd 5b       	rjmp	8000a66e <sd_mmc_spi_check_hc+0xc6>
8000a6c6:	d7 03       	nop

8000a6c8 <sd_mmc_spi_get_if>:
8000a6c8:	d4 21       	pushm	r4-r7,lr
8000a6ca:	20 1d       	sub	sp,4
8000a6cc:	30 1b       	mov	r11,1
8000a6ce:	fe 7c 24 00 	mov	r12,-56320
8000a6d2:	fa c5 ff fe 	sub	r5,sp,-2
8000a6d6:	e0 a0 0a 72 	rcall	8000bbba <spi_selectChip>
8000a6da:	e0 66 0c e4 	mov	r6,3300
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
8000a6de:	30 07       	mov	r7,0
8000a6e0:	3f f4       	mov	r4,-1
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
     return 0xFF;
   return data_read;
8000a6e2:	c0 98       	rjmp	8000a6f4 <sd_mmc_spi_get_if+0x2c>
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
8000a6e4:	1b b8       	ld.ub	r8,sp[0x3]
8000a6e6:	ac 88       	st.b	r6[0x0],r8
8000a6e8:	e8 08 18 00 	cp.b	r8,r4
  {
    retry++;
    if (retry == 200000)
8000a6ec:	c1 40       	breq	8000a714 <sd_mmc_spi_get_if+0x4c>
8000a6ee:	e2 57 0d 40 	cp.w	r7,200000
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000a6f2:	c7 20       	breq	8000a7d6 <sd_mmc_spi_get_if+0x10e>
8000a6f4:	e0 6b 00 ff 	mov	r11,255
8000a6f8:	fe 7c 24 00 	mov	r12,-56320
8000a6fc:	e0 a0 0a f3 	rcall	8000bce2 <spi_write>
bool sd_mmc_spi_wait_not_busy(void)
{
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000a700:	0a 9b       	mov	r11,r5
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000a702:	2f f7       	sub	r7,-1
8000a704:	fe 7c 24 00 	mov	r12,-56320
8000a708:	e0 a0 0a fb 	rcall	8000bcfe <spi_read>
8000a70c:	58 1c       	cp.w	r12,1
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
8000a70e:	ce b1       	brne	8000a6e4 <sd_mmc_spi_get_if+0x1c>
8000a710:	3f f8       	mov	r8,-1
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
      return false;
    }
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000a712:	ac 88       	st.b	r6[0x0],r8
8000a714:	30 1b       	mov	r11,1
8000a716:	fe 7c 24 00 	mov	r12,-56320
8000a71a:	e0 a0 0a 78 	rcall	8000bc0a <spi_unselectChip>
{
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
    return SD_FAILURE;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000a71e:	30 1b       	mov	r11,1
8000a720:	fe 7c 24 00 	mov	r12,-56320
8000a724:	e0 a0 0a 4b 	rcall	8000bbba <spi_selectChip>
  r1 = sd_mmc_spi_command(MMC_SEND_IF_COND, 0x000001AA);
8000a728:	e0 6b 01 aa 	mov	r11,426
8000a72c:	30 8c       	mov	r12,8
8000a72e:	fe b0 fb 55 	rcall	80009dd8 <sd_mmc_spi_command>
  // check for valid response
  if((r1 & MMC_R1_ILLEGAL_COM) != 0) {
8000a732:	ac 8c       	st.b	r6[0x0],r12
8000a734:	ed bc 00 02 	bld	r12,0x2
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000a738:	c5 60       	breq	8000a7e4 <sd_mmc_spi_get_if+0x11c>
8000a73a:	e0 6b 00 ff 	mov	r11,255
8000a73e:	fe 7c 24 00 	mov	r12,-56320
8000a742:	e0 a0 0a d0 	rcall	8000bce2 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000a746:	0a 9b       	mov	r11,r5
8000a748:	fe 7c 24 00 	mov	r12,-56320
8000a74c:	e0 a0 0a d9 	rcall	8000bcfe <spi_read>
8000a750:	58 1c       	cp.w	r12,1
     return 0xFF;
   return data_read;
8000a752:	c5 00       	breq	8000a7f2 <sd_mmc_spi_get_if+0x12a>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000a754:	1b b8       	ld.ub	r8,sp[0x3]
8000a756:	e0 6b 00 ff 	mov	r11,255
8000a75a:	ac 88       	st.b	r6[0x0],r8
8000a75c:	fe 7c 24 00 	mov	r12,-56320
8000a760:	e0 a0 0a c1 	rcall	8000bce2 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000a764:	0a 9b       	mov	r11,r5
8000a766:	fe 7c 24 00 	mov	r12,-56320
8000a76a:	e0 a0 0a ca 	rcall	8000bcfe <spi_read>
8000a76e:	58 1c       	cp.w	r12,1
     return 0xFF;
   return data_read;
8000a770:	c4 70       	breq	8000a7fe <sd_mmc_spi_get_if+0x136>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000a772:	1b b8       	ld.ub	r8,sp[0x3]
8000a774:	e0 6b 00 ff 	mov	r11,255
8000a778:	ac 88       	st.b	r6[0x0],r8
8000a77a:	fe 7c 24 00 	mov	r12,-56320
8000a77e:	e0 a0 0a b2 	rcall	8000bce2 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000a782:	0a 9b       	mov	r11,r5
8000a784:	fe 7c 24 00 	mov	r12,-56320
8000a788:	e0 67 0c e4 	mov	r7,3300
8000a78c:	e0 a0 0a b9 	rcall	8000bcfe <spi_read>
     return 0xFF;
   return data_read;
8000a790:	58 1c       	cp.w	r12,1
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return SD_MMC;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
8000a792:	c3 30       	breq	8000a7f8 <sd_mmc_spi_get_if+0x130>
  if((r1 & 0x01) == 0) {
8000a794:	1b b8       	ld.ub	r8,sp[0x3]
8000a796:	ae 88       	st.b	r7[0x0],r8
8000a798:	ed b8 00 00 	bld	r8,0x0
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000a79c:	c1 d1       	brne	8000a7d6 <sd_mmc_spi_get_if+0x10e>
8000a79e:	e0 6b 00 ff 	mov	r11,255
8000a7a2:	fe 7c 24 00 	mov	r12,-56320
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000a7a6:	e0 a0 0a 9e 	rcall	8000bce2 <spi_write>
8000a7aa:	0a 9b       	mov	r11,r5
8000a7ac:	fe 7c 24 00 	mov	r12,-56320
8000a7b0:	e0 a0 0a a7 	rcall	8000bcfe <spi_read>
     return 0xFF;
   return data_read;
8000a7b4:	58 1c       	cp.w	r12,1
  r1 = sd_mmc_spi_send_and_read(0xFF);
  if((r1 & 0x01) == 0) {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return SD_FAILURE;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
8000a7b6:	c0 e0       	breq	8000a7d2 <sd_mmc_spi_get_if+0x10a>
  if(r1 != 0xaa) {
8000a7b8:	1b b8       	ld.ub	r8,sp[0x3]
8000a7ba:	ac 88       	st.b	r6[0x0],r8
8000a7bc:	3a a9       	mov	r9,-86
8000a7be:	f2 08 18 00 	cp.b	r8,r9
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return SD_FAILURE; /* wrong test pattern */
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a7c2:	c0 a1       	brne	8000a7d6 <sd_mmc_spi_get_if+0x10e>
8000a7c4:	30 1b       	mov	r11,1
8000a7c6:	fe 7c 24 00 	mov	r12,-56320
8000a7ca:	e0 a0 0a 20 	rcall	8000bc0a <spi_unselectChip>
  r1 = sd_mmc_spi_send_and_read(0xFF);
  if((r1 & 0x01) == 0) {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return SD_FAILURE;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
8000a7ce:	2f fd       	sub	sp,-4
8000a7d0:	da 2a       	popm	r4-r7,pc,r12=1
  if(r1 != 0xaa) {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a7d2:	3f f8       	mov	r8,-1
8000a7d4:	ac 88       	st.b	r6[0x0],r8
8000a7d6:	30 1b       	mov	r11,1
8000a7d8:	fe 7c 24 00 	mov	r12,-56320
8000a7dc:	e0 a0 0a 17 	rcall	8000bc0a <spi_unselectChip>

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(MMC_SEND_IF_COND, 0x000001AA);
  // check for valid response
  if((r1 & MMC_R1_ILLEGAL_COM) != 0) {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a7e0:	2f fd       	sub	sp,-4
8000a7e2:	dc 2a       	popm	r4-r7,pc,r12=-1
8000a7e4:	30 1b       	mov	r11,1
8000a7e6:	fe 7c 24 00 	mov	r12,-56320
8000a7ea:	e0 a0 0a 10 	rcall	8000bc0a <spi_unselectChip>
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000a7ee:	2f fd       	sub	sp,-4
8000a7f0:	d8 2a       	popm	r4-r7,pc,r12=0
8000a7f2:	e0 68 00 ff 	mov	r8,255
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return SD_MMC;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
8000a7f6:	cb 0b       	rjmp	8000a756 <sd_mmc_spi_get_if+0x8e>
8000a7f8:	3f f8       	mov	r8,-1
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000a7fa:	ae 88       	st.b	r7[0x0],r8
8000a7fc:	cd 1b       	rjmp	8000a79e <sd_mmc_spi_get_if+0xd6>
8000a7fe:	e0 68 00 ff 	mov	r8,255
8000a802:	cb 9b       	rjmp	8000a774 <sd_mmc_spi_get_if+0xac>

8000a804 <sd_mmc_spi_internal_init>:
8000a804:	d4 31       	pushm	r0-r7,lr
8000a806:	20 1d       	sub	sp,4
8000a808:	e6 68 1a 80 	mov	r8,400000
8000a80c:	e0 69 09 80 	mov	r9,2432
8000a810:	e0 67 09 70 	mov	r7,2416
8000a814:	72 0a       	ld.w	r10,r9[0x0]
8000a816:	8f 18       	st.w	r7[0x4],r8
  int i;
  int if_cond;

  // Start at low frequency
  sd_mmc_opt.baudrate = 400000;
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
8000a818:	0e 9b       	mov	r11,r7
8000a81a:	fe 7c 24 00 	mov	r12,-56320
8000a81e:	e0 a0 0a 09 	rcall	8000bc30 <spi_setupChipReg>

  /* card needs 74 cycles minimum to start up */
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000a822:	30 1b       	mov	r11,1
8000a824:	fe 7c 24 00 	mov	r12,-56320
8000a828:	e0 a0 09 c9 	rcall	8000bbba <spi_selectChip>
  for(i = 0; i < 10; ++i) {
    spi_write(SD_MMC_SPI,0xFF);
8000a82c:	e0 6b 00 ff 	mov	r11,255
8000a830:	fe 7c 24 00 	mov	r12,-56320
8000a834:	e0 a0 0a 57 	rcall	8000bce2 <spi_write>
8000a838:	e0 6b 00 ff 	mov	r11,255
8000a83c:	fe 7c 24 00 	mov	r12,-56320
8000a840:	e0 a0 0a 51 	rcall	8000bce2 <spi_write>
8000a844:	e0 6b 00 ff 	mov	r11,255
8000a848:	fe 7c 24 00 	mov	r12,-56320
8000a84c:	e0 a0 0a 4b 	rcall	8000bce2 <spi_write>
8000a850:	e0 6b 00 ff 	mov	r11,255
8000a854:	fe 7c 24 00 	mov	r12,-56320
8000a858:	e0 a0 0a 45 	rcall	8000bce2 <spi_write>
8000a85c:	e0 6b 00 ff 	mov	r11,255
8000a860:	fe 7c 24 00 	mov	r12,-56320
8000a864:	e0 a0 0a 3f 	rcall	8000bce2 <spi_write>
8000a868:	e0 6b 00 ff 	mov	r11,255
8000a86c:	fe 7c 24 00 	mov	r12,-56320
8000a870:	e0 a0 0a 39 	rcall	8000bce2 <spi_write>
8000a874:	e0 6b 00 ff 	mov	r11,255
8000a878:	fe 7c 24 00 	mov	r12,-56320
8000a87c:	e0 a0 0a 33 	rcall	8000bce2 <spi_write>
8000a880:	e0 6b 00 ff 	mov	r11,255
8000a884:	fe 7c 24 00 	mov	r12,-56320
8000a888:	e0 a0 0a 2d 	rcall	8000bce2 <spi_write>
8000a88c:	e0 6b 00 ff 	mov	r11,255
8000a890:	fe 7c 24 00 	mov	r12,-56320
8000a894:	e0 a0 0a 27 	rcall	8000bce2 <spi_write>
8000a898:	e0 6b 00 ff 	mov	r11,255
8000a89c:	fe 7c 24 00 	mov	r12,-56320
8000a8a0:	e0 a0 0a 21 	rcall	8000bce2 <spi_write>
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a8a4:	30 1b       	mov	r11,1
8000a8a6:	fe 7c 24 00 	mov	r12,-56320
8000a8aa:	e0 a0 09 b0 	rcall	8000bc0a <spi_unselectChip>

  // RESET THE MEMORY CARD
  sd_mmc_spi_init_done = false;
8000a8ae:	30 08       	mov	r8,0
8000a8b0:	e0 69 09 84 	mov	r9,2436
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000a8b4:	30 1b       	mov	r11,1
    spi_write(SD_MMC_SPI,0xFF);
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI

  // RESET THE MEMORY CARD
  sd_mmc_spi_init_done = false;
8000a8b6:	b2 88       	st.b	r9[0x0],r8
  card_type = MMC_CARD;
8000a8b8:	e0 61 0c d2 	mov	r1,3282
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000a8bc:	fe 7c 24 00 	mov	r12,-56320
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI

  // RESET THE MEMORY CARD
  sd_mmc_spi_init_done = false;
  card_type = MMC_CARD;
8000a8c0:	a2 88       	st.b	r1[0x0],r8
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000a8c2:	e0 a0 09 7c 	rcall	8000bbba <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
8000a8c6:	30 0b       	mov	r11,0
8000a8c8:	16 9c       	mov	r12,r11
8000a8ca:	fe b0 fa 87 	rcall	80009dd8 <sd_mmc_spi_command>
8000a8ce:	e0 66 0c e4 	mov	r6,3300
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a8d2:	30 1b       	mov	r11,1
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000a8d4:	ac 8c       	st.b	r6[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a8d6:	fe 7c 24 00 	mov	r12,-56320
8000a8da:	e0 a0 09 98 	rcall	8000bc0a <spi_unselectChip>
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000a8de:	e0 6b 00 ff 	mov	r11,255
8000a8e2:	fe 7c 24 00 	mov	r12,-56320
8000a8e6:	30 05       	mov	r5,0
8000a8e8:	e0 a0 09 fd 	rcall	8000bce2 <spi_write>
    // do retry counter
    retry++;
    if(retry > 100)
      return false;
  }
  while(r1 != 0x01);   // check memory enters idle_state
8000a8ec:	0c 90       	mov	r0,r6
8000a8ee:	30 12       	mov	r2,1
8000a8f0:	c1 68       	rjmp	8000a91c <sd_mmc_spi_internal_init+0x118>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000a8f2:	e0 a0 09 64 	rcall	8000bbba <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
8000a8f6:	30 0b       	mov	r11,0
8000a8f8:	16 9c       	mov	r12,r11
8000a8fa:	fe b0 fa 6f 	rcall	80009dd8 <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a8fe:	30 1b       	mov	r11,1
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000a900:	a0 8c       	st.b	r0[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a902:	fe 7c 24 00 	mov	r12,-56320
8000a906:	e0 a0 09 82 	rcall	8000bc0a <spi_unselectChip>
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000a90a:	e0 6b 00 ff 	mov	r11,255
8000a90e:	fe 7c 24 00 	mov	r12,-56320
8000a912:	e0 a0 09 e8 	rcall	8000bce2 <spi_write>
    // do retry counter
    retry++;
    if(retry > 100)
8000a916:	e0 45 00 64 	cp.w	r5,100
8000a91a:	c7 80       	breq	8000aa0a <sd_mmc_spi_internal_init+0x206>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000a91c:	30 1b       	mov	r11,1
8000a91e:	fe 7c 24 00 	mov	r12,-56320
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000a922:	16 05       	add	r5,r11
    // do retry counter
    retry++;
    if(retry > 100)
      return false;
  }
  while(r1 != 0x01);   // check memory enters idle_state
8000a924:	0d 84       	ld.ub	r4,r6[0x0]
8000a926:	e0 63 0c e4 	mov	r3,3300
8000a92a:	e4 04 18 00 	cp.b	r4,r2
8000a92e:	ce 21       	brne	8000a8f2 <sd_mmc_spi_internal_init+0xee>

  if_cond = sd_mmc_spi_get_if();
8000a930:	cc ce       	rcall	8000a6c8 <sd_mmc_spi_get_if>
8000a932:	5b fc       	cp.w	r12,-1
  if(if_cond == -1) {
8000a934:	c6 b0       	breq	8000aa0a <sd_mmc_spi_internal_init+0x206>
8000a936:	58 1c       	cp.w	r12,1
      return false; // card is bad
  } else if (if_cond == 1) {
8000a938:	c6 c0       	breq	8000aa10 <sd_mmc_spi_internal_init+0x20c>
8000a93a:	30 1b       	mov	r11,1
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000a93c:	fe 7c 24 00 	mov	r12,-56320
8000a940:	e0 a0 09 3d 	rcall	8000bbba <spi_selectChip>
8000a944:	30 0b       	mov	r11,0
  r1 = sd_mmc_spi_command(command, arg);
8000a946:	33 7c       	mov	r12,55
8000a948:	fe b0 fa 48 	rcall	80009dd8 <sd_mmc_spi_command>
8000a94c:	30 1b       	mov	r11,1
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a94e:	a6 8c       	st.b	r3[0x0],r12
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000a950:	fe 7c 24 00 	mov	r12,-56320
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a954:	e0 a0 09 5b 	rcall	8000bc0a <spi_unselectChip>
8000a958:	e0 6b 00 ff 	mov	r11,255
      card_type = SD_CARD_2;
  } else {
    // IDENTIFICATION OF THE CARD TYPE (SD or MMC)
    // Both cards will accept CMD55 command but only the SD card will respond to ACMD41
    r1 = sd_mmc_spi_send_command(SD_APP_CMD55,0);
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte
8000a95c:	fe 7c 24 00 	mov	r12,-56320
8000a960:	e0 a0 09 c1 	rcall	8000bce2 <spi_write>
8000a964:	30 1b       	mov	r11,1
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000a966:	fe 7c 24 00 	mov	r12,-56320
8000a96a:	e0 a0 09 28 	rcall	8000bbba <spi_selectChip>
8000a96e:	30 0b       	mov	r11,0
  r1 = sd_mmc_spi_command(command, arg);
8000a970:	32 9c       	mov	r12,41
8000a972:	fe b0 fa 33 	rcall	80009dd8 <sd_mmc_spi_command>
8000a976:	30 1b       	mov	r11,1
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a978:	a6 8c       	st.b	r3[0x0],r12
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000a97a:	fe 7c 24 00 	mov	r12,-56320
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a97e:	e0 a0 09 46 	rcall	8000bc0a <spi_unselectChip>
8000a982:	e0 6b 00 ff 	mov	r11,255
    // Both cards will accept CMD55 command but only the SD card will respond to ACMD41
    r1 = sd_mmc_spi_send_command(SD_APP_CMD55,0);
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte

    r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte
8000a986:	fe 7c 24 00 	mov	r12,-56320
8000a98a:	e0 a0 09 ac 	rcall	8000bce2 <spi_write>
8000a98e:	07 88       	ld.ub	r8,r3[0x0]

    if ((r1&0xFE) == 0) {   // ignore "in_idle_state" flag bit
8000a990:	e2 18 00 fe 	andl	r8,0xfe,COH
8000a994:	e0 80 01 db 	breq	8000ad4a <sd_mmc_spi_internal_init+0x546>
8000a998:	30 08       	mov	r8,0
      card_type = SD_CARD;    // card has accepted the command, this is a SD card
    } else {
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
8000a99a:	30 1b       	mov	r11,1
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000a99c:	a2 88       	st.b	r1[0x0],r8
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte

    if ((r1&0xFE) == 0) {   // ignore "in_idle_state" flag bit
      card_type = SD_CARD;    // card has accepted the command, this is a SD card
    } else {
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
8000a99e:	fe 7c 24 00 	mov	r12,-56320
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000a9a2:	e0 a0 09 0c 	rcall	8000bbba <spi_selectChip>
8000a9a6:	30 0b       	mov	r11,0
  r1 = sd_mmc_spi_command(command, arg);
8000a9a8:	16 9c       	mov	r12,r11
8000a9aa:	fe b0 fa 17 	rcall	80009dd8 <sd_mmc_spi_command>
8000a9ae:	30 1b       	mov	r11,1
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a9b0:	a6 8c       	st.b	r3[0x0],r12
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000a9b2:	fe 7c 24 00 	mov	r12,-56320
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a9b6:	e0 a0 09 2a 	rcall	8000bc0a <spi_unselectChip>
8000a9ba:	e0 6b 00 ff 	mov	r11,255
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000a9be:	fe 7c 24 00 	mov	r12,-56320
8000a9c2:	30 05       	mov	r5,0
8000a9c4:	e0 a0 09 8f 	rcall	8000bce2 <spi_write>
8000a9c8:	30 14       	mov	r4,1
        // do retry counter
        retry++;
        if(retry > 100)
          return false;
      }
      while(r1 != 0x01);   // check memory enters idle_state
8000a9ca:	c1 68       	rjmp	8000a9f6 <sd_mmc_spi_internal_init+0x1f2>
8000a9cc:	e0 a0 08 f7 	rcall	8000bbba <spi_selectChip>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000a9d0:	30 0b       	mov	r11,0
  r1 = sd_mmc_spi_command(command, arg);
8000a9d2:	16 9c       	mov	r12,r11
8000a9d4:	fe b0 fa 02 	rcall	80009dd8 <sd_mmc_spi_command>
8000a9d8:	30 1b       	mov	r11,1
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a9da:	a6 8c       	st.b	r3[0x0],r12
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000a9dc:	fe 7c 24 00 	mov	r12,-56320
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000a9e0:	e0 a0 09 15 	rcall	8000bc0a <spi_unselectChip>
8000a9e4:	e0 6b 00 ff 	mov	r11,255
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000a9e8:	fe 7c 24 00 	mov	r12,-56320
8000a9ec:	e0 a0 09 7b 	rcall	8000bce2 <spi_write>
8000a9f0:	e0 45 00 64 	cp.w	r5,100
        // do retry counter
        retry++;
        if(retry > 100)
8000a9f4:	c0 b0       	breq	8000aa0a <sd_mmc_spi_internal_init+0x206>
8000a9f6:	30 1b       	mov	r11,1
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000a9f8:	fe 7c 24 00 	mov	r12,-56320
8000a9fc:	16 05       	add	r5,r11
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000a9fe:	0d 88       	ld.ub	r8,r6[0x0]
        // do retry counter
        retry++;
        if(retry > 100)
          return false;
      }
      while(r1 != 0x01);   // check memory enters idle_state
8000aa00:	e8 08 18 00 	cp.b	r8,r4
8000aa04:	ce 41       	brne	8000a9cc <sd_mmc_spi_internal_init+0x1c8>
8000aa06:	03 88       	ld.ub	r8,r1[0x0]
8000aa08:	c0 78       	rjmp	8000aa16 <sd_mmc_spi_internal_init+0x212>
8000aa0a:	30 0c       	mov	r12,0
  sd_mmc_spi_init_done = true;

  // Set SPI Speed to MAX
  sd_mmc_opt.baudrate = SD_MMC_SPI_MASTER_SPEED;
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
  return true;
8000aa0c:	2f fd       	sub	sp,-4
}
8000aa0e:	d8 32       	popm	r0-r7,pc
8000aa10:	30 28       	mov	r8,2

  if_cond = sd_mmc_spi_get_if();
  if(if_cond == -1) {
      return false; // card is bad
  } else if (if_cond == 1) {
      card_type = SD_CARD_2;
8000aa12:	a2 88       	st.b	r1[0x0],r8
8000aa14:	30 28       	mov	r8,2
8000aa16:	30 05       	mov	r5,0
        // do retry counter
        retry++;
        if(retry > 100)
          return false;
      }
      while(r1 != 0x01);   // check memory enters idle_state
8000aa18:	30 14       	mov	r4,1

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
  do {
    switch(card_type) {
8000aa1a:	30 23       	mov	r3,2
8000aa1c:	c1 d8       	rjmp	8000aa56 <sd_mmc_spi_internal_init+0x252>
8000aa1e:	e0 a0 08 ce 	rcall	8000bbba <spi_selectChip>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000aa22:	30 0b       	mov	r11,0
  r1 = sd_mmc_spi_command(command, arg);
8000aa24:	30 1c       	mov	r12,1
8000aa26:	fe b0 f9 d9 	rcall	80009dd8 <sd_mmc_spi_command>
8000aa2a:	30 1b       	mov	r11,1
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000aa2c:	ac 8c       	st.b	r6[0x0],r12
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000aa2e:	fe 7c 24 00 	mov	r12,-56320
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000aa32:	e0 a0 08 ec 	rcall	8000bc0a <spi_unselectChip>
8000aa36:	e0 6b 00 ff 	mov	r11,255
      break;
    case SD_CARD_2:
      // set high capacity bit mask
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0x40000000);
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000aa3a:	fe 7c 24 00 	mov	r12,-56320
8000aa3e:	e0 a0 09 52 	rcall	8000bce2 <spi_write>
8000aa42:	e0 45 c3 4f 	cp.w	r5,49999
      break;
    }
     // do retry counter
     retry++;
     if(retry == 50000)    // measured approx. 500 on several cards
8000aa46:	ce 20       	breq	8000aa0a <sd_mmc_spi_internal_init+0x206>
8000aa48:	2f f5       	sub	r5,-1
8000aa4a:	0d 89       	ld.ub	r9,r6[0x0]
        return false;
  } while (r1);
8000aa4c:	30 08       	mov	r8,0
8000aa4e:	f0 09 18 00 	cp.b	r9,r8
8000aa52:	c3 b0       	breq	8000aac8 <sd_mmc_spi_internal_init+0x2c4>
8000aa54:	03 88       	ld.ub	r8,r1[0x0]
8000aa56:	e8 08 18 00 	cp.b	r8,r4

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
  do {
    switch(card_type) {
8000aa5a:	c2 00       	breq	8000aa9a <sd_mmc_spi_internal_init+0x296>
8000aa5c:	30 1b       	mov	r11,1
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000aa5e:	fe 7c 24 00 	mov	r12,-56320
8000aa62:	cd e3       	brcs	8000aa1e <sd_mmc_spi_internal_init+0x21a>

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
  do {
    switch(card_type) {
8000aa64:	e6 08 18 00 	cp.b	r8,r3
8000aa68:	ce d1       	brne	8000aa42 <sd_mmc_spi_internal_init+0x23e>
8000aa6a:	30 1b       	mov	r11,1
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000aa6c:	fe 7c 24 00 	mov	r12,-56320
8000aa70:	e0 a0 08 a5 	rcall	8000bbba <spi_selectChip>
8000aa74:	30 0b       	mov	r11,0
  r1 = sd_mmc_spi_command(command, arg);
8000aa76:	33 7c       	mov	r12,55
8000aa78:	fe b0 f9 b0 	rcall	80009dd8 <sd_mmc_spi_command>
8000aa7c:	30 1b       	mov	r11,1
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000aa7e:	ac 8c       	st.b	r6[0x0],r12
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000aa80:	fe 7c 24 00 	mov	r12,-56320
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000aa84:	e0 a0 08 c3 	rcall	8000bc0a <spi_unselectChip>
8000aa88:	30 1b       	mov	r11,1
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000aa8a:	fe 7c 24 00 	mov	r12,-56320
8000aa8e:	e0 a0 08 96 	rcall	8000bbba <spi_selectChip>
8000aa92:	fc 1b 40 00 	movh	r11,0x4000
  r1 = sd_mmc_spi_command(command, arg);
8000aa96:	32 9c       	mov	r12,41
8000aa98:	cc 7b       	rjmp	8000aa26 <sd_mmc_spi_internal_init+0x222>
8000aa9a:	30 1b       	mov	r11,1
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000aa9c:	fe 7c 24 00 	mov	r12,-56320
8000aaa0:	e0 a0 08 8d 	rcall	8000bbba <spi_selectChip>
8000aaa4:	30 0b       	mov	r11,0
  r1 = sd_mmc_spi_command(command, arg);
8000aaa6:	33 7c       	mov	r12,55
8000aaa8:	fe b0 f9 98 	rcall	80009dd8 <sd_mmc_spi_command>
8000aaac:	30 1b       	mov	r11,1
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000aaae:	ac 8c       	st.b	r6[0x0],r12
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000aab0:	fe 7c 24 00 	mov	r12,-56320
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000aab4:	e0 a0 08 ab 	rcall	8000bc0a <spi_unselectChip>
8000aab8:	30 1b       	mov	r11,1
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000aaba:	fe 7c 24 00 	mov	r12,-56320
8000aabe:	e0 a0 08 7e 	rcall	8000bbba <spi_selectChip>
8000aac2:	30 0b       	mov	r11,0
  r1 = sd_mmc_spi_command(command, arg);
8000aac4:	32 9c       	mov	r12,41
8000aac6:	cb 0b       	rjmp	8000aa26 <sd_mmc_spi_internal_init+0x222>
8000aac8:	03 89       	ld.ub	r9,r1[0x0]
     if(retry == 50000)    // measured approx. 500 on several cards
        return false;
  } while (r1);

  // CHECK FOR SDHC
  if(card_type == SD_CARD_2) {
8000aaca:	30 28       	mov	r8,2
8000aacc:	f0 09 18 00 	cp.b	r9,r8
8000aad0:	e0 80 01 41 	breq	8000ad52 <sd_mmc_spi_internal_init+0x54e>
8000aad4:	30 1b       	mov	r11,1
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000aad6:	fe 7c 24 00 	mov	r12,-56320
8000aada:	e0 a0 08 70 	rcall	8000bbba <spi_selectChip>
8000aade:	30 0b       	mov	r11,0
  r1 = sd_mmc_spi_command(command, arg);
8000aae0:	33 bc       	mov	r12,59
8000aae2:	fe b0 f9 7b 	rcall	80009dd8 <sd_mmc_spi_command>
8000aae6:	30 1b       	mov	r11,1
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000aae8:	ac 8c       	st.b	r6[0x0],r12
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000aaea:	fe 7c 24 00 	mov	r12,-56320
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000aaee:	e0 a0 08 8e 	rcall	8000bc0a <spi_unselectChip>
8000aaf2:	e0 6b 00 ff 	mov	r11,255
      }
  }

  // DISABLE CRC TO SIMPLIFY AND SPEED UP COMMUNICATIONS
  r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0);  // disable CRC (should be already initialized on SPI init)
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000aaf6:	fe 7c 24 00 	mov	r12,-56320
8000aafa:	e0 a0 08 f4 	rcall	8000bce2 <spi_write>
8000aafe:	30 1b       	mov	r11,1
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000ab00:	fe 7c 24 00 	mov	r12,-56320
8000ab04:	e0 a0 08 5b 	rcall	8000bbba <spi_selectChip>
8000ab08:	e0 6b 02 00 	mov	r11,512
  r1 = sd_mmc_spi_command(command, arg);
8000ab0c:	31 0c       	mov	r12,16
8000ab0e:	fe b0 f9 65 	rcall	80009dd8 <sd_mmc_spi_command>
8000ab12:	30 1b       	mov	r11,1
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000ab14:	ac 8c       	st.b	r6[0x0],r12
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000ab16:	fe 7c 24 00 	mov	r12,-56320
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000ab1a:	e0 a0 08 78 	rcall	8000bc0a <spi_unselectChip>
8000ab1e:	e0 6b 00 ff 	mov	r11,255
  r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0);  // disable CRC (should be already initialized on SPI init)
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte

  // SET BLOCK LENGTH TO 512 BYTES
  r1 = sd_mmc_spi_send_command(MMC_SET_BLOCKLEN, 512);
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000ab22:	fe 7c 24 00 	mov	r12,-56320
8000ab26:	e0 a0 08 de 	rcall	8000bce2 <spi_write>
8000ab2a:	0d 89       	ld.ub	r9,r6[0x0]
  if (r1 != 0x00)
8000ab2c:	30 08       	mov	r8,0
8000ab2e:	f0 09 18 00 	cp.b	r9,r8
8000ab32:	fe 91 ff 6c 	brne	8000aa0a <sd_mmc_spi_internal_init+0x206>
8000ab36:	30 1b       	mov	r11,1
bool sd_mmc_spi_wait_not_busy(void)
{
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000ab38:	fe 7c 24 00 	mov	r12,-56320
8000ab3c:	30 05       	mov	r5,0
8000ab3e:	e0 a0 08 3e 	rcall	8000bbba <spi_selectChip>
8000ab42:	1a 94       	mov	r4,sp
8000ab44:	3f f3       	mov	r3,-1
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
8000ab46:	c0 a8       	rjmp	8000ab5a <sd_mmc_spi_internal_init+0x356>
8000ab48:	1b 98       	ld.ub	r8,sp[0x1]
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
     return 0xFF;
   return data_read;
8000ab4a:	ac 88       	st.b	r6[0x0],r8
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
8000ab4c:	e6 08 18 00 	cp.b	r8,r3
8000ab50:	c1 50       	breq	8000ab7a <sd_mmc_spi_internal_init+0x376>
8000ab52:	e2 55 0d 40 	cp.w	r5,200000
  {
    retry++;
    if (retry == 200000)
8000ab56:	e0 80 00 f3 	breq	8000ad3c <sd_mmc_spi_internal_init+0x538>
8000ab5a:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000ab5e:	fe 7c 24 00 	mov	r12,-56320
8000ab62:	e0 a0 08 c0 	rcall	8000bce2 <spi_write>
8000ab66:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000ab68:	2f f5       	sub	r5,-1
bool sd_mmc_spi_wait_not_busy(void)
{
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000ab6a:	fe 7c 24 00 	mov	r12,-56320
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000ab6e:	e0 a0 08 c8 	rcall	8000bcfe <spi_read>
8000ab72:	58 1c       	cp.w	r12,1
8000ab74:	ce a1       	brne	8000ab48 <sd_mmc_spi_internal_init+0x344>
8000ab76:	3f f8       	mov	r8,-1
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
8000ab78:	ac 88       	st.b	r6[0x0],r8
8000ab7a:	30 1b       	mov	r11,1
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
      return false;
    }
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000ab7c:	fe 7c 24 00 	mov	r12,-56320
8000ab80:	e0 a0 08 45 	rcall	8000bc0a <spi_unselectChip>
8000ab84:	30 1b       	mov	r11,1
unsigned short data_read;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000ab86:	fe 7c 24 00 	mov	r12,-56320
8000ab8a:	e0 a0 08 18 	rcall	8000bbba <spi_selectChip>
8000ab8e:	30 0b       	mov	r11,0
  // issue command
  r1 = sd_mmc_spi_command(MMC_SEND_CSD, 0);
8000ab90:	30 9c       	mov	r12,9
8000ab92:	fe b0 f9 23 	rcall	80009dd8 <sd_mmc_spi_command>
8000ab96:	ac 8c       	st.b	r6[0x0],r12
8000ab98:	e0 65 0c e4 	mov	r5,3300
8000ab9c:	58 0c       	cp.w	r12,0
  // check for valid response
  if(r1 != 0x00)
8000ab9e:	e0 81 00 e7 	brne	8000ad6c <sd_mmc_spi_internal_init+0x568>
8000aba2:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000aba6:	fe 7c 24 00 	mov	r12,-56320
8000abaa:	e0 a0 08 9c 	rcall	8000bce2 <spi_write>
8000abae:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000abb0:	fe 7c 24 00 	mov	r12,-56320
8000abb4:	e0 a0 08 a5 	rcall	8000bcfe <spi_read>
8000abb8:	58 1c       	cp.w	r12,1
8000abba:	e0 80 00 e5 	breq	8000ad84 <sd_mmc_spi_internal_init+0x580>
8000abbe:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
8000abc0:	aa 88       	st.b	r5[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
8000abc2:	3f e9       	mov	r9,-2
8000abc4:	f2 08 18 00 	cp.b	r8,r9
8000abc8:	e0 80 00 f3 	breq	8000adae <sd_mmc_spi_internal_init+0x5aa>
8000abcc:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000abd0:	fe 7c 24 00 	mov	r12,-56320
8000abd4:	e0 a0 08 87 	rcall	8000bce2 <spi_write>
8000abd8:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000abda:	fe 7c 24 00 	mov	r12,-56320
8000abde:	e0 a0 08 90 	rcall	8000bcfe <spi_read>
8000abe2:	58 1c       	cp.w	r12,1
8000abe4:	e0 80 00 d3 	breq	8000ad8a <sd_mmc_spi_internal_init+0x586>
8000abe8:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
8000abea:	ac 88       	st.b	r6[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
8000abec:	3f e9       	mov	r9,-2
8000abee:	f2 08 18 00 	cp.b	r8,r9
8000abf2:	e0 80 00 de 	breq	8000adae <sd_mmc_spi_internal_init+0x5aa>
8000abf6:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000abfa:	fe 7c 24 00 	mov	r12,-56320
8000abfe:	e0 a0 08 72 	rcall	8000bce2 <spi_write>
8000ac02:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000ac04:	fe 7c 24 00 	mov	r12,-56320
8000ac08:	e0 a0 08 7b 	rcall	8000bcfe <spi_read>
8000ac0c:	58 1c       	cp.w	r12,1
8000ac0e:	e0 80 00 c1 	breq	8000ad90 <sd_mmc_spi_internal_init+0x58c>
8000ac12:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
8000ac14:	ac 88       	st.b	r6[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
8000ac16:	3f e9       	mov	r9,-2
8000ac18:	f2 08 18 00 	cp.b	r8,r9
8000ac1c:	e0 80 00 c9 	breq	8000adae <sd_mmc_spi_internal_init+0x5aa>
8000ac20:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000ac24:	fe 7c 24 00 	mov	r12,-56320
8000ac28:	e0 a0 08 5d 	rcall	8000bce2 <spi_write>
8000ac2c:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000ac2e:	fe 7c 24 00 	mov	r12,-56320
8000ac32:	e0 a0 08 66 	rcall	8000bcfe <spi_read>
8000ac36:	58 1c       	cp.w	r12,1
8000ac38:	e0 80 00 af 	breq	8000ad96 <sd_mmc_spi_internal_init+0x592>
8000ac3c:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
8000ac3e:	ac 88       	st.b	r6[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
8000ac40:	3f e9       	mov	r9,-2
8000ac42:	f2 08 18 00 	cp.b	r8,r9
8000ac46:	e0 80 00 b4 	breq	8000adae <sd_mmc_spi_internal_init+0x5aa>
8000ac4a:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000ac4e:	fe 7c 24 00 	mov	r12,-56320
8000ac52:	e0 a0 08 48 	rcall	8000bce2 <spi_write>
8000ac56:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000ac58:	fe 7c 24 00 	mov	r12,-56320
8000ac5c:	e0 a0 08 51 	rcall	8000bcfe <spi_read>
8000ac60:	58 1c       	cp.w	r12,1
8000ac62:	e0 80 00 9d 	breq	8000ad9c <sd_mmc_spi_internal_init+0x598>
8000ac66:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
8000ac68:	ac 88       	st.b	r6[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
8000ac6a:	3f e9       	mov	r9,-2
8000ac6c:	f2 08 18 00 	cp.b	r8,r9
8000ac70:	e0 80 00 9f 	breq	8000adae <sd_mmc_spi_internal_init+0x5aa>
8000ac74:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000ac78:	fe 7c 24 00 	mov	r12,-56320
8000ac7c:	e0 a0 08 33 	rcall	8000bce2 <spi_write>
8000ac80:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000ac82:	fe 7c 24 00 	mov	r12,-56320
8000ac86:	e0 a0 08 3c 	rcall	8000bcfe <spi_read>
8000ac8a:	58 1c       	cp.w	r12,1
8000ac8c:	e0 80 00 8b 	breq	8000ada2 <sd_mmc_spi_internal_init+0x59e>
8000ac90:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
8000ac92:	ac 88       	st.b	r6[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
8000ac94:	3f e9       	mov	r9,-2
8000ac96:	f2 08 18 00 	cp.b	r8,r9
8000ac9a:	e0 80 00 8a 	breq	8000adae <sd_mmc_spi_internal_init+0x5aa>
8000ac9e:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000aca2:	fe 7c 24 00 	mov	r12,-56320
8000aca6:	e0 a0 08 1e 	rcall	8000bce2 <spi_write>
8000acaa:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000acac:	fe 7c 24 00 	mov	r12,-56320
8000acb0:	e0 a0 08 27 	rcall	8000bcfe <spi_read>
8000acb4:	58 1c       	cp.w	r12,1
8000acb6:	c7 90       	breq	8000ada8 <sd_mmc_spi_internal_init+0x5a4>
8000acb8:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
8000acba:	ac 88       	st.b	r6[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
8000acbc:	3f e9       	mov	r9,-2
8000acbe:	f2 08 18 00 	cp.b	r8,r9
8000acc2:	c7 60       	breq	8000adae <sd_mmc_spi_internal_init+0x5aa>
8000acc4:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000acc8:	fe 7c 24 00 	mov	r12,-56320
8000accc:	e0 a0 08 0b 	rcall	8000bce2 <spi_write>
8000acd0:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000acd2:	fe 7c 24 00 	mov	r12,-56320
8000acd6:	e0 a0 08 14 	rcall	8000bcfe <spi_read>
8000acda:	58 1c       	cp.w	r12,1
8000acdc:	e0 80 01 77 	breq	8000afca <sd_mmc_spi_internal_init+0x7c6>
8000ace0:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
8000ace2:	ac 88       	st.b	r6[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
8000ace4:	3f e9       	mov	r9,-2
8000ace6:	f2 08 18 00 	cp.b	r8,r9
8000acea:	c6 20       	breq	8000adae <sd_mmc_spi_internal_init+0x5aa>
8000acec:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000acf0:	fe 7c 24 00 	mov	r12,-56320
8000acf4:	e0 a0 07 f7 	rcall	8000bce2 <spi_write>
8000acf8:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000acfa:	fe 7c 24 00 	mov	r12,-56320
8000acfe:	e0 a0 08 00 	rcall	8000bcfe <spi_read>
8000ad02:	58 1c       	cp.w	r12,1
8000ad04:	e0 80 01 5f 	breq	8000afc2 <sd_mmc_spi_internal_init+0x7be>
8000ad08:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
8000ad0a:	ac 88       	st.b	r6[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
8000ad0c:	3f e9       	mov	r9,-2
8000ad0e:	f2 08 18 00 	cp.b	r8,r9
8000ad12:	c4 e0       	breq	8000adae <sd_mmc_spi_internal_init+0x5aa>
8000ad14:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000ad18:	fe 7c 24 00 	mov	r12,-56320
8000ad1c:	e0 a0 07 e3 	rcall	8000bce2 <spi_write>
8000ad20:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000ad22:	fe 7c 24 00 	mov	r12,-56320
8000ad26:	e0 a0 07 ec 	rcall	8000bcfe <spi_read>
8000ad2a:	58 1c       	cp.w	r12,1
8000ad2c:	e0 80 01 53 	breq	8000afd2 <sd_mmc_spi_internal_init+0x7ce>
8000ad30:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
8000ad32:	ac 88       	st.b	r6[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
8000ad34:	3f e9       	mov	r9,-2
8000ad36:	f2 08 18 00 	cp.b	r8,r9
8000ad3a:	c3 a0       	breq	8000adae <sd_mmc_spi_internal_init+0x5aa>
8000ad3c:	30 1b       	mov	r11,1
  {
    if (retry > 8)
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000ad3e:	fe 7c 24 00 	mov	r12,-56320
8000ad42:	e0 a0 07 64 	rcall	8000bc0a <spi_unselectChip>
8000ad46:	2f fd       	sub	sp,-4
8000ad48:	d8 3a       	popm	r0-r7,pc,r12=0
8000ad4a:	a2 84       	st.b	r1[0x0],r4

    r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte

    if ((r1&0xFE) == 0) {   // ignore "in_idle_state" flag bit
      card_type = SD_CARD;    // card has accepted the command, this is a SD card
8000ad4c:	30 18       	mov	r8,1
8000ad4e:	fe 9f fe 64 	bral	8000aa16 <sd_mmc_spi_internal_init+0x212>
8000ad52:	fe b0 fc 2b 	rcall	8000a5a8 <sd_mmc_spi_check_hc>
        return false;
  } while (r1);

  // CHECK FOR SDHC
  if(card_type == SD_CARD_2) {
    if_cond = sd_mmc_spi_check_hc();
8000ad56:	5b fc       	cp.w	r12,-1
    if (if_cond == -1) {
8000ad58:	fe 90 fe 59 	breq	8000aa0a <sd_mmc_spi_internal_init+0x206>
8000ad5c:	58 1c       	cp.w	r12,1
      return false;
    } else if (if_cond == 1){
8000ad5e:	fe 91 fe bb 	brne	8000aad4 <sd_mmc_spi_internal_init+0x2d0>
8000ad62:	30 39       	mov	r9,3
          card_type = SD_CARD_2_SDHC;
8000ad64:	e0 68 0c d2 	mov	r8,3282
8000ad68:	b0 89       	st.b	r8[0x0],r9
8000ad6a:	cb 5a       	rjmp	8000aad4 <sd_mmc_spi_internal_init+0x2d0>
8000ad6c:	30 1b       	mov	r11,1
  // issue command
  r1 = sd_mmc_spi_command(MMC_SEND_CSD, 0);
  // check for valid response
  if(r1 != 0x00)
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000ad6e:	fe 7c 24 00 	mov	r12,-56320
8000ad72:	e0 a0 07 4c 	rcall	8000bc0a <spi_unselectChip>
8000ad76:	30 08       	mov	r8,0
    sd_mmc_spi_init_done = false;
8000ad78:	e0 69 09 84 	mov	r9,2436
8000ad7c:	30 0c       	mov	r12,0
8000ad7e:	b2 88       	st.b	r9[0x0],r8
8000ad80:	fe 9f fe 46 	bral	8000aa0c <sd_mmc_spi_internal_init+0x208>
8000ad84:	3f f8       	mov	r8,-1
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
8000ad86:	aa 88       	st.b	r5[0x0],r8
8000ad88:	c2 2b       	rjmp	8000abcc <sd_mmc_spi_internal_init+0x3c8>
8000ad8a:	3f f8       	mov	r8,-1
8000ad8c:	ac 88       	st.b	r6[0x0],r8
8000ad8e:	c3 4b       	rjmp	8000abf6 <sd_mmc_spi_internal_init+0x3f2>
8000ad90:	3f f8       	mov	r8,-1
8000ad92:	ac 88       	st.b	r6[0x0],r8
8000ad94:	c4 6b       	rjmp	8000ac20 <sd_mmc_spi_internal_init+0x41c>
8000ad96:	3f f8       	mov	r8,-1
8000ad98:	ac 88       	st.b	r6[0x0],r8
8000ad9a:	c5 8b       	rjmp	8000ac4a <sd_mmc_spi_internal_init+0x446>
8000ad9c:	3f f8       	mov	r8,-1
8000ad9e:	ac 88       	st.b	r6[0x0],r8
8000ada0:	c6 ab       	rjmp	8000ac74 <sd_mmc_spi_internal_init+0x470>
8000ada2:	3f f8       	mov	r8,-1
8000ada4:	ac 88       	st.b	r6[0x0],r8
8000ada6:	c7 cb       	rjmp	8000ac9e <sd_mmc_spi_internal_init+0x49a>
8000ada8:	3f f8       	mov	r8,-1
8000adaa:	ac 88       	st.b	r6[0x0],r8
8000adac:	c8 cb       	rjmp	8000acc4 <sd_mmc_spi_internal_init+0x4c0>
8000adae:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000adb2:	fe 7c 24 00 	mov	r12,-56320
8000adb6:	e0 a0 07 96 	rcall	8000bce2 <spi_write>
8000adba:	fa c5 ff fe 	sub	r5,sp,-2
   spi_read(SD_MMC_SPI,&data_read);
8000adbe:	fe 7c 24 00 	mov	r12,-56320
8000adc2:	0a 9b       	mov	r11,r5
8000adc4:	e0 a0 07 9d 	rcall	8000bcfe <spi_read>
8000adc8:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
8000adca:	e0 66 0c d4 	mov	r6,3284
8000adce:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000add2:	ac 88       	st.b	r6[0x0],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
8000add4:	fe 7c 24 00 	mov	r12,-56320
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000add8:	e0 a0 07 85 	rcall	8000bce2 <spi_write>
8000addc:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
8000adde:	fe 7c 24 00 	mov	r12,-56320
8000ade2:	e0 a0 07 8e 	rcall	8000bcfe <spi_read>
8000ade6:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
8000ade8:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000adec:	ac 98       	st.b	r6[0x1],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
8000adee:	fe 7c 24 00 	mov	r12,-56320
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000adf2:	e0 a0 07 78 	rcall	8000bce2 <spi_write>
8000adf6:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
8000adf8:	fe 7c 24 00 	mov	r12,-56320
8000adfc:	e0 a0 07 81 	rcall	8000bcfe <spi_read>
8000ae00:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
8000ae02:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000ae06:	ac a8       	st.b	r6[0x2],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
8000ae08:	fe 7c 24 00 	mov	r12,-56320
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000ae0c:	e0 a0 07 6b 	rcall	8000bce2 <spi_write>
8000ae10:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
8000ae12:	fe 7c 24 00 	mov	r12,-56320
8000ae16:	e0 a0 07 74 	rcall	8000bcfe <spi_read>
8000ae1a:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
8000ae1c:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000ae20:	ac b8       	st.b	r6[0x3],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
8000ae22:	fe 7c 24 00 	mov	r12,-56320
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000ae26:	e0 a0 07 5e 	rcall	8000bce2 <spi_write>
8000ae2a:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
8000ae2c:	fe 7c 24 00 	mov	r12,-56320
8000ae30:	e0 a0 07 67 	rcall	8000bcfe <spi_read>
8000ae34:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
8000ae36:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000ae3a:	ac c8       	st.b	r6[0x4],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
8000ae3c:	fe 7c 24 00 	mov	r12,-56320
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000ae40:	e0 a0 07 51 	rcall	8000bce2 <spi_write>
8000ae44:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
8000ae46:	fe 7c 24 00 	mov	r12,-56320
8000ae4a:	e0 a0 07 5a 	rcall	8000bcfe <spi_read>
8000ae4e:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
8000ae50:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000ae54:	ac d8       	st.b	r6[0x5],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
8000ae56:	fe 7c 24 00 	mov	r12,-56320
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000ae5a:	e0 a0 07 44 	rcall	8000bce2 <spi_write>
8000ae5e:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
8000ae60:	fe 7c 24 00 	mov	r12,-56320
8000ae64:	e0 a0 07 4d 	rcall	8000bcfe <spi_read>
8000ae68:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
8000ae6a:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000ae6e:	ac e8       	st.b	r6[0x6],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
8000ae70:	fe 7c 24 00 	mov	r12,-56320
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000ae74:	e0 a0 07 37 	rcall	8000bce2 <spi_write>
8000ae78:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
8000ae7a:	fe 7c 24 00 	mov	r12,-56320
8000ae7e:	e0 a0 07 40 	rcall	8000bcfe <spi_read>
8000ae82:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
8000ae84:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000ae88:	ac f8       	st.b	r6[0x7],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
8000ae8a:	fe 7c 24 00 	mov	r12,-56320
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000ae8e:	e0 a0 07 2a 	rcall	8000bce2 <spi_write>
8000ae92:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
8000ae94:	fe 7c 24 00 	mov	r12,-56320
8000ae98:	e0 a0 07 33 	rcall	8000bcfe <spi_read>
8000ae9c:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
8000ae9e:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000aea2:	ed 68 00 08 	st.b	r6[8],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
8000aea6:	fe 7c 24 00 	mov	r12,-56320
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000aeaa:	e0 a0 07 1c 	rcall	8000bce2 <spi_write>
8000aeae:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
8000aeb0:	fe 7c 24 00 	mov	r12,-56320
8000aeb4:	e0 a0 07 25 	rcall	8000bcfe <spi_read>
8000aeb8:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
8000aeba:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000aebe:	ed 68 00 09 	st.b	r6[9],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
8000aec2:	fe 7c 24 00 	mov	r12,-56320
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000aec6:	e0 a0 07 0e 	rcall	8000bce2 <spi_write>
8000aeca:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
8000aecc:	fe 7c 24 00 	mov	r12,-56320
8000aed0:	e0 a0 07 17 	rcall	8000bcfe <spi_read>
8000aed4:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
8000aed6:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000aeda:	ed 68 00 0a 	st.b	r6[10],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
8000aede:	fe 7c 24 00 	mov	r12,-56320
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000aee2:	e0 a0 07 00 	rcall	8000bce2 <spi_write>
8000aee6:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
8000aee8:	fe 7c 24 00 	mov	r12,-56320
8000aeec:	e0 a0 07 09 	rcall	8000bcfe <spi_read>
8000aef0:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
8000aef2:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000aef6:	ed 68 00 0b 	st.b	r6[11],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
8000aefa:	fe 7c 24 00 	mov	r12,-56320
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000aefe:	e0 a0 06 f2 	rcall	8000bce2 <spi_write>
8000af02:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
8000af04:	fe 7c 24 00 	mov	r12,-56320
8000af08:	e0 a0 06 fb 	rcall	8000bcfe <spi_read>
8000af0c:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
8000af0e:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000af12:	ed 68 00 0c 	st.b	r6[12],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
8000af16:	fe 7c 24 00 	mov	r12,-56320
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000af1a:	e0 a0 06 e4 	rcall	8000bce2 <spi_write>
8000af1e:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
8000af20:	fe 7c 24 00 	mov	r12,-56320
8000af24:	e0 a0 06 ed 	rcall	8000bcfe <spi_read>
8000af28:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
8000af2a:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000af2e:	ed 68 00 0d 	st.b	r6[13],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
8000af32:	fe 7c 24 00 	mov	r12,-56320
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000af36:	e0 a0 06 d6 	rcall	8000bce2 <spi_write>
8000af3a:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
8000af3c:	fe 7c 24 00 	mov	r12,-56320
8000af40:	e0 a0 06 df 	rcall	8000bcfe <spi_read>
8000af44:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
8000af46:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000af4a:	ed 68 00 0e 	st.b	r6[14],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
8000af4e:	fe 7c 24 00 	mov	r12,-56320
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000af52:	e0 a0 06 c8 	rcall	8000bce2 <spi_write>
8000af56:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
8000af58:	fe 7c 24 00 	mov	r12,-56320
8000af5c:	e0 a0 06 d1 	rcall	8000bcfe <spi_read>
8000af60:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
8000af62:	e0 6b 00 ff 	mov	r11,255
  }
   spi_write(SD_MMC_SPI,0xFF);   // load CRC (not used)
8000af66:	ed 68 00 0f 	st.b	r6[15],r8
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
8000af6a:	fe 7c 24 00 	mov	r12,-56320
  }
   spi_write(SD_MMC_SPI,0xFF);   // load CRC (not used)
8000af6e:	e0 a0 06 ba 	rcall	8000bce2 <spi_write>
8000af72:	e0 6b 00 ff 	mov	r11,255
   spi_write(SD_MMC_SPI,0xFF);
8000af76:	fe 7c 24 00 	mov	r12,-56320
8000af7a:	e0 a0 06 b4 	rcall	8000bce2 <spi_write>
8000af7e:	e0 6b 00 ff 	mov	r11,255
   spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction
8000af82:	fe 7c 24 00 	mov	r12,-56320
8000af86:	e0 a0 06 ae 	rcall	8000bce2 <spi_write>
8000af8a:	30 1b       	mov	r11,1
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000af8c:	fe 7c 24 00 	mov	r12,-56320
8000af90:	e0 a0 06 3d 	rcall	8000bc0a <spi_unselectChip>
8000af94:	fe b0 f6 76 	rcall	80009c80 <sd_mmc_spi_get_capacity>
  // GET CARD SPECIFIC DATA
  if (false ==  sd_mmc_spi_get_csd(csd))
    return false;

  // GET CARD CAPACITY and NUMBER OF SECTORS
  sd_mmc_spi_get_capacity();
8000af98:	e0 68 09 80 	mov	r8,2432

  sd_mmc_spi_init_done = true;

  // Set SPI Speed to MAX
  sd_mmc_opt.baudrate = SD_MMC_SPI_MASTER_SPEED;
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
8000af9c:	70 0a       	ld.w	r10,r8[0x0]
#if (defined SD_MMC_READ_CID) && (SD_MMC_READ_CID == true)
  if (false ==  sd_mmc_spi_get_cid(cid))
    return false;
#endif

  sd_mmc_spi_init_done = true;
8000af9e:	30 18       	mov	r8,1
8000afa0:	e0 69 09 84 	mov	r9,2436

  // Set SPI Speed to MAX
  sd_mmc_opt.baudrate = SD_MMC_SPI_MASTER_SPEED;
8000afa4:	b2 88       	st.b	r9[0x0],r8
8000afa6:	e0 68 1b 00 	mov	r8,6912
8000afaa:	ea 18 00 b7 	orh	r8,0xb7
8000afae:	e0 6b 09 70 	mov	r11,2416
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
8000afb2:	8f 18       	st.w	r7[0x4],r8
8000afb4:	fe 7c 24 00 	mov	r12,-56320
8000afb8:	e0 a0 06 3c 	rcall	8000bc30 <spi_setupChipReg>
  return true;
8000afbc:	30 1c       	mov	r12,1
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
8000afbe:	fe 9f fd 27 	bral	8000aa0c <sd_mmc_spi_internal_init+0x208>
8000afc2:	3f f8       	mov	r8,-1
8000afc4:	ac 88       	st.b	r6[0x0],r8
8000afc6:	fe 9f fe a7 	bral	8000ad14 <sd_mmc_spi_internal_init+0x510>
8000afca:	3f f8       	mov	r8,-1
8000afcc:	ac 88       	st.b	r6[0x0],r8
8000afce:	fe 9f fe 8f 	bral	8000acec <sd_mmc_spi_internal_init+0x4e8>
8000afd2:	3f f8       	mov	r8,-1
8000afd4:	ac 88       	st.b	r6[0x0],r8
8000afd6:	fe 9f fe b3 	bral	8000ad3c <sd_mmc_spi_internal_init+0x538>
8000afda:	d7 03       	nop

8000afdc <sd_mmc_spi_mem_check>:
8000afdc:	eb cd 40 e0 	pushm	r5-r7,lr
8000afe0:	e0 65 09 84 	mov	r5,2436
8000afe4:	30 07       	mov	r7,0
8000afe6:	0b 88       	ld.ub	r8,r5[0x0]
8000afe8:	ee 08 18 00 	cp.b	r8,r7
8000afec:	e0 81 01 2c 	brne	8000b244 <sd_mmc_spi_mem_check+0x268>
8000aff0:	30 1b       	mov	r11,1
8000aff2:	fe 7c 24 00 	mov	r12,-56320
8000aff6:	e0 a0 05 e2 	rcall	8000bbba <spi_selectChip>
8000affa:	30 0b       	mov	r11,0
8000affc:	16 9c       	mov	r12,r11
8000affe:	fe b0 f6 ed 	rcall	80009dd8 <sd_mmc_spi_command>
8000b002:	30 1b       	mov	r11,1
8000b004:	e0 67 0c e4 	mov	r7,3300
8000b008:	ae 8c       	st.b	r7[0x0],r12
8000b00a:	fe 7c 24 00 	mov	r12,-56320
8000b00e:	e0 a0 05 fe 	rcall	8000bc0a <spi_unselectChip>
8000b012:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
8000b014:	ae 88       	st.b	r7[0x0],r8
8000b016:	30 16       	mov	r6,1
8000b018:	ec 08 18 00 	cp.b	r8,r6
8000b01c:	e0 80 01 29 	breq	8000b26e <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000b020:	e0 6b 00 ff 	mov	r11,255
8000b024:	fe 7c 24 00 	mov	r12,-56320
8000b028:	e0 a0 06 5d 	rcall	8000bce2 <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000b02c:	30 1b       	mov	r11,1
8000b02e:	fe 7c 24 00 	mov	r12,-56320
8000b032:	e0 a0 05 c4 	rcall	8000bbba <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
8000b036:	30 0b       	mov	r11,0
8000b038:	16 9c       	mov	r12,r11
8000b03a:	fe b0 f6 cf 	rcall	80009dd8 <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000b03e:	30 1b       	mov	r11,1
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000b040:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000b042:	fe 7c 24 00 	mov	r12,-56320
8000b046:	e0 a0 05 e2 	rcall	8000bc0a <spi_unselectChip>
  return r1;
8000b04a:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
8000b04c:	ae 88       	st.b	r7[0x0],r8
8000b04e:	ec 08 18 00 	cp.b	r8,r6
8000b052:	e0 80 01 0e 	breq	8000b26e <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000b056:	e0 6b 00 ff 	mov	r11,255
8000b05a:	fe 7c 24 00 	mov	r12,-56320
8000b05e:	e0 a0 06 42 	rcall	8000bce2 <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000b062:	30 1b       	mov	r11,1
8000b064:	fe 7c 24 00 	mov	r12,-56320
8000b068:	e0 a0 05 a9 	rcall	8000bbba <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
8000b06c:	30 0b       	mov	r11,0
8000b06e:	16 9c       	mov	r12,r11
8000b070:	fe b0 f6 b4 	rcall	80009dd8 <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000b074:	30 1b       	mov	r11,1
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000b076:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000b078:	fe 7c 24 00 	mov	r12,-56320
8000b07c:	e0 a0 05 c7 	rcall	8000bc0a <spi_unselectChip>
  return r1;
8000b080:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
8000b082:	ae 88       	st.b	r7[0x0],r8
8000b084:	ec 08 18 00 	cp.b	r8,r6
8000b088:	e0 80 00 f3 	breq	8000b26e <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000b08c:	e0 6b 00 ff 	mov	r11,255
8000b090:	fe 7c 24 00 	mov	r12,-56320
8000b094:	e0 a0 06 27 	rcall	8000bce2 <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000b098:	30 1b       	mov	r11,1
8000b09a:	fe 7c 24 00 	mov	r12,-56320
8000b09e:	e0 a0 05 8e 	rcall	8000bbba <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
8000b0a2:	30 0b       	mov	r11,0
8000b0a4:	16 9c       	mov	r12,r11
8000b0a6:	fe b0 f6 99 	rcall	80009dd8 <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000b0aa:	30 1b       	mov	r11,1
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000b0ac:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000b0ae:	fe 7c 24 00 	mov	r12,-56320
8000b0b2:	e0 a0 05 ac 	rcall	8000bc0a <spi_unselectChip>
  return r1;
8000b0b6:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
8000b0b8:	ae 88       	st.b	r7[0x0],r8
8000b0ba:	ec 08 18 00 	cp.b	r8,r6
8000b0be:	e0 80 00 d8 	breq	8000b26e <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000b0c2:	e0 6b 00 ff 	mov	r11,255
8000b0c6:	fe 7c 24 00 	mov	r12,-56320
8000b0ca:	e0 a0 06 0c 	rcall	8000bce2 <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000b0ce:	30 1b       	mov	r11,1
8000b0d0:	fe 7c 24 00 	mov	r12,-56320
8000b0d4:	e0 a0 05 73 	rcall	8000bbba <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
8000b0d8:	30 0b       	mov	r11,0
8000b0da:	16 9c       	mov	r12,r11
8000b0dc:	fe b0 f6 7e 	rcall	80009dd8 <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000b0e0:	30 1b       	mov	r11,1
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000b0e2:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000b0e4:	fe 7c 24 00 	mov	r12,-56320
8000b0e8:	e0 a0 05 91 	rcall	8000bc0a <spi_unselectChip>
  return r1;
8000b0ec:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
8000b0ee:	ae 88       	st.b	r7[0x0],r8
8000b0f0:	ec 08 18 00 	cp.b	r8,r6
8000b0f4:	e0 80 00 bd 	breq	8000b26e <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000b0f8:	e0 6b 00 ff 	mov	r11,255
8000b0fc:	fe 7c 24 00 	mov	r12,-56320
8000b100:	e0 a0 05 f1 	rcall	8000bce2 <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000b104:	30 1b       	mov	r11,1
8000b106:	fe 7c 24 00 	mov	r12,-56320
8000b10a:	e0 a0 05 58 	rcall	8000bbba <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
8000b10e:	30 0b       	mov	r11,0
8000b110:	16 9c       	mov	r12,r11
8000b112:	fe b0 f6 63 	rcall	80009dd8 <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000b116:	30 1b       	mov	r11,1
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000b118:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000b11a:	fe 7c 24 00 	mov	r12,-56320
8000b11e:	e0 a0 05 76 	rcall	8000bc0a <spi_unselectChip>
  return r1;
8000b122:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
8000b124:	ae 88       	st.b	r7[0x0],r8
8000b126:	ec 08 18 00 	cp.b	r8,r6
8000b12a:	e0 80 00 a2 	breq	8000b26e <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000b12e:	e0 6b 00 ff 	mov	r11,255
8000b132:	fe 7c 24 00 	mov	r12,-56320
8000b136:	e0 a0 05 d6 	rcall	8000bce2 <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000b13a:	30 1b       	mov	r11,1
8000b13c:	fe 7c 24 00 	mov	r12,-56320
8000b140:	e0 a0 05 3d 	rcall	8000bbba <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
8000b144:	30 0b       	mov	r11,0
8000b146:	16 9c       	mov	r12,r11
8000b148:	fe b0 f6 48 	rcall	80009dd8 <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000b14c:	30 1b       	mov	r11,1
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000b14e:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000b150:	fe 7c 24 00 	mov	r12,-56320
8000b154:	e0 a0 05 5b 	rcall	8000bc0a <spi_unselectChip>
  return r1;
8000b158:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
8000b15a:	ae 88       	st.b	r7[0x0],r8
8000b15c:	ec 08 18 00 	cp.b	r8,r6
8000b160:	e0 80 00 87 	breq	8000b26e <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000b164:	e0 6b 00 ff 	mov	r11,255
8000b168:	fe 7c 24 00 	mov	r12,-56320
8000b16c:	e0 a0 05 bb 	rcall	8000bce2 <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000b170:	30 1b       	mov	r11,1
8000b172:	fe 7c 24 00 	mov	r12,-56320
8000b176:	e0 a0 05 22 	rcall	8000bbba <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
8000b17a:	30 0b       	mov	r11,0
8000b17c:	16 9c       	mov	r12,r11
8000b17e:	fe b0 f6 2d 	rcall	80009dd8 <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000b182:	30 1b       	mov	r11,1
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000b184:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000b186:	fe 7c 24 00 	mov	r12,-56320
8000b18a:	e0 a0 05 40 	rcall	8000bc0a <spi_unselectChip>
  return r1;
8000b18e:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
8000b190:	ae 88       	st.b	r7[0x0],r8
8000b192:	ec 08 18 00 	cp.b	r8,r6
8000b196:	c6 c0       	breq	8000b26e <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000b198:	e0 6b 00 ff 	mov	r11,255
8000b19c:	fe 7c 24 00 	mov	r12,-56320
8000b1a0:	e0 a0 05 a1 	rcall	8000bce2 <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000b1a4:	30 1b       	mov	r11,1
8000b1a6:	fe 7c 24 00 	mov	r12,-56320
8000b1aa:	e0 a0 05 08 	rcall	8000bbba <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
8000b1ae:	30 0b       	mov	r11,0
8000b1b0:	16 9c       	mov	r12,r11
8000b1b2:	fe b0 f6 13 	rcall	80009dd8 <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000b1b6:	30 1b       	mov	r11,1
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000b1b8:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000b1ba:	fe 7c 24 00 	mov	r12,-56320
8000b1be:	e0 a0 05 26 	rcall	8000bc0a <spi_unselectChip>
  return r1;
8000b1c2:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
8000b1c4:	ae 88       	st.b	r7[0x0],r8
8000b1c6:	ec 08 18 00 	cp.b	r8,r6
8000b1ca:	c5 20       	breq	8000b26e <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000b1cc:	e0 6b 00 ff 	mov	r11,255
8000b1d0:	fe 7c 24 00 	mov	r12,-56320
8000b1d4:	e0 a0 05 87 	rcall	8000bce2 <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000b1d8:	30 1b       	mov	r11,1
8000b1da:	fe 7c 24 00 	mov	r12,-56320
8000b1de:	e0 a0 04 ee 	rcall	8000bbba <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
8000b1e2:	30 0b       	mov	r11,0
8000b1e4:	16 9c       	mov	r12,r11
8000b1e6:	fe b0 f5 f9 	rcall	80009dd8 <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000b1ea:	30 1b       	mov	r11,1
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000b1ec:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000b1ee:	fe 7c 24 00 	mov	r12,-56320
8000b1f2:	e0 a0 05 0c 	rcall	8000bc0a <spi_unselectChip>
  return r1;
8000b1f6:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
8000b1f8:	ae 88       	st.b	r7[0x0],r8
8000b1fa:	ec 08 18 00 	cp.b	r8,r6
8000b1fe:	c3 80       	breq	8000b26e <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000b200:	e0 6b 00 ff 	mov	r11,255
8000b204:	fe 7c 24 00 	mov	r12,-56320
8000b208:	e0 a0 05 6d 	rcall	8000bce2 <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000b20c:	30 1b       	mov	r11,1
8000b20e:	fe 7c 24 00 	mov	r12,-56320
8000b212:	e0 a0 04 d4 	rcall	8000bbba <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
8000b216:	30 0b       	mov	r11,0
8000b218:	16 9c       	mov	r12,r11
8000b21a:	fe b0 f5 df 	rcall	80009dd8 <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000b21e:	30 1b       	mov	r11,1
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000b220:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000b222:	fe 7c 24 00 	mov	r12,-56320
8000b226:	e0 a0 04 f2 	rcall	8000bc0a <spi_unselectChip>
  return r1;
8000b22a:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
8000b22c:	ae 88       	st.b	r7[0x0],r8
8000b22e:	ec 08 18 00 	cp.b	r8,r6
8000b232:	c1 e0       	breq	8000b26e <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000b234:	e0 6b 00 ff 	mov	r11,255
8000b238:	fe 7c 24 00 	mov	r12,-56320
8000b23c:	e0 a0 05 53 	rcall	8000bce2 <spi_write>
8000b240:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000b244:	30 1b       	mov	r11,1
8000b246:	fe 7c 24 00 	mov	r12,-56320
8000b24a:	e0 a0 04 b8 	rcall	8000bbba <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
8000b24e:	30 0b       	mov	r11,0
8000b250:	33 bc       	mov	r12,59
8000b252:	fe b0 f5 c3 	rcall	80009dd8 <sd_mmc_spi_command>
8000b256:	e0 66 0c e4 	mov	r6,3300
8000b25a:	30 1b       	mov	r11,1
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000b25c:	ac 8c       	st.b	r6[0x0],r12
8000b25e:	fe 7c 24 00 	mov	r12,-56320
8000b262:	e0 a0 04 d4 	rcall	8000bc0a <spi_unselectChip>
    return true;
  }
  else
  {
    // If memory already initialized, send a CRC command (CMD59) (supported only if card is initialized)
    if ((r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0)) == 0x00)
8000b266:	0d 88       	ld.ub	r8,r6[0x0]
8000b268:	ac 88       	st.b	r6[0x0],r8
8000b26a:	58 08       	cp.w	r8,0
//!   The memory check failed -> false
bool sd_mmc_spi_mem_check(void)
{
  if (sd_mmc_spi_check_presence())
  {
    if (sd_mmc_spi_init_done == false)
8000b26c:	c0 c1       	brne	8000b284 <sd_mmc_spi_mem_check+0x2a8>
8000b26e:	0b 89       	ld.ub	r9,r5[0x0]
8000b270:	30 08       	mov	r8,0
8000b272:	f0 09 18 00 	cp.b	r9,r8
8000b276:	c0 30       	breq	8000b27c <sd_mmc_spi_mem_check+0x2a0>
8000b278:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
    {
      return sd_mmc_spi_internal_init();
8000b27c:	fe b0 fa c4 	rcall	8000a804 <sd_mmc_spi_internal_init>
    }
    else
      return true;
  }
  return false;
}
8000b280:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
  else
  {
    // If memory already initialized, send a CRC command (CMD59) (supported only if card is initialized)
    if ((r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0)) == 0x00)
      return true;
    sd_mmc_spi_init_done = false;
8000b284:	aa 87       	st.b	r5[0x0],r7
8000b286:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
8000b28a:	d7 03       	nop

8000b28c <sd_mmc_spi_init>:
8000b28c:	eb cd 40 10 	pushm	r4,lr
8000b290:	e0 68 09 70 	mov	r8,2416
8000b294:	fa c4 ff f8 	sub	r4,sp,-8
8000b298:	e8 ea 00 08 	ld.d	r10,r4[8]
8000b29c:	f0 eb 00 08 	st.d	r8[8],r10
8000b2a0:	e0 69 09 80 	mov	r9,2432
//!   The memory is ready     -> true (always)
bool sd_mmc_spi_init(spi_options_t spiOptions, unsigned int pba_hz)
{
  // Keep SPI options internally
  sd_mmc_pba_hz = pba_hz;
  memcpy( &sd_mmc_opt, &spiOptions, sizeof(spi_options_t) );
8000b2a4:	93 0c       	st.w	r9[0x0],r12
8000b2a6:	e8 ea 00 00 	ld.d	r10,r4[0]

  // Initialize the SD/MMC controller.
  return sd_mmc_spi_internal_init();
8000b2aa:	f0 eb 00 00 	st.d	r8[0],r10
}
8000b2ae:	fe b0 fa ab 	rcall	8000a804 <sd_mmc_spi_internal_init>
8000b2b2:	e3 cd 80 10 	ldm	sp++,r4,pc
8000b2b6:	d7 03       	nop

8000b2b8 <sd_mmc_spi_write_sector_from_ram>:
8000b2b8:	eb cd 40 fc 	pushm	r2-r7,lr
8000b2bc:	20 1d       	sub	sp,4
8000b2be:	30 1b       	mov	r11,1
//! @return bit
//!   The write succeeded   -> true
//!   The write failed      -> false
//!
bool sd_mmc_spi_write_sector_from_ram(const void *ram)
{
8000b2c0:	18 97       	mov	r7,r12
bool sd_mmc_spi_wait_not_busy(void)
{
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000b2c2:	30 06       	mov	r6,0
8000b2c4:	fe 7c 24 00 	mov	r12,-56320
8000b2c8:	fa c4 ff fe 	sub	r4,sp,-2
8000b2cc:	e0 a0 04 77 	rcall	8000bbba <spi_selectChip>
8000b2d0:	e0 65 0c e4 	mov	r5,3300
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
8000b2d4:	3f f3       	mov	r3,-1
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
     return 0xFF;
   return data_read;
8000b2d6:	c0 98       	rjmp	8000b2e8 <sd_mmc_spi_write_sector_from_ram+0x30>
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
8000b2d8:	1b b8       	ld.ub	r8,sp[0x3]
8000b2da:	aa 88       	st.b	r5[0x0],r8
8000b2dc:	e6 08 18 00 	cp.b	r8,r3
  {
    retry++;
    if (retry == 200000)
8000b2e0:	c1 40       	breq	8000b308 <sd_mmc_spi_write_sector_from_ram+0x50>
8000b2e2:	e2 56 0d 40 	cp.w	r6,200000
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000b2e6:	c6 b0       	breq	8000b3bc <sd_mmc_spi_write_sector_from_ram+0x104>
8000b2e8:	e0 6b 00 ff 	mov	r11,255
8000b2ec:	fe 7c 24 00 	mov	r12,-56320
8000b2f0:	e0 a0 04 f9 	rcall	8000bce2 <spi_write>
bool sd_mmc_spi_wait_not_busy(void)
{
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000b2f4:	08 9b       	mov	r11,r4
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000b2f6:	2f f6       	sub	r6,-1
8000b2f8:	fe 7c 24 00 	mov	r12,-56320
8000b2fc:	e0 a0 05 01 	rcall	8000bcfe <spi_read>
8000b300:	58 1c       	cp.w	r12,1
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
8000b302:	ce b1       	brne	8000b2d8 <sd_mmc_spi_write_sector_from_ram+0x20>
8000b304:	3f f8       	mov	r8,-1
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
      return false;
    }
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000b306:	aa 88       	st.b	r5[0x0],r8
8000b308:	30 1b       	mov	r11,1
8000b30a:	fe 7c 24 00 	mov	r12,-56320
8000b30e:	e0 a0 04 7e 	rcall	8000bc0a <spi_unselectChip>

  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000b312:	30 1b       	mov	r11,1
8000b314:	fe 7c 24 00 	mov	r12,-56320
8000b318:	e0 a0 04 51 	rcall	8000bbba <spi_selectChip>

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
8000b31c:	e0 68 0c d2 	mov	r8,3282
8000b320:	11 89       	ld.ub	r9,r8[0x0]
8000b322:	30 38       	mov	r8,3
8000b324:	f0 09 18 00 	cp.b	r9,r8
    r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem>>9);
  } else {
    r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem);
8000b328:	c5 20       	breq	8000b3cc <sd_mmc_spi_write_sector_from_ram+0x114>
8000b32a:	e0 63 09 6c 	mov	r3,2412
8000b32e:	31 8c       	mov	r12,24
8000b330:	66 0b       	ld.w	r11,r3[0x0]
  }

  // check for valid response
  if(r1 != 0x00)
8000b332:	fe b0 f5 53 	rcall	80009dd8 <sd_mmc_spi_command>
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
    return false;
  }
  // send dummy
  spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction
8000b336:	aa 8c       	st.b	r5[0x0],r12
8000b338:	58 0c       	cp.w	r12,0
8000b33a:	c4 11       	brne	8000b3bc <sd_mmc_spi_write_sector_from_ram+0x104>
8000b33c:	e0 6b 00 ff 	mov	r11,255
8000b340:	fe 7c 24 00 	mov	r12,-56320

  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
8000b344:	e0 a0 04 cf 	rcall	8000bce2 <spi_write>
8000b348:	e0 6b 00 fe 	mov	r11,254
//!
//! @return bit
//!   The write succeeded   -> true
//!   The write failed      -> false
//!
bool sd_mmc_spi_write_sector_from_ram(const void *ram)
8000b34c:	fe 7c 24 00 	mov	r12,-56320
  }
  // send dummy
  spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction

  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
8000b350:	ee c6 fe 00 	sub	r6,r7,-512
  // write data
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,*_ram++);
8000b354:	e0 a0 04 c7 	rcall	8000bce2 <spi_write>
8000b358:	0f 3b       	ld.ub	r11,r7++
8000b35a:	fe 7c 24 00 	mov	r12,-56320
  spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction

  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
  // write data
  for(i=0;i<MMC_SECTOR_SIZE;i++)
8000b35e:	e0 a0 04 c2 	rcall	8000bce2 <spi_write>
  {
    spi_write(SD_MMC_SPI,*_ram++);
  }

  spi_write(SD_MMC_SPI,0xFF);    // send CRC (field required but value ignored)
8000b362:	0c 37       	cp.w	r7,r6
8000b364:	cf a1       	brne	8000b358 <sd_mmc_spi_write_sector_from_ram+0xa0>
8000b366:	e0 6b 00 ff 	mov	r11,255
8000b36a:	fe 7c 24 00 	mov	r12,-56320
  spi_write(SD_MMC_SPI,0xFF);
8000b36e:	e0 a0 04 ba 	rcall	8000bce2 <spi_write>
8000b372:	e0 6b 00 ff 	mov	r11,255
8000b376:	fe 7c 24 00 	mov	r12,-56320
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000b37a:	e0 a0 04 b4 	rcall	8000bce2 <spi_write>
8000b37e:	e0 6b 00 ff 	mov	r11,255
8000b382:	fe 7c 24 00 	mov	r12,-56320
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000b386:	e0 a0 04 ae 	rcall	8000bce2 <spi_write>
8000b38a:	08 9b       	mov	r11,r4
8000b38c:	fe 7c 24 00 	mov	r12,-56320
8000b390:	e0 a0 04 b7 	rcall	8000bcfe <spi_read>

  spi_write(SD_MMC_SPI,0xFF);    // send CRC (field required but value ignored)
  spi_write(SD_MMC_SPI,0xFF);

  // read data response token
  r1 = sd_mmc_spi_send_and_read(0xFF);
8000b394:	58 1c       	cp.w	r12,1
  if( (r1&MMC_DR_MASK) != MMC_DR_ACCEPT)
8000b396:	c6 b0       	breq	8000b46c <sd_mmc_spi_write_sector_from_ram+0x1b4>
8000b398:	1b b8       	ld.ub	r8,sp[0x3]
8000b39a:	aa 88       	st.b	r5[0x0],r8
8000b39c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
  {
    spi_write(SD_MMC_SPI,0xFF);    // send dummy bytes
8000b3a0:	58 58       	cp.w	r8,5
8000b3a2:	c1 e0       	breq	8000b3de <sd_mmc_spi_write_sector_from_ram+0x126>
8000b3a4:	e0 6b 00 ff 	mov	r11,255
8000b3a8:	fe 7c 24 00 	mov	r12,-56320
    spi_write(SD_MMC_SPI,0xFF);
8000b3ac:	e0 a0 04 9b 	rcall	8000bce2 <spi_write>
8000b3b0:	e0 6b 00 ff 	mov	r11,255
8000b3b4:	fe 7c 24 00 	mov	r12,-56320
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000b3b8:	e0 a0 04 95 	rcall	8000bce2 <spi_write>
8000b3bc:	30 1b       	mov	r11,1
8000b3be:	fe 7c 24 00 	mov	r12,-56320
8000b3c2:	e0 a0 04 24 	rcall	8000bc0a <spi_unselectChip>

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
    r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem>>9);
8000b3c6:	2f fd       	sub	sp,-4
8000b3c8:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
8000b3cc:	e0 63 09 6c 	mov	r3,2412
8000b3d0:	31 8c       	mov	r12,24
8000b3d2:	66 0b       	ld.w	r11,r3[0x0]
8000b3d4:	a9 9b       	lsr	r11,0x9
    spi_write(SD_MMC_SPI,0xFF);
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
    return false;         // return ERROR byte
  }

  spi_write(SD_MMC_SPI,0xFF);    // send dummy bytes
8000b3d6:	fe b0 f5 01 	rcall	80009dd8 <sd_mmc_spi_command>
8000b3da:	aa 8c       	st.b	r5[0x0],r12
8000b3dc:	ca eb       	rjmp	8000b338 <sd_mmc_spi_write_sector_from_ram+0x80>
8000b3de:	e0 6b 00 ff 	mov	r11,255
  spi_write(SD_MMC_SPI,0xFF);
8000b3e2:	fe 7c 24 00 	mov	r12,-56320
8000b3e6:	e0 a0 04 7e 	rcall	8000bce2 <spi_write>
8000b3ea:	e0 6b 00 ff 	mov	r11,255

  // release chip select
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000b3ee:	fe 7c 24 00 	mov	r12,-56320
8000b3f2:	e0 a0 04 78 	rcall	8000bce2 <spi_write>
8000b3f6:	30 1b       	mov	r11,1
  gl_ptr_mem += 512;        // Update the memory pointer.
8000b3f8:	fe 7c 24 00 	mov	r12,-56320
8000b3fc:	e0 a0 04 07 	rcall	8000bc0a <spi_unselectChip>
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
8000b400:	66 08       	ld.w	r8,r3[0x0]
  spi_write(SD_MMC_SPI,0xFF);    // send dummy bytes
  spi_write(SD_MMC_SPI,0xFF);

  // release chip select
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
  gl_ptr_mem += 512;        // Update the memory pointer.
8000b402:	30 02       	mov	r2,0
bool sd_mmc_spi_wait_not_busy(void)
{
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000b404:	f0 c8 fe 00 	sub	r8,r8,-512
8000b408:	3f f6       	mov	r6,-1
8000b40a:	87 08       	st.w	r3[0x0],r8
8000b40c:	30 1b       	mov	r11,1
8000b40e:	fe 7c 24 00 	mov	r12,-56320
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
     return 0xFF;
   return data_read;
8000b412:	e0 a0 03 d4 	rcall	8000bbba <spi_selectChip>
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
8000b416:	30 07       	mov	r7,0
8000b418:	c0 98       	rjmp	8000b42a <sd_mmc_spi_write_sector_from_ram+0x172>
8000b41a:	1b b8       	ld.ub	r8,sp[0x3]
  {
    retry++;
    if (retry == 200000)
8000b41c:	aa 88       	st.b	r5[0x0],r8
8000b41e:	ec 08 18 00 	cp.b	r8,r6
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000b422:	c1 40       	breq	8000b44a <sd_mmc_spi_write_sector_from_ram+0x192>
8000b424:	e2 57 0d 40 	cp.w	r7,200000
8000b428:	c1 90       	breq	8000b45a <sd_mmc_spi_write_sector_from_ram+0x1a2>
8000b42a:	e0 6b 00 ff 	mov	r11,255
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000b42e:	fe 7c 24 00 	mov	r12,-56320
8000b432:	e0 a0 04 58 	rcall	8000bce2 <spi_write>
8000b436:	08 9b       	mov	r11,r4
8000b438:	2f f7       	sub	r7,-1
8000b43a:	fe 7c 24 00 	mov	r12,-56320
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
8000b43e:	e0 a0 04 60 	rcall	8000bcfe <spi_read>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
      return false;
    }
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000b442:	58 1c       	cp.w	r12,1
8000b444:	ce b1       	brne	8000b41a <sd_mmc_spi_write_sector_from_ram+0x162>
8000b446:	3f f8       	mov	r8,-1
8000b448:	aa 88       	st.b	r5[0x0],r8
8000b44a:	30 1b       	mov	r11,1
8000b44c:	fe 7c 24 00 	mov	r12,-56320
8000b450:	e0 a0 03 dd 	rcall	8000bc0a <spi_unselectChip>
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
  {
    retry++;
    if (retry == 200000)
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000b454:	2f fd       	sub	sp,-4
8000b456:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
8000b45a:	2f f2       	sub	r2,-1
8000b45c:	30 1b       	mov	r11,1
  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
  {
    i++;
    if (i == 10)
8000b45e:	fe 7c 24 00 	mov	r12,-56320
8000b462:	e0 a0 03 d4 	rcall	8000bc0a <spi_unselectChip>

  spi_write(SD_MMC_SPI,0xFF);    // send CRC (field required but value ignored)
  spi_write(SD_MMC_SPI,0xFF);

  // read data response token
  r1 = sd_mmc_spi_send_and_read(0xFF);
8000b466:	58 a2       	cp.w	r2,10
8000b468:	cd 21       	brne	8000b40c <sd_mmc_spi_write_sector_from_ram+0x154>
8000b46a:	ca eb       	rjmp	8000b3c6 <sd_mmc_spi_write_sector_from_ram+0x10e>
8000b46c:	3f f8       	mov	r8,-1
8000b46e:	aa 88       	st.b	r5[0x0],r8
8000b470:	c9 ab       	rjmp	8000b3a4 <sd_mmc_spi_write_sector_from_ram+0xec>
8000b472:	d7 03       	nop

8000b474 <sd_mmc_spi_wr_protect>:
//! @return false  -> the memory is not write-protected (always)
//!/
bool  sd_mmc_spi_wr_protect(void)
{
   return false;
}
8000b474:	5e fd       	retal	0
8000b476:	d7 03       	nop

8000b478 <sd_mmc_spi_test_unit_ready>:
}



Ctrl_status sd_mmc_spi_test_unit_ready(void)
{
8000b478:	eb cd 40 c0 	pushm	r6-r7,lr
  Sd_mmc_spi_access_signal_on();
  switch (sd_mmc_spi_presence_status)
8000b47c:	30 c6       	mov	r6,12
8000b47e:	30 17       	mov	r7,1
8000b480:	0d 88       	ld.ub	r8,r6[0x0]
8000b482:	ee 08 18 00 	cp.b	r8,r7
8000b486:	c1 b0       	breq	8000b4bc <sd_mmc_spi_test_unit_ready+0x44>
8000b488:	c0 a3       	brcs	8000b49c <sd_mmc_spi_test_unit_ready+0x24>
8000b48a:	30 29       	mov	r9,2
8000b48c:	f2 08 18 00 	cp.b	r8,r9
8000b490:	c1 10       	breq	8000b4b2 <sd_mmc_spi_test_unit_ready+0x3a>
      sd_mmc_spi_presence_status = SD_MMC_REMOVED;
      Sd_mmc_spi_access_signal_off();
      return CTRL_NO_PRESENT;

    default:
      sd_mmc_spi_presence_status = SD_MMC_REMOVED;
8000b492:	30 08       	mov	r8,0
8000b494:	30 3c       	mov	r12,3
8000b496:	ac 88       	st.b	r6[0x0],r8
    }
    else
      return CTRL_NO_PRESENT;
  }
*/
}
8000b498:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
{
  Sd_mmc_spi_access_signal_on();
  switch (sd_mmc_spi_presence_status)
  {
    case SD_MMC_REMOVED:
      sd_mmc_spi_init_done = false;
8000b49c:	30 09       	mov	r9,0
8000b49e:	e0 68 09 84 	mov	r8,2436
      if (sd_mmc_spi_mem_check())
8000b4a2:	b0 89       	st.b	r8[0x0],r9
8000b4a4:	fe b0 fd 9c 	rcall	8000afdc <sd_mmc_spi_mem_check>
      {
        sd_mmc_spi_presence_status = SD_MMC_INSERTED;
8000b4a8:	c0 70       	breq	8000b4b6 <sd_mmc_spi_test_unit_ready+0x3e>
8000b4aa:	ac 87       	st.b	r6[0x0],r7
        Sd_mmc_spi_access_signal_off();
        return CTRL_BUSY;
8000b4ac:	30 3c       	mov	r12,3
8000b4ae:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
      }
      Sd_mmc_spi_access_signal_off();
      return CTRL_GOOD;

    case SD_MMC_REMOVING:
      sd_mmc_spi_presence_status = SD_MMC_REMOVED;
8000b4b2:	30 08       	mov	r8,0
8000b4b4:	ac 88       	st.b	r6[0x0],r8
      Sd_mmc_spi_access_signal_off();
      return CTRL_NO_PRESENT;
8000b4b6:	30 2c       	mov	r12,2
8000b4b8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
      }
      Sd_mmc_spi_access_signal_off();
      return CTRL_NO_PRESENT;

    case SD_MMC_INSERTED:
      if (!sd_mmc_spi_mem_check())
8000b4bc:	fe b0 fd 90 	rcall	8000afdc <sd_mmc_spi_mem_check>
      {
        sd_mmc_spi_presence_status = SD_MMC_REMOVING;
8000b4c0:	c0 91       	brne	8000b4d2 <sd_mmc_spi_test_unit_ready+0x5a>
8000b4c2:	30 28       	mov	r8,2
        sd_mmc_spi_init_done = false;
8000b4c4:	ac 88       	st.b	r6[0x0],r8
8000b4c6:	e0 68 09 84 	mov	r8,2436
        Sd_mmc_spi_access_signal_off();
        return CTRL_BUSY;
8000b4ca:	b0 8c       	st.b	r8[0x0],r12
8000b4cc:	30 3c       	mov	r12,3
      }
      Sd_mmc_spi_access_signal_off();
      return CTRL_NO_PRESENT;

    case SD_MMC_INSERTED:
      if (!sd_mmc_spi_mem_check())
8000b4ce:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000b4d2:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
8000b4d6:	d7 03       	nop

8000b4d8 <sd_mmc_spi_ram_2_mem>:
8000b4d8:	d4 21       	pushm	r4-r7,lr
8000b4da:	18 97       	mov	r7,r12
8000b4dc:	16 94       	mov	r4,r11
8000b4de:	fe b0 f5 c9 	rcall	8000a070 <sd_mmc_spi_check_presence>
Ctrl_status    sd_mmc_spi_ram_2_mem(uint32_t addr, const void *ram)
{
   Sd_mmc_spi_access_signal_on();
   sd_mmc_spi_check_presence();

   if (!sd_mmc_spi_init_done)
8000b4e2:	e0 65 09 84 	mov	r5,2436
8000b4e6:	30 08       	mov	r8,0
8000b4e8:	0b 86       	ld.ub	r6,r5[0x0]
8000b4ea:	f0 06 18 00 	cp.b	r6,r8
      sd_mmc_spi_mem_init();
   }

   if (sd_mmc_spi_init_done)
   {
     sd_mmc_spi_write_open(addr);
8000b4ee:	c0 b0       	breq	8000b504 <sd_mmc_spi_ram_2_mem+0x2c>
8000b4f0:	0e 9c       	mov	r12,r7
8000b4f2:	fe b0 f7 07 	rcall	8000a300 <sd_mmc_spi_write_open>
     if (!sd_mmc_spi_write_sector_from_ram(ram))
8000b4f6:	08 9c       	mov	r12,r4
8000b4f8:	ce 0e       	rcall	8000b2b8 <sd_mmc_spi_write_sector_from_ram>
8000b4fa:	c0 d1       	brne	8000b514 <sd_mmc_spi_ram_2_mem+0x3c>
     {
       sd_mmc_spi_write_close();
8000b4fc:	fe b0 f4 4c 	rcall	80009d94 <sd_mmc_spi_write_close>
8000b500:	30 2c       	mov	r12,2
       Sd_mmc_spi_access_signal_off();
       return CTRL_NO_PRESENT;
8000b502:	d8 22       	popm	r4-r7,pc
//_____ D E C L A R A T I O N ______________________________________________


void sd_mmc_spi_mem_init(void)
{
  sd_mmc_spi_internal_init();        // Restart Init of SD/MMC card after previous first init
8000b504:	fe b0 f9 80 	rcall	8000a804 <sd_mmc_spi_internal_init>
   if (!sd_mmc_spi_init_done)
   {
      sd_mmc_spi_mem_init();
   }

   if (sd_mmc_spi_init_done)
8000b508:	0b 88       	ld.ub	r8,r5[0x0]
8000b50a:	ec 08 18 00 	cp.b	r8,r6
8000b50e:	cf 11       	brne	8000b4f0 <sd_mmc_spi_ram_2_mem+0x18>
   {
     sd_mmc_spi_write_open(addr);
     if (!sd_mmc_spi_write_sector_from_ram(ram))
     {
       sd_mmc_spi_write_close();
8000b510:	30 2c       	mov	r12,2
       Sd_mmc_spi_access_signal_off();
       return CTRL_NO_PRESENT;
8000b512:	d8 22       	popm	r4-r7,pc
     }
     sd_mmc_spi_write_close();
8000b514:	fe b0 f4 40 	rcall	80009d94 <sd_mmc_spi_write_close>
8000b518:	d8 2a       	popm	r4-r7,pc,r12=0
8000b51a:	d7 03       	nop

8000b51c <sd_mmc_spi_mem_2_ram>:
8000b51c:	d4 21       	pushm	r4-r7,lr
8000b51e:	18 97       	mov	r7,r12
8000b520:	16 94       	mov	r4,r11
8000b522:	fe b0 f5 a7 	rcall	8000a070 <sd_mmc_spi_check_presence>
8000b526:	e0 65 09 84 	mov	r5,2436
8000b52a:	30 08       	mov	r8,0
8000b52c:	0b 86       	ld.ub	r6,r5[0x0]
8000b52e:	f0 06 18 00 	cp.b	r6,r8
8000b532:	c0 60       	breq	8000b53e <sd_mmc_spi_mem_2_ram+0x22>
   }

   if (!sd_mmc_spi_init_done)
     return CTRL_NO_PRESENT;

   if( !sd_mmc_spi_read_open(addr) )
8000b534:	0e 9c       	mov	r12,r7
8000b536:	fe b0 f7 51 	rcall	8000a3d8 <sd_mmc_spi_read_open>
     goto sd_mmc_spi_mem_2_ram_fail;

   if( !sd_mmc_spi_read_sector_to_ram(ram))
     goto sd_mmc_spi_mem_2_ram_fail;

   if( !sd_mmc_spi_read_close() )
8000b53a:	c0 a1       	brne	8000b54e <sd_mmc_spi_mem_2_ram+0x32>
//_____ D E C L A R A T I O N ______________________________________________


void sd_mmc_spi_mem_init(void)
{
  sd_mmc_spi_internal_init();        // Restart Init of SD/MMC card after previous first init
8000b53c:	da 2a       	popm	r4-r7,pc,r12=1
8000b53e:	fe b0 f9 63 	rcall	8000a804 <sd_mmc_spi_internal_init>
   if (!sd_mmc_spi_init_done)
   {
      sd_mmc_spi_mem_init();
   }

   if (!sd_mmc_spi_init_done)
8000b542:	0b 88       	ld.ub	r8,r5[0x0]
8000b544:	ec 08 18 00 	cp.b	r8,r6
8000b548:	cf 61       	brne	8000b534 <sd_mmc_spi_mem_2_ram+0x18>
8000b54a:	30 2c       	mov	r12,2
     return CTRL_NO_PRESENT;

   if( !sd_mmc_spi_read_open(addr) )
     goto sd_mmc_spi_mem_2_ram_fail;

   if( !sd_mmc_spi_read_sector_to_ram(ram))
8000b54c:	d8 22       	popm	r4-r7,pc
8000b54e:	08 9c       	mov	r12,r4
8000b550:	fe b0 f7 7c 	rcall	8000a448 <sd_mmc_spi_read_sector_to_ram>
     goto sd_mmc_spi_mem_2_ram_fail;

   if( !sd_mmc_spi_read_close() )
8000b554:	cf 40       	breq	8000b53c <sd_mmc_spi_mem_2_ram+0x20>
8000b556:	fe b0 f7 0d 	rcall	8000a370 <sd_mmc_spi_read_close>
8000b55a:	ec 1c 00 01 	eorl	r12,0x1
8000b55e:	5c 5c       	castu.b	r12
8000b560:	d8 22       	popm	r4-r7,pc
8000b562:	d7 03       	nop

8000b564 <smc_init>:

static void smc_enable_muxed_pins(void);


void smc_init(unsigned long hsb_hz)
{
8000b564:	eb cd 40 fc 	pushm	r2-r7,lr
  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
8000b568:	ee 78 42 3f 	mov	r8,999999
8000b56c:	f8 08 00 07 	add	r7,r12,r8
8000b570:	e0 68 de 83 	mov	r8,56963
8000b574:	ea 18 43 1b 	orh	r8,0x431b
//! Whether to use the NCS0 pin
#ifdef SMC_USE_NCS0
  #include SMC_COMPONENT_CS0

  // Setup SMC for NCS0
  SMC_CS_SETUP(0)
8000b578:	e0 69 4d d3 	mov	r9,19923
8000b57c:	ea 19 10 62 	orh	r9,0x1062
static void smc_enable_muxed_pins(void);


void smc_init(unsigned long hsb_hz)
{
  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
8000b580:	ee 08 06 46 	mulu.d	r6,r7,r8
8000b584:	0e 98       	mov	r8,r7
8000b586:	b3 88       	lsr	r8,0x12
//! Whether to use the NCS0 pin
#ifdef SMC_USE_NCS0
  #include SMC_COMPONENT_CS0

  // Setup SMC for NCS0
  SMC_CS_SETUP(0)
8000b588:	f0 08 00 25 	add	r5,r8,r8<<0x2
8000b58c:	a3 65       	lsl	r5,0x2
8000b58e:	ea c5 fc 19 	sub	r5,r5,-999
8000b592:	ea 09 06 44 	mulu.d	r4,r5,r9
8000b596:	f0 07 15 04 	lsl	r7,r8,0x4
8000b59a:	ea 0c 16 06 	lsr	r12,r5,0x6
8000b59e:	ee 08 01 05 	sub	r5,r7,r8
8000b5a2:	a1 75       	lsl	r5,0x1
8000b5a4:	ea c5 fc 19 	sub	r5,r5,-999
8000b5a8:	ea 09 06 44 	mulu.d	r4,r5,r9
8000b5ac:	f0 03 10 5a 	mul	r3,r8,90
8000b5b0:	ea 06 16 06 	lsr	r6,r5,0x6
8000b5b4:	e6 c3 fc 19 	sub	r3,r3,-999
8000b5b8:	f9 e6 11 0b 	or	r11,r12,r6<<0x10
8000b5bc:	e6 09 06 42 	mulu.d	r2,r3,r9
8000b5c0:	ee 08 01 05 	sub	r5,r7,r8
8000b5c4:	a5 65       	lsl	r5,0x4
8000b5c6:	ea c5 fc 19 	sub	r5,r5,-999
8000b5ca:	ea 09 06 44 	mulu.d	r4,r5,r9
8000b5ce:	fe 6a 1c 00 	mov	r10,-123904
8000b5d2:	ea 0e 16 06 	lsr	lr,r5,0x6
8000b5d6:	95 0b       	st.w	r10[0x0],r11
8000b5d8:	ee 08 01 05 	sub	r5,r7,r8
8000b5dc:	e6 07 16 06 	lsr	r7,r3,0x6
8000b5e0:	a3 65       	lsl	r5,0x2
8000b5e2:	e0 63 00 d2 	mov	r3,210
8000b5e6:	ea c5 fc 19 	sub	r5,r5,-999
8000b5ea:	f0 03 02 43 	mul	r3,r8,r3
8000b5ee:	ea 09 06 44 	mulu.d	r4,r5,r9
8000b5f2:	e6 c3 fc 19 	sub	r3,r3,-999
8000b5f6:	a7 85       	lsr	r5,0x6
8000b5f8:	e6 09 06 42 	mulu.d	r2,r3,r9
8000b5fc:	ea 0c 00 0c 	add	r12,r5,r12
8000b600:	e6 0b 16 06 	lsr	r11,r3,0x6
8000b604:	0e 3c       	cp.w	r12,r7
8000b606:	f8 07 17 20 	movhs	r7,r12
8000b60a:	eb eb 11 05 	or	r5,r5,r11<<0x10
8000b60e:	0c 0b       	add	r11,r6
8000b610:	eb e7 10 85 	or	r5,r5,r7<<0x8
8000b614:	1c 3b       	cp.w	r11,lr
8000b616:	f6 0e 17 20 	movhs	lr,r11
8000b61a:	eb ee 11 85 	or	r5,r5,lr<<0x18
8000b61e:	95 15       	st.w	r10[0x4],r5
8000b620:	f0 05 10 64 	mul	r5,r8,100
8000b624:	ea c5 fc 19 	sub	r5,r5,-999
8000b628:	ea 09 06 44 	mulu.d	r4,r5,r9
8000b62c:	ea 06 16 06 	lsr	r6,r5,0x6
8000b630:	0c 3c       	cp.w	r12,r6
8000b632:	ec 0c 17 30 	movlo	r12,r6
8000b636:	0e 3c       	cp.w	r12,r7
8000b638:	ee 0c 17 30 	movlo	r12,r7
8000b63c:	e0 67 01 0e 	mov	r7,270
8000b640:	af 38       	mul	r8,r7
8000b642:	f0 c8 fc 19 	sub	r8,r8,-999
8000b646:	f0 09 06 48 	mulu.d	r8,r8,r9
8000b64a:	e0 68 10 03 	mov	r8,4099
8000b64e:	a7 89       	lsr	r9,0x6
8000b650:	12 3b       	cp.w	r11,r9
8000b652:	f2 0b 17 30 	movlo	r11,r9
8000b656:	1c 3b       	cp.w	r11,lr
8000b658:	fc 0b 17 30 	movlo	r11,lr
8000b65c:	f9 eb 11 0b 	or	r11,r12,r11<<0x10
8000b660:	95 2b       	st.w	r10[0x8],r11
8000b662:	95 38       	st.w	r10[0xc],r8
8000b664:	30 19       	mov	r9,1
8000b666:	e0 68 09 88 	mov	r8,2440
8000b66a:	31 4b       	mov	r11,20
        {ATPASTE2(EBI_NCS_5,_PIN),ATPASTE2(EBI_NCS_5,_FUNCTION)},
    #endif
#endif
 };

  gpio_enable_module(SMC_EBI_GPIO_MAP, sizeof(SMC_EBI_GPIO_MAP) / sizeof(SMC_EBI_GPIO_MAP[0]));
8000b66c:	b0 89       	st.b	r8[0x0],r9
8000b66e:	48 3c       	lddpc	r12,8000b678 <smc_init+0x114>
8000b670:	c6 5c       	rcall	8000b73a <gpio_enable_module>
  #undef NCS_CONTROLLED_WRITE
  #undef NWAIT_MODE
#endif
  // Put the multiplexed MCU pins used for the SM under control of the SMC.
  smc_enable_muxed_pins();
}
8000b672:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000b676:	d7 03       	nop
8000b678:	80 01       	ld.sh	r1,r0[0x0]
8000b67a:	81 7c       	st.w	r0[0x1c],r12

8000b67c <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
8000b67c:	fe 68 14 00 	mov	r8,-125952
8000b680:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
8000b682:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
8000b686:	91 09       	st.w	r8[0x0],r9
}
8000b688:	5e fc       	retal	r12

8000b68a <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000b68a:	f8 08 16 05 	lsr	r8,r12,0x5
8000b68e:	a9 68       	lsl	r8,0x8
8000b690:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
8000b694:	58 1b       	cp.w	r11,1
8000b696:	c1 50       	breq	8000b6c0 <gpio_enable_module_pin+0x36>
8000b698:	c0 82       	brcc	8000b6a8 <gpio_enable_module_pin+0x1e>
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000b69a:	30 1b       	mov	r11,1
8000b69c:	f6 0c 09 4c 	lsl	r12,r11,r12
8000b6a0:	91 6c       	st.w	r8[0x18],r12
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000b6a2:	91 ac       	st.w	r8[0x28],r12
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000b6a4:	91 2c       	st.w	r8[0x8],r12
8000b6a6:	5e fd       	retal	0
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Enable the correct function. */
	switch (function) {
8000b6a8:	58 2b       	cp.w	r11,2
8000b6aa:	c1 10       	breq	8000b6cc <gpio_enable_module_pin+0x42>
8000b6ac:	58 3b       	cp.w	r11,3
8000b6ae:	c0 20       	breq	8000b6b2 <gpio_enable_module_pin+0x28>
8000b6b0:	5e ff       	retal	1
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000b6b2:	30 1b       	mov	r11,1
8000b6b4:	f6 0c 09 4c 	lsl	r12,r11,r12
8000b6b8:	91 5c       	st.w	r8[0x14],r12
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000b6ba:	91 9c       	st.w	r8[0x24],r12
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000b6bc:	91 2c       	st.w	r8[0x8],r12
8000b6be:	5e fd       	retal	0
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000b6c0:	f6 0c 09 4c 	lsl	r12,r11,r12
8000b6c4:	91 5c       	st.w	r8[0x14],r12
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000b6c6:	91 ac       	st.w	r8[0x28],r12
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000b6c8:	91 2c       	st.w	r8[0x8],r12
8000b6ca:	5e fd       	retal	0
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000b6cc:	30 1b       	mov	r11,1
8000b6ce:	f6 0c 09 4c 	lsl	r12,r11,r12
8000b6d2:	91 6c       	st.w	r8[0x18],r12
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000b6d4:	91 9c       	st.w	r8[0x24],r12
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000b6d6:	91 2c       	st.w	r8[0x8],r12
8000b6d8:	5e fd       	retal	0

8000b6da <gpio_enable_gpio_pin>:
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
	
	gpio_port->oderc = 1 << (pin & 0x1F);
8000b6da:	30 18       	mov	r8,1
8000b6dc:	f0 0c 09 48 	lsl	r8,r8,r12
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000b6e0:	a5 9c       	lsr	r12,0x5
8000b6e2:	a9 6c       	lsl	r12,0x8
8000b6e4:	e0 2c f0 00 	sub	r12,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
8000b6e8:	f9 48 00 48 	st.w	r12[72],r8
	gpio_port->gpers = 1 << (pin & 0x1F);
8000b6ec:	99 18       	st.w	r12[0x4],r8
}
8000b6ee:	5e fc       	retal	r12

8000b6f0 <gpio_get_pin_value>:
 *
 * \return The pin value.
 */
bool gpio_get_pin_value(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000b6f0:	f8 08 16 05 	lsr	r8,r12,0x5
8000b6f4:	a9 68       	lsl	r8,0x8
8000b6f6:	e0 28 f0 00 	sub	r8,61440
	
	return (gpio_port->pvr >> (pin & 0x1F)) & 1;
8000b6fa:	71 88       	ld.w	r8,r8[0x60]
8000b6fc:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
8000b700:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
8000b704:	5e fc       	retal	r12

8000b706 <gpio_set_gpio_pin>:
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000b706:	30 18       	mov	r8,1
8000b708:	f0 0c 09 48 	lsl	r8,r8,r12
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000b70c:	a5 9c       	lsr	r12,0x5
8000b70e:	a9 6c       	lsl	r12,0x8
8000b710:	e0 2c f0 00 	sub	r12,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000b714:	f9 48 00 54 	st.w	r12[84],r8
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
8000b718:	f9 48 00 44 	st.w	r12[68],r8
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000b71c:	99 18       	st.w	r12[0x4],r8
}
8000b71e:	5e fc       	retal	r12

8000b720 <gpio_clr_gpio_pin>:
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
8000b720:	30 18       	mov	r8,1
8000b722:	f0 0c 09 48 	lsl	r8,r8,r12
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000b726:	a5 9c       	lsr	r12,0x5
8000b728:	a9 6c       	lsl	r12,0x8
8000b72a:	e0 2c f0 00 	sub	r12,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
8000b72e:	f9 48 00 58 	st.w	r12[88],r8
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
8000b732:	f9 48 00 44 	st.w	r12[68],r8
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000b736:	99 18       	st.w	r12[0x4],r8
}
8000b738:	5e fc       	retal	r12

8000b73a <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
8000b73a:	eb cd 40 c0 	pushm	r6-r7,lr
8000b73e:	18 98       	mov	r8,r12
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000b740:	58 0b       	cp.w	r11,0
8000b742:	c3 60       	breq	8000b7ae <gpio_enable_module+0x74>
8000b744:	30 0e       	mov	lr,0
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Enable the correct function. */
	switch (function) {
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000b746:	30 16       	mov	r6,1
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000b748:	1c 9c       	mov	r12,lr
8000b74a:	c0 d8       	rjmp	8000b764 <gpio_enable_module+0x2a>
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Enable the correct function. */
	switch (function) {
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000b74c:	ec 07 09 4a 	lsl	r10,r6,r7
8000b750:	93 6a       	st.w	r9[0x18],r10
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000b752:	93 aa       	st.w	r9[0x28],r10
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000b754:	93 2a       	st.w	r9[0x8],r10
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000b756:	2f fe       	sub	lr,-1
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000b758:	30 09       	mov	r9,0
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000b75a:	12 4c       	or	r12,r9
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000b75c:	1c 3b       	cp.w	r11,lr
8000b75e:	e0 88 00 17 	brls	8000b78c <gpio_enable_module+0x52>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
8000b762:	2f 88       	sub	r8,-8
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000b764:	70 07       	ld.w	r7,r8[0x0]
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Enable the correct function. */
	switch (function) {
8000b766:	70 1a       	ld.w	r10,r8[0x4]
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000b768:	ee 09 16 05 	lsr	r9,r7,0x5
8000b76c:	a9 69       	lsl	r9,0x8
8000b76e:	e0 29 f0 00 	sub	r9,61440

	/* Enable the correct function. */
	switch (function) {
8000b772:	58 1a       	cp.w	r10,1
8000b774:	c0 e0       	breq	8000b790 <gpio_enable_module+0x56>
8000b776:	ce b3       	brcs	8000b74c <gpio_enable_module+0x12>
8000b778:	58 2a       	cp.w	r10,2
8000b77a:	c1 50       	breq	8000b7a4 <gpio_enable_module+0x6a>
8000b77c:	58 3a       	cp.w	r10,3
8000b77e:	c0 e0       	breq	8000b79a <gpio_enable_module+0x60>
8000b780:	30 19       	mov	r9,1
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000b782:	2f fe       	sub	lr,-1
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000b784:	12 4c       	or	r12,r9
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000b786:	1c 3b       	cp.w	r11,lr
8000b788:	fe 9b ff ed 	brhi	8000b762 <gpio_enable_module+0x28>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000b78c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000b790:	f4 07 09 4a 	lsl	r10,r10,r7
8000b794:	93 5a       	st.w	r9[0x14],r10
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000b796:	93 aa       	st.w	r9[0x28],r10
8000b798:	cd eb       	rjmp	8000b754 <gpio_enable_module+0x1a>
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000b79a:	ec 07 09 4a 	lsl	r10,r6,r7
8000b79e:	93 5a       	st.w	r9[0x14],r10
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000b7a0:	93 9a       	st.w	r9[0x24],r10
8000b7a2:	cd 9b       	rjmp	8000b754 <gpio_enable_module+0x1a>
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000b7a4:	ec 07 09 4a 	lsl	r10,r6,r7
8000b7a8:	93 6a       	st.w	r9[0x18],r10
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000b7aa:	93 9a       	st.w	r9[0x24],r10
8000b7ac:	cd 4b       	rjmp	8000b754 <gpio_enable_module+0x1a>
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
8000b7ae:	16 9c       	mov	r12,r11
8000b7b0:	ce eb       	rjmp	8000b78c <gpio_enable_module+0x52>

8000b7b2 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
8000b7b2:	c0 08       	rjmp	8000b7b2 <_unhandled_interrupt>

8000b7b4 <INTC_register_interrupt>:

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
8000b7b4:	f3 db c0 05 	bfextu	r9,r11,0x0,0x5
8000b7b8:	49 b8       	lddpc	r8,8000b824 <INTC_register_interrupt+0x70>
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
8000b7ba:	a5 9b       	lsr	r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
8000b7bc:	f0 0b 00 38 	add	r8,r8,r11<<0x3
8000b7c0:	70 18       	ld.w	r8,r8[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
8000b7c2:	f0 09 09 2c 	st.w	r8[r9<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
8000b7c6:	58 0a       	cp.w	r10,0
8000b7c8:	c1 00       	breq	8000b7e8 <INTC_register_interrupt+0x34>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
	} else if (int_level == AVR32_INTC_INT1) {
8000b7ca:	58 1a       	cp.w	r10,1
8000b7cc:	c1 70       	breq	8000b7fa <INTC_register_interrupt+0x46>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
	} else if (int_level == AVR32_INTC_INT2) {
8000b7ce:	58 2a       	cp.w	r10,2
8000b7d0:	c1 f0       	breq	8000b80e <INTC_register_interrupt+0x5a>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
8000b7d2:	49 69       	lddpc	r9,8000b828 <INTC_register_interrupt+0x74>
8000b7d4:	49 68       	lddpc	r8,8000b82c <INTC_register_interrupt+0x78>
8000b7d6:	f2 08 01 08 	sub	r8,r9,r8
8000b7da:	fe 79 08 00 	mov	r9,-63488
8000b7de:	ea 18 c0 00 	orh	r8,0xc000
8000b7e2:	f2 0b 09 28 	st.w	r9[r11<<0x2],r8
8000b7e6:	5e fc       	retal	r12
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000b7e8:	fe 78 08 00 	mov	r8,-63488
8000b7ec:	49 09       	lddpc	r9,8000b82c <INTC_register_interrupt+0x78>
8000b7ee:	49 1a       	lddpc	r10,8000b830 <INTC_register_interrupt+0x7c>
8000b7f0:	f4 09 01 09 	sub	r9,r10,r9
8000b7f4:	f0 0b 09 29 	st.w	r8[r11<<0x2],r9
8000b7f8:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000b7fa:	48 f9       	lddpc	r9,8000b834 <INTC_register_interrupt+0x80>
8000b7fc:	48 c8       	lddpc	r8,8000b82c <INTC_register_interrupt+0x78>
8000b7fe:	f2 08 01 08 	sub	r8,r9,r8
8000b802:	fe 79 08 00 	mov	r9,-63488
8000b806:	bf a8       	sbr	r8,0x1e
8000b808:	f2 0b 09 28 	st.w	r9[r11<<0x2],r8
8000b80c:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000b80e:	48 b9       	lddpc	r9,8000b838 <INTC_register_interrupt+0x84>
8000b810:	48 78       	lddpc	r8,8000b82c <INTC_register_interrupt+0x78>
8000b812:	f2 08 01 08 	sub	r8,r9,r8
8000b816:	fe 79 08 00 	mov	r9,-63488
8000b81a:	bf b8       	sbr	r8,0x1f
8000b81c:	f2 0b 09 28 	st.w	r9[r11<<0x2],r8
8000b820:	5e fc       	retal	r12
8000b822:	d7 03       	nop
8000b824:	80 01       	ld.sh	r1,r0[0x0]
8000b826:	82 1c       	ld.sh	r12,r1[0x2]
8000b828:	80 01       	ld.sh	r1,r0[0x0]
8000b82a:	6d 2e       	ld.w	lr,r6[0x48]
8000b82c:	80 01       	ld.sh	r1,r0[0x0]
8000b82e:	6c 00       	ld.w	r0,r6[0x0]
8000b830:	80 01       	ld.sh	r1,r0[0x0]
8000b832:	6d 04       	ld.w	r4,r6[0x40]
8000b834:	80 01       	ld.sh	r1,r0[0x0]
8000b836:	6d 12       	ld.w	r2,r6[0x44]
8000b838:	80 01       	ld.sh	r1,r0[0x0]
8000b83a:	6d 20       	ld.w	r0,r6[0x48]

8000b83c <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
8000b83c:	eb cd 40 e0 	pushm	r5-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000b840:	48 f8       	lddpc	r8,8000b87c <INTC_init_interrupts+0x40>
8000b842:	e3 b8 00 01 	mtsr	0x4,r8
8000b846:	48 f5       	lddpc	r5,8000b880 <INTC_init_interrupts+0x44>
8000b848:	48 f7       	lddpc	r7,8000b884 <INTC_init_interrupts+0x48>
8000b84a:	10 15       	sub	r5,r8
8000b84c:	30 0e       	mov	lr,0
8000b84e:	fe cc 00 9c 	sub	r12,pc,156

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000b852:	fe 76 08 00 	mov	r6,-63488

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000b856:	6e 0a       	ld.w	r10,r7[0x0]
8000b858:	58 0a       	cp.w	r10,0
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000b85a:	c0 90       	breq	8000b86c <INTC_init_interrupts+0x30>
8000b85c:	30 08       	mov	r8,0
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000b85e:	6e 1b       	ld.w	r11,r7[0x4]
8000b860:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000b864:	2f f8       	sub	r8,-1
8000b866:	10 3a       	cp.w	r10,r8
8000b868:	fe 9b ff fc 	brhi	8000b860 <INTC_init_interrupts+0x24>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000b86c:	ec 0e 09 25 	st.w	r6[lr<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
8000b870:	2f 87       	sub	r7,-8
8000b872:	2f fe       	sub	lr,-1
8000b874:	59 4e       	cp.w	lr,20
8000b876:	cf 01       	brne	8000b856 <INTC_init_interrupts+0x1a>
8000b878:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000b87c:	80 01       	ld.sh	r1,r0[0x0]
8000b87e:	6c 00       	ld.w	r0,r6[0x0]
8000b880:	80 01       	ld.sh	r1,r0[0x0]
8000b882:	6d 04       	ld.w	r4,r6[0x40]
8000b884:	80 01       	ld.sh	r1,r0[0x0]
8000b886:	82 1c       	ld.sh	r12,r1[0x2]

8000b888 <_get_interrupt_handler>:
8000b888:	e0 68 00 83 	mov	r8,131
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
8000b88c:	f0 0c 01 0c 	sub	r12,r8,r12
8000b890:	fe 78 08 00 	mov	r8,-63488
8000b894:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
8000b898:	f2 ca ff c0 	sub	r10,r9,-64
8000b89c:	f0 0a 03 2c 	ld.w	r12,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000b8a0:	58 0c       	cp.w	r12,0
8000b8a2:	5e 0c       	reteq	r12
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000b8a4:	48 68       	lddpc	r8,8000b8bc <_get_interrupt_handler+0x34>
8000b8a6:	f8 0c 12 00 	clz	r12,r12
8000b8aa:	f0 09 00 39 	add	r9,r8,r9<<0x3
8000b8ae:	f8 0c 11 1f 	rsub	r12,r12,31
8000b8b2:	72 18       	ld.w	r8,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000b8b4:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000b8b8:	5e fc       	retal	r12
8000b8ba:	d7 03       	nop
8000b8bc:	80 01       	ld.sh	r1,r0[0x0]
8000b8be:	82 1c       	ld.sh	r12,r1[0x2]

8000b8c0 <pdca_disable>:
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
8000b8c0:	30 e8       	mov	r8,14
8000b8c2:	f0 0c 18 00 	cp.b	r12,r8
8000b8c6:	e0 8b 00 08 	brhi	8000b8d6 <pdca_disable+0x16>

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
8000b8ca:	a7 6c       	lsl	r12,0x6
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	/* Disable transfer */
	pdca_channel->cr = AVR32_PDCA_TDIS_MASK;
8000b8cc:	30 28       	mov	r8,2

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
8000b8ce:	e0 3c 00 00 	sub	r12,65536
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	/* Disable transfer */
	pdca_channel->cr = AVR32_PDCA_TDIS_MASK;
8000b8d2:	99 58       	st.w	r12[0x14],r8
}
8000b8d4:	5e fc       	retal	r12
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
8000b8d6:	3f fc       	mov	r12,-1
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	/* Disable transfer */
	pdca_channel->cr = AVR32_PDCA_TDIS_MASK;
8000b8d8:	30 28       	mov	r8,2
8000b8da:	99 58       	st.w	r12[0x14],r8
}
8000b8dc:	5e fc       	retal	r12

8000b8de <pdca_disable_interrupt_transfer_complete>:
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
8000b8de:	30 e8       	mov	r8,14
8000b8e0:	f0 0c 18 00 	cp.b	r12,r8
8000b8e4:	e0 88 00 0e 	brls	8000b900 <pdca_disable_interrupt_transfer_complete+0x22>
8000b8e8:	3f fc       	mov	r12,-1

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000b8ea:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
8000b8ee:	d3 03       	ssrf	0x10
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_TRC_MASK;
8000b8f0:	30 29       	mov	r9,2
8000b8f2:	99 99       	st.w	r12[0x24],r9
	pdca_channel->isr;
8000b8f4:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000b8f6:	ed b8 00 10 	bld	r8,0x10
8000b8fa:	c0 20       	breq	8000b8fe <pdca_disable_interrupt_transfer_complete+0x20>
      cpu_irq_enable();
8000b8fc:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
8000b8fe:	5e fc       	retal	r12

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
8000b900:	a7 6c       	lsl	r12,0x6
8000b902:	e0 3c 00 00 	sub	r12,65536
8000b906:	cf 2b       	rjmp	8000b8ea <pdca_disable_interrupt_transfer_complete+0xc>

8000b908 <pdca_init_channel>:
	return pdca_channel;
}

uint32_t pdca_init_channel(uint8_t pdca_ch_number,
		const pdca_channel_options_t *opt)
{
8000b908:	eb cd 40 80 	pushm	r7,lr
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
8000b90c:	30 e8       	mov	r8,14

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
8000b90e:	f8 09 15 06 	lsl	r9,r12,0x6
8000b912:	e0 39 00 00 	sub	r9,65536

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
8000b916:	f0 0c 18 00 	cp.b	r12,r8
8000b91a:	f9 b8 0b ff 	movhi	r8,-1
8000b91e:	f0 0e 17 b0 	movhi	lr,r8
8000b922:	f2 08 17 80 	movls	r8,r9
8000b926:	f2 0e 17 80 	movls	lr,r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000b92a:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
8000b92e:	d3 03       	ssrf	0x10
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_TRC_MASK;
8000b930:	30 27       	mov	r7,2
8000b932:	9d 97       	st.w	lr[0x24],r7
	pdca_channel->isr;
8000b934:	7c be       	ld.w	lr,lr[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000b936:	ed ba 00 10 	bld	r10,0x10
8000b93a:	c0 20       	breq	8000b93e <pdca_init_channel+0x36>
      cpu_irq_enable();
8000b93c:	d5 03       	csrf	0x10
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
8000b93e:	30 ea       	mov	r10,14
8000b940:	f8 0a 18 00 	cp.b	r10,r12
8000b944:	f9 b9 03 ff 	movlo	r9,-1

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000b948:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
8000b94c:	d3 03       	ssrf	0x10
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_RCZ_MASK;
8000b94e:	30 1c       	mov	r12,1
8000b950:	93 9c       	st.w	r9[0x24],r12
	pdca_channel->isr;
8000b952:	72 b9       	ld.w	r9,r9[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000b954:	ed ba 00 10 	bld	r10,0x10
8000b958:	c0 20       	breq	8000b95c <pdca_init_channel+0x54>
      cpu_irq_enable();
8000b95a:	d5 03       	csrf	0x10

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000b95c:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
8000b960:	d3 03       	ssrf	0x10
	pdca_disable_interrupt_transfer_complete(pdca_ch_number); 
	pdca_disable_interrupt_reload_counter_zero(pdca_ch_number);
	
	irqflags_t flags = cpu_irq_save();

	pdca_channel->mar = (uint32_t)opt->addr;
8000b962:	76 0a       	ld.w	r10,r11[0x0]
8000b964:	91 0a       	st.w	r8[0x0],r10
	pdca_channel->tcr = opt->size;
8000b966:	76 1a       	ld.w	r10,r11[0x4]
8000b968:	91 2a       	st.w	r8[0x8],r10
	pdca_channel->psr = opt->pid;
8000b96a:	76 4a       	ld.w	r10,r11[0x10]
8000b96c:	91 1a       	st.w	r8[0x4],r10
	pdca_channel->marr = (uint32_t)opt->r_addr;
8000b96e:	76 2a       	ld.w	r10,r11[0x8]
8000b970:	91 3a       	st.w	r8[0xc],r10
	pdca_channel->tcrr = opt->r_size;
8000b972:	76 3a       	ld.w	r10,r11[0xc]
8000b974:	91 4a       	st.w	r8[0x10],r10
	pdca_channel->mr =
8000b976:	76 5a       	ld.w	r10,r11[0x14]
8000b978:	91 6a       	st.w	r8[0x18],r10
#if (AVR32_PDCA_H_VERSION >= 120)
			opt->etrig << AVR32_PDCA_ETRIG_OFFSET |
#endif
			opt->transfer_size << AVR32_PDCA_SIZE_OFFSET;
	pdca_channel->cr = AVR32_PDCA_ECLR_MASK;
8000b97a:	e0 6a 01 00 	mov	r10,256
8000b97e:	91 5a       	st.w	r8[0x14],r10
	pdca_channel->isr;
8000b980:	70 b8       	ld.w	r8,r8[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000b982:	ed b9 00 10 	bld	r9,0x10
8000b986:	c0 20       	breq	8000b98a <pdca_init_channel+0x82>
      cpu_irq_enable();
8000b988:	d5 03       	csrf	0x10
	
	cpu_irq_restore(flags);

	return PDCA_SUCCESS;
}
8000b98a:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0

8000b98e <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
8000b98e:	eb cd 40 90 	pushm	r4,r7,lr
8000b992:	fa c4 ff f4 	sub	r4,sp,-12
8000b996:	68 17       	ld.w	r7,r4[0x4]
8000b998:	68 0e       	ld.w	lr,r4[0x0]
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
8000b99a:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
8000b99e:	fd de c0 01 	bfextu	lr,lr,0x0,0x1
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
8000b9a2:	30 04       	mov	r4,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
8000b9a4:	e9 d7 d0 03 	bfins	r4,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
8000b9a8:	e9 de d0 e1 	bfins	r4,lr,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
8000b9ac:	e9 d7 d1 03 	bfins	r4,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
8000b9b0:	e9 de d1 e1 	bfins	r4,lr,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
8000b9b4:	e9 da d2 03 	bfins	r4,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
8000b9b8:	e9 db d2 e1 	bfins	r4,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
8000b9bc:	e9 d8 d3 03 	bfins	r4,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
8000b9c0:	e9 d9 d3 e1 	bfins	r4,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
8000b9c4:	99 14       	st.w	r12[0x4],r4

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
8000b9c6:	79 58       	ld.w	r8,r12[0x54]
8000b9c8:	ed b8 00 05 	bld	r8,0x5
8000b9cc:	cf d1       	brne	8000b9c6 <pm_cksel+0x38>
}
8000b9ce:	e3 cd 80 90 	ldm	sp++,r4,r7,pc

8000b9d2 <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
8000b9d2:	eb cd 40 80 	pushm	r7,lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
8000b9d6:	30 07       	mov	r7,0
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
8000b9d8:	40 2e       	lddsp	lr,sp[0x8]
  u_avr32_pm_pll.PLL.pllosc   = osc;
  u_avr32_pm_pll.PLL.plldiv   = div;
  u_avr32_pm_pll.PLL.pllmul   = mul;
  u_avr32_pm_pll.PLL.pllcount = lockcount;

  pm->pll[pll] = u_avr32_pm_pll.pll;
8000b9da:	2f 8b       	sub	r11,-8
                  unsigned int osc,
                  unsigned int lockcount)
{
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};

  u_avr32_pm_pll.PLL.pllosc   = osc;
8000b9dc:	ef d8 d0 21 	bfins	r7,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
8000b9e0:	ef d9 d1 04 	bfins	r7,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
8000b9e4:	ef da d2 04 	bfins	r7,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
8000b9e8:	ef de d3 06 	bfins	r7,lr,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
8000b9ec:	f8 0b 09 27 	st.w	r12[r11<<0x2],r7
}
8000b9f0:	e3 cd 80 80 	ldm	sp++,r7,pc

8000b9f4 <pm_pll_set_option>:
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
8000b9f4:	f5 e9 10 19 	or	r9,r10,r9<<0x1
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
8000b9f8:	2f 8b       	sub	r11,-8
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
8000b9fa:	f3 e8 10 28 	or	r8,r9,r8<<0x2
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
8000b9fe:	f8 0b 03 29 	ld.w	r9,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
8000ba02:	f3 d8 d0 43 	bfins	r9,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
8000ba06:	f8 0b 09 29 	st.w	r12[r11<<0x2],r9
}
8000ba0a:	5e fc       	retal	r12

8000ba0c <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
8000ba0c:	2f 8b       	sub	r11,-8
8000ba0e:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
8000ba12:	a1 a8       	sbr	r8,0x0
8000ba14:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
8000ba18:	5e fc       	retal	r12

8000ba1a <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
8000ba1a:	79 58       	ld.w	r8,r12[0x54]
8000ba1c:	ed b8 00 00 	bld	r8,0x0
8000ba20:	cf d1       	brne	8000ba1a <pm_wait_for_pll0_locked>
}
8000ba22:	5e fc       	retal	r12

8000ba24 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
8000ba24:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
8000ba26:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
8000ba2a:	99 08       	st.w	r12[0x0],r8
}
8000ba2c:	5e fc       	retal	r12

8000ba2e <pm_switch_to_osc0>:
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
8000ba2e:	ec 5b bb 9f 	cp.w	r11,899999
8000ba32:	e0 8b 00 18 	brhi	8000ba62 <pm_switch_to_osc0+0x34>
8000ba36:	30 4b       	mov	r11,4
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
8000ba38:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
8000ba3a:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000ba3e:	99 a8       	st.w	r12[0x28],r8


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
8000ba40:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
8000ba42:	f1 da d1 03 	bfins	r8,r10,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000ba46:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
8000ba48:	78 08       	ld.w	r8,r12[0x0]
8000ba4a:	a3 a8       	sbr	r8,0x2
8000ba4c:	99 08       	st.w	r12[0x0],r8
}


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
8000ba4e:	79 58       	ld.w	r8,r12[0x54]
8000ba50:	ed b8 00 07 	bld	r8,0x7
8000ba54:	cf d1       	brne	8000ba4e <pm_switch_to_osc0+0x20>


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
8000ba56:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
8000ba58:	30 19       	mov	r9,1
8000ba5a:	f1 d9 d0 02 	bfins	r8,r9,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
8000ba5e:	99 08       	st.w	r12[0x0],r8
void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
}
8000ba60:	5e fc       	retal	r12
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
8000ba62:	e0 68 c6 bf 	mov	r8,50879
8000ba66:	ea 18 00 2d 	orh	r8,0x2d
8000ba6a:	10 3b       	cp.w	r11,r8
8000ba6c:	e0 88 00 0c 	brls	8000ba84 <pm_switch_to_osc0+0x56>
8000ba70:	e0 68 12 00 	mov	r8,4608
8000ba74:	ea 18 00 7a 	orh	r8,0x7a
8000ba78:	10 3b       	cp.w	r11,r8
8000ba7a:	f9 bb 03 06 	movlo	r11,6
8000ba7e:	f9 bb 02 07 	movhs	r11,7
8000ba82:	cd bb       	rjmp	8000ba38 <pm_switch_to_osc0+0xa>
8000ba84:	30 5b       	mov	r11,5
8000ba86:	cd 9b       	rjmp	8000ba38 <pm_switch_to_osc0+0xa>

8000ba88 <pwm_channel_init>:

int pwm_channel_init( unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (pwm_channel == 0) // Null pointer.
8000ba88:	58 0b       	cp.w	r11,0
8000ba8a:	c1 60       	breq	8000bab6 <pwm_channel_init+0x2e>
    return PWM_INVALID_ARGUMENT;
  if (channel_id > AVR32_PWM_LINES_MSB) // Control input values.
8000ba8c:	58 6c       	cp.w	r12,6
8000ba8e:	e0 8b 00 14 	brhi	8000bab6 <pwm_channel_init+0x2e>
    return PWM_INVALID_INPUT;

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode.
8000ba92:	76 09       	ld.w	r9,r11[0x0]
8000ba94:	f8 08 15 05 	lsl	r8,r12,0x5
8000ba98:	e0 28 ce 00 	sub	r8,52736
8000ba9c:	91 09       	st.w	r8[0x0],r9
  pwm->channel[channel_id].cdty= pwm_channel->cdty; // Duty cycle, should be < CPRD.
8000ba9e:	a5 7c       	lsl	r12,0x5
8000baa0:	76 19       	ld.w	r9,r11[0x4]
8000baa2:	fe 7a 32 04 	mov	r10,-52732
8000baa6:	f8 0a 00 08 	add	r8,r12,r10
  pwm->channel[channel_id].cprd= pwm_channel->cprd; // Channel period.
8000baaa:	e0 2c cd f8 	sub	r12,52728
    return PWM_INVALID_ARGUMENT;
  if (channel_id > AVR32_PWM_LINES_MSB) // Control input values.
    return PWM_INVALID_INPUT;

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode.
  pwm->channel[channel_id].cdty= pwm_channel->cdty; // Duty cycle, should be < CPRD.
8000baae:	91 09       	st.w	r8[0x0],r9
  pwm->channel[channel_id].cprd= pwm_channel->cprd; // Channel period.
8000bab0:	76 28       	ld.w	r8,r11[0x8]
8000bab2:	99 08       	st.w	r12[0x0],r8
8000bab4:	5e fd       	retal	0

  return PWM_SUCCESS;
8000bab6:	5e ff       	retal	1

8000bab8 <pwm_start_channels>:
}


int pwm_start_channels(unsigned long channels_bitmask)
{
8000bab8:	18 98       	mov	r8,r12
  if (channels_bitmask & ~((1 << (AVR32_PWM_LINES_MSB + 1)) - 1))
8000baba:	e0 1c ff 80 	andl	r12,0xff80
8000babe:	c0 51       	brne	8000bac8 <pwm_start_channels+0x10>
    return PWM_INVALID_INPUT;

  AVR32_PWM.ena = channels_bitmask; // Enable channels.
8000bac0:	fe 79 30 00 	mov	r9,-53248
8000bac4:	93 18       	st.w	r9[0x4],r8

  return PWM_SUCCESS;
}
8000bac6:	5e fc       	retal	r12
}


int pwm_start_channels(unsigned long channels_bitmask)
{
  if (channels_bitmask & ~((1 << (AVR32_PWM_LINES_MSB + 1)) - 1))
8000bac8:	5e ff       	retal	1

8000baca <pwm_async_update_channel>:

int pwm_async_update_channel(unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (channel_id > AVR32_PWM_LINES_MSB)
8000baca:	58 6c       	cp.w	r12,6
8000bacc:	e0 8b 00 0e 	brhi	8000bae8 <pwm_async_update_channel+0x1e>
     return PWM_INVALID_INPUT;

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode register: update of the period or duty cycle.
8000bad0:	76 09       	ld.w	r9,r11[0x0]
8000bad2:	f8 08 15 05 	lsl	r8,r12,0x5
  pwm->channel[channel_id].cupd= pwm_channel->cupd; // Channel update CPRDx or CDTYx according to CPD value in CMRx.
8000bad6:	a5 7c       	lsl	r12,0x5
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (channel_id > AVR32_PWM_LINES_MSB)
     return PWM_INVALID_INPUT;

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode register: update of the period or duty cycle.
8000bad8:	e0 28 ce 00 	sub	r8,52736
  pwm->channel[channel_id].cupd= pwm_channel->cupd; // Channel update CPRDx or CDTYx according to CPD value in CMRx.
8000badc:	e0 2c cd f0 	sub	r12,52720
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (channel_id > AVR32_PWM_LINES_MSB)
     return PWM_INVALID_INPUT;

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode register: update of the period or duty cycle.
8000bae0:	91 09       	st.w	r8[0x0],r9
  pwm->channel[channel_id].cupd= pwm_channel->cupd; // Channel update CPRDx or CDTYx according to CPD value in CMRx.
8000bae2:	76 48       	ld.w	r8,r11[0x10]
8000bae4:	99 08       	st.w	r12[0x0],r8
8000bae6:	5e fd       	retal	0

int pwm_async_update_channel(unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (channel_id > AVR32_PWM_LINES_MSB)
8000bae8:	5e ff       	retal	1

8000baea <pwm_init>:


int pwm_init(const pwm_opt_t *opt)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
8000baea:	e1 b8 00 00 	mfsr	r8,0x0

  if (opt == 0 ) // Null pointer.
8000baee:	58 0c       	cp.w	r12,0
8000baf0:	c2 00       	breq	8000bb30 <pwm_init+0x46>
    return PWM_INVALID_INPUT;

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
8000baf2:	ed b8 00 10 	bld	r8,0x10
8000baf6:	c1 51       	brne	8000bb20 <pwm_init+0x36>
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
8000baf8:	fe 78 30 00 	mov	r8,-53248
8000bafc:	37 f9       	mov	r9,127
8000bafe:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
8000bb00:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
    ((opt->diva)<<AVR32_PWM_DIVA_OFFSET) |
8000bb02:	78 28       	ld.w	r8,r12[0x8]
8000bb04:	78 0a       	ld.w	r10,r12[0x0]
8000bb06:	78 39       	ld.w	r9,r12[0xc]
8000bb08:	a9 69       	lsl	r9,0x8
8000bb0a:	f3 ea 11 09 	or	r9,r9,r10<<0x10
8000bb0e:	78 1a       	ld.w	r10,r12[0x4]
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
  pwm->isr;
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
8000bb10:	30 0c       	mov	r12,0
    ((opt->diva)<<AVR32_PWM_DIVA_OFFSET) |
8000bb12:	14 49       	or	r9,r10
8000bb14:	f3 e8 11 89 	or	r9,r9,r8<<0x18
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
  pwm->isr;
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
8000bb18:	fe 78 30 00 	mov	r8,-53248
8000bb1c:	91 09       	st.w	r8[0x0],r9
    ((opt->prea)<<AVR32_PWM_PREA_OFFSET) |
    ((opt->preb)<<AVR32_PWM_PREB_OFFSET)
    ;

  return PWM_SUCCESS;
}
8000bb1e:	5e fc       	retal	r12

  if (opt == 0 ) // Null pointer.
    return PWM_INVALID_INPUT;

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
8000bb20:	d3 03       	ssrf	0x10
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
8000bb22:	fe 78 30 00 	mov	r8,-53248
8000bb26:	37 f9       	mov	r9,127
8000bb28:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
8000bb2a:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();
8000bb2c:	d5 03       	csrf	0x10
8000bb2e:	ce ab       	rjmp	8000bb02 <pwm_init+0x18>
int pwm_init(const pwm_opt_t *opt)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;
  bool global_interrupt_enabled = Is_global_interrupt_enabled();

  if (opt == 0 ) // Null pointer.
8000bb30:	5e ff       	retal	1

8000bb32 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
8000bb32:	f8 c8 00 01 	sub	r8,r12,1
8000bb36:	f0 0b 00 0b 	add	r11,r8,r11
8000bb3a:	f6 0c 0d 0a 	divu	r10,r11,r12
8000bb3e:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
8000bb40:	f4 c8 00 01 	sub	r8,r10,1
8000bb44:	e0 48 00 fe 	cp.w	r8,254
8000bb48:	e0 8b 00 04 	brhi	8000bb50 <getBaudDiv+0x1e>
		return -1;
	}

	return baudDiv;
8000bb4c:	5c 8c       	casts.h	r12
}
8000bb4e:	5e fc       	retal	r12

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);

	if (baudDiv <= 0 || baudDiv > 255) {
8000bb50:	5e fe       	retal	-1

8000bb52 <spi_initMaster>:
	return SPI_OK;
}

spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
8000bb52:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
8000bb54:	30 18       	mov	r8,1
	return SPI_OK;
}

spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
8000bb56:	18 99       	mov	r9,r12
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
8000bb58:	f7 3a 00 0d 	ld.ub	r10,r11[13]
8000bb5c:	f0 0a 18 00 	cp.b	r10,r8
8000bb60:	e0 88 00 04 	brls	8000bb68 <spi_initMaster+0x16>
8000bb64:	30 2c       	mov	r12,2
8000bb66:	d8 02       	popm	pc

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
	u_avr32_spi_mr.MR.mstr = 1;
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
	u_avr32_spi_mr.MR.llb = 0;
8000bb68:	30 0a       	mov	r10,0
	if (options->modfdis > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
8000bb6a:	e0 68 00 80 	mov	r8,128
8000bb6e:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
	u_avr32_spi_mr.MR.mstr = 1;
8000bb70:	30 1e       	mov	lr,1

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
8000bb72:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
8000bb74:	f7 3b 00 0d 	ld.ub	r11,r11[13]
	u_avr32_spi_mr.MR.llb = 0;
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
	spi->mr = u_avr32_spi_mr.mr;
8000bb78:	14 9c       	mov	r12,r10
	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
	u_avr32_spi_mr.MR.mstr = 1;
8000bb7a:	f1 de d0 01 	bfins	r8,lr,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
8000bb7e:	f1 db d0 81 	bfins	r8,r11,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
8000bb82:	f1 da d0 e1 	bfins	r8,r10,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
8000bb86:	30 fa       	mov	r10,15
8000bb88:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
8000bb8c:	93 18       	st.w	r9[0x4],r8

	return SPI_OK;
}
8000bb8e:	d8 02       	popm	pc

8000bb90 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
8000bb90:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
8000bb92:	30 18       	mov	r8,1
8000bb94:	f0 0b 18 00 	cp.b	r11,r8
8000bb98:	5f be       	srhi	lr
8000bb9a:	f0 0a 18 00 	cp.b	r10,r8
8000bb9e:	5f b8       	srhi	r8
8000bba0:	1c 48       	or	r8,lr
8000bba2:	c0 a1       	brne	8000bbb6 <spi_selectionMode+0x26>
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
8000bba4:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
8000bba6:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
8000bbaa:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
8000bbae:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
8000bbb2:	99 18       	st.w	r12[0x4],r8
8000bbb4:	d8 0a       	popm	pc,r12=0
		uint8_t pcs_decode,
		uint8_t delay)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
8000bbb6:	30 2c       	mov	r12,2
8000bbb8:	d8 02       	popm	pc

8000bbba <spi_selectChip>:
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
8000bbba:	78 19       	ld.w	r9,r12[0x4]

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000bbbc:	18 98       	mov	r8,r12
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
8000bbbe:	ea 19 00 0f 	orh	r9,0xf
8000bbc2:	99 19       	st.w	r12[0x4],r9

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
8000bbc4:	78 1c       	ld.w	r12,r12[0x4]
8000bbc6:	e2 1c 00 04 	andl	r12,0x4,COH
8000bbca:	c0 80       	breq	8000bbda <spi_selectChip+0x20>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
8000bbcc:	30 e9       	mov	r9,14
8000bbce:	f2 0b 18 00 	cp.b	r11,r9
8000bbd2:	e0 88 00 12 	brls	8000bbf6 <spi_selectChip+0x3c>
	} else {
		if (chip > 3) {
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
8000bbd6:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
8000bbd8:	5e fc       	retal	r12
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
8000bbda:	30 39       	mov	r9,3
8000bbdc:	f2 0b 18 00 	cp.b	r11,r9
8000bbe0:	fe 9b ff fb 	brhi	8000bbd6 <spi_selectChip+0x1c>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
8000bbe4:	70 19       	ld.w	r9,r8[0x4]
8000bbe6:	2f 0b       	sub	r11,-16
8000bbe8:	30 1a       	mov	r10,1
8000bbea:	f4 0b 09 4b 	lsl	r11,r10,r11
8000bbee:	5c db       	com	r11
8000bbf0:	12 6b       	and	r11,r9
8000bbf2:	91 1b       	st.w	r8[0x4],r11
8000bbf4:	5e fc       	retal	r12
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
8000bbf6:	70 19       	ld.w	r9,r8[0x4]
8000bbf8:	b1 6b       	lsl	r11,0x10
8000bbfa:	30 0c       	mov	r12,0
8000bbfc:	ea 1b ff f0 	orh	r11,0xfff0
8000bc00:	e8 1b ff ff 	orl	r11,0xffff
8000bc04:	12 6b       	and	r11,r9
8000bc06:	91 1b       	st.w	r8[0x4],r11
8000bc08:	5e fc       	retal	r12

8000bc0a <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000bc0a:	30 09       	mov	r9,0
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000bc0c:	c0 58       	rjmp	8000bc16 <spi_unselectChip+0xc>
8000bc0e:	2f f9       	sub	r9,-1
		if (!timeout--) {
8000bc10:	e0 49 3a 99 	cp.w	r9,15001
8000bc14:	c0 d0       	breq	8000bc2e <spi_unselectChip+0x24>

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000bc16:	78 48       	ld.w	r8,r12[0x10]
8000bc18:	ed b8 00 09 	bld	r8,0x9
8000bc1c:	cf 91       	brne	8000bc0e <spi_unselectChip+0x4>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
8000bc1e:	78 18       	ld.w	r8,r12[0x4]
8000bc20:	ea 18 00 0f 	orh	r8,0xf
8000bc24:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
8000bc26:	fc 18 01 00 	movh	r8,0x100
8000bc2a:	99 08       	st.w	r12[0x0],r8
8000bc2c:	5e fd       	retal	0
spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
8000bc2e:	5e ff       	retal	1

8000bc30 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
8000bc30:	eb cd 40 fe 	pushm	r1-r7,lr
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000bc34:	30 34       	mov	r4,3
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
8000bc36:	16 97       	mov	r7,r11
8000bc38:	18 96       	mov	r6,r12
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000bc3a:	f7 35 00 0c 	ld.ub	r5,r11[12]
8000bc3e:	e8 05 18 00 	cp.b	r5,r4
8000bc42:	e0 8b 00 09 	brhi	8000bc54 <spi_setupChipReg+0x24>
			options->stay_act > 1 ||
8000bc46:	f7 32 00 0b 	ld.ub	r2,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000bc4a:	30 13       	mov	r3,1
8000bc4c:	e6 02 18 00 	cp.b	r2,r3
8000bc50:	e0 88 00 05 	brls	8000bc5a <spi_setupChipReg+0x2a>
		spi->csr2 = u_avr32_spi_csr.csr;
		break;

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
		break;
8000bc54:	30 2c       	mov	r12,2
		}
	}
#endif

	return SPI_OK;
}
8000bc56:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
8000bc5a:	f7 31 00 08 	ld.ub	r1,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000bc5e:	30 78       	mov	r8,7
8000bc60:	f0 01 18 00 	cp.b	r1,r8
8000bc64:	fe 98 ff f8 	brls	8000bc54 <spi_setupChipReg+0x24>
8000bc68:	31 08       	mov	r8,16
8000bc6a:	f0 01 18 00 	cp.b	r1,r8
8000bc6e:	fe 9b ff f3 	brhi	8000bc54 <spi_setupChipReg+0x24>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
8000bc72:	14 9b       	mov	r11,r10
8000bc74:	6e 1c       	ld.w	r12,r7[0x4]
8000bc76:	c5 ef       	rcall	8000bb32 <getBaudDiv>
8000bc78:	ce e5       	brlt	8000bc54 <spi_setupChipReg+0x24>

	if (baudDiv < 0) {
8000bc7a:	0a 9a       	mov	r10,r5
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
8000bc7c:	ec 1a 00 01 	eorl	r10,0x1
8000bc80:	30 08       	mov	r8,0
	if (baudDiv < 0) {
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
8000bc82:	a1 95       	lsr	r5,0x1
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
8000bc84:	f1 d5 d0 01 	bfins	r8,r5,0x0,0x1
8000bc88:	f1 da d0 21 	bfins	r8,r10,0x1,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
8000bc8c:	ef 3a 00 09 	ld.ub	r10,r7[9]
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
8000bc90:	20 81       	sub	r1,8
	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
8000bc92:	f1 d2 d0 61 	bfins	r8,r2,0x3,0x1

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
8000bc96:	0f 89       	ld.ub	r9,r7[0x0]
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;

	switch (options->reg) {
8000bc98:	f1 d1 d0 84 	bfins	r8,r1,0x4,0x4
	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
8000bc9c:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
8000bca0:	f1 da d2 08 	bfins	r8,r10,0x10,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
8000bca4:	ef 3a 00 0a 	ld.ub	r10,r7[10]
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
8000bca8:	f1 da d3 08 	bfins	r8,r10,0x18,0x8
8000bcac:	e6 09 18 00 	cp.b	r9,r3

	switch (options->reg) {
8000bcb0:	c0 f0       	breq	8000bcce <spi_setupChipReg+0x9e>
8000bcb2:	c0 b3       	brcs	8000bcc8 <spi_setupChipReg+0x98>
8000bcb4:	30 2a       	mov	r10,2
8000bcb6:	f4 09 18 00 	cp.b	r9,r10
8000bcba:	c0 d0       	breq	8000bcd4 <spi_setupChipReg+0xa4>
8000bcbc:	e8 09 18 00 	cp.b	r9,r4
8000bcc0:	cc a1       	brne	8000bc54 <spi_setupChipReg+0x24>
8000bcc2:	8d f8       	st.w	r6[0x3c],r8
	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
		break;

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
8000bcc4:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
8000bcc8:	8d c8       	st.w	r6[0x30],r8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;

	switch (options->reg) {
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
8000bcca:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
8000bcce:	8d d8       	st.w	r6[0x34],r8
		break;

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
8000bcd0:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
8000bcd4:	8d e8       	st.w	r6[0x38],r8
		break;

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
8000bcd6:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
8000bcda:	d7 03       	nop

8000bcdc <spi_enable>:
8000bcdc:	30 18       	mov	r8,1
8000bcde:	99 08       	st.w	r12[0x0],r8
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
}
8000bce0:	5e fc       	retal	r12

8000bce2 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
8000bce2:	30 09       	mov	r9,0
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000bce4:	c0 58       	rjmp	8000bcee <spi_write+0xc>
8000bce6:	2f f9       	sub	r9,-1
		if (!timeout--) {
8000bce8:	e0 49 3a 99 	cp.w	r9,15001
8000bcec:	c0 80       	breq	8000bcfc <spi_write+0x1a>

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000bcee:	78 48       	ld.w	r8,r12[0x10]
8000bcf0:	ed b8 00 01 	bld	r8,0x1
8000bcf4:	cf 91       	brne	8000bce6 <spi_write+0x4>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
8000bcf6:	5c 7b       	castu.h	r11
8000bcf8:	99 3b       	st.w	r12[0xc],r11
8000bcfa:	5e fd       	retal	0
spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
		if (!timeout--) {
8000bcfc:	5e ff       	retal	1

8000bcfe <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
8000bcfe:	30 09       	mov	r9,0
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
8000bd00:	c0 58       	rjmp	8000bd0a <spi_read+0xc>
8000bd02:	2f f9       	sub	r9,-1
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
8000bd04:	e0 49 3a 99 	cp.w	r9,15001
8000bd08:	c0 b0       	breq	8000bd1e <spi_read+0x20>

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
8000bd0a:	78 48       	ld.w	r8,r12[0x10]
8000bd0c:	e2 18 02 01 	andl	r8,0x201,COH
8000bd10:	e0 48 02 01 	cp.w	r8,513
8000bd14:	cf 71       	brne	8000bd02 <spi_read+0x4>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
8000bd16:	78 28       	ld.w	r8,r12[0x8]
8000bd18:	30 0c       	mov	r12,0
8000bd1a:	b6 08       	st.h	r11[0x0],r8

	return SPI_OK;
}
8000bd1c:	5e fc       	retal	r12
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
8000bd1e:	5e ff       	retal	1

8000bd20 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
8000bd20:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
8000bd22:	f6 08 15 04 	lsl	r8,r11,0x4
8000bd26:	14 38       	cp.w	r8,r10
8000bd28:	e0 8b 00 26 	brhi	8000bd74 <usart_set_async_baudrate+0x54>
8000bd2c:	31 0e       	mov	lr,16
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
8000bd2e:	f0 09 16 01 	lsr	r9,r8,0x1
8000bd32:	f2 0a 00 39 	add	r9,r9,r10<<0x3
8000bd36:	f2 08 0d 08 	divu	r8,r9,r8
8000bd3a:	10 99       	mov	r9,r8
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
8000bd3c:	a3 98       	lsr	r8,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
8000bd3e:	f0 cb 00 01 	sub	r11,r8,1
8000bd42:	e0 4b ff fe 	cp.w	r11,65534
8000bd46:	e0 8b 00 1b 	brhi	8000bd7c <usart_set_async_baudrate+0x5c>
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
8000bd4a:	78 1a       	ld.w	r10,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
8000bd4c:	e8 6b 00 00 	mov	r11,524288
8000bd50:	e4 1a ff f7 	andh	r10,0xfff7
8000bd54:	e0 1a fe cf 	andl	r10,0xfecf
8000bd58:	59 0e       	cp.w	lr,16
8000bd5a:	f6 0e 17 10 	movne	lr,r11
8000bd5e:	f9 be 00 00 	moveq	lr,0
8000bd62:	fd ea 10 0a 	or	r10,lr,r10
8000bd66:	99 1a       	st.w	r12[0x4],r10
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
8000bd68:	f3 d9 c0 03 	bfextu	r9,r9,0x0,0x3
8000bd6c:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000bd70:	99 88       	st.w	r12[0x20],r8
8000bd72:	d8 0a       	popm	pc,r12=0
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
8000bd74:	f6 08 15 03 	lsl	r8,r11,0x3
8000bd78:	30 8e       	mov	lr,8
8000bd7a:	cd ab       	rjmp	8000bd2e <usart_set_async_baudrate+0xe>
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
8000bd7c:	da 0a       	popm	pc,r12=1

8000bd7e <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
8000bd7e:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
8000bd80:	ed b8 00 01 	bld	r8,0x1
8000bd84:	c0 51       	brne	8000bd8e <usart_write_char+0x10>
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
8000bd86:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
8000bd8a:	99 7b       	st.w	r12[0x1c],r11
8000bd8c:	5e fd       	retal	0
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
8000bd8e:	30 2c       	mov	r12,2
8000bd90:	5e fc       	retal	r12

8000bd92 <usart_write_line>:
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
8000bd92:	17 8a       	ld.ub	r10,r11[0x0]
8000bd94:	58 0a       	cp.w	r10,0
8000bd96:	5e 0c       	reteq	r12
8000bd98:	30 09       	mov	r9,0
8000bd9a:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
8000bd9c:	ed b8 00 01 	bld	r8,0x1
8000bda0:	c0 91       	brne	8000bdb2 <usart_write_line+0x20>
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
8000bda2:	f1 da c0 09 	bfextu	r8,r10,0x0,0x9


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
    usart_putchar(usart, *string++);
8000bda6:	2f fb       	sub	r11,-1

int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
8000bda8:	99 78       	st.w	r12[0x1c],r8
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
8000bdaa:	17 8a       	ld.ub	r10,r11[0x0]
8000bdac:	58 0a       	cp.w	r10,0
8000bdae:	cf 51       	brne	8000bd98 <usart_write_line+0x6>
8000bdb0:	5e fc       	retal	r12
8000bdb2:	2f f9       	sub	r9,-1
{
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
8000bdb4:	e0 49 27 10 	cp.w	r9,10000
8000bdb8:	cf 11       	brne	8000bd9a <usart_write_line+0x8>


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
    usart_putchar(usart, *string++);
8000bdba:	2f fb       	sub	r11,-1
8000bdbc:	cf 7b       	rjmp	8000bdaa <usart_write_line+0x18>
8000bdbe:	d7 03       	nop

8000bdc0 <usart_init_rs232>:
              AVR32_USART_CR_RTSDIS_MASK;
}


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
8000bdc0:	eb cd 40 e0 	pushm	r5-r7,lr
8000bdc4:	18 97       	mov	r7,r12
8000bdc6:	16 96       	mov	r6,r11
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
8000bdc8:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
8000bdcc:	ed b8 00 10 	bld	r8,0x10
8000bdd0:	c2 e1       	brne	8000be2c <usart_init_rs232+0x6c>
  usart->idr = 0xFFFFFFFF;
8000bdd2:	3f f8       	mov	r8,-1
8000bdd4:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000bdd6:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
8000bdd8:	30 08       	mov	r8,0
8000bdda:	8f 18       	st.w	r7[0x4],r8
  usart->rtor = 0;
8000bddc:	8f 98       	st.w	r7[0x24],r8
  usart->ttgr = 0;
8000bdde:	8f a8       	st.w	r7[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
8000bde0:	ea 68 61 0c 	mov	r8,680204
8000bde4:	8f 08       	st.w	r7[0x0],r8
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000bde6:	58 06       	cp.w	r6,0
8000bde8:	c2 00       	breq	8000be28 <usart_init_rs232+0x68>
      opt->charlength < 5 || opt->charlength > 9 ||
8000bdea:	0d c8       	ld.ub	r8,r6[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000bdec:	30 49       	mov	r9,4
8000bdee:	f2 08 18 00 	cp.b	r8,r9
8000bdf2:	e0 88 00 1b 	brls	8000be28 <usart_init_rs232+0x68>
8000bdf6:	30 95       	mov	r5,9
8000bdf8:	ea 08 18 00 	cp.b	r8,r5
8000bdfc:	e0 8b 00 16 	brhi	8000be28 <usart_init_rs232+0x68>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
8000be00:	0d d9       	ld.ub	r9,r6[0x5]
8000be02:	30 78       	mov	r8,7
8000be04:	f0 09 18 00 	cp.b	r9,r8
8000be08:	e0 8b 00 10 	brhi	8000be28 <usart_init_rs232+0x68>
      opt->stopbits > 2 + 255 ||
8000be0c:	8c 39       	ld.sh	r9,r6[0x6]
8000be0e:	e0 68 01 01 	mov	r8,257
8000be12:	f0 09 19 00 	cp.h	r9,r8
8000be16:	e0 8b 00 09 	brhi	8000be28 <usart_init_rs232+0x68>
      opt->channelmode > 3 ||
8000be1a:	ed 39 00 08 	ld.ub	r9,r6[8]
8000be1e:	30 38       	mov	r8,3
8000be20:	f0 09 18 00 	cp.b	r9,r8
8000be24:	e0 88 00 0a 	brls	8000be38 <usart_init_rs232+0x78>
  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
8000be28:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
8000be2c:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
8000be2e:	3f f8       	mov	r8,-1
8000be30:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000be32:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
8000be34:	d5 03       	csrf	0x10
8000be36:	cd 1b       	rjmp	8000bdd8 <usart_init_rs232+0x18>
  if (!opt || // Null pointer.
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
8000be38:	6c 0b       	ld.w	r11,r6[0x0]
8000be3a:	0e 9c       	mov	r12,r7
8000be3c:	c7 2f       	rcall	8000bd20 <usart_set_async_baudrate>
8000be3e:	58 1c       	cp.w	r12,1
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000be40:	cf 40       	breq	8000be28 <usart_init_rs232+0x68>
8000be42:	0d c8       	ld.ub	r8,r6[0x4]
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
8000be44:	ea 08 18 00 	cp.b	r8,r5
8000be48:	c2 a0       	breq	8000be9c <usart_init_rs232+0xdc>
8000be4a:	6e 19       	ld.w	r9,r7[0x4]
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
8000be4c:	20 58       	sub	r8,5
8000be4e:	f3 e8 10 68 	or	r8,r9,r8<<0x6
8000be52:	8f 18       	st.w	r7[0x4],r8
8000be54:	6e 19       	ld.w	r9,r7[0x4]
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
8000be56:	ed 3a 00 08 	ld.ub	r10,r6[8]
8000be5a:	0d d8       	ld.ub	r8,r6[0x5]
8000be5c:	a9 78       	lsl	r8,0x9
8000be5e:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
8000be62:	12 48       	or	r8,r9
8000be64:	8f 18       	st.w	r7[0x4],r8
8000be66:	30 29       	mov	r9,2
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
8000be68:	8c 38       	ld.sh	r8,r6[0x6]
8000be6a:	f2 08 19 00 	cp.h	r8,r9
8000be6e:	e0 88 00 11 	brls	8000be90 <usart_init_rs232+0xd0>
8000be72:	6e 18       	ld.w	r8,r7[0x4]
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
8000be74:	ad b8       	sbr	r8,0xd
8000be76:	8f 18       	st.w	r7[0x4],r8
8000be78:	8c b8       	ld.uh	r8,r6[0x6]
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
8000be7a:	20 28       	sub	r8,2
8000be7c:	8f a8       	st.w	r7[0x28],r8
8000be7e:	6e 18       	ld.w	r8,r7[0x4]
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
8000be80:	e0 18 ff f0 	andl	r8,0xfff0
8000be84:	8f 18       	st.w	r7[0x4],r8
8000be86:	30 0c       	mov	r12,0
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
8000be88:	35 08       	mov	r8,80
8000be8a:	8f 08       	st.w	r7[0x0],r8
8000be8c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
8000be90:	6e 19       	ld.w	r9,r7[0x4]
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
8000be92:	5c 78       	castu.h	r8
8000be94:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
8000be98:	8f 18       	st.w	r7[0x4],r8
8000be9a:	cf 2b       	rjmp	8000be7e <usart_init_rs232+0xbe>
8000be9c:	6e 18       	ld.w	r8,r7[0x4]
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
8000be9e:	b1 b8       	sbr	r8,0x11
8000bea0:	8f 18       	st.w	r7[0x4],r8
8000bea2:	cd 9b       	rjmp	8000be54 <usart_init_rs232+0x94>

8000bea4 <fat_check_is_file>:
//! @return    true  It is a file and not a directory
//! @return    false otherwise
//!
bool  fat_check_is_file( void )
{
   if( Fat_is_not_a_file )
8000bea4:	e0 68 0c ec 	mov	r8,3308
8000bea8:	11 a8       	ld.ub	r8,r8[0x2]
8000beaa:	e2 18 00 18 	andl	r8,0x18,COH
   {
      fs_g_status = FS_ERR_NO_FILE;   // It isn't a file, it is a directory or a volume id
8000beae:	c0 70       	breq	8000bebc <fat_check_is_file+0x18>
8000beb0:	31 39       	mov	r9,19
8000beb2:	e0 68 0f 7c 	mov	r8,3964
      return false;
   }
   return true;
}
8000beb6:	30 0c       	mov	r12,0
//! @return    true  It is a file and not a directory
//! @return    false otherwise
//!
bool  fat_check_is_file( void )
{
   if( Fat_is_not_a_file )
8000beb8:	b0 89       	st.b	r8[0x0],r9
8000beba:	5e fc       	retal	r12
8000bebc:	5e ff       	retal	1
8000bebe:	d7 03       	nop

8000bec0 <fat_cache_clusterlist_reset>:
8000bec0:	3f f9       	mov	r9,-1
8000bec2:	e0 68 0d 00 	mov	r8,3328
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
      fs_g_cache_clusterlist[u8_i].u8_level_use = 0xFF;
8000bec6:	f1 69 00 15 	st.b	r8[21],r9
8000beca:	b0 a9       	st.b	r8[0x2],r9
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
8000becc:	b0 99       	st.b	r8[0x1],r9
8000bece:	f1 69 00 16 	st.b	r8[22],r9
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
8000bed2:	30 09       	mov	r9,0
8000bed4:	f1 69 00 14 	st.b	r8[20],r9
//! This function resets the cluster list caches
//!
void  fat_cache_clusterlist_reset( void )
{
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
8000bed8:	e0 6a 0f 7e 	mov	r10,3966
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
8000bedc:	b4 89       	st.b	r10[0x0],r9
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
      fs_g_cache_clusterlist[u8_i].u8_level_use = 0xFF;
   }
}
8000bede:	30 19       	mov	r9,1
8000bee0:	b0 89       	st.b	r8[0x0],r9
8000bee2:	5e fc       	retal	r12

8000bee4 <fat_cache_clusterlist_update_finish>:
8000bee4:	eb cd 40 c0 	pushm	r6-r7,lr

//! This function updates a cache of cluster list caches
//!
void  fat_cache_clusterlist_update_finish( void )
{
   uint8_t u8_cluster_offset = fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start % fs_g_nav.u8_BPB_SecPerClus;
8000bee8:	e0 68 0f 7e 	mov	r8,3966
8000beec:	e0 6e 0f 2c 	mov	lr,3884
8000bef0:	11 8c       	ld.ub	r12,r8[0x0]
8000bef2:	1d 87       	ld.ub	r7,lr[0x0]
8000bef4:	e0 69 0d 00 	mov	r9,3328
8000bef8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000befc:	f2 0c 00 28 	add	r8,r9,r12<<0x2
8000bf00:	b0 a7       	st.b	r8[0x2],r7
8000bf02:	70 2a       	ld.w	r10,r8[0x8]
8000bf04:	1d 97       	ld.ub	r7,lr[0x1]
8000bf06:	f0 cb ff f8 	sub	r11,r8,-8
8000bf0a:	f4 07 0d 06 	divu	r6,r10,r7
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = fs_g_nav.u8_lun;          // valid cache
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start   -= u8_cluster_offset;
8000bf0e:	76 0e       	ld.w	lr,r11[0x0]
8000bf10:	0e 9a       	mov	r10,r7
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_addr     = fs_g_seg.u32_addr - u8_cluster_offset;
8000bf12:	5c 5a       	castu.b	r10
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_size     = fs_g_seg.u32_size_or_pos + u8_cluster_offset;
8000bf14:	14 1e       	sub	lr,r10
8000bf16:	97 0e       	st.w	r11[0x0],lr
8000bf18:	e0 6b 0f d4 	mov	r11,4052
void  fat_cache_clusterlist_update_finish( void )
{
   uint8_t u8_cluster_offset = fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start % fs_g_nav.u8_BPB_SecPerClus;
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = fs_g_nav.u8_lun;          // valid cache
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start   -= u8_cluster_offset;
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_addr     = fs_g_seg.u32_addr - u8_cluster_offset;
8000bf1c:	76 1e       	ld.w	lr,r11[0x4]
8000bf1e:	f4 0e 00 0e 	add	lr,r10,lr
   uint8_t u8_i;
   uint8_t u8_level_to_update;
   bool b_file_cache;

   b_file_cache         = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].b_cache_file;
   u8_level_to_update   = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].u8_level_use;
8000bf22:	91 4e       	st.w	r8[0x10],lr
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( fs_g_cache_clusterlist[u8_i].b_cache_file == b_file_cache )
8000bf24:	76 0b       	ld.w	r11,r11[0x0]
{
   uint8_t u8_i;
   uint8_t u8_level_to_update;
   bool b_file_cache;

   b_file_cache         = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].b_cache_file;
8000bf26:	14 1b       	sub	r11,r10
   u8_level_to_update   = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].u8_level_use;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( fs_g_cache_clusterlist[u8_i].b_cache_file == b_file_cache )
8000bf28:	91 3b       	st.w	r8[0xc],r11
8000bf2a:	11 9b       	ld.ub	r11,r8[0x1]
8000bf2c:	13 8a       	ld.ub	r10,r9[0x0]
8000bf2e:	11 88       	ld.ub	r8,r8[0x0]
8000bf30:	f0 0a 18 00 	cp.b	r10,r8
8000bf34:	c0 e0       	breq	8000bf50 <fat_cache_clusterlist_update_finish+0x6c>
8000bf36:	e0 6e 0d 00 	mov	lr,3328
         if( u8_level_to_update > fs_g_cache_clusterlist[u8_i].u8_level_use )
           fs_g_cache_clusterlist[u8_i].u8_level_use++;
   }
   fs_g_cache_clusterlist[  fs_g_u8_current_cache  ].u8_level_use = 0;
8000bf3a:	f3 3a 00 14 	ld.ub	r10,r9[20]
8000bf3e:	f0 0a 18 00 	cp.b	r10,r8
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_addr     = fs_g_seg.u32_addr - u8_cluster_offset;
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_size     = fs_g_seg.u32_size_or_pos + u8_cluster_offset;

   // Update the "level used" of cache
   fat_cache_clusterlist_update_select();
}
8000bf42:	c0 f0       	breq	8000bf60 <fat_cache_clusterlist_update_finish+0x7c>
8000bf44:	f2 0c 00 29 	add	r9,r9,r12<<0x2
   u8_level_to_update   = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].u8_level_use;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( fs_g_cache_clusterlist[u8_i].b_cache_file == b_file_cache )
         if( u8_level_to_update > fs_g_cache_clusterlist[u8_i].u8_level_use )
           fs_g_cache_clusterlist[u8_i].u8_level_use++;
8000bf48:	30 08       	mov	r8,0
8000bf4a:	b2 98       	st.b	r9[0x1],r8
8000bf4c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000bf50:	13 9a       	ld.ub	r10,r9[0x1]
8000bf52:	f6 0a 18 00 	cp.b	r10,r11
   b_file_cache         = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].b_cache_file;
   u8_level_to_update   = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].u8_level_use;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( fs_g_cache_clusterlist[u8_i].b_cache_file == b_file_cache )
         if( u8_level_to_update > fs_g_cache_clusterlist[u8_i].u8_level_use )
8000bf56:	f7 ba 03 ff 	sublo	r10,-1
           fs_g_cache_clusterlist[u8_i].u8_level_use++;
8000bf5a:	f3 fa 3e 01 	st.bcs	r9[0x1],r10
8000bf5e:	ce cb       	rjmp	8000bf36 <fat_cache_clusterlist_update_finish+0x52>
8000bf60:	fd 38 00 15 	ld.ub	r8,lr[21]
8000bf64:	f0 0b 18 00 	cp.b	r11,r8
   }
   fs_g_cache_clusterlist[  fs_g_u8_current_cache  ].u8_level_use = 0;
8000bf68:	f7 b8 0b ff 	subhi	r8,-1
8000bf6c:	fd f8 be 15 	st.bhi	lr[0x15],r8
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_addr     = fs_g_seg.u32_addr - u8_cluster_offset;
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_size     = fs_g_seg.u32_size_or_pos + u8_cluster_offset;

   // Update the "level used" of cache
   fat_cache_clusterlist_update_select();
}
8000bf70:	f2 0c 00 29 	add	r9,r9,r12<<0x2
8000bf74:	30 08       	mov	r8,0
8000bf76:	b2 98       	st.b	r9[0x1],r8
8000bf78:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

8000bf7c <fat_entry_check>:
8000bf7c:	e0 68 0f 78 	mov	r8,3960
8000bf80:	90 99       	ld.uh	r9,r8[0x2]
8000bf82:	e0 68 0d 2c 	mov	r8,3372
//!
//! @return a pointer on the internal cache
//!
PTR_CACHE fat_get_ptr_entry( void )
{
   return &fs_g_sector[(fs_g_nav_fast.u16_entry_pos_sel_file * FS_SIZE_FILE_ENTRY) & FS_512B_MASK];
8000bf86:	a5 79       	lsl	r9,0x5
8000bf88:	f3 d9 c0 09 	bfextu	r9,r9,0x0,0x9
   uint8_t u8_attribut;

   u8_ptr_entry = fat_get_ptr_entry();

   u8_first_byte = u8_ptr_entry[0];
   if ( FS_ENTRY_END == u8_first_byte )
8000bf8c:	10 09       	add	r9,r8
8000bf8e:	13 88       	ld.ub	r8,r9[0x0]
   {
      fs_g_status = FS_ERR_ENTRY_EMPTY;   // end of directory
      return false;
   }
   fs_g_status = FS_ERR_ENTRY_BAD;        // by default BAD ENTRY
8000bf90:	58 08       	cp.w	r8,0
8000bf92:	c1 a0       	breq	8000bfc6 <fat_entry_check+0x4a>
8000bf94:	e0 6a 0f 7c 	mov	r10,3964
   if ( FS_ENTRY_DEL == u8_first_byte )      { return false;   } // entry deleted
8000bf98:	30 bb       	mov	r11,11
8000bf9a:	b4 8b       	st.b	r10[0x0],r11
8000bf9c:	3e 5a       	mov	r10,-27
   if (   '.'  == u8_first_byte )            { return false;   } // current dir "."
8000bf9e:	f4 08 18 00 	cp.b	r8,r10
8000bfa2:	c1 10       	breq	8000bfc4 <fat_entry_check+0x48>
8000bfa4:	32 ea       	mov	r10,46
   if ( ('.'  == u8_first_byte)
   &&   ('.'  == u8_seconde_byte) )          { return false;   } // current dir ".."

   // Check Attribute
   u8_attribut = u8_ptr_entry[11];
   if ( FS_ATTR_VOLUME_ID & u8_attribut )    { return false;   } // volume id
8000bfa6:	f4 08 18 00 	cp.b	r8,r10
8000bfaa:	c0 d0       	breq	8000bfc4 <fat_entry_check+0x48>
8000bfac:	f3 38 00 0b 	ld.ub	r8,r9[11]
   // Optimization, this line isn't necessary because the next test control this case
   // if ( FS_ATTR_LFN_ENTRY == *u8_ptr_entry) { return false;   } // long file name

   // Check entry type
   if( FS_ATTR_DIRECTORY & u8_attribut )
8000bfb0:	ed b8 00 03 	bld	r8,0x3
8000bfb4:	c0 80       	breq	8000bfc4 <fat_entry_check+0x48>
   {
      return (FS_DIR == b_type);
8000bfb6:	ed b8 00 04 	bld	r8,0x4
8000bfba:	5e 1c       	retne	r12
8000bfbc:	ec 1c 00 01 	eorl	r12,0x1
   u8_ptr_entry = fat_get_ptr_entry();

   u8_first_byte = u8_ptr_entry[0];
   if ( FS_ENTRY_END == u8_first_byte )
   {
      fs_g_status = FS_ERR_ENTRY_EMPTY;   // end of directory
8000bfc0:	5c 5c       	castu.b	r12
8000bfc2:	5e fc       	retal	r12
8000bfc4:	5e fd       	retal	0
8000bfc6:	10 9c       	mov	r12,r8
      return false;
8000bfc8:	30 a9       	mov	r9,10
8000bfca:	e0 68 0f 7c 	mov	r8,3964
8000bfce:	b0 89       	st.b	r8[0x0],r9
8000bfd0:	5e fc       	retal	r12
8000bfd2:	d7 03       	nop

8000bfd4 <fat_entry_checkext>:
8000bfd4:	eb cd 40 f8 	pushm	r3-r7,lr
//!
//! @return a pointer on the internal cache
//!
PTR_CACHE fat_get_ptr_entry( void )
{
   return &fs_g_sector[(fs_g_nav_fast.u16_entry_pos_sel_file * FS_SIZE_FILE_ENTRY) & FS_512B_MASK];
8000bfd8:	e0 68 0f 78 	mov	r8,3960
8000bfdc:	30 0a       	mov	r10,0

   // Compare the extension with filter
   for( u8_i=0 ; u8_i<3 ; u8_i++)
   {
      u8_filter_char = *sz_filter;
      if ('*' == u8_filter_char)
8000bfde:	90 95       	ld.uh	r5,r8[0x2]
//!
//! @return a pointer on the internal cache
//!
PTR_CACHE fat_get_ptr_entry( void )
{
   return &fs_g_sector[(fs_g_nav_fast.u16_entry_pos_sel_file * FS_SIZE_FILE_ENTRY) & FS_512B_MASK];
8000bfe0:	32 a6       	mov	r6,42
8000bfe2:	a5 75       	lsl	r5,0x5
8000bfe4:	e0 68 0d 2c 	mov	r8,3372
   uint8_t u8_i, u8_filter_char, u8_entry_char;

   u8_ptr_entry = fat_get_ptr_entry();

   // Compare the extension with filter
   for( u8_i=0 ; u8_i<3 ; u8_i++)
8000bfe8:	eb d5 c0 09 	bfextu	r5,r5,0x0,0x9
      // Compare the extension filter to extension file (this one ignore the case)
      if( (u8_filter_char!=  u8_entry_char     )
      &&  (u8_filter_char!= (u8_entry_char+('a'-'A'))) )
      {
         if ( (',' == u8_filter_char)
         ||   ( 0  == u8_filter_char) )
8000bfec:	30 24       	mov	r4,2

      // Compare the extension filter to extension file (this one ignore the case)
      if( (u8_filter_char!=  u8_entry_char     )
      &&  (u8_filter_char!= (u8_entry_char+('a'-'A'))) )
      {
         if ( (',' == u8_filter_char)
8000bfee:	10 05       	add	r5,r8
         ||   ( 0  == u8_filter_char) )
         {
           // It is the end of filter
           if (' ' == u8_entry_char)
8000bff0:	14 97       	mov	r7,r10
   u8_ptr_entry = fat_get_ptr_entry();

   // Compare the extension with filter
   for( u8_i=0 ; u8_i<3 ; u8_i++)
   {
      u8_filter_char = *sz_filter;
8000bff2:	32 c9       	mov	r9,44
      if ('*' == u8_filter_char)
8000bff4:	32 03       	mov	r3,32
8000bff6:	19 88       	ld.ub	r8,r12[0x0]
8000bff8:	ec 08 18 00 	cp.b	r8,r6
         break; // All extension is good

      u8_entry_char = u8_ptr_entry[8+u8_i];
8000bffc:	c3 40       	breq	8000c064 <fat_entry_checkext+0x90>
8000bffe:	ea 0a 00 0b 	add	r11,r5,r10

      // Compare the extension filter to extension file (this one ignore the case)
      if( (u8_filter_char!=  u8_entry_char     )
8000c002:	f7 3b 00 08 	ld.ub	r11,r11[8]
8000c006:	f6 08 18 00 	cp.b	r8,r11
8000c00a:	c2 30       	breq	8000c050 <fat_entry_checkext+0x7c>
8000c00c:	f6 ce ff e0 	sub	lr,r11,-32
      &&  (u8_filter_char!= (u8_entry_char+('a'-'A'))) )
      {
         if ( (',' == u8_filter_char)
         ||   ( 0  == u8_filter_char) )
8000c010:	1c 38       	cp.w	r8,lr
8000c012:	c1 f0       	breq	8000c050 <fat_entry_checkext+0x7c>
8000c014:	ee 08 18 00 	cp.b	r8,r7

      // Compare the extension filter to extension file (this one ignore the case)
      if( (u8_filter_char!=  u8_entry_char     )
      &&  (u8_filter_char!= (u8_entry_char+('a'-'A'))) )
      {
         if ( (',' == u8_filter_char)
8000c018:	5f 0a       	sreq	r10
8000c01a:	f2 08 18 00 	cp.b	r8,r9
8000c01e:	5f 0e       	sreq	lr
8000c020:	f5 ee 10 0e 	or	lr,r10,lr
8000c024:	ee 0e 18 00 	cp.b	lr,r7
         ||   ( 0  == u8_filter_char) )
         {
           // It is the end of filter
           if (' ' == u8_entry_char)
8000c028:	c0 40       	breq	8000c030 <fat_entry_checkext+0x5c>
8000c02a:	e6 0b 18 00 	cp.b	r11,r3
              break; // it is the end of extension file -> extension good
         }
         // here, bad extension

         // Search the next filter
         while( ',' != u8_filter_char )
8000c02e:	c1 b0       	breq	8000c064 <fat_entry_checkext+0x90>
8000c030:	f2 08 18 00 	cp.b	r8,r9
         {
            if (0  == u8_filter_char)
8000c034:	c0 b0       	breq	8000c04a <fat_entry_checkext+0x76>
8000c036:	58 0a       	cp.w	r10,0
8000c038:	c0 40       	breq	8000c040 <fat_entry_checkext+0x6c>
8000c03a:	c1 38       	rjmp	8000c060 <fat_entry_checkext+0x8c>
            {
               return false;   // it is the last filter
            }
            sz_filter++;
8000c03c:	58 08       	cp.w	r8,0
            u8_filter_char = *sz_filter;
8000c03e:	c1 10       	breq	8000c060 <fat_entry_checkext+0x8c>
              break; // it is the end of extension file -> extension good
         }
         // here, bad extension

         // Search the next filter
         while( ',' != u8_filter_char )
8000c040:	2f fc       	sub	r12,-1
8000c042:	19 88       	ld.ub	r8,r12[0x0]
8000c044:	f2 08 18 00 	cp.b	r8,r9
            sz_filter++;
            u8_filter_char = *sz_filter;
         }
         u8_i = 0xFF;          // restart loop compare
      }
      sz_filter++; // go to next char of filter
8000c048:	cf a1       	brne	8000c03c <fat_entry_checkext+0x68>
8000c04a:	2f fc       	sub	r12,-1
   uint8_t u8_i, u8_filter_char, u8_entry_char;

   u8_ptr_entry = fat_get_ptr_entry();

   // Compare the extension with filter
   for( u8_i=0 ; u8_i<3 ; u8_i++)
8000c04c:	30 0a       	mov	r10,0
8000c04e:	cd 4b       	rjmp	8000bff6 <fat_entry_checkext+0x22>
8000c050:	2f fa       	sub	r10,-1
8000c052:	5c 5a       	castu.b	r10
8000c054:	e8 0a 18 00 	cp.b	r10,r4
            sz_filter++;
            u8_filter_char = *sz_filter;
         }
         u8_i = 0xFF;          // restart loop compare
      }
      sz_filter++; // go to next char of filter
8000c058:	e0 8b 00 06 	brhi	8000c064 <fat_entry_checkext+0x90>
8000c05c:	2f fc       	sub	r12,-1
8000c05e:	cc cb       	rjmp	8000bff6 <fat_entry_checkext+0x22>
8000c060:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
8000c064:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1

8000c068 <fat_get_entry_info>:
8000c068:	eb cd 40 c0 	pushm	r6-r7,lr
//!
//! @return a pointer on the internal cache
//!
PTR_CACHE fat_get_ptr_entry( void )
{
   return &fs_g_sector[(fs_g_nav_fast.u16_entry_pos_sel_file * FS_SIZE_FILE_ENTRY) & FS_512B_MASK];
8000c06c:	e0 69 0f 78 	mov	r9,3960
8000c070:	92 9b       	ld.uh	r11,r9[0x2]
8000c072:	e0 69 0d 2c 	mov	r9,3372
8000c076:	a5 7b       	lsl	r11,0x5
8000c078:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
   ptr_entry += (26-20);
   LSB0(fs_g_nav_entry.u32_cluster) = ptr_entry[0];
   LSB1(fs_g_nav_entry.u32_cluster) = ptr_entry[1];

   // Get the size of file
   ptr_entry += (28-26);
8000c07c:	12 0b       	add	r11,r9
   LSB0(fs_g_nav_entry.u32_size) = ptr_entry[0];
   LSB1(fs_g_nav_entry.u32_size) = ptr_entry[1];
   LSB2(fs_g_nav_entry.u32_size) = ptr_entry[2];
   LSB3(fs_g_nav_entry.u32_size) = ptr_entry[3];
8000c07e:	f6 c9 ff e4 	sub	r9,r11,-28
   // Get Attribute
   ptr_entry+= 11;
   fs_g_nav_entry.u8_attr = ptr_entry[0];

   // Get the first cluster of the file cluster list
   ptr_entry += (20-11);
8000c082:	13 be       	ld.ub	lr,r9[0x3]
8000c084:	e0 6c 0c ec 	mov	r12,3308
   LSB0(fs_g_nav_entry.u32_cluster) = ptr_entry[0];
   LSB1(fs_g_nav_entry.u32_cluster) = ptr_entry[1];

   // Get the size of file
   ptr_entry += (28-26);
   LSB0(fs_g_nav_entry.u32_size) = ptr_entry[0];
8000c088:	f6 c7 ff ec 	sub	r7,r11,-20
   fs_g_nav_entry.u8_attr = ptr_entry[0];

   // Get the first cluster of the file cluster list
   ptr_entry += (20-11);
   LSB2(fs_g_nav_entry.u32_cluster) = ptr_entry[0];
   LSB3(fs_g_nav_entry.u32_cluster) = ptr_entry[1];
8000c08c:	f8 c8 ff f8 	sub	r8,r12,-8
   ptr_entry+= 11;
   fs_g_nav_entry.u8_attr = ptr_entry[0];

   // Get the first cluster of the file cluster list
   ptr_entry += (20-11);
   LSB2(fs_g_nav_entry.u32_cluster) = ptr_entry[0];
8000c090:	b0 8e       	st.b	r8[0x0],lr
   LSB3(fs_g_nav_entry.u32_cluster) = ptr_entry[1];
8000c092:	0f 9e       	ld.ub	lr,r7[0x1]
   ptr_entry += (26-20);
8000c094:	f8 ca ff fc 	sub	r10,r12,-4
   LSB0(fs_g_nav_entry.u32_cluster) = ptr_entry[0];
   LSB1(fs_g_nav_entry.u32_cluster) = ptr_entry[1];
8000c098:	b4 8e       	st.b	r10[0x0],lr
8000c09a:	f6 ce ff e6 	sub	lr,r11,-26

   ptr_entry = fat_get_ptr_entry();

   // Get Attribute
   ptr_entry+= 11;
   fs_g_nav_entry.u8_attr = ptr_entry[0];
8000c09e:	1d 96       	ld.ub	r6,lr[0x1]
8000c0a0:	b4 a6       	st.b	r10[0x2],r6

   // Get the first cluster of the file cluster list
   ptr_entry += (20-11);
   LSB2(fs_g_nav_entry.u32_cluster) = ptr_entry[0];
8000c0a2:	f7 3b 00 0b 	ld.ub	r11,r11[11]
   LSB3(fs_g_nav_entry.u32_cluster) = ptr_entry[1];
   ptr_entry += (26-20);
   LSB0(fs_g_nav_entry.u32_cluster) = ptr_entry[0];
8000c0a6:	b8 ab       	st.b	r12[0x2],r11
8000c0a8:	0f 8b       	ld.ub	r11,r7[0x0]
   LSB1(fs_g_nav_entry.u32_cluster) = ptr_entry[1];

   // Get the size of file
   ptr_entry += (28-26);
   LSB0(fs_g_nav_entry.u32_size) = ptr_entry[0];
8000c0aa:	b4 9b       	st.b	r10[0x1],r11
8000c0ac:	1d 8b       	ld.ub	r11,lr[0x0]
   LSB1(fs_g_nav_entry.u32_size) = ptr_entry[1];
8000c0ae:	b4 bb       	st.b	r10[0x3],r11
8000c0b0:	13 8a       	ld.ub	r10,r9[0x0]
   LSB2(fs_g_nav_entry.u32_size) = ptr_entry[2];
8000c0b2:	b0 ba       	st.b	r8[0x3],r10
8000c0b4:	13 9a       	ld.ub	r10,r9[0x1]
   LSB3(fs_g_nav_entry.u32_size) = ptr_entry[3];
}
8000c0b6:	b0 aa       	st.b	r8[0x2],r10
8000c0b8:	13 a9       	ld.ub	r9,r9[0x2]
8000c0ba:	b0 99       	st.b	r8[0x1],r9
8000c0bc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

8000c0c0 <fat_entry_is_dir>:
8000c0c0:	e0 68 0f 7c 	mov	r8,3964
8000c0c4:	30 d9       	mov	r9,13
8000c0c6:	b0 89       	st.b	r8[0x0],r9
//! @return    true,    this entry is a directory
//! @return    false,   otherwise
//!
bool  fat_entry_is_dir(void)
{
   fs_g_status = FS_ERR_NO_DIR;
8000c0c8:	e0 68 0c ec 	mov	r8,3308
   return (FS_ATTR_DIRECTORY & fs_g_nav_entry.u8_attr);
}
8000c0cc:	11 ac       	ld.ub	r12,r8[0x2]
8000c0ce:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
8000c0d2:	5e fc       	retal	r12

8000c0d4 <fat_clear_entry_info_and_ptr>:
8000c0d4:	3f f9       	mov	r9,-1
8000c0d6:	e0 68 0f 2c 	mov	r8,3884
//! This function resets the selection pointers
//!
void  fat_clear_entry_info_and_ptr( void )
{
   fs_g_nav_fast.u16_entry_pos_sel_file= FS_NO_SEL;
   fs_g_nav.u16_pos_sel_file           = FS_NO_SEL;
8000c0da:	e0 6a 0f 78 	mov	r10,3960

//! This function resets the selection pointers
//!
void  fat_clear_entry_info_and_ptr( void )
{
   fs_g_nav_fast.u16_entry_pos_sel_file= FS_NO_SEL;
8000c0de:	f1 59 00 24 	st.h	r8[36],r9
   fs_g_nav.u16_pos_sel_file           = FS_NO_SEL;
   if( !fs_g_nav.b_mode_nav_single )
8000c0e2:	b4 19       	st.h	r10[0x2],r9
   {
      fs_g_nav.b_mode_nav                 = FS_DIR;
8000c0e4:	f1 39 00 2d 	ld.ub	r9,r8[45]
8000c0e8:	58 09       	cp.w	r9,0
   }
   fs_g_nav_entry.u8_attr     = 0;
8000c0ea:	f1 f9 0e 2c 	st.beq	r8[0x2c],r9
   fs_g_nav_entry.u32_cluster = 0;
   fs_g_nav_entry.u32_size    = 0;
   Fat_file_close();
8000c0ee:	e0 68 0c ec 	mov	r8,3308
   {
      fs_g_nav.b_mode_nav                 = FS_DIR;
   }
   fs_g_nav_entry.u8_attr     = 0;
   fs_g_nav_entry.u32_cluster = 0;
   fs_g_nav_entry.u32_size    = 0;
8000c0f2:	30 09       	mov	r9,0
   fs_g_nav.u16_pos_sel_file           = FS_NO_SEL;
   if( !fs_g_nav.b_mode_nav_single )
   {
      fs_g_nav.b_mode_nav                 = FS_DIR;
   }
   fs_g_nav_entry.u8_attr     = 0;
8000c0f4:	b0 89       	st.b	r8[0x0],r9
   fs_g_nav_entry.u32_cluster = 0;
   fs_g_nav_entry.u32_size    = 0;
   Fat_file_close();
}
8000c0f6:	91 19       	st.w	r8[0x4],r9
8000c0f8:	91 29       	st.w	r8[0x8],r9
8000c0fa:	b0 a9       	st.b	r8[0x2],r9
8000c0fc:	5e fc       	retal	r12
8000c0fe:	d7 03       	nop

8000c100 <fat_write_entry_file>:
8000c100:	e0 6a 0d 2c 	mov	r10,3372
//!
//! @return a pointer on the internal cache
//!
PTR_CACHE fat_get_ptr_entry( void )
{
   return &fs_g_sector[(fs_g_nav_fast.u16_entry_pos_sel_file * FS_SIZE_FILE_ENTRY) & FS_512B_MASK];
8000c104:	e0 69 0c ec 	mov	r9,3308
8000c108:	e0 68 0f 78 	mov	r8,3960
8000c10c:	90 98       	ld.uh	r8,r8[0x2]
8000c10e:	a5 78       	lsl	r8,0x5
         fs_g_nav_entry.u32_cluster = 0;
   }

   //! Write the Attribute
   ptr_entry+= 11;
   ptr_entry[0] = fs_g_nav_entry.u8_attr;
8000c110:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
8000c114:	14 08       	add	r8,r10

   // Write the first cluster of file cluster list
   ptr_entry += (20-11);
   ptr_entry[0] = LSB2(fs_g_nav_entry.u32_cluster);
8000c116:	13 aa       	ld.ub	r10,r9[0x2]
8000c118:	f1 6a 00 0b 	st.b	r8[11],r10
   //! Write the Attribute
   ptr_entry+= 11;
   ptr_entry[0] = fs_g_nav_entry.u8_attr;

   // Write the first cluster of file cluster list
   ptr_entry += (20-11);
8000c11c:	f2 ca ff fc 	sub	r10,r9,-4
   ptr_entry[0] = LSB2(fs_g_nav_entry.u32_cluster);
8000c120:	15 9c       	ld.ub	r12,r10[0x1]
   ptr_entry[1] = LSB3(fs_g_nav_entry.u32_cluster);
8000c122:	f0 cb ff ec 	sub	r11,r8,-20
   ptr_entry += (26-20);
8000c126:	b6 8c       	st.b	r11[0x0],r12
8000c128:	15 8c       	ld.ub	r12,r10[0x0]
   ptr_entry[0] = LSB0(fs_g_nav_entry.u32_cluster);
   ptr_entry[1] = LSB1(fs_g_nav_entry.u32_cluster);
8000c12a:	b6 9c       	st.b	r11[0x1],r12
8000c12c:	f0 cb ff e6 	sub	r11,r8,-26

   //! Write the size of file
   ptr_entry += (28-26);
   ptr_entry[0] = LSB0(fs_g_nav_entry.u32_size);
8000c130:	15 ac       	ld.ub	r12,r10[0x2]
   // Write the first cluster of file cluster list
   ptr_entry += (20-11);
   ptr_entry[0] = LSB2(fs_g_nav_entry.u32_cluster);
   ptr_entry[1] = LSB3(fs_g_nav_entry.u32_cluster);
   ptr_entry += (26-20);
   ptr_entry[0] = LSB0(fs_g_nav_entry.u32_cluster);
8000c132:	b6 9c       	st.b	r11[0x1],r12
   //! Write the size of file
   ptr_entry += (28-26);
   ptr_entry[0] = LSB0(fs_g_nav_entry.u32_size);
   ptr_entry[1] = LSB1(fs_g_nav_entry.u32_size);
   ptr_entry[2] = LSB2(fs_g_nav_entry.u32_size);
   ptr_entry[3] = LSB3(fs_g_nav_entry.u32_size);
8000c134:	15 ba       	ld.ub	r10,r10[0x3]
   ptr_entry += (26-20);
   ptr_entry[0] = LSB0(fs_g_nav_entry.u32_cluster);
   ptr_entry[1] = LSB1(fs_g_nav_entry.u32_cluster);

   //! Write the size of file
   ptr_entry += (28-26);
8000c136:	2f 89       	sub	r9,-8
   ptr_entry[0] = LSB0(fs_g_nav_entry.u32_size);
   ptr_entry[1] = LSB1(fs_g_nav_entry.u32_size);
   ptr_entry[2] = LSB2(fs_g_nav_entry.u32_size);
   ptr_entry[3] = LSB3(fs_g_nav_entry.u32_size);
8000c138:	b6 8a       	st.b	r11[0x0],r10

//! This function sets a flag to signal that sector cache is modified
//!
void  fat_cache_mark_sector_as_dirty( void )
{
   fs_g_sectorcache.u8_dirty = true;
8000c13a:	13 8a       	ld.ub	r10,r9[0x0]
8000c13c:	2e 48       	sub	r8,-28
8000c13e:	b0 ba       	st.b	r8[0x3],r10
8000c140:	e0 6a 0f b4 	mov	r10,4020
   ptr_entry[0] = LSB0(fs_g_nav_entry.u32_cluster);
   ptr_entry[1] = LSB1(fs_g_nav_entry.u32_cluster);

   //! Write the size of file
   ptr_entry += (28-26);
   ptr_entry[0] = LSB0(fs_g_nav_entry.u32_size);
8000c144:	30 1b       	mov	r11,1
   ptr_entry[1] = LSB1(fs_g_nav_entry.u32_size);
8000c146:	f5 6b 00 08 	st.b	r10[8],r11
   ptr_entry[2] = LSB2(fs_g_nav_entry.u32_size);
8000c14a:	13 ba       	ld.ub	r10,r9[0x3]
8000c14c:	b0 8a       	st.b	r8[0x0],r10
   ptr_entry[3] = LSB3(fs_g_nav_entry.u32_size);
}
8000c14e:	13 aa       	ld.ub	r10,r9[0x2]
8000c150:	b0 9a       	st.b	r8[0x1],r10
8000c152:	13 99       	ld.ub	r9,r9[0x1]
8000c154:	b0 a9       	st.b	r8[0x2],r9
8000c156:	5e fc       	retal	r12

8000c158 <fat_entry_shortname>:
8000c158:	d4 31       	pushm	r0-r7,lr
8000c15a:	20 1d       	sub	sp,4
8000c15c:	e0 68 0f 7c 	mov	r8,3964
   uint8_t u8_pos_name;
   uint8_t u8_entry_char, u8_szname_char;
   PTR_CACHE ptr_entry;
   uint8_t u8_pos_entry;

   fs_g_status = FS_ERR_NAME_INCORRECT;  // by default the name don't corresponding at filter name
8000c160:	31 69       	mov	r9,22
//!
//! @return a pointer on the internal cache
//!
PTR_CACHE fat_get_ptr_entry( void )
{
   return &fs_g_sector[(fs_g_nav_fast.u16_entry_pos_sel_file * FS_SIZE_FILE_ENTRY) & FS_512B_MASK];
8000c162:	b0 89       	st.b	r8[0x0],r9
8000c164:	e0 68 0f 78 	mov	r8,3960
8000c168:	90 9e       	ld.uh	lr,r8[0x2]
8000c16a:	e0 68 0d 2c 	mov	r8,3372
8000c16e:	a5 7e       	lsl	lr,0x5
8000c170:	fd de c0 09 	bfextu	lr,lr,0x0,0x9
8000c174:	10 0e       	add	lr,r8
8000c176:	58 0a       	cp.w	r10,0
8000c178:	c5 b1       	brne	8000c22e <fat_entry_shortname+0xd6>
   ptr_entry = fat_get_ptr_entry();

   // for each characters of short name
   while( 1 )
   {
      if( FS_SIZE_SFNAME == u8_pos_entry )
8000c17a:	30 18       	mov	r8,1
8000c17c:	14 99       	mov	r9,r10
         u8_entry_char = 0;   // end of name
      }
      else
      {
         u8_entry_char = ptr_entry[ u8_pos_entry ];
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT == u8_pos_entry) && b_extension_nostart)  // end of name and '.' character not written
8000c17e:	50 08       	stdsp	sp[0x0],r8
8000c180:	30 b6       	mov	r6,11
         {
            u8_szname_char = ((FS_STR_UNICODE)sz_name)[0];
         }else{
            u8_szname_char = sz_name[0];
         }
         if ('*' == u8_szname_char)
8000c182:	19 8b       	ld.ub	r11,r12[0x0]
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( (0 != u8_entry_char) || (('\\' != u8_szname_char) && ('/' != u8_szname_char)) )
8000c184:	30 85       	mov	r5,8
8000c186:	32 04       	mov	r4,32
   ptr_entry = fat_get_ptr_entry();

   // for each characters of short name
   while( 1 )
   {
      if( FS_SIZE_SFNAME == u8_pos_entry )
8000c188:	32 a7       	mov	r7,42
8000c18a:	32 f0       	mov	r0,47
8000c18c:	35 c1       	mov	r1,92
      {
         u8_entry_char = 0;   // end of name
      }
      else
      {
         u8_entry_char = ptr_entry[ u8_pos_entry ];
8000c18e:	ec 0a 18 00 	cp.b	r10,r6
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT == u8_pos_entry) && b_extension_nostart)  // end of name and '.' character not written
8000c192:	c2 40       	breq	8000c1da <fat_entry_shortname+0x82>
8000c194:	fc 0a 07 08 	ld.ub	r8,lr[r10]
8000c198:	ea 0a 18 00 	cp.b	r10,r5
8000c19c:	c3 70       	breq	8000c20a <fat_entry_shortname+0xb2>
         {
            u8_szname_char = ((FS_STR_UNICODE)sz_name)[0];
         }else{
            u8_szname_char = sz_name[0];
         }
         if ('*' == u8_szname_char)
8000c19e:	e8 08 18 00 	cp.b	r8,r4
8000c1a2:	c1 80       	breq	8000c1d2 <fat_entry_shortname+0x7a>
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( (0 != u8_entry_char) || (('\\' != u8_szname_char) && ('/' != u8_szname_char)) )
8000c1a4:	ee 0b 18 00 	cp.b	r11,r7
8000c1a8:	c1 20       	breq	8000c1cc <fat_entry_shortname+0x74>
8000c1aa:	58 08       	cp.w	r8,0
8000c1ac:	c1 91       	brne	8000c1de <fat_entry_shortname+0x86>
8000c1ae:	e0 0b 18 00 	cp.b	r11,r0
8000c1b2:	5f 12       	srne	r2
8000c1b4:	e2 0b 18 00 	cp.b	r11,r1
8000c1b8:	5f 13       	srne	r3
8000c1ba:	06 62       	and	r2,r3

            if( Is_unicode )
            {
               ((FS_STR_UNICODE)sz_name)[0] = u8_entry_char;
            }else{
               sz_name[0] = u8_entry_char;
8000c1bc:	f0 02 18 00 	cp.b	r2,r8
      }

      // For each characters
      if (0 == u8_entry_char)
      {
         if( g_b_string_length )
8000c1c0:	c0 f1       	brne	8000c1de <fat_entry_shortname+0x86>
8000c1c2:	e0 68 0f 7d 	mov	r8,3965
         sz_name += (Is_unicode? 2 : 1 );
      }
      u8_pos_name++;
      u8_pos_entry++;
   }
}
8000c1c6:	11 83       	ld.ub	r3,r8[0x0]
8000c1c8:	58 03       	cp.w	r3,0
         u8_entry_char = ptr_entry[ u8_pos_entry ];
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT == u8_pos_entry) && b_extension_nostart)  // end of name and '.' character not written
         ||  ( ' ' == u8_entry_char) )
         {
            // end of name or extension
            if( (FS_SIZE_SFNAME_WITHOUT_EXT >= u8_pos_entry)         // End of name without extension
8000c1ca:	c7 51       	brne	8000c2b4 <fat_entry_shortname+0x15c>
8000c1cc:	30 1c       	mov	r12,1
8000c1ce:	2f fd       	sub	sp,-4
8000c1d0:	d8 32       	popm	r0-r7,pc
         u8_entry_char = 0;   // end of name
      }
      else
      {
         u8_entry_char = ptr_entry[ u8_pos_entry ];
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT == u8_pos_entry) && b_extension_nostart)  // end of name and '.' character not written
8000c1d2:	ea 0a 18 00 	cp.b	r10,r5
            return true;   //*** The name is correct ***
         }

         if( (0 != u8_entry_char) || (('\\' != u8_szname_char) && ('/' != u8_szname_char)) )
         {
            if((u8_szname_char != u8_entry_char)
8000c1d6:	e0 88 00 1d 	brls	8000c210 <fat_entry_shortname+0xb8>
8000c1da:	30 08       	mov	r8,0
8000c1dc:	ce 4b       	rjmp	8000c1a4 <fat_entry_shortname+0x4c>
8000c1de:	f0 0b 18 00 	cp.b	r11,r8
8000c1e2:	c2 10       	breq	8000c224 <fat_entry_shortname+0xcc>
8000c1e4:	f0 c3 ff e0 	sub	r3,r8,-32
               return false;  // short name not equal
         }
      }

      // For each characters
      if (0 == u8_entry_char)
8000c1e8:	06 3b       	cp.w	r11,r3
8000c1ea:	c6 91       	brne	8000c2bc <fat_entry_shortname+0x164>
         }
         return true;   // End of test correct or end of get name
      }
      if( !g_b_string_length )
      {
         sz_name += (Is_unicode? 2 : 1 );
8000c1ec:	e0 63 0f 7d 	mov	r3,3965
8000c1f0:	07 83       	ld.ub	r3,r3[0x0]
8000c1f2:	58 08       	cp.w	r8,0
8000c1f4:	ce a0       	breq	8000c1c8 <fat_entry_shortname+0x70>
      }
      u8_pos_name++;
8000c1f6:	58 03       	cp.w	r3,0
      u8_pos_entry++;
8000c1f8:	f7 bc 00 ff 	subeq	r12,-1
8000c1fc:	f9 fb 08 00 	ld.ubeq	r11,r12[0x0]
         u8_entry_char = 0;   // end of name
      }
      else
      {
         u8_entry_char = ptr_entry[ u8_pos_entry ];
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT == u8_pos_entry) && b_extension_nostart)  // end of name and '.' character not written
8000c200:	2f f9       	sub	r9,-1
8000c202:	2f fa       	sub	r10,-1
8000c204:	5c 59       	castu.b	r9
         ||  ( ' ' == u8_entry_char) )
         {
            // end of name or extension
            if( (FS_SIZE_SFNAME_WITHOUT_EXT >= u8_pos_entry)         // End of name without extension
            &&  (' ' != ptr_entry[ FS_SIZE_SFNAME_WITHOUT_EXT ]) )   // extension exists
8000c206:	5c 5a       	castu.b	r10
8000c208:	cc 3b       	rjmp	8000c18e <fat_entry_shortname+0x36>
8000c20a:	40 03       	lddsp	r3,sp[0x0]
8000c20c:	58 03       	cp.w	r3,0
8000c20e:	cc 80       	breq	8000c19e <fat_entry_shortname+0x46>
8000c210:	fd 38 00 08 	ld.ub	r8,lr[8]
8000c214:	e8 08 18 00 	cp.b	r8,r4
8000c218:	ce 10       	breq	8000c1da <fat_entry_shortname+0x82>
            return true;   //*** The name is correct ***
         }

         if( (0 != u8_entry_char) || (('\\' != u8_szname_char) && ('/' != u8_szname_char)) )
         {
            if((u8_szname_char != u8_entry_char)
8000c21a:	30 03       	mov	r3,0
8000c21c:	30 7a       	mov	r10,7
8000c21e:	32 e8       	mov	r8,46
8000c220:	50 03       	stdsp	sp[0x0],r3
      if( !g_b_string_length )
      {
         sz_name += (Is_unicode? 2 : 1 );
      }
      u8_pos_name++;
      u8_pos_entry++;
8000c222:	cc 1b       	rjmp	8000c1a4 <fat_entry_shortname+0x4c>

      if( FS_NAME_GET == b_mode )
      {
         if( !g_b_string_length )
         {
            if(u8_pos_name >= (u8_size_max-1))
8000c224:	e0 68 0f 7d 	mov	r8,3965
      if( !g_b_string_length )
      {
         sz_name += (Is_unicode? 2 : 1 );
      }
      u8_pos_name++;
      u8_pos_entry++;
8000c228:	11 83       	ld.ub	r3,r8[0x0]
8000c22a:	16 98       	mov	r8,r11
   ptr_entry = fat_get_ptr_entry();

   // for each characters of short name
   while( 1 )
   {
      if( FS_SIZE_SFNAME == u8_pos_entry )
8000c22c:	ce 3b       	rjmp	8000c1f2 <fat_entry_shortname+0x9a>
         u8_entry_char = 0;   // end of name
      }
      else
      {
         u8_entry_char = ptr_entry[ u8_pos_entry ];
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT == u8_pos_entry) && b_extension_nostart)  // end of name and '.' character not written
8000c22e:	30 08       	mov	r8,0
         ||  ( ' ' == u8_entry_char) )
         {
            // end of name or extension
            if( (FS_SIZE_SFNAME_WITHOUT_EXT >= u8_pos_entry)         // End of name without extension
            &&  (' ' != ptr_entry[ FS_SIZE_SFNAME_WITHOUT_EXT ]) )   // extension exists
8000c230:	20 1b       	sub	r11,1
         if( !g_b_string_length )
         {
            if(u8_pos_name >= (u8_size_max-1))
               u8_entry_char = 0;                                    // buffer full then force end of string

            if( ('A'<=u8_entry_char) && (u8_entry_char<='Z'))
8000c232:	30 12       	mov	r2,1
8000c234:	10 99       	mov	r9,r8
      {
         u8_entry_char = 0;   // end of name
      }
      else
      {
         u8_entry_char = ptr_entry[ u8_pos_entry ];
8000c236:	e0 67 0f 7d 	mov	r7,3965
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT == u8_pos_entry) && b_extension_nostart)  // end of name and '.' character not written
8000c23a:	30 b6       	mov	r6,11
8000c23c:	30 85       	mov	r5,8
8000c23e:	32 04       	mov	r4,32
8000c240:	31 91       	mov	r1,25
8000c242:	c1 a8       	rjmp	8000c276 <fat_entry_shortname+0x11e>
8000c244:	fc 08 07 0a 	ld.ub	r10,lr[r8]
         }
      }

      if( FS_NAME_GET == b_mode )
      {
         if( !g_b_string_length )
8000c248:	ea 08 18 00 	cp.b	r8,r5
         {
            if(u8_pos_name >= (u8_size_max-1))
8000c24c:	c1 a0       	breq	8000c280 <fat_entry_shortname+0x128>
8000c24e:	e8 0a 18 00 	cp.b	r10,r4

            if( Is_unicode )
            {
               ((FS_STR_UNICODE)sz_name)[0] = u8_entry_char;
            }else{
               sz_name[0] = u8_entry_char;
8000c252:	c2 20       	breq	8000c296 <fat_entry_shortname+0x13e>
8000c254:	0f 83       	ld.ub	r3,r7[0x0]
               return false;  // short name not equal
         }
      }

      // For each characters
      if (0 == u8_entry_char)
8000c256:	58 03       	cp.w	r3,0
8000c258:	c0 61       	brne	8000c264 <fat_entry_shortname+0x10c>
      }
      if( !g_b_string_length )
      {
         sz_name += (Is_unicode? 2 : 1 );
      }
      u8_pos_name++;
8000c25a:	16 39       	cp.w	r9,r11
      u8_pos_entry++;
8000c25c:	c2 35       	brlt	8000c2a2 <fat_entry_shortname+0x14a>
         }
         return true;   // End of test correct or end of get name
      }
      if( !g_b_string_length )
      {
         sz_name += (Is_unicode? 2 : 1 );
8000c25e:	06 9a       	mov	r10,r3
8000c260:	b8 8a       	st.b	r12[0x0],r10
8000c262:	0f 83       	ld.ub	r3,r7[0x0]
      }
      u8_pos_name++;
8000c264:	58 0a       	cp.w	r10,0
      u8_pos_entry++;
8000c266:	cb 10       	breq	8000c1c8 <fat_entry_shortname+0x70>
   ptr_entry = fat_get_ptr_entry();

   // for each characters of short name
   while( 1 )
   {
      if( FS_SIZE_SFNAME == u8_pos_entry )
8000c268:	2f f9       	sub	r9,-1
8000c26a:	2f f8       	sub	r8,-1
8000c26c:	58 03       	cp.w	r3,0
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT == u8_pos_entry) && b_extension_nostart)  // end of name and '.' character not written
         ||  ( ' ' == u8_entry_char) )
         {
            // end of name or extension
            if( (FS_SIZE_SFNAME_WITHOUT_EXT >= u8_pos_entry)         // End of name without extension
            &&  (' ' != ptr_entry[ FS_SIZE_SFNAME_WITHOUT_EXT ]) )   // extension exists
8000c26e:	f7 bc 00 ff 	subeq	r12,-1
         u8_entry_char = 0;   // end of name
      }
      else
      {
         u8_entry_char = ptr_entry[ u8_pos_entry ];
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT == u8_pos_entry) && b_extension_nostart)  // end of name and '.' character not written
8000c272:	5c 59       	castu.b	r9
8000c274:	5c 58       	castu.b	r8
         ||  ( ' ' == u8_entry_char) )
         {
            // end of name or extension
            if( (FS_SIZE_SFNAME_WITHOUT_EXT >= u8_pos_entry)         // End of name without extension
            &&  (' ' != ptr_entry[ FS_SIZE_SFNAME_WITHOUT_EXT ]) )   // extension exists
8000c276:	ec 08 18 00 	cp.b	r8,r6
8000c27a:	ce 51       	brne	8000c244 <fat_entry_shortname+0xec>
8000c27c:	30 0a       	mov	r10,0
8000c27e:	ce bb       	rjmp	8000c254 <fat_entry_shortname+0xfc>
8000c280:	58 02       	cp.w	r2,0
8000c282:	ce 60       	breq	8000c24e <fat_entry_shortname+0xf6>
8000c284:	fd 3a 00 08 	ld.ub	r10,lr[8]
         u8_entry_char = ptr_entry[ u8_pos_entry ];
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT == u8_pos_entry) && b_extension_nostart)  // end of name and '.' character not written
         ||  ( ' ' == u8_entry_char) )
         {
            // end of name or extension
            if( (FS_SIZE_SFNAME_WITHOUT_EXT >= u8_pos_entry)         // End of name without extension
8000c288:	e8 0a 18 00 	cp.b	r10,r4
8000c28c:	cf 80       	breq	8000c27c <fat_entry_shortname+0x124>
8000c28e:	30 78       	mov	r8,7
            &&  (' ' != ptr_entry[ FS_SIZE_SFNAME_WITHOUT_EXT ]) )   // extension exists
8000c290:	32 ea       	mov	r10,46
8000c292:	30 02       	mov	r2,0
         if( !g_b_string_length )
         {
            if(u8_pos_name >= (u8_size_max-1))
               u8_entry_char = 0;                                    // buffer full then force end of string

            if( ('A'<=u8_entry_char) && (u8_entry_char<='Z'))
8000c294:	ce 0b       	rjmp	8000c254 <fat_entry_shortname+0xfc>
8000c296:	ea 08 18 00 	cp.b	r8,r5
8000c29a:	fe 98 ff f5 	brls	8000c284 <fat_entry_shortname+0x12c>
8000c29e:	30 0a       	mov	r10,0
               u8_entry_char += ('a'-'A');                           // display short name in down case
8000c2a0:	cd ab       	rjmp	8000c254 <fat_entry_shortname+0xfc>
8000c2a2:	f4 c3 00 41 	sub	r3,r10,65
      // For each characters
      if (0 == u8_entry_char)
      {
         if( g_b_string_length )
         {
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;      // Get length name
8000c2a6:	e2 03 18 00 	cp.b	r3,r1
8000c2aa:	fe 9b ff db 	brhi	8000c260 <fat_entry_shortname+0x108>
      {
         sz_name += (Is_unicode? 2 : 1 );
      }
      u8_pos_name++;
      u8_pos_entry++;
   }
8000c2ae:	2e 0a       	sub	r10,-32
8000c2b0:	5c 5a       	castu.b	r10
8000c2b2:	cd 7b       	rjmp	8000c260 <fat_entry_shortname+0x108>
8000c2b4:	2f f9       	sub	r9,-1
8000c2b6:	b8 09       	st.h	r12[0x0],r9
8000c2b8:	2f fd       	sub	sp,-4
8000c2ba:	da 3a       	popm	r0-r7,pc,r12=1
8000c2bc:	30 0c       	mov	r12,0
8000c2be:	c8 8b       	rjmp	8000c1ce <fat_entry_shortname+0x76>

8000c2c0 <fat_entry_longname>:
8000c2c0:	d4 31       	pushm	r0-r7,lr
8000c2c2:	20 3d       	sub	sp,12
//!
//! @return a pointer on the internal cache
//!
PTR_CACHE fat_get_ptr_entry( void )
{
   return &fs_g_sector[(fs_g_nav_fast.u16_entry_pos_sel_file * FS_SIZE_FILE_ENTRY) & FS_512B_MASK];
8000c2c4:	e0 6e 0d 2c 	mov	lr,3372
8000c2c8:	e0 68 0f 78 	mov	r8,3960
8000c2cc:	90 98       	ld.uh	r8,r8[0x2]
8000c2ce:	a5 78       	lsl	r8,0x5
8000c2d0:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
8000c2d4:	1c 08       	add	r8,lr
   uint16_t u16_unicode_entry;
   uint16_t u16_unicode_szname;

   ptr_entry = fat_get_ptr_entry();

   if( (FS_ENTRY_END == *ptr_entry )            // end of directory
8000c2d6:	3e 5e       	mov	lr,-27
8000c2d8:	11 87       	ld.ub	r7,r8[0x0]
8000c2da:	fc 07 18 00 	cp.b	r7,lr
8000c2de:	5f 05       	sreq	r5
8000c2e0:	30 0e       	mov	lr,0
8000c2e2:	fc 07 18 00 	cp.b	r7,lr
8000c2e6:	5f 06       	sreq	r6
8000c2e8:	eb e6 10 06 	or	r6,r5,r6
8000c2ec:	fc 06 18 00 	cp.b	r6,lr
8000c2f0:	c0 71       	brne	8000c2fe <fat_entry_longname+0x3e>
   ||  (FS_ENTRY_DEL == *ptr_entry )            // entry deleted
   ||  (FS_ATTR_LFN_ENTRY != ptr_entry[11]) )   // no long name
8000c2f2:	f1 36 00 0b 	ld.ub	r6,r8[11]
8000c2f6:	30 fe       	mov	lr,15
8000c2f8:	fc 06 18 00 	cp.b	r6,lr
8000c2fc:	c0 80       	breq	8000c30c <fat_entry_longname+0x4c>
   {
      fs_g_status = FS_ERR_ENTRY_BAD;
8000c2fe:	30 b9       	mov	r9,11
8000c300:	e0 68 0f 7c 	mov	r8,3964
8000c304:	30 0c       	mov	r12,0
8000c306:	b0 89       	st.b	r8[0x0],r9
         sz_name += (Is_unicode? 2 : 1 );
      }
      u8_pos_name++;
      ptr_entry+=2;
   }
}
8000c308:	2f dd       	sub	sp,-12
8000c30a:	d8 32       	popm	r0-r7,pc
   {
      fs_g_status = FS_ERR_ENTRY_BAD;
      return false;
   }

   if( g_b_string_length )
8000c30c:	e0 6e 0f 7d 	mov	lr,3965
8000c310:	1d 82       	ld.ub	r2,lr[0x0]
8000c312:	58 02       	cp.w	r2,0
8000c314:	c5 21       	brne	8000c3b8 <fat_entry_longname+0xf8>
         fs_g_status = FS_NO_LAST_LFN_ENTRY;
         return false;                          // Other entry long name
      }
   }

   ptr_entry++;                                 // The long name start at offset 1 of the entry file
8000c316:	2f f8       	sub	r8,-1
8000c318:	fa c6 ff f6 	sub	r6,sp,-10
8000c31c:	fa c7 ff f5 	sub	r7,sp,-11
8000c320:	58 0a       	cp.w	r10,0
8000c322:	c5 41       	brne	8000c3ca <fat_entry_longname+0x10a>
8000c324:	58 09       	cp.w	r9,0
8000c326:	c7 c1       	brne	8000c41e <fat_entry_longname+0x15e>
8000c328:	19 8b       	ld.ub	r11,r12[0x0]
8000c32a:	14 99       	mov	r9,r10
            u16_unicode_szname = ((FS_STR_UNICODE)sz_name)[0];
         }else{
            u16_unicode_szname = sz_name[0];
         }
         // Check the name
         if( '*' == u16_unicode_szname )
8000c32c:	32 a4       	mov	r4,42
         {
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;
         }
         return true;                           // Last long name entry
      }
      if( 4 == u8_pos_name )
8000c32e:	30 43       	mov	r3,4
         ptr_entry += 3;                        // Go to second character

      if( 10 == u8_pos_name )
8000c330:	30 a1       	mov	r1,10
         ptr_entry += 2;                        // Go to third character

      if( 12 == u8_pos_name )
8000c332:	50 1a       	stdsp	sp[0x4],r10
8000c334:	c1 38       	rjmp	8000c35a <fat_entry_longname+0x9a>
         return true;                           // Last long name entry
      }
      if( 4 == u8_pos_name )
         ptr_entry += 3;                        // Go to second character

      if( 10 == u8_pos_name )
8000c336:	e2 09 18 00 	cp.b	r9,r1
8000c33a:	e0 80 00 e1 	breq	8000c4fc <fat_entry_longname+0x23c>
         ptr_entry += 2;                        // Go to third character

      if( 12 == u8_pos_name )
8000c33e:	30 c0       	mov	r0,12
8000c340:	e0 09 18 00 	cp.b	r9,r0
8000c344:	e0 80 00 b5 	breq	8000c4ae <fat_entry_longname+0x1ee>
               return fat_check_eof_name(u16_unicode_szname);
            }
         }
      }

      if( !g_b_string_length )
8000c348:	1d 82       	ld.ub	r2,lr[0x0]
      {
         sz_name += (Is_unicode? 2 : 1 );
      }
      u8_pos_name++;
8000c34a:	2f f9       	sub	r9,-1
         }
      }

      if( !g_b_string_length )
      {
         sz_name += (Is_unicode? 2 : 1 );
8000c34c:	58 02       	cp.w	r2,0
8000c34e:	f7 bc 00 ff 	subeq	r12,-1
8000c352:	f9 fb 08 00 	ld.ubeq	r11,r12[0x0]
      }
      u8_pos_name++;
      ptr_entry+=2;
8000c356:	2f e8       	sub	r8,-2

      if( !g_b_string_length )
      {
         sz_name += (Is_unicode? 2 : 1 );
      }
      u8_pos_name++;
8000c358:	5c 59       	castu.b	r9
   ptr_entry++;                                 // The long name start at offset 1 of the entry file

   u8_pos_name=0;
   while( 1 )
   {
      LSB(u16_unicode_entry) = ptr_entry[0];
8000c35a:	11 8a       	ld.ub	r10,r8[0x0]
8000c35c:	ae 8a       	st.b	r7[0x0],r10
      MSB(u16_unicode_entry) = ptr_entry[1];
8000c35e:	11 9a       	ld.ub	r10,r8[0x1]
8000c360:	ac 8a       	st.b	r6[0x0],r10
            u16_unicode_szname = ((FS_STR_UNICODE)sz_name)[0];
         }else{
            u16_unicode_szname = sz_name[0];
         }
         // Check the name
         if( '*' == u16_unicode_szname )
8000c362:	e8 0b 19 00 	cp.h	r11,r4
8000c366:	e0 80 00 d9 	breq	8000c518 <fat_entry_longname+0x258>
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( ((0 != u16_unicode_entry ) || (( '\\' != u16_unicode_szname) && ( '/' != u16_unicode_szname)) )
8000c36a:	9a 5a       	ld.sh	r10,sp[0xa]
8000c36c:	58 0a       	cp.w	r10,0
8000c36e:	c0 e1       	brne	8000c38a <fat_entry_longname+0xca>
8000c370:	32 f5       	mov	r5,47
8000c372:	ea 0b 19 00 	cp.h	r11,r5
8000c376:	5f 10       	srne	r0
8000c378:	35 c5       	mov	r5,92
8000c37a:	ea 0b 19 00 	cp.h	r11,r5
8000c37e:	5f 15       	srne	r5
8000c380:	0a 60       	and	r0,r5
8000c382:	14 95       	mov	r5,r10
8000c384:	f4 00 18 00 	cp.b	r0,r10
8000c388:	c6 a0       	breq	8000c45c <fat_entry_longname+0x19c>
         &&  ((u16_unicode_szname != (u16_unicode_entry+('a'-'A'))) || b_match_case)
8000c38a:	e5 da c0 10 	bfextu	r2,r10,0x0,0x10
8000c38e:	eb db c0 10 	bfextu	r5,r11,0x0,0x10
         if( '*' == u16_unicode_szname )
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( ((0 != u16_unicode_entry ) || (( '\\' != u16_unicode_szname) && ( '/' != u16_unicode_szname)) )
8000c392:	e4 c0 ff e0 	sub	r0,r2,-32
8000c396:	00 35       	cp.w	r5,r0
8000c398:	c0 80       	breq	8000c3a8 <fat_entry_longname+0xe8>
8000c39a:	22 02       	sub	r2,32
8000c39c:	04 35       	cp.w	r5,r2
8000c39e:	c0 50       	breq	8000c3a8 <fat_entry_longname+0xe8>
8000c3a0:	f4 0b 19 00 	cp.h	r11,r10
8000c3a4:	e0 81 00 d4 	brne	8000c54c <fat_entry_longname+0x28c>
           fs_g_status = FS_ERR_NAME_INCORRECT; //  The name don't corresponding at filter name
           return false;
         }
      }

      if( 0 == u16_unicode_entry)
8000c3a8:	58 0a       	cp.w	r10,0
8000c3aa:	e0 80 00 db 	breq	8000c560 <fat_entry_longname+0x2a0>
         {
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;
         }
         return true;                           // Last long name entry
      }
      if( 4 == u8_pos_name )
8000c3ae:	e6 09 18 00 	cp.b	r9,r3
8000c3b2:	cc 21       	brne	8000c336 <fat_entry_longname+0x76>
         ptr_entry += 3;                        // Go to second character
8000c3b4:	2f d8       	sub	r8,-3
8000c3b6:	cc 9b       	rjmp	8000c348 <fat_entry_longname+0x88>
      return false;
   }

   if( g_b_string_length )
   {
      if ( 0 == (FS_ENTRY_LFN_LAST & *ptr_entry))
8000c3b8:	e2 17 00 40 	andl	r7,0x40,COH
8000c3bc:	ca d1       	brne	8000c316 <fat_entry_longname+0x56>
      if( 12 == u8_pos_name )
      {  // End of entry long name
         ptr_entry -= (FS_SIZE_FILE_ENTRY-2);   // Go to the first byte of the file entry
         if ( 0 == (FS_ENTRY_LFN_LAST & ptr_entry[0]))
         {
            fs_g_status = FS_NO_LAST_LFN_ENTRY;
8000c3be:	31 09       	mov	r9,16
8000c3c0:	e0 68 0f 7c 	mov	r8,3964
8000c3c4:	0e 9c       	mov	r12,r7
            return false;                       // Other long name entry is present
8000c3c6:	b0 89       	st.b	r8[0x0],r9
      if( !g_b_string_length )
      {
         sz_name += (Is_unicode? 2 : 1 );
      }
      u8_pos_name++;
      ptr_entry+=2;
8000c3c8:	ca 0b       	rjmp	8000c308 <fat_entry_longname+0x48>
8000c3ca:	58 09       	cp.w	r9,0
      if( FS_NAME_GET == b_mode )
      {
         if( !g_b_string_length )
         {
            // Check the end of buffer
            if( u8_pos_name>=(u8_size_max-1) )
8000c3cc:	c4 e0       	breq	8000c468 <fat_entry_longname+0x1a8>
      if( !g_b_string_length )
      {
         sz_name += (Is_unicode? 2 : 1 );
      }
      u8_pos_name++;
      ptr_entry+=2;
8000c3ce:	20 1b       	sub	r11,1
         {
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;
         }
         return true;                           // Last long name entry
      }
      if( 4 == u8_pos_name )
8000c3d0:	30 09       	mov	r9,0
         ptr_entry += 3;                        // Go to second character

      if( 10 == u8_pos_name )
8000c3d2:	30 44       	mov	r4,4
         ptr_entry += 2;                        // Go to third character

      if( 12 == u8_pos_name )
8000c3d4:	30 a3       	mov	r3,10
8000c3d6:	30 c1       	mov	r1,12
      if( FS_NAME_GET == b_mode )
      {
         if( !g_b_string_length )
         {
            // Check the end of buffer
            if( u8_pos_name>=(u8_size_max-1) )
8000c3d8:	c1 b8       	rjmp	8000c40e <fat_entry_longname+0x14e>
8000c3da:	16 39       	cp.w	r9,r11
8000c3dc:	e0 84 00 be 	brge	8000c558 <fat_entry_longname+0x298>
            // Read and store the long name
            if( Is_unicode )
            {
               ((FS_STR_UNICODE)sz_name)[0] = u16_unicode_entry;
            }else{
               sz_name[0] = (uint8_t)u16_unicode_entry;
8000c3e0:	9a 55       	ld.sh	r5,sp[0xa]
           fs_g_status = FS_ERR_NAME_INCORRECT; //  The name don't corresponding at filter name
           return false;
         }
      }

      if( 0 == u16_unicode_entry)
8000c3e2:	b8 85       	st.b	r12[0x0],r5
8000c3e4:	58 05       	cp.w	r5,0
8000c3e6:	e0 80 00 bd 	breq	8000c560 <fat_entry_longname+0x2a0>
         {
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;
         }
         return true;                           // Last long name entry
      }
      if( 4 == u8_pos_name )
8000c3ea:	e8 09 18 00 	cp.b	r9,r4
8000c3ee:	e0 80 00 8f 	breq	8000c50c <fat_entry_longname+0x24c>
         ptr_entry += 3;                        // Go to second character

      if( 10 == u8_pos_name )
8000c3f2:	e6 09 18 00 	cp.b	r9,r3
8000c3f6:	e0 80 00 89 	breq	8000c508 <fat_entry_longname+0x248>
         ptr_entry += 2;                        // Go to third character

      if( 12 == u8_pos_name )
8000c3fa:	e2 09 18 00 	cp.b	r9,r1
               return fat_check_eof_name(u16_unicode_szname);
            }
         }
      }

      if( !g_b_string_length )
8000c3fe:	c5 90       	breq	8000c4b0 <fat_entry_longname+0x1f0>
      {
         sz_name += (Is_unicode? 2 : 1 );
      }
      u8_pos_name++;
8000c400:	1d 82       	ld.ub	r2,lr[0x0]
         }
      }

      if( !g_b_string_length )
      {
         sz_name += (Is_unicode? 2 : 1 );
8000c402:	2f f9       	sub	r9,-1
8000c404:	58 02       	cp.w	r2,0
8000c406:	f7 bc 00 ff 	subeq	r12,-1
      }
      u8_pos_name++;
8000c40a:	2f e8       	sub	r8,-2
   ptr_entry++;                                 // The long name start at offset 1 of the entry file

   u8_pos_name=0;
   while( 1 )
   {
      LSB(u16_unicode_entry) = ptr_entry[0];
8000c40c:	5c 59       	castu.b	r9
8000c40e:	11 85       	ld.ub	r5,r8[0x0]
      MSB(u16_unicode_entry) = ptr_entry[1];
8000c410:	ae 85       	st.b	r7[0x0],r5
8000c412:	11 95       	ld.ub	r5,r8[0x1]
      if( FS_NAME_GET == b_mode )
      {
         if( !g_b_string_length )
8000c414:	ac 85       	st.b	r6[0x0],r5
8000c416:	58 02       	cp.w	r2,0
         &&  ((u16_unicode_szname != (u16_unicode_entry+('a'-'A'))) || b_match_case)
         &&  ((u16_unicode_szname != (u16_unicode_entry-('a'-'A'))) || b_match_case)
         &&  (u16_unicode_szname != u16_unicode_entry) )
         {
           fs_g_status = FS_ERR_NAME_INCORRECT; //  The name don't corresponding at filter name
           return false;
8000c418:	ce 10       	breq	8000c3da <fat_entry_longname+0x11a>
8000c41a:	9a 55       	ld.sh	r5,sp[0xa]
8000c41c:	ce 4b       	rjmp	8000c3e4 <fat_entry_longname+0x124>
      if( !g_b_string_length )
      {
         sz_name += (Is_unicode? 2 : 1 );
      }
      u8_pos_name++;
      ptr_entry+=2;
8000c41e:	19 8b       	ld.ub	r11,r12[0x0]
            u16_unicode_szname = ((FS_STR_UNICODE)sz_name)[0];
         }else{
            u16_unicode_szname = sz_name[0];
         }
         // Check the name
         if( '*' == u16_unicode_szname )
8000c420:	14 99       	mov	r9,r10
         {
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;
         }
         return true;                           // Last long name entry
      }
      if( 4 == u8_pos_name )
8000c422:	32 a4       	mov	r4,42
         ptr_entry += 3;                        // Go to second character

      if( 10 == u8_pos_name )
8000c424:	30 43       	mov	r3,4
         ptr_entry += 2;                        // Go to third character

      if( 12 == u8_pos_name )
8000c426:	30 a1       	mov	r1,10
   ptr_entry++;                                 // The long name start at offset 1 of the entry file

   u8_pos_name=0;
   while( 1 )
   {
      LSB(u16_unicode_entry) = ptr_entry[0];
8000c428:	50 0a       	stdsp	sp[0x0],r10
8000c42a:	11 85       	ld.ub	r5,r8[0x0]
      MSB(u16_unicode_entry) = ptr_entry[1];
8000c42c:	ae 85       	st.b	r7[0x0],r5
8000c42e:	11 95       	ld.ub	r5,r8[0x1]
            u16_unicode_szname = ((FS_STR_UNICODE)sz_name)[0];
         }else{
            u16_unicode_szname = sz_name[0];
         }
         // Check the name
         if( '*' == u16_unicode_szname )
8000c430:	ac 85       	st.b	r6[0x0],r5
8000c432:	e8 0b 19 00 	cp.h	r11,r4
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( ((0 != u16_unicode_entry ) || (( '\\' != u16_unicode_szname) && ( '/' != u16_unicode_szname)) )
8000c436:	c7 10       	breq	8000c518 <fat_entry_longname+0x258>
8000c438:	9a 55       	ld.sh	r5,sp[0xa]
8000c43a:	58 05       	cp.w	r5,0
8000c43c:	c4 71       	brne	8000c4ca <fat_entry_longname+0x20a>
8000c43e:	32 fa       	mov	r10,47
8000c440:	f4 0b 19 00 	cp.h	r11,r10
8000c444:	5f 10       	srne	r0
8000c446:	35 ca       	mov	r10,92
8000c448:	50 10       	stdsp	sp[0x4],r0
8000c44a:	f4 0b 19 00 	cp.h	r11,r10
8000c44e:	5f 10       	srne	r0
8000c450:	40 1a       	lddsp	r10,sp[0x4]
8000c452:	00 6a       	and	r10,r0
8000c454:	0a 90       	mov	r0,r5
8000c456:	ea 0a 18 00 	cp.b	r10,r5
         }
      }

      if( 0 == u16_unicode_entry)
      {
         if( g_b_string_length )
8000c45a:	c3 81       	brne	8000c4ca <fat_entry_longname+0x20a>
8000c45c:	58 02       	cp.w	r2,0
         {
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;
8000c45e:	c5 d0       	breq	8000c518 <fat_entry_longname+0x258>
8000c460:	2f f9       	sub	r9,-1
8000c462:	b8 09       	st.h	r12[0x0],r9
8000c464:	30 1c       	mov	r12,1
      if( FS_NAME_GET == b_mode )
      {
         if( !g_b_string_length )
         {
            // Check the end of buffer
            if( u8_pos_name>=(u8_size_max-1) )
8000c466:	c5 1b       	rjmp	8000c308 <fat_entry_longname+0x48>
         {
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;
         }
         return true;                           // Last long name entry
      }
      if( 4 == u8_pos_name )
8000c468:	20 1b       	sub	r11,1
         ptr_entry += 3;                        // Go to second character

      if( 10 == u8_pos_name )
8000c46a:	30 44       	mov	r4,4
         ptr_entry += 2;                        // Go to third character

      if( 12 == u8_pos_name )
8000c46c:	30 a3       	mov	r3,10
8000c46e:	30 c1       	mov	r1,12
   {
      LSB(u16_unicode_entry) = ptr_entry[0];
      MSB(u16_unicode_entry) = ptr_entry[1];
      if( FS_NAME_GET == b_mode )
      {
         if( !g_b_string_length )
8000c470:	c1 48       	rjmp	8000c498 <fat_entry_longname+0x1d8>
           fs_g_status = FS_ERR_NAME_INCORRECT; //  The name don't corresponding at filter name
           return false;
         }
      }

      if( 0 == u16_unicode_entry)
8000c472:	9a 55       	ld.sh	r5,sp[0xa]
8000c474:	58 05       	cp.w	r5,0
         {
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;
         }
         return true;                           // Last long name entry
      }
      if( 4 == u8_pos_name )
8000c476:	c7 50       	breq	8000c560 <fat_entry_longname+0x2a0>
8000c478:	e8 09 18 00 	cp.b	r9,r4
         ptr_entry += 3;                        // Go to second character

      if( 10 == u8_pos_name )
8000c47c:	c4 40       	breq	8000c504 <fat_entry_longname+0x244>
8000c47e:	e6 09 18 00 	cp.b	r9,r3
         ptr_entry += 2;                        // Go to third character

      if( 12 == u8_pos_name )
8000c482:	c3 f0       	breq	8000c500 <fat_entry_longname+0x240>
8000c484:	e2 09 18 00 	cp.b	r9,r1
               return fat_check_eof_name(u16_unicode_szname);
            }
         }
      }

      if( !g_b_string_length )
8000c488:	c1 40       	breq	8000c4b0 <fat_entry_longname+0x1f0>
      {
         sz_name += (Is_unicode? 2 : 1 );
      }
      u8_pos_name++;
8000c48a:	1d 82       	ld.ub	r2,lr[0x0]
         }
      }

      if( !g_b_string_length )
      {
         sz_name += (Is_unicode? 2 : 1 );
8000c48c:	2f f9       	sub	r9,-1
8000c48e:	58 02       	cp.w	r2,0
8000c490:	f7 bc 00 ff 	subeq	r12,-1
      }
      u8_pos_name++;
8000c494:	2f e8       	sub	r8,-2
   ptr_entry++;                                 // The long name start at offset 1 of the entry file

   u8_pos_name=0;
   while( 1 )
   {
      LSB(u16_unicode_entry) = ptr_entry[0];
8000c496:	5c 59       	castu.b	r9
8000c498:	11 85       	ld.ub	r5,r8[0x0]
      MSB(u16_unicode_entry) = ptr_entry[1];
8000c49a:	ae 85       	st.b	r7[0x0],r5
8000c49c:	11 95       	ld.ub	r5,r8[0x1]
      if( FS_NAME_GET == b_mode )
      {
         if( !g_b_string_length )
8000c49e:	ac 85       	st.b	r6[0x0],r5
8000c4a0:	58 02       	cp.w	r2,0
         {
            // Check the end of buffer
            if( u8_pos_name>=(u8_size_max-1) )
8000c4a2:	ce 81       	brne	8000c472 <fat_entry_longname+0x1b2>
8000c4a4:	16 39       	cp.w	r9,r11
            // Read and store the long name
            if( Is_unicode )
            {
               ((FS_STR_UNICODE)sz_name)[0] = u16_unicode_entry;
            }else{
               sz_name[0] = (uint8_t)u16_unicode_entry;
8000c4a6:	c5 94       	brge	8000c558 <fat_entry_longname+0x298>
8000c4a8:	9a 55       	ld.sh	r5,sp[0xa]
8000c4aa:	b8 85       	st.b	r12[0x0],r5
8000c4ac:	ce 4b       	rjmp	8000c474 <fat_entry_longname+0x1b4>
         ptr_entry += 2;                        // Go to third character

      if( 12 == u8_pos_name )
      {  // End of entry long name
         ptr_entry -= (FS_SIZE_FILE_ENTRY-2);   // Go to the first byte of the file entry
         if ( 0 == (FS_ENTRY_LFN_LAST & ptr_entry[0]))
8000c4ae:	40 1a       	lddsp	r10,sp[0x4]
8000c4b0:	f1 37 ff e2 	ld.ub	r7,r8[-30]
8000c4b4:	e2 17 00 40 	andl	r7,0x40,COH
            return false;                       // Other long name entry is present
         }
         else
         {  // It is the last long name entry
            // then it is the end of name
            if( (FS_NAME_GET == b_mode) && g_b_string_length )
8000c4b8:	c8 30       	breq	8000c3be <fat_entry_longname+0xfe>
8000c4ba:	58 0a       	cp.w	r10,0
8000c4bc:	c3 00       	breq	8000c51c <fat_entry_longname+0x25c>
8000c4be:	1d 88       	ld.ub	r8,lr[0x0]
8000c4c0:	58 08       	cp.w	r8,0
               // Write end of string UNICODE
               if( Is_unicode )
               {
                  ((FS_STR_UNICODE)sz_name)[0] = 0;
               }else{
                  sz_name[0] = 0;
8000c4c2:	c4 11       	brne	8000c544 <fat_entry_longname+0x284>
8000c4c4:	b8 98       	st.b	r12[0x1],r8
               }
               return true;
8000c4c6:	30 1c       	mov	r12,1
         if( '*' == u16_unicode_szname )
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( ((0 != u16_unicode_entry ) || (( '\\' != u16_unicode_szname) && ( '/' != u16_unicode_szname)) )
8000c4c8:	c2 0b       	rjmp	8000c308 <fat_entry_longname+0x48>
8000c4ca:	ea 0b 19 00 	cp.h	r11,r5
           fs_g_status = FS_ERR_NAME_INCORRECT; //  The name don't corresponding at filter name
           return false;
         }
      }

      if( 0 == u16_unicode_entry)
8000c4ce:	c3 f1       	brne	8000c54c <fat_entry_longname+0x28c>
8000c4d0:	58 05       	cp.w	r5,0
         {
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;
         }
         return true;                           // Last long name entry
      }
      if( 4 == u8_pos_name )
8000c4d2:	c4 70       	breq	8000c560 <fat_entry_longname+0x2a0>
8000c4d4:	e6 09 18 00 	cp.b	r9,r3
         ptr_entry += 3;                        // Go to second character

      if( 10 == u8_pos_name )
8000c4d8:	c1 e0       	breq	8000c514 <fat_entry_longname+0x254>
8000c4da:	e2 09 18 00 	cp.b	r9,r1
         ptr_entry += 2;                        // Go to third character

      if( 12 == u8_pos_name )
8000c4de:	c1 90       	breq	8000c510 <fat_entry_longname+0x250>
8000c4e0:	30 c5       	mov	r5,12
8000c4e2:	ea 09 18 00 	cp.b	r9,r5
               return fat_check_eof_name(u16_unicode_szname);
            }
         }
      }

      if( !g_b_string_length )
8000c4e6:	c2 d0       	breq	8000c540 <fat_entry_longname+0x280>
      {
         sz_name += (Is_unicode? 2 : 1 );
      }
      u8_pos_name++;
8000c4e8:	1d 82       	ld.ub	r2,lr[0x0]
         }
      }

      if( !g_b_string_length )
      {
         sz_name += (Is_unicode? 2 : 1 );
8000c4ea:	2f f9       	sub	r9,-1
8000c4ec:	58 02       	cp.w	r2,0
8000c4ee:	f7 bc 00 ff 	subeq	r12,-1
8000c4f2:	f9 fb 08 00 	ld.ubeq	r11,r12[0x0]
      }
      u8_pos_name++;
8000c4f6:	2f e8       	sub	r8,-2
8000c4f8:	5c 59       	castu.b	r9
      }
      if( 4 == u8_pos_name )
         ptr_entry += 3;                        // Go to second character

      if( 10 == u8_pos_name )
         ptr_entry += 2;                        // Go to third character
8000c4fa:	c9 8b       	rjmp	8000c42a <fat_entry_longname+0x16a>
8000c4fc:	2f e8       	sub	r8,-2
8000c4fe:	c2 5b       	rjmp	8000c348 <fat_entry_longname+0x88>
8000c500:	2f e8       	sub	r8,-2
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;
         }
         return true;                           // Last long name entry
      }
      if( 4 == u8_pos_name )
         ptr_entry += 3;                        // Go to second character
8000c502:	cc 4b       	rjmp	8000c48a <fat_entry_longname+0x1ca>
8000c504:	2f d8       	sub	r8,-3

      if( 10 == u8_pos_name )
         ptr_entry += 2;                        // Go to third character
8000c506:	cc 2b       	rjmp	8000c48a <fat_entry_longname+0x1ca>
8000c508:	2f e8       	sub	r8,-2
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;
         }
         return true;                           // Last long name entry
      }
      if( 4 == u8_pos_name )
         ptr_entry += 3;                        // Go to second character
8000c50a:	c7 bb       	rjmp	8000c400 <fat_entry_longname+0x140>
8000c50c:	2f d8       	sub	r8,-3

      if( 10 == u8_pos_name )
         ptr_entry += 2;                        // Go to third character
8000c50e:	c7 9b       	rjmp	8000c400 <fat_entry_longname+0x140>
8000c510:	2f e8       	sub	r8,-2
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;
         }
         return true;                           // Last long name entry
      }
      if( 4 == u8_pos_name )
         ptr_entry += 3;                        // Go to second character
8000c512:	ce bb       	rjmp	8000c4e8 <fat_entry_longname+0x228>
8000c514:	2f d8       	sub	r8,-3
      {
         sz_name += (Is_unicode? 2 : 1 );
      }
      u8_pos_name++;
      ptr_entry+=2;
   }
8000c516:	ce 9b       	rjmp	8000c4e8 <fat_entry_longname+0x228>
8000c518:	30 1c       	mov	r12,1
         {  // It is the last long name entry
            // then it is the end of name
            if( (FS_NAME_GET == b_mode) && g_b_string_length )
            {
               ((FS_STR_UNICODE)sz_name)[0] = 14;
               return true;
8000c51a:	cf 7a       	rjmp	8000c308 <fat_entry_longname+0x48>
//! @return    true, it is a character to signal a end of name (0,'\\','/')
//! @return    false, otherwise
//!
bool  fat_check_eof_name( uint16_t character )
{
   return (('\0'==character)||('\\'==character)||('/'==character));
8000c51c:	19 98       	ld.ub	r8,r12[0x1]
8000c51e:	35 cb       	mov	r11,92
8000c520:	f4 08 19 00 	cp.h	r8,r10
8000c524:	5f 09       	sreq	r9
8000c526:	f6 08 19 00 	cp.h	r8,r11
8000c52a:	5f 0b       	sreq	r11
8000c52c:	f7 e9 10 09 	or	r9,r11,r9
8000c530:	f4 09 18 00 	cp.b	r9,r10
8000c534:	cf 21       	brne	8000c518 <fat_entry_longname+0x258>
8000c536:	32 f9       	mov	r9,47
8000c538:	f2 08 19 00 	cp.h	r8,r9
8000c53c:	5f 0c       	sreq	r12
8000c53e:	ce 5a       	rjmp	8000c308 <fat_entry_longname+0x48>
8000c540:	40 0a       	lddsp	r10,sp[0x0]
         else
         {  // It is the last long name entry
            // then it is the end of name
            if( (FS_NAME_GET == b_mode) && g_b_string_length )
            {
               ((FS_STR_UNICODE)sz_name)[0] = 14;
8000c542:	cb 7b       	rjmp	8000c4b0 <fat_entry_longname+0x1f0>
8000c544:	30 e8       	mov	r8,14
8000c546:	b8 08       	st.h	r12[0x0],r8
               return true;
8000c548:	30 1c       	mov	r12,1
         if( ((0 != u16_unicode_entry ) || (( '\\' != u16_unicode_szname) && ( '/' != u16_unicode_szname)) )
         &&  ((u16_unicode_szname != (u16_unicode_entry+('a'-'A'))) || b_match_case)
         &&  ((u16_unicode_szname != (u16_unicode_entry-('a'-'A'))) || b_match_case)
         &&  (u16_unicode_szname != u16_unicode_entry) )
         {
           fs_g_status = FS_ERR_NAME_INCORRECT; //  The name don't corresponding at filter name
8000c54a:	cd fa       	rjmp	8000c308 <fat_entry_longname+0x48>
8000c54c:	31 69       	mov	r9,22
8000c54e:	e0 68 0f 7c 	mov	r8,3964
           return false;
8000c552:	30 0c       	mov	r12,0
               // Write end of string
               if( Is_unicode )
               {
                  ((FS_STR_UNICODE)sz_name)[0] = 0;
               }else{
                  sz_name[0] = 0;
8000c554:	b0 89       	st.b	r8[0x0],r9
8000c556:	cd 9a       	rjmp	8000c308 <fat_entry_longname+0x48>
8000c558:	30 08       	mov	r8,0
               }
               return true;                     // the buffer is full
8000c55a:	b8 88       	st.b	r12[0x0],r8
           fs_g_status = FS_ERR_NAME_INCORRECT; //  The name don't corresponding at filter name
           return false;
         }
      }

      if( 0 == u16_unicode_entry)
8000c55c:	30 1c       	mov	r12,1
8000c55e:	cd 5a       	rjmp	8000c308 <fat_entry_longname+0x48>
8000c560:	1d 82       	ld.ub	r2,lr[0x0]
8000c562:	c7 db       	rjmp	8000c45c <fat_entry_longname+0x19c>

8000c564 <fat_cache_reset>:
8000c564:	3f f9       	mov	r9,-1
8000c566:	e0 68 0f b4 	mov	r8,4020
8000c56a:	b0 89       	st.b	r8[0x0],r9
8000c56c:	30 09       	mov	r9,0
8000c56e:	f1 69 00 08 	st.b	r8[8],r9
//!
void  fat_cache_reset( void )
{
   fs_g_sectorcache.u8_lun                = FS_BUF_SECTOR_EMPTY;
   fs_g_sectorcache.u8_dirty              = false;
   fs_g_sectorcache.u32_clusterlist_start = 0xFFFFFFFF;
8000c572:	3f f9       	mov	r9,-1
}
8000c574:	91 39       	st.w	r8[0xc],r9
8000c576:	5e fc       	retal	r12

8000c578 <fat_cache_mark_sector_as_dirty>:
8000c578:	30 19       	mov	r9,1
8000c57a:	e0 68 0f b4 	mov	r8,4020

//! This function sets a flag to signal that sector cache is modified
//!
void  fat_cache_mark_sector_as_dirty( void )
{
   fs_g_sectorcache.u8_dirty = true;
8000c57e:	f1 69 00 08 	st.b	r8[8],r9
}
8000c582:	5e fc       	retal	r12

8000c584 <fat_check_nav_access_file>:
8000c584:	eb cd 40 80 	pushm	r7,lr

   // For each navigators
   for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
   {
      // Disk mounted ?
      if( FS_TYPE_FAT_UNM != fs_g_navext_fast[i].u8_type_fat )
8000c588:	e0 68 0f 74 	mov	r8,3956
8000c58c:	30 09       	mov	r9,0
8000c58e:	11 8a       	ld.ub	r10,r8[0x0]
8000c590:	f2 0a 18 00 	cp.b	r10,r9
      // Is it the same disk ?
      if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
8000c594:	c0 a0       	breq	8000c5a8 <fat_check_nav_access_file+0x24>
8000c596:	e0 6b 0f 2c 	mov	r11,3884
8000c59a:	e0 6a 0f 80 	mov	r10,3968
8000c59e:	17 87       	ld.ub	r7,r11[0x0]
8000c5a0:	15 8e       	ld.ub	lr,r10[0x0]
         {
            // Is it open in write mode ?
            if( fs_g_navext_entry[i].u8_open_mode & FOPEN_WRITE_ACCESS )
            {
               fs_g_status = FS_ERR_FILE_OPEN_WR;
               return false;  // File opened in write mode then read access not possible
8000c5a2:	fc 07 18 00 	cp.b	r7,lr
#if (FS_MULTI_PARTITION == true)
      // Is it the same partition ?
      if( fs_g_nav.u8_partition == fs_g_navext[i].u8_partition )
#endif
      // Is it the same directory ?
      if( fs_g_nav.u32_cluster_sel_dir == fs_g_navext[i].u32_cluster_sel_dir )
8000c5a6:	c0 30       	breq	8000c5ac <fat_check_nav_access_file+0x28>
8000c5a8:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
8000c5ac:	76 8b       	ld.w	r11,r11[0x20]
      // Is it the same file ?
      if( fs_g_nav_fast.u16_entry_pos_sel_file == fs_g_navext_fast[i].u16_entry_pos_sel_file )
8000c5ae:	74 8a       	ld.w	r10,r10[0x20]
8000c5b0:	14 3b       	cp.w	r11,r10
8000c5b2:	cf b1       	brne	8000c5a8 <fat_check_nav_access_file+0x24>
8000c5b4:	e0 6a 0f 78 	mov	r10,3960
8000c5b8:	90 18       	ld.sh	r8,r8[0x2]
      {
         if( mode )
8000c5ba:	94 1a       	ld.sh	r10,r10[0x2]
8000c5bc:	f0 0a 19 00 	cp.h	r10,r8
         {
            // Is it open ?
            if( fs_g_navext_entry[i].u8_open_mode!=0 )
8000c5c0:	cf 41       	brne	8000c5a8 <fat_check_nav_access_file+0x24>
8000c5c2:	58 0c       	cp.w	r12,0
8000c5c4:	c0 e0       	breq	8000c5e0 <fat_check_nav_access_file+0x5c>
8000c5c6:	e0 68 0f 64 	mov	r8,3940
            {
               fs_g_status = FS_ERR_FILE_OPEN;
8000c5ca:	11 88       	ld.ub	r8,r8[0x0]
8000c5cc:	f2 08 18 00 	cp.b	r8,r9
               return false;  // File opened then write access not possible
8000c5d0:	ce c0       	breq	8000c5a8 <fat_check_nav_access_file+0x24>
8000c5d2:	32 89       	mov	r9,40
            }
         }
         else
         {
            // Is it open in write mode ?
            if( fs_g_navext_entry[i].u8_open_mode & FOPEN_WRITE_ACCESS )
8000c5d4:	e0 68 0f 7c 	mov	r8,3964
8000c5d8:	30 0c       	mov	r12,0
8000c5da:	b0 89       	st.b	r8[0x0],r9
8000c5dc:	e3 cd 80 80 	ldm	sp++,r7,pc
            {
               fs_g_status = FS_ERR_FILE_OPEN_WR;
8000c5e0:	e0 68 0f 64 	mov	r8,3940
               return false;  // File opened in write mode then read access not possible
8000c5e4:	11 88       	ld.ub	r8,r8[0x0]
8000c5e6:	ed b8 00 01 	bld	r8,0x1
8000c5ea:	cd f1       	brne	8000c5a8 <fat_check_nav_access_file+0x24>
8000c5ec:	32 99       	mov	r9,41
8000c5ee:	e0 68 0f 7c 	mov	r8,3964
8000c5f2:	b0 89       	st.b	r8[0x0],r9
8000c5f4:	e3 cd 80 80 	ldm	sp++,r7,pc

8000c5f8 <fat_invert_nav>:
8000c5f8:	d4 21       	pushm	r4-r7,lr
8000c5fa:	20 dd       	sub	sp,52
8000c5fc:	58 0c       	cp.w	r12,0
8000c5fe:	c5 e0       	breq	8000c6ba <fat_invert_nav+0xc2>

   if( u8_idnav == 0 )
      return;
   u8_idnav--;

   memcpy_ram2ram(Temp,                              (uint8_t*)&fs_g_nav,                     sizeof(Fs_management));
8000c600:	e0 68 0f 2c 	mov	r8,3884
8000c604:	f0 ea 00 00 	ld.d	r10,r8[0]
8000c608:	fa eb 00 00 	st.d	sp[0],r10
8000c60c:	f0 ea 00 08 	ld.d	r10,r8[8]
8000c610:	fa eb 00 08 	st.d	sp[8],r10
8000c614:	f0 ea 00 10 	ld.d	r10,r8[16]
8000c618:	fa eb 00 10 	st.d	sp[16],r10
8000c61c:	f0 ea 00 18 	ld.d	r10,r8[24]
8000c620:	fa eb 00 18 	st.d	sp[24],r10
8000c624:	f0 ea 00 20 	ld.d	r10,r8[32]
   memcpy_ram2ram((uint8_t*)&fs_g_nav,                    (uint8_t*)&fs_g_navext[u8_idnav],        sizeof(Fs_management));
8000c628:	f8 c6 00 01 	sub	r6,r12,1

   if( u8_idnav == 0 )
      return;
   u8_idnav--;

   memcpy_ram2ram(Temp,                              (uint8_t*)&fs_g_nav,                     sizeof(Fs_management));
8000c62c:	fa eb 00 20 	st.d	sp[32],r10
8000c630:	10 9c       	mov	r12,r8
8000c632:	f0 ea 00 28 	ld.d	r10,r8[40]
8000c636:	fa eb 00 28 	st.d	sp[40],r10
8000c63a:	70 c8       	ld.w	r8,r8[0x30]
   memcpy_ram2ram((uint8_t*)&fs_g_nav,                    (uint8_t*)&fs_g_navext[u8_idnav],        sizeof(Fs_management));
8000c63c:	50 c8       	stdsp	sp[0x30],r8

   if( u8_idnav == 0 )
      return;
   u8_idnav--;

   memcpy_ram2ram(Temp,                              (uint8_t*)&fs_g_nav,                     sizeof(Fs_management));
8000c63e:	e0 68 0f 80 	mov	r8,3968
   memcpy_ram2ram((uint8_t*)&fs_g_nav,                    (uint8_t*)&fs_g_navext[u8_idnav],        sizeof(Fs_management));
8000c642:	1a 97       	mov	r7,sp
8000c644:	5c 56       	castu.b	r6
8000c646:	33 4a       	mov	r10,52
8000c648:	ec 0a 02 45 	mul	r5,r6,r10
8000c64c:	10 05       	add	r5,r8
8000c64e:	0a 9b       	mov	r11,r5
   memcpy_ram2ram((uint8_t*)&fs_g_navext[u8_idnav],       Temp,                               sizeof(Fs_management));
8000c650:	e0 a0 1e 76 	rcall	8001033c <memcpy>
8000c654:	0a 9c       	mov	r12,r5
8000c656:	33 4a       	mov	r10,52
8000c658:	1a 9b       	mov	r11,sp

   memcpy_ram2ram(Temp,                              (uint8_t*)&fs_g_nav_entry,               sizeof(Fs_management_entry));
8000c65a:	e0 a0 1e 71 	rcall	8001033c <memcpy>
8000c65e:	e0 68 0c ec 	mov	r8,3308
8000c662:	f0 e4 00 00 	ld.d	r4,r8[0]
8000c666:	10 9c       	mov	r12,r8
8000c668:	fa e5 00 00 	st.d	sp[0],r4
8000c66c:	f0 e8 00 08 	ld.d	r8,r8[8]
   memcpy_ram2ram((uint8_t*)&fs_g_nav_entry,              (uint8_t*)&fs_g_navext_entry[u8_idnav],  sizeof(Fs_management_entry));
8000c670:	fa e9 00 08 	st.d	sp[8],r8
8000c674:	e0 68 0f 64 	mov	r8,3940
8000c678:	31 0a       	mov	r10,16
8000c67a:	ec 05 15 04 	lsl	r5,r6,0x4
   memcpy_ram2ram((uint8_t*)&fs_g_navext_entry[u8_idnav], Temp,                               sizeof(Fs_management_entry));
8000c67e:	10 05       	add	r5,r8
8000c680:	0a 9b       	mov	r11,r5
8000c682:	e0 a0 1e 5d 	rcall	8001033c <memcpy>
8000c686:	31 0a       	mov	r10,16

   memcpy_ram2ram(Temp,                              (uint8_t*)&fs_g_nav_fast,                sizeof(Fs_management_fast));
8000c688:	1a 9b       	mov	r11,sp
8000c68a:	0a 9c       	mov	r12,r5
8000c68c:	e0 a0 1e 58 	rcall	8001033c <memcpy>
8000c690:	30 4a       	mov	r10,4
   memcpy_ram2ram((uint8_t*)&fs_g_nav_fast,               (uint8_t*)&fs_g_navext_fast[u8_idnav],   sizeof(Fs_management_fast));
8000c692:	e0 6b 0f 78 	mov	r11,3960
8000c696:	1a 9c       	mov	r12,sp
8000c698:	e0 a0 1e 52 	rcall	8001033c <memcpy>
8000c69c:	e0 68 0f 74 	mov	r8,3956
8000c6a0:	30 4a       	mov	r10,4
   memcpy_ram2ram((uint8_t*)&fs_g_navext_fast[u8_idnav],  Temp,                               sizeof(Fs_management_fast));
8000c6a2:	f0 06 00 26 	add	r6,r8,r6<<0x2
8000c6a6:	e0 6c 0f 78 	mov	r12,3960
8000c6aa:	0c 9b       	mov	r11,r6
}
8000c6ac:	e0 a0 1e 48 	rcall	8001033c <memcpy>
8000c6b0:	1a 9b       	mov	r11,sp
8000c6b2:	0c 9c       	mov	r12,r6
8000c6b4:	30 4a       	mov	r10,4
8000c6b6:	e0 a0 1e 43 	rcall	8001033c <memcpy>
8000c6ba:	2f 3d       	sub	sp,-52
8000c6bc:	d8 22       	popm	r4-r7,pc
8000c6be:	d7 03       	nop

8000c6c0 <fat_cache_flush>:
8000c6c0:	eb cd 40 e0 	pushm	r5-r7,lr
8000c6c4:	e0 65 0f b4 	mov	r5,4020
8000c6c8:	30 18       	mov	r8,1
8000c6ca:	eb 37 00 08 	ld.ub	r7,r5[8]
//! @return    true otherwise
//!
bool  fat_cache_flush( void )
{
   // If the cache is modified, then write the sector cache on the device
   if ( true == fs_g_sectorcache.u8_dirty )
8000c6ce:	f0 07 18 00 	cp.b	r7,r8
         return false;
      }
      if (CTRL_GOOD != ram_2_memory( fs_g_sectorcache.u8_lun , fs_g_sectorcache.u32_addr , fs_g_sector ))
      {
         fs_g_status = FS_ERR_HW;
         return false;
8000c6d2:	c0 30       	breq	8000c6d8 <fat_cache_flush+0x18>
8000c6d4:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
{
   // If the cache is modified, then write the sector cache on the device
   if ( true == fs_g_sectorcache.u8_dirty )
   {
      fs_g_sectorcache.u8_dirty = false; // Always clear, although an error occur
      if( mem_wr_protect( fs_g_sectorcache.u8_lun  ))
8000c6d8:	30 08       	mov	r8,0
bool  fat_cache_flush( void )
{
   // If the cache is modified, then write the sector cache on the device
   if ( true == fs_g_sectorcache.u8_dirty )
   {
      fs_g_sectorcache.u8_dirty = false; // Always clear, although an error occur
8000c6da:	0b 8c       	ld.ub	r12,r5[0x0]
8000c6dc:	eb 68 00 08 	st.b	r5[8],r8
      if( mem_wr_protect( fs_g_sectorcache.u8_lun  ))
8000c6e0:	e0 a0 12 14 	rcall	8000eb08 <mem_wr_protect>
8000c6e4:	18 96       	mov	r6,r12
      {
         fs_g_status = FS_LUN_WP;
8000c6e6:	c0 80       	breq	8000c6f6 <fat_cache_flush+0x36>
8000c6e8:	31 49       	mov	r9,20
8000c6ea:	e0 68 0f 7c 	mov	r8,3964
         return false;
8000c6ee:	30 0c       	mov	r12,0
8000c6f0:	b0 89       	st.b	r8[0x0],r9
      }
      if (CTRL_GOOD != ram_2_memory( fs_g_sectorcache.u8_lun , fs_g_sectorcache.u32_addr , fs_g_sector ))
8000c6f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000c6f6:	0b 8c       	ld.ub	r12,r5[0x0]
8000c6f8:	e0 6a 0d 2c 	mov	r10,3372
8000c6fc:	6a 1b       	ld.w	r11,r5[0x4]
      {
         fs_g_status = FS_ERR_HW;
8000c6fe:	e0 a0 12 17 	rcall	8000eb2c <ram_2_memory>
8000c702:	ce 90       	breq	8000c6d4 <fat_cache_flush+0x14>
         return false;
8000c704:	e0 68 0f 7c 	mov	r8,3964
8000c708:	0c 9c       	mov	r12,r6
8000c70a:	b0 87       	st.b	r8[0x0],r7
8000c70c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c710 <fat_cache_clear>:
8000c710:	d4 01       	pushm	lr
8000c712:	e0 6a 02 00 	mov	r10,512
8000c716:	30 0b       	mov	r11,0
8000c718:	e0 6c 0d 2c 	mov	r12,3372
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
//! This function clears the sector cache
//!
void  fat_cache_clear( void )
{
   memset( fs_g_sector , 0 , FS_CACHE_SIZE );
8000c71c:	e0 a0 1e b4 	rcall	80010484 <memset>
}
8000c720:	d8 02       	popm	pc
8000c722:	d7 03       	nop

8000c724 <fat_check_device>:
8000c724:	d4 31       	pushm	r0-r7,lr
8000c726:	e0 68 0c fe 	mov	r8,3326
   uint8_t i;
#endif
   Ctrl_status status;

   // Possibility to ignore the disk check. Used to take time during multi read/write access
   if( g_b_no_check_disk )
8000c72a:	11 89       	ld.ub	r9,r8[0x0]
8000c72c:	30 08       	mov	r8,0
8000c72e:	f0 09 18 00 	cp.b	r9,r8
      return true;

   if( 0xFF == fs_g_nav.u8_lun )
8000c732:	c4 01       	brne	8000c7b2 <fat_check_device+0x8e>
8000c734:	e0 65 0f 2c 	mov	r5,3884
8000c738:	3f f6       	mov	r6,-1
8000c73a:	0b 89       	ld.ub	r9,r5[0x0]
8000c73c:	ec 09 18 00 	cp.b	r9,r6
      if( CTRL_GOOD       == status )
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
8000c740:	c3 a0       	breq	8000c7b4 <fat_check_device+0x90>
8000c742:	30 03       	mov	r3,0
      Fat_file_close();                            // By default the file is not open
8000c744:	e0 60 0f 78 	mov	r0,3960
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
         }
      }
#endif
      // If the internal cache corresponding at device then clean it
      if( fs_g_nav.u8_lun == fs_g_sectorcache.u8_lun )
8000c748:	06 97       	mov	r7,r3
   }

   for( retry=0 ; retry<100 ; retry++ )
   {
      // Check device
      status = mem_test_unit_ready( fs_g_nav.u8_lun );
8000c74a:	e0 61 0c ec 	mov	r1,3308
8000c74e:	e0 62 0f 80 	mov	r2,3968
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
8000c752:	e0 64 0f b4 	mov	r4,4020

   for( retry=0 ; retry<100 ; retry++ )
   {
      // Check device
      status = mem_test_unit_ready( fs_g_nav.u8_lun );
      if( CTRL_GOOD       == status )
8000c756:	12 9c       	mov	r12,r9
8000c758:	e0 a0 11 cc 	rcall	8000eaf0 <mem_test_unit_ready>
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
      Fat_file_close();                            // By default the file is not open
8000c75c:	e0 68 0d 00 	mov	r8,3328
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
8000c760:	30 1a       	mov	r10,1
8000c762:	e0 6b 0f 7c 	mov	r11,3964
8000c766:	58 0c       	cp.w	r12,0
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
         }
      }
#endif
      // If the internal cache corresponding at device then clean it
      if( fs_g_nav.u8_lun == fs_g_sectorcache.u8_lun )
8000c768:	c2 50       	breq	8000c7b2 <fat_check_device+0x8e>

//! This function resets the sector cache
//!
void  fat_cache_reset( void )
{
   fs_g_sectorcache.u8_lun                = FS_BUF_SECTOR_EMPTY;
8000c76a:	a0 87       	st.b	r0[0x0],r7
8000c76c:	a2 87       	st.b	r1[0x0],r7
8000c76e:	0b 89       	ld.ub	r9,r5[0x0]
8000c770:	05 8e       	ld.ub	lr,r2[0x0]
   fs_g_sectorcache.u8_dirty              = false;
8000c772:	f2 0e 18 00 	cp.b	lr,r9
   fs_g_sectorcache.u32_clusterlist_start = 0xFFFFFFFF;
8000c776:	c2 a0       	breq	8000c7ca <fat_check_device+0xa6>
8000c778:	09 8e       	ld.ub	lr,r4[0x0]
8000c77a:	f2 0e 18 00 	cp.b	lr,r9
//! This function resets the cluster list caches
//!
void  fat_cache_clusterlist_reset( void )
{
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
8000c77e:	e9 f6 0e 00 	st.beq	r4[0x0],r6
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
      fs_g_cache_clusterlist[u8_i].u8_level_use = 0xFF;
8000c782:	e9 f7 0e 08 	st.beq	r4[0x8],r7
      {
         fat_cache_reset();
      }
      fat_cache_clusterlist_reset();

      fs_g_status = FS_ERR_HW;                     // By default HW error
8000c786:	f9 be 00 ff 	moveq	lr,-1
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
8000c78a:	e9 fe 0a 03 	st.weq	r4[0xc],lr
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
8000c78e:	e0 6e 0f 7e 	mov	lr,3966
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
8000c792:	bc 87       	st.b	lr[0x0],r7
8000c794:	f1 66 00 15 	st.b	r8[21],r6
         fat_cache_reset();
      }
      fat_cache_clusterlist_reset();

      fs_g_status = FS_ERR_HW;                     // By default HW error
      if( CTRL_BUSY == status )
8000c798:	b6 8a       	st.b	r11[0x0],r10
         continue;                                 // If device busy then retry

      if( CTRL_NO_PRESENT == status )
8000c79a:	b0 8a       	st.b	r8[0x0],r10
8000c79c:	b0 a6       	st.b	r8[0x2],r6
         fs_g_status = FS_ERR_HW_NO_PRESENT;       // Update error flag
8000c79e:	b0 96       	st.b	r8[0x1],r6
8000c7a0:	f1 67 00 14 	st.b	r8[20],r7
   if( g_b_no_check_disk )
      return true;

   if( 0xFF == fs_g_nav.u8_lun )
   {
      fs_g_status = FS_ERR_HW;
8000c7a4:	f1 66 00 16 	st.b	r8[22],r6
8000c7a8:	58 3c       	cp.w	r12,3
      return false;                                // No device selected
8000c7aa:	c0 b0       	breq	8000c7c0 <fat_check_device+0x9c>
         fat_cache_reset();
      }
      fat_cache_clusterlist_reset();

      fs_g_status = FS_ERR_HW;                     // By default HW error
      if( CTRL_BUSY == status )
8000c7ac:	58 2c       	cp.w	r12,2
   {
      fs_g_status = FS_ERR_HW;
      return false;                                // No device selected
   }

   for( retry=0 ; retry<100 ; retry++ )
8000c7ae:	c1 50       	breq	8000c7d8 <fat_check_device+0xb4>
8000c7b0:	d8 3a       	popm	r0-r7,pc,r12=0
8000c7b2:	da 3a       	popm	r0-r7,pc,r12=1
8000c7b4:	30 19       	mov	r9,1
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
         {
            fs_g_navext_fast[i].u8_type_fat     = FS_TYPE_FAT_UNM;   // By default the fat isn't mounted
8000c7b6:	e0 68 0f 7c 	mov	r8,3964
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
8000c7ba:	30 0c       	mov	r12,0
8000c7bc:	b0 89       	st.b	r8[0x0],r9
8000c7be:	d8 32       	popm	r0-r7,pc
      fs_g_status = FS_ERR_HW;                     // By default HW error
      if( CTRL_BUSY == status )
         continue;                                 // If device busy then retry

      if( CTRL_NO_PRESENT == status )
         fs_g_status = FS_ERR_HW_NO_PRESENT;       // Update error flag
8000c7c0:	2f f3       	sub	r3,-1
8000c7c2:	e0 43 00 64 	cp.w	r3,100
8000c7c6:	cc 81       	brne	8000c756 <fat_check_device+0x32>
8000c7c8:	cf 4b       	rjmp	8000c7b0 <fat_check_device+0x8c>
8000c7ca:	e0 6e 0f 74 	mov	lr,3956
8000c7ce:	bc 87       	st.b	lr[0x0],r7
8000c7d0:	e0 6e 0f 64 	mov	lr,3940
8000c7d4:	bc 87       	st.b	lr[0x0],r7
8000c7d6:	cd 1b       	rjmp	8000c778 <fat_check_device+0x54>
8000c7d8:	31 88       	mov	r8,24
8000c7da:	30 0c       	mov	r12,0
8000c7dc:	b6 88       	st.b	r11[0x0],r8
8000c7de:	d8 32       	popm	r0-r7,pc

8000c7e0 <fat_cache_read_sector>:
8000c7e0:	eb cd 40 fc 	pushm	r2-r7,lr
8000c7e4:	e0 66 0f 2c 	mov	r6,3884
8000c7e8:	18 94       	mov	r4,r12
8000c7ea:	e0 67 0f b4 	mov	r7,4020
8000c7ee:	0d 8c       	ld.ub	r12,r6[0x0]
8000c7f0:	0f 88       	ld.ub	r8,r7[0x0]
8000c7f2:	f8 08 18 00 	cp.b	r8,r12
8000c7f6:	c1 90       	breq	8000c828 <fat_cache_read_sector+0x48>
//! @return    true otherwise
//!
bool  fat_cache_flush( void )
{
   // If the cache is modified, then write the sector cache on the device
   if ( true == fs_g_sectorcache.u8_dirty )
8000c7f8:	ef 35 00 08 	ld.ub	r5,r7[8]
8000c7fc:	e0 62 0f b4 	mov	r2,4020
8000c800:	30 18       	mov	r8,1

//! This function resets the sector cache
//!
void  fat_cache_reset( void )
{
   fs_g_sectorcache.u8_lun                = FS_BUF_SECTOR_EMPTY;
8000c802:	f0 05 18 00 	cp.b	r5,r8
   fs_g_sectorcache.u8_dirty              = false;
8000c806:	c1 90       	breq	8000c838 <fat_cache_read_sector+0x58>
8000c808:	3f f8       	mov	r8,-1
8000c80a:	ae 88       	st.b	r7[0x0],r8
   fs_g_sectorcache.u32_clusterlist_start = 0xFFFFFFFF;
8000c80c:	30 08       	mov	r8,0
8000c80e:	ef 68 00 08 	st.b	r7[8],r8

   // Delete informations about the caches
   fat_cache_reset();

   // Init sector cache
   fs_g_sectorcache.u32_addr = fs_gu32_addrsector;
8000c812:	3f f8       	mov	r8,-1
8000c814:	8f 38       	st.w	r7[0xc],r8
   if( b_load )
8000c816:	e0 68 0c e8 	mov	r8,3304
         fs_g_status = FS_ERR_HW;
         return false;
      }
   }
   // Valid sector cache
   fs_g_sectorcache.u8_lun = fs_g_nav.u8_lun;
8000c81a:	70 0b       	ld.w	r11,r8[0x0]
8000c81c:	8f 1b       	st.w	r7[0x4],r11
8000c81e:	58 04       	cp.w	r4,0
//! @endverbatim
//!
bool  fat_cache_read_sector( bool b_load )
{
   // Check if the sector asked is the same in cache
   if( (fs_g_sectorcache.u8_lun     == fs_g_nav.u8_lun )
8000c820:	c1 b1       	brne	8000c856 <fat_cache_read_sector+0x76>
8000c822:	ae 8c       	st.b	r7[0x0],r12
8000c824:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
8000c828:	e0 68 0c e8 	mov	r8,3304
8000c82c:	6e 19       	ld.w	r9,r7[0x4]
bool  fat_cache_flush( void )
{
   // If the cache is modified, then write the sector cache on the device
   if ( true == fs_g_sectorcache.u8_dirty )
   {
      fs_g_sectorcache.u8_dirty = false; // Always clear, although an error occur
8000c82e:	70 08       	ld.w	r8,r8[0x0]
      if( mem_wr_protect( fs_g_sectorcache.u8_lun  ))
8000c830:	10 39       	cp.w	r9,r8
bool  fat_cache_flush( void )
{
   // If the cache is modified, then write the sector cache on the device
   if ( true == fs_g_sectorcache.u8_dirty )
   {
      fs_g_sectorcache.u8_dirty = false; // Always clear, although an error occur
8000c832:	ce 31       	brne	8000c7f8 <fat_cache_read_sector+0x18>
8000c834:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
      if( mem_wr_protect( fs_g_sectorcache.u8_lun  ))
8000c838:	30 08       	mov	r8,0
8000c83a:	05 8c       	ld.ub	r12,r2[0x0]
8000c83c:	e5 68 00 08 	st.b	r2[8],r8
      {
         fs_g_status = FS_LUN_WP;
8000c840:	e0 a0 11 64 	rcall	8000eb08 <mem_wr_protect>
8000c844:	18 93       	mov	r3,r12
8000c846:	c0 f0       	breq	8000c864 <fat_cache_read_sector+0x84>
8000c848:	31 49       	mov	r9,20
   // Init sector cache
   fs_g_sectorcache.u32_addr = fs_gu32_addrsector;
   if( b_load )
   {
      // Load the sector from memory
      if( CTRL_GOOD != memory_2_ram( fs_g_nav.u8_lun  , fs_g_sectorcache.u32_addr, fs_g_sector))
8000c84a:	e0 68 0f 7c 	mov	r8,3964
8000c84e:	30 0c       	mov	r12,0
8000c850:	b0 89       	st.b	r8[0x0],r9
8000c852:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
      if( mem_wr_protect( fs_g_sectorcache.u8_lun  ))
      {
         fs_g_status = FS_LUN_WP;
         return false;
      }
      if (CTRL_GOOD != ram_2_memory( fs_g_sectorcache.u8_lun , fs_g_sectorcache.u32_addr , fs_g_sector ))
8000c856:	e0 6a 0d 2c 	mov	r10,3372
8000c85a:	e0 a0 11 5f 	rcall	8000eb18 <memory_2_ram>
8000c85e:	c1 01       	brne	8000c87e <fat_cache_read_sector+0x9e>
8000c860:	0d 8c       	ld.ub	r12,r6[0x0]
      {
         fs_g_status = FS_ERR_HW;
8000c862:	ce 0b       	rjmp	8000c822 <fat_cache_read_sector+0x42>
8000c864:	05 8c       	ld.ub	r12,r2[0x0]
8000c866:	e0 6a 0d 2c 	mov	r10,3372
8000c86a:	64 1b       	ld.w	r11,r2[0x4]
   if( b_load )
   {
      // Load the sector from memory
      if( CTRL_GOOD != memory_2_ram( fs_g_nav.u8_lun  , fs_g_sectorcache.u32_addr, fs_g_sector))
      {
         fs_g_status = FS_ERR_HW;
8000c86c:	e0 a0 11 60 	rcall	8000eb2c <ram_2_memory>
8000c870:	c0 e0       	breq	8000c88c <fat_cache_read_sector+0xac>
8000c872:	e0 68 0f 7c 	mov	r8,3964
         return false;
8000c876:	06 9c       	mov	r12,r3
      if( mem_wr_protect( fs_g_sectorcache.u8_lun  ))
      {
         fs_g_status = FS_LUN_WP;
         return false;
      }
      if (CTRL_GOOD != ram_2_memory( fs_g_sectorcache.u8_lun , fs_g_sectorcache.u32_addr , fs_g_sector ))
8000c878:	b0 85       	st.b	r8[0x0],r5
8000c87a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000c87e:	30 19       	mov	r9,1
8000c880:	e0 68 0f 7c 	mov	r8,3964
8000c884:	30 0c       	mov	r12,0
8000c886:	b0 89       	st.b	r8[0x0],r9
8000c888:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000c88c:	0d 8c       	ld.ub	r12,r6[0x0]
8000c88e:	cb db       	rjmp	8000c808 <fat_cache_read_sector+0x28>

8000c890 <T.78>:
8000c890:	eb cd 40 f8 	pushm	r3-r7,lr
8000c894:	e0 66 0f 2c 	mov	r6,3884
8000c898:	e0 67 0f b4 	mov	r7,4020
//! @endverbatim
//!
bool  fat_cache_read_sector( bool b_load )
{
   // Check if the sector asked is the same in cache
   if( (fs_g_sectorcache.u8_lun     == fs_g_nav.u8_lun )
8000c89c:	0d 8c       	ld.ub	r12,r6[0x0]
8000c89e:	0f 88       	ld.ub	r8,r7[0x0]
8000c8a0:	f8 08 18 00 	cp.b	r8,r12
//! @return    true otherwise
//!
bool  fat_cache_flush( void )
{
   // If the cache is modified, then write the sector cache on the device
   if ( true == fs_g_sectorcache.u8_dirty )
8000c8a4:	c2 00       	breq	8000c8e4 <T.78+0x54>
8000c8a6:	ef 35 00 08 	ld.ub	r5,r7[8]
8000c8aa:	e0 63 0f b4 	mov	r3,4020
8000c8ae:	30 18       	mov	r8,1

//! This function resets the sector cache
//!
void  fat_cache_reset( void )
{
   fs_g_sectorcache.u8_lun                = FS_BUF_SECTOR_EMPTY;
8000c8b0:	f0 05 18 00 	cp.b	r5,r8
   fs_g_sectorcache.u8_dirty              = false;
8000c8b4:	c2 70       	breq	8000c902 <T.78+0x72>
8000c8b6:	3f f8       	mov	r8,-1
8000c8b8:	ae 88       	st.b	r7[0x0],r8
   fs_g_sectorcache.u32_clusterlist_start = 0xFFFFFFFF;
8000c8ba:	30 08       	mov	r8,0
8000c8bc:	ef 68 00 08 	st.b	r7[8],r8
   // Init sector cache
   fs_g_sectorcache.u32_addr = fs_gu32_addrsector;
   if( b_load )
   {
      // Load the sector from memory
      if( CTRL_GOOD != memory_2_ram( fs_g_nav.u8_lun  , fs_g_sectorcache.u32_addr, fs_g_sector))
8000c8c0:	3f f8       	mov	r8,-1

   // Delete informations about the caches
   fat_cache_reset();

   // Init sector cache
   fs_g_sectorcache.u32_addr = fs_gu32_addrsector;
8000c8c2:	8f 38       	st.w	r7[0xc],r8
8000c8c4:	e0 68 0c e8 	mov	r8,3304
   if( b_load )
   {
      // Load the sector from memory
      if( CTRL_GOOD != memory_2_ram( fs_g_nav.u8_lun  , fs_g_sectorcache.u32_addr, fs_g_sector))
8000c8c8:	e0 6a 0d 2c 	mov	r10,3372
         fs_g_status = FS_ERR_HW;
         return false;
      }
   }
   // Valid sector cache
   fs_g_sectorcache.u8_lun = fs_g_nav.u8_lun;
8000c8cc:	70 0b       	ld.w	r11,r8[0x0]
8000c8ce:	8f 1b       	st.w	r7[0x4],r11
8000c8d0:	e0 a0 11 24 	rcall	8000eb18 <memory_2_ram>
   return true;
}
8000c8d4:	c1 01       	brne	8000c8f4 <T.78+0x64>
8000c8d6:	0d 89       	ld.ub	r9,r6[0x0]
//! @endverbatim
//!
bool  fat_cache_read_sector( bool b_load )
{
   // Check if the sector asked is the same in cache
   if( (fs_g_sectorcache.u8_lun     == fs_g_nav.u8_lun )
8000c8d8:	e0 68 0f b4 	mov	r8,4020
8000c8dc:	30 1c       	mov	r12,1
8000c8de:	b0 89       	st.b	r8[0x0],r9
8000c8e0:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000c8e4:	e0 68 0c e8 	mov	r8,3304
   if( b_load )
   {
      // Load the sector from memory
      if( CTRL_GOOD != memory_2_ram( fs_g_nav.u8_lun  , fs_g_sectorcache.u32_addr, fs_g_sector))
      {
         fs_g_status = FS_ERR_HW;
8000c8e8:	6e 19       	ld.w	r9,r7[0x4]
8000c8ea:	70 08       	ld.w	r8,r8[0x0]
8000c8ec:	10 39       	cp.w	r9,r8
8000c8ee:	cd c1       	brne	8000c8a6 <T.78+0x16>
8000c8f0:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
{
   // If the cache is modified, then write the sector cache on the device
   if ( true == fs_g_sectorcache.u8_dirty )
   {
      fs_g_sectorcache.u8_dirty = false; // Always clear, although an error occur
      if( mem_wr_protect( fs_g_sectorcache.u8_lun  ))
8000c8f4:	30 19       	mov	r9,1
bool  fat_cache_flush( void )
{
   // If the cache is modified, then write the sector cache on the device
   if ( true == fs_g_sectorcache.u8_dirty )
   {
      fs_g_sectorcache.u8_dirty = false; // Always clear, although an error occur
8000c8f6:	e0 68 0f 7c 	mov	r8,3964
      if( mem_wr_protect( fs_g_sectorcache.u8_lun  ))
8000c8fa:	30 0c       	mov	r12,0
8000c8fc:	b0 89       	st.b	r8[0x0],r9
8000c8fe:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
      {
         fs_g_status = FS_LUN_WP;
8000c902:	30 08       	mov	r8,0
8000c904:	07 8c       	ld.ub	r12,r3[0x0]
8000c906:	e7 68 00 08 	st.b	r3[8],r8
8000c90a:	e0 a0 10 ff 	rcall	8000eb08 <mem_wr_protect>
         return false;
      }
      if (CTRL_GOOD != ram_2_memory( fs_g_sectorcache.u8_lun , fs_g_sectorcache.u32_addr , fs_g_sector ))
8000c90e:	18 94       	mov	r4,r12
8000c910:	c0 80       	breq	8000c920 <T.78+0x90>
8000c912:	31 49       	mov	r9,20
8000c914:	e0 68 0f 7c 	mov	r8,3964
8000c918:	30 0c       	mov	r12,0
      {
         fs_g_status = FS_ERR_HW;
8000c91a:	b0 89       	st.b	r8[0x0],r9
8000c91c:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000c920:	07 8c       	ld.ub	r12,r3[0x0]
8000c922:	e0 6a 0d 2c 	mov	r10,3372
      if( mem_wr_protect( fs_g_sectorcache.u8_lun  ))
      {
         fs_g_status = FS_LUN_WP;
         return false;
      }
      if (CTRL_GOOD != ram_2_memory( fs_g_sectorcache.u8_lun , fs_g_sectorcache.u32_addr , fs_g_sector ))
8000c926:	66 1b       	ld.w	r11,r3[0x4]
8000c928:	e0 a0 11 02 	rcall	8000eb2c <ram_2_memory>
8000c92c:	c0 70       	breq	8000c93a <T.78+0xaa>
8000c92e:	e0 68 0f 7c 	mov	r8,3964
8000c932:	08 9c       	mov	r12,r4
8000c934:	b0 85       	st.b	r8[0x0],r5
8000c936:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000c93a:	0d 8c       	ld.ub	r12,r6[0x0]
8000c93c:	cb db       	rjmp	8000c8b6 <T.78+0x26>
8000c93e:	d7 03       	nop

8000c940 <fat_check_noopen>:
8000c940:	d4 31       	pushm	r0-r7,lr
8000c942:	e0 68 0c fe 	mov	r8,3326
8000c946:	11 89       	ld.ub	r9,r8[0x0]
   uint8_t i;
#endif
   Ctrl_status status;

   // Possibility to ignore the disk check. Used to take time during multi read/write access
   if( g_b_no_check_disk )
8000c948:	30 08       	mov	r8,0
8000c94a:	f0 09 18 00 	cp.b	r9,r8
      return true;

   if( 0xFF == fs_g_nav.u8_lun )
8000c94e:	c4 01       	brne	8000c9ce <fat_check_noopen+0x8e>
8000c950:	e0 64 0f 2c 	mov	r4,3884
8000c954:	3f f6       	mov	r6,-1
8000c956:	09 89       	ld.ub	r9,r4[0x0]
8000c958:	ec 09 18 00 	cp.b	r9,r6
   {
      fs_g_status = FS_ERR_HW;
8000c95c:	c4 c0       	breq	8000c9f4 <fat_check_noopen+0xb4>
      if( CTRL_GOOD       == status )
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
8000c95e:	30 02       	mov	r2,0
      Fat_file_close();                            // By default the file is not open
8000c960:	e0 65 0f 78 	mov	r5,3960
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
         }
      }
#endif
      // If the internal cache corresponding at device then clean it
      if( fs_g_nav.u8_lun == fs_g_sectorcache.u8_lun )
8000c964:	04 97       	mov	r7,r2
   }

   for( retry=0 ; retry<100 ; retry++ )
   {
      // Check device
      status = mem_test_unit_ready( fs_g_nav.u8_lun );
8000c966:	e0 60 0c ec 	mov	r0,3308
8000c96a:	e0 61 0f 80 	mov	r1,3968
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
8000c96e:	e0 63 0f b4 	mov	r3,4020

   for( retry=0 ; retry<100 ; retry++ )
   {
      // Check device
      status = mem_test_unit_ready( fs_g_nav.u8_lun );
      if( CTRL_GOOD       == status )
8000c972:	12 9c       	mov	r12,r9
8000c974:	e0 a0 10 be 	rcall	8000eaf0 <mem_test_unit_ready>
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
      Fat_file_close();                            // By default the file is not open
8000c978:	e0 68 0d 00 	mov	r8,3328
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
8000c97c:	30 1a       	mov	r10,1
8000c97e:	e0 6b 0f 7c 	mov	r11,3964
8000c982:	58 0c       	cp.w	r12,0
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
         }
      }
#endif
      // If the internal cache corresponding at device then clean it
      if( fs_g_nav.u8_lun == fs_g_sectorcache.u8_lun )
8000c984:	c2 70       	breq	8000c9d2 <fat_check_noopen+0x92>

//! This function resets the sector cache
//!
void  fat_cache_reset( void )
{
   fs_g_sectorcache.u8_lun                = FS_BUF_SECTOR_EMPTY;
8000c986:	aa 87       	st.b	r5[0x0],r7
8000c988:	a0 87       	st.b	r0[0x0],r7
8000c98a:	09 89       	ld.ub	r9,r4[0x0]
8000c98c:	03 8e       	ld.ub	lr,r1[0x0]
   fs_g_sectorcache.u8_dirty              = false;
8000c98e:	f2 0e 18 00 	cp.b	lr,r9
   fs_g_sectorcache.u32_clusterlist_start = 0xFFFFFFFF;
8000c992:	c3 c0       	breq	8000ca0a <fat_check_noopen+0xca>
8000c994:	07 8e       	ld.ub	lr,r3[0x0]
8000c996:	f2 0e 18 00 	cp.b	lr,r9
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
      fs_g_cache_clusterlist[u8_i].u8_level_use = 0xFF;
8000c99a:	e7 f6 0e 00 	st.beq	r3[0x0],r6
      {
         fat_cache_reset();
      }
      fat_cache_clusterlist_reset();

      fs_g_status = FS_ERR_HW;                     // By default HW error
8000c99e:	e7 f7 0e 08 	st.beq	r3[0x8],r7
//! This function resets the cluster list caches
//!
void  fat_cache_clusterlist_reset( void )
{
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
8000c9a2:	f9 be 00 ff 	moveq	lr,-1
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
8000c9a6:	e7 fe 0a 03 	st.weq	r3[0xc],lr
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
8000c9aa:	f1 66 00 15 	st.b	r8[21],r6
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
8000c9ae:	b6 8a       	st.b	r11[0x0],r10
8000c9b0:	e0 6e 0f 7e 	mov	lr,3966
         fat_cache_reset();
      }
      fat_cache_clusterlist_reset();

      fs_g_status = FS_ERR_HW;                     // By default HW error
      if( CTRL_BUSY == status )
8000c9b4:	bc 87       	st.b	lr[0x0],r7
         continue;                                 // If device busy then retry

      if( CTRL_NO_PRESENT == status )
8000c9b6:	b0 8a       	st.b	r8[0x0],r10
8000c9b8:	b0 a6       	st.b	r8[0x2],r6
   if (FS_TYPE_FAT_UNM == fs_g_nav_fast.u8_type_fat)
      return true;
   if( Fat_file_is_open() )
   {
      fs_g_status = FS_ERR_TOO_FILE_OPEN;  // The navigation have already open a file
      return false;
8000c9ba:	b0 96       	st.b	r8[0x1],r6
8000c9bc:	f1 67 00 14 	st.b	r8[20],r7
//!
bool  fat_check_noopen( void )
{
   if( !fat_check_device() )
      return true;
   if (FS_TYPE_FAT_UNM == fs_g_nav_fast.u8_type_fat)
8000c9c0:	f1 66 00 16 	st.b	r8[22],r6
8000c9c4:	58 3c       	cp.w	r12,3
8000c9c6:	c1 d0       	breq	8000ca00 <fat_check_noopen+0xc0>
      return true;
   if( Fat_file_is_open() )
8000c9c8:	58 2c       	cp.w	r12,2
8000c9ca:	c2 70       	breq	8000ca18 <fat_check_noopen+0xd8>
8000c9cc:	da 3a       	popm	r0-r7,pc,r12=1
8000c9ce:	e0 65 0f 78 	mov	r5,3960
   {
      fs_g_status = FS_ERR_TOO_FILE_OPEN;  // The navigation have already open a file
8000c9d2:	0b 89       	ld.ub	r9,r5[0x0]
8000c9d4:	30 08       	mov	r8,0
8000c9d6:	f0 09 18 00 	cp.b	r9,r8
      return false;
8000c9da:	cf 90       	breq	8000c9cc <fat_check_noopen+0x8c>
   if( g_b_no_check_disk )
      return true;

   if( 0xFF == fs_g_nav.u8_lun )
   {
      fs_g_status = FS_ERR_HW;
8000c9dc:	e0 69 0c ec 	mov	r9,3308
8000c9e0:	13 89       	ld.ub	r9,r9[0x0]
8000c9e2:	f0 09 18 00 	cp.b	r9,r8
         fat_cache_reset();
      }
      fat_cache_clusterlist_reset();

      fs_g_status = FS_ERR_HW;                     // By default HW error
      if( CTRL_BUSY == status )
8000c9e6:	cf 30       	breq	8000c9cc <fat_check_noopen+0x8c>
   {
      fs_g_status = FS_ERR_HW;
      return false;                                // No device selected
   }

   for( retry=0 ; retry<100 ; retry++ )
8000c9e8:	30 59       	mov	r9,5
8000c9ea:	e0 68 0f 7c 	mov	r8,3964
8000c9ee:	30 0c       	mov	r12,0
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
         {
            fs_g_navext_fast[i].u8_type_fat     = FS_TYPE_FAT_UNM;   // By default the fat isn't mounted
8000c9f0:	b0 89       	st.b	r8[0x0],r9
8000c9f2:	d8 32       	popm	r0-r7,pc
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
8000c9f4:	30 19       	mov	r9,1
8000c9f6:	e0 68 0f 7c 	mov	r8,3964
      fs_g_status = FS_ERR_HW;                     // By default HW error
      if( CTRL_BUSY == status )
         continue;                                 // If device busy then retry

      if( CTRL_NO_PRESENT == status )
         fs_g_status = FS_ERR_HW_NO_PRESENT;       // Update error flag
8000c9fa:	30 1c       	mov	r12,1
8000c9fc:	b0 89       	st.b	r8[0x0],r9
8000c9fe:	d8 32       	popm	r0-r7,pc
8000ca00:	2f f2       	sub	r2,-1
8000ca02:	e0 42 00 64 	cp.w	r2,100
8000ca06:	cb 61       	brne	8000c972 <fat_check_noopen+0x32>
8000ca08:	ce 2b       	rjmp	8000c9cc <fat_check_noopen+0x8c>
8000ca0a:	e0 6e 0f 74 	mov	lr,3956
8000ca0e:	bc 87       	st.b	lr[0x0],r7
8000ca10:	e0 6e 0f 64 	mov	lr,3940
8000ca14:	bc 87       	st.b	lr[0x0],r7
8000ca16:	cb fb       	rjmp	8000c994 <fat_check_noopen+0x54>
8000ca18:	31 88       	mov	r8,24
8000ca1a:	30 1c       	mov	r12,1
8000ca1c:	b6 88       	st.b	r11[0x0],r8
8000ca1e:	d8 32       	popm	r0-r7,pc

8000ca20 <fat_cluster_val>:
8000ca20:	d4 31       	pushm	r0-r7,lr
8000ca22:	20 5d       	sub	sp,20
8000ca24:	e0 64 0f 78 	mov	r4,3960
8000ca28:	18 95       	mov	r5,r12
8000ca2a:	09 8a       	ld.ub	r10,r4[0x0]
8000ca2c:	30 38       	mov	r8,3
8000ca2e:	f0 0a 18 00 	cp.b	r10,r8
8000ca32:	e0 80 00 99 	breq	8000cb64 <fat_cluster_val+0x144>

      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos * 4) % FS_CACHE_SIZE;
      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos % 128) * 4
      fs_g_u16_pos_fat = ((uint16_t)(LSB0(fs_g_cluster.u32_pos) & 0x7F))<< 2;
   }
   else if ( Is_fat16 )
8000ca36:	30 28       	mov	r8,2
8000ca38:	f0 0a 18 00 	cp.b	r10,r8
8000ca3c:	e0 80 00 a7 	breq	8000cb8a <fat_cluster_val+0x16a>
      u32_offset_fat = LSB1(fs_g_cluster.u32_pos);
      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos * 2) % FS_CACHE_SIZE;
      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos % 256) * 2
      fs_g_u16_pos_fat = ((uint16_t)LSB0(fs_g_cluster.u32_pos)) <<1;
   }
   else if ( Is_fat12 )
8000ca40:	30 18       	mov	r8,1
8000ca42:	f0 0a 18 00 	cp.b	r10,r8
8000ca46:	e0 80 00 ab 	breq	8000cb9c <fat_cluster_val+0x17c>
8000ca4a:	30 0b       	mov	r11,0
      // Optimization of -> fs_g_u16_pos_fat = fs_g_u16_pos_fat % FS_CACHE_SIZE
      MSB( fs_g_u16_pos_fat ) &= 0x01;
   }

#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
   if (b_mode)
8000ca4c:	58 05       	cp.w	r5,0
8000ca4e:	c1 40       	breq	8000ca76 <fat_cluster_val+0x56>
   {
      // Update information about FAT modification
      if( fs_g_u32_first_mod_fat > u32_offset_fat )
8000ca50:	e0 68 0f 60 	mov	r8,3936
8000ca54:	70 09       	ld.w	r9,r8[0x0]
      {
         fs_g_u32_first_mod_fat = u32_offset_fat;
8000ca56:	12 3b       	cp.w	r11,r9
8000ca58:	f1 fb 3a 00 	st.wcs	r8[0x0],r11
      }
      if( fs_g_u32_last_mod_fat < u32_offset_fat )
8000ca5c:	e0 69 0d 28 	mov	r9,3368
8000ca60:	72 08       	ld.w	r8,r9[0x0]
      {
         fs_g_u32_last_mod_fat = u32_offset_fat;
8000ca62:	10 3b       	cp.w	r11,r8
8000ca64:	f3 fb ba 00 	st.whi	r9[0x0],r11
8000ca68:	f6 08 17 b0 	movhi	r8,r11
      }
      if ( Is_fat12 )
8000ca6c:	30 1c       	mov	r12,1
8000ca6e:	f8 0a 18 00 	cp.b	r10,r12
8000ca72:	e0 80 00 e4 	breq	8000cc3a <fat_cluster_val+0x21a>
      }
   }
#endif  // FS_LEVEL_FEATURES

   //**** Read cluster sector in FAT
   fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + u32_offset_fat;   // Computed logical sector address
8000ca76:	e0 66 0f 2c 	mov	r6,3884
8000ca7a:	e0 63 0c e8 	mov	r3,3304
8000ca7e:	6c 48       	ld.w	r8,r6[0x10]
8000ca80:	10 0b       	add	r11,r8
8000ca82:	87 0b       	st.w	r3[0x0],r11
//! @endverbatim
//!
bool  fat_cache_read_sector( bool b_load )
{
   // Check if the sector asked is the same in cache
   if( (fs_g_sectorcache.u8_lun     == fs_g_nav.u8_lun )
8000ca84:	e0 67 0f b4 	mov	r7,4020
8000ca88:	0d 8c       	ld.ub	r12,r6[0x0]
8000ca8a:	0f 88       	ld.ub	r8,r7[0x0]
8000ca8c:	f8 08 18 00 	cp.b	r8,r12
8000ca90:	c0 51       	brne	8000ca9a <fat_cluster_val+0x7a>
8000ca92:	6e 18       	ld.w	r8,r7[0x4]
8000ca94:	10 3b       	cp.w	r11,r8
8000ca96:	e0 80 00 e1 	breq	8000cc58 <fat_cluster_val+0x238>
//! @return    true otherwise
//!
bool  fat_cache_flush( void )
{
   // If the cache is modified, then write the sector cache on the device
   if ( true == fs_g_sectorcache.u8_dirty )
8000ca9a:	ef 32 00 08 	ld.ub	r2,r7[8]
8000ca9e:	e0 68 0f b4 	mov	r8,4020
8000caa2:	30 19       	mov	r9,1
8000caa4:	f2 02 18 00 	cp.b	r2,r9
8000caa8:	e0 80 00 b8 	breq	8000cc18 <fat_cluster_val+0x1f8>
8000caac:	e0 61 0d 2c 	mov	r1,3372

//! This function resets the sector cache
//!
void  fat_cache_reset( void )
{
   fs_g_sectorcache.u8_lun                = FS_BUF_SECTOR_EMPTY;
8000cab0:	3f f8       	mov	r8,-1
8000cab2:	ae 88       	st.b	r7[0x0],r8
   fs_g_sectorcache.u8_dirty              = false;
8000cab4:	30 08       	mov	r8,0
8000cab6:	ef 68 00 08 	st.b	r7[8],r8
   fs_g_sectorcache.u32_clusterlist_start = 0xFFFFFFFF;
8000caba:	3f f8       	mov	r8,-1

   // Delete informations about the caches
   fat_cache_reset();

   // Init sector cache
   fs_g_sectorcache.u32_addr = fs_gu32_addrsector;
8000cabc:	8f 1b       	st.w	r7[0x4],r11
//!
void  fat_cache_reset( void )
{
   fs_g_sectorcache.u8_lun                = FS_BUF_SECTOR_EMPTY;
   fs_g_sectorcache.u8_dirty              = false;
   fs_g_sectorcache.u32_clusterlist_start = 0xFFFFFFFF;
8000cabe:	8f 38       	st.w	r7[0xc],r8
   // Init sector cache
   fs_g_sectorcache.u32_addr = fs_gu32_addrsector;
   if( b_load )
   {
      // Load the sector from memory
      if( CTRL_GOOD != memory_2_ram( fs_g_nav.u8_lun  , fs_g_sectorcache.u32_addr, fs_g_sector))
8000cac0:	e0 6a 0d 2c 	mov	r10,3372
8000cac4:	e0 a0 10 2a 	rcall	8000eb18 <memory_2_ram>
8000cac8:	c5 a1       	brne	8000cb7c <fat_cluster_val+0x15c>
         fs_g_status = FS_ERR_HW;
         return false;
      }
   }
   // Valid sector cache
   fs_g_sectorcache.u8_lun = fs_g_nav.u8_lun;
8000caca:	0d 89       	ld.ub	r9,r6[0x0]
8000cacc:	e0 68 0f b4 	mov	r8,4020
8000cad0:	09 8a       	ld.ub	r10,r4[0x0]
8000cad2:	b0 89       	st.b	r8[0x0],r9
   fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + u32_offset_fat;   // Computed logical sector address
   if( !fat_cache_read_sector( true ))
      return false;

   // Read cluster information
   u8_ptr_cluster = &fs_g_sector[fs_g_u16_pos_fat];
8000cad4:	e0 68 0c fc 	mov	r8,3324
8000cad8:	90 0c       	ld.sh	r12,r8[0x0]
8000cada:	e5 dc c0 10 	bfextu	r2,r12,0x0,0x10
8000cade:	e2 02 00 02 	add	r2,r1,r2
   u8_data1 = u8_ptr_cluster[0];
   // Remark: if (fs_g_u16_pos_fat+1)=512 then it isn't a mistake, because this value will be erase in next lines
   u8_data2 = u8_ptr_cluster[1];
   u8_data3 = u8_ptr_cluster[2];
   u8_data4 = u8_ptr_cluster[3];
8000cae2:	e4 ce ff fd 	sub	lr,r2,-3
   if( !fat_cache_read_sector( true ))
      return false;

   // Read cluster information
   u8_ptr_cluster = &fs_g_sector[fs_g_u16_pos_fat];
   u8_data1 = u8_ptr_cluster[0];
8000cae6:	04 96       	mov	r6,r2
   // Remark: if (fs_g_u16_pos_fat+1)=512 then it isn't a mistake, because this value will be erase in next lines
   u8_data2 = u8_ptr_cluster[1];
   u8_data3 = u8_ptr_cluster[2];
8000cae8:	e4 c9 ff fe 	sub	r9,r2,-2
   if( !fat_cache_read_sector( true ))
      return false;

   // Read cluster information
   u8_ptr_cluster = &fs_g_sector[fs_g_u16_pos_fat];
   u8_data1 = u8_ptr_cluster[0];
8000caec:	0d 30       	ld.ub	r0,r6++
   // Remark: if (fs_g_u16_pos_fat+1)=512 then it isn't a mistake, because this value will be erase in next lines
   u8_data2 = u8_ptr_cluster[1];
   u8_data3 = u8_ptr_cluster[2];
   u8_data4 = u8_ptr_cluster[3];
8000caee:	50 2e       	stdsp	sp[0x8],lr
   // Read cluster information
   u8_ptr_cluster = &fs_g_sector[fs_g_u16_pos_fat];
   u8_data1 = u8_ptr_cluster[0];
   // Remark: if (fs_g_u16_pos_fat+1)=512 then it isn't a mistake, because this value will be erase in next lines
   u8_data2 = u8_ptr_cluster[1];
   u8_data3 = u8_ptr_cluster[2];
8000caf0:	13 8e       	ld.ub	lr,r9[0x0]

   // Read cluster information
   u8_ptr_cluster = &fs_g_sector[fs_g_u16_pos_fat];
   u8_data1 = u8_ptr_cluster[0];
   // Remark: if (fs_g_u16_pos_fat+1)=512 then it isn't a mistake, because this value will be erase in next lines
   u8_data2 = u8_ptr_cluster[1];
8000caf2:	0d 8b       	ld.ub	r11,r6[0x0]
   u8_data3 = u8_ptr_cluster[2];
8000caf4:	50 4e       	stdsp	sp[0x10],lr
   u8_data4 = u8_ptr_cluster[3];
8000caf6:	40 2e       	lddsp	lr,sp[0x8]
8000caf8:	1d 8e       	ld.ub	lr,lr[0x0]
8000cafa:	50 3e       	stdsp	sp[0xc],lr

   if ( Is_fat12 )
8000cafc:	30 1e       	mov	lr,1
8000cafe:	fc 0a 18 00 	cp.b	r10,lr
8000cb02:	c7 80       	breq	8000cbf2 <fat_cluster_val+0x1d2>
           return false;
         u8_data2 = fs_g_sector[0];
      }
   }

   if (false == b_mode)
8000cb04:	58 05       	cp.w	r5,0
8000cb06:	c1 91       	brne	8000cb38 <fat_cluster_val+0x118>
   {
      //**** Read the cluster value
      LSB0( fs_g_cluster.u32_val ) = u8_data1;  // FAT 12,16,32
8000cb08:	e0 68 0f cc 	mov	r8,4044
8000cb0c:	f0 ce ff f9 	sub	lr,r8,-7
8000cb10:	bc 80       	st.b	lr[0x0],r0
      LSB1( fs_g_cluster.u32_val ) = u8_data2;  // FAT 12,16,32
8000cb12:	f0 cc ff fa 	sub	r12,r8,-6
8000cb16:	b8 8b       	st.b	r12[0x0],r11
   }

   if (false == b_mode)
   {
      //**** Read the cluster value
      LSB0( fs_g_cluster.u32_val ) = u8_data1;  // FAT 12,16,32
8000cb18:	f0 c9 ff fc 	sub	r9,r8,-4
      LSB1( fs_g_cluster.u32_val ) = u8_data2;  // FAT 12,16,32

      if ( Is_fat32 )
8000cb1c:	30 3b       	mov	r11,3
8000cb1e:	f6 0a 18 00 	cp.b	r10,r11
8000cb22:	e0 80 00 d5 	breq	8000cccc <fat_cluster_val+0x2ac>
         LSB3( fs_g_cluster.u32_val ) = u8_data4 & 0x0F; // The high 4 bits are reserved
      }
      else
      {  // FAT 12 & 16 don't use the high bytes
         LSB2( fs_g_cluster.u32_val ) = 0;
         LSB3( fs_g_cluster.u32_val ) = 0;
8000cb26:	b2 85       	st.b	r9[0x0],r5
         LSB2( fs_g_cluster.u32_val ) = u8_data3;
         LSB3( fs_g_cluster.u32_val ) = u8_data4 & 0x0F; // The high 4 bits are reserved
      }
      else
      {  // FAT 12 & 16 don't use the high bytes
         LSB2( fs_g_cluster.u32_val ) = 0;
8000cb28:	b2 95       	st.b	r9[0x1],r5
         LSB3( fs_g_cluster.u32_val ) = 0;

         // FAT 12 translate 16bits value to 12bits
         if ( Is_fat12 )
8000cb2a:	30 19       	mov	r9,1
8000cb2c:	f2 0a 18 00 	cp.b	r10,r9
8000cb30:	c4 60       	breq	8000cbbc <fat_cluster_val+0x19c>
               LSB0( fs_g_cluster.u32_val ) = (LSB1( fs_g_cluster.u32_val ) <<4 ) + (LSB0( fs_g_cluster.u32_val ) >>4 );
               LSB1( fs_g_cluster.u32_val ) =  LSB1( fs_g_cluster.u32_val ) >>4 ;
            }
            else
            {  // Read cluster is EVEN
               LSB1( fs_g_cluster.u32_val ) &= 0x0F;
8000cb32:	30 1c       	mov	r12,1
      return false;
#endif  // FS_LEVEL_FEATURES
   }

   return true;
}
8000cb34:	2f bd       	sub	sp,-20
8000cb36:	d8 32       	popm	r0-r7,pc
         }
      }
   } else {
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
      //**** Write the cluster value
      if ( Is_fat12 )
8000cb38:	30 1c       	mov	r12,1
8000cb3a:	f8 0a 18 00 	cp.b	r10,r12
8000cb3e:	e0 80 00 90 	breq	8000cc5e <fat_cluster_val+0x23e>
         }
      }
      else
      {
         // FAT 16 & 32
         u8_data1 = LSB0( fs_g_cluster.u32_val );
8000cb42:	e0 68 0f cc 	mov	r8,4044
8000cb46:	30 3c       	mov	r12,3
8000cb48:	2f c8       	sub	r8,-4
         u8_data2 = LSB1( fs_g_cluster.u32_val );
8000cb4a:	11 b5       	ld.ub	r5,r8[0x3]
         if ( Is_fat32 )
8000cb4c:	11 ab       	ld.ub	r11,r8[0x2]
8000cb4e:	f8 0a 18 00 	cp.b	r10,r12
            u8_ptr_cluster[2] = LSB2( fs_g_cluster.u32_val );
            u8_ptr_cluster[3] = LSB3( fs_g_cluster.u32_val ) + (u8_data4 & 0xF0); // The high 4 bits are reserved
         }
      }
      // Here for FAT 32, 16 & 12 (only if the cluster values are in the same sector)
      u8_ptr_cluster[0] = u8_data1;
8000cb52:	c4 60       	breq	8000cbde <fat_cluster_val+0x1be>
      u8_ptr_cluster[1] = u8_data2;
8000cb54:	a4 85       	st.b	r2[0x0],r5

//! This function sets a flag to signal that sector cache is modified
//!
void  fat_cache_mark_sector_as_dirty( void )
{
   fs_g_sectorcache.u8_dirty = true;
8000cb56:	ac 8b       	st.b	r6[0x0],r11
8000cb58:	30 18       	mov	r8,1
8000cb5a:	30 1c       	mov	r12,1
8000cb5c:	ef 68 00 08 	st.b	r7[8],r8
      return false;
#endif  // FS_LEVEL_FEATURES
   }

   return true;
}
8000cb60:	2f bd       	sub	sp,-20
   if ( Is_fat32 )
   {
      // FAT 32
      // Optimization of -> u32_offset_fat = fs_g_cluster.pos * 4 / FS_CACHE_SIZE;
      // Optimization of -> u32_offset_fat = fs_g_cluster.pos / 128
      u32_offset_fat = fs_g_cluster.u32_pos >> (8-1);
8000cb62:	d8 32       	popm	r0-r7,pc

      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos * 4) % FS_CACHE_SIZE;
      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos % 128) * 4
      fs_g_u16_pos_fat = ((uint16_t)(LSB0(fs_g_cluster.u32_pos) & 0x7F))<< 2;
8000cb64:	e0 68 0f cc 	mov	r8,4044
8000cb68:	11 b9       	ld.ub	r9,r8[0x3]
8000cb6a:	70 0b       	ld.w	r11,r8[0x0]
8000cb6c:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
   if ( Is_fat32 )
   {
      // FAT 32
      // Optimization of -> u32_offset_fat = fs_g_cluster.pos * 4 / FS_CACHE_SIZE;
      // Optimization of -> u32_offset_fat = fs_g_cluster.pos / 128
      u32_offset_fat = fs_g_cluster.u32_pos >> (8-1);
8000cb70:	e0 68 0c fc 	mov	r8,3324

      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos * 4) % FS_CACHE_SIZE;
      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos % 128) * 4
      fs_g_u16_pos_fat = ((uint16_t)(LSB0(fs_g_cluster.u32_pos) & 0x7F))<< 2;
8000cb74:	a3 69       	lsl	r9,0x2
   if( b_load )
   {
      // Load the sector from memory
      if( CTRL_GOOD != memory_2_ram( fs_g_nav.u8_lun  , fs_g_sectorcache.u32_addr, fs_g_sector))
      {
         fs_g_status = FS_ERR_HW;
8000cb76:	a7 9b       	lsr	r11,0x7
8000cb78:	b0 09       	st.h	r8[0x0],r9
8000cb7a:	c6 9b       	rjmp	8000ca4c <fat_cluster_val+0x2c>
8000cb7c:	30 19       	mov	r9,1
      return false;
#endif  // FS_LEVEL_FEATURES
   }

   return true;
}
8000cb7e:	e0 68 0f 7c 	mov	r8,3964
   }
   else if ( Is_fat16 )
   {
      // FAT 16
      // Optimization of -> u32_offset_fat = fs_g_cluster.u32_pos * 2 / FS_CACHE_SIZE = fs_g_cluster.u32_pos / 256;
      u32_offset_fat = LSB1(fs_g_cluster.u32_pos);
8000cb82:	30 0c       	mov	r12,0
      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos * 2) % FS_CACHE_SIZE;
      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos % 256) * 2
      fs_g_u16_pos_fat = ((uint16_t)LSB0(fs_g_cluster.u32_pos)) <<1;
8000cb84:	b0 89       	st.b	r8[0x0],r9
8000cb86:	2f bd       	sub	sp,-20
8000cb88:	d8 32       	popm	r0-r7,pc
8000cb8a:	e0 68 0f cc 	mov	r8,4044
   }
   else if ( Is_fat16 )
   {
      // FAT 16
      // Optimization of -> u32_offset_fat = fs_g_cluster.u32_pos * 2 / FS_CACHE_SIZE = fs_g_cluster.u32_pos / 256;
      u32_offset_fat = LSB1(fs_g_cluster.u32_pos);
8000cb8e:	11 bb       	ld.ub	r11,r8[0x3]
   }
   else if ( Is_fat12 )
   {
      // FAT 12
      // Optimization of -> fs_g_u16_pos_fat = fs_g_cluster.u32_pos + (fs_g_cluster.u32_pos/ 2)
      fs_g_u16_pos_fat = (uint16_t)fs_g_cluster.u32_pos + ((uint16_t)fs_g_cluster.u32_pos >>1);
8000cb90:	a1 7b       	lsl	r11,0x1
8000cb92:	e0 69 0c fc 	mov	r9,3324
8000cb96:	b2 0b       	st.h	r9[0x0],r11
8000cb98:	11 ab       	ld.ub	r11,r8[0x2]
8000cb9a:	c5 9b       	rjmp	8000ca4c <fat_cluster_val+0x2c>
8000cb9c:	e0 68 0c fc 	mov	r8,3324
      // Optimization of -> u32_offset_fat = fs_g_cluster.u32_pos / FS_CACHE_SIZE
      u32_offset_fat = MSB(fs_g_u16_pos_fat) >> 1;
8000cba0:	e0 69 0f cc 	mov	r9,4044
      // Optimization of -> fs_g_u16_pos_fat = fs_g_u16_pos_fat % FS_CACHE_SIZE
      MSB( fs_g_u16_pos_fat ) &= 0x01;
8000cba4:	72 09       	ld.w	r9,r9[0x0]
   {
      // FAT 12
      // Optimization of -> fs_g_u16_pos_fat = fs_g_cluster.u32_pos + (fs_g_cluster.u32_pos/ 2)
      fs_g_u16_pos_fat = (uint16_t)fs_g_cluster.u32_pos + ((uint16_t)fs_g_cluster.u32_pos >>1);
      // Optimization of -> u32_offset_fat = fs_g_cluster.u32_pos / FS_CACHE_SIZE
      u32_offset_fat = MSB(fs_g_u16_pos_fat) >> 1;
8000cba6:	f7 d9 c0 2f 	bfextu	r11,r9,0x1,0xf
      // Optimization of -> fs_g_u16_pos_fat = fs_g_u16_pos_fat % FS_CACHE_SIZE
      MSB( fs_g_u16_pos_fat ) &= 0x01;
8000cbaa:	12 0b       	add	r11,r9
         LSB3( fs_g_cluster.u32_val ) = 0;

         // FAT 12 translate 16bits value to 12bits
         if ( Is_fat12 )
         {
            if ( 0x01 & LSB0(fs_g_cluster.u32_pos) )
8000cbac:	b0 0b       	st.h	r8[0x0],r11
8000cbae:	f7 db c1 08 	bfextu	r11,r11,0x8,0x8
8000cbb2:	f3 db c0 01 	bfextu	r9,r11,0x0,0x1
            {  // Read cluster is ODD
               LSB0( fs_g_cluster.u32_val ) = (LSB1( fs_g_cluster.u32_val ) <<4 ) + (LSB0( fs_g_cluster.u32_val ) >>4 );
8000cbb6:	a1 9b       	lsr	r11,0x1
               LSB1( fs_g_cluster.u32_val ) =  LSB1( fs_g_cluster.u32_val ) >>4 ;
8000cbb8:	b0 89       	st.b	r8[0x0],r9
8000cbba:	c4 9b       	rjmp	8000ca4c <fat_cluster_val+0x2c>
8000cbbc:	11 b8       	ld.ub	r8,r8[0x3]
         // FAT 12 translate 16bits value to 12bits
         if ( Is_fat12 )
         {
            if ( 0x01 & LSB0(fs_g_cluster.u32_pos) )
            {  // Read cluster is ODD
               LSB0( fs_g_cluster.u32_val ) = (LSB1( fs_g_cluster.u32_val ) <<4 ) + (LSB0( fs_g_cluster.u32_val ) >>4 );
8000cbbe:	ed b8 00 00 	bld	r8,0x0
               LSB1( fs_g_cluster.u32_val ) =  LSB1( fs_g_cluster.u32_val ) >>4 ;
8000cbc2:	e0 81 00 8d 	brne	8000ccdc <fat_cluster_val+0x2bc>
         // FAT 12 translate 16bits value to 12bits
         if ( Is_fat12 )
         {
            if ( 0x01 & LSB0(fs_g_cluster.u32_pos) )
            {  // Read cluster is ODD
               LSB0( fs_g_cluster.u32_val ) = (LSB1( fs_g_cluster.u32_val ) <<4 ) + (LSB0( fs_g_cluster.u32_val ) >>4 );
8000cbc6:	19 88       	ld.ub	r8,r12[0x0]
8000cbc8:	f0 09 16 04 	lsr	r9,r8,0x4
8000cbcc:	b8 89       	st.b	r12[0x0],r9
         // FAT 16 & 32
         u8_data1 = LSB0( fs_g_cluster.u32_val );
         u8_data2 = LSB1( fs_g_cluster.u32_val );
         if ( Is_fat32 )
         {  // FAT 32
            u8_ptr_cluster[2] = LSB2( fs_g_cluster.u32_val );
8000cbce:	a5 68       	lsl	r8,0x4
8000cbd0:	1d 89       	ld.ub	r9,lr[0x0]
            u8_ptr_cluster[3] = LSB3( fs_g_cluster.u32_val ) + (u8_data4 & 0xF0); // The high 4 bits are reserved
8000cbd2:	30 1c       	mov	r12,1
8000cbd4:	a5 89       	lsr	r9,0x4
8000cbd6:	f2 08 00 08 	add	r8,r9,r8
8000cbda:	bc 88       	st.b	lr[0x0],r8
8000cbdc:	cc 2b       	rjmp	8000cb60 <fat_cluster_val+0x140>
8000cbde:	11 9a       	ld.ub	r10,r8[0x1]
8000cbe0:	b2 8a       	st.b	r9[0x0],r10
   u8_data3 = u8_ptr_cluster[2];
   u8_data4 = u8_ptr_cluster[3];

   if ( Is_fat12 )
   {   // A cluster may be stored on two sectors
      if(  fs_g_u16_pos_fat == (FS_CACHE_SIZE-1) )
8000cbe2:	40 39       	lddsp	r9,sp[0xc]
8000cbe4:	e0 19 ff f0 	andl	r9,0xfff0
8000cbe8:	11 88       	ld.ub	r8,r8[0x0]
8000cbea:	12 08       	add	r8,r9
      {  // Go to next sector
         fs_gu32_addrsector++;
8000cbec:	40 29       	lddsp	r9,sp[0x8]
8000cbee:	b2 88       	st.b	r9[0x0],r8
         if( !fat_cache_read_sector( true ))
8000cbf0:	cb 2b       	rjmp	8000cb54 <fat_cluster_val+0x134>
8000cbf2:	e0 6e 01 ff 	mov	lr,511
8000cbf6:	fc 0c 19 00 	cp.h	r12,lr
8000cbfa:	c8 51       	brne	8000cb04 <fat_cluster_val+0xe4>
8000cbfc:	66 0a       	ld.w	r10,r3[0x0]
8000cbfe:	2f fa       	sub	r10,-1
           return false;
         u8_data2 = fs_g_sector[0];
8000cc00:	50 19       	stdsp	sp[0x4],r9
8000cc02:	50 08       	stdsp	sp[0x0],r8
8000cc04:	87 0a       	st.w	r3[0x0],r10
8000cc06:	c4 5e       	rcall	8000c890 <T.78>
bool  fat_cache_flush( void )
{
   // If the cache is modified, then write the sector cache on the device
   if ( true == fs_g_sectorcache.u8_dirty )
   {
      fs_g_sectorcache.u8_dirty = false; // Always clear, although an error occur
8000cc08:	40 19       	lddsp	r9,sp[0x4]
8000cc0a:	40 08       	lddsp	r8,sp[0x0]
8000cc0c:	c7 f0       	breq	8000cd0a <fat_cluster_val+0x2ea>
      if( mem_wr_protect( fs_g_sectorcache.u8_lun  ))
8000cc0e:	e0 6a 0d 2c 	mov	r10,3372
8000cc12:	15 8b       	ld.ub	r11,r10[0x0]
8000cc14:	09 8a       	ld.ub	r10,r4[0x0]
8000cc16:	c7 7b       	rjmp	8000cb04 <fat_cluster_val+0xe4>
8000cc18:	30 09       	mov	r9,0
8000cc1a:	f1 69 00 08 	st.b	r8[8],r9
      {
         fs_g_status = FS_LUN_WP;
8000cc1e:	11 8c       	ld.ub	r12,r8[0x0]
8000cc20:	50 08       	stdsp	sp[0x0],r8
8000cc22:	e0 a0 0f 73 	rcall	8000eb08 <mem_wr_protect>
      return false;
#endif  // FS_LEVEL_FEATURES
   }

   return true;
}
8000cc26:	40 08       	lddsp	r8,sp[0x0]
      {
         fs_g_u32_last_mod_fat = u32_offset_fat;
      }
      if ( Is_fat12 )
      {  // A cluster may be stored on two sectors
         if( fs_g_u16_pos_fat == (FS_CACHE_SIZE-1) )
8000cc28:	18 90       	mov	r0,r12
8000cc2a:	c4 40       	breq	8000ccb2 <fat_cluster_val+0x292>
8000cc2c:	31 49       	mov	r9,20
8000cc2e:	e0 68 0f 7c 	mov	r8,3964
8000cc32:	30 0c       	mov	r12,0
8000cc34:	b0 89       	st.b	r8[0x0],r9
8000cc36:	2f bd       	sub	sp,-20
         {  // Count the next FAT sector
            if( fs_g_u32_last_mod_fat < (u32_offset_fat+1) )
8000cc38:	d8 32       	popm	r0-r7,pc
8000cc3a:	e0 6c 0c fc 	mov	r12,3324
            {
               fs_g_u32_last_mod_fat = (u32_offset_fat+1);
8000cc3e:	98 0e       	ld.sh	lr,r12[0x0]
8000cc40:	e0 6c 01 ff 	mov	r12,511
8000cc44:	f8 0e 19 00 	cp.h	lr,r12
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
      //**** Write the cluster value
      if ( Is_fat12 )
      {
         // FAT 12, translate cluster value
         if ( 0x01 & LSB0(fs_g_cluster.u32_pos) )
8000cc48:	fe 91 ff 17 	brne	8000ca76 <fat_cluster_val+0x56>
8000cc4c:	f6 cc ff ff 	sub	r12,r11,-1
8000cc50:	10 3c       	cp.w	r12,r8
         {  // Cluster writing is ODD
            u8_data1 = (u8_data1 & 0x0F) + (LSB0( fs_g_cluster.u32_val )<<4);
            u8_data2 = (LSB1( fs_g_cluster.u32_val )<<4) + (LSB0( fs_g_cluster.u32_val )>>4) ;
         } else {
            // Cluster writing is EVEN
            u8_data1 = LSB0( fs_g_cluster.u32_val );
8000cc52:	f3 fc ba 00 	st.whi	r9[0x0],r12
            u8_data2 = (u8_data2 & 0xF0) + (LSB1( fs_g_cluster.u32_val ) & 0x0F) ;
8000cc56:	c1 0b       	rjmp	8000ca76 <fat_cluster_val+0x56>
8000cc58:	e0 61 0d 2c 	mov	r1,3372
8000cc5c:	c3 cb       	rjmp	8000cad4 <fat_cluster_val+0xb4>
8000cc5e:	e0 69 0f cc 	mov	r9,4044
8000cc62:	13 ba       	ld.ub	r10,r9[0x3]
         }

         // A cluster may be stored on two sectors
         if( fs_g_u16_pos_fat == (FS_CACHE_SIZE-1) )
8000cc64:	ed ba 00 00 	bld	r10,0x0
8000cc68:	c4 00       	breq	8000cce8 <fat_cluster_val+0x2c8>
8000cc6a:	2f c9       	sub	r9,-4
8000cc6c:	e2 1b 00 f0 	andl	r11,0xf0,COH
8000cc70:	13 aa       	ld.ub	r10,r9[0x2]
         {
            fs_g_sector[0] = u8_data2;
            fat_cache_mark_sector_as_dirty();
            // Go to previous sector
            fs_gu32_addrsector--;
8000cc72:	13 b5       	ld.ub	r5,r9[0x3]
8000cc74:	f5 da c0 04 	bfextu	r10,r10,0x0,0x4
         }

         // A cluster may be stored on two sectors
         if( fs_g_u16_pos_fat == (FS_CACHE_SIZE-1) )
         {
            fs_g_sector[0] = u8_data2;
8000cc78:	14 0b       	add	r11,r10
            fat_cache_mark_sector_as_dirty();
            // Go to previous sector
            fs_gu32_addrsector--;
8000cc7a:	5c 5b       	castu.b	r11

//! This function sets a flag to signal that sector cache is modified
//!
void  fat_cache_mark_sector_as_dirty( void )
{
   fs_g_sectorcache.u8_dirty = true;
8000cc7c:	90 09       	ld.sh	r9,r8[0x0]
8000cc7e:	e0 68 01 ff 	mov	r8,511
         {
            fs_g_sector[0] = u8_data2;
            fat_cache_mark_sector_as_dirty();
            // Go to previous sector
            fs_gu32_addrsector--;
            if( !fat_cache_read_sector( true ))
8000cc82:	f0 09 19 00 	cp.h	r9,r8
              return false;
            // Modify the previous sector
            fs_g_sector[ FS_CACHE_SIZE-1 ] = u8_data1;
8000cc86:	fe 91 ff 67 	brne	8000cb54 <fat_cluster_val+0x134>
8000cc8a:	66 08       	ld.w	r8,r3[0x0]
8000cc8c:	20 18       	sub	r8,1

//! This function sets a flag to signal that sector cache is modified
//!
void  fat_cache_mark_sector_as_dirty( void )
{
   fs_g_sectorcache.u8_dirty = true;
8000cc8e:	30 16       	mov	r6,1
8000cc90:	a2 8b       	st.b	r1[0x0],r11
8000cc92:	87 08       	st.w	r3[0x0],r8
            if( !fat_cache_read_sector( true ))
              return false;
            // Modify the previous sector
            fs_g_sector[ FS_CACHE_SIZE-1 ] = u8_data1;
            fat_cache_mark_sector_as_dirty();
            return true;
8000cc94:	ef 66 00 08 	st.b	r7[8],r6
      if( mem_wr_protect( fs_g_sectorcache.u8_lun  ))
      {
         fs_g_status = FS_LUN_WP;
         return false;
      }
      if (CTRL_GOOD != ram_2_memory( fs_g_sectorcache.u8_lun , fs_g_sectorcache.u32_addr , fs_g_sector ))
8000cc98:	fe b0 fd fc 	rcall	8000c890 <T.78>
8000cc9c:	c3 70       	breq	8000cd0a <fat_cluster_val+0x2ea>
8000cc9e:	e0 68 0d 2c 	mov	r8,3372
8000cca2:	30 1c       	mov	r12,1
      {
         fs_g_status = FS_ERR_HW;
8000cca4:	f1 65 01 ff 	st.b	r8[511],r5
8000cca8:	e0 68 0f b4 	mov	r8,4020
      LSB0( fs_g_cluster.u32_val ) = u8_data1;  // FAT 12,16,32
      LSB1( fs_g_cluster.u32_val ) = u8_data2;  // FAT 12,16,32

      if ( Is_fat32 )
      {  // FAT 32
         LSB2( fs_g_cluster.u32_val ) = u8_data3;
8000ccac:	f1 66 00 08 	st.b	r8[8],r6
8000ccb0:	c5 8b       	rjmp	8000cb60 <fat_cluster_val+0x140>
         LSB3( fs_g_cluster.u32_val ) = u8_data4 & 0x0F; // The high 4 bits are reserved
8000ccb2:	e0 61 0d 2c 	mov	r1,3372
8000ccb6:	11 8c       	ld.ub	r12,r8[0x0]
8000ccb8:	70 1b       	ld.w	r11,r8[0x4]
8000ccba:	02 9a       	mov	r10,r1
               LSB0( fs_g_cluster.u32_val ) = (LSB1( fs_g_cluster.u32_val ) <<4 ) + (LSB0( fs_g_cluster.u32_val ) >>4 );
               LSB1( fs_g_cluster.u32_val ) =  LSB1( fs_g_cluster.u32_val ) >>4 ;
            }
            else
            {  // Read cluster is EVEN
               LSB1( fs_g_cluster.u32_val ) &= 0x0F;
8000ccbc:	e0 a0 0f 38 	rcall	8000eb2c <ram_2_memory>
8000ccc0:	c2 20       	breq	8000cd04 <fat_cluster_val+0x2e4>
8000ccc2:	e0 68 0f 7c 	mov	r8,3964
8000ccc6:	00 9c       	mov	r12,r0
      if ( Is_fat12 )
      {
         // FAT 12, translate cluster value
         if ( 0x01 & LSB0(fs_g_cluster.u32_pos) )
         {  // Cluster writing is ODD
            u8_data1 = (u8_data1 & 0x0F) + (LSB0( fs_g_cluster.u32_val )<<4);
8000ccc8:	b0 82       	st.b	r8[0x0],r2
8000ccca:	c4 bb       	rjmp	8000cb60 <fat_cluster_val+0x140>
8000cccc:	40 4b       	lddsp	r11,sp[0x10]
            u8_data2 = (LSB1( fs_g_cluster.u32_val )<<4) + (LSB0( fs_g_cluster.u32_val )>>4) ;
8000ccce:	30 1c       	mov	r12,1
      if ( Is_fat12 )
      {
         // FAT 12, translate cluster value
         if ( 0x01 & LSB0(fs_g_cluster.u32_pos) )
         {  // Cluster writing is ODD
            u8_data1 = (u8_data1 & 0x0F) + (LSB0( fs_g_cluster.u32_val )<<4);
8000ccd0:	b2 9b       	st.b	r9[0x1],r11
            u8_data2 = (LSB1( fs_g_cluster.u32_val )<<4) + (LSB0( fs_g_cluster.u32_val )>>4) ;
8000ccd2:	40 3a       	lddsp	r10,sp[0xc]
8000ccd4:	f1 da c0 04 	bfextu	r8,r10,0x0,0x4
      if ( Is_fat12 )
      {
         // FAT 12, translate cluster value
         if ( 0x01 & LSB0(fs_g_cluster.u32_pos) )
         {  // Cluster writing is ODD
            u8_data1 = (u8_data1 & 0x0F) + (LSB0( fs_g_cluster.u32_val )<<4);
8000ccd8:	b2 88       	st.b	r9[0x0],r8
            u8_data2 = (LSB1( fs_g_cluster.u32_val )<<4) + (LSB0( fs_g_cluster.u32_val )>>4) ;
8000ccda:	c4 3b       	rjmp	8000cb60 <fat_cluster_val+0x140>
      if ( Is_fat12 )
      {
         // FAT 12, translate cluster value
         if ( 0x01 & LSB0(fs_g_cluster.u32_pos) )
         {  // Cluster writing is ODD
            u8_data1 = (u8_data1 & 0x0F) + (LSB0( fs_g_cluster.u32_val )<<4);
8000ccdc:	19 88       	ld.ub	r8,r12[0x0]
            u8_data2 = (LSB1( fs_g_cluster.u32_val )<<4) + (LSB0( fs_g_cluster.u32_val )>>4) ;
8000ccde:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
      if ( Is_fat12 )
      {
         // FAT 12, translate cluster value
         if ( 0x01 & LSB0(fs_g_cluster.u32_pos) )
         {  // Cluster writing is ODD
            u8_data1 = (u8_data1 & 0x0F) + (LSB0( fs_g_cluster.u32_val )<<4);
8000cce2:	b8 88       	st.b	r12[0x0],r8
      if( mem_wr_protect( fs_g_sectorcache.u8_lun  ))
      {
         fs_g_status = FS_LUN_WP;
         return false;
      }
      if (CTRL_GOOD != ram_2_memory( fs_g_sectorcache.u8_lun , fs_g_sectorcache.u32_addr , fs_g_sector ))
8000cce4:	30 1c       	mov	r12,1
8000cce6:	c2 7b       	rjmp	8000cb34 <fat_cluster_val+0x114>
8000cce8:	2f c9       	sub	r9,-4

//! This function sets a flag to signal that sector cache is modified
//!
void  fat_cache_mark_sector_as_dirty( void )
{
   fs_g_sectorcache.u8_dirty = true;
8000ccea:	eb d0 c0 04 	bfextu	r5,r0,0x0,0x4
8000ccee:	13 aa       	ld.ub	r10,r9[0x2]
8000ccf0:	13 b9       	ld.ub	r9,r9[0x3]
8000ccf2:	a5 6a       	lsl	r10,0x4
8000ccf4:	f2 0b 16 04 	lsr	r11,r9,0x4
8000ccf8:	a5 69       	lsl	r9,0x4
8000ccfa:	14 0b       	add	r11,r10
8000ccfc:	12 05       	add	r5,r9
8000ccfe:	5c 5b       	castu.b	r11
8000cd00:	5c 55       	castu.b	r5
8000cd02:	cb db       	rjmp	8000cc7c <fat_cluster_val+0x25c>
8000cd04:	66 0b       	ld.w	r11,r3[0x0]
8000cd06:	0d 8c       	ld.ub	r12,r6[0x0]
8000cd08:	cd 4a       	rjmp	8000cab0 <fat_cluster_val+0x90>
8000cd0a:	30 0c       	mov	r12,0
8000cd0c:	c2 ab       	rjmp	8000cb60 <fat_cluster_val+0x140>
8000cd0e:	d7 03       	nop

8000cd10 <fat_check_mount_select>:
8000cd10:	d4 31       	pushm	r0-r7,lr
8000cd12:	e0 68 0c fe 	mov	r8,3326
8000cd16:	11 89       	ld.ub	r9,r8[0x0]
8000cd18:	30 08       	mov	r8,0
8000cd1a:	f0 09 18 00 	cp.b	r9,r8
8000cd1e:	c4 01       	brne	8000cd9e <fat_check_mount_select+0x8e>
8000cd20:	e0 64 0f 2c 	mov	r4,3884
8000cd24:	3f f6       	mov	r6,-1
8000cd26:	09 89       	ld.ub	r9,r4[0x0]

   // Possibility to ignore the disk check. Used to take time during multi read/write access
   if( g_b_no_check_disk )
      return true;

   if( 0xFF == fs_g_nav.u8_lun )
8000cd28:	ec 09 18 00 	cp.b	r9,r6
   {
      fs_g_status = FS_ERR_HW;
8000cd2c:	c4 e0       	breq	8000cdc8 <fat_check_mount_select+0xb8>
      if( CTRL_GOOD       == status )
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
8000cd2e:	30 02       	mov	r2,0
      Fat_file_close();                            // By default the file is not open
8000cd30:	e0 65 0f 78 	mov	r5,3960
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
         }
      }
#endif
      // If the internal cache corresponding at device then clean it
      if( fs_g_nav.u8_lun == fs_g_sectorcache.u8_lun )
8000cd34:	04 97       	mov	r7,r2
   }

   for( retry=0 ; retry<100 ; retry++ )
   {
      // Check device
      status = mem_test_unit_ready( fs_g_nav.u8_lun );
8000cd36:	e0 60 0c ec 	mov	r0,3308
8000cd3a:	e0 61 0f 80 	mov	r1,3968
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
8000cd3e:	e0 63 0f b4 	mov	r3,4020

   for( retry=0 ; retry<100 ; retry++ )
   {
      // Check device
      status = mem_test_unit_ready( fs_g_nav.u8_lun );
      if( CTRL_GOOD       == status )
8000cd42:	12 9c       	mov	r12,r9
8000cd44:	e0 a0 0e d6 	rcall	8000eaf0 <mem_test_unit_ready>
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
      Fat_file_close();                            // By default the file is not open
8000cd48:	e0 68 0d 00 	mov	r8,3328
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
8000cd4c:	30 1a       	mov	r10,1
8000cd4e:	e0 6b 0f 7c 	mov	r11,3964
8000cd52:	58 0c       	cp.w	r12,0
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
         }
      }
#endif
      // If the internal cache corresponding at device then clean it
      if( fs_g_nav.u8_lun == fs_g_sectorcache.u8_lun )
8000cd54:	c2 70       	breq	8000cda2 <fat_check_mount_select+0x92>

//! This function resets the sector cache
//!
void  fat_cache_reset( void )
{
   fs_g_sectorcache.u8_lun                = FS_BUF_SECTOR_EMPTY;
8000cd56:	aa 87       	st.b	r5[0x0],r7
8000cd58:	a0 87       	st.b	r0[0x0],r7
8000cd5a:	09 89       	ld.ub	r9,r4[0x0]
8000cd5c:	03 8e       	ld.ub	lr,r1[0x0]
   fs_g_sectorcache.u8_dirty              = false;
8000cd5e:	f2 0e 18 00 	cp.b	lr,r9
   fs_g_sectorcache.u32_clusterlist_start = 0xFFFFFFFF;
8000cd62:	c3 e0       	breq	8000cdde <fat_check_mount_select+0xce>
8000cd64:	07 8e       	ld.ub	lr,r3[0x0]
8000cd66:	f2 0e 18 00 	cp.b	lr,r9
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
      fs_g_cache_clusterlist[u8_i].u8_level_use = 0xFF;
8000cd6a:	e7 f6 0e 00 	st.beq	r3[0x0],r6
      {
         fat_cache_reset();
      }
      fat_cache_clusterlist_reset();

      fs_g_status = FS_ERR_HW;                     // By default HW error
8000cd6e:	e7 f7 0e 08 	st.beq	r3[0x8],r7
//! This function resets the cluster list caches
//!
void  fat_cache_clusterlist_reset( void )
{
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
8000cd72:	f9 be 00 ff 	moveq	lr,-1
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
8000cd76:	e7 fe 0a 03 	st.weq	r3[0xc],lr
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
8000cd7a:	f1 66 00 15 	st.b	r8[21],r6
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
8000cd7e:	b6 8a       	st.b	r11[0x0],r10
8000cd80:	e0 6e 0f 7e 	mov	lr,3966
         fat_cache_reset();
      }
      fat_cache_clusterlist_reset();

      fs_g_status = FS_ERR_HW;                     // By default HW error
      if( CTRL_BUSY == status )
8000cd84:	bc 87       	st.b	lr[0x0],r7
         continue;                                 // If device busy then retry

      if( CTRL_NO_PRESENT == status )
8000cd86:	b0 8a       	st.b	r8[0x0],r10
8000cd88:	b0 a6       	st.b	r8[0x2],r6
//!
bool  fat_check_select( void )
{
   if (FS_NO_SEL == fs_g_nav_fast.u16_entry_pos_sel_file)
   {
      fs_g_status = FS_ERR_NO_FILE_SEL;
8000cd8a:	b0 96       	st.b	r8[0x1],r6
8000cd8c:	f1 67 00 14 	st.b	r8[20],r7
//!
bool  fat_check_mount( void )
{
   if( !fat_check_device() )
      return false;
   if (FS_TYPE_FAT_UNM == fs_g_nav_fast.u8_type_fat)
8000cd90:	f1 66 00 16 	st.b	r8[22],r6
8000cd94:	58 3c       	cp.w	r12,3
8000cd96:	c1 f0       	breq	8000cdd4 <fat_check_mount_select+0xc4>
//! @return    true  a file is selected
//! @return    false otherwise
//!
bool  fat_check_select( void )
{
   if (FS_NO_SEL == fs_g_nav_fast.u16_entry_pos_sel_file)
8000cd98:	58 2c       	cp.w	r12,2
8000cd9a:	c2 f0       	breq	8000cdf8 <fat_check_mount_select+0xe8>
8000cd9c:	d8 3a       	popm	r0-r7,pc,r12=0
8000cd9e:	e0 65 0f 78 	mov	r5,3960
8000cda2:	0b 89       	ld.ub	r9,r5[0x0]
{
   if( !fat_check_device() )
      return false;
   if (FS_TYPE_FAT_UNM == fs_g_nav_fast.u8_type_fat)
   {
      if( !fat_mount() )
8000cda4:	30 08       	mov	r8,0
8000cda6:	f0 09 18 00 	cp.b	r9,r8
      {
         fs_g_status = FS_ERR_NO_MOUNT;
8000cdaa:	c0 70       	breq	8000cdb8 <fat_check_mount_select+0xa8>
8000cdac:	8a 19       	ld.sh	r9,r5[0x2]
8000cdae:	3f f8       	mov	r8,-1
8000cdb0:	f0 09 19 00 	cp.h	r9,r8
   if( g_b_no_check_disk )
      return true;

   if( 0xFF == fs_g_nav.u8_lun )
   {
      fs_g_status = FS_ERR_HW;
8000cdb4:	c1 c0       	breq	8000cdec <fat_check_mount_select+0xdc>
8000cdb6:	da 3a       	popm	r0-r7,pc,r12=1
8000cdb8:	e0 a0 06 a0 	rcall	8000daf8 <fat_mount>
         fat_cache_reset();
      }
      fat_cache_clusterlist_reset();

      fs_g_status = FS_ERR_HW;                     // By default HW error
      if( CTRL_BUSY == status )
8000cdbc:	cf 81       	brne	8000cdac <fat_check_mount_select+0x9c>
   {
      fs_g_status = FS_ERR_HW;
      return false;                                // No device selected
   }

   for( retry=0 ; retry<100 ; retry++ )
8000cdbe:	30 e9       	mov	r9,14
8000cdc0:	e0 68 0f 7c 	mov	r8,3964
8000cdc4:	b0 89       	st.b	r8[0x0],r9
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
         {
            fs_g_navext_fast[i].u8_type_fat     = FS_TYPE_FAT_UNM;   // By default the fat isn't mounted
8000cdc6:	d8 32       	popm	r0-r7,pc
8000cdc8:	30 19       	mov	r9,1
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
8000cdca:	e0 68 0f 7c 	mov	r8,3964
8000cdce:	30 0c       	mov	r12,0
//!
bool  fat_check_select( void )
{
   if (FS_NO_SEL == fs_g_nav_fast.u16_entry_pos_sel_file)
   {
      fs_g_status = FS_ERR_NO_FILE_SEL;
8000cdd0:	b0 89       	st.b	r8[0x0],r9
8000cdd2:	d8 32       	popm	r0-r7,pc
8000cdd4:	2f f2       	sub	r2,-1
8000cdd6:	e0 42 00 64 	cp.w	r2,100
      fs_g_status = FS_ERR_HW;                     // By default HW error
      if( CTRL_BUSY == status )
         continue;                                 // If device busy then retry

      if( CTRL_NO_PRESENT == status )
         fs_g_status = FS_ERR_HW_NO_PRESENT;       // Update error flag
8000cdda:	cb 41       	brne	8000cd42 <fat_check_mount_select+0x32>
8000cddc:	ce 0b       	rjmp	8000cd9c <fat_check_mount_select+0x8c>
8000cdde:	e0 6e 0f 74 	mov	lr,3956
8000cde2:	bc 87       	st.b	lr[0x0],r7
8000cde4:	e0 6e 0f 64 	mov	lr,3940
8000cde8:	bc 87       	st.b	lr[0x0],r7
8000cdea:	cb db       	rjmp	8000cd64 <fat_check_mount_select+0x54>
8000cdec:	30 f9       	mov	r9,15
8000cdee:	e0 68 0f 7c 	mov	r8,3964
8000cdf2:	30 0c       	mov	r12,0
8000cdf4:	b0 89       	st.b	r8[0x0],r9
8000cdf6:	d8 32       	popm	r0-r7,pc
8000cdf8:	31 88       	mov	r8,24
8000cdfa:	30 0c       	mov	r12,0
8000cdfc:	b6 88       	st.b	r11[0x0],r8
8000cdfe:	d8 32       	popm	r0-r7,pc

8000ce00 <fat_check_mount_select_open>:
8000ce00:	d4 31       	pushm	r0-r7,lr
8000ce02:	e0 68 0c fe 	mov	r8,3326
8000ce06:	11 89       	ld.ub	r9,r8[0x0]
8000ce08:	30 08       	mov	r8,0
8000ce0a:	f0 09 18 00 	cp.b	r9,r8
8000ce0e:	c4 01       	brne	8000ce8e <fat_check_mount_select_open+0x8e>
8000ce10:	e0 64 0f 2c 	mov	r4,3884
8000ce14:	3f f6       	mov	r6,-1
8000ce16:	09 89       	ld.ub	r9,r4[0x0]

   // Possibility to ignore the disk check. Used to take time during multi read/write access
   if( g_b_no_check_disk )
      return true;

   if( 0xFF == fs_g_nav.u8_lun )
8000ce18:	ec 09 18 00 	cp.b	r9,r6
   {
      fs_g_status = FS_ERR_HW;
8000ce1c:	c5 b0       	breq	8000ced2 <fat_check_mount_select_open+0xd2>
      if( CTRL_GOOD       == status )
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
8000ce1e:	30 02       	mov	r2,0
      Fat_file_close();                            // By default the file is not open
8000ce20:	e0 65 0f 78 	mov	r5,3960
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
         }
      }
#endif
      // If the internal cache corresponding at device then clean it
      if( fs_g_nav.u8_lun == fs_g_sectorcache.u8_lun )
8000ce24:	04 97       	mov	r7,r2
   }

   for( retry=0 ; retry<100 ; retry++ )
   {
      // Check device
      status = mem_test_unit_ready( fs_g_nav.u8_lun );
8000ce26:	e0 60 0c ec 	mov	r0,3308
8000ce2a:	e0 61 0f 80 	mov	r1,3968
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
8000ce2e:	e0 63 0f b4 	mov	r3,4020

   for( retry=0 ; retry<100 ; retry++ )
   {
      // Check device
      status = mem_test_unit_ready( fs_g_nav.u8_lun );
      if( CTRL_GOOD       == status )
8000ce32:	12 9c       	mov	r12,r9
8000ce34:	e0 a0 0e 5e 	rcall	8000eaf0 <mem_test_unit_ready>
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
      Fat_file_close();                            // By default the file is not open
8000ce38:	e0 68 0d 00 	mov	r8,3328
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
8000ce3c:	30 1a       	mov	r10,1
8000ce3e:	e0 6b 0f 7c 	mov	r11,3964
8000ce42:	58 0c       	cp.w	r12,0
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
         }
      }
#endif
      // If the internal cache corresponding at device then clean it
      if( fs_g_nav.u8_lun == fs_g_sectorcache.u8_lun )
8000ce44:	c2 70       	breq	8000ce92 <fat_check_mount_select_open+0x92>

//! This function resets the sector cache
//!
void  fat_cache_reset( void )
{
   fs_g_sectorcache.u8_lun                = FS_BUF_SECTOR_EMPTY;
8000ce46:	aa 87       	st.b	r5[0x0],r7
8000ce48:	a0 87       	st.b	r0[0x0],r7
8000ce4a:	09 89       	ld.ub	r9,r4[0x0]
8000ce4c:	03 8e       	ld.ub	lr,r1[0x0]
   fs_g_sectorcache.u8_dirty              = false;
8000ce4e:	f2 0e 18 00 	cp.b	lr,r9
   fs_g_sectorcache.u32_clusterlist_start = 0xFFFFFFFF;
8000ce52:	c4 b0       	breq	8000cee8 <fat_check_mount_select_open+0xe8>
8000ce54:	07 8e       	ld.ub	lr,r3[0x0]
8000ce56:	f2 0e 18 00 	cp.b	lr,r9
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
      fs_g_cache_clusterlist[u8_i].u8_level_use = 0xFF;
8000ce5a:	e7 f6 0e 00 	st.beq	r3[0x0],r6
      {
         fat_cache_reset();
      }
      fat_cache_clusterlist_reset();

      fs_g_status = FS_ERR_HW;                     // By default HW error
8000ce5e:	e7 f7 0e 08 	st.beq	r3[0x8],r7
//! This function resets the cluster list caches
//!
void  fat_cache_clusterlist_reset( void )
{
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
8000ce62:	f9 be 00 ff 	moveq	lr,-1
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
8000ce66:	e7 fe 0a 03 	st.weq	r3[0xc],lr
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
8000ce6a:	f1 66 00 15 	st.b	r8[21],r6
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
8000ce6e:	b6 8a       	st.b	r11[0x0],r10
8000ce70:	e0 6e 0f 7e 	mov	lr,3966
         fat_cache_reset();
      }
      fat_cache_clusterlist_reset();

      fs_g_status = FS_ERR_HW;                     // By default HW error
      if( CTRL_BUSY == status )
8000ce74:	bc 87       	st.b	lr[0x0],r7
         continue;                                 // If device busy then retry

      if( CTRL_NO_PRESENT == status )
8000ce76:	b0 8a       	st.b	r8[0x0],r10
8000ce78:	b0 a6       	st.b	r8[0x2],r6
//!
bool  fat_check_open( void )
{
   if( Fat_file_isnot_open() )
   {
      fs_g_status = FS_ERR_FILE_NO_OPEN;
8000ce7a:	b0 96       	st.b	r8[0x1],r6
8000ce7c:	f1 67 00 14 	st.b	r8[20],r7
//!
bool  fat_check_mount( void )
{
   if( !fat_check_device() )
      return false;
   if (FS_TYPE_FAT_UNM == fs_g_nav_fast.u8_type_fat)
8000ce80:	f1 66 00 16 	st.b	r8[22],r6
8000ce84:	58 3c       	cp.w	r12,3
8000ce86:	c2 c0       	breq	8000cede <fat_check_mount_select_open+0xde>
//! @return    true  a file is selected
//! @return    false otherwise
//!
bool  fat_check_select( void )
{
   if (FS_NO_SEL == fs_g_nav_fast.u16_entry_pos_sel_file)
8000ce88:	58 2c       	cp.w	r12,2
8000ce8a:	c3 c0       	breq	8000cf02 <fat_check_mount_select_open+0x102>
8000ce8c:	d8 3a       	popm	r0-r7,pc,r12=0
8000ce8e:	e0 65 0f 78 	mov	r5,3960
//! @return    true  a file is opened
//! @return    false otherwise
//!
bool  fat_check_open( void )
{
   if( Fat_file_isnot_open() )
8000ce92:	0b 89       	ld.ub	r9,r5[0x0]
8000ce94:	30 08       	mov	r8,0
8000ce96:	f0 09 18 00 	cp.b	r9,r8
8000ce9a:	c1 30       	breq	8000cec0 <fat_check_mount_select_open+0xc0>
8000ce9c:	8a 19       	ld.sh	r9,r5[0x2]
   {
      fs_g_status = FS_ERR_FILE_NO_OPEN;
8000ce9e:	3f f8       	mov	r8,-1
8000cea0:	f0 09 19 00 	cp.h	r9,r8
8000cea4:	c2 90       	breq	8000cef6 <fat_check_mount_select_open+0xf6>
8000cea6:	e0 68 0c ec 	mov	r8,3308
{
   if( !fat_check_device() )
      return false;
   if (FS_TYPE_FAT_UNM == fs_g_nav_fast.u8_type_fat)
   {
      if( !fat_mount() )
8000ceaa:	11 89       	ld.ub	r9,r8[0x0]
8000ceac:	30 08       	mov	r8,0
      {
         fs_g_status = FS_ERR_NO_MOUNT;
8000ceae:	f0 09 18 00 	cp.b	r9,r8
8000ceb2:	c0 f1       	brne	8000ced0 <fat_check_mount_select_open+0xd0>
8000ceb4:	31 79       	mov	r9,23
//! @return    true  a file is opened
//! @return    false otherwise
//!
bool  fat_check_open( void )
{
   if( Fat_file_isnot_open() )
8000ceb6:	e0 68 0f 7c 	mov	r8,3964
   if( g_b_no_check_disk )
      return true;

   if( 0xFF == fs_g_nav.u8_lun )
   {
      fs_g_status = FS_ERR_HW;
8000ceba:	30 0c       	mov	r12,0
8000cebc:	b0 89       	st.b	r8[0x0],r9
8000cebe:	d8 32       	popm	r0-r7,pc
8000cec0:	e0 a0 06 1c 	rcall	8000daf8 <fat_mount>
      return false;                                // No device selected
   }

   for( retry=0 ; retry<100 ; retry++ )
8000cec4:	ce c1       	brne	8000ce9c <fat_check_mount_select_open+0x9c>
8000cec6:	30 e9       	mov	r9,14
8000cec8:	e0 68 0f 7c 	mov	r8,3964
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
         {
            fs_g_navext_fast[i].u8_type_fat     = FS_TYPE_FAT_UNM;   // By default the fat isn't mounted
8000cecc:	b0 89       	st.b	r8[0x0],r9
8000cece:	d8 32       	popm	r0-r7,pc
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
8000ced0:	da 3a       	popm	r0-r7,pc,r12=1
8000ced2:	30 19       	mov	r9,1
8000ced4:	e0 68 0f 7c 	mov	r8,3964
//!
bool  fat_check_select( void )
{
   if (FS_NO_SEL == fs_g_nav_fast.u16_entry_pos_sel_file)
   {
      fs_g_status = FS_ERR_NO_FILE_SEL;
8000ced8:	30 0c       	mov	r12,0
8000ceda:	b0 89       	st.b	r8[0x0],r9
8000cedc:	d8 32       	popm	r0-r7,pc
8000cede:	2f f2       	sub	r2,-1
      fs_g_status = FS_ERR_HW;                     // By default HW error
      if( CTRL_BUSY == status )
         continue;                                 // If device busy then retry

      if( CTRL_NO_PRESENT == status )
         fs_g_status = FS_ERR_HW_NO_PRESENT;       // Update error flag
8000cee0:	e0 42 00 64 	cp.w	r2,100
8000cee4:	ca 71       	brne	8000ce32 <fat_check_mount_select_open+0x32>
8000cee6:	cd 3b       	rjmp	8000ce8c <fat_check_mount_select_open+0x8c>
8000cee8:	e0 6e 0f 74 	mov	lr,3956
8000ceec:	bc 87       	st.b	lr[0x0],r7
8000ceee:	e0 6e 0f 64 	mov	lr,3940
8000cef2:	bc 87       	st.b	lr[0x0],r7
8000cef4:	cb 0b       	rjmp	8000ce54 <fat_check_mount_select_open+0x54>
8000cef6:	30 f9       	mov	r9,15
8000cef8:	e0 68 0f 7c 	mov	r8,3964
8000cefc:	30 0c       	mov	r12,0
8000cefe:	b0 89       	st.b	r8[0x0],r9
8000cf00:	d8 32       	popm	r0-r7,pc
8000cf02:	31 88       	mov	r8,24
8000cf04:	30 0c       	mov	r12,0
8000cf06:	b6 88       	st.b	r11[0x0],r8
8000cf08:	d8 32       	popm	r0-r7,pc
8000cf0a:	d7 03       	nop

8000cf0c <fat_check_mount_noopen>:
8000cf0c:	d4 31       	pushm	r0-r7,lr
8000cf0e:	e0 64 0c fe 	mov	r4,3326
8000cf12:	30 08       	mov	r8,0
8000cf14:	09 89       	ld.ub	r9,r4[0x0]
8000cf16:	f0 09 18 00 	cp.b	r9,r8
8000cf1a:	c4 11       	brne	8000cf9c <fat_check_mount_noopen+0x90>

   // Possibility to ignore the disk check. Used to take time during multi read/write access
   if( g_b_no_check_disk )
      return true;

   if( 0xFF == fs_g_nav.u8_lun )
8000cf1c:	e0 65 0f 2c 	mov	r5,3884
8000cf20:	3f f6       	mov	r6,-1
8000cf22:	0b 89       	ld.ub	r9,r5[0x0]
8000cf24:	ec 09 18 00 	cp.b	r9,r6
   {
      fs_g_status = FS_ERR_HW;
8000cf28:	e0 80 00 8b 	breq	8000d03e <fat_check_mount_noopen+0x132>
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
      Fat_file_close();                            // By default the file is not open
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
8000cf2c:	30 01       	mov	r1,0
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
         }
      }
#endif
      // If the internal cache corresponding at device then clean it
      if( fs_g_nav.u8_lun == fs_g_sectorcache.u8_lun )
8000cf2e:	e0 63 0f 78 	mov	r3,3960
   }

   for( retry=0 ; retry<100 ; retry++ )
   {
      // Check device
      status = mem_test_unit_ready( fs_g_nav.u8_lun );
8000cf32:	02 97       	mov	r7,r1
8000cf34:	e0 60 0f 80 	mov	r0,3968
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
8000cf38:	e0 62 0f b4 	mov	r2,4020

   for( retry=0 ; retry<100 ; retry++ )
   {
      // Check device
      status = mem_test_unit_ready( fs_g_nav.u8_lun );
      if( CTRL_GOOD       == status )
8000cf3c:	12 9c       	mov	r12,r9
8000cf3e:	e0 a0 0d d9 	rcall	8000eaf0 <mem_test_unit_ready>
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
8000cf42:	e0 68 0d 00 	mov	r8,3328
      Fat_file_close();                            // By default the file is not open
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
8000cf46:	30 1a       	mov	r10,1
8000cf48:	e0 6b 0f 7c 	mov	r11,3964
8000cf4c:	58 0c       	cp.w	r12,0
8000cf4e:	c2 90       	breq	8000cfa0 <fat_check_mount_noopen+0x94>
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
         }
      }
#endif
      // If the internal cache corresponding at device then clean it
      if( fs_g_nav.u8_lun == fs_g_sectorcache.u8_lun )
8000cf50:	e0 6e 0c ec 	mov	lr,3308

//! This function resets the sector cache
//!
void  fat_cache_reset( void )
{
   fs_g_sectorcache.u8_lun                = FS_BUF_SECTOR_EMPTY;
8000cf54:	a6 87       	st.b	r3[0x0],r7
8000cf56:	bc 87       	st.b	lr[0x0],r7
8000cf58:	0b 89       	ld.ub	r9,r5[0x0]
   fs_g_sectorcache.u8_dirty              = false;
8000cf5a:	01 8e       	ld.ub	lr,r0[0x0]
8000cf5c:	f2 0e 18 00 	cp.b	lr,r9
   fs_g_sectorcache.u32_clusterlist_start = 0xFFFFFFFF;
8000cf60:	c7 b0       	breq	8000d056 <fat_check_mount_noopen+0x14a>
8000cf62:	05 8e       	ld.ub	lr,r2[0x0]
8000cf64:	f2 0e 18 00 	cp.b	lr,r9
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
      fs_g_cache_clusterlist[u8_i].u8_level_use = 0xFF;
8000cf68:	e5 f6 0e 00 	st.beq	r2[0x0],r6
//! This function resets the cluster list caches
//!
void  fat_cache_clusterlist_reset( void )
{
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
8000cf6c:	e5 f7 0e 08 	st.beq	r2[0x8],r7
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
8000cf70:	f9 be 00 ff 	moveq	lr,-1
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
      fs_g_cache_clusterlist[u8_i].u8_level_use = 0xFF;
8000cf74:	e5 fe 0a 03 	st.weq	r2[0xc],lr
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
8000cf78:	f1 66 00 15 	st.b	r8[21],r6
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
8000cf7c:	b6 8a       	st.b	r11[0x0],r10
         fat_cache_reset();
      }
      fat_cache_clusterlist_reset();

      fs_g_status = FS_ERR_HW;                     // By default HW error
      if( CTRL_BUSY == status )
8000cf7e:	e0 6e 0f 7e 	mov	lr,3966
         continue;                                 // If device busy then retry

      if( CTRL_NO_PRESENT == status )
8000cf82:	bc 87       	st.b	lr[0x0],r7
8000cf84:	b0 8a       	st.b	r8[0x0],r10
      return true;
   if (FS_TYPE_FAT_UNM == fs_g_nav_fast.u8_type_fat)
      return true;
   if( Fat_file_is_open() )
   {
      fs_g_status = FS_ERR_TOO_FILE_OPEN;  // The navigation have already open a file
8000cf86:	b0 a6       	st.b	r8[0x2],r6
8000cf88:	b0 96       	st.b	r8[0x1],r6
//!
bool  fat_check_mount( void )
{
   if( !fat_check_device() )
      return false;
   if (FS_TYPE_FAT_UNM == fs_g_nav_fast.u8_type_fat)
8000cf8a:	f1 67 00 14 	st.b	r8[20],r7
8000cf8e:	f1 66 00 16 	st.b	r8[22],r6
8000cf92:	58 3c       	cp.w	r12,3
   uint8_t i;
#endif
   Ctrl_status status;

   // Possibility to ignore the disk check. Used to take time during multi read/write access
   if( g_b_no_check_disk )
8000cf94:	c5 b0       	breq	8000d04a <fat_check_mount_noopen+0x13e>
8000cf96:	58 2c       	cp.w	r12,2
8000cf98:	c7 70       	breq	8000d086 <fat_check_mount_noopen+0x17a>
8000cf9a:	d8 3a       	popm	r0-r7,pc,r12=0
8000cf9c:	e0 63 0f 78 	mov	r3,3960
      return true;

   if( 0xFF == fs_g_nav.u8_lun )
8000cfa0:	07 89       	ld.ub	r9,r3[0x0]
8000cfa2:	30 08       	mov	r8,0
8000cfa4:	f0 09 18 00 	cp.b	r9,r8
8000cfa8:	c4 30       	breq	8000d02e <fat_check_mount_noopen+0x122>
   {
      fs_g_status = FS_ERR_HW;
8000cfaa:	09 89       	ld.ub	r9,r4[0x0]
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
      Fat_file_close();                            // By default the file is not open
8000cfac:	30 08       	mov	r8,0
      if( CTRL_GOOD       == status )
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
8000cfae:	f0 09 18 00 	cp.b	r9,r8
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
         }
      }
#endif
      // If the internal cache corresponding at device then clean it
      if( fs_g_nav.u8_lun == fs_g_sectorcache.u8_lun )
8000cfb2:	c5 91       	brne	8000d064 <fat_check_mount_noopen+0x158>
   }

   for( retry=0 ; retry<100 ; retry++ )
   {
      // Check device
      status = mem_test_unit_ready( fs_g_nav.u8_lun );
8000cfb4:	e0 65 0f 2c 	mov	r5,3884
8000cfb8:	3f f6       	mov	r6,-1
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
8000cfba:	0b 89       	ld.ub	r9,r5[0x0]
8000cfbc:	ec 09 18 00 	cp.b	r9,r6

   for( retry=0 ; retry<100 ; retry++ )
   {
      // Check device
      status = mem_test_unit_ready( fs_g_nav.u8_lun );
      if( CTRL_GOOD       == status )
8000cfc0:	c7 70       	breq	8000d0ae <fat_check_mount_noopen+0x1a2>
8000cfc2:	30 02       	mov	r2,0
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
8000cfc4:	e0 60 0c ec 	mov	r0,3308
      Fat_file_close();                            // By default the file is not open
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
8000cfc8:	04 97       	mov	r7,r2
8000cfca:	e0 61 0f 80 	mov	r1,3968
8000cfce:	e0 64 0f b4 	mov	r4,4020
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
         }
      }
#endif
      // If the internal cache corresponding at device then clean it
      if( fs_g_nav.u8_lun == fs_g_sectorcache.u8_lun )
8000cfd2:	12 9c       	mov	r12,r9

//! This function resets the sector cache
//!
void  fat_cache_reset( void )
{
   fs_g_sectorcache.u8_lun                = FS_BUF_SECTOR_EMPTY;
8000cfd4:	e0 a0 0d 8e 	rcall	8000eaf0 <mem_test_unit_ready>
8000cfd8:	e0 68 0d 00 	mov	r8,3328
   fs_g_sectorcache.u8_dirty              = false;
8000cfdc:	30 1a       	mov	r10,1
8000cfde:	e0 6b 0f 7c 	mov	r11,3964
   fs_g_sectorcache.u32_clusterlist_start = 0xFFFFFFFF;
8000cfe2:	58 0c       	cp.w	r12,0
8000cfe4:	c4 00       	breq	8000d064 <fat_check_mount_noopen+0x158>
8000cfe6:	a6 87       	st.b	r3[0x0],r7
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
      fs_g_cache_clusterlist[u8_i].u8_level_use = 0xFF;
8000cfe8:	a0 87       	st.b	r0[0x0],r7
8000cfea:	0b 89       	ld.ub	r9,r5[0x0]
      {
         fat_cache_reset();
      }
      fat_cache_clusterlist_reset();

      fs_g_status = FS_ERR_HW;                     // By default HW error
8000cfec:	03 8e       	ld.ub	lr,r1[0x0]
//! This function resets the cluster list caches
//!
void  fat_cache_clusterlist_reset( void )
{
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
8000cfee:	f2 0e 18 00 	cp.b	lr,r9
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
8000cff2:	c5 30       	breq	8000d098 <fat_check_mount_noopen+0x18c>
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
8000cff4:	09 8e       	ld.ub	lr,r4[0x0]
      fs_g_cache_clusterlist[u8_i].u8_level_use = 0xFF;
8000cff6:	f2 0e 18 00 	cp.b	lr,r9
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
8000cffa:	e9 f6 0e 00 	st.beq	r4[0x0],r6
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
8000cffe:	e9 f7 0e 08 	st.beq	r4[0x8],r7
         fat_cache_reset();
      }
      fat_cache_clusterlist_reset();

      fs_g_status = FS_ERR_HW;                     // By default HW error
      if( CTRL_BUSY == status )
8000d002:	f9 be 00 ff 	moveq	lr,-1
         continue;                                 // If device busy then retry

      if( CTRL_NO_PRESENT == status )
8000d006:	e9 fe 0a 03 	st.weq	r4[0xc],lr
{
   if( !fat_check_device() )
      return false;
   if (FS_TYPE_FAT_UNM == fs_g_nav_fast.u8_type_fat)
   {
      if( !fat_mount() )
8000d00a:	f1 66 00 15 	st.b	r8[21],r6
8000d00e:	b6 8a       	st.b	r11[0x0],r10
      {
         fs_g_status = FS_ERR_NO_MOUNT;
8000d010:	e0 6e 0f 7e 	mov	lr,3966
8000d014:	bc 87       	st.b	lr[0x0],r7
8000d016:	b0 8a       	st.b	r8[0x0],r10
   if( g_b_no_check_disk )
      return true;

   if( 0xFF == fs_g_nav.u8_lun )
   {
      fs_g_status = FS_ERR_HW;
8000d018:	b0 a6       	st.b	r8[0x2],r6
8000d01a:	b0 96       	st.b	r8[0x1],r6
8000d01c:	f1 67 00 14 	st.b	r8[20],r7
8000d020:	f1 66 00 16 	st.b	r8[22],r6
      return false;                                // No device selected
   }

   for( retry=0 ; retry<100 ; retry++ )
8000d024:	58 3c       	cp.w	r12,3
8000d026:	c3 40       	breq	8000d08e <fat_check_mount_noopen+0x182>
8000d028:	58 2c       	cp.w	r12,2
8000d02a:	c3 e0       	breq	8000d0a6 <fat_check_mount_noopen+0x19a>
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
         {
            fs_g_navext_fast[i].u8_type_fat     = FS_TYPE_FAT_UNM;   // By default the fat isn't mounted
8000d02c:	da 3a       	popm	r0-r7,pc,r12=1
8000d02e:	e0 a0 05 65 	rcall	8000daf8 <fat_mount>
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
8000d032:	cb c1       	brne	8000cfaa <fat_check_mount_noopen+0x9e>
8000d034:	30 e9       	mov	r9,14
//!
bool  fat_check_noopen( void )
{
   if( !fat_check_device() )
      return true;
   if (FS_TYPE_FAT_UNM == fs_g_nav_fast.u8_type_fat)
8000d036:	e0 68 0f 7c 	mov	r8,3964
8000d03a:	b0 89       	st.b	r8[0x0],r9
8000d03c:	d8 32       	popm	r0-r7,pc
8000d03e:	30 19       	mov	r9,1
      return true;
   if( Fat_file_is_open() )
8000d040:	e0 68 0f 7c 	mov	r8,3964
8000d044:	30 0c       	mov	r12,0
8000d046:	b0 89       	st.b	r8[0x0],r9
8000d048:	d8 32       	popm	r0-r7,pc
   {
      fs_g_status = FS_ERR_TOO_FILE_OPEN;  // The navigation have already open a file
8000d04a:	2f f1       	sub	r1,-1
8000d04c:	e0 41 00 64 	cp.w	r1,100
8000d050:	fe 91 ff 76 	brne	8000cf3c <fat_check_mount_noopen+0x30>
      fs_g_status = FS_ERR_HW;                     // By default HW error
      if( CTRL_BUSY == status )
         continue;                                 // If device busy then retry

      if( CTRL_NO_PRESENT == status )
         fs_g_status = FS_ERR_HW_NO_PRESENT;       // Update error flag
8000d054:	ca 3b       	rjmp	8000cf9a <fat_check_mount_noopen+0x8e>
8000d056:	e0 6e 0f 74 	mov	lr,3956
8000d05a:	bc 87       	st.b	lr[0x0],r7
         fat_cache_reset();
      }
      fat_cache_clusterlist_reset();

      fs_g_status = FS_ERR_HW;                     // By default HW error
      if( CTRL_BUSY == status )
8000d05c:	e0 6e 0f 64 	mov	lr,3940
   {
      fs_g_status = FS_ERR_HW;
      return false;                                // No device selected
   }

   for( retry=0 ; retry<100 ; retry++ )
8000d060:	bc 87       	st.b	lr[0x0],r7
8000d062:	c8 0b       	rjmp	8000cf62 <fat_check_mount_noopen+0x56>
8000d064:	07 89       	ld.ub	r9,r3[0x0]
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
         {
            fs_g_navext_fast[i].u8_type_fat     = FS_TYPE_FAT_UNM;   // By default the fat isn't mounted
8000d066:	30 08       	mov	r8,0
8000d068:	f0 09 18 00 	cp.b	r9,r8
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
8000d06c:	ce 00       	breq	8000d02c <fat_check_mount_noopen+0x120>
8000d06e:	e0 69 0c ec 	mov	r9,3308
      fs_g_status = FS_ERR_HW;                     // By default HW error
      if( CTRL_BUSY == status )
         continue;                                 // If device busy then retry

      if( CTRL_NO_PRESENT == status )
         fs_g_status = FS_ERR_HW_NO_PRESENT;       // Update error flag
8000d072:	13 89       	ld.ub	r9,r9[0x0]
8000d074:	f0 09 18 00 	cp.b	r9,r8
   if( g_b_no_check_disk )
      return true;

   if( 0xFF == fs_g_nav.u8_lun )
   {
      fs_g_status = FS_ERR_HW;
8000d078:	cd a0       	breq	8000d02c <fat_check_mount_noopen+0x120>
8000d07a:	30 59       	mov	r9,5
8000d07c:	e0 68 0f 7c 	mov	r8,3964
8000d080:	30 0c       	mov	r12,0
8000d082:	b0 89       	st.b	r8[0x0],r9
8000d084:	d8 32       	popm	r0-r7,pc
8000d086:	31 88       	mov	r8,24
8000d088:	30 0c       	mov	r12,0
8000d08a:	b6 88       	st.b	r11[0x0],r8
8000d08c:	d8 32       	popm	r0-r7,pc
8000d08e:	2f f2       	sub	r2,-1
8000d090:	e0 42 00 64 	cp.w	r2,100
8000d094:	c9 f1       	brne	8000cfd2 <fat_check_mount_noopen+0xc6>
8000d096:	cc bb       	rjmp	8000d02c <fat_check_mount_noopen+0x120>
8000d098:	e0 6e 0f 74 	mov	lr,3956
8000d09c:	bc 87       	st.b	lr[0x0],r7
8000d09e:	e0 6e 0f 64 	mov	lr,3940
8000d0a2:	bc 87       	st.b	lr[0x0],r7
8000d0a4:	ca 8b       	rjmp	8000cff4 <fat_check_mount_noopen+0xe8>
8000d0a6:	31 88       	mov	r8,24
8000d0a8:	30 1c       	mov	r12,1
8000d0aa:	b6 88       	st.b	r11[0x0],r8
8000d0ac:	d8 32       	popm	r0-r7,pc
8000d0ae:	30 19       	mov	r9,1
8000d0b0:	e0 68 0f 7c 	mov	r8,3964
8000d0b4:	30 1c       	mov	r12,1
8000d0b6:	b0 89       	st.b	r8[0x0],r9
8000d0b8:	d8 32       	popm	r0-r7,pc
8000d0ba:	d7 03       	nop

8000d0bc <fat_cluster_list>:
//!   fs_g_seg.u32_addr          The memory segment address corresponding at the beginning of cluster list (only for action FS_CLUST_ACT_SEG & FS_CLUST_ACT_ONE)
//!   fs_g_seg.u32_size_or_pos   The memory segment size corresponding at cluster list read or cleared (unit 512B)
//! @endverbatim
//!
bool  fat_cluster_list( uint8_t opt_action, bool b_for_file )
{
8000d0bc:	d4 31       	pushm	r0-r7,lr
8000d0be:	20 9d       	sub	sp,36
   _MEM_TYPE_FAST_ uint32_t u32_tmp;
   _MEM_TYPE_FAST_ uint8_t u8_cluster_status;

   fs_g_status = FS_ERR_FS;      // By default system error
8000d0c0:	30 88       	mov	r8,8
8000d0c2:	e0 6e 0f 7c 	mov	lr,3964
8000d0c6:	bc 88       	st.b	lr[0x0],r8

   if(  Is_fat32
   &&  (FS_CLUST_ACT_CLR == opt_action) )
8000d0c8:	30 38       	mov	r8,3
8000d0ca:	f0 0c 18 00 	cp.b	r12,r8
8000d0ce:	5f 0a       	sreq	r10
8000d0d0:	50 3a       	stdsp	sp[0xc],r10
   _MEM_TYPE_FAST_ uint32_t u32_tmp;
   _MEM_TYPE_FAST_ uint8_t u8_cluster_status;

   fs_g_status = FS_ERR_FS;      // By default system error

   if(  Is_fat32
8000d0d2:	e0 63 0f 78 	mov	r3,3960
//!   fs_g_seg.u32_addr          The memory segment address corresponding at the beginning of cluster list (only for action FS_CLUST_ACT_SEG & FS_CLUST_ACT_ONE)
//!   fs_g_seg.u32_size_or_pos   The memory segment size corresponding at cluster list read or cleared (unit 512B)
//! @endverbatim
//!
bool  fat_cluster_list( uint8_t opt_action, bool b_for_file )
{
8000d0d6:	18 94       	mov	r4,r12
   _MEM_TYPE_FAST_ uint32_t u32_tmp;
   _MEM_TYPE_FAST_ uint8_t u8_cluster_status;

   fs_g_status = FS_ERR_FS;      // By default system error

   if(  Is_fat32
8000d0d8:	07 89       	ld.ub	r9,r3[0x0]
8000d0da:	f0 09 18 00 	cp.b	r9,r8
8000d0de:	5f 08       	sreq	r8
8000d0e0:	f5 e8 00 08 	and	r8,r10,r8
8000d0e4:	e0 81 01 a0 	brne	8000d424 <fat_cluster_list+0x368>
#else
      return false;
#endif
   }

   if ( 0 == fs_g_seg.u32_addr )
8000d0e8:	e0 66 0f d4 	mov	r6,4052
8000d0ec:	6c 08       	ld.w	r8,r6[0x0]
8000d0ee:	58 08       	cp.w	r8,0
8000d0f0:	c7 c0       	breq	8000d1e8 <fat_cluster_list+0x12c>
         // For FAT 32, the root is a cluster list and the first cluster is reading during the mount
         fs_g_cluster.u32_pos = fs_g_nav.rootdir.u32_cluster;
      }
   } else {
      // It is the first cluster of a cluster list
      fs_g_cluster.u32_pos = fs_g_seg.u32_addr;
8000d0f2:	e0 67 0f cc 	mov	r7,4044
8000d0f6:	8f 08       	st.w	r7[0x0],r8
   }

   // Management of cluster list caches
   if( FS_CLUST_ACT_CLR != opt_action )
8000d0f8:	30 39       	mov	r9,3
8000d0fa:	f2 04 18 00 	cp.b	r4,r9
8000d0fe:	e0 81 02 07 	brne	8000d50c <fat_cluster_list+0x450>
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
8000d102:	e0 6c 0d 00 	mov	r12,3328
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
8000d106:	3f f8       	mov	r8,-1
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
8000d108:	50 4c       	stdsp	sp[0x10],r12
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
      fs_g_cache_clusterlist[u8_i].u8_level_use = 0xFF;
8000d10a:	f9 68 00 15 	st.b	r12[21],r8
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
8000d10e:	b8 a8       	st.b	r12[0x2],r8
      fs_g_cache_clusterlist[u8_i].u8_level_use = 0xFF;
8000d110:	b8 98       	st.b	r12[0x1],r8
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
8000d112:	f9 68 00 16 	st.b	r12[22],r8
//! This function resets the cluster list caches
//!
void  fat_cache_clusterlist_reset( void )
{
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
8000d116:	30 08       	mov	r8,0
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
8000d118:	f9 68 00 14 	st.b	r12[20],r8
//! This function resets the cluster list caches
//!
void  fat_cache_clusterlist_reset( void )
{
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
8000d11c:	e0 6b 0f 7e 	mov	r11,3966
8000d120:	b6 88       	st.b	r11[0x0],r8
8000d122:	50 6b       	stdsp	sp[0x18],r11
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
8000d124:	30 18       	mov	r8,1
8000d126:	b8 88       	st.b	r12[0x0],r8
         return true;            // Segment found in cache
      // Segment not found & cache ready to update
   }else{
      fat_cache_clusterlist_reset();   // It is a clear action then clear cluster list caches
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
      fat_clear_info_fat_mod();        // Init cache on fat modification range
8000d128:	e0 a0 04 6a 	rcall	8000d9fc <fat_clear_info_fat_mod>
8000d12c:	e0 65 0f 2c 	mov	r5,3884
8000d130:	0b 99       	ld.ub	r9,r5[0x1]
#endif  // FS_LEVEL_FEATURES
   }

   // Init loop with a start segment no found
   MSB0( fs_g_seg.u32_addr ) = 0xFF;
8000d132:	3f f8       	mov	r8,-1
8000d134:	6c 1a       	ld.w	r10,r6[0x4]
8000d136:	ac 88       	st.b	r6[0x0],r8
//! @endverbatim
//!
bool  fat_cluster_readnext( void )
{
   // Compute the next cluster position in FAT
   if ( Is_fat32 )
8000d138:	30 32       	mov	r2,3
            // Send a size of one sector
            fs_g_seg.u32_size_or_pos = 1;
            return true;
         }
         // Update the segment size
         fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus - LSB0( fs_g_seg.u32_size_or_pos );
8000d13a:	e0 68 0f d4 	mov	r8,4052
8000d13e:	2f 98       	sub	r8,-7
8000d140:	50 28       	stdsp	sp[0x8],r8
   MSB0( fs_g_seg.u32_addr ) = 0xFF;

   //**** Loop to read the cluster list
   while ( 1 )
   {
      if ( fs_g_seg.u32_size_or_pos < fs_g_nav.u8_BPB_SecPerClus )
8000d142:	14 39       	cp.w	r9,r10
8000d144:	e0 88 00 21 	brls	8000d186 <fat_cluster_list+0xca>
      {
         // The segment starts in this cluster
         // Compute the sector address of this cluster
         fs_g_seg.u32_addr = ((fs_g_cluster.u32_pos - 2) * fs_g_nav.u8_BPB_SecPerClus)
8000d148:	6a 5c       	ld.w	r12,r5[0x14]
8000d14a:	6a 4b       	ld.w	r11,r5[0x10]
8000d14c:	f8 0b 00 0b 	add	r11,r12,r11
8000d150:	6e 08       	ld.w	r8,r7[0x0]
8000d152:	f6 0a 00 0a 	add	r10,r11,r10
8000d156:	f0 cb 00 02 	sub	r11,r8,2
8000d15a:	f2 0b 03 4a 	mac	r10,r9,r11
8000d15e:	8d 0a       	st.w	r6[0x0],r10
8000d160:	e0 61 0f d4 	mov	r1,4052
                           + fs_g_nav.u32_ptr_fat + fs_g_nav.u32_offset_data + fs_g_seg.u32_size_or_pos;

         if ( FS_CLUST_ACT_ONE == opt_action )
8000d164:	30 2a       	mov	r10,2
8000d166:	f4 04 18 00 	cp.b	r4,r10
8000d16a:	e0 80 01 fc 	breq	8000d562 <fat_cluster_list+0x4a6>
            // Send a size of one sector
            fs_g_seg.u32_size_or_pos = 1;
            return true;
         }
         // Update the segment size
         fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus - LSB0( fs_g_seg.u32_size_or_pos );
8000d16e:	40 2c       	lddsp	r12,sp[0x8]
8000d170:	e0 6b 0f d4 	mov	r11,4052
8000d174:	19 8a       	ld.ub	r10,r12[0x0]
8000d176:	f2 0a 01 0e 	sub	lr,r9,r10
8000d17a:	97 1e       	st.w	r11[0x4],lr

         // Take time, during read cluster list on FAT 16 & 32
         if( (FS_CLUST_ACT_SEG == opt_action)
8000d17c:	30 19       	mov	r9,1
8000d17e:	f2 04 18 00 	cp.b	r4,r9
8000d182:	e0 80 00 a7 	breq	8000d2d0 <fat_cluster_list+0x214>
                  return false;
            }
         }
      }
      // Get the cluster value
      if( !fat_cluster_val( FS_CLUST_VAL_READ ))
8000d186:	30 0c       	mov	r12,0
8000d188:	fe b0 fc 4c 	rcall	8000ca20 <fat_cluster_val>
8000d18c:	c7 00       	breq	8000d26c <fat_cluster_list+0x1b0>
//!   fs_g_cluster.u32_val       value to check
//! @endverbatim
//!
uint8_t    fat_checkcluster( void )
{
  if ( !fs_g_cluster.u32_val )
8000d18e:	6e 18       	ld.w	r8,r7[0x4]
8000d190:	58 08       	cp.w	r8,0
8000d192:	c6 d0       	breq	8000d26c <fat_cluster_list+0x1b0>
    return FS_CLUS_BAD;

  // Cluster bad if (FAT12 == 0x0FF7) (FAT16 == 0xFFF7) (FAT32 == 0x0FFFFFF7)
  // Last cluster if (FAT12 > 0x0FF7) (FAT16 > 0xFFF7) (FAT32 > 0x0FFFFFF7)
  if ( Is_fat32 )
8000d194:	07 89       	ld.ub	r9,r3[0x0]
8000d196:	e4 09 18 00 	cp.b	r9,r2
8000d19a:	e0 80 00 91 	breq	8000d2bc <fat_cluster_list+0x200>
    if (fs_g_cluster.u32_val >= 0x0FFFFFF8)
      return FS_CLUS_END;
    else if (fs_g_cluster.u32_val == 0x0FFFFFF7)
      return FS_CLUS_BAD;
  }
  else if ( Is_fat16 )
8000d19e:	30 2a       	mov	r10,2
8000d1a0:	f4 09 18 00 	cp.b	r9,r10
8000d1a4:	e0 80 01 39 	breq	8000d416 <fat_cluster_list+0x35a>
    if (fs_g_cluster.u32_val >= 0xFFF8)
      return FS_CLUS_END;
    else if (fs_g_cluster.u32_val == 0xFFF7)
      return FS_CLUS_BAD;
  }
  else if ( Is_fat12 )
8000d1a8:	30 1a       	mov	r10,1
8000d1aa:	f4 09 18 00 	cp.b	r9,r10
8000d1ae:	c5 a0       	breq	8000d262 <fat_cluster_list+0x1a6>
         fs_g_seg.u32_size_or_pos += fs_g_nav.u8_BPB_SecPerClus;
      }
      // HERE, Continue to read the cluster list
      // The next cluster is the value of previous cluster
      fs_g_cluster.u32_pos = fs_g_cluster.u32_val;
   }  // End of main loop
8000d1b0:	30 01       	mov	r1,0
      // Read and check the status of the new cluster
      u8_cluster_status = fat_checkcluster();
      if (FS_CLUS_BAD == u8_cluster_status)
         return false; // error, end of cluster list

      if (0xFF == MSB0(fs_g_seg.u32_addr))
8000d1b2:	e0 6e 0f d4 	mov	lr,4052
8000d1b6:	3f f9       	mov	r9,-1
8000d1b8:	1d 8a       	ld.ub	r10,lr[0x0]
8000d1ba:	f2 0a 18 00 	cp.b	r10,r9
8000d1be:	c5 c0       	breq	8000d276 <fat_cluster_list+0x1ba>
#endif  // FS_LEVEL_FEATURES
      }
      else
      {
         // The beginning of segment is found
         if (FS_CLUST_ACT_SEG == opt_action)
8000d1c0:	30 19       	mov	r9,1
8000d1c2:	f2 04 18 00 	cp.b	r4,r9
8000d1c6:	e0 80 00 c5 	breq	8000d350 <fat_cluster_list+0x294>
               fat_cache_clusterlist_update_finish();
               return true;                              // End of segment
            }
         }
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
         if (FS_CLUST_ACT_CLR == opt_action)
8000d1ca:	40 3b       	lddsp	r11,sp[0xc]
8000d1cc:	58 0b       	cp.w	r11,0
8000d1ce:	e0 81 00 ca 	brne	8000d362 <fat_cluster_list+0x2a6>
            // !!!! because it isn't possible that MSB0( fs_g_cluster.val ) = 0xFF.
         }
#endif  // FS_LEVEL_FEATURES

         // Check the end of cluster list
         if (FS_CLUS_END == u8_cluster_status)
8000d1d2:	58 01       	cp.w	r1,0
8000d1d4:	e0 81 01 ed 	brne	8000d5ae <fat_cluster_list+0x4f2>
            fat_cache_clusterlist_update_finish();
            return true; // End of segment
         }

         // Update the segment size
         fs_g_seg.u32_size_or_pos += fs_g_nav.u8_BPB_SecPerClus;
8000d1d8:	6c 1a       	ld.w	r10,r6[0x4]
8000d1da:	0b 99       	ld.ub	r9,r5[0x1]
8000d1dc:	6e 18       	ld.w	r8,r7[0x4]
8000d1de:	f2 0a 00 0a 	add	r10,r9,r10
8000d1e2:	8d 1a       	st.w	r6[0x4],r10
      }
      // HERE, Continue to read the cluster list
      // The next cluster is the value of previous cluster
      fs_g_cluster.u32_pos = fs_g_cluster.u32_val;
8000d1e4:	8f 08       	st.w	r7[0x0],r8
   }  // End of main loop
8000d1e6:	ca eb       	rjmp	8000d142 <fat_cluster_list+0x86>
   }

   if ( 0 == fs_g_seg.u32_addr )
   {
      // Cluster list of root directory
      if( FS_CLUST_ACT_CLR == opt_action )
8000d1e8:	40 39       	lddsp	r9,sp[0xc]
8000d1ea:	58 09       	cp.w	r9,0
8000d1ec:	c4 01       	brne	8000d26c <fat_cluster_list+0x1b0>
         return false;           // Impossible to erase ROOT DIR

      if ( Is_fat12 || Is_fat16 )
8000d1ee:	07 88       	ld.ub	r8,r3[0x0]
8000d1f0:	30 19       	mov	r9,1
8000d1f2:	f0 ca 00 01 	sub	r10,r8,1
8000d1f6:	f2 0a 18 00 	cp.b	r10,r9
8000d1fa:	e0 88 01 8d 	brls	8000d514 <fat_cluster_list+0x458>
         } else {
            fs_g_status = FS_ERR_OUT_LIST;
            return false;        // Position outside the root area
         }
      }
      if ( Is_fat32 )
8000d1fe:	30 39       	mov	r9,3
8000d200:	f2 08 18 00 	cp.b	r8,r9
8000d204:	e0 80 01 21 	breq	8000d446 <fat_cluster_list+0x38a>
8000d208:	e0 67 0f cc 	mov	r7,4044
8000d20c:	e0 65 0f 2c 	mov	r5,3884
8000d210:	6e 08       	ld.w	r8,r7[0x0]
{
   uint32_t u32_tmp;
   uint8_t u8_i;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( (fs_g_cache_clusterlist[u8_i].b_cache_file == b_for_file)
8000d212:	e0 6c 0d 00 	mov	r12,3328
8000d216:	50 4c       	stdsp	sp[0x10],r12
      // It is the first cluster of a cluster list
      fs_g_cluster.u32_pos = fs_g_seg.u32_addr;
   }

   // Management of cluster list caches
   if( FS_CLUST_ACT_CLR != opt_action )
8000d218:	6c 1a       	ld.w	r10,r6[0x4]
   uint32_t u32_tmp;
   uint8_t u8_i;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( (fs_g_cache_clusterlist[u8_i].b_cache_file == b_for_file)
      &&  (fs_g_cache_clusterlist[u8_i].u8_lun == fs_g_nav.u8_lun ) )
8000d21a:	0b 82       	ld.ub	r2,r5[0x0]
{
   uint32_t u32_tmp;
   uint8_t u8_i;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( (fs_g_cache_clusterlist[u8_i].b_cache_file == b_for_file)
8000d21c:	19 89       	ld.ub	r9,r12[0x0]
8000d21e:	f2 0b 18 00 	cp.b	r11,r9
8000d222:	e0 80 01 29 	breq	8000d474 <fat_cluster_list+0x3b8>
8000d226:	40 4e       	lddsp	lr,sp[0x10]
8000d228:	e0 61 0d 00 	mov	r1,3328
8000d22c:	fd 3c 00 14 	ld.ub	r12,lr[20]
8000d230:	f6 0c 18 00 	cp.b	r12,r11
8000d234:	e0 80 01 10 	breq	8000d454 <fat_cluster_list+0x398>
#endif
            break;
      }
   }
   fs_g_u8_current_cache = u8_i;
   fs_g_cache_clusterlist[fs_g_u8_current_cache].b_cache_file = b_for_file;
8000d238:	40 42       	lddsp	r2,sp[0x10]
                  u32_tmp  = fs_g_seg.u32_size_or_pos;                                 // save position ask
                  // Compute the position of the end of cluster list cache, and decrement the position asked
                  fs_g_seg.u32_size_or_pos-= ((fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start + fs_g_cache_clusterlist[u8_i].u32_size -1)
                                             / fs_g_nav.u8_BPB_SecPerClus)
                                             * fs_g_nav.u8_BPB_SecPerClus;
                  fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start = u32_tmp;   // Update cache with the position asked
8000d23a:	f7 e9 20 09 	eor	r9,r11,r9
8000d23e:	5c 59       	castu.b	r9
#endif
            break;
      }
   }
   fs_g_u8_current_cache = u8_i;
   fs_g_cache_clusterlist[fs_g_u8_current_cache].b_cache_file = b_for_file;
8000d240:	f2 09 00 2e 	add	lr,r9,r9<<0x2
8000d244:	e4 0e 00 2c 	add	r12,r2,lr<<0x2
8000d248:	b8 8b       	st.b	r12[0x0],r11
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = 0xFF;                     // invalid cache
8000d24a:	3f fb       	mov	r11,-1
8000d24c:	b8 ab       	st.b	r12[0x2],r11
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_cluster  = fs_g_cluster.u32_pos;
8000d24e:	2f fe       	sub	lr,-1
8000d250:	e4 0e 09 28 	st.w	r2[lr<<0x2],r8
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start    = fs_g_seg.u32_size_or_pos;
8000d254:	99 2a       	st.w	r12[0x8],r10
         if( (FS_NB_CACHE_CLUSLIST-2) < fs_g_cache_clusterlist[u8_i].u8_level_use )
#endif
            break;
      }
   }
   fs_g_u8_current_cache = u8_i;
8000d256:	e0 6e 0f 7e 	mov	lr,3966
8000d25a:	bc 89       	st.b	lr[0x0],r9
8000d25c:	50 6e       	stdsp	sp[0x18],lr
   fs_g_cache_clusterlist[fs_g_u8_current_cache].b_cache_file = b_for_file;
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = 0xFF;                     // invalid cache
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_cluster  = fs_g_cluster.u32_pos;
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start    = fs_g_seg.u32_size_or_pos;
8000d25e:	0b 99       	ld.ub	r9,r5[0x1]
8000d260:	c6 9b       	rjmp	8000d132 <fat_cluster_list+0x76>
    else if (fs_g_cluster.u32_val == 0xFFF7)
      return FS_CLUS_BAD;
  }
  else if ( Is_fat12 )
  {
    if (fs_g_cluster.u32_val >= 0xFF8)
8000d262:	e0 48 0f f7 	cp.w	r8,4087
8000d266:	e0 8b 00 06 	brhi	8000d272 <fat_cluster_list+0x1b6>
      return FS_CLUS_END;
    else if (fs_g_cluster.u32_val == 0xFF7)
8000d26a:	ca 31       	brne	8000d1b0 <fat_cluster_list+0xf4>
         fs_g_seg.u32_size_or_pos += fs_g_nav.u8_BPB_SecPerClus;
      }
      // HERE, Continue to read the cluster list
      // The next cluster is the value of previous cluster
      fs_g_cluster.u32_pos = fs_g_cluster.u32_val;
   }  // End of main loop
8000d26c:	30 0c       	mov	r12,0
}
8000d26e:	2f 7d       	sub	sp,-36
8000d270:	d8 32       	popm	r0-r7,pc
         fs_g_seg.u32_size_or_pos += fs_g_nav.u8_BPB_SecPerClus;
      }
      // HERE, Continue to read the cluster list
      // The next cluster is the value of previous cluster
      fs_g_cluster.u32_pos = fs_g_cluster.u32_val;
   }  // End of main loop
8000d272:	30 21       	mov	r1,2
8000d274:	c9 fb       	rjmp	8000d1b2 <fat_cluster_list+0xf6>
         return false; // error, end of cluster list

      if (0xFF == MSB0(fs_g_seg.u32_addr))
      {
         // The beginning of the segment isn't found
         if (FS_CLUS_END == u8_cluster_status)
8000d276:	58 01       	cp.w	r1,0
8000d278:	e0 81 01 ba 	brne	8000d5ec <fat_cluster_list+0x530>
            fs_g_seg.u32_size_or_pos = u32_tmp;       // Restore number of sector remaining
            fs_g_status = FS_ERR_OUT_LIST;
            return false;
         }
         // Good cluster then continue
         fs_g_seg.u32_size_or_pos -= fs_g_nav.u8_BPB_SecPerClus;
8000d27c:	6c 1a       	ld.w	r10,r6[0x4]
8000d27e:	0b 99       	ld.ub	r9,r5[0x1]
8000d280:	12 1a       	sub	r10,r9
8000d282:	8d 1a       	st.w	r6[0x4],r10
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
         if (FS_CLUST_ACT_CLR == opt_action)
8000d284:	40 3c       	lddsp	r12,sp[0xc]
8000d286:	58 0c       	cp.w	r12,0
8000d288:	ca e0       	breq	8000d1e4 <fat_cluster_list+0x128>
         {
            if( fs_g_seg.u32_size_or_pos == 0)
8000d28a:	58 0a       	cp.w	r10,0
8000d28c:	ca c1       	brne	8000d1e4 <fat_cluster_list+0x128>
            {
               // At cluster position, set the flag end of cluster list
               fs_g_seg.u32_addr = fs_g_cluster.u32_val; // Save the next cluster
8000d28e:	e0 6b 0f d4 	mov	r11,4052
8000d292:	97 08       	st.w	r11[0x0],r8
               fs_g_cluster.u32_val = FS_CLUST_VAL_EOL;
8000d294:	e0 68 ff ff 	mov	r8,65535
8000d298:	ea 18 0f ff 	orh	r8,0xfff
               if( !fat_cluster_val( FS_CLUST_VAL_WRITE ))
8000d29c:	30 1c       	mov	r12,1
         {
            if( fs_g_seg.u32_size_or_pos == 0)
            {
               // At cluster position, set the flag end of cluster list
               fs_g_seg.u32_addr = fs_g_cluster.u32_val; // Save the next cluster
               fs_g_cluster.u32_val = FS_CLUST_VAL_EOL;
8000d29e:	8f 18       	st.w	r7[0x4],r8
               if( !fat_cluster_val( FS_CLUST_VAL_WRITE ))
8000d2a0:	fe b0 fb c0 	rcall	8000ca20 <fat_cluster_val>
8000d2a4:	ce 40       	breq	8000d26c <fat_cluster_list+0x1b0>
                  return false;
               fs_g_cluster.u32_val = fs_g_seg.u32_addr; // Restore the next cluster
8000d2a6:	e0 68 0f 2c 	mov	r8,3884
8000d2aa:	e0 6a 0f d4 	mov	r10,4052
8000d2ae:	11 99       	ld.ub	r9,r8[0x1]
8000d2b0:	e0 6e 0f cc 	mov	lr,4044
8000d2b4:	74 08       	ld.w	r8,r10[0x0]
8000d2b6:	74 1a       	ld.w	r10,r10[0x4]
8000d2b8:	9d 18       	st.w	lr[0x4],r8
8000d2ba:	c9 5b       	rjmp	8000d1e4 <fat_cluster_list+0x128>

  // Cluster bad if (FAT12 == 0x0FF7) (FAT16 == 0xFFF7) (FAT32 == 0x0FFFFFF7)
  // Last cluster if (FAT12 > 0x0FF7) (FAT16 > 0xFFF7) (FAT32 > 0x0FFFFFF7)
  if ( Is_fat32 )
  {
    if (fs_g_cluster.u32_val >= 0x0FFFFFF8)
8000d2bc:	e0 6b ff f7 	mov	r11,65527
8000d2c0:	ea 1b 0f ff 	orh	r11,0xfff
8000d2c4:	16 38       	cp.w	r8,r11
8000d2c6:	fe 9b ff d6 	brhi	8000d272 <fat_cluster_list+0x1b6>
      return FS_CLUS_END;
    else if (fs_g_cluster.u32_val == 0x0FFFFFF7)
8000d2ca:	fe 91 ff 73 	brne	8000d1b0 <fat_cluster_list+0xf4>
8000d2ce:	cc fb       	rjmp	8000d26c <fat_cluster_list+0x1b0>
         }
         // Update the segment size
         fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus - LSB0( fs_g_seg.u32_size_or_pos );

         // Take time, during read cluster list on FAT 16 & 32
         if( (FS_CLUST_ACT_SEG == opt_action)
8000d2d0:	07 8a       	ld.ub	r10,r3[0x0]
8000d2d2:	f2 0a 18 00 	cp.b	r10,r9
8000d2d6:	fe 90 ff 58 	breq	8000d186 <fat_cluster_list+0xca>
         &&  (!Is_fat12) )
         {
            // Init loop with the current cluster
            u32_tmp = fs_g_cluster.u32_pos;
            if( !fat_cluster_val( FS_CLUST_VAL_READ ))
8000d2da:	50 08       	stdsp	sp[0x0],r8
8000d2dc:	30 0c       	mov	r12,0
8000d2de:	fe b0 fb a1 	rcall	8000ca20 <fat_cluster_val>
8000d2e2:	40 08       	lddsp	r8,sp[0x0]
8000d2e4:	cc 40       	breq	8000d26c <fat_cluster_list+0x1b0>
   // Init sector cache
   fs_g_sectorcache.u32_addr = fs_gu32_addrsector;
   if( b_load )
   {
      // Load the sector from memory
      if( CTRL_GOOD != memory_2_ram( fs_g_nav.u8_lun  , fs_g_sectorcache.u32_addr, fs_g_sector))
8000d2e6:	08 90       	mov	r0,r4
   if ( Is_fat32 )
   {
      fs_g_u16_pos_fat += 4;
   }else{
      // Is_fat16
      fs_g_u16_pos_fat += 2;
8000d2e8:	e0 61 0c fc 	mov	r1,3324
   }

   // Check if next cluster is in internal cache
   if( FS_CACHE_SIZE == fs_g_u16_pos_fat )
8000d2ec:	e0 69 02 00 	mov	r9,512
   // Init sector cache
   fs_g_sectorcache.u32_addr = fs_gu32_addrsector;
   if( b_load )
   {
      // Load the sector from memory
      if( CTRL_GOOD != memory_2_ram( fs_g_nav.u8_lun  , fs_g_sectorcache.u32_addr, fs_g_sector))
8000d2f0:	0a 94       	mov	r4,r5
            if( !fat_cluster_val( FS_CLUST_VAL_READ ))
               return false;
            // Read cluster list, while this one is continue
            while(1)
            {
               if ( (++fs_g_cluster.u32_pos) != fs_g_cluster.u32_val )
8000d2f2:	6e 0b       	ld.w	r11,r7[0x0]
8000d2f4:	f6 ca ff ff 	sub	r10,r11,-1
8000d2f8:	8f 0a       	st.w	r7[0x0],r10
8000d2fa:	6e 1c       	ld.w	r12,r7[0x4]
8000d2fc:	18 3a       	cp.w	r10,r12
8000d2fe:	e0 81 01 1d 	brne	8000d538 <fat_cluster_list+0x47c>
//! @endverbatim
//!
bool  fat_cluster_readnext( void )
{
   // Compute the next cluster position in FAT
   if ( Is_fat32 )
8000d302:	07 8c       	ld.ub	r12,r3[0x0]
8000d304:	e4 0c 18 00 	cp.b	r12,r2
8000d308:	c4 30       	breq	8000d38e <fat_cluster_list+0x2d2>
   {
      fs_g_u16_pos_fat += 4;
   }else{
      // Is_fat16
      fs_g_u16_pos_fat += 2;
8000d30a:	82 0b       	ld.sh	r11,r1[0x0]
8000d30c:	e0 6a 0c fc 	mov	r10,3324
8000d310:	2f eb       	sub	r11,-2
8000d312:	50 5a       	stdsp	sp[0x14],r10
8000d314:	5c 8b       	casts.h	r11
8000d316:	a2 0b       	st.h	r1[0x0],r11
   }

   // Check if next cluster is in internal cache
   if( FS_CACHE_SIZE == fs_g_u16_pos_fat )
8000d318:	f2 0b 19 00 	cp.h	r11,r9
8000d31c:	c4 30       	breq	8000d3a2 <fat_cluster_list+0x2e6>
8000d31e:	5c 7b       	castu.h	r11
8000d320:	e0 65 0d 2c 	mov	r5,3372
8000d324:	f6 ca ff ff 	sub	r10,r11,-1
         return false;
   }

   //**** Read the cluster value
   LSB0( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+0];  // FAT 16,32
   LSB1( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+1];  // FAT 16,32
8000d328:	ea 0a 07 0e 	ld.ub	lr,r5[r10]
      if( !fat_cache_read_sector( true ))
         return false;
   }

   //**** Read the cluster value
   LSB0( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+0];  // FAT 16,32
8000d32c:	ee ca ff fc 	sub	r10,r7,-4
   LSB1( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+1];  // FAT 16,32
8000d330:	b4 ae       	st.b	r10[0x2],lr
      if( !fat_cache_read_sector( true ))
         return false;
   }

   //**** Read the cluster value
   LSB0( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+0];  // FAT 16,32
8000d332:	ea 0b 07 0e 	ld.ub	lr,r5[r11]
8000d336:	b4 be       	st.b	r10[0x3],lr
   LSB1( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+1];  // FAT 16,32

   if ( Is_fat32 )
8000d338:	e4 0c 18 00 	cp.b	r12,r2
8000d33c:	cd b1       	brne	8000d2f2 <fat_cluster_list+0x236>
   {  // FAT 32
      LSB2( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+2];
8000d33e:	e0 6c 0d 2c 	mov	r12,3372
8000d342:	f8 0b 00 0b 	add	r11,r12,r11
      LSB3( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+3];
8000d346:	17 bc       	ld.ub	r12,r11[0x3]
8000d348:	b4 8c       	st.b	r10[0x0],r12
   LSB0( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+0];  // FAT 16,32
   LSB1( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+1];  // FAT 16,32

   if ( Is_fat32 )
   {  // FAT 32
      LSB2( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+2];
8000d34a:	17 ab       	ld.ub	r11,r11[0x2]
8000d34c:	b4 9b       	st.b	r10[0x1],r11
8000d34e:	cd 2b       	rjmp	8000d2f2 <fat_cluster_list+0x236>
      else
      {
         // The beginning of segment is found
         if (FS_CLUST_ACT_SEG == opt_action)
         {
            if ( (fs_g_cluster.u32_pos+1) != fs_g_cluster.u32_val )
8000d350:	6e 09       	ld.w	r9,r7[0x0]
8000d352:	2f f9       	sub	r9,-1
8000d354:	10 39       	cp.w	r9,r8
8000d356:	fe 90 ff 3e 	breq	8000d1d2 <fat_cluster_list+0x116>
            if (FS_CLUST_ACT_CLR == opt_action)
            {
               return fat_update_fat2();
            }
#endif  // FS_LEVEL_FEATURES
            fat_cache_clusterlist_update_finish();
8000d35a:	fe b0 f5 c5 	rcall	8000bee4 <fat_cache_clusterlist_update_finish>
8000d35e:	30 1c       	mov	r12,1
            return true; // End of segment
8000d360:	c8 7b       	rjmp	8000d26e <fat_cluster_list+0x1b2>
         }
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
         if (FS_CLUST_ACT_CLR == opt_action)
         {
            //** Clear cluster position
            fs_g_seg.u32_addr = fs_g_cluster.u32_val;    // Save the next cluster
8000d362:	8d 08       	st.w	r6[0x0],r8
            fs_g_cluster.u32_val = 0;                    // by default free cluster
8000d364:	30 08       	mov	r8,0
8000d366:	8f 18       	st.w	r7[0x4],r8
            // If it is the first cluster (fs_g_seg.u32_size_or_pos <= fs_g_nav.u8_BPB_SecPerClus)
            // and doesn't start at the beginning of cluster (fs_g_seg.u32_size_or_pos != fs_g_nav.u8_BPB_SecPerClus)
            if (fs_g_seg.u32_size_or_pos < fs_g_nav.u8_BPB_SecPerClus)
8000d368:	6c 19       	ld.w	r9,r6[0x4]
8000d36a:	0b 98       	ld.ub	r8,r5[0x1]
8000d36c:	10 39       	cp.w	r9,r8
8000d36e:	c0 82       	brcc	8000d37e <fat_cluster_list+0x2c2>
            {
               fs_g_cluster.u32_val = FS_CLUST_VAL_EOL;  // End of cluster list allocated
8000d370:	e0 68 ff ff 	mov	r8,65535
8000d374:	ea 18 0f ff 	orh	r8,0xfff
8000d378:	e0 6a 0f cc 	mov	r10,4044
8000d37c:	95 18       	st.w	r10[0x4],r8
            }
            if( !fat_cluster_val( FS_CLUST_VAL_WRITE ))
8000d37e:	30 1c       	mov	r12,1
8000d380:	fe b0 fb 50 	rcall	8000ca20 <fat_cluster_val>
8000d384:	fe 90 ff 74 	breq	8000d26c <fat_cluster_list+0x1b0>
               return false;
            fs_g_cluster.u32_val = fs_g_seg.u32_addr;    // Restore the next cluster
8000d388:	6c 08       	ld.w	r8,r6[0x0]
8000d38a:	8f 18       	st.w	r7[0x4],r8
8000d38c:	c2 3b       	rjmp	8000d1d2 <fat_cluster_list+0x116>
bool  fat_cluster_readnext( void )
{
   // Compute the next cluster position in FAT
   if ( Is_fat32 )
   {
      fs_g_u16_pos_fat += 4;
8000d38e:	82 0b       	ld.sh	r11,r1[0x0]
8000d390:	e0 6e 0c fc 	mov	lr,3324
8000d394:	2f cb       	sub	r11,-4
8000d396:	50 5e       	stdsp	sp[0x14],lr
8000d398:	5c 8b       	casts.h	r11
8000d39a:	a2 0b       	st.h	r1[0x0],r11
      // Is_fat16
      fs_g_u16_pos_fat += 2;
   }

   // Check if next cluster is in internal cache
   if( FS_CACHE_SIZE == fs_g_u16_pos_fat )
8000d39c:	f2 0b 19 00 	cp.h	r11,r9
8000d3a0:	cb f1       	brne	8000d31e <fat_cluster_list+0x262>
   {
      // Update cache
      fs_g_u16_pos_fat = 0;
      fs_gu32_addrsector++;
8000d3a2:	e0 6a 0c e8 	mov	r10,3304

   // Check if next cluster is in internal cache
   if( FS_CACHE_SIZE == fs_g_u16_pos_fat )
   {
      // Update cache
      fs_g_u16_pos_fat = 0;
8000d3a6:	30 0c       	mov	r12,0
      fs_gu32_addrsector++;
8000d3a8:	74 0b       	ld.w	r11,r10[0x0]

   // Check if next cluster is in internal cache
   if( FS_CACHE_SIZE == fs_g_u16_pos_fat )
   {
      // Update cache
      fs_g_u16_pos_fat = 0;
8000d3aa:	40 5e       	lddsp	lr,sp[0x14]
      fs_gu32_addrsector++;
8000d3ac:	2f fb       	sub	r11,-1

   // Check if next cluster is in internal cache
   if( FS_CACHE_SIZE == fs_g_u16_pos_fat )
   {
      // Update cache
      fs_g_u16_pos_fat = 0;
8000d3ae:	bc 0c       	st.h	lr[0x0],r12
      fs_gu32_addrsector++;
8000d3b0:	95 0b       	st.w	r10[0x0],r11
//! @endverbatim
//!
bool  fat_cache_read_sector( bool b_load )
{
   // Check if the sector asked is the same in cache
   if( (fs_g_sectorcache.u8_lun     == fs_g_nav.u8_lun )
8000d3b2:	e0 6e 0f b4 	mov	lr,4020
8000d3b6:	09 8c       	ld.ub	r12,r4[0x0]
8000d3b8:	1d 8a       	ld.ub	r10,lr[0x0]
8000d3ba:	f8 0a 18 00 	cp.b	r10,r12
8000d3be:	c3 b0       	breq	8000d434 <fat_cluster_list+0x378>
//! @return    true otherwise
//!
bool  fat_cache_flush( void )
{
   // If the cache is modified, then write the sector cache on the device
   if ( true == fs_g_sectorcache.u8_dirty )
8000d3c0:	e0 6a 0f b4 	mov	r10,4020
8000d3c4:	f5 3a 00 08 	ld.ub	r10,r10[8]
8000d3c8:	50 7a       	stdsp	sp[0x1c],r10
8000d3ca:	14 9e       	mov	lr,r10
8000d3cc:	30 1a       	mov	r10,1
8000d3ce:	f4 0e 18 00 	cp.b	lr,r10
8000d3d2:	e0 80 00 d2 	breq	8000d576 <fat_cluster_list+0x4ba>
8000d3d6:	e0 65 0d 2c 	mov	r5,3372

//! This function resets the sector cache
//!
void  fat_cache_reset( void )
{
   fs_g_sectorcache.u8_lun                = FS_BUF_SECTOR_EMPTY;
8000d3da:	3f fa       	mov	r10,-1

   // Delete informations about the caches
   fat_cache_reset();

   // Init sector cache
   fs_g_sectorcache.u32_addr = fs_gu32_addrsector;
8000d3dc:	e0 6e 0f b4 	mov	lr,4020

//! This function resets the sector cache
//!
void  fat_cache_reset( void )
{
   fs_g_sectorcache.u8_lun                = FS_BUF_SECTOR_EMPTY;
8000d3e0:	bc 8a       	st.b	lr[0x0],r10
   fs_g_sectorcache.u8_dirty              = false;
8000d3e2:	30 0a       	mov	r10,0

   // Delete informations about the caches
   fat_cache_reset();

   // Init sector cache
   fs_g_sectorcache.u32_addr = fs_gu32_addrsector;
8000d3e4:	9d 1b       	st.w	lr[0x4],r11
//! This function resets the sector cache
//!
void  fat_cache_reset( void )
{
   fs_g_sectorcache.u8_lun                = FS_BUF_SECTOR_EMPTY;
   fs_g_sectorcache.u8_dirty              = false;
8000d3e6:	fd 6a 00 08 	st.b	lr[8],r10
   fs_g_sectorcache.u32_clusterlist_start = 0xFFFFFFFF;
8000d3ea:	3f fa       	mov	r10,-1
8000d3ec:	9d 3a       	st.w	lr[0xc],r10
   // Init sector cache
   fs_g_sectorcache.u32_addr = fs_gu32_addrsector;
   if( b_load )
   {
      // Load the sector from memory
      if( CTRL_GOOD != memory_2_ram( fs_g_nav.u8_lun  , fs_g_sectorcache.u32_addr, fs_g_sector))
8000d3ee:	50 19       	stdsp	sp[0x4],r9
8000d3f0:	50 08       	stdsp	sp[0x0],r8
8000d3f2:	e0 6a 0d 2c 	mov	r10,3372
8000d3f6:	e0 a0 0b 91 	rcall	8000eb18 <memory_2_ram>
8000d3fa:	40 19       	lddsp	r9,sp[0x4]
8000d3fc:	40 08       	lddsp	r8,sp[0x0]
8000d3fe:	e0 81 00 ab 	brne	8000d554 <fat_cluster_list+0x498>
         fs_g_status = FS_ERR_HW;
         return false;
      }
   }
   // Valid sector cache
   fs_g_sectorcache.u8_lun = fs_g_nav.u8_lun;
8000d402:	40 5a       	lddsp	r10,sp[0x14]
8000d404:	94 8b       	ld.uh	r11,r10[0x0]
8000d406:	09 8a       	ld.ub	r10,r4[0x0]
8000d408:	e0 6e 0f b4 	mov	lr,4020
8000d40c:	07 8c       	ld.ub	r12,r3[0x0]
8000d40e:	bc 8a       	st.b	lr[0x0],r10
8000d410:	f6 ca ff ff 	sub	r10,r11,-1
8000d414:	c8 ab       	rjmp	8000d328 <fat_cluster_list+0x26c>
    else if (fs_g_cluster.u32_val == 0x0FFFFFF7)
      return FS_CLUS_BAD;
  }
  else if ( Is_fat16 )
  {
    if (fs_g_cluster.u32_val >= 0xFFF8)
8000d416:	e0 48 ff f7 	cp.w	r8,65527
8000d41a:	fe 9b ff 2c 	brhi	8000d272 <fat_cluster_list+0x1b6>
      return FS_CLUS_END;
    else if (fs_g_cluster.u32_val == 0xFFF7)
8000d41e:	fe 91 fe c9 	brne	8000d1b0 <fat_cluster_list+0xf4>
8000d422:	c2 5b       	rjmp	8000d26c <fat_cluster_list+0x1b0>
   if(  Is_fat32
   &&  (FS_CLUST_ACT_CLR == opt_action) )
   {
#if (FSFEATURE_WRITE_COMPLET == (FS_LEVEL_FEATURES & FSFEATURE_WRITE_COMPLET) )
      // Clear free space information storage in FAT32
      if( !fat_write_fat32_FSInfo( 0xFFFFFFFF ))
8000d424:	50 1b       	stdsp	sp[0x4],r11
8000d426:	3f fc       	mov	r12,-1
8000d428:	e0 a0 03 26 	rcall	8000da74 <fat_write_fat32_FSInfo>
8000d42c:	40 1b       	lddsp	r11,sp[0x4]
8000d42e:	fe 91 fe 5d 	brne	8000d0e8 <fat_cluster_list+0x2c>
8000d432:	c1 db       	rjmp	8000d26c <fat_cluster_list+0x1b0>
//! @endverbatim
//!
bool  fat_cache_read_sector( bool b_load )
{
   // Check if the sector asked is the same in cache
   if( (fs_g_sectorcache.u8_lun     == fs_g_nav.u8_lun )
8000d434:	7c 1a       	ld.w	r10,lr[0x4]
8000d436:	14 3b       	cp.w	r11,r10
8000d438:	cc 41       	brne	8000d3c0 <fat_cluster_list+0x304>
8000d43a:	30 1a       	mov	r10,1
8000d43c:	30 0b       	mov	r11,0
8000d43e:	e0 65 0d 2c 	mov	r5,3372
         fs_g_status = FS_ERR_HW;
         return false;
      }
   }
   // Valid sector cache
   fs_g_sectorcache.u8_lun = fs_g_nav.u8_lun;
8000d442:	07 8c       	ld.ub	r12,r3[0x0]
8000d444:	c7 2b       	rjmp	8000d328 <fat_cluster_list+0x26c>
         }
      }
      if ( Is_fat32 )
      {
         // For FAT 32, the root is a cluster list and the first cluster is reading during the mount
         fs_g_cluster.u32_pos = fs_g_nav.rootdir.u32_cluster;
8000d446:	e0 67 0f cc 	mov	r7,4044
8000d44a:	e0 65 0f 2c 	mov	r5,3884
8000d44e:	6a 68       	ld.w	r8,r5[0x18]
8000d450:	8f 08       	st.w	r7[0x0],r8
8000d452:	ce 0a       	rjmp	8000d212 <fat_cluster_list+0x156>
{
   uint32_t u32_tmp;
   uint8_t u8_i;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( (fs_g_cache_clusterlist[u8_i].b_cache_file == b_for_file)
8000d454:	e3 3c 00 16 	ld.ub	r12,r1[22]
8000d458:	e4 0c 18 00 	cp.b	r12,r2
8000d45c:	fe 91 fe ee 	brne	8000d238 <fat_cluster_list+0x17c>
      &&  (fs_g_cache_clusterlist[u8_i].u8_lun == fs_g_nav.u8_lun ) )
      {
         if( fs_g_cache_clusterlist[u8_i].u32_cluster == fs_g_cluster.u32_pos )
8000d460:	62 6c       	ld.w	r12,r1[0x18]
8000d462:	10 3c       	cp.w	r12,r8
8000d464:	fe 91 fe ea 	brne	8000d238 <fat_cluster_list+0x17c>
         {
            if( fs_g_cache_clusterlist[u8_i].u32_start <= fs_g_seg.u32_size_or_pos )
8000d468:	62 7c       	ld.w	r12,r1[0x1c]
8000d46a:	18 3a       	cp.w	r10,r12
8000d46c:	fe 93 fe e6 	brlo	8000d238 <fat_cluster_list+0x17c>
8000d470:	30 18       	mov	r8,1
8000d472:	c1 08       	rjmp	8000d492 <fat_cluster_list+0x3d6>
{
   uint32_t u32_tmp;
   uint8_t u8_i;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( (fs_g_cache_clusterlist[u8_i].b_cache_file == b_for_file)
8000d474:	19 ac       	ld.ub	r12,r12[0x2]
8000d476:	e4 0c 18 00 	cp.b	r12,r2
8000d47a:	fe 91 fe d6 	brne	8000d226 <fat_cluster_list+0x16a>
      &&  (fs_g_cache_clusterlist[u8_i].u8_lun == fs_g_nav.u8_lun ) )
      {
         if( fs_g_cache_clusterlist[u8_i].u32_cluster == fs_g_cluster.u32_pos )
8000d47e:	40 4e       	lddsp	lr,sp[0x10]
8000d480:	7c 1c       	ld.w	r12,lr[0x4]
8000d482:	10 3c       	cp.w	r12,r8
8000d484:	fe 91 fe d1 	brne	8000d226 <fat_cluster_list+0x16a>
         {
            if( fs_g_cache_clusterlist[u8_i].u32_start <= fs_g_seg.u32_size_or_pos )
8000d488:	7c 2c       	ld.w	r12,lr[0x8]
8000d48a:	18 3a       	cp.w	r10,r12
8000d48c:	fe 93 fe cd 	brlo	8000d226 <fat_cluster_list+0x16a>
8000d490:	30 08       	mov	r8,0
            {
               // The segment research is in or after the cache
               if( fs_g_cache_clusterlist[u8_i].u32_size  > (fs_g_seg.u32_size_or_pos-fs_g_cache_clusterlist[u8_i].u32_start) )
8000d492:	f0 0e 15 02 	lsl	lr,r8,0x2
8000d496:	10 0e       	add	lr,r8
8000d498:	40 42       	lddsp	r2,sp[0x10]
8000d49a:	50 6e       	stdsp	sp[0x18],lr
8000d49c:	f4 0c 01 01 	sub	r1,r10,r12
8000d4a0:	e4 0e 00 2c 	add	r12,r2,lr<<0x2
8000d4a4:	f8 ce ff f0 	sub	lr,r12,-16
8000d4a8:	50 5e       	stdsp	sp[0x14],lr
8000d4aa:	e0 60 0d 00 	mov	r0,3328
8000d4ae:	7c 02       	ld.w	r2,lr[0x0]
8000d4b0:	02 32       	cp.w	r2,r1
8000d4b2:	e0 88 00 cb 	brls	8000d648 <fat_cluster_list+0x58c>
               {
                  //** The segment research is in cache, then compute the segment infos
                  fs_g_seg.u32_size_or_pos -= fs_g_cache_clusterlist[u8_i].u32_start;
                  fs_g_seg.u32_addr = fs_g_cache_clusterlist[u8_i].u32_addr + fs_g_seg.u32_size_or_pos;
                  fs_g_seg.u32_size_or_pos = fs_g_cache_clusterlist[u8_i].u32_size - fs_g_seg.u32_size_or_pos;
8000d4b6:	02 12       	sub	r2,r1
               // The segment research is in or after the cache
               if( fs_g_cache_clusterlist[u8_i].u32_size  > (fs_g_seg.u32_size_or_pos-fs_g_cache_clusterlist[u8_i].u32_start) )
               {
                  //** The segment research is in cache, then compute the segment infos
                  fs_g_seg.u32_size_or_pos -= fs_g_cache_clusterlist[u8_i].u32_start;
                  fs_g_seg.u32_addr = fs_g_cache_clusterlist[u8_i].u32_addr + fs_g_seg.u32_size_or_pos;
8000d4b8:	8d 12       	st.w	r6[0x4],r2
8000d4ba:	78 3a       	ld.w	r10,r12[0xc]
                  fs_g_seg.u32_size_or_pos = fs_g_cache_clusterlist[u8_i].u32_size - fs_g_seg.u32_size_or_pos;
                  fs_g_u8_current_cache = u8_i;
8000d4bc:	14 01       	add	r1,r10
               // The segment research is in or after the cache
               if( fs_g_cache_clusterlist[u8_i].u32_size  > (fs_g_seg.u32_size_or_pos-fs_g_cache_clusterlist[u8_i].u32_start) )
               {
                  //** The segment research is in cache, then compute the segment infos
                  fs_g_seg.u32_size_or_pos -= fs_g_cache_clusterlist[u8_i].u32_start;
                  fs_g_seg.u32_addr = fs_g_cache_clusterlist[u8_i].u32_addr + fs_g_seg.u32_size_or_pos;
8000d4be:	e0 6a 0f 7e 	mov	r10,3966
   uint8_t u8_i;
   uint8_t u8_level_to_update;
   bool b_file_cache;

   b_file_cache         = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].b_cache_file;
   u8_level_to_update   = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].u8_level_use;
8000d4c2:	8d 01       	st.w	r6[0x0],r1
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( fs_g_cache_clusterlist[u8_i].b_cache_file == b_file_cache )
8000d4c4:	b4 88       	st.b	r10[0x0],r8
8000d4c6:	19 9a       	ld.ub	r10,r12[0x1]
8000d4c8:	f2 0b 18 00 	cp.b	r11,r9
         if( u8_level_to_update > fs_g_cache_clusterlist[u8_i].u8_level_use )
           fs_g_cache_clusterlist[u8_i].u8_level_use++;
8000d4cc:	c0 81       	brne	8000d4dc <fat_cluster_list+0x420>
8000d4ce:	01 98       	ld.ub	r8,r0[0x1]
8000d4d0:	f0 0a 18 00 	cp.b	r10,r8
8000d4d4:	f7 b8 0b ff 	subhi	r8,-1

   b_file_cache         = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].b_cache_file;
   u8_level_to_update   = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].u8_level_use;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( fs_g_cache_clusterlist[u8_i].b_cache_file == b_file_cache )
8000d4d8:	e1 f8 be 01 	st.bhi	r0[0x1],r8
8000d4dc:	40 4c       	lddsp	r12,sp[0x10]
8000d4de:	e0 68 0d 00 	mov	r8,3328
8000d4e2:	f9 39 00 14 	ld.ub	r9,r12[20]
         if( u8_level_to_update > fs_g_cache_clusterlist[u8_i].u8_level_use )
8000d4e6:	f6 09 18 00 	cp.b	r9,r11
           fs_g_cache_clusterlist[u8_i].u8_level_use++;
8000d4ea:	c0 91       	brne	8000d4fc <fat_cluster_list+0x440>
8000d4ec:	f1 39 00 15 	ld.ub	r9,r8[21]
8000d4f0:	f2 0a 18 00 	cp.b	r10,r9
8000d4f4:	f7 b9 0b ff 	subhi	r9,-1
   }
   fs_g_cache_clusterlist[  fs_g_u8_current_cache  ].u8_level_use = 0;
8000d4f8:	f1 f9 be 15 	st.bhi	r8[0x15],r9
8000d4fc:	40 6b       	lddsp	r11,sp[0x18]
8000d4fe:	40 4a       	lddsp	r10,sp[0x10]
8000d500:	30 08       	mov	r8,0
8000d502:	f4 0b 00 2e 	add	lr,r10,r11<<0x2
8000d506:	30 1c       	mov	r12,1
8000d508:	bc 98       	st.b	lr[0x1],r8
8000d50a:	cb 2a       	rjmp	8000d26e <fat_cluster_list+0x1b2>

      if ( Is_fat12 || Is_fat16 )
      {
         // For a FAT 12 & 16, the root dir isn't a cluster list
         // Check the position
         if ( fs_g_seg.u32_size_or_pos < fs_g_nav.rootdir.seg.u16_size )
8000d50c:	e0 65 0f 2c 	mov	r5,3884
8000d510:	fe 9f fe 81 	bral	8000d212 <fat_cluster_list+0x156>
8000d514:	e0 69 0f 2c 	mov	r9,3884
         {
            // Compute the start address and the size
            fs_g_seg.u32_addr = fs_g_nav.u32_ptr_fat + fs_g_nav.rootdir.seg.u16_pos + fs_g_seg.u32_size_or_pos;
            fs_g_seg.u32_size_or_pos = fs_g_nav.rootdir.seg.u16_size - fs_g_seg.u32_size_or_pos;
8000d518:	6c 18       	ld.w	r8,r6[0x4]
8000d51a:	f3 1a 00 1a 	ld.uh	r10,r9[26]
         // For a FAT 12 & 16, the root dir isn't a cluster list
         // Check the position
         if ( fs_g_seg.u32_size_or_pos < fs_g_nav.rootdir.seg.u16_size )
         {
            // Compute the start address and the size
            fs_g_seg.u32_addr = fs_g_nav.u32_ptr_fat + fs_g_nav.rootdir.seg.u16_pos + fs_g_seg.u32_size_or_pos;
8000d51e:	14 38       	cp.w	r8,r10
8000d520:	c4 02       	brcc	8000d5a0 <fat_cluster_list+0x4e4>
8000d522:	10 1a       	sub	r10,r8
8000d524:	30 1c       	mov	r12,1
8000d526:	8d 1a       	st.w	r6[0x4],r10
8000d528:	f3 1a 00 18 	ld.uh	r10,r9[24]
            fs_g_seg.u32_size_or_pos = fs_g_nav.rootdir.seg.u16_size - fs_g_seg.u32_size_or_pos;
            return true;
8000d52c:	72 49       	ld.w	r9,r9[0x10]
            // Read cluster list, while this one is continue
            while(1)
            {
               if ( (++fs_g_cluster.u32_pos) != fs_g_cluster.u32_val )
               {
                  fs_g_cluster.u32_pos--;                   // Recompute previous value
8000d52e:	12 08       	add	r8,r9
8000d530:	14 08       	add	r8,r10
                  u32_tmp = fs_g_cluster.u32_pos - u32_tmp; // Compute the size of cluster list
                  fs_g_seg.u32_size_or_pos += u32_tmp * fs_g_nav.u8_BPB_SecPerClus;
8000d532:	8d 08       	st.w	r6[0x0],r8
8000d534:	fe 9f fe 9d 	bral	8000d26e <fat_cluster_list+0x1b2>
            // Read cluster list, while this one is continue
            while(1)
            {
               if ( (++fs_g_cluster.u32_pos) != fs_g_cluster.u32_val )
               {
                  fs_g_cluster.u32_pos--;                   // Recompute previous value
8000d538:	e0 6a 0f cc 	mov	r10,4044
                  u32_tmp = fs_g_cluster.u32_pos - u32_tmp; // Compute the size of cluster list
                  fs_g_seg.u32_size_or_pos += u32_tmp * fs_g_nav.u8_BPB_SecPerClus;
8000d53c:	08 95       	mov	r5,r4
8000d53e:	6c 19       	ld.w	r9,r6[0x4]
8000d540:	f6 08 01 08 	sub	r8,r11,r8
                  break;
8000d544:	95 0b       	st.w	r10[0x0],r11
8000d546:	00 94       	mov	r4,r0
   if( b_load )
   {
      // Load the sector from memory
      if( CTRL_GOOD != memory_2_ram( fs_g_nav.u8_lun  , fs_g_sectorcache.u32_addr, fs_g_sector))
      {
         fs_g_status = FS_ERR_HW;
8000d548:	0b 9a       	ld.ub	r10,r5[0x1]
8000d54a:	b5 38       	mul	r8,r10
8000d54c:	12 08       	add	r8,r9
8000d54e:	8d 18       	st.w	r6[0x4],r8
8000d550:	fe 9f fe 1b 	bral	8000d186 <fat_cluster_list+0xca>
                           + fs_g_nav.u32_ptr_fat + fs_g_nav.u32_offset_data + fs_g_seg.u32_size_or_pos;

         if ( FS_CLUST_ACT_ONE == opt_action )
         {
            // Compute the maximum size
            fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus-fs_g_seg.u32_size_or_pos;
8000d554:	e0 6c 0f 7c 	mov	r12,3964
8000d558:	30 18       	mov	r8,1
8000d55a:	b8 88       	st.b	r12[0x0],r8
            fat_cache_clusterlist_update_finish();
8000d55c:	30 0c       	mov	r12,0
8000d55e:	fe 9f fe 88 	bral	8000d26e <fat_cluster_list+0x1b2>
            // Send a size of one sector
            fs_g_seg.u32_size_or_pos = 1;
8000d562:	62 18       	ld.w	r8,r1[0x4]
            return true;
8000d564:	f2 08 01 08 	sub	r8,r9,r8
bool  fat_cache_flush( void )
{
   // If the cache is modified, then write the sector cache on the device
   if ( true == fs_g_sectorcache.u8_dirty )
   {
      fs_g_sectorcache.u8_dirty = false; // Always clear, although an error occur
8000d568:	83 18       	st.w	r1[0x4],r8
8000d56a:	fe b0 f4 bd 	rcall	8000bee4 <fat_cache_clusterlist_update_finish>
8000d56e:	30 1c       	mov	r12,1
      if( mem_wr_protect( fs_g_sectorcache.u8_lun  ))
8000d570:	83 1c       	st.w	r1[0x4],r12
8000d572:	fe 9f fe 7e 	bral	8000d26e <fat_cluster_list+0x1b2>
8000d576:	e0 6e 0f b4 	mov	lr,4020
8000d57a:	30 0a       	mov	r10,0
8000d57c:	fd 6a 00 08 	st.b	lr[8],r10
8000d580:	1d 8c       	ld.ub	r12,lr[0x0]
      {
         fs_g_status = FS_LUN_WP;
8000d582:	50 19       	stdsp	sp[0x4],r9
8000d584:	50 08       	stdsp	sp[0x0],r8
8000d586:	e0 a0 0a c1 	rcall	8000eb08 <mem_wr_protect>
8000d58a:	50 8c       	stdsp	sp[0x20],r12
8000d58c:	40 19       	lddsp	r9,sp[0x4]
            // Compute the start address and the size
            fs_g_seg.u32_addr = fs_g_nav.u32_ptr_fat + fs_g_nav.rootdir.seg.u16_pos + fs_g_seg.u32_size_or_pos;
            fs_g_seg.u32_size_or_pos = fs_g_nav.rootdir.seg.u16_size - fs_g_seg.u32_size_or_pos;
            return true;
         } else {
            fs_g_status = FS_ERR_OUT_LIST;
8000d58e:	40 08       	lddsp	r8,sp[0x0]
8000d590:	c1 70       	breq	8000d5be <fat_cluster_list+0x502>
8000d592:	e0 6c 0f 7c 	mov	r12,3964
            return false;        // Position outside the root area
8000d596:	31 48       	mov	r8,20
8000d598:	b8 88       	st.b	r12[0x0],r8

         // Check the end of cluster list
         if (FS_CLUS_END == u8_cluster_status)
         {
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
            if (FS_CLUST_ACT_CLR == opt_action)
8000d59a:	30 0c       	mov	r12,0
8000d59c:	fe 9f fe 69 	bral	8000d26e <fat_cluster_list+0x1b2>
8000d5a0:	31 a8       	mov	r8,26
            {
               return fat_update_fat2();
8000d5a2:	e0 62 0f 7c 	mov	r2,3964
8000d5a6:	40 3c       	lddsp	r12,sp[0xc]
8000d5a8:	a4 88       	st.b	r2[0x0],r8
      if( mem_wr_protect( fs_g_sectorcache.u8_lun  ))
      {
         fs_g_status = FS_LUN_WP;
         return false;
      }
      if (CTRL_GOOD != ram_2_memory( fs_g_sectorcache.u8_lun , fs_g_sectorcache.u32_addr , fs_g_sector ))
8000d5aa:	fe 9f fe 62 	bral	8000d26e <fat_cluster_list+0x1b2>
8000d5ae:	40 39       	lddsp	r9,sp[0xc]
8000d5b0:	58 09       	cp.w	r9,0
8000d5b2:	fe 90 fe d4 	breq	8000d35a <fat_cluster_list+0x29e>
8000d5b6:	e0 a0 02 2d 	rcall	8000da10 <fat_update_fat2>
8000d5ba:	fe 9f fe 5a 	bral	8000d26e <fat_cluster_list+0x1b2>
8000d5be:	e0 6a 0f b4 	mov	r10,4020
8000d5c2:	e0 6e 0f b4 	mov	lr,4020
      {
         fs_g_status = FS_ERR_HW;
8000d5c6:	74 1b       	ld.w	r11,r10[0x4]
8000d5c8:	1d 8c       	ld.ub	r12,lr[0x0]
8000d5ca:	e0 65 0d 2c 	mov	r5,3372
8000d5ce:	50 19       	stdsp	sp[0x4],r9
         if (FS_CLUS_END == u8_cluster_status)
         {
            u32_tmp = fs_g_seg.u32_size_or_pos;       // Save number of sector remaining

            // Compute the sector address of this last cluster to take time during a future request with the same cluster list
            fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start -= fs_g_seg.u32_size_or_pos;
8000d5d0:	50 08       	stdsp	sp[0x0],r8
            fs_g_seg.u32_addr = ((fs_g_cluster.u32_pos - 2) * fs_g_nav.u8_BPB_SecPerClus)
8000d5d2:	0a 9a       	mov	r10,r5
         if (FS_CLUS_END == u8_cluster_status)
         {
            u32_tmp = fs_g_seg.u32_size_or_pos;       // Save number of sector remaining

            // Compute the sector address of this last cluster to take time during a future request with the same cluster list
            fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start -= fs_g_seg.u32_size_or_pos;
8000d5d4:	e0 a0 0a ac 	rcall	8000eb2c <ram_2_memory>
            fs_g_seg.u32_addr = ((fs_g_cluster.u32_pos - 2) * fs_g_nav.u8_BPB_SecPerClus)
8000d5d8:	40 19       	lddsp	r9,sp[0x4]
                              + fs_g_nav.u32_ptr_fat + fs_g_nav.u32_offset_data;
            fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus;
8000d5da:	40 08       	lddsp	r8,sp[0x0]
         {
            u32_tmp = fs_g_seg.u32_size_or_pos;       // Save number of sector remaining

            // Compute the sector address of this last cluster to take time during a future request with the same cluster list
            fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start -= fs_g_seg.u32_size_or_pos;
            fs_g_seg.u32_addr = ((fs_g_cluster.u32_pos - 2) * fs_g_nav.u8_BPB_SecPerClus)
8000d5dc:	c3 10       	breq	8000d63e <fat_cluster_list+0x582>
         if (FS_CLUS_END == u8_cluster_status)
         {
            u32_tmp = fs_g_seg.u32_size_or_pos;       // Save number of sector remaining

            // Compute the sector address of this last cluster to take time during a future request with the same cluster list
            fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start -= fs_g_seg.u32_size_or_pos;
8000d5de:	40 7a       	lddsp	r10,sp[0x1c]
8000d5e0:	e0 6b 0f 7c 	mov	r11,3964
8000d5e4:	40 8c       	lddsp	r12,sp[0x20]
8000d5e6:	b6 8a       	st.b	r11[0x0],r10
8000d5e8:	fe 9f fe 43 	bral	8000d26e <fat_cluster_list+0x1b2>
8000d5ec:	40 69       	lddsp	r9,sp[0x18]
            fs_g_seg.u32_addr = ((fs_g_cluster.u32_pos - 2) * fs_g_nav.u8_BPB_SecPerClus)
8000d5ee:	6e 08       	ld.w	r8,r7[0x0]
8000d5f0:	13 8a       	ld.ub	r10,r9[0x0]
8000d5f2:	6c 17       	ld.w	r7,r6[0x4]
8000d5f4:	0b 99       	ld.ub	r9,r5[0x1]
8000d5f6:	8d 19       	st.w	r6[0x4],r9
8000d5f8:	6a 4b       	ld.w	r11,r5[0x10]
8000d5fa:	40 42       	lddsp	r2,sp[0x10]
8000d5fc:	f4 0a 00 2a 	add	r10,r10,r10<<0x2
                              + fs_g_nav.u32_ptr_fat + fs_g_nav.u32_offset_data;
            fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus;
            if (FS_CLUST_ACT_CLR != opt_action)
8000d600:	e4 0a 00 2a 	add	r10,r2,r10<<0x2
8000d604:	74 2c       	ld.w	r12,r10[0x8]
               fat_cache_clusterlist_update_finish();
8000d606:	0e 1c       	sub	r12,r7
8000d608:	95 2c       	st.w	r10[0x8],r12
8000d60a:	6a 5a       	ld.w	r10,r5[0x14]
8000d60c:	16 0a       	add	r10,r11

            // The position is outside the cluster list
            fs_g_seg.u32_addr = fs_g_cluster.u32_pos; // Send the last cluster value
8000d60e:	f0 cb 00 02 	sub	r11,r8,2
            fs_g_seg.u32_size_or_pos = u32_tmp;       // Restore number of sector remaining
            fs_g_status = FS_ERR_OUT_LIST;
8000d612:	b7 39       	mul	r9,r11
            if (FS_CLUST_ACT_CLR != opt_action)
               fat_cache_clusterlist_update_finish();

            // The position is outside the cluster list
            fs_g_seg.u32_addr = fs_g_cluster.u32_pos; // Send the last cluster value
            fs_g_seg.u32_size_or_pos = u32_tmp;       // Restore number of sector remaining
8000d614:	f4 09 00 09 	add	r9,r10,r9
            fs_g_status = FS_ERR_OUT_LIST;
8000d618:	8d 09       	st.w	r6[0x0],r9
            return false;
8000d61a:	30 39       	mov	r9,3
8000d61c:	f2 04 18 00 	cp.b	r4,r9
      if( mem_wr_protect( fs_g_sectorcache.u8_lun  ))
      {
         fs_g_status = FS_LUN_WP;
         return false;
      }
      if (CTRL_GOOD != ram_2_memory( fs_g_sectorcache.u8_lun , fs_g_sectorcache.u32_addr , fs_g_sector ))
8000d620:	c0 60       	breq	8000d62c <fat_cluster_list+0x570>
8000d622:	fe b0 f4 61 	rcall	8000bee4 <fat_cache_clusterlist_update_finish>
                  return true;   // the segment is in cluster list cache
               }else{
                  //** It is after the cache then get cache information and continue to read the cluster list in FAT
                  // Store the result in this cache
                  fs_g_u8_current_cache = u8_i;
                  fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = 0xFF;   // invalid cache
8000d626:	e0 68 0f cc 	mov	r8,4044
                  // fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_cluster  = fs_g_cluster.u32_pos;  // It is the same cluster start

                  // Get cache information to take time during the next FAT access
                  // Compute the cluster number corresponding at the last cluster of the cluster list cache
                  fs_g_cluster.u32_pos     = ((fs_g_cache_clusterlist[u8_i].u32_addr -fs_g_nav.u32_ptr_fat - fs_g_nav.u32_offset_data + fs_g_cache_clusterlist[u8_i].u32_size -1)
8000d62a:	70 08       	ld.w	r8,r8[0x0]
8000d62c:	8d 08       	st.w	r6[0x0],r8
8000d62e:	e0 6e 0f 7c 	mov	lr,3964
                                             / fs_g_nav.u8_BPB_SecPerClus) +2;
                  u32_tmp  = fs_g_seg.u32_size_or_pos;                                 // save position ask
                  // Compute the position of the end of cluster list cache, and decrement the position asked
                  fs_g_seg.u32_size_or_pos-= ((fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start + fs_g_cache_clusterlist[u8_i].u32_size -1)
8000d632:	31 a8       	mov	r8,26
                  fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = 0xFF;   // invalid cache
                  // fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_cluster  = fs_g_cluster.u32_pos;  // It is the same cluster start

                  // Get cache information to take time during the next FAT access
                  // Compute the cluster number corresponding at the last cluster of the cluster list cache
                  fs_g_cluster.u32_pos     = ((fs_g_cache_clusterlist[u8_i].u32_addr -fs_g_nav.u32_ptr_fat - fs_g_nav.u32_offset_data + fs_g_cache_clusterlist[u8_i].u32_size -1)
8000d634:	8d 17       	st.w	r6[0x4],r7
                                             / fs_g_nav.u8_BPB_SecPerClus) +2;
                  u32_tmp  = fs_g_seg.u32_size_or_pos;                                 // save position ask
                  // Compute the position of the end of cluster list cache, and decrement the position asked
                  fs_g_seg.u32_size_or_pos-= ((fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start + fs_g_cache_clusterlist[u8_i].u32_size -1)
8000d636:	bc 88       	st.b	lr[0x0],r8
                                             / fs_g_nav.u8_BPB_SecPerClus)
                                             * fs_g_nav.u8_BPB_SecPerClus;
                  fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start = u32_tmp;   // Update cache with the position asked
8000d638:	30 0c       	mov	r12,0
                  fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = 0xFF;   // invalid cache
                  // fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_cluster  = fs_g_cluster.u32_pos;  // It is the same cluster start

                  // Get cache information to take time during the next FAT access
                  // Compute the cluster number corresponding at the last cluster of the cluster list cache
                  fs_g_cluster.u32_pos     = ((fs_g_cache_clusterlist[u8_i].u32_addr -fs_g_nav.u32_ptr_fat - fs_g_nav.u32_offset_data + fs_g_cache_clusterlist[u8_i].u32_size -1)
8000d63a:	fe 9f fe 1a 	bral	8000d26e <fat_cluster_list+0x1b2>
                                             / fs_g_nav.u8_BPB_SecPerClus) +2;
                  u32_tmp  = fs_g_seg.u32_size_or_pos;                                 // save position ask
                  // Compute the position of the end of cluster list cache, and decrement the position asked
                  fs_g_seg.u32_size_or_pos-= ((fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start + fs_g_cache_clusterlist[u8_i].u32_size -1)
8000d63e:	e0 6c 0c e8 	mov	r12,3304
                  fat_cache_clusterlist_update_select();
                  return true;   // the segment is in cluster list cache
               }else{
                  //** It is after the cache then get cache information and continue to read the cluster list in FAT
                  // Store the result in this cache
                  fs_g_u8_current_cache = u8_i;
8000d642:	78 0b       	ld.w	r11,r12[0x0]
                  // Compute the cluster number corresponding at the last cluster of the cluster list cache
                  fs_g_cluster.u32_pos     = ((fs_g_cache_clusterlist[u8_i].u32_addr -fs_g_nav.u32_ptr_fat - fs_g_nav.u32_offset_data + fs_g_cache_clusterlist[u8_i].u32_size -1)
                                             / fs_g_nav.u8_BPB_SecPerClus) +2;
                  u32_tmp  = fs_g_seg.u32_size_or_pos;                                 // save position ask
                  // Compute the position of the end of cluster list cache, and decrement the position asked
                  fs_g_seg.u32_size_or_pos-= ((fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start + fs_g_cache_clusterlist[u8_i].u32_size -1)
8000d644:	09 8c       	ld.ub	r12,r4[0x0]
8000d646:	cc aa       	rjmp	8000d3da <fat_cluster_list+0x31e>
                  fat_cache_clusterlist_update_select();
                  return true;   // the segment is in cluster list cache
               }else{
                  //** It is after the cache then get cache information and continue to read the cluster list in FAT
                  // Store the result in this cache
                  fs_g_u8_current_cache = u8_i;
8000d648:	3f f9       	mov	r9,-1
                  // Compute the cluster number corresponding at the last cluster of the cluster list cache
                  fs_g_cluster.u32_pos     = ((fs_g_cache_clusterlist[u8_i].u32_addr -fs_g_nav.u32_ptr_fat - fs_g_nav.u32_offset_data + fs_g_cache_clusterlist[u8_i].u32_size -1)
                                             / fs_g_nav.u8_BPB_SecPerClus) +2;
                  u32_tmp  = fs_g_seg.u32_size_or_pos;                                 // save position ask
                  // Compute the position of the end of cluster list cache, and decrement the position asked
                  fs_g_seg.u32_size_or_pos-= ((fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start + fs_g_cache_clusterlist[u8_i].u32_size -1)
8000d64a:	b8 a9       	st.b	r12[0x2],r9
8000d64c:	40 59       	lddsp	r9,sp[0x14]
                  fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = 0xFF;   // invalid cache
                  // fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_cluster  = fs_g_cluster.u32_pos;  // It is the same cluster start

                  // Get cache information to take time during the next FAT access
                  // Compute the cluster number corresponding at the last cluster of the cluster list cache
                  fs_g_cluster.u32_pos     = ((fs_g_cache_clusterlist[u8_i].u32_addr -fs_g_nav.u32_ptr_fat - fs_g_nav.u32_offset_data + fs_g_cache_clusterlist[u8_i].u32_size -1)
8000d64e:	78 32       	ld.w	r2,r12[0xc]
                                             / fs_g_nav.u8_BPB_SecPerClus) +2;
                  u32_tmp  = fs_g_seg.u32_size_or_pos;                                 // save position ask
                  // Compute the position of the end of cluster list cache, and decrement the position asked
                  fs_g_seg.u32_size_or_pos-= ((fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start + fs_g_cache_clusterlist[u8_i].u32_size -1)
8000d650:	72 0e       	ld.w	lr,r9[0x0]
8000d652:	f8 cb ff f8 	sub	r11,r12,-8
8000d656:	0b 99       	ld.ub	r9,r5[0x1]
                  fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = 0xFF;   // invalid cache
                  // fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_cluster  = fs_g_cluster.u32_pos;  // It is the same cluster start

                  // Get cache information to take time during the next FAT access
                  // Compute the cluster number corresponding at the last cluster of the cluster list cache
                  fs_g_cluster.u32_pos     = ((fs_g_cache_clusterlist[u8_i].u32_addr -fs_g_nav.u32_ptr_fat - fs_g_nav.u32_offset_data + fs_g_cache_clusterlist[u8_i].u32_size -1)
8000d658:	76 0c       	ld.w	r12,r11[0x0]
                                             / fs_g_nav.u8_BPB_SecPerClus) +2;
                  u32_tmp  = fs_g_seg.u32_size_or_pos;                                 // save position ask
                  // Compute the position of the end of cluster list cache, and decrement the position asked
                  fs_g_seg.u32_size_or_pos-= ((fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start + fs_g_cache_clusterlist[u8_i].u32_size -1)
8000d65a:	97 0a       	st.w	r11[0x0],r10
                  fat_cache_clusterlist_update_select();
                  return true;   // the segment is in cluster list cache
               }else{
                  //** It is after the cache then get cache information and continue to read the cluster list in FAT
                  // Store the result in this cache
                  fs_g_u8_current_cache = u8_i;
8000d65c:	fc 02 00 02 	add	r2,lr,r2
                  fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = 0xFF;   // invalid cache
                  // fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_cluster  = fs_g_cluster.u32_pos;  // It is the same cluster start

                  // Get cache information to take time during the next FAT access
                  // Compute the cluster number corresponding at the last cluster of the cluster list cache
                  fs_g_cluster.u32_pos     = ((fs_g_cache_clusterlist[u8_i].u32_addr -fs_g_nav.u32_ptr_fat - fs_g_nav.u32_offset_data + fs_g_cache_clusterlist[u8_i].u32_size -1)
8000d660:	fc 0c 00 0c 	add	r12,lr,r12
8000d664:	e0 6e 0f 7e 	mov	lr,3966
8000d668:	f8 c1 00 01 	sub	r1,r12,1
8000d66c:	bc 88       	st.b	lr[0x0],r8
8000d66e:	e2 09 0d 00 	divu	r0,r1,r9
8000d672:	6a 58       	ld.w	r8,r5[0x14]
8000d674:	f2 00 02 4b 	mul	r11,r9,r0
8000d678:	f4 0b 01 0b 	sub	r11,r10,r11
8000d67c:	20 12       	sub	r2,1
8000d67e:	8d 1b       	st.w	r6[0x4],r11
8000d680:	50 6e       	stdsp	sp[0x18],lr
8000d682:	6a 4b       	ld.w	r11,r5[0x10]
8000d684:	e4 0b 01 0b 	sub	r11,r2,r11
8000d688:	10 1b       	sub	r11,r8
8000d68a:	f6 09 0d 0a 	divu	r10,r11,r9
8000d68e:	f4 c8 ff fe 	sub	r8,r10,-2
8000d692:	8f 08       	st.w	r7[0x0],r8
8000d694:	fe 9f fd 4f 	bral	8000d132 <fat_cluster_list+0x76>

8000d698 <fat_read_dir>:
8000d698:	eb cd 40 fe 	pushm	r1-r7,lr
8000d69c:	e0 68 0f 78 	mov	r8,3960
8000d6a0:	e0 67 0f b4 	mov	r7,4020
8000d6a4:	90 95       	ld.uh	r5,r8[0x2]
8000d6a6:	e0 66 0f 2c 	mov	r6,3884
8000d6aa:	a5 85       	lsr	r5,0x4
8000d6ac:	0f 89       	ld.ub	r9,r7[0x0]
8000d6ae:	0d 88       	ld.ub	r8,r6[0x0]
8000d6b0:	f0 09 18 00 	cp.b	r9,r8
8000d6b4:	c0 d0       	breq	8000d6ce <fat_read_dir+0x36>
8000d6b6:	6c 88       	ld.w	r8,r6[0x20]
8000d6b8:	e0 64 0f d4 	mov	r4,4052
8000d6bc:	30 0b       	mov	r11,0
8000d6be:	89 08       	st.w	r4[0x0],r8
   }

   // Get sector address corresponding at cluster list position
   fs_g_seg.u32_addr = fs_g_nav.u32_cluster_sel_dir;
   fs_g_seg.u32_size_or_pos = u32_cluster_pos;
   if( fat_cluster_list( FS_CLUST_ACT_ONE, false ) )
8000d6c0:	89 15       	st.w	r4[0x4],r5
         fs_g_sectorcache.u32_clusterlist_pos    = u32_cluster_pos;
         return true;
      }
   }
   return false;
}
8000d6c2:	30 2c       	mov	r12,2
8000d6c4:	fe b0 fc fc 	rcall	8000d0bc <fat_cluster_list>

   // Compute the cluster list position corresponding of the current entry
   u32_cluster_pos = fs_g_nav_fast.u16_entry_pos_sel_file >> (FS_512B_SHIFT_BIT - FS_SHIFT_B_TO_FILE_ENTRY);

   if( (fs_g_sectorcache.u8_lun                 == fs_g_nav.u8_lun )
   &&  (fs_g_sectorcache.u32_clusterlist_start  == fs_g_nav.u32_cluster_sel_dir )
8000d6c8:	c0 91       	brne	8000d6da <fat_read_dir+0x42>
   uint32_t u32_cluster_pos;

   // Compute the cluster list position corresponding of the current entry
   u32_cluster_pos = fs_g_nav_fast.u16_entry_pos_sel_file >> (FS_512B_SHIFT_BIT - FS_SHIFT_B_TO_FILE_ENTRY);

   if( (fs_g_sectorcache.u8_lun                 == fs_g_nav.u8_lun )
8000d6ca:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000d6ce:	6e 38       	ld.w	r8,r7[0xc]
8000d6d0:	6c 89       	ld.w	r9,r6[0x20]
   fs_g_seg.u32_addr = fs_g_nav.u32_cluster_sel_dir;
   fs_g_seg.u32_size_or_pos = u32_cluster_pos;
   if( fat_cluster_list( FS_CLUST_ACT_ONE, false ) )
   {
      // Read the sector
      fs_gu32_addrsector = fs_g_seg.u32_addr;
8000d6d2:	12 38       	cp.w	r8,r9
8000d6d4:	c3 70       	breq	8000d742 <fat_read_dir+0xaa>
8000d6d6:	12 98       	mov	r8,r9
//! @endverbatim
//!
bool  fat_cache_read_sector( bool b_load )
{
   // Check if the sector asked is the same in cache
   if( (fs_g_sectorcache.u8_lun     == fs_g_nav.u8_lun )
8000d6d8:	cf 0b       	rjmp	8000d6b8 <fat_read_dir+0x20>
8000d6da:	68 0b       	ld.w	r11,r4[0x0]
8000d6dc:	e0 64 0c e8 	mov	r4,3304
8000d6e0:	89 0b       	st.w	r4[0x0],r11
//! @return    true otherwise
//!
bool  fat_cache_flush( void )
{
   // If the cache is modified, then write the sector cache on the device
   if ( true == fs_g_sectorcache.u8_dirty )
8000d6e2:	0d 8c       	ld.ub	r12,r6[0x0]
8000d6e4:	0f 88       	ld.ub	r8,r7[0x0]
8000d6e6:	f8 08 18 00 	cp.b	r8,r12
8000d6ea:	c1 f0       	breq	8000d728 <fat_read_dir+0x90>
8000d6ec:	ef 33 00 08 	ld.ub	r3,r7[8]

//! This function resets the sector cache
//!
void  fat_cache_reset( void )
{
   fs_g_sectorcache.u8_lun                = FS_BUF_SECTOR_EMPTY;
8000d6f0:	e0 61 0f b4 	mov	r1,4020
   fs_g_sectorcache.u8_dirty              = false;
8000d6f4:	30 18       	mov	r8,1
8000d6f6:	f0 03 18 00 	cp.b	r3,r8
   fs_g_sectorcache.u32_clusterlist_start = 0xFFFFFFFF;
8000d6fa:	c2 90       	breq	8000d74c <fat_read_dir+0xb4>

   // Delete informations about the caches
   fat_cache_reset();

   // Init sector cache
   fs_g_sectorcache.u32_addr = fs_gu32_addrsector;
8000d6fc:	3f f8       	mov	r8,-1
//!
void  fat_cache_reset( void )
{
   fs_g_sectorcache.u8_lun                = FS_BUF_SECTOR_EMPTY;
   fs_g_sectorcache.u8_dirty              = false;
   fs_g_sectorcache.u32_clusterlist_start = 0xFFFFFFFF;
8000d6fe:	ae 88       	st.b	r7[0x0],r8
   // Init sector cache
   fs_g_sectorcache.u32_addr = fs_gu32_addrsector;
   if( b_load )
   {
      // Load the sector from memory
      if( CTRL_GOOD != memory_2_ram( fs_g_nav.u8_lun  , fs_g_sectorcache.u32_addr, fs_g_sector))
8000d700:	30 08       	mov	r8,0
8000d702:	ef 68 00 08 	st.b	r7[8],r8
8000d706:	3f f8       	mov	r8,-1
         fs_g_status = FS_ERR_HW;
         return false;
      }
   }
   // Valid sector cache
   fs_g_sectorcache.u8_lun = fs_g_nav.u8_lun;
8000d708:	8f 1b       	st.w	r7[0x4],r11
8000d70a:	8f 38       	st.w	r7[0xc],r8
8000d70c:	e0 6a 0d 2c 	mov	r10,3372
      fs_gu32_addrsector = fs_g_seg.u32_addr;
      if( fat_cache_read_sector( true ) )
      {
         // Update information about internal sector cache
         fs_g_sectorcache.u32_clusterlist_start  = fs_g_nav.u32_cluster_sel_dir;
         fs_g_sectorcache.u32_clusterlist_pos    = u32_cluster_pos;
8000d710:	e0 a0 0a 04 	rcall	8000eb18 <memory_2_ram>
8000d714:	c1 01       	brne	8000d734 <fat_read_dir+0x9c>
         return true;
8000d716:	0d 89       	ld.ub	r9,r6[0x0]
//! @endverbatim
//!
bool  fat_cache_read_sector( bool b_load )
{
   // Check if the sector asked is the same in cache
   if( (fs_g_sectorcache.u8_lun     == fs_g_nav.u8_lun )
8000d718:	e0 68 0f b4 	mov	r8,4020
8000d71c:	b0 89       	st.b	r8[0x0],r9
8000d71e:	6c 88       	ld.w	r8,r6[0x20]
8000d720:	8f 45       	st.w	r7[0x10],r5
   if( b_load )
   {
      // Load the sector from memory
      if( CTRL_GOOD != memory_2_ram( fs_g_nav.u8_lun  , fs_g_sectorcache.u32_addr, fs_g_sector))
      {
         fs_g_status = FS_ERR_HW;
8000d722:	8f 38       	st.w	r7[0xc],r8
8000d724:	30 1c       	mov	r12,1
8000d726:	cd 2b       	rjmp	8000d6ca <fat_read_dir+0x32>
8000d728:	e0 68 0f b4 	mov	r8,4020
8000d72c:	70 18       	ld.w	r8,r8[0x4]
   uint32_t u32_cluster_pos;

   // Compute the cluster list position corresponding of the current entry
   u32_cluster_pos = fs_g_nav_fast.u16_entry_pos_sel_file >> (FS_512B_SHIFT_BIT - FS_SHIFT_B_TO_FILE_ENTRY);

   if( (fs_g_sectorcache.u8_lun                 == fs_g_nav.u8_lun )
8000d72e:	10 3b       	cp.w	r11,r8
8000d730:	cd e1       	brne	8000d6ec <fat_read_dir+0x54>
8000d732:	cf 6b       	rjmp	8000d71e <fat_read_dir+0x86>
8000d734:	30 19       	mov	r9,1
8000d736:	e0 68 0f 7c 	mov	r8,3964
{
   // If the cache is modified, then write the sector cache on the device
   if ( true == fs_g_sectorcache.u8_dirty )
   {
      fs_g_sectorcache.u8_dirty = false; // Always clear, although an error occur
      if( mem_wr_protect( fs_g_sectorcache.u8_lun  ))
8000d73a:	30 0c       	mov	r12,0
bool  fat_cache_flush( void )
{
   // If the cache is modified, then write the sector cache on the device
   if ( true == fs_g_sectorcache.u8_dirty )
   {
      fs_g_sectorcache.u8_dirty = false; // Always clear, although an error occur
8000d73c:	b0 89       	st.b	r8[0x0],r9
8000d73e:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
      if( mem_wr_protect( fs_g_sectorcache.u8_lun  ))
8000d742:	6e 49       	ld.w	r9,r7[0x10]
8000d744:	0a 39       	cp.w	r9,r5
8000d746:	cb 91       	brne	8000d6b8 <fat_read_dir+0x20>
      {
         fs_g_status = FS_LUN_WP;
8000d748:	e3 cf 90 fe 	ldm	sp++,r1-r7,pc,r12=1
8000d74c:	30 08       	mov	r8,0
8000d74e:	03 8c       	ld.ub	r12,r1[0x0]
8000d750:	e3 68 00 08 	st.b	r1[8],r8
         return false;
      }
      if (CTRL_GOOD != ram_2_memory( fs_g_sectorcache.u8_lun , fs_g_sectorcache.u32_addr , fs_g_sector ))
8000d754:	e0 a0 09 da 	rcall	8000eb08 <mem_wr_protect>
8000d758:	18 92       	mov	r2,r12
8000d75a:	c0 80       	breq	8000d76a <fat_read_dir+0xd2>
8000d75c:	31 49       	mov	r9,20
8000d75e:	e0 68 0f 7c 	mov	r8,3964
      {
         fs_g_status = FS_ERR_HW;
8000d762:	30 0c       	mov	r12,0
8000d764:	b0 89       	st.b	r8[0x0],r9
8000d766:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
      if( mem_wr_protect( fs_g_sectorcache.u8_lun  ))
      {
         fs_g_status = FS_LUN_WP;
         return false;
      }
      if (CTRL_GOOD != ram_2_memory( fs_g_sectorcache.u8_lun , fs_g_sectorcache.u32_addr , fs_g_sector ))
8000d76a:	03 8c       	ld.ub	r12,r1[0x0]
8000d76c:	e0 6a 0d 2c 	mov	r10,3372
8000d770:	62 1b       	ld.w	r11,r1[0x4]
8000d772:	e0 a0 09 dd 	rcall	8000eb2c <ram_2_memory>
8000d776:	c0 70       	breq	8000d784 <fat_read_dir+0xec>
8000d778:	e0 68 0f 7c 	mov	r8,3964
8000d77c:	04 9c       	mov	r12,r2
8000d77e:	b0 83       	st.b	r8[0x0],r3
8000d780:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000d784:	68 0b       	ld.w	r11,r4[0x0]
8000d786:	0d 8c       	ld.ub	r12,r6[0x0]
8000d788:	cb ab       	rjmp	8000d6fc <fat_read_dir+0x64>
8000d78a:	d7 03       	nop

8000d78c <fat_read_file>:
8000d78c:	d4 21       	pushm	r4-r7,lr
8000d78e:	e0 66 0c ec 	mov	r6,3308
8000d792:	18 97       	mov	r7,r12
8000d794:	6c 38       	ld.w	r8,r6[0xc]
8000d796:	30 29       	mov	r9,2
8000d798:	f0 05 16 09 	lsr	r5,r8,0x9
   uint32_t   u32_sector_pos;

   // Compute sector position
   u32_sector_pos = fs_g_nav_entry.u32_pos_in_file >> FS_512B_SHIFT_BIT;

   if(FS_CLUST_ACT_ONE  == mode)
8000d79c:	f2 0c 18 00 	cp.b	r12,r9
         return true;      // The internal cache contains the sector requested
      }
   }
   else
   {
      if( FS_CLUST_ACT_CLR == mode )
8000d7a0:	c1 80       	breq	8000d7d0 <fat_read_file+0x44>
8000d7a2:	30 39       	mov	r9,3
8000d7a4:	f2 0c 18 00 	cp.b	r12,r9
//! IN :
//!   fs_g_nav_entry.u32_cluster       First cluster of selected file
//!   fs_g_nav_entry.u32_pos_in_file   Position in file (unit byte)
//! @endverbatim
//!
bool  fat_read_file( uint8_t mode )
8000d7a8:	c1 00       	breq	8000d7c8 <fat_read_file+0x3c>
         }
      }
   }

   // Get the segment which start at the current position
   fs_g_seg.u32_addr = fs_g_nav_entry.u32_cluster;
8000d7aa:	6c 19       	ld.w	r9,r6[0x4]
   fs_g_seg.u32_size_or_pos = u32_sector_pos;
   if( FS_CLUST_ACT_ONE != mode )
   {
      if( fat_cluster_list( mode, true ) )
8000d7ac:	e0 68 0f d4 	mov	r8,4052
         }
      }
   }

   // Get the segment which start at the current position
   fs_g_seg.u32_addr = fs_g_nav_entry.u32_cluster;
8000d7b0:	30 1b       	mov	r11,1
   fs_g_seg.u32_size_or_pos = u32_sector_pos;
   if( FS_CLUST_ACT_ONE != mode )
   {
      if( fat_cluster_list( mode, true ) )
8000d7b2:	91 15       	st.w	r8[0x4],r5
8000d7b4:	91 09       	st.w	r8[0x0],r9
8000d7b6:	0e 9c       	mov	r12,r7
8000d7b8:	fe b0 fc 82 	rcall	8000d0bc <fat_cluster_list>
            fs_g_sectorcache.u32_clusterlist_pos    = u32_sector_pos;
            return true;
         }
      }
   }
   if( (FS_CLUST_ACT_CLR == mode       )
8000d7bc:	c0 91       	brne	8000d7ce <fat_read_file+0x42>
8000d7be:	30 38       	mov	r8,3
8000d7c0:	f0 07 18 00 	cp.b	r7,r8
   else
   {
      if( FS_CLUST_ACT_CLR == mode )
      {
         // Clear cluster list
         if( 0 == fs_g_nav_entry.u32_cluster )
8000d7c4:	c2 90       	breq	8000d816 <fat_read_file+0x8a>
8000d7c6:	d8 2a       	popm	r4-r7,pc,r12=0
8000d7c8:	6c 19       	ld.w	r9,r6[0x4]
//! IN :
//!   fs_g_nav_entry.u32_cluster       First cluster of selected file
//!   fs_g_nav_entry.u32_pos_in_file   Position in file (unit byte)
//! @endverbatim
//!
bool  fat_read_file( uint8_t mode )
8000d7ca:	58 09       	cp.w	r9,0
   // Compute sector position
   u32_sector_pos = fs_g_nav_entry.u32_pos_in_file >> FS_512B_SHIFT_BIT;

   if(FS_CLUST_ACT_ONE  == mode)
   {
      if( (fs_g_sectorcache.u8_lun                 == fs_g_nav.u8_lun )
8000d7cc:	c2 01       	brne	8000d80c <fat_read_file+0x80>
8000d7ce:	da 2a       	popm	r4-r7,pc,r12=1
8000d7d0:	e0 67 0f b4 	mov	r7,4020
8000d7d4:	e0 68 0f 2c 	mov	r8,3884
8000d7d8:	0f 89       	ld.ub	r9,r7[0x0]
            return true;   // No cluster list is linked with the file, then no clear is necessary

         if(0 != (fs_g_nav_entry.u32_pos_in_file & FS_512B_MASK) )
         {
            // The actual sector is used, then start clear on the next sector
            u32_sector_pos++;
8000d7da:	11 88       	ld.ub	r8,r8[0x0]
         }
      }
   }

   // Get the segment which start at the current position
   fs_g_seg.u32_addr = fs_g_nav_entry.u32_cluster;
8000d7dc:	f0 09 18 00 	cp.b	r9,r8
8000d7e0:	c2 30       	breq	8000d826 <fat_read_file+0x9a>
   fs_g_seg.u32_size_or_pos = u32_sector_pos;
8000d7e2:	6c 18       	ld.w	r8,r6[0x4]
      if( fat_cluster_list( mode, true ) )
         return true;      // Get or clear segment OK
   }
   else
   {
      if( fat_cluster_list( FS_CLUST_ACT_SEG, true ) )   // Read all segment
8000d7e4:	e0 64 0f d4 	mov	r4,4052
8000d7e8:	30 1b       	mov	r11,1
8000d7ea:	89 08       	st.w	r4[0x0],r8
      {
         // Read the sector corresponding at the position file (= first sector of segment)
         fs_gu32_addrsector = fs_g_seg.u32_addr ;
8000d7ec:	89 15       	st.w	r4[0x4],r5
8000d7ee:	16 9c       	mov	r12,r11
8000d7f0:	fe b0 fc 66 	rcall	8000d0bc <fat_cluster_list>
         if( fat_cache_read_sector( true ) )
8000d7f4:	ce 90       	breq	8000d7c6 <fat_read_file+0x3a>
8000d7f6:	68 09       	ld.w	r9,r4[0x0]
         {
            fs_g_sectorcache.u32_clusterlist_start  = fs_g_nav_entry.u32_cluster;
8000d7f8:	e0 68 0c e8 	mov	r8,3304
8000d7fc:	91 09       	st.w	r8[0x0],r9
            fs_g_sectorcache.u32_clusterlist_pos    = u32_sector_pos;
8000d7fe:	fe b0 f8 49 	rcall	8000c890 <T.78>
      {
         // Clear cluster list
         if( 0 == fs_g_nav_entry.u32_cluster )
            return true;   // No cluster list is linked with the file, then no clear is necessary

         if(0 != (fs_g_nav_entry.u32_pos_in_file & FS_512B_MASK) )
8000d802:	ce 20       	breq	8000d7c6 <fat_read_file+0x3a>
8000d804:	6c 18       	ld.w	r8,r6[0x4]
         {
            // The actual sector is used, then start clear on the next sector
            u32_sector_pos++;
8000d806:	8f 45       	st.w	r7[0x10],r5
8000d808:	8f 38       	st.w	r7[0xc],r8
//! IN :
//!   fs_g_nav_entry.u32_cluster       First cluster of selected file
//!   fs_g_nav_entry.u32_pos_in_file   Position in file (unit byte)
//! @endverbatim
//!
bool  fat_read_file( uint8_t mode )
8000d80a:	da 2a       	popm	r4-r7,pc,r12=1
8000d80c:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
8000d810:	cc e0       	breq	8000d7ac <fat_read_file+0x20>
8000d812:	2f f5       	sub	r5,-1
8000d814:	cc cb       	rjmp	8000d7ac <fat_read_file+0x20>
8000d816:	e0 68 0f 7c 	mov	r8,3964
   u32_sector_pos = fs_g_nav_entry.u32_pos_in_file >> FS_512B_SHIFT_BIT;

   if(FS_CLUST_ACT_ONE  == mode)
   {
      if( (fs_g_sectorcache.u8_lun                 == fs_g_nav.u8_lun )
      &&  (fs_g_sectorcache.u32_clusterlist_start  == fs_g_nav_entry.u32_cluster )
8000d81a:	11 89       	ld.ub	r9,r8[0x0]
   // Compute sector position
   u32_sector_pos = fs_g_nav_entry.u32_pos_in_file >> FS_512B_SHIFT_BIT;

   if(FS_CLUST_ACT_ONE  == mode)
   {
      if( (fs_g_sectorcache.u8_lun                 == fs_g_nav.u8_lun )
8000d81c:	31 a8       	mov	r8,26
8000d81e:	f0 09 18 00 	cp.b	r9,r8
8000d822:	5f 0c       	sreq	r12
8000d824:	d8 22       	popm	r4-r7,pc
8000d826:	6e 38       	ld.w	r8,r7[0xc]
8000d828:	6c 19       	ld.w	r9,r6[0x4]
8000d82a:	12 38       	cp.w	r8,r9
8000d82c:	c0 30       	breq	8000d832 <fat_read_file+0xa6>
8000d82e:	12 98       	mov	r8,r9
8000d830:	cd ab       	rjmp	8000d7e4 <fat_read_file+0x58>
8000d832:	6e 49       	ld.w	r9,r7[0x10]
8000d834:	0a 39       	cp.w	r9,r5
8000d836:	cd 71       	brne	8000d7e4 <fat_read_file+0x58>
8000d838:	cc bb       	rjmp	8000d7ce <fat_read_file+0x42>
8000d83a:	d7 03       	nop

8000d83c <fat_check_mount_select_noopen>:
8000d83c:	d4 31       	pushm	r0-r7,lr
8000d83e:	e0 64 0c fe 	mov	r4,3326
8000d842:	30 08       	mov	r8,0
8000d844:	09 89       	ld.ub	r9,r4[0x0]
8000d846:	f0 09 18 00 	cp.b	r9,r8
8000d84a:	c4 11       	brne	8000d8cc <fat_check_mount_select_noopen+0x90>

   // Possibility to ignore the disk check. Used to take time during multi read/write access
   if( g_b_no_check_disk )
      return true;

   if( 0xFF == fs_g_nav.u8_lun )
8000d84c:	e0 63 0f 2c 	mov	r3,3884
8000d850:	3f f6       	mov	r6,-1
8000d852:	07 89       	ld.ub	r9,r3[0x0]
8000d854:	ec 09 18 00 	cp.b	r9,r6
   {
      fs_g_status = FS_ERR_HW;
8000d858:	e0 80 00 8e 	breq	8000d974 <fat_check_mount_select_noopen+0x138>
      if( CTRL_GOOD       == status )
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
8000d85c:	30 01       	mov	r1,0
      Fat_file_close();                            // By default the file is not open
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
8000d85e:	e0 65 0f 78 	mov	r5,3960
   }

   for( retry=0 ; retry<100 ; retry++ )
   {
      // Check device
      status = mem_test_unit_ready( fs_g_nav.u8_lun );
8000d862:	02 97       	mov	r7,r1
8000d864:	e0 60 0f 80 	mov	r0,3968
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
8000d868:	e0 62 0f b4 	mov	r2,4020
      {
         fat_cache_reset();
      }
      fat_cache_clusterlist_reset();

      fs_g_status = FS_ERR_HW;                     // By default HW error
8000d86c:	12 9c       	mov	r12,r9

   for( retry=0 ; retry<100 ; retry++ )
   {
      // Check device
      status = mem_test_unit_ready( fs_g_nav.u8_lun );
      if( CTRL_GOOD       == status )
8000d86e:	e0 a0 09 41 	rcall	8000eaf0 <mem_test_unit_ready>
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
      Fat_file_close();                            // By default the file is not open
8000d872:	e0 68 0d 00 	mov	r8,3328
8000d876:	30 1a       	mov	r10,1
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
8000d878:	e0 6b 0f 7c 	mov	r11,3964
8000d87c:	58 0c       	cp.w	r12,0
8000d87e:	c2 90       	breq	8000d8d0 <fat_check_mount_select_noopen+0x94>
8000d880:	e0 6e 0c ec 	mov	lr,3308

//! This function resets the sector cache
//!
void  fat_cache_reset( void )
{
   fs_g_sectorcache.u8_lun                = FS_BUF_SECTOR_EMPTY;
8000d884:	aa 87       	st.b	r5[0x0],r7
8000d886:	bc 87       	st.b	lr[0x0],r7
8000d888:	07 89       	ld.ub	r9,r3[0x0]
8000d88a:	01 8e       	ld.ub	lr,r0[0x0]
   fs_g_sectorcache.u8_dirty              = false;
8000d88c:	f2 0e 18 00 	cp.b	lr,r9
   fs_g_sectorcache.u32_clusterlist_start = 0xFFFFFFFF;
8000d890:	c7 e0       	breq	8000d98c <fat_check_mount_select_noopen+0x150>
8000d892:	05 8e       	ld.ub	lr,r2[0x0]
8000d894:	f2 0e 18 00 	cp.b	lr,r9
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
      fs_g_cache_clusterlist[u8_i].u8_level_use = 0xFF;
8000d898:	e5 f6 0e 00 	st.beq	r2[0x0],r6
      {
         fat_cache_reset();
      }
      fat_cache_clusterlist_reset();

      fs_g_status = FS_ERR_HW;                     // By default HW error
8000d89c:	e5 f7 0e 08 	st.beq	r2[0x8],r7
//! This function resets the cluster list caches
//!
void  fat_cache_clusterlist_reset( void )
{
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
8000d8a0:	f9 be 00 ff 	moveq	lr,-1
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
8000d8a4:	e5 fe 0a 03 	st.weq	r2[0xc],lr
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
8000d8a8:	f1 66 00 15 	st.b	r8[21],r6
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
8000d8ac:	b6 8a       	st.b	r11[0x0],r10
8000d8ae:	e0 6e 0f 7e 	mov	lr,3966
         fat_cache_reset();
      }
      fat_cache_clusterlist_reset();

      fs_g_status = FS_ERR_HW;                     // By default HW error
      if( CTRL_BUSY == status )
8000d8b2:	bc 87       	st.b	lr[0x0],r7
         continue;                                 // If device busy then retry

      if( CTRL_NO_PRESENT == status )
8000d8b4:	b0 8a       	st.b	r8[0x0],r10
8000d8b6:	b0 a6       	st.b	r8[0x2],r6
      return true;
   if (FS_TYPE_FAT_UNM == fs_g_nav_fast.u8_type_fat)
      return true;
   if( Fat_file_is_open() )
   {
      fs_g_status = FS_ERR_TOO_FILE_OPEN;  // The navigation have already open a file
8000d8b8:	b0 96       	st.b	r8[0x1],r6
8000d8ba:	f1 67 00 14 	st.b	r8[20],r7
//!
bool  fat_check_mount( void )
{
   if( !fat_check_device() )
      return false;
   if (FS_TYPE_FAT_UNM == fs_g_nav_fast.u8_type_fat)
8000d8be:	f1 66 00 16 	st.b	r8[22],r6
8000d8c2:	58 3c       	cp.w	r12,3
8000d8c4:	c5 e0       	breq	8000d980 <fat_check_mount_select_noopen+0x144>
//! @return    true  a file is selected
//! @return    false otherwise
//!
bool  fat_check_select( void )
{
   if (FS_NO_SEL == fs_g_nav_fast.u16_entry_pos_sel_file)
8000d8c6:	58 2c       	cp.w	r12,2
8000d8c8:	c6 f0       	breq	8000d9a6 <fat_check_mount_select_noopen+0x16a>
8000d8ca:	d8 3a       	popm	r0-r7,pc,r12=0
8000d8cc:	e0 65 0f 78 	mov	r5,3960
   uint8_t i;
#endif
   Ctrl_status status;

   // Possibility to ignore the disk check. Used to take time during multi read/write access
   if( g_b_no_check_disk )
8000d8d0:	0b 89       	ld.ub	r9,r5[0x0]
8000d8d2:	30 08       	mov	r8,0
8000d8d4:	f0 09 18 00 	cp.b	r9,r8
8000d8d8:	c4 70       	breq	8000d966 <fat_check_mount_select_noopen+0x12a>
      return true;

   if( 0xFF == fs_g_nav.u8_lun )
8000d8da:	8a 18       	ld.sh	r8,r5[0x2]
8000d8dc:	3f f6       	mov	r6,-1
8000d8de:	ec 08 19 00 	cp.h	r8,r6
8000d8e2:	c5 c0       	breq	8000d99a <fat_check_mount_select_noopen+0x15e>
   {
      fs_g_status = FS_ERR_HW;
8000d8e4:	09 89       	ld.ub	r9,r4[0x0]
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
      Fat_file_close();                            // By default the file is not open
8000d8e6:	30 08       	mov	r8,0
      if( CTRL_GOOD       == status )
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
8000d8e8:	f0 09 18 00 	cp.b	r9,r8
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
         }
      }
#endif
      // If the internal cache corresponding at device then clean it
      if( fs_g_nav.u8_lun == fs_g_sectorcache.u8_lun )
8000d8ec:	c6 11       	brne	8000d9ae <fat_check_mount_select_noopen+0x172>
   }

   for( retry=0 ; retry<100 ; retry++ )
   {
      // Check device
      status = mem_test_unit_ready( fs_g_nav.u8_lun );
8000d8ee:	e0 63 0f 2c 	mov	r3,3884
8000d8f2:	07 89       	ld.ub	r9,r3[0x0]
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
8000d8f4:	ec 09 18 00 	cp.b	r9,r6
      {
         fat_cache_reset();
      }
      fat_cache_clusterlist_reset();

      fs_g_status = FS_ERR_HW;                     // By default HW error
8000d8f8:	c6 c0       	breq	8000d9d0 <fat_check_mount_select_noopen+0x194>

   for( retry=0 ; retry<100 ; retry++ )
   {
      // Check device
      status = mem_test_unit_ready( fs_g_nav.u8_lun );
      if( CTRL_GOOD       == status )
8000d8fa:	30 02       	mov	r2,0
8000d8fc:	e0 60 0c ec 	mov	r0,3308
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
      Fat_file_close();                            // By default the file is not open
8000d900:	04 97       	mov	r7,r2
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
8000d902:	e0 61 0f 80 	mov	r1,3968
8000d906:	e0 64 0f b4 	mov	r4,4020
8000d90a:	12 9c       	mov	r12,r9
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
         }
      }
#endif
      // If the internal cache corresponding at device then clean it
      if( fs_g_nav.u8_lun == fs_g_sectorcache.u8_lun )
8000d90c:	e0 a0 08 f2 	rcall	8000eaf0 <mem_test_unit_ready>

//! This function resets the sector cache
//!
void  fat_cache_reset( void )
{
   fs_g_sectorcache.u8_lun                = FS_BUF_SECTOR_EMPTY;
8000d910:	e0 68 0d 00 	mov	r8,3328
8000d914:	30 1a       	mov	r10,1
   fs_g_sectorcache.u8_dirty              = false;
8000d916:	e0 6b 0f 7c 	mov	r11,3964
   fs_g_sectorcache.u32_clusterlist_start = 0xFFFFFFFF;
8000d91a:	58 0c       	cp.w	r12,0
8000d91c:	c4 90       	breq	8000d9ae <fat_check_mount_select_noopen+0x172>
8000d91e:	aa 87       	st.b	r5[0x0],r7
8000d920:	a0 87       	st.b	r0[0x0],r7
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
      fs_g_cache_clusterlist[u8_i].u8_level_use = 0xFF;
8000d922:	07 89       	ld.ub	r9,r3[0x0]
8000d924:	03 8e       	ld.ub	lr,r1[0x0]
      {
         fat_cache_reset();
      }
      fat_cache_clusterlist_reset();

      fs_g_status = FS_ERR_HW;                     // By default HW error
8000d926:	f2 0e 18 00 	cp.b	lr,r9
//! This function resets the cluster list caches
//!
void  fat_cache_clusterlist_reset( void )
{
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
8000d92a:	c5 e0       	breq	8000d9e6 <fat_check_mount_select_noopen+0x1aa>
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
8000d92c:	09 8e       	ld.ub	lr,r4[0x0]
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
8000d92e:	f2 0e 18 00 	cp.b	lr,r9
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
8000d932:	e9 f6 0e 00 	st.beq	r4[0x0],r6
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
8000d936:	e9 f7 0e 08 	st.beq	r4[0x8],r7
         fat_cache_reset();
      }
      fat_cache_clusterlist_reset();

      fs_g_status = FS_ERR_HW;                     // By default HW error
      if( CTRL_BUSY == status )
8000d93a:	f9 be 00 ff 	moveq	lr,-1
         continue;                                 // If device busy then retry

      if( CTRL_NO_PRESENT == status )
8000d93e:	e9 fe 0a 03 	st.weq	r4[0xc],lr
      return true;
   if (FS_TYPE_FAT_UNM == fs_g_nav_fast.u8_type_fat)
      return true;
   if( Fat_file_is_open() )
   {
      fs_g_status = FS_ERR_TOO_FILE_OPEN;  // The navigation have already open a file
8000d942:	f1 66 00 15 	st.b	r8[21],r6
{
   if( !fat_check_device() )
      return false;
   if (FS_TYPE_FAT_UNM == fs_g_nav_fast.u8_type_fat)
   {
      if( !fat_mount() )
8000d946:	b6 8a       	st.b	r11[0x0],r10
8000d948:	e0 6e 0f 7e 	mov	lr,3966
      {
         fs_g_status = FS_ERR_NO_MOUNT;
8000d94c:	bc 87       	st.b	lr[0x0],r7
8000d94e:	b0 8a       	st.b	r8[0x0],r10
8000d950:	b0 a6       	st.b	r8[0x2],r6
   if( g_b_no_check_disk )
      return true;

   if( 0xFF == fs_g_nav.u8_lun )
   {
      fs_g_status = FS_ERR_HW;
8000d952:	b0 96       	st.b	r8[0x1],r6
8000d954:	f1 67 00 14 	st.b	r8[20],r7
8000d958:	f1 66 00 16 	st.b	r8[22],r6
         fat_cache_reset();
      }
      fat_cache_clusterlist_reset();

      fs_g_status = FS_ERR_HW;                     // By default HW error
      if( CTRL_BUSY == status )
8000d95c:	58 3c       	cp.w	r12,3
   {
      fs_g_status = FS_ERR_HW;
      return false;                                // No device selected
   }

   for( retry=0 ; retry<100 ; retry++ )
8000d95e:	c3 f0       	breq	8000d9dc <fat_check_mount_select_noopen+0x1a0>
8000d960:	58 2c       	cp.w	r12,2
8000d962:	c4 90       	breq	8000d9f4 <fat_check_mount_select_noopen+0x1b8>
8000d964:	da 3a       	popm	r0-r7,pc,r12=1
8000d966:	cc 9c       	rcall	8000daf8 <fat_mount>
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
         {
            fs_g_navext_fast[i].u8_type_fat     = FS_TYPE_FAT_UNM;   // By default the fat isn't mounted
8000d968:	cb 91       	brne	8000d8da <fat_check_mount_select_noopen+0x9e>
8000d96a:	30 e9       	mov	r9,14
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
8000d96c:	e0 68 0f 7c 	mov	r8,3964
8000d970:	b0 89       	st.b	r8[0x0],r9
//!
bool  fat_check_select( void )
{
   if (FS_NO_SEL == fs_g_nav_fast.u16_entry_pos_sel_file)
   {
      fs_g_status = FS_ERR_NO_FILE_SEL;
8000d972:	d8 32       	popm	r0-r7,pc
8000d974:	30 19       	mov	r9,1
8000d976:	e0 68 0f 7c 	mov	r8,3964
8000d97a:	30 0c       	mov	r12,0
      fs_g_status = FS_ERR_HW;                     // By default HW error
      if( CTRL_BUSY == status )
         continue;                                 // If device busy then retry

      if( CTRL_NO_PRESENT == status )
         fs_g_status = FS_ERR_HW_NO_PRESENT;       // Update error flag
8000d97c:	b0 89       	st.b	r8[0x0],r9
8000d97e:	d8 32       	popm	r0-r7,pc
8000d980:	2f f1       	sub	r1,-1
8000d982:	e0 41 00 64 	cp.w	r1,100
//!
bool  fat_check_noopen( void )
{
   if( !fat_check_device() )
      return true;
   if (FS_TYPE_FAT_UNM == fs_g_nav_fast.u8_type_fat)
8000d986:	fe 91 ff 73 	brne	8000d86c <fat_check_mount_select_noopen+0x30>
8000d98a:	ca 0b       	rjmp	8000d8ca <fat_check_mount_select_noopen+0x8e>
8000d98c:	e0 6e 0f 74 	mov	lr,3956
      return true;
   if( Fat_file_is_open() )
8000d990:	bc 87       	st.b	lr[0x0],r7
8000d992:	e0 6e 0f 64 	mov	lr,3940
8000d996:	bc 87       	st.b	lr[0x0],r7
   {
      fs_g_status = FS_ERR_TOO_FILE_OPEN;  // The navigation have already open a file
8000d998:	c7 db       	rjmp	8000d892 <fat_check_mount_select_noopen+0x56>
8000d99a:	30 f9       	mov	r9,15
8000d99c:	e0 68 0f 7c 	mov	r8,3964
8000d9a0:	30 0c       	mov	r12,0
   if( g_b_no_check_disk )
      return true;

   if( 0xFF == fs_g_nav.u8_lun )
   {
      fs_g_status = FS_ERR_HW;
8000d9a2:	b0 89       	st.b	r8[0x0],r9
8000d9a4:	d8 32       	popm	r0-r7,pc
8000d9a6:	31 88       	mov	r8,24
8000d9a8:	30 0c       	mov	r12,0
8000d9aa:	b6 88       	st.b	r11[0x0],r8
         fat_cache_reset();
      }
      fat_cache_clusterlist_reset();

      fs_g_status = FS_ERR_HW;                     // By default HW error
      if( CTRL_BUSY == status )
8000d9ac:	d8 32       	popm	r0-r7,pc
   {
      fs_g_status = FS_ERR_HW;
      return false;                                // No device selected
   }

   for( retry=0 ; retry<100 ; retry++ )
8000d9ae:	0b 89       	ld.ub	r9,r5[0x0]
8000d9b0:	30 08       	mov	r8,0
8000d9b2:	f0 09 18 00 	cp.b	r9,r8
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
         {
            fs_g_navext_fast[i].u8_type_fat     = FS_TYPE_FAT_UNM;   // By default the fat isn't mounted
8000d9b6:	cd 70       	breq	8000d964 <fat_check_mount_select_noopen+0x128>
8000d9b8:	e0 69 0c ec 	mov	r9,3308
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
8000d9bc:	13 89       	ld.ub	r9,r9[0x0]
8000d9be:	f0 09 18 00 	cp.b	r9,r8
      fs_g_status = FS_ERR_HW;                     // By default HW error
      if( CTRL_BUSY == status )
         continue;                                 // If device busy then retry

      if( CTRL_NO_PRESENT == status )
         fs_g_status = FS_ERR_HW_NO_PRESENT;       // Update error flag
8000d9c2:	cd 10       	breq	8000d964 <fat_check_mount_select_noopen+0x128>
8000d9c4:	30 59       	mov	r9,5
8000d9c6:	e0 68 0f 7c 	mov	r8,3964
8000d9ca:	30 0c       	mov	r12,0
8000d9cc:	b0 89       	st.b	r8[0x0],r9
8000d9ce:	d8 32       	popm	r0-r7,pc
8000d9d0:	30 19       	mov	r9,1
8000d9d2:	e0 68 0f 7c 	mov	r8,3964
8000d9d6:	30 1c       	mov	r12,1
8000d9d8:	b0 89       	st.b	r8[0x0],r9
8000d9da:	d8 32       	popm	r0-r7,pc
8000d9dc:	2f f2       	sub	r2,-1
8000d9de:	e0 42 00 64 	cp.w	r2,100
8000d9e2:	c9 41       	brne	8000d90a <fat_check_mount_select_noopen+0xce>
8000d9e4:	cc 0b       	rjmp	8000d964 <fat_check_mount_select_noopen+0x128>
8000d9e6:	e0 6e 0f 74 	mov	lr,3956
8000d9ea:	bc 87       	st.b	lr[0x0],r7
8000d9ec:	e0 6e 0f 64 	mov	lr,3940
8000d9f0:	bc 87       	st.b	lr[0x0],r7
8000d9f2:	c9 db       	rjmp	8000d92c <fat_check_mount_select_noopen+0xf0>
8000d9f4:	31 88       	mov	r8,24
8000d9f6:	30 1c       	mov	r12,1
8000d9f8:	b6 88       	st.b	r11[0x0],r8
8000d9fa:	d8 32       	popm	r0-r7,pc

8000d9fc <fat_clear_info_fat_mod>:
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
//! This function clears the cache information about FAT modifications
//!
void  fat_clear_info_fat_mod( void )
{
   fs_g_u32_first_mod_fat = 0xFFFFFFFF;
8000d9fc:	3f f9       	mov	r9,-1
8000d9fe:	e0 68 0f 60 	mov	r8,3936
   fs_g_u32_last_mod_fat = 0;
8000da02:	91 09       	st.w	r8[0x0],r9
8000da04:	30 09       	mov	r9,0
8000da06:	e0 68 0d 28 	mov	r8,3368
}
8000da0a:	91 09       	st.w	r8[0x0],r9
8000da0c:	5e fc       	retal	r12
8000da0e:	d7 03       	nop

8000da10 <fat_update_fat2>:
8000da10:	eb cd 40 fe 	pushm	r1-r7,lr
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_update_fat2( void )
{
  while( fs_g_u32_first_mod_fat <= fs_g_u32_last_mod_fat )
8000da14:	e0 65 0f 60 	mov	r5,3936
8000da18:	e0 62 0d 28 	mov	r2,3368
8000da1c:	6a 08       	ld.w	r8,r5[0x0]
8000da1e:	64 09       	ld.w	r9,r2[0x0]
8000da20:	12 38       	cp.w	r8,r9
8000da22:	e0 8b 00 26 	brhi	8000da6e <fat_update_fat2+0x5e>
  {
     // Compute the modification position of FAT 1
     fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + fs_g_u32_first_mod_fat;
8000da26:	e0 63 0c e8 	mov	r3,3304
     // Read FAT1
      if( !fat_cache_read_sector( true ))
         return false;
     // Compute the modification position of FAT 2
     fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + (fs_g_u32_first_mod_fat + fs_g_nav.u32_fat_size);
8000da2a:	e0 64 0f 2c 	mov	r4,3884
8000da2e:	06 91       	mov	r1,r3
8000da30:	08 97       	mov	r7,r4
8000da32:	0a 96       	mov	r6,r5
8000da34:	c1 48       	rjmp	8000da5c <fat_update_fat2+0x4c>
8000da36:	6e 19       	ld.w	r9,r7[0x4]
8000da38:	6e 48       	ld.w	r8,r7[0x10]
     // Init the sector FAT2 with the previous sector of the FAT1
     if( !fat_cache_read_sector( false ))
8000da3a:	f2 08 00 08 	add	r8,r9,r8
8000da3e:	6a 09       	ld.w	r9,r5[0x0]
8000da40:	12 08       	add	r8,r9
8000da42:	30 0c       	mov	r12,0
         return false;
     // Flag the sector FAT2 like modify
     fat_cache_mark_sector_as_dirty();
8000da44:	83 08       	st.w	r1[0x0],r8
8000da46:	fe b0 f6 cd 	rcall	8000c7e0 <fat_cache_read_sector>
     fs_g_u32_first_mod_fat++;
8000da4a:	c1 00       	breq	8000da6a <fat_update_fat2+0x5a>
8000da4c:	fe b0 f5 96 	rcall	8000c578 <fat_cache_mark_sector_as_dirty>
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_update_fat2( void )
{
  while( fs_g_u32_first_mod_fat <= fs_g_u32_last_mod_fat )
8000da50:	6c 08       	ld.w	r8,r6[0x0]
8000da52:	2f f8       	sub	r8,-1
  {
     // Compute the modification position of FAT 1
     fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + fs_g_u32_first_mod_fat;
8000da54:	8d 08       	st.w	r6[0x0],r8
8000da56:	64 09       	ld.w	r9,r2[0x0]
     // Read FAT1
      if( !fat_cache_read_sector( true ))
8000da58:	10 39       	cp.w	r9,r8
bool  fat_update_fat2( void )
{
  while( fs_g_u32_first_mod_fat <= fs_g_u32_last_mod_fat )
  {
     // Compute the modification position of FAT 1
     fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + fs_g_u32_first_mod_fat;
8000da5a:	c0 a3       	brcs	8000da6e <fat_update_fat2+0x5e>
     // Read FAT1
      if( !fat_cache_read_sector( true ))
8000da5c:	68 49       	ld.w	r9,r4[0x10]
8000da5e:	12 08       	add	r8,r9
8000da60:	30 1c       	mov	r12,1
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_update_fat2( void )
{
  while( fs_g_u32_first_mod_fat <= fs_g_u32_last_mod_fat )
8000da62:	87 08       	st.w	r3[0x0],r8
8000da64:	fe b0 f6 be 	rcall	8000c7e0 <fat_cache_read_sector>
8000da68:	ce 71       	brne	8000da36 <fat_update_fat2+0x26>
8000da6a:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
8000da6e:	e3 cf 90 fe 	ldm	sp++,r1-r7,pc,r12=1
8000da72:	d7 03       	nop

8000da74 <fat_write_fat32_FSInfo>:
8000da74:	eb cd 40 80 	pushm	r7,lr
8000da78:	20 1d       	sub	sp,4
8000da7a:	e0 68 0f 2c 	mov	r8,3884
8000da7e:	70 4a       	ld.w	r10,r8[0x10]
8000da80:	90 c9       	ld.uh	r9,r8[0x8]
8000da82:	e0 68 0c e8 	mov	r8,3304
//! @return    true otherwise
//!
bool  fat_write_fat32_FSInfo( uint32_t u32_nb_free_cluster )
{
   // Init sector
   fs_gu32_addrsector = fs_g_nav.u32_ptr_fat - fs_g_nav.u16_offset_FSInfo;
8000da86:	12 1a       	sub	r10,r9

   if( !fat_cache_read_sector( false ))
8000da88:	50 0c       	stdsp	sp[0x0],r12
8000da8a:	91 0a       	st.w	r8[0x0],r10
8000da8c:	30 0c       	mov	r12,0
8000da8e:	fe b0 f6 a9 	rcall	8000c7e0 <fat_cache_read_sector>
      return false;
   fat_cache_mark_sector_as_dirty();
8000da92:	c2 c0       	breq	8000daea <fat_write_fat32_FSInfo+0x76>
   fat_cache_clear();
8000da94:	fe b0 f5 72 	rcall	8000c578 <fat_cache_mark_sector_as_dirty>

   // Fill sector
   // offset 00-04, This lead signature
   memcpy_code2ram( &fs_g_sector[0], const_FSI_LeadSig, sizeof(const_FSI_LeadSig) );
8000da98:	fe b0 f6 3c 	rcall	8000c710 <fat_cache_clear>
8000da9c:	30 4a       	mov	r10,4
8000da9e:	e0 67 0d 2c 	mov	r7,3372
8000daa2:	49 4b       	lddpc	r11,8000daf0 <fat_write_fat32_FSInfo+0x7c>
   // offset 004-483, reserved (fill with 0)
   // offset 484-487, signature
   memcpy_code2ram( &fs_g_sector[484], const_FSI_StrucSig, sizeof(const_FSI_StrucSig) );
8000daa4:	0e 9c       	mov	r12,r7
8000daa6:	e0 a0 14 4b 	rcall	8001033c <memcpy>
8000daaa:	30 4a       	mov	r10,4
8000daac:	49 2b       	lddpc	r11,8000daf4 <fat_write_fat32_FSInfo+0x80>
8000daae:	ee cc fe 1c 	sub	r12,r7,-484
   // offset 488-491, free cluster count (by default NO value)
   fs_g_sector[488] = LSB0(u32_nb_free_cluster);
   fs_g_sector[489] = LSB1(u32_nb_free_cluster);
   fs_g_sector[490] = LSB2(u32_nb_free_cluster);
   fs_g_sector[491] = LSB3(u32_nb_free_cluster);
8000dab2:	e0 a0 14 45 	rcall	8001033c <memcpy>
   memcpy_code2ram( &fs_g_sector[0], const_FSI_LeadSig, sizeof(const_FSI_LeadSig) );
   // offset 004-483, reserved (fill with 0)
   // offset 484-487, signature
   memcpy_code2ram( &fs_g_sector[484], const_FSI_StrucSig, sizeof(const_FSI_StrucSig) );
   // offset 488-491, free cluster count (by default NO value)
   fs_g_sector[488] = LSB0(u32_nb_free_cluster);
8000dab6:	1b 89       	ld.ub	r9,sp[0x0]
8000dab8:	ef 69 01 eb 	st.b	r7[491],r9
   fs_g_sector[489] = LSB1(u32_nb_free_cluster);
8000dabc:	1b b9       	ld.ub	r9,sp[0x3]
8000dabe:	ef 69 01 e8 	st.b	r7[488],r9
   fs_g_sector[490] = LSB2(u32_nb_free_cluster);
8000dac2:	1b a9       	ld.ub	r9,sp[0x2]
   fs_g_sector[491] = LSB3(u32_nb_free_cluster);
   // offset 492-495, indicates the cluster number at which the driver should start looking for free clusters (by default NO value)
   memset( &fs_g_sector[492] , 0xFF , 4 );
8000dac4:	ef 69 01 e9 	st.b	r7[489],r9
   // offset 484-487, signature
   memcpy_code2ram( &fs_g_sector[484], const_FSI_StrucSig, sizeof(const_FSI_StrucSig) );
   // offset 488-491, free cluster count (by default NO value)
   fs_g_sector[488] = LSB0(u32_nb_free_cluster);
   fs_g_sector[489] = LSB1(u32_nb_free_cluster);
   fs_g_sector[490] = LSB2(u32_nb_free_cluster);
8000dac8:	1b 98       	ld.ub	r8,sp[0x1]
   fs_g_sector[491] = LSB3(u32_nb_free_cluster);
   // offset 492-495, indicates the cluster number at which the driver should start looking for free clusters (by default NO value)
   memset( &fs_g_sector[492] , 0xFF , 4 );
8000daca:	30 4a       	mov	r10,4
8000dacc:	ef 68 01 ea 	st.b	r7[490],r8
8000dad0:	e0 6b 00 ff 	mov	r11,255
8000dad4:	ee cc fe 14 	sub	r12,r7,-492
   // offset 496-509, reserved (fill with 0)
   // offset 510-511, Signature
   fs_g_sector[510] = FS_BR_SIGNATURE_LOW;
   fs_g_sector[511] = FS_BR_SIGNATURE_HIGH;
8000dad8:	e0 a0 14 d6 	rcall	80010484 <memset>
   fs_g_sector[491] = LSB3(u32_nb_free_cluster);
   // offset 492-495, indicates the cluster number at which the driver should start looking for free clusters (by default NO value)
   memset( &fs_g_sector[492] , 0xFF , 4 );
   // offset 496-509, reserved (fill with 0)
   // offset 510-511, Signature
   fs_g_sector[510] = FS_BR_SIGNATURE_LOW;
8000dadc:	35 58       	mov	r8,85
   fs_g_sector[511] = FS_BR_SIGNATURE_HIGH;
8000dade:	30 1c       	mov	r12,1
8000dae0:	ef 68 01 fe 	st.b	r7[510],r8
   return true;
}
8000dae4:	3a a8       	mov	r8,-86
8000dae6:	ef 68 01 ff 	st.b	r7[511],r8
8000daea:	2f fd       	sub	sp,-4
8000daec:	e3 cd 80 80 	ldm	sp++,r7,pc
8000daf0:	80 01       	ld.sh	r1,r0[0x0]
8000daf2:	82 bc       	ld.uh	r12,r1[0x6]
8000daf4:	80 01       	ld.sh	r1,r0[0x0]
8000daf6:	82 c0       	ld.uh	r0,r1[0x8]

8000daf8 <fat_mount>:
8000daf8:	d4 31       	pushm	r0-r7,lr
8000dafa:	20 5d       	sub	sp,20
8000dafc:	e0 6e 0f 2c 	mov	lr,3884
8000db00:	30 06       	mov	r6,0
8000db02:	9d 86       	st.w	lr[0x20],r6
8000db04:	fe b0 f2 e8 	rcall	8000c0d4 <fat_clear_entry_info_and_ptr>
8000db08:	e0 6b 0f 78 	mov	r11,3960
8000db0c:	e0 62 0c e8 	mov	r2,3304
8000db10:	b6 86       	st.b	r11[0x0],r6
8000db12:	85 06       	st.w	r2[0x0],r6

   fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM;
   fs_gu32_addrsector = 0;    // Start read at the beginning of memory

   // Check if the drive is available
   if( !fat_check_device() )
8000db14:	fe b0 f6 08 	rcall	8000c724 <fat_check_device>
8000db18:	e0 80 01 9d 	breq	8000de52 <fat_mount+0x35a>
      // Read one sector
      if( !fat_cache_read_sector( true ))
         return false;

      // Check PBR/MBR signature
      if ( (fs_g_sector[510] != FS_BR_SIGNATURE_LOW  )
8000db1c:	e0 67 0d 2c 	mov	r7,3372
8000db20:	35 51       	mov	r1,85
8000db22:	0e 98       	mov	r8,r7
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
         {
            // The first sector must be a MBR, then check the partition entry in the MBR
            if ( ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_BOOTABLE             )||
8000db24:	38 05       	mov	r5,-128
8000db26:	30 43       	mov	r3,4
8000db28:	30 14       	mov	r4,1
      return false;

   while( 1 )  // Search a valid partition
   {
      // Read one sector
      if( !fat_cache_read_sector( true ))
8000db2a:	50 18       	stdsp	sp[0x4],r8
8000db2c:	30 1c       	mov	r12,1
8000db2e:	fe b0 f6 59 	rcall	8000c7e0 <fat_cache_read_sector>
8000db32:	40 18       	lddsp	r8,sp[0x4]
8000db34:	e0 80 01 8f 	breq	8000de52 <fat_mount+0x35a>
         return false;

      // Check PBR/MBR signature
      if ( (fs_g_sector[510] != FS_BR_SIGNATURE_LOW  )
8000db38:	e0 6c 0d 2c 	mov	r12,3372
8000db3c:	ef 39 01 fe 	ld.ub	r9,r7[510]
8000db40:	e2 09 18 00 	cp.b	r9,r1
8000db44:	c0 80       	breq	8000db54 <fat_mount+0x5c>
      &&   (fs_g_sector[511] != FS_BR_SIGNATURE_HIGH ) )
8000db46:	f1 39 01 ff 	ld.ub	r9,r8[511]
8000db4a:	3a aa       	mov	r10,-86
8000db4c:	f4 09 18 00 	cp.b	r9,r10
8000db50:	e0 81 01 c7 	brne	8000dede <fat_mount+0x3e6>
      {
         fs_g_status = FS_ERR_NO_FORMAT;
         return false;
      }

      if ( 0 == fs_gu32_addrsector )
8000db54:	64 0b       	ld.w	r11,r2[0x0]
8000db56:	58 0b       	cp.w	r11,0
8000db58:	e0 81 00 b9 	brne	8000dcca <fat_mount+0x1d2>
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
         {
            // The first sector must be a MBR, then check the partition entry in the MBR
            if ( ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_BOOTABLE             )||
8000db5c:	ef 3a 01 be 	ld.ub	r10,r7[446]
8000db60:	ea 0a 18 00 	cp.b	r10,r5
8000db64:	5f 0e       	sreq	lr
8000db66:	f6 0a 18 00 	cp.b	r10,r11
8000db6a:	5f 0a       	sreq	r10
8000db6c:	1c 4a       	or	r10,lr
8000db6e:	f6 0a 18 00 	cp.b	r10,r11
8000db72:	c2 20       	breq	8000dbb6 <fat_mount+0xbe>
                  (fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_NO_BOOTABLE          )  )
            &&   ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+4] == FS_PART_TYPE_FAT12           )||
8000db74:	ef 3a 01 c2 	ld.ub	r10,r7[450]
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
         {
            // The first sector must be a MBR, then check the partition entry in the MBR
            if ( ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_BOOTABLE             )||
8000db78:	e6 0a 18 00 	cp.b	r10,r3
8000db7c:	5f 00       	sreq	r0
8000db7e:	e8 0a 18 00 	cp.b	r10,r4
8000db82:	5f 0e       	sreq	lr
8000db84:	1c 40       	or	r0,lr
8000db86:	f6 00 18 00 	cp.b	r0,r11
8000db8a:	e0 81 01 90 	brne	8000deaa <fat_mount+0x3b2>
8000db8e:	30 69       	mov	r9,6
8000db90:	f2 0a 18 00 	cp.b	r10,r9
8000db94:	e0 80 01 8b 	breq	8000deaa <fat_mount+0x3b2>
8000db98:	30 e9       	mov	r9,14
8000db9a:	f2 0a 18 00 	cp.b	r10,r9
8000db9e:	e0 80 01 86 	breq	8000deaa <fat_mount+0x3b2>
8000dba2:	30 b9       	mov	r9,11
8000dba4:	f2 0a 18 00 	cp.b	r10,r9
8000dba8:	e0 80 01 81 	breq	8000deaa <fat_mount+0x3b2>
8000dbac:	30 c9       	mov	r9,12
8000dbae:	f2 0a 18 00 	cp.b	r10,r9
8000dbb2:	e0 80 01 7c 	breq	8000deaa <fat_mount+0x3b2>
8000dbb6:	ef 39 01 ce 	ld.ub	r9,r7[462]
8000dbba:	ea 09 18 00 	cp.b	r9,r5
8000dbbe:	5f 0a       	sreq	r10
8000dbc0:	ec 09 18 00 	cp.b	r9,r6
8000dbc4:	5f 09       	sreq	r9
8000dbc6:	14 49       	or	r9,r10
8000dbc8:	ec 09 18 00 	cp.b	r9,r6
8000dbcc:	c2 30       	breq	8000dc12 <fat_mount+0x11a>
                  (fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_NO_BOOTABLE          )  )
            &&   ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+4] == FS_PART_TYPE_FAT12           )||
8000dbce:	ef 39 01 d2 	ld.ub	r9,r7[466]
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
         {
            // The first sector must be a MBR, then check the partition entry in the MBR
            if ( ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_BOOTABLE             )||
8000dbd2:	e6 09 18 00 	cp.b	r9,r3
8000dbd6:	5f 0e       	sreq	lr
8000dbd8:	e8 09 18 00 	cp.b	r9,r4
8000dbdc:	5f 0a       	sreq	r10
8000dbde:	fd ea 10 0a 	or	r10,lr,r10
8000dbe2:	ec 0a 18 00 	cp.b	r10,r6
8000dbe6:	e0 81 01 38 	brne	8000de56 <fat_mount+0x35e>
8000dbea:	30 6a       	mov	r10,6
8000dbec:	f4 09 18 00 	cp.b	r9,r10
8000dbf0:	e0 80 01 33 	breq	8000de56 <fat_mount+0x35e>
8000dbf4:	30 ea       	mov	r10,14
8000dbf6:	f4 09 18 00 	cp.b	r9,r10
8000dbfa:	e0 80 01 2e 	breq	8000de56 <fat_mount+0x35e>
8000dbfe:	30 ba       	mov	r10,11
8000dc00:	f4 09 18 00 	cp.b	r9,r10
8000dc04:	e0 80 01 29 	breq	8000de56 <fat_mount+0x35e>
8000dc08:	30 ca       	mov	r10,12
8000dc0a:	f4 09 18 00 	cp.b	r9,r10
8000dc0e:	e0 80 01 24 	breq	8000de56 <fat_mount+0x35e>
8000dc12:	ef 39 01 de 	ld.ub	r9,r7[478]
8000dc16:	ea 09 18 00 	cp.b	r9,r5
8000dc1a:	5f 0a       	sreq	r10
8000dc1c:	ec 09 18 00 	cp.b	r9,r6
8000dc20:	5f 09       	sreq	r9
8000dc22:	14 49       	or	r9,r10
8000dc24:	ec 09 18 00 	cp.b	r9,r6
8000dc28:	c2 30       	breq	8000dc6e <fat_mount+0x176>
                  (fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_NO_BOOTABLE          )  )
            &&   ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+4] == FS_PART_TYPE_FAT12           )||
8000dc2a:	ef 39 01 e2 	ld.ub	r9,r7[482]
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
         {
            // The first sector must be a MBR, then check the partition entry in the MBR
            if ( ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_BOOTABLE             )||
8000dc2e:	e6 09 18 00 	cp.b	r9,r3
8000dc32:	5f 0e       	sreq	lr
8000dc34:	e8 09 18 00 	cp.b	r9,r4
8000dc38:	5f 0a       	sreq	r10
8000dc3a:	fd ea 10 0a 	or	r10,lr,r10
8000dc3e:	ec 0a 18 00 	cp.b	r10,r6
8000dc42:	e0 81 01 2b 	brne	8000de98 <fat_mount+0x3a0>
8000dc46:	30 6a       	mov	r10,6
8000dc48:	f4 09 18 00 	cp.b	r9,r10
8000dc4c:	e0 80 01 26 	breq	8000de98 <fat_mount+0x3a0>
8000dc50:	30 ea       	mov	r10,14
8000dc52:	f4 09 18 00 	cp.b	r9,r10
8000dc56:	e0 80 01 21 	breq	8000de98 <fat_mount+0x3a0>
8000dc5a:	30 ba       	mov	r10,11
8000dc5c:	f4 09 18 00 	cp.b	r9,r10
8000dc60:	e0 80 01 1c 	breq	8000de98 <fat_mount+0x3a0>
8000dc64:	30 ca       	mov	r10,12
8000dc66:	f4 09 18 00 	cp.b	r9,r10
8000dc6a:	e0 80 01 17 	breq	8000de98 <fat_mount+0x3a0>
8000dc6e:	ef 39 01 ee 	ld.ub	r9,r7[494]
8000dc72:	ea 09 18 00 	cp.b	r9,r5
8000dc76:	5f 0a       	sreq	r10
8000dc78:	ec 09 18 00 	cp.b	r9,r6
8000dc7c:	5f 09       	sreq	r9
8000dc7e:	14 49       	or	r9,r10
8000dc80:	ec 09 18 00 	cp.b	r9,r6
8000dc84:	c2 30       	breq	8000dcca <fat_mount+0x1d2>
                  (fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_NO_BOOTABLE          )  )
            &&   ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+4] == FS_PART_TYPE_FAT12           )||
8000dc86:	ef 39 01 f2 	ld.ub	r9,r7[498]
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
         {
            // The first sector must be a MBR, then check the partition entry in the MBR
            if ( ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_BOOTABLE             )||
8000dc8a:	e6 09 18 00 	cp.b	r9,r3
8000dc8e:	5f 0e       	sreq	lr
8000dc90:	e8 09 18 00 	cp.b	r9,r4
8000dc94:	5f 0a       	sreq	r10
8000dc96:	fd ea 10 0a 	or	r10,lr,r10
8000dc9a:	ec 0a 18 00 	cp.b	r10,r6
8000dc9e:	e0 81 01 0f 	brne	8000debc <fat_mount+0x3c4>
8000dca2:	30 6a       	mov	r10,6
8000dca4:	f4 09 18 00 	cp.b	r9,r10
8000dca8:	e0 80 01 0a 	breq	8000debc <fat_mount+0x3c4>
8000dcac:	30 ea       	mov	r10,14
8000dcae:	f4 09 18 00 	cp.b	r9,r10
8000dcb2:	e0 80 01 05 	breq	8000debc <fat_mount+0x3c4>
8000dcb6:	30 ba       	mov	r10,11
8000dcb8:	f4 09 18 00 	cp.b	r9,r10
8000dcbc:	e0 80 01 00 	breq	8000debc <fat_mount+0x3c4>
8000dcc0:	30 ca       	mov	r10,12
8000dcc2:	f4 09 18 00 	cp.b	r9,r10
8000dcc6:	e0 80 00 fb 	breq	8000debc <fat_mount+0x3c4>
         }
#endif
      }

      //** Check a PBR structure
      if ( (fs_g_sector[0] == 0xEB) &&          // PBR Byte 0
8000dcca:	e0 6a 0d 2c 	mov	r10,3372
8000dcce:	19 89       	ld.ub	r9,r12[0x0]
8000dcd0:	3e b8       	mov	r8,-21
8000dcd2:	f0 09 18 00 	cp.b	r9,r8
8000dcd6:	c0 80       	breq	8000dce6 <fat_mount+0x1ee>
           ((fs_g_sector[21] & 0xF0) == 0xF0) ) // PBR Byte 21 : Media byte
      {
         break;   // valid PBR found
      }
      // PBR not found
      fs_g_status = FS_ERR_NO_PART;
8000dcd8:	30 39       	mov	r9,3
8000dcda:	e0 68 0f 7c 	mov	r8,3964
8000dcde:	30 0c       	mov	r12,0
8000dce0:	b0 89       	st.b	r8[0x0],r9
      LSB3( fs_g_nav.rootdir.u32_cluster ) = LOW3_32_BPB_RootClus;
   }
   }

   return true;
}
8000dce2:	2f bd       	sub	sp,-20
8000dce4:	d8 32       	popm	r0-r7,pc
#endif
      }

      //** Check a PBR structure
      if ( (fs_g_sector[0] == 0xEB) &&          // PBR Byte 0
           (fs_g_sector[2] == 0x90) &&          // PBR Byte 2
8000dce6:	15 a9       	ld.ub	r9,r10[0x2]
8000dce8:	39 08       	mov	r8,-112
8000dcea:	f0 09 18 00 	cp.b	r9,r8
8000dcee:	cf 51       	brne	8000dcd8 <fat_mount+0x1e0>
           ((fs_g_sector[21] & 0xF0) == 0xF0) ) // PBR Byte 21 : Media byte
8000dcf0:	f5 38 00 15 	ld.ub	r8,r10[21]
8000dcf4:	e2 18 00 f0 	andl	r8,0xf0,COH
8000dcf8:	e0 48 00 f0 	cp.w	r8,240
8000dcfc:	ce e1       	brne	8000dcd8 <fat_mount+0x1e0>
   // Read BPB_SecPerClus (unit sector)
   fs_g_nav.u8_BPB_SecPerClus = U8_BPB_SecPerClus * u8_sector_size;

   //** FAT Type determination (algorithm of "Hardware White Paper FAT")
   // Get FAT size (unit sector)
   u32_tmp=0;
8000dcfe:	30 08       	mov	r8,0
      // PBR not found
      fs_g_status = FS_ERR_NO_PART;
      return false;
   }

   fs_g_status = FS_ERR_NO_SUPPORT_PART;  // by default partition no supported
8000dd00:	30 49       	mov	r9,4
   // Read BPB_SecPerClus (unit sector)
   fs_g_nav.u8_BPB_SecPerClus = U8_BPB_SecPerClus * u8_sector_size;

   //** FAT Type determination (algorithm of "Hardware White Paper FAT")
   // Get FAT size (unit sector)
   u32_tmp=0;
8000dd02:	50 38       	stdsp	sp[0xc],r8
      // PBR not found
      fs_g_status = FS_ERR_NO_PART;
      return false;
   }

   fs_g_status = FS_ERR_NO_SUPPORT_PART;  // by default partition no supported
8000dd04:	e0 68 0f 7c 	mov	r8,3964

   // Get sector size of File System (unit 512B)
   // To translate from sector disk unit to sector 512B unit
   u8_sector_size = HIGH_16_BPB_BytsPerSec/2;
8000dd08:	f5 3e 00 0c 	ld.ub	lr,r10[12]
      // PBR not found
      fs_g_status = FS_ERR_NO_PART;
      return false;
   }

   fs_g_status = FS_ERR_NO_SUPPORT_PART;  // by default partition no supported
8000dd0c:	b0 89       	st.b	r8[0x0],r9

   // Get sector size of File System (unit 512B)
   // To translate from sector disk unit to sector 512B unit
   u8_sector_size = HIGH_16_BPB_BytsPerSec/2;
8000dd0e:	a1 9e       	lsr	lr,0x1

   // Read BPB_SecPerClus (unit sector)
   fs_g_nav.u8_BPB_SecPerClus = U8_BPB_SecPerClus * u8_sector_size;
8000dd10:	f5 38 00 0d 	ld.ub	r8,r10[13]
8000dd14:	e0 69 0f 2c 	mov	r9,3884
8000dd18:	bd 38       	mul	r8,lr
8000dd1a:	5c 58       	castu.b	r8

   //** FAT Type determination (algorithm of "Hardware White Paper FAT")
   // Get FAT size (unit sector)
   u32_tmp=0;
   LSB0( u32_tmp ) = LOW_16_BPB_FATSz16;
8000dd1c:	b2 98       	st.b	r9[0x1],r8
8000dd1e:	fa c6 ff f1 	sub	r6,sp,-15
8000dd22:	f5 39 00 16 	ld.ub	r9,r10[22]
   LSB1( u32_tmp ) = HIGH_16_BPB_FATSz16;
8000dd26:	ac 89       	st.b	r6[0x0],r9
8000dd28:	fa c7 ff f2 	sub	r7,sp,-14
8000dd2c:	f5 39 00 17 	ld.ub	r9,r10[23]
   fs_g_nav.u8_BPB_SecPerClus = U8_BPB_SecPerClus * u8_sector_size;

   //** FAT Type determination (algorithm of "Hardware White Paper FAT")
   // Get FAT size (unit sector)
   u32_tmp=0;
   LSB0( u32_tmp ) = LOW_16_BPB_FATSz16;
8000dd30:	ae 89       	st.b	r7[0x0],r9
8000dd32:	fa c5 ff f4 	sub	r5,sp,-12
   LSB1( u32_tmp ) = HIGH_16_BPB_FATSz16;
   if ( 0==u32_tmp )
8000dd36:	40 39       	lddsp	r9,sp[0xc]
8000dd38:	58 09       	cp.w	r9,0
8000dd3a:	e0 80 00 d8 	breq	8000deea <fat_mount+0x3f2>
8000dd3e:	fa c4 ff f3 	sub	r4,sp,-13
      LSB0( u32_tmp ) = LOW0_32_BPB_FATSz32;
      LSB1( u32_tmp ) = LOW1_32_BPB_FATSz32;
      LSB2( u32_tmp ) = LOW2_32_BPB_FATSz32;
      LSB3( u32_tmp ) = LOW3_32_BPB_FATSz32;
   }
   fs_g_nav.u32_fat_size = u32_tmp * u8_sector_size;
8000dd42:	bd 39       	mul	r9,lr
8000dd44:	e0 60 0f 2c 	mov	r0,3884

   // Get total count of sectors in partition
   if ( (0==LOW_16_BPB_TotSec16) && (0==HIGH_16_BPB_TotSec16) )
8000dd48:	81 19       	st.w	r0[0x4],r9
8000dd4a:	e0 63 0d 2c 	mov	r3,3372
8000dd4e:	f9 3a 00 13 	ld.ub	r10,r12[19]
8000dd52:	58 0a       	cp.w	r10,0
8000dd54:	e0 81 00 bd 	brne	8000dece <fat_mount+0x3d6>
8000dd58:	e7 32 00 14 	ld.ub	r2,r3[20]
   {
      LSB0( u32_tmp ) = LOW0_32_BPB_TotSec32;
8000dd5c:	58 02       	cp.w	r2,0
8000dd5e:	e0 81 00 ba 	brne	8000ded2 <fat_mount+0x3da>
      LSB1( u32_tmp ) = LOW1_32_BPB_TotSec32;
8000dd62:	e7 3a 00 20 	ld.ub	r10,r3[32]
8000dd66:	ac 8a       	st.b	r6[0x0],r10
      LSB2( u32_tmp ) = LOW2_32_BPB_TotSec32;
8000dd68:	e7 3a 00 21 	ld.ub	r10,r3[33]
8000dd6c:	ae 8a       	st.b	r7[0x0],r10
      LSB3( u32_tmp ) = LOW3_32_BPB_TotSec32;
8000dd6e:	e7 3a 00 22 	ld.ub	r10,r3[34]
8000dd72:	a8 8a       	st.b	r4[0x0],r10
      LSB3( u32_tmp ) = 0;
   }
   u32_tmp *= u8_sector_size;   // Translate from sector disk unit to sector 512B unit

   // Compute the offset (unit 512B) between the end of FAT (beginning of root dir in FAT1x) and the beginning of PBR
   fs_g_nav.rootdir.seg.u16_pos = FS_NB_FAT * (uint16_t)fs_g_nav.u32_fat_size;
8000dd74:	e7 3a 00 23 	ld.ub	r10,r3[35]
8000dd78:	aa 8a       	st.b	r5[0x0],r10
8000dd7a:	a1 79       	lsl	r9,0x1
      LSB0( u32_tmp ) = LOW_16_BPB_TotSec16;
      LSB1( u32_tmp ) = HIGH_16_BPB_TotSec16;
      LSB2( u32_tmp ) = 0;
      LSB3( u32_tmp ) = 0;
   }
   u32_tmp *= u8_sector_size;   // Translate from sector disk unit to sector 512B unit
8000dd7c:	e0 6a 0f 2c 	mov	r10,3884

   // Compute the offset (unit 512B) between the end of FAT (beginning of root dir in FAT1x) and the beginning of PBR
   fs_g_nav.rootdir.seg.u16_pos = FS_NB_FAT * (uint16_t)fs_g_nav.u32_fat_size;

   // Compute the root directory size (unit sector), for FAT32 is always 0
   LSB( u16_tmp ) = LOW_16_BPB_RootEntCnt;
8000dd80:	f5 59 00 18 	st.h	r10[24],r9
8000dd84:	40 35       	lddsp	r5,sp[0xc]
8000dd86:	f9 3a 00 11 	ld.ub	r10,r12[17]
   MSB( u16_tmp ) = HIGH_16_BPB_RootEntCnt;
8000dd8a:	fa c7 ff ec 	sub	r7,sp,-20

   // Compute the offset (unit 512B) between the end of FAT (beginning of root dir in FAT1x) and the beginning of PBR
   fs_g_nav.rootdir.seg.u16_pos = FS_NB_FAT * (uint16_t)fs_g_nav.u32_fat_size;

   // Compute the root directory size (unit sector), for FAT32 is always 0
   LSB( u16_tmp ) = LOW_16_BPB_RootEntCnt;
8000dd8e:	0e fa       	st.b	--r7,r10
   MSB( u16_tmp ) = HIGH_16_BPB_RootEntCnt;
   fs_g_nav.rootdir.seg.u16_size = ((u16_tmp * FS_SIZE_FILE_ENTRY) + ((FS_512B*u8_sector_size)-1)) / (FS_512B*u8_sector_size);
   fs_g_nav.rootdir.seg.u16_size *= u8_sector_size;
8000dd90:	f9 36 00 12 	ld.ub	r6,r12[18]
   // Compute the offset (unit 512B) between the end of FAT (beginning of root dir in FAT1x) and the beginning of PBR
   fs_g_nav.rootdir.seg.u16_pos = FS_NB_FAT * (uint16_t)fs_g_nav.u32_fat_size;

   // Compute the root directory size (unit sector), for FAT32 is always 0
   LSB( u16_tmp ) = LOW_16_BPB_RootEntCnt;
   MSB( u16_tmp ) = HIGH_16_BPB_RootEntCnt;
8000dd94:	fa ca ff ee 	sub	r10,sp,-18
   fs_g_nav.rootdir.seg.u16_size = ((u16_tmp * FS_SIZE_FILE_ENTRY) + ((FS_512B*u8_sector_size)-1)) / (FS_512B*u8_sector_size);
   fs_g_nav.rootdir.seg.u16_size *= u8_sector_size;
8000dd98:	fc 04 15 04 	lsl	r4,lr,0x4
8000dd9c:	b4 86       	st.b	r10[0x0],r6
8000dd9e:	fb 16 00 12 	ld.uh	r6,sp[18]
8000dda2:	e8 06 00 06 	add	r6,r4,r6
8000dda6:	a5 76       	lsl	r6,0x5
8000dda8:	20 16       	sub	r6,1
8000ddaa:	e0 64 0f 2c 	mov	r4,3884
8000ddae:	fc 03 15 09 	lsl	r3,lr,0x9
8000ddb2:	ec 03 0c 02 	divs	r2,r6,r3

   // Get number of reserved sector
   LSB( u16_tmp ) = LOW_16_BPB_ResvSecCnt;
8000ddb6:	fc 02 02 46 	mul	r6,lr,r2

   // Compute the FAT address (unit 512B)
   fs_g_nav.u32_ptr_fat = fs_gu32_addrsector + u16_tmp;

   // Compute the offset (unit 512B) between the first data cluster and the FAT beginning
   fs_g_nav.u32_offset_data = (FS_NB_FAT * fs_g_nav.u32_fat_size) + (uint32_t)fs_g_nav.rootdir.seg.u16_size;
8000ddba:	e9 56 00 1a 	st.h	r4[26],r6
8000ddbe:	f9 34 00 0e 	ld.ub	r4,r12[14]
   fs_g_nav.rootdir.seg.u16_size = ((u16_tmp * FS_SIZE_FILE_ENTRY) + ((FS_512B*u8_sector_size)-1)) / (FS_512B*u8_sector_size);
   fs_g_nav.rootdir.seg.u16_size *= u8_sector_size;

   // Get number of reserved sector
   LSB( u16_tmp ) = LOW_16_BPB_ResvSecCnt;
   MSB( u16_tmp ) = HIGH_16_BPB_ResvSecCnt;
8000ddc2:	ae 84       	st.b	r7[0x0],r4
8000ddc4:	e0 60 0f 2c 	mov	r0,3884
   // Get FSInfo position
   fs_g_nav.u16_offset_FSInfo = (u16_tmp-LOW_16_BPB_FSInfo)*u8_sector_size;
8000ddc8:	5c 76       	castu.h	r6
8000ddca:	0c 09       	add	r9,r6
8000ddcc:	81 59       	st.w	r0[0x14],r9
8000ddce:	f9 37 00 0f 	ld.ub	r7,r12[15]
   u16_tmp *= u8_sector_size; // number of reserved sector translated in unit 512B

   // Compute the FAT address (unit 512B)
   fs_g_nav.u32_ptr_fat = fs_gu32_addrsector + u16_tmp;
8000ddd2:	b4 87       	st.b	r10[0x0],r7

   // Get number of reserved sector
   LSB( u16_tmp ) = LOW_16_BPB_ResvSecCnt;
   MSB( u16_tmp ) = HIGH_16_BPB_ResvSecCnt;
   // Get FSInfo position
   fs_g_nav.u16_offset_FSInfo = (u16_tmp-LOW_16_BPB_FSInfo)*u8_sector_size;
8000ddd4:	fb 0a 00 12 	ld.sh	r10,sp[18]
8000ddd8:	f9 36 00 30 	ld.ub	r6,r12[48]
8000dddc:	fc 0a 02 47 	mul	r7,lr,r10
8000dde0:	5c 7a       	castu.h	r10
   // Compute the data region (clusters space = Total - Sector used) size (unit 512B)
   u32_tmp -= ((uint32_t)u16_tmp + fs_g_nav.u32_offset_data);

   // Compute the count of CLUSTER in the data region
   // !!!Optimization -> u32_CountofCluster (unit 512B)/ fs_g_nav.u8_BPB_SecPerClus (unit 512B & power of 2)
   if (!fs_g_nav.u8_BPB_SecPerClus)
8000dde2:	5c 77       	castu.h	r7
8000dde4:	0c 1a       	sub	r10,r6

   // Compute the offset (unit 512B) between the first data cluster and the FAT beginning
   fs_g_nav.u32_offset_data = (FS_NB_FAT * fs_g_nav.u32_fat_size) + (uint32_t)fs_g_nav.rootdir.seg.u16_size;

   // Compute the data region (clusters space = Total - Sector used) size (unit 512B)
   u32_tmp -= ((uint32_t)u16_tmp + fs_g_nav.u32_offset_data);
8000dde6:	0e 0b       	add	r11,r7

   // Compute the count of CLUSTER in the data region
   // !!!Optimization -> u32_CountofCluster (unit 512B)/ fs_g_nav.u8_BPB_SecPerClus (unit 512B & power of 2)
   if (!fs_g_nav.u8_BPB_SecPerClus)
     return false;
   for( u8_tmp = fs_g_nav.u8_BPB_SecPerClus; u8_tmp!=1 ; u8_tmp >>= 1 )
8000dde8:	bd 3a       	mul	r10,lr

   // Compute the offset (unit 512B) between the first data cluster and the FAT beginning
   fs_g_nav.u32_offset_data = (FS_NB_FAT * fs_g_nav.u32_fat_size) + (uint32_t)fs_g_nav.rootdir.seg.u16_size;

   // Compute the data region (clusters space = Total - Sector used) size (unit 512B)
   u32_tmp -= ((uint32_t)u16_tmp + fs_g_nav.u32_offset_data);
8000ddea:	81 4b       	st.w	r0[0x10],r11
8000ddec:	a0 4a       	st.h	r0[0x8],r10
8000ddee:	58 08       	cp.w	r8,0
8000ddf0:	c3 10       	breq	8000de52 <fat_mount+0x35a>

   // Compute the count of CLUSTER in the data region
   // !!!Optimization -> u32_CountofCluster (unit 512B)/ fs_g_nav.u8_BPB_SecPerClus (unit 512B & power of 2)
   if (!fs_g_nav.u8_BPB_SecPerClus)
     return false;
   for( u8_tmp = fs_g_nav.u8_BPB_SecPerClus; u8_tmp!=1 ; u8_tmp >>= 1 )
8000ddf2:	ab 3e       	mul	lr,r5
8000ddf4:	30 1a       	mov	r10,1
8000ddf6:	fc 07 01 07 	sub	r7,lr,r7
8000ddfa:	ee 09 01 09 	sub	r9,r7,r9
8000ddfe:	f4 08 18 00 	cp.b	r8,r10
   {
     u32_tmp  >>= 1;   // This computation round down
   }
   fs_g_nav.u32_CountofCluster = u32_tmp+2; // The total of cluster include the two reserved clusters
8000de02:	c0 60       	breq	8000de0e <fat_mount+0x316>
8000de04:	a1 99       	lsr	r9,0x1
8000de06:	a1 98       	lsr	r8,0x1
8000de08:	f4 08 18 00 	cp.b	r8,r10

   // Determine the FAT type
   if (u32_tmp < FS_FAT12_MAX_CLUSTERS)
8000de0c:	cf c1       	brne	8000de04 <fat_mount+0x30c>
8000de0e:	f2 c8 ff fe 	sub	r8,r9,-2
#if (FS_FAT_12 == false)
      return false;
#endif
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_12;
   } else {
   if (u32_tmp < FS_FAT16_MAX_CLUSTERS)
8000de12:	e0 6e 0f 2c 	mov	lr,3884
8000de16:	9d 38       	st.w	lr[0xc],r8
8000de18:	e0 49 0f f4 	cp.w	r9,4084
      // In FAT32, the root dir is like another directory, this one have a cluster list
      // Get the first cluster number of root
      LSB0( fs_g_nav.rootdir.u32_cluster ) = LOW0_32_BPB_RootClus;
      LSB1( fs_g_nav.rootdir.u32_cluster ) = LOW1_32_BPB_RootClus;
      LSB2( fs_g_nav.rootdir.u32_cluster ) = LOW2_32_BPB_RootClus;
      LSB3( fs_g_nav.rootdir.u32_cluster ) = LOW3_32_BPB_RootClus;
8000de1c:	e0 88 00 77 	brls	8000df0a <fat_mount+0x412>
      return false;
#endif
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_32;
      // In FAT32, the root dir is like another directory, this one have a cluster list
      // Get the first cluster number of root
      LSB0( fs_g_nav.rootdir.u32_cluster ) = LOW0_32_BPB_RootClus;
8000de20:	e0 49 ff f4 	cp.w	r9,65524
   } else {
      // Is FAT 32
#if (FS_FAT_32 == false)
      return false;
#endif
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_32;
8000de24:	e0 88 00 79 	brls	8000df16 <fat_mount+0x41e>
8000de28:	f9 39 00 2f 	ld.ub	r9,r12[47]
      // In FAT32, the root dir is like another directory, this one have a cluster list
      // Get the first cluster number of root
      LSB0( fs_g_nav.rootdir.u32_cluster ) = LOW0_32_BPB_RootClus;
8000de2c:	e0 68 0f 2c 	mov	r8,3884
      LSB1( fs_g_nav.rootdir.u32_cluster ) = LOW1_32_BPB_RootClus;
8000de30:	2e 88       	sub	r8,-24
8000de32:	b0 89       	st.b	r8[0x0],r9
8000de34:	30 39       	mov	r9,3
      LSB2( fs_g_nav.rootdir.u32_cluster ) = LOW2_32_BPB_RootClus;
8000de36:	e0 67 0f 78 	mov	r7,3960
      LSB3( fs_g_nav.rootdir.u32_cluster ) = LOW3_32_BPB_RootClus;
8000de3a:	ae 89       	st.b	r7[0x0],r9
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_32;
      // In FAT32, the root dir is like another directory, this one have a cluster list
      // Get the first cluster number of root
      LSB0( fs_g_nav.rootdir.u32_cluster ) = LOW0_32_BPB_RootClus;
      LSB1( fs_g_nav.rootdir.u32_cluster ) = LOW1_32_BPB_RootClus;
      LSB2( fs_g_nav.rootdir.u32_cluster ) = LOW2_32_BPB_RootClus;
8000de3c:	f9 39 00 2c 	ld.ub	r9,r12[44]
      LSB3( fs_g_nav.rootdir.u32_cluster ) = LOW3_32_BPB_RootClus;
8000de40:	b0 b9       	st.b	r8[0x3],r9
8000de42:	f9 39 00 2d 	ld.ub	r9,r12[45]
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
         {
            // The first sector must be a MBR, then check the partition entry in the MBR
            if ( ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_BOOTABLE             )||
8000de46:	b0 a9       	st.b	r8[0x2],r9
8000de48:	f9 39 00 2e 	ld.ub	r9,r12[46]
8000de4c:	30 1c       	mov	r12,1
8000de4e:	b0 99       	st.b	r8[0x1],r9
8000de50:	c4 9b       	rjmp	8000dce2 <fat_mount+0x1ea>
8000de52:	2f bd       	sub	sp,-20
            }
         }
         if( u8_tmp != 4 )
         {
            // Partition found -> Get partition position (unit sector) at offset 8
            LSB0(fs_gu32_addrsector) = fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+8];
8000de54:	d8 3a       	popm	r0-r7,pc,r12=0
8000de56:	e0 69 01 d9 	mov	r9,473
            LSB1(fs_gu32_addrsector) = fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+9];
8000de5a:	e0 6a 01 d8 	mov	r10,472
8000de5e:	e0 6b 01 d7 	mov	r11,471
            LSB2(fs_gu32_addrsector) = fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+10];
8000de62:	e0 6c 01 d6 	mov	r12,470
8000de66:	ee 0c 07 0c 	ld.ub	r12,r7[r12]
            LSB3(fs_gu32_addrsector) = fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+11];
8000de6a:	a4 bc       	st.b	r2[0x3],r12
8000de6c:	ee 0b 07 0b 	ld.ub	r11,r7[r11]
            fs_gu32_addrsector *= mem_sector_size( fs_g_nav.u8_lun );
8000de70:	a4 ab       	st.b	r2[0x2],r11
8000de72:	e0 6b 0f 2c 	mov	r11,3884
8000de76:	ee 0a 07 0a 	ld.ub	r10,r7[r10]
8000de7a:	a4 9a       	st.b	r2[0x1],r10
8000de7c:	ee 09 07 09 	ld.ub	r9,r7[r9]
         break;   // valid PBR found
      }
      // PBR not found
      fs_g_status = FS_ERR_NO_PART;
      return false;
   }
8000de80:	a4 89       	st.b	r2[0x0],r9
8000de82:	17 8c       	ld.ub	r12,r11[0x0]
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
         {
            // The first sector must be a MBR, then check the partition entry in the MBR
            if ( ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_BOOTABLE             )||
8000de84:	50 18       	stdsp	sp[0x4],r8
8000de86:	e0 a0 06 3d 	rcall	8000eb00 <mem_sector_size>
8000de8a:	64 09       	ld.w	r9,r2[0x0]
8000de8c:	f8 09 02 49 	mul	r9,r12,r9
8000de90:	85 09       	st.w	r2[0x0],r9
8000de92:	40 18       	lddsp	r8,sp[0x4]
8000de94:	fe 9f fe 4b 	bral	8000db2a <fat_mount+0x32>
8000de98:	e0 69 01 e9 	mov	r9,489
8000de9c:	e0 6a 01 e8 	mov	r10,488
8000dea0:	e0 6b 01 e7 	mov	r11,487
8000dea4:	e0 6c 01 e6 	mov	r12,486
8000dea8:	cd fb       	rjmp	8000de66 <fat_mount+0x36e>
8000deaa:	e0 69 01 c9 	mov	r9,457
8000deae:	e0 6a 01 c8 	mov	r10,456
8000deb2:	e0 6b 01 c7 	mov	r11,455
8000deb6:	e0 6c 01 c6 	mov	r12,454
      LSB3( u32_tmp ) = LOW3_32_BPB_FATSz32;
   }
   fs_g_nav.u32_fat_size = u32_tmp * u8_sector_size;

   // Get total count of sectors in partition
   if ( (0==LOW_16_BPB_TotSec16) && (0==HIGH_16_BPB_TotSec16) )
8000deba:	cd 6b       	rjmp	8000de66 <fat_mount+0x36e>
8000debc:	e0 69 01 f9 	mov	r9,505
      LSB3( u32_tmp ) = LOW3_32_BPB_TotSec32;
   }
   else
   {
      LSB0( u32_tmp ) = LOW_16_BPB_TotSec16;
      LSB1( u32_tmp ) = HIGH_16_BPB_TotSec16;
8000dec0:	e0 6a 01 f8 	mov	r10,504
      LSB2( u32_tmp ) = 0;
8000dec4:	e0 6b 01 f7 	mov	r11,503
      LSB3( u32_tmp ) = 0;
8000dec8:	e0 6c 01 f6 	mov	r12,502

      // Check PBR/MBR signature
      if ( (fs_g_sector[510] != FS_BR_SIGNATURE_LOW  )
      &&   (fs_g_sector[511] != FS_BR_SIGNATURE_HIGH ) )
      {
         fs_g_status = FS_ERR_NO_FORMAT;
8000decc:	cc db       	rjmp	8000de66 <fat_mount+0x36e>
8000dece:	e7 32 00 14 	ld.ub	r2,r3[20]
         return false;
8000ded2:	ac 8a       	st.b	r6[0x0],r10
   u32_tmp=0;
   LSB0( u32_tmp ) = LOW_16_BPB_FATSz16;
   LSB1( u32_tmp ) = HIGH_16_BPB_FATSz16;
   if ( 0==u32_tmp )
   {
      LSB0( u32_tmp ) = LOW0_32_BPB_FATSz32;
8000ded4:	ae 82       	st.b	r7[0x0],r2
8000ded6:	30 0a       	mov	r10,0
8000ded8:	a8 8a       	st.b	r4[0x0],r10
      LSB1( u32_tmp ) = LOW1_32_BPB_FATSz32;
8000deda:	aa 8a       	st.b	r5[0x0],r10
8000dedc:	c4 fb       	rjmp	8000dd7a <fat_mount+0x282>
8000dede:	30 29       	mov	r9,2
      LSB2( u32_tmp ) = LOW2_32_BPB_FATSz32;
8000dee0:	e0 68 0f 7c 	mov	r8,3964
8000dee4:	30 0c       	mov	r12,0
8000dee6:	b0 89       	st.b	r8[0x0],r9
8000dee8:	cf da       	rjmp	8000dce2 <fat_mount+0x1ea>
      LSB3( u32_tmp ) = LOW3_32_BPB_FATSz32;
8000deea:	f5 39 00 24 	ld.ub	r9,r10[36]
8000deee:	ac 89       	st.b	r6[0x0],r9
8000def0:	f5 39 00 25 	ld.ub	r9,r10[37]
   {
      // Is FAT 12
#if (FS_FAT_12 == false)
      return false;
#endif
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_12;
8000def4:	ae 89       	st.b	r7[0x0],r9
8000def6:	f5 39 00 26 	ld.ub	r9,r10[38]
8000defa:	fa c4 ff f3 	sub	r4,sp,-13
   {
      // Is FAT 16
#if (FS_FAT_16 == false)
      return FS_NO_SUPPORT_PART;
#endif
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_16;
8000defe:	a8 89       	st.b	r4[0x0],r9
8000df00:	f5 39 00 27 	ld.ub	r9,r10[39]
8000df04:	aa 89       	st.b	r5[0x0],r9
8000df06:	40 39       	lddsp	r9,sp[0xc]
8000df08:	c1 db       	rjmp	8000dd42 <fat_mount+0x24a>
8000df0a:	30 18       	mov	r8,1
8000df0c:	e0 6b 0f 78 	mov	r11,3960
8000df10:	30 1c       	mov	r12,1
8000df12:	b6 88       	st.b	r11[0x0],r8
8000df14:	ce 7a       	rjmp	8000dce2 <fat_mount+0x1ea>
8000df16:	30 28       	mov	r8,2
8000df18:	e0 6a 0f 78 	mov	r10,3960
8000df1c:	30 1c       	mov	r12,1
8000df1e:	b4 88       	st.b	r10[0x0],r8
8000df20:	ce 1a       	rjmp	8000dce2 <fat_mount+0x1ea>
8000df22:	d7 03       	nop

8000df24 <file_bof>:
//! @return    1     the position is at the beginning of file
//! @return    0     the position isn't at the beginning of file
//! @return    FFh   error
//!
uint8_t    file_bof( void )
{
8000df24:	d4 01       	pushm	lr
   if( !fat_check_mount_select_open() )
8000df26:	fe b0 f7 6d 	rcall	8000ce00 <fat_check_mount_select_open>
8000df2a:	c0 70       	breq	8000df38 <file_bof+0x14>
      return 0xFF;

   return (0 == fs_g_nav_entry.u32_pos_in_file );
8000df2c:	e0 68 0c ec 	mov	r8,3308
8000df30:	70 38       	ld.w	r8,r8[0xc]
8000df32:	58 08       	cp.w	r8,0
}
8000df34:	5f 0c       	sreq	r12
//! @return    0     the position isn't at the beginning of file
//! @return    FFh   error
//!
uint8_t    file_bof( void )
{
   if( !fat_check_mount_select_open() )
8000df36:	d8 02       	popm	pc
8000df38:	e0 6c 00 ff 	mov	r12,255
8000df3c:	d8 02       	popm	pc
8000df3e:	d7 03       	nop

8000df40 <file_seek>:
8000df40:	eb cd 40 c0 	pushm	r6-r7,lr
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  file_seek( uint32_t u32_pos , uint8_t u8_whence )
{
8000df44:	18 97       	mov	r7,r12
8000df46:	16 96       	mov	r6,r11
   if( !fat_check_mount_select_open())
8000df48:	fe b0 f7 5c 	rcall	8000ce00 <fat_check_mount_select_open>
8000df4c:	c2 50       	breq	8000df96 <file_seek+0x56>
      return false;

   switch(u8_whence)
8000df4e:	30 18       	mov	r8,1
8000df50:	f0 06 18 00 	cp.b	r6,r8
8000df54:	c2 30       	breq	8000df9a <file_seek+0x5a>
8000df56:	c0 e2       	brcc	8000df72 <file_seek+0x32>
      // update the position
      fs_g_nav_entry.u32_pos_in_file -= u32_pos;
      break;

      case FS_SEEK_SET:
      if( fs_g_nav_entry.u32_size < u32_pos )
8000df58:	e0 68 0c ec 	mov	r8,3308
8000df5c:	70 29       	ld.w	r9,r8[0x8]
8000df5e:	12 37       	cp.w	r7,r9
8000df60:	e0 88 00 25 	brls	8000dfaa <file_seek+0x6a>

      case FS_SEEK_CUR_FW:
      u32_pos += fs_g_nav_entry.u32_pos_in_file;
      if( fs_g_nav_entry.u32_size < u32_pos )
      {  // Out of the limit
         fs_g_status = FS_ERR_BAD_POS;
8000df64:	30 79       	mov	r9,7
8000df66:	e0 68 0f 7c 	mov	r8,3964
         return false;
8000df6a:	30 0c       	mov	r12,0
8000df6c:	b0 89       	st.b	r8[0x0],r9
bool  file_seek( uint32_t u32_pos , uint8_t u8_whence )
{
   if( !fat_check_mount_select_open())
      return false;

   switch(u8_whence)
8000df6e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000df72:	30 28       	mov	r8,2
8000df74:	f0 06 18 00 	cp.b	r6,r8
8000df78:	c1 c0       	breq	8000dfb0 <file_seek+0x70>
8000df7a:	30 38       	mov	r8,3
8000df7c:	f0 06 18 00 	cp.b	r6,r8
      // update the position
      fs_g_nav_entry.u32_pos_in_file = fs_g_nav_entry.u32_size - u32_pos;
      break;

      case FS_SEEK_CUR_FW:
      u32_pos += fs_g_nav_entry.u32_pos_in_file;
8000df80:	c1 61       	brne	8000dfac <file_seek+0x6c>
8000df82:	e0 68 0c ec 	mov	r8,3308
      if( fs_g_nav_entry.u32_size < u32_pos )
8000df86:	70 39       	ld.w	r9,r8[0xc]
8000df88:	12 07       	add	r7,r9
8000df8a:	70 29       	ld.w	r9,r8[0x8]
      {  // Out of the limit
         fs_g_status = FS_ERR_BAD_POS;
         return false;
      }
      // update the position
      fs_g_nav_entry.u32_pos_in_file = u32_pos;
8000df8c:	12 37       	cp.w	r7,r9
8000df8e:	fe 9b ff eb 	brhi	8000df64 <file_seek+0x24>
      break;
   }
   return true;
}
8000df92:	91 37       	st.w	r8[0xc],r7
      // update the position
      fs_g_nav_entry.u32_pos_in_file = u32_pos;
      break;

      case FS_SEEK_END:
      if( fs_g_nav_entry.u32_size < u32_pos )
8000df94:	30 1c       	mov	r12,1
8000df96:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000df9a:	e0 68 0c ec 	mov	r8,3308
      {  // Out of the limit
         fs_g_status = FS_ERR_BAD_POS;
         return false;
      }
      // update the position
      fs_g_nav_entry.u32_pos_in_file = fs_g_nav_entry.u32_size - u32_pos;
8000df9e:	70 29       	ld.w	r9,r8[0x8]
8000dfa0:	12 37       	cp.w	r7,r9
8000dfa2:	fe 9b ff e1 	brhi	8000df64 <file_seek+0x24>
8000dfa6:	f2 07 01 07 	sub	r7,r9,r7
      return false;

   switch(u8_whence)
   {
      case FS_SEEK_CUR_RE:
      if( fs_g_nav_entry.u32_pos_in_file < u32_pos )
8000dfaa:	91 37       	st.w	r8[0xc],r7
8000dfac:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
      {  // Out of the limit
         fs_g_status = FS_ERR_BAD_POS;
         return false;
      }
      // update the position
      fs_g_nav_entry.u32_pos_in_file -= u32_pos;
8000dfb0:	e0 68 0c ec 	mov	r8,3308
8000dfb4:	70 39       	ld.w	r9,r8[0xc]
8000dfb6:	0e 39       	cp.w	r9,r7
      break;
8000dfb8:	cd 63       	brcs	8000df64 <file_seek+0x24>
8000dfba:	f2 07 01 07 	sub	r7,r9,r7
8000dfbe:	30 1c       	mov	r12,1
8000dfc0:	91 37       	st.w	r8[0xc],r7
8000dfc2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000dfc6:	d7 03       	nop

8000dfc8 <file_close>:


//! This function closes the file
//!
void  file_close( void )
{
8000dfc8:	eb cd 40 80 	pushm	r7,lr
   // If a file is opened, then close this one
   if( fat_check_mount_select_open() )
8000dfcc:	fe b0 f7 1a 	rcall	8000ce00 <fat_check_mount_select_open>
8000dfd0:	c0 90       	breq	8000dfe2 <file_close+0x1a>
   {

#if (FSFEATURE_WRITE == (FS_LEVEL_FEATURES & FSFEATURE_WRITE))
      if( FOPEN_WRITE_ACCESS & fs_g_nav_entry.u8_open_mode )
8000dfd2:	e0 67 0c ec 	mov	r7,3308
8000dfd6:	0f 88       	ld.ub	r8,r7[0x0]
8000dfd8:	ed b8 00 01 	bld	r8,0x1
            return;           // error
         fat_write_entry_file();
         fat_cache_flush();   // In case of error during writing data, flush the data before exit function
      }
#endif  // FS_LEVEL_FEATURES
      Fat_file_close();
8000dfdc:	c0 50       	breq	8000dfe6 <file_close+0x1e>
8000dfde:	30 08       	mov	r8,0
8000dfe0:	ae 88       	st.b	r7[0x0],r8
8000dfe2:	e3 cd 80 80 	ldm	sp++,r7,pc

#if (FSFEATURE_WRITE == (FS_LEVEL_FEATURES & FSFEATURE_WRITE))
      if( FOPEN_WRITE_ACCESS & fs_g_nav_entry.u8_open_mode )
      {
         // Write file information
         if( !fat_read_dir() )
8000dfe6:	fe b0 fb 59 	rcall	8000d698 <fat_read_dir>
            return;           // error
         fat_write_entry_file();
8000dfea:	cf c0       	breq	8000dfe2 <file_close+0x1a>
8000dfec:	fe b0 f0 8a 	rcall	8000c100 <fat_write_entry_file>
         fat_cache_flush();   // In case of error during writing data, flush the data before exit function
8000dff0:	fe b0 f3 68 	rcall	8000c6c0 <fat_cache_flush>
8000dff4:	cf 5b       	rjmp	8000dfde <file_close+0x16>
8000dff6:	d7 03       	nop

8000dff8 <file_getc>:
8000dff8:	eb cd 40 80 	pushm	r7,lr
8000dffc:	e0 67 0c ec 	mov	r7,3308
8000e000:	0f 88       	ld.ub	r8,r7[0x0]
8000e002:	ed b8 00 00 	bld	r8,0x0
8000e006:	c0 80       	breq	8000e016 <file_getc+0x1e>

   while(1)
   {
      if(!(FOPEN_READ_ACCESS & fs_g_nav_entry.u8_open_mode))
      {
         fs_g_status = FS_ERR_WRITE_ONLY;
8000e008:	31 e9       	mov	r9,30
8000e00a:	e0 68 0f 7c 	mov	r8,3964
         break;
8000e00e:	3f fc       	mov	r12,-1
8000e010:	b0 89       	st.b	r8[0x0],r9
      }
      if( fs_g_nav_entry.u32_size <= fs_g_nav_entry.u32_pos_in_file )
8000e012:	e3 cd 80 80 	ldm	sp++,r7,pc
8000e016:	6e 29       	ld.w	r9,r7[0x8]
8000e018:	6e 38       	ld.w	r8,r7[0xc]
8000e01a:	10 39       	cp.w	r9,r8
      {
         fs_g_status = FS_ERR_EOF;
8000e01c:	e0 8b 00 09 	brhi	8000e02e <file_getc+0x36>
8000e020:	32 09       	mov	r9,32
8000e022:	e0 68 0f 7c 	mov	r8,3964
         break;
8000e026:	3f fc       	mov	r12,-1
      }

      if( !fat_read_file( FS_CLUST_ACT_ONE ))
8000e028:	b0 89       	st.b	r8[0x0],r9
8000e02a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000e02e:	30 2c       	mov	r12,2
      {
         if( FS_ERR_OUT_LIST == fs_g_status )
8000e030:	fe b0 fb ae 	rcall	8000d78c <fat_read_file>
8000e034:	c0 e1       	brne	8000e050 <file_getc+0x58>
         {  // Translate the error
            fs_g_status = FS_ERR_EOF;   // End of file
8000e036:	e0 68 0f 7c 	mov	r8,3964
8000e03a:	31 a9       	mov	r9,26
8000e03c:	11 8a       	ld.ub	r10,r8[0x0]
8000e03e:	3f fc       	mov	r12,-1
8000e040:	f2 0a 18 00 	cp.b	r10,r9
8000e044:	f9 b9 00 20 	moveq	r9,32
         }
         break;
      }

      u16_byte = fs_g_sector[ fs_g_nav_entry.u32_pos_in_file & FS_512B_MASK ];
8000e048:	f1 f9 0e 00 	st.beq	r8[0x0],r9
      fs_g_nav_entry.u32_pos_in_file++;
8000e04c:	e3 cd 80 80 	ldm	sp++,r7,pc
            fs_g_status = FS_ERR_EOF;   // End of file
         }
         break;
      }

      u16_byte = fs_g_sector[ fs_g_nav_entry.u32_pos_in_file & FS_512B_MASK ];
8000e050:	6e 38       	ld.w	r8,r7[0xc]
      fs_g_nav_entry.u32_pos_in_file++;
8000e052:	f0 c9 ff ff 	sub	r9,r8,-1
            fs_g_status = FS_ERR_EOF;   // End of file
         }
         break;
      }

      u16_byte = fs_g_sector[ fs_g_nav_entry.u32_pos_in_file & FS_512B_MASK ];
8000e056:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
      fs_g_nav_entry.u32_pos_in_file++;
      return u16_byte;
   }
   return FS_EOF;   // No data read
}
8000e05a:	8f 39       	st.w	r7[0xc],r9
8000e05c:	e0 69 0d 2c 	mov	r9,3372
8000e060:	f2 08 07 0c 	ld.ub	r12,r9[r8]
8000e064:	e3 cd 80 80 	ldm	sp++,r7,pc

8000e068 <file_open>:
8000e068:	eb cd 40 e0 	pushm	r5-r7,lr
8000e06c:	18 97       	mov	r7,r12
8000e06e:	fe b0 fb e7 	rcall	8000d83c <fat_check_mount_select_noopen>
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  file_open( uint8_t fopen_mode )
{
   if( !fat_check_mount_select_noopen())
8000e072:	c0 31       	brne	8000e078 <file_open+0x10>
   else
   {  // Go to at the end of file
      fs_g_nav_entry.u32_pos_in_file = fs_g_nav_entry.u32_size;
   }
   fs_g_nav_entry.u8_open_mode = fopen_mode;
   return true;
8000e074:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
bool  file_open( uint8_t fopen_mode )
{
   if( !fat_check_mount_select_noopen())
      return false;

   if( !fat_check_is_file())
8000e078:	fe b0 ef 16 	rcall	8000bea4 <fat_check_is_file>
8000e07c:	cf c0       	breq	8000e074 <file_open+0xc>
      return false;

   if(FOPEN_WRITE_ACCESS & fopen_mode)
8000e07e:	0e 9c       	mov	r12,r7
8000e080:	e2 1c 00 02 	andl	r12,0x2,COH
8000e084:	c1 c1       	brne	8000e0bc <file_open+0x54>
      return false;
#endif  // FS_LEVEL_FEATURES
   }
   else
   {
      if( !fat_check_nav_access_file( false ) )
8000e086:	fe b0 f2 7f 	rcall	8000c584 <fat_check_nav_access_file>
8000e08a:	cf 50       	breq	8000e074 <file_open+0xc>
8000e08c:	e0 66 0c ec 	mov	r6,3308
         return false;
   }

   if(FOPEN_CLEAR_SIZE & fopen_mode)
   {
      fs_g_nav_entry.u32_size    = 0;     // The size is null
8000e090:	0e 98       	mov	r8,r7
8000e092:	ed b8 00 02 	bld	r8,0x2
8000e096:	f9 b8 00 00 	moveq	r8,0
8000e09a:	ed f8 0a 02 	st.weq	r6[0x8],r8
   }
   if(FOPEN_CLEAR_PTR & fopen_mode)
8000e09e:	ac 87       	st.b	r6[0x0],r7
   }
   else
   {  // Go to at the end of file
      fs_g_nav_entry.u32_pos_in_file = fs_g_nav_entry.u32_size;
   }
   fs_g_nav_entry.u8_open_mode = fopen_mode;
8000e0a0:	0e 98       	mov	r8,r7
   {
      fs_g_nav_entry.u32_size    = 0;     // The size is null
   }
   if(FOPEN_CLEAR_PTR & fopen_mode)
   {
      fs_g_nav_entry.u32_pos_in_file = 0;
8000e0a2:	30 1c       	mov	r12,1
8000e0a4:	ed b8 00 03 	bld	r8,0x3
8000e0a8:	f9 b8 00 00 	moveq	r8,0
8000e0ac:	ed f8 0a 03 	st.weq	r6[0xc],r8
   }
   else
   {  // Go to at the end of file
      fs_g_nav_entry.u32_pos_in_file = fs_g_nav_entry.u32_size;
8000e0b0:	ed f8 10 02 	ld.wne	r8,r6[0x8]
8000e0b4:	ed f8 1a 03 	st.wne	r6[0xc],r8
   }
   fs_g_nav_entry.u8_open_mode = fopen_mode;
   return true;
8000e0b8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
   if( !fat_check_is_file())
      return false;

   if(FOPEN_WRITE_ACCESS & fopen_mode)
   {
      if( !fat_check_nav_access_file( true ) )
8000e0bc:	30 1c       	mov	r12,1
8000e0be:	fe b0 f2 63 	rcall	8000c584 <fat_check_nav_access_file>
         return false;
#if (FSFEATURE_WRITE == (FS_LEVEL_FEATURES & FSFEATURE_WRITE))
      if (FS_ATTR_READ_ONLY & fs_g_nav_entry.u8_attr)
8000e0c2:	cd 90       	breq	8000e074 <file_open+0xc>
8000e0c4:	e0 66 0c ec 	mov	r6,3308
8000e0c8:	0d a5       	ld.ub	r5,r6[0x2]
8000e0ca:	eb d5 c0 01 	bfextu	r5,r5,0x0,0x1
      {
         fs_g_status = FS_ERR_READ_ONLY;  // File is read only
8000e0ce:	c0 80       	breq	8000e0de <file_open+0x76>
8000e0d0:	31 59       	mov	r9,21
8000e0d2:	e0 68 0f 7c 	mov	r8,3964
         return false;
8000e0d6:	30 0c       	mov	r12,0
      }
      if( mem_wr_protect( fs_g_nav.u8_lun  ))
8000e0d8:	b0 89       	st.b	r8[0x0],r9
8000e0da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000e0de:	e0 68 0f 2c 	mov	r8,3884
      {
         fs_g_status = FS_LUN_WP;  // Disk read only
8000e0e2:	11 8c       	ld.ub	r12,r8[0x0]
8000e0e4:	e0 a0 05 12 	rcall	8000eb08 <mem_wr_protect>
8000e0e8:	cd 40       	breq	8000e090 <file_open+0x28>
         return false;
8000e0ea:	31 49       	mov	r9,20
8000e0ec:	e0 68 0f 7c 	mov	r8,3964
8000e0f0:	0a 9c       	mov	r12,r5
8000e0f2:	b0 89       	st.b	r8[0x0],r9
8000e0f4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000e0f8 <file_read_buf>:
8000e0f8:	d4 31       	pushm	r0-r7,lr
8000e0fa:	18 97       	mov	r7,r12
8000e0fc:	16 95       	mov	r5,r11
8000e0fe:	fe b0 f6 81 	rcall	8000ce00 <fat_check_mount_select_open>
8000e102:	e0 80 00 94 	breq	8000e22a <file_read_buf+0x132>
8000e106:	e0 63 0c ec 	mov	r3,3308
8000e10a:	07 81       	ld.ub	r1,r3[0x0]
   _MEM_TYPE_FAST_ uint32_t u32_byte_remaining;

   if( !fat_check_mount_select_open())
      return false;

   if(!(FOPEN_READ_ACCESS & fs_g_nav_entry.u8_open_mode))
8000e10c:	e3 d1 c0 01 	bfextu	r1,r1,0x0,0x1
      return false;
   }

   u16_nb_read = 0;

   while( 0 != u16_buf_size )
8000e110:	c5 70       	breq	8000e1be <file_read_buf+0xc6>
8000e112:	58 05       	cp.w	r5,0
8000e114:	e0 80 00 8b 	breq	8000e22a <file_read_buf+0x132>
            if( FS_ERR_OUT_LIST == fs_g_status )
               fs_g_status = FS_ERR_EOF;  // translate the error
            return u16_nb_read;
         }
         // Truncate the segment size found if more larger than asked size
         if( u16_nb_read_tmp > fs_g_seg.u32_size_or_pos )
8000e118:	30 01       	mov	r1,0
8000e11a:	e0 66 0f d4 	mov	r6,4052
//! @return    0     the position isn't at the end of file
//! @return    FFh   error
//!
uint8_t    file_eof( void )
{
   if( !fat_check_mount_select_open() )
8000e11e:	e0 60 0f 2c 	mov	r0,3884
      return 0xFF;
   return (fs_g_nav_entry.u32_size <= fs_g_nav_entry.u32_pos_in_file );
8000e122:	fe b0 f6 6f 	rcall	8000ce00 <fat_check_mount_select_open>

   u16_nb_read = 0;

   while( 0 != u16_buf_size )
   {
      if ( file_eof() )
8000e126:	c7 d0       	breq	8000e220 <file_read_buf+0x128>
8000e128:	66 24       	ld.w	r4,r3[0x8]
8000e12a:	66 32       	ld.w	r2,r3[0xc]
      {
         fs_g_status = FS_ERR_EOF;
         return u16_nb_read;     // End of the file
      }
      u32_byte_remaining = fs_g_nav_entry.u32_size-fs_g_nav_entry.u32_pos_in_file;
8000e12c:	04 34       	cp.w	r4,r2
      u16_pos_in_sector = fs_g_nav_entry.u32_pos_in_file % FS_512B;

      if( (0== u16_pos_in_sector)
8000e12e:	e0 88 00 79 	brls	8000e220 <file_read_buf+0x128>
      {
         fs_g_status = FS_ERR_EOF;
         return u16_nb_read;     // End of the file
      }
      u32_byte_remaining = fs_g_nav_entry.u32_size-fs_g_nav_entry.u32_pos_in_file;
      u16_pos_in_sector = fs_g_nav_entry.u32_pos_in_file % FS_512B;
8000e132:	04 14       	sub	r4,r2

      if( (0== u16_pos_in_sector)
8000e134:	30 09       	mov	r9,0
8000e136:	e5 d2 c0 09 	bfextu	r2,r2,0x0,0x9
8000e13a:	f2 02 19 00 	cp.h	r2,r9
8000e13e:	5f 09       	sreq	r9
8000e140:	e0 44 01 ff 	cp.w	r4,511
8000e144:	5f b8       	srhi	r8
8000e146:	f3 e8 00 08 	and	r8,r9,r8
8000e14a:	30 09       	mov	r9,0
8000e14c:	f2 08 18 00 	cp.b	r8,r9
8000e150:	c3 d0       	breq	8000e1ca <file_read_buf+0xd2>
8000e152:	e0 68 01 ff 	mov	r8,511
8000e156:	f0 05 19 00 	cp.h	r5,r8
8000e15a:	e0 88 00 38 	brls	8000e1ca <file_read_buf+0xd2>
      &&  (Test_align((uint32_t)buffer, sizeof(uint32_t)))
#endif
      )
      {
         // The file data sector can been directly transfer from memory to buffer (don't use internal cache)
         if( u16_buf_size <= u32_byte_remaining)
8000e15e:	f1 d7 c0 02 	bfextu	r8,r7,0x0,0x2
8000e162:	c3 41       	brne	8000e1ca <file_read_buf+0xd2>
8000e164:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000e168:	10 34       	cp.w	r4,r8
            u16_nb_read_tmp = u32_byte_remaining;
         }
         u16_nb_read_tmp = u16_nb_read_tmp / FS_512B;  // read a modulo sector size

         // Get following sector segment of file
         if( !fat_read_file(FS_CLUST_ACT_SEG))
8000e16a:	c6 83       	brcs	8000e23a <file_read_buf+0x142>
8000e16c:	e9 d5 b0 10 	bfexts	r4,r5,0x0,0x10
8000e170:	30 1c       	mov	r12,1
         {
            u16_nb_read_tmp = u16_buf_size;
         }else{
            u16_nb_read_tmp = u32_byte_remaining;
         }
         u16_nb_read_tmp = u16_nb_read_tmp / FS_512B;  // read a modulo sector size
8000e172:	fe b0 fb 0d 	rcall	8000d78c <fat_read_file>
            if( FS_ERR_OUT_LIST == fs_g_status )
               fs_g_status = FS_ERR_EOF;  // translate the error
            return u16_nb_read;
         }
         // Truncate the segment size found if more larger than asked size
         if( u16_nb_read_tmp > fs_g_seg.u32_size_or_pos )
8000e176:	c6 80       	breq	8000e246 <file_read_buf+0x14e>
8000e178:	e9 d4 c1 27 	bfextu	r4,r4,0x9,0x7
8000e17c:	6c 18       	ld.w	r8,r6[0x4]
8000e17e:	08 99       	mov	r9,r4
8000e180:	5c 79       	castu.h	r9
         {
            u16_nb_read_tmp = fs_g_seg.u32_size_or_pos;
8000e182:	10 39       	cp.w	r9,r8
8000e184:	e0 88 00 5d 	brls	8000e23e <file_read_buf+0x146>
         }else{
            fs_g_seg.u32_size_or_pos = u16_nb_read_tmp;
         }

         // Directly data transfers from memory to buffer
         while( 0 != fs_g_seg.u32_size_or_pos )
8000e188:	e9 d8 b0 10 	bfexts	r4,r8,0x0,0x10
         // Truncate the segment size found if more larger than asked size
         if( u16_nb_read_tmp > fs_g_seg.u32_size_or_pos )
         {
            u16_nb_read_tmp = fs_g_seg.u32_size_or_pos;
         }else{
            fs_g_seg.u32_size_or_pos = u16_nb_read_tmp;
8000e18c:	58 08       	cp.w	r8,0
            if( CTRL_GOOD != memory_2_ram( fs_g_nav.u8_lun  , fs_g_seg.u32_addr, buffer))
            {
               fs_g_status = FS_ERR_HW;
               return u16_nb_read;
            }
            fs_g_seg.u32_size_or_pos--;
8000e18e:	c5 10       	breq	8000e230 <file_read_buf+0x138>
            fs_g_seg.u32_addr++;
8000e190:	6c 0b       	ld.w	r11,r6[0x0]
            if( CTRL_GOOD != memory_2_ram( fs_g_nav.u8_lun  , fs_g_seg.u32_addr, buffer))
            {
               fs_g_status = FS_ERR_HW;
               return u16_nb_read;
            }
            fs_g_seg.u32_size_or_pos--;
8000e192:	c0 98       	rjmp	8000e1a4 <file_read_buf+0xac>
            fs_g_seg.u32_addr++;
8000e194:	6c 18       	ld.w	r8,r6[0x4]
            if( CTRL_GOOD != memory_2_ram( fs_g_nav.u8_lun  , fs_g_seg.u32_addr, buffer))
            {
               fs_g_status = FS_ERR_HW;
               return u16_nb_read;
            }
            fs_g_seg.u32_size_or_pos--;
8000e196:	6c 0b       	ld.w	r11,r6[0x0]
            fs_g_seg.u32_addr++;
8000e198:	20 18       	sub	r8,1
         }else{
            fs_g_seg.u32_size_or_pos = u16_nb_read_tmp;
         }

         // Directly data transfers from memory to buffer
         while( 0 != fs_g_seg.u32_size_or_pos )
8000e19a:	2f fb       	sub	r11,-1
8000e19c:	8d 18       	st.w	r6[0x4],r8
         {
            if( CTRL_GOOD != memory_2_ram( fs_g_nav.u8_lun  , fs_g_seg.u32_addr, buffer))
8000e19e:	8d 0b       	st.w	r6[0x0],r11
8000e1a0:	58 08       	cp.w	r8,0
               fs_g_status = FS_ERR_HW;
               return u16_nb_read;
            }
            fs_g_seg.u32_size_or_pos--;
            fs_g_seg.u32_addr++;
            buffer += FS_512B;
8000e1a2:	c4 70       	breq	8000e230 <file_read_buf+0x138>
8000e1a4:	0e 9a       	mov	r10,r7
         }

         // Directly data transfers from memory to buffer
         while( 0 != fs_g_seg.u32_size_or_pos )
         {
            if( CTRL_GOOD != memory_2_ram( fs_g_nav.u8_lun  , fs_g_seg.u32_addr, buffer))
8000e1a6:	01 8c       	ld.ub	r12,r0[0x0]
8000e1a8:	ee c7 fe 00 	sub	r7,r7,-512
            {
               fs_g_status = FS_ERR_HW;
8000e1ac:	e0 a0 04 b6 	rcall	8000eb18 <memory_2_ram>
      fs_g_nav_entry.u32_pos_in_file   += u16_nb_read_tmp;
      u16_nb_read                      += u16_nb_read_tmp;
      u16_buf_size                     -= u16_nb_read_tmp;
   }
   return u16_nb_read;  // Buffer is full
}
8000e1b0:	cf 20       	breq	8000e194 <file_read_buf+0x9c>
         // Directly data transfers from memory to buffer
         while( 0 != fs_g_seg.u32_size_or_pos )
         {
            if( CTRL_GOOD != memory_2_ram( fs_g_nav.u8_lun  , fs_g_seg.u32_addr, buffer))
            {
               fs_g_status = FS_ERR_HW;
8000e1b2:	30 19       	mov	r9,1
      fs_g_nav_entry.u32_pos_in_file   += u16_nb_read_tmp;
      u16_nb_read                      += u16_nb_read_tmp;
      u16_buf_size                     -= u16_nb_read_tmp;
   }
   return u16_nb_read;  // Buffer is full
}
8000e1b4:	e0 68 0f 7c 	mov	r8,3964
   if( !fat_check_mount_select_open())
      return false;

   if(!(FOPEN_READ_ACCESS & fs_g_nav_entry.u8_open_mode))
   {
      fs_g_status = FS_ERR_WRITE_ONLY;
8000e1b8:	02 9c       	mov	r12,r1
8000e1ba:	b0 89       	st.b	r8[0x0],r9
      fs_g_nav_entry.u32_pos_in_file   += u16_nb_read_tmp;
      u16_nb_read                      += u16_nb_read_tmp;
      u16_buf_size                     -= u16_nb_read_tmp;
   }
   return u16_nb_read;  // Buffer is full
}
8000e1bc:	d8 32       	popm	r0-r7,pc
8000e1be:	31 e9       	mov	r9,30
      else
      {
         // The file data can't been directly transfer from memory to buffer, the internal cache must be used

         // Transfer data from memory to internal cache
         if( !fat_read_file( FS_CLUST_ACT_ONE ))
8000e1c0:	e0 68 0f 7c 	mov	r8,3964
8000e1c4:	b0 89       	st.b	r8[0x0],r9
8000e1c6:	02 9c       	mov	r12,r1
            }
            return u16_nb_read;
         }

         // Compute the number of data to transfer
         u16_nb_read_tmp = FS_512B - u16_pos_in_sector;  // The number is limited at sector size
8000e1c8:	d8 32       	popm	r0-r7,pc
8000e1ca:	30 2c       	mov	r12,2
8000e1cc:	fe b0 fa e0 	rcall	8000d78c <fat_read_file>
         if( u16_nb_read_tmp > u32_byte_remaining )
8000e1d0:	c3 b0       	breq	8000e246 <file_read_buf+0x14e>
8000e1d2:	e0 68 02 00 	mov	r8,512
8000e1d6:	04 18       	sub	r8,r2
            u16_nb_read_tmp = u32_byte_remaining;
8000e1d8:	5c 88       	casts.h	r8
8000e1da:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
8000e1de:	12 34       	cp.w	r4,r9
8000e1e0:	c0 22       	brcc	8000e1e4 <file_read_buf+0xec>
8000e1e2:	08 98       	mov	r8,r4
8000e1e4:	f0 05 19 00 	cp.h	r5,r8
8000e1e8:	f0 04 17 20 	movhs	r4,r8
         if( u16_nb_read_tmp > u16_buf_size )
            u16_nb_read_tmp = u16_buf_size;

         // Transfer data from internal cache to buffer
         memcpy_ram2ram( buffer , &fs_g_sector[ u16_pos_in_sector ], u16_nb_read_tmp );
8000e1ec:	ea 04 17 30 	movlo	r4,r5
8000e1f0:	e0 6b 0d 2c 	mov	r11,3372
8000e1f4:	5c 84       	casts.h	r4
8000e1f6:	04 0b       	add	r11,r2
8000e1f8:	0e 9c       	mov	r12,r7
         buffer += u16_nb_read_tmp;
      }
      // Update positions
      fs_g_nav_entry.u32_pos_in_file   += u16_nb_read_tmp;
8000e1fa:	08 92       	mov	r2,r4
8000e1fc:	5c 72       	castu.h	r2
8000e1fe:	04 07       	add	r7,r2
      u16_nb_read                      += u16_nb_read_tmp;
      u16_buf_size                     -= u16_nb_read_tmp;
8000e200:	04 9a       	mov	r10,r2
         memcpy_ram2ram( buffer , &fs_g_sector[ u16_pos_in_sector ], u16_nb_read_tmp );
         buffer += u16_nb_read_tmp;
      }
      // Update positions
      fs_g_nav_entry.u32_pos_in_file   += u16_nb_read_tmp;
      u16_nb_read                      += u16_nb_read_tmp;
8000e202:	e0 a0 10 9d 	rcall	8001033c <memcpy>
      u16_buf_size                     -= u16_nb_read_tmp;
8000e206:	66 38       	ld.w	r8,r3[0xc]
         memcpy_ram2ram( buffer , &fs_g_sector[ u16_pos_in_sector ], u16_nb_read_tmp );
         buffer += u16_nb_read_tmp;
      }
      // Update positions
      fs_g_nav_entry.u32_pos_in_file   += u16_nb_read_tmp;
      u16_nb_read                      += u16_nb_read_tmp;
8000e208:	10 02       	add	r2,r8
      return false;
   }

   u16_nb_read = 0;

   while( 0 != u16_buf_size )
8000e20a:	87 32       	st.w	r3[0xc],r2
8000e20c:	08 15       	sub	r5,r4
//! @return    0     the position isn't at the end of file
//! @return    FFh   error
//!
uint8_t    file_eof( void )
{
   if( !fat_check_mount_select_open() )
8000e20e:	e8 01 00 01 	add	r1,r4,r1
8000e212:	5c 85       	casts.h	r5

   while( 0 != u16_buf_size )
   {
      if ( file_eof() )
      {
         fs_g_status = FS_ERR_EOF;
8000e214:	5c 81       	casts.h	r1
8000e216:	58 05       	cp.w	r5,0
8000e218:	cd 70       	breq	8000e1c6 <file_read_buf+0xce>
         return u16_nb_read;     // End of the file
8000e21a:	fe b0 f5 f3 	rcall	8000ce00 <fat_check_mount_select_open>
      fs_g_nav_entry.u32_pos_in_file   += u16_nb_read_tmp;
      u16_nb_read                      += u16_nb_read_tmp;
      u16_buf_size                     -= u16_nb_read_tmp;
   }
   return u16_nb_read;  // Buffer is full
}
8000e21e:	c8 51       	brne	8000e128 <file_read_buf+0x30>
8000e220:	32 09       	mov	r9,32
            fs_g_seg.u32_size_or_pos--;
            fs_g_seg.u32_addr++;
            buffer += FS_512B;
         }
         // Translate from sector unit to byte unit
         u16_nb_read_tmp *= FS_512B;
8000e222:	e0 68 0f 7c 	mov	r8,3964
8000e226:	b0 89       	st.b	r8[0x0],r9
8000e228:	cc fb       	rjmp	8000e1c6 <file_read_buf+0xce>
         return u16_nb_read;     // End of the file
      }
      u32_byte_remaining = fs_g_nav_entry.u32_size-fs_g_nav_entry.u32_pos_in_file;
      u16_pos_in_sector = fs_g_nav_entry.u32_pos_in_file % FS_512B;

      if( (0== u16_pos_in_sector)
8000e22a:	30 01       	mov	r1,0
         // The file data sector can been directly transfer from memory to buffer (don't use internal cache)
         if( u16_buf_size <= u32_byte_remaining)
         {
            u16_nb_read_tmp = u16_buf_size;
         }else{
            u16_nb_read_tmp = u32_byte_remaining;
8000e22c:	02 9c       	mov	r12,r1
8000e22e:	d8 32       	popm	r0-r7,pc
         // Truncate the segment size found if more larger than asked size
         if( u16_nb_read_tmp > fs_g_seg.u32_size_or_pos )
         {
            u16_nb_read_tmp = fs_g_seg.u32_size_or_pos;
         }else{
            fs_g_seg.u32_size_or_pos = u16_nb_read_tmp;
8000e230:	a9 74       	lsl	r4,0x9
8000e232:	5c 84       	casts.h	r4
8000e234:	08 92       	mov	r2,r4
         // The file data can't been directly transfer from memory to buffer, the internal cache must be used

         // Transfer data from memory to internal cache
         if( !fat_read_file( FS_CLUST_ACT_ONE ))
         {
            if( FS_ERR_OUT_LIST == fs_g_status )
8000e236:	5c 72       	castu.h	r2
8000e238:	ce 7b       	rjmp	8000e206 <file_read_buf+0x10e>
8000e23a:	5c 84       	casts.h	r4
8000e23c:	c9 ab       	rjmp	8000e170 <file_read_buf+0x78>
8000e23e:	e0 68 0f d4 	mov	r8,4052
            {  // Translate the error
               fs_g_status = FS_ERR_EOF;   // End of file
8000e242:	91 19       	st.w	r8[0x4],r9
8000e244:	ca 6b       	rjmp	8000e190 <file_read_buf+0x98>
8000e246:	e0 68 0f 7c 	mov	r8,3964
8000e24a:	31 a9       	mov	r9,26
8000e24c:	11 8a       	ld.ub	r10,r8[0x0]
8000e24e:	f2 0a 18 00 	cp.b	r10,r9
8000e252:	cb a1       	brne	8000e1c6 <file_read_buf+0xce>
8000e254:	32 09       	mov	r9,32
8000e256:	b0 89       	st.b	r8[0x0],r9
8000e258:	cb 7b       	rjmp	8000e1c6 <file_read_buf+0xce>
8000e25a:	d7 03       	nop

8000e25c <nav_checkdisk_disable>:
//! This check can reduce the speed access on specific disk.
//! @endverbatim
//!
void  nav_checkdisk_disable( void )
{
   g_b_no_check_disk = true;
8000e25c:	30 19       	mov	r9,1
8000e25e:	e0 68 0c fe 	mov	r8,3326
}
8000e262:	b0 89       	st.b	r8[0x0],r9
8000e264:	5e fc       	retal	r12
8000e266:	d7 03       	nop

8000e268 <nav_drive_get>:
//!
//! @return    0 to nav_drive_nb()-1
//! @return    0xFF in case of no drive selected
//!
uint8_t    nav_drive_get( void )
{
8000e268:	e0 68 0f 2c 	mov	r8,3884
      return 0xFF;
   return ((fs_g_nav.u8_lun*4) + fs_g_nav.u8_partition); // Maximum 4 partitions per device
#else
   return (fs_g_nav.u8_lun);
#endif
}
8000e26c:	11 8c       	ld.ub	r12,r8[0x0]
8000e26e:	5e fc       	retal	r12

8000e270 <nav_filelist_get>:
8000e270:	e0 68 0f 2c 	mov	r8,3884
//! @return    FS_NO_SEL, in case of no file selected
//!
uint16_t   nav_filelist_get( void )
{
   return fs_g_nav.u16_pos_sel_file;
}
8000e274:	f1 0c 00 24 	ld.sh	r12,r8[36]
8000e278:	5e fc       	retal	r12
8000e27a:	d7 03       	nop

8000e27c <nav_file_lgt>:
//! This function returns the size of selected file (unit byte)
//!
//! @return    Size of selected file (unit byte)
//!
uint32_t   nav_file_lgt( void )
{
8000e27c:	e0 68 0c ec 	mov	r8,3308
   return fs_g_nav_entry.u32_size;
}
8000e280:	70 2c       	ld.w	r12,r8[0x8]
8000e282:	5e fc       	retal	r12

8000e284 <nav_file_checkext>:
8000e284:	eb cd 40 80 	pushm	r7,lr
//!
//! @return    true, the file extension match with extension filter
//! @return    false, in other case
//!
bool  nav_file_checkext( const FS_STRING sz_filterext )
{
8000e288:	18 97       	mov	r7,r12
   if ( fat_check_mount_select() )
8000e28a:	fe b0 f5 43 	rcall	8000cd10 <fat_check_mount_select>
8000e28e:	c0 31       	brne	8000e294 <nav_file_checkext+0x10>
   {
      // Read selected entry (=short name entry) in directory
      if ( fat_read_dir())
      {
         // Check the extension with filter
         if ( fat_entry_checkext( (FS_STRING) sz_filterext ) )
8000e290:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
bool  nav_file_checkext( const FS_STRING sz_filterext )
{
   if ( fat_check_mount_select() )
   {
      // Read selected entry (=short name entry) in directory
      if ( fat_read_dir())
8000e294:	fe b0 fa 02 	rcall	8000d698 <fat_read_dir>
8000e298:	cf c0       	breq	8000e290 <nav_file_checkext+0xc>
      {
         // Check the extension with filter
         if ( fat_entry_checkext( (FS_STRING) sz_filterext ) )
8000e29a:	0e 9c       	mov	r12,r7
8000e29c:	fe b0 ee 9c 	rcall	8000bfd4 <fat_entry_checkext>
8000e2a0:	e3 cd 80 80 	ldm	sp++,r7,pc

8000e2a4 <nav_file_isdir>:
8000e2a4:	d4 01       	pushm	lr
8000e2a6:	fe b0 ef 0d 	rcall	8000c0c0 <fat_entry_is_dir>
8000e2aa:	d8 02       	popm	pc

8000e2ac <nav_filelist_set>:
8000e2ac:	d4 31       	pushm	r0-r7,lr
8000e2ae:	20 4d       	sub	sp,16
//! @verbatim
//! Note: if no file is selected then nav_filelist_set( 0 , FS_NEXT ) goes to the first entry of the file list.
//! @endverbatim
//!
bool  nav_filelist_set( uint16_t u16_nb , bool b_direction )
{
8000e2b0:	50 0c       	stdsp	sp[0x0],r12
8000e2b2:	16 95       	mov	r5,r11
   uint16_t   u16_ptr_save_entry;
   uint16_t   u16_save_pos_sel_file;
   bool  b_save_entry_type;
   bool  b_find_last_entry = false;

   if ( !fat_check_mount_noopen())
8000e2b4:	fe b0 f6 2c 	rcall	8000cf0c <fat_check_mount_noopen>
8000e2b8:	e0 80 00 97 	breq	8000e3e6 <nav_filelist_set+0x13a>
      return false;

   // Save the current selection
   u16_ptr_save_entry      = fs_g_nav_fast.u16_entry_pos_sel_file;
   u16_save_pos_sel_file   = fs_g_nav.u16_pos_sel_file;
8000e2bc:	e0 64 0f 2c 	mov	r4,3884
8000e2c0:	e0 67 0f 78 	mov	r7,3960

   if ( !fat_check_mount_noopen())
      return false;

   // Save the current selection
   u16_ptr_save_entry      = fs_g_nav_fast.u16_entry_pos_sel_file;
8000e2c4:	e9 08 00 24 	ld.sh	r8,r4[36]
8000e2c8:	8e 19       	ld.sh	r9,r7[0x2]
   u16_save_pos_sel_file   = fs_g_nav.u16_pos_sel_file;
8000e2ca:	30 06       	mov	r6,0
   b_save_entry_type       = fs_g_nav.b_mode_nav;
8000e2cc:	50 19       	stdsp	sp[0x4],r9
8000e2ce:	50 28       	stdsp	sp[0x8],r8
8000e2d0:	e9 39 00 2c 	ld.ub	r9,r4[44]
8000e2d4:	40 18       	lddsp	r8,sp[0x4]
   while( 1 )
   {
      if(( FS_FIND_NEXT == b_direction )
      || ( b_find_last_entry ) )
      {
         if ( FS_END_FIND == fs_g_nav_fast.u16_entry_pos_sel_file )
8000e2d6:	50 39       	stdsp	sp[0xc],r9
            break;
         }
         if ( 0 == fs_g_nav_fast.u16_entry_pos_sel_file )
         {
            // beginning of directory
            if ( (FS_DIR == fs_g_nav.b_mode_nav ) || fs_g_nav.b_mode_nav_single )
8000e2d8:	5c 88       	casts.h	r8
           continue;
         }
      }

      // Here error, check type of error
      if(( FS_ERR_ENTRY_EMPTY == fs_g_status )
8000e2da:	3f e0       	mov	r0,-2
8000e2dc:	0c 93       	mov	r3,r6
8000e2de:	e0 61 0f 7c 	mov	r1,3964
   b_save_entry_type       = fs_g_nav.b_mode_nav;

   // Loop in directory
   while( 1 )
   {
      if(( FS_FIND_NEXT == b_direction )
8000e2e2:	31 a2       	mov	r2,26
         }
         fs_g_nav_fast.u16_entry_pos_sel_file++;      // Update entry position
      }
      else
      {
         if ( FS_NO_SEL == fs_g_nav_fast.u16_entry_pos_sel_file )
8000e2e4:	c2 78       	rjmp	8000e332 <nav_filelist_set+0x86>
8000e2e6:	58 06       	cp.w	r6,0
8000e2e8:	c2 71       	brne	8000e336 <nav_filelist_set+0x8a>
8000e2ea:	3f f9       	mov	r9,-1
8000e2ec:	f2 08 19 00 	cp.h	r8,r9
         {
            // No selected file then previous action impossible
            fs_g_status = FS_ERR_NO_FIND;
            break;
         }
         if ( 0 == fs_g_nav_fast.u16_entry_pos_sel_file )
8000e2f0:	e0 80 00 8b 	breq	8000e406 <nav_filelist_set+0x15a>
         {
            // beginning of directory
            if ( (FS_DIR == fs_g_nav.b_mode_nav ) || fs_g_nav.b_mode_nav_single )
8000e2f4:	58 08       	cp.w	r8,0
8000e2f6:	c6 61       	brne	8000e3c2 <nav_filelist_set+0x116>
8000e2f8:	e9 38 00 2c 	ld.ub	r8,r4[44]
8000e2fc:	e6 08 18 00 	cp.b	r8,r3
8000e300:	e0 80 00 83 	breq	8000e406 <nav_filelist_set+0x15a>
8000e304:	e0 69 0f 2c 	mov	r9,3884
8000e308:	f3 38 00 2d 	ld.ub	r8,r9[45]
         }else{
            fs_g_nav_fast.u16_entry_pos_sel_file--;   // Update entry position
         }
      }

      if( !fat_read_dir())
8000e30c:	e6 08 18 00 	cp.b	r8,r3
      {
         if( FS_ERR_OUT_LIST != fs_g_status )
8000e310:	c7 b1       	brne	8000e406 <nav_filelist_set+0x15a>
8000e312:	30 16       	mov	r6,1
8000e314:	fe b0 f9 c2 	rcall	8000d698 <fat_read_dir>
8000e318:	c1 71       	brne	8000e346 <nav_filelist_set+0x9a>
      // Here error, check type of error
      if(( FS_ERR_ENTRY_EMPTY == fs_g_status )
      || ( FS_ERR_OUT_LIST    == fs_g_status ) )
      {
         // Here, end of the directory
         if( b_find_last_entry )
8000e31a:	e0 6a 0f 7c 	mov	r10,3964
         {
            // Re enable the previous command at the end of directory to find the last directory entry
            b_find_last_entry = false;
            fs_g_nav.b_mode_nav = FS_DIR;
8000e31e:	03 88       	ld.ub	r8,r1[0x0]
8000e320:	e4 08 18 00 	cp.b	r8,r2
      return false;

   // Save the current selection
   u16_ptr_save_entry      = fs_g_nav_fast.u16_entry_pos_sel_file;
   u16_save_pos_sel_file   = fs_g_nav.u16_pos_sel_file;
   b_save_entry_type       = fs_g_nav.b_mode_nav;
8000e324:	c5 61       	brne	8000e3d0 <nav_filelist_set+0x124>

   // Loop in directory
   while( 1 )
   {
      if(( FS_FIND_NEXT == b_direction )
8000e326:	58 06       	cp.w	r6,0
8000e328:	c2 90       	breq	8000e37a <nav_filelist_set+0xce>
      || ( b_find_last_entry ) )
      {
         if ( FS_END_FIND == fs_g_nav_fast.u16_entry_pos_sel_file )
8000e32a:	e9 63 00 2c 	st.b	r4[44],r3
8000e32e:	30 06       	mov	r6,0
         {
            // Too many files in directory (case impossible)
            fs_g_status = FS_ERR_FS;
            break;
         }
         fs_g_nav_fast.u16_entry_pos_sel_file++;      // Update entry position
8000e330:	8e 18       	ld.sh	r8,r7[0x2]
8000e332:	58 05       	cp.w	r5,0
         }else{
            fs_g_nav_fast.u16_entry_pos_sel_file--;   // Update entry position
         }
      }

      if( !fat_read_dir())
8000e334:	cd 90       	breq	8000e2e6 <nav_filelist_set+0x3a>
8000e336:	e0 08 19 00 	cp.h	r8,r0
      {
         if( FS_ERR_OUT_LIST != fs_g_status )
            break; // Error
      }else{
         if ( fat_entry_check( fs_g_nav.b_mode_nav ) )
8000e33a:	c4 70       	breq	8000e3c8 <nav_filelist_set+0x11c>
8000e33c:	2f f8       	sub	r8,-1
8000e33e:	ae 18       	st.h	r7[0x2],r8
8000e340:	fe b0 f9 ac 	rcall	8000d698 <fat_read_dir>
8000e344:	ce b0       	breq	8000e31a <nav_filelist_set+0x6e>
8000e346:	e9 38 00 2c 	ld.ub	r8,r4[44]
         {
           // HERE, the file entry match with the type searched

           if( b_find_last_entry )
8000e34a:	e6 08 18 00 	cp.b	r8,r3
             continue;  // The search of last directory is on going then continue the search

           // Update position in directory
           if ( FS_FIND_NEXT == b_direction )
8000e34e:	5f 1c       	srne	r12
8000e350:	fe b0 ee 16 	rcall	8000bf7c <fat_entry_check>
              fs_g_nav.u16_pos_sel_file++;
           else
              fs_g_nav.u16_pos_sel_file--;
8000e354:	c2 80       	breq	8000e3a4 <nav_filelist_set+0xf8>
8000e356:	58 06       	cp.w	r6,0
8000e358:	ce c1       	brne	8000e330 <nav_filelist_set+0x84>
8000e35a:	58 05       	cp.w	r5,0
8000e35c:	c4 71       	brne	8000e3ea <nav_filelist_set+0x13e>

           if (0 == u16_nb)
8000e35e:	e0 69 0f 2c 	mov	r9,3884
8000e362:	f3 08 00 24 	ld.sh	r8,r9[36]
           {
              // It is the end of move then update file information
              fat_get_entry_info();
              return true;         // NB FILE FIND
           }
           u16_nb--;
8000e366:	20 18       	sub	r8,1
8000e368:	f3 58 00 24 	st.h	r9[36],r8
            b_find_last_entry = false;
            fs_g_nav.b_mode_nav = FS_DIR;
            continue;
         }
         // Here, a next action is on going
         if ( (FS_FILE == fs_g_nav.b_mode_nav) || fs_g_nav.b_mode_nav_single )
8000e36c:	40 08       	lddsp	r8,sp[0x0]
8000e36e:	58 08       	cp.w	r8,0
8000e370:	c4 70       	breq	8000e3fe <nav_filelist_set+0x152>
8000e372:	20 18       	sub	r8,1
8000e374:	5c 88       	casts.h	r8
8000e376:	50 08       	stdsp	sp[0x0],r8
8000e378:	cd cb       	rjmp	8000e330 <nav_filelist_set+0x84>
8000e37a:	e9 38 00 2c 	ld.ub	r8,r4[44]
8000e37e:	30 19       	mov	r9,1
8000e380:	f2 08 18 00 	cp.b	r8,r9
            // End of next file action then end of next action
            fs_g_status = FS_ERR_NO_FIND; // No file found
            break;                        // end of search
         }else{
            // End of next dir action then starts the next file action at the beginning of directory
            fs_g_nav_fast.u16_entry_pos_sel_file = 0xFFFF;
8000e384:	c4 60       	breq	8000e410 <nav_filelist_set+0x164>
            fs_g_nav.b_mode_nav = FS_FILE;
8000e386:	e0 69 0f 2c 	mov	r9,3884
8000e38a:	f3 38 00 2d 	ld.ub	r8,r9[45]
8000e38e:	e6 08 18 00 	cp.b	r8,r3
           continue;
         }
      }

      // Here error, check type of error
      if(( FS_ERR_ENTRY_EMPTY == fs_g_status )
8000e392:	c3 f1       	brne	8000e410 <nav_filelist_set+0x164>
8000e394:	3f f8       	mov	r8,-1
8000e396:	e0 69 0f 2c 	mov	r9,3884
8000e39a:	ae 18       	st.h	r7[0x2],r8
8000e39c:	30 18       	mov	r8,1
8000e39e:	f3 68 00 2c 	st.b	r9[44],r8
8000e3a2:	cc 7b       	rjmp	8000e330 <nav_filelist_set+0x84>
8000e3a4:	30 aa       	mov	r10,10
8000e3a6:	03 88       	ld.ub	r8,r1[0x0]
8000e3a8:	e4 08 18 00 	cp.b	r8,r2
8000e3ac:	5f 09       	sreq	r9
               break;
            }
            // End of file scan, then find last directory
            b_find_last_entry = true;
         }else{
            fs_g_nav_fast.u16_entry_pos_sel_file--;   // Update entry position
8000e3ae:	f4 08 18 00 	cp.b	r8,r10
8000e3b2:	5f 08       	sreq	r8
      || ( b_find_last_entry ) )
      {
         if ( FS_END_FIND == fs_g_nav_fast.u16_entry_pos_sel_file )
         {
            // Too many files in directory (case impossible)
            fs_g_status = FS_ERR_FS;
8000e3b4:	e0 6a 0f 7c 	mov	r10,3964
8000e3b8:	10 49       	or	r9,r8
         }
      }
   }  // end of loop while(1)

   fs_g_nav.b_mode_nav                    = b_save_entry_type;
   fs_g_nav_fast.u16_entry_pos_sel_file   = u16_ptr_save_entry;
8000e3ba:	e6 09 18 00 	cp.b	r9,r3
8000e3be:	cb 90       	breq	8000e330 <nav_filelist_set+0x84>
   fs_g_nav.u16_pos_sel_file              = u16_save_pos_sel_file;
8000e3c0:	cb 3b       	rjmp	8000e326 <nav_filelist_set+0x7a>
8000e3c2:	20 18       	sub	r8,1
            fs_g_nav.b_mode_nav = FS_FILE;
         }
      }
   }  // end of loop while(1)

   fs_g_nav.b_mode_nav                    = b_save_entry_type;
8000e3c4:	ae 18       	st.h	r7[0x2],r8
   fs_g_nav_fast.u16_entry_pos_sel_file   = u16_ptr_save_entry;
   fs_g_nav.u16_pos_sel_file              = u16_save_pos_sel_file;
8000e3c6:	ca 7b       	rjmp	8000e314 <nav_filelist_set+0x68>
            fs_g_nav.b_mode_nav = FS_FILE;
         }
      }
   }  // end of loop while(1)

   fs_g_nav.b_mode_nav                    = b_save_entry_type;
8000e3c8:	30 89       	mov	r9,8
8000e3ca:	e0 68 0f 7c 	mov	r8,3964
8000e3ce:	b0 89       	st.b	r8[0x0],r9
   fs_g_nav_fast.u16_entry_pos_sel_file   = u16_ptr_save_entry;
   fs_g_nav.u16_pos_sel_file              = u16_save_pos_sel_file;
   return false;
}
8000e3d0:	40 19       	lddsp	r9,sp[0x4]
8000e3d2:	40 28       	lddsp	r8,sp[0x8]
           if( b_find_last_entry )
             continue;  // The search of last directory is on going then continue the search

           // Update position in directory
           if ( FS_FIND_NEXT == b_direction )
              fs_g_nav.u16_pos_sel_file++;
8000e3d4:	ae 19       	st.h	r7[0x2],r9
8000e3d6:	e9 58 00 24 	st.h	r4[36],r8
8000e3da:	40 39       	lddsp	r9,sp[0xc]
8000e3dc:	30 0c       	mov	r12,0
8000e3de:	58 09       	cp.w	r9,0
           else
              fs_g_nav.u16_pos_sel_file--;

           if (0 == u16_nb)
8000e3e0:	5f 18       	srne	r8
8000e3e2:	e9 68 00 2c 	st.b	r4[44],r8
           {
              // It is the end of move then update file information
              fat_get_entry_info();
8000e3e6:	2f cd       	sub	sp,-16
8000e3e8:	d8 32       	popm	r0-r7,pc
8000e3ea:	e0 69 0f 2c 	mov	r9,3884
         {
            // beginning of directory
            if ( (FS_DIR == fs_g_nav.b_mode_nav ) || fs_g_nav.b_mode_nav_single )
            {
               // End of directory scan, then no previous action possible
               fs_g_status = FS_ERR_NO_FIND;
8000e3ee:	f3 08 00 24 	ld.sh	r8,r9[36]
8000e3f2:	2f f8       	sub	r8,-1
               break;
8000e3f4:	f3 58 00 24 	st.h	r9[36],r8
         }
         // Here, a next action is on going
         if ( (FS_FILE == fs_g_nav.b_mode_nav) || fs_g_nav.b_mode_nav_single )
         {
            // End of next file action then end of next action
            fs_g_status = FS_ERR_NO_FIND; // No file found
8000e3f8:	40 08       	lddsp	r8,sp[0x0]
            break;                        // end of search
8000e3fa:	58 08       	cp.w	r8,0
8000e3fc:	cb b1       	brne	8000e372 <nav_filelist_set+0xc6>
8000e3fe:	fe b0 ee 35 	rcall	8000c068 <fat_get_entry_info>
8000e402:	2f cd       	sub	sp,-16
8000e404:	da 3a       	popm	r0-r7,pc,r12=1
8000e406:	30 99       	mov	r9,9
8000e408:	e0 68 0f 7c 	mov	r8,3964
8000e40c:	b0 89       	st.b	r8[0x0],r9
8000e40e:	ce 1b       	rjmp	8000e3d0 <nav_filelist_set+0x124>
8000e410:	30 98       	mov	r8,9
8000e412:	b4 88       	st.b	r10[0x0],r8
8000e414:	cd eb       	rjmp	8000e3d0 <nav_filelist_set+0x124>
8000e416:	d7 03       	nop

8000e418 <nav_filelist_reset>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filelist_reset( void )
{
8000e418:	d4 01       	pushm	lr
   if ( !fat_check_mount_noopen())
8000e41a:	fe b0 f5 79 	rcall	8000cf0c <fat_check_mount_noopen>
8000e41e:	c0 40       	breq	8000e426 <nav_filelist_reset+0xe>
      return false;

   // No file selected and reset navigation
   fat_clear_entry_info_and_ptr();
8000e420:	fe b0 ee 5a 	rcall	8000c0d4 <fat_clear_entry_info_and_ptr>
8000e424:	30 1c       	mov	r12,1
   return true;
}
8000e426:	d8 02       	popm	pc

8000e428 <nav_partition_mount>:
8000e428:	d4 01       	pushm	lr
8000e42a:	fe b0 f2 8b 	rcall	8000c940 <fat_check_noopen>
8000e42e:	c0 a0       	breq	8000e442 <nav_partition_mount+0x1a>
bool  nav_partition_mount( void )
{
   if ( !fat_check_noopen() )
      return false;

   if( FS_TYPE_FAT_UNM != fs_g_nav_fast.u8_type_fat)
8000e430:	e0 68 0f 78 	mov	r8,3960
8000e434:	11 89       	ld.ub	r9,r8[0x0]
8000e436:	30 08       	mov	r8,0
8000e438:	f0 09 18 00 	cp.b	r9,r8
      // No file is selected by default
      fat_clear_entry_info_and_ptr();
      return true;
   }

   return fat_mount();
8000e43c:	c0 41       	brne	8000e444 <nav_partition_mount+0x1c>
8000e43e:	fe b0 fb 5d 	rcall	8000daf8 <fat_mount>

   if( FS_TYPE_FAT_UNM != fs_g_nav_fast.u8_type_fat)
   {
      // Already mounted
      // Go to root directory
      fs_g_nav.u32_cluster_sel_dir   = 0;
8000e442:	d8 02       	popm	pc
8000e444:	30 09       	mov	r9,0
8000e446:	e0 68 0f 2c 	mov	r8,3884
      // No file is selected by default
      fat_clear_entry_info_and_ptr();
8000e44a:	91 89       	st.w	r8[0x20],r9
8000e44c:	fe b0 ee 44 	rcall	8000c0d4 <fat_clear_entry_info_and_ptr>
8000e450:	da 0a       	popm	pc,r12=1
8000e452:	d7 03       	nop

8000e454 <nav_drive_set>:
8000e454:	eb cd 40 80 	pushm	r7,lr
8000e458:	18 97       	mov	r7,r12
8000e45a:	fe b0 f2 73 	rcall	8000c940 <fat_check_noopen>
8000e45e:	c0 31       	brne	8000e464 <nav_drive_set+0x10>
8000e460:	e3 cd 80 80 	ldm	sp++,r7,pc
bool  nav_drive_set( uint8_t u8_number )
{
   if ( !fat_check_noopen() )
      return false;

   if (u8_number >= get_nb_lun() )
8000e464:	e0 a0 03 44 	rcall	8000eaec <get_nb_lun>
8000e468:	ee 0c 18 00 	cp.b	r12,r7
8000e46c:	e0 88 00 10 	brls	8000e48c <nav_drive_set+0x38>
   {
      fs_g_status = FS_ERR_END_OF_DRIVE;   // The drive number is bad
      return false;
   }

   if ( fs_g_nav.u8_lun == u8_number)
8000e470:	e0 68 0f 2c 	mov	r8,3884
8000e474:	11 89       	ld.ub	r9,r8[0x0]
8000e476:	ee 09 18 00 	cp.b	r9,r7
      return true;   // It is the same drive number

   // Go to the device
   fs_g_nav.u8_lun = u8_number;
8000e47a:	c1 00       	breq	8000e49a <nav_drive_set+0x46>
   fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM;
8000e47c:	b0 87       	st.b	r8[0x0],r7
8000e47e:	30 09       	mov	r9,0
8000e480:	e0 68 0f 78 	mov	r8,3960
#if (FS_MULTI_PARTITION  ==  true)
   fs_g_nav.u8_partition=0;   // by default select the first partition
#endif
   return true;
}
8000e484:	30 1c       	mov	r12,1
8000e486:	b0 89       	st.b	r8[0x0],r9
   if ( !fat_check_noopen() )
      return false;

   if (u8_number >= get_nb_lun() )
   {
      fs_g_status = FS_ERR_END_OF_DRIVE;   // The drive number is bad
8000e488:	e3 cd 80 80 	ldm	sp++,r7,pc
8000e48c:	30 69       	mov	r9,6
8000e48e:	e0 68 0f 7c 	mov	r8,3964
      return false;
8000e492:	30 0c       	mov	r12,0
   }

   if ( fs_g_nav.u8_lun == u8_number)
8000e494:	b0 89       	st.b	r8[0x0],r9
8000e496:	e3 cd 80 80 	ldm	sp++,r7,pc
8000e49a:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
8000e49e:	d7 03       	nop

8000e4a0 <nav_drive_nb>:
8000e4a0:	d4 01       	pushm	lr
8000e4a2:	e0 a0 03 25 	rcall	8000eaec <get_nb_lun>
8000e4a6:	d8 02       	popm	pc

8000e4a8 <nav_reset>:
8000e4a8:	eb cd 40 fc 	pushm	r2-r7,lr
void  nav_reset( void )
{
#if ( (FS_ASCII   == true) && (FS_UNICODE == true))
   g_b_unicode = true;
#endif
   g_b_string_length = false;
8000e4ac:	e0 68 0f 7d 	mov	r8,3965
8000e4b0:	30 07       	mov	r7,0
   g_b_no_check_disk = false;
8000e4b2:	b0 87       	st.b	r8[0x0],r7
8000e4b4:	e0 68 0c fe 	mov	r8,3326

   fat_cache_reset();
8000e4b8:	b0 87       	st.b	r8[0x0],r7
   fat_cache_clusterlist_reset();
8000e4ba:	fe b0 f0 55 	rcall	8000c564 <fat_cache_reset>
   {
      fs_g_status = FS_ERR_BAD_NAV;             // The navigator doesn't exist
      return false;
   }
#if (FS_NB_NAVIGATOR > 1)
   if( fs_g_u8_nav_selected != u8_idnav )
8000e4be:	fe b0 ed 01 	rcall	8000bec0 <fat_cache_clusterlist_reset>
8000e4c2:	e0 66 0f f4 	mov	r6,4084
   {
      fat_invert_nav( fs_g_u8_nav_selected );   // Deselect previous navigator = Select default navigator
8000e4c6:	0d 8c       	ld.ub	r12,r6[0x0]
8000e4c8:	58 0c       	cp.w	r12,0
      fat_invert_nav( u8_idnav );               // Select new navigator
8000e4ca:	c0 70       	breq	8000e4d8 <nav_reset+0x30>
8000e4cc:	fe b0 f0 96 	rcall	8000c5f8 <fat_invert_nav>
      fs_g_u8_nav_selected = u8_idnav;
8000e4d0:	30 0c       	mov	r12,0
   uint8_t i;
   // Reset variables of each navigators
   for( i=0 ; i!=FS_NB_NAVIGATOR ; i++ )
   {
      nav_select(i);
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
8000e4d2:	fe b0 f0 93 	rcall	8000c5f8 <fat_invert_nav>
8000e4d6:	ac 87       	st.b	r6[0x0],r7
      fs_g_nav.u8_lun = 0xFF;                      // By default don't select a drive
8000e4d8:	30 07       	mov	r7,0
#if (FS_MULTI_PARTITION  ==  true)
      fs_g_nav.u8_partition=0;                     // By default select the first partition
#endif
      Fat_file_close();                            // By default no file is opened
8000e4da:	e0 65 0f 2c 	mov	r5,3884
      fs_g_nav.b_mode_nav_single = false;          // By default display files and directories
8000e4de:	e0 62 0f 78 	mov	r2,3960
   uint8_t i;
   // Reset variables of each navigators
   for( i=0 ; i!=FS_NB_NAVIGATOR ; i++ )
   {
      nav_select(i);
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
8000e4e2:	3f f3       	mov	r3,-1
      fs_g_nav.u8_lun = 0xFF;                      // By default don't select a drive
8000e4e4:	e0 64 0c ec 	mov	r4,3308
      return false;
   }
#if (FS_NB_NAVIGATOR > 1)
   if( fs_g_u8_nav_selected != u8_idnav )
   {
      fat_invert_nav( fs_g_u8_nav_selected );   // Deselect previous navigator = Select default navigator
8000e4e8:	0d 8c       	ld.ub	r12,r6[0x0]
8000e4ea:	eb 67 00 2d 	st.b	r5[45],r7
      fat_invert_nav( u8_idnav );               // Select new navigator
8000e4ee:	a4 87       	st.b	r2[0x0],r7
8000e4f0:	aa 83       	st.b	r5[0x0],r3
#endif
      Fat_file_close();                            // By default no file is opened
      fs_g_nav.b_mode_nav_single = false;          // By default display files and directories
   }
   // By default select the navigator 0
   fs_g_u8_nav_selected = 0;
8000e4f2:	a8 87       	st.b	r4[0x0],r7
   uint8_t i;
   // Reset variables of each navigators
   for( i=0 ; i!=FS_NB_NAVIGATOR ; i++ )
   {
      nav_select(i);
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
8000e4f4:	fe b0 f0 82 	rcall	8000c5f8 <fat_invert_nav>
      fs_g_nav.u8_lun = 0xFF;                      // By default don't select a drive
#if (FS_MULTI_PARTITION  ==  true)
      fs_g_nav.u8_partition=0;                     // By default select the first partition
#endif
      Fat_file_close();                            // By default no file is opened
8000e4f8:	30 1c       	mov	r12,1
      fs_g_nav.b_mode_nav_single = false;          // By default display files and directories
8000e4fa:	fe b0 f0 7f 	rcall	8000c5f8 <fat_invert_nav>
#  if (FS_MULTI_PARTITION  ==  true)
   fs_g_nav.u8_partition=0;                        // By default select the first partition
#  endif
   Fat_file_close();                               // By default no file is opened
#endif // (FS_NB_NAVIGATOR > 1)
}
8000e4fe:	ac 87       	st.b	r6[0x0],r7
8000e500:	a4 87       	st.b	r2[0x0],r7
8000e502:	aa 83       	st.b	r5[0x0],r3
8000e504:	a8 87       	st.b	r4[0x0],r7
8000e506:	eb 67 00 2d 	st.b	r5[45],r7
8000e50a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000e50e:	d7 03       	nop

8000e510 <nav_filelist_first>:
8000e510:	eb cd 40 c0 	pushm	r6-r7,lr
8000e514:	18 97       	mov	r7,r12
8000e516:	fe b0 f4 fb 	rcall	8000cf0c <fat_check_mount_noopen>
8000e51a:	c0 31       	brne	8000e520 <nav_filelist_first+0x10>
8000e51c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000e520:	fe b0 ed da 	rcall	8000c0d4 <fat_clear_entry_info_and_ptr>
8000e524:	e0 66 0f 2c 	mov	r6,3884
{
   // Reset position
   if ( !nav_filelist_reset())
      return false;
   // Find the first file or directory
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
8000e528:	30 1b       	mov	r11,1
8000e52a:	30 0c       	mov	r12,0
8000e52c:	cc 0e       	rcall	8000e2ac <nav_filelist_set>
8000e52e:	c0 70       	breq	8000e53c <nav_filelist_first+0x2c>
   {
      if( b_type == fs_g_nav.b_mode_nav )
8000e530:	ed 38 00 2c 	ld.ub	r8,r6[44]
8000e534:	10 37       	cp.w	r7,r8
8000e536:	cf 91       	brne	8000e528 <nav_filelist_first+0x18>
8000e538:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
         return true;   // First file or directory found
   }
   fs_g_status = FS_ERR_NO_FIND;
8000e53c:	30 99       	mov	r9,9
8000e53e:	e0 68 0f 7c 	mov	r8,3964
   return false;
}
8000e542:	b0 89       	st.b	r8[0x0],r9
8000e544:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

8000e548 <nav_filelist_single_disable>:
8000e548:	d4 01       	pushm	lr
8000e54a:	30 09       	mov	r9,0
8000e54c:	e0 68 0f 2c 	mov	r8,3884
8000e550:	f1 69 00 2d 	st.b	r8[45],r9
8000e554:	fe b0 f4 dc 	rcall	8000cf0c <fat_check_mount_noopen>
8000e558:	c0 40       	breq	8000e560 <nav_filelist_single_disable+0x18>
8000e55a:	fe b0 ed bd 	rcall	8000c0d4 <fat_clear_entry_info_and_ptr>
//!
bool  nav_filelist_single_disable( void )
{
   fs_g_nav.b_mode_nav_single = false;
   return nav_filelist_reset();
}
8000e55e:	30 1c       	mov	r12,1
8000e560:	d8 02       	popm	pc
8000e562:	d7 03       	nop

8000e564 <nav_filelist_single_enable>:
8000e564:	eb cd 40 80 	pushm	r7,lr
8000e568:	18 97       	mov	r7,r12
8000e56a:	fe b0 f4 d1 	rcall	8000cf0c <fat_check_mount_noopen>
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filelist_reset( void )
{
   if ( !fat_check_mount_noopen())
8000e56e:	c0 b0       	breq	8000e584 <nav_filelist_single_enable+0x20>
      return false;

   // No file selected and reset navigation
   fat_clear_entry_info_and_ptr();
8000e570:	fe b0 ed b2 	rcall	8000c0d4 <fat_clear_entry_info_and_ptr>
bool  nav_filelist_single_enable( bool b_type )
{
   if ( !nav_filelist_reset())
      return false;

   fs_g_nav.b_mode_nav_single = true;
8000e574:	e0 68 0f 2c 	mov	r8,3884
   fs_g_nav.b_mode_nav        = b_type;
8000e578:	30 19       	mov	r9,1
8000e57a:	f1 67 00 2c 	st.b	r8[44],r7
bool  nav_filelist_single_enable( bool b_type )
{
   if ( !nav_filelist_reset())
      return false;

   fs_g_nav.b_mode_nav_single = true;
8000e57e:	f1 69 00 2d 	st.b	r8[45],r9
   fs_g_nav.b_mode_nav        = b_type;
   return true;
}
8000e582:	30 1c       	mov	r12,1
8000e584:	e3 cd 80 80 	ldm	sp++,r7,pc

8000e588 <nav_dir_root>:
8000e588:	d4 01       	pushm	lr
8000e58a:	fe b0 f1 db 	rcall	8000c940 <fat_check_noopen>
8000e58e:	c0 a0       	breq	8000e5a2 <nav_dir_root+0x1a>
8000e590:	e0 68 0f 78 	mov	r8,3960
bool  nav_partition_mount( void )
{
   if ( !fat_check_noopen() )
      return false;

   if( FS_TYPE_FAT_UNM != fs_g_nav_fast.u8_type_fat)
8000e594:	11 89       	ld.ub	r9,r8[0x0]
8000e596:	30 08       	mov	r8,0
8000e598:	f0 09 18 00 	cp.b	r9,r8
      // No file is selected by default
      fat_clear_entry_info_and_ptr();
      return true;
   }

   return fat_mount();
8000e59c:	c0 41       	brne	8000e5a4 <nav_dir_root+0x1c>
8000e59e:	fe b0 fa ad 	rcall	8000daf8 <fat_mount>

   if( FS_TYPE_FAT_UNM != fs_g_nav_fast.u8_type_fat)
   {
      // Already mounted
      // Go to root directory
      fs_g_nav.u32_cluster_sel_dir   = 0;
8000e5a2:	d8 02       	popm	pc
8000e5a4:	30 09       	mov	r9,0
8000e5a6:	e0 68 0f 2c 	mov	r8,3884
      // No file is selected by default
      fat_clear_entry_info_and_ptr();
8000e5aa:	91 89       	st.w	r8[0x20],r9
8000e5ac:	fe b0 ed 94 	rcall	8000c0d4 <fat_clear_entry_info_and_ptr>
8000e5b0:	da 0a       	popm	pc,r12=1
8000e5b2:	d7 03       	nop

8000e5b4 <nav_filelist_nb>:
8000e5b4:	eb cd 40 fc 	pushm	r2-r7,lr
8000e5b8:	e0 66 0f 2c 	mov	r6,3884
8000e5bc:	18 92       	mov	r2,r12
8000e5be:	ed 03 00 24 	ld.sh	r3,r6[36]
8000e5c2:	fe b0 f4 a5 	rcall	8000cf0c <fat_check_mount_noopen>
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filelist_reset( void )
{
   if ( !fat_check_mount_noopen())
8000e5c6:	c0 51       	brne	8000e5d0 <nav_filelist_nb+0x1c>
   // Return the value asked
   if( FS_FILE == b_type )
      return u16_save_number_file;
   else
      return u16_save_number_dir;
}
8000e5c8:	18 94       	mov	r4,r12
8000e5ca:	08 9c       	mov	r12,r4
8000e5cc:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
{
   if ( !fat_check_mount_noopen())
      return false;

   // No file selected and reset navigation
   fat_clear_entry_info_and_ptr();
8000e5d0:	30 04       	mov	r4,0
8000e5d2:	fe b0 ed 81 	rcall	8000c0d4 <fat_clear_entry_info_and_ptr>
8000e5d6:	30 15       	mov	r5,1
   if ( !nav_filelist_reset())
      return 0;
   // Scan all directory
   u16_save_number_dir  = 0;
   u16_save_number_file = 0;
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
8000e5d8:	08 97       	mov	r7,r4
8000e5da:	30 1b       	mov	r11,1
8000e5dc:	30 0c       	mov	r12,0
8000e5de:	c6 7e       	rcall	8000e2ac <nav_filelist_set>
8000e5e0:	c0 e0       	breq	8000e5fc <nav_filelist_nb+0x48>
   {
      if( FS_FILE == fs_g_nav.b_mode_nav )
         u16_save_number_file++;    // It is a file
      else
         u16_save_number_dir++;     // It is a directory
8000e5e2:	0e 99       	mov	r9,r7
   // Scan all directory
   u16_save_number_dir  = 0;
   u16_save_number_file = 0;
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
   {
      if( FS_FILE == fs_g_nav.b_mode_nav )
8000e5e4:	ed 38 00 2c 	ld.ub	r8,r6[44]
         u16_save_number_file++;    // It is a file
      else
         u16_save_number_dir++;     // It is a directory
8000e5e8:	2f f9       	sub	r9,-1
   // Scan all directory
   u16_save_number_dir  = 0;
   u16_save_number_file = 0;
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
   {
      if( FS_FILE == fs_g_nav.b_mode_nav )
8000e5ea:	ea 08 18 00 	cp.b	r8,r5
8000e5ee:	c0 40       	breq	8000e5f6 <nav_filelist_nb+0x42>
         u16_save_number_file++;    // It is a file
      else
         u16_save_number_dir++;     // It is a directory
8000e5f0:	ef d9 b0 10 	bfexts	r7,r9,0x0,0x10
8000e5f4:	cf 3b       	rjmp	8000e5da <nav_filelist_nb+0x26>
   u16_save_number_dir  = 0;
   u16_save_number_file = 0;
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
   {
      if( FS_FILE == fs_g_nav.b_mode_nav )
         u16_save_number_file++;    // It is a file
8000e5f6:	2f f4       	sub	r4,-1
8000e5f8:	5c 84       	casts.h	r4
8000e5fa:	cf 0b       	rjmp	8000e5da <nav_filelist_nb+0x26>
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filelist_reset( void )
{
   if ( !fat_check_mount_noopen())
8000e5fc:	fe b0 f4 88 	rcall	8000cf0c <fat_check_mount_noopen>
8000e600:	c0 30       	breq	8000e606 <nav_filelist_nb+0x52>
      return false;

   // No file selected and reset navigation
   fat_clear_entry_info_and_ptr();
8000e602:	fe b0 ed 69 	rcall	8000c0d4 <fat_clear_entry_info_and_ptr>
      else
         u16_save_number_dir++;     // It is a directory
   }
   // Restore previous position
   nav_filelist_reset();
   if ( u16_save_position != FS_NO_SEL )
8000e606:	3f f8       	mov	r8,-1
8000e608:	f0 03 19 00 	cp.h	r3,r8
8000e60c:	c0 50       	breq	8000e616 <nav_filelist_nb+0x62>
   {
      nav_filelist_set( u16_save_position , FS_FIND_NEXT );
8000e60e:	f9 d3 c0 10 	bfextu	r12,r3,0x0,0x10
8000e612:	30 1b       	mov	r11,1
8000e614:	c4 ce       	rcall	8000e2ac <nav_filelist_set>
8000e616:	58 02       	cp.w	r2,0
   }
   // Return the value asked
   if( FS_FILE == b_type )
8000e618:	cd 91       	brne	8000e5ca <nav_filelist_nb+0x16>
8000e61a:	0e 94       	mov	r4,r7
8000e61c:	5c 84       	casts.h	r4
8000e61e:	08 9c       	mov	r12,r4
      return u16_save_number_file;
   else
      return u16_save_number_dir;
}
8000e620:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc

8000e624 <nav_filelist_goto>:
8000e624:	eb cd 40 80 	pushm	r7,lr
8000e628:	3f f9       	mov	r9,-1
8000e62a:	18 97       	mov	r7,r12
8000e62c:	f2 0c 19 00 	cp.h	r12,r9
8000e630:	c3 20       	breq	8000e694 <nav_filelist_goto+0x70>
8000e632:	e0 68 0f 2c 	mov	r8,3884
8000e636:	f1 08 00 24 	ld.sh	r8,r8[36]

   if( FS_NO_SEL == u16_newpos )
      return nav_filelist_reset();

   u16_current_pos = nav_filelist_get();
   if( u16_newpos < (u16_current_pos/2) )
8000e63a:	f5 d8 c0 2f 	bfextu	r10,r8,0x1,0xf
8000e63e:	f4 0c 19 00 	cp.h	r12,r10
      // Restart at the beginning of list to accelerate the search
      if( !nav_filelist_reset() )
         return false;
      u16_current_pos = FS_NO_SEL;
   }
   if (FS_NO_SEL == u16_current_pos)
8000e642:	c1 53       	brcs	8000e66c <nav_filelist_goto+0x48>
8000e644:	f2 08 19 00 	cp.h	r8,r9
   {
      return nav_filelist_set( u16_newpos, FS_FIND_NEXT );
   }
   else
   {
      if (u16_newpos < u16_current_pos)
8000e648:	c1 70       	breq	8000e676 <nav_filelist_goto+0x52>
8000e64a:	f0 0c 19 00 	cp.h	r12,r8
      {
         return nav_filelist_set( u16_current_pos -u16_newpos -1 , FS_FIND_PREV );
      }
      if (u16_newpos > u16_current_pos)
8000e64e:	c1 a3       	brcs	8000e682 <nav_filelist_goto+0x5e>
8000e650:	e0 8b 00 04 	brhi	8000e658 <nav_filelist_goto+0x34>
8000e654:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
      {
         return nav_filelist_set( u16_newpos -u16_current_pos - 1 , FS_FIND_NEXT );
8000e658:	f0 08 11 ff 	rsub	r8,r8,-1
8000e65c:	30 1b       	mov	r11,1
8000e65e:	f0 0c 00 07 	add	r7,r8,r12
8000e662:	f9 d7 c0 10 	bfextu	r12,r7,0x0,0x10
8000e666:	c2 3e       	rcall	8000e2ac <nav_filelist_set>
      }
   }
   return true;
}
8000e668:	e3 cd 80 80 	ldm	sp++,r7,pc
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filelist_reset( void )
{
   if ( !fat_check_mount_noopen())
8000e66c:	fe b0 f4 50 	rcall	8000cf0c <fat_check_mount_noopen>
8000e670:	cf c0       	breq	8000e668 <nav_filelist_goto+0x44>
      return false;

   // No file selected and reset navigation
   fat_clear_entry_info_and_ptr();
8000e672:	fe b0 ed 31 	rcall	8000c0d4 <fat_clear_entry_info_and_ptr>
         return false;
      u16_current_pos = FS_NO_SEL;
   }
   if (FS_NO_SEL == u16_current_pos)
   {
      return nav_filelist_set( u16_newpos, FS_FIND_NEXT );
8000e676:	0e 9c       	mov	r12,r7
8000e678:	30 1b       	mov	r11,1
8000e67a:	5c 7c       	castu.h	r12
8000e67c:	c1 8e       	rcall	8000e2ac <nav_filelist_set>
8000e67e:	e3 cd 80 80 	ldm	sp++,r7,pc
8000e682:	20 18       	sub	r8,1
   }
   else
   {
      if (u16_newpos < u16_current_pos)
      {
         return nav_filelist_set( u16_current_pos -u16_newpos -1 , FS_FIND_PREV );
8000e684:	30 0b       	mov	r11,0
8000e686:	f0 0c 01 07 	sub	r7,r8,r12
8000e68a:	f9 d7 c0 10 	bfextu	r12,r7,0x0,0x10
8000e68e:	c0 fe       	rcall	8000e2ac <nav_filelist_set>
8000e690:	e3 cd 80 80 	ldm	sp++,r7,pc
8000e694:	cc 2e       	rcall	8000e418 <nav_filelist_reset>
8000e696:	e3 cd 80 80 	ldm	sp++,r7,pc
bool  nav_filelist_goto( uint16_t u16_newpos )
{
   uint16_t u16_current_pos;

   if( FS_NO_SEL == u16_newpos )
      return nav_filelist_reset();
8000e69a:	d7 03       	nop

8000e69c <nav_file_getname>:
8000e69c:	d4 31       	pushm	r0-r7,lr
8000e69e:	18 95       	mov	r5,r12
8000e6a0:	16 97       	mov	r7,r11
8000e6a2:	fe b0 f3 37 	rcall	8000cd10 <fat_check_mount_select>
8000e6a6:	c2 60       	breq	8000e6f2 <nav_file_getname+0x56>
8000e6a8:	58 07       	cp.w	r7,0
8000e6aa:	c3 10       	breq	8000e70c <nav_file_getname+0x70>
8000e6ac:	e0 64 0f 78 	mov	r4,3960
8000e6b0:	88 13       	ld.sh	r3,r4[0x2]
8000e6b2:	58 03       	cp.w	r3,0
   }

   // Save the current entry position
   u16_ptr_save_entry = fs_g_nav_fast.u16_entry_pos_sel_file;
   // if it is the beginning of the directory
   if ( 0 == fs_g_nav_fast.u16_entry_pos_sel_file )
8000e6b4:	c2 d1       	brne	8000e70e <nav_file_getname+0x72>
   {
      b_readshortname = true;                   // It isn't possible to have a long name
   }
   else
   {
      fs_g_nav_fast.u16_entry_pos_sel_file--;   // Initialize entry position to search the first long name entry
8000e6b6:	30 16       	mov	r6,1
         }
         fs_g_nav_fast.u16_entry_pos_sel_file = u16_ptr_save_entry;
         return true;
      }

      if ( FS_NO_LAST_LFN_ENTRY != fs_g_status )
8000e6b8:	30 01       	mov	r1,0
8000e6ba:	e0 60 0f 7c 	mov	r0,3964

   // Loop in directory entry
   u16_lgt = 0;
   while( 1 )
   {
      if ( !fat_read_dir())
8000e6be:	31 02       	mov	r2,16
8000e6c0:	fe b0 f7 ec 	rcall	8000d698 <fat_read_dir>
         break; // error

      if ( b_readshortname )
8000e6c4:	c1 70       	breq	8000e6f2 <nav_file_getname+0x56>
         // No long name present then read short name
         return fat_entry_shortname( sz_name , u8_size_max , b_mode  );
      }

      // Check or read the part of long file name in this entry
      if ( fat_entry_longname( sz_name , u8_size_max , b_mode , b_match_case  ))
8000e6c6:	58 06       	cp.w	r6,0
8000e6c8:	c3 91       	brne	8000e73a <nav_file_getname+0x9e>
8000e6ca:	0c 99       	mov	r9,r6
8000e6cc:	30 1a       	mov	r10,1
8000e6ce:	0e 9b       	mov	r11,r7
8000e6d0:	0a 9c       	mov	r12,r5
8000e6d2:	fe b0 ed f7 	rcall	8000c2c0 <fat_entry_longname>
         }
         fs_g_nav_fast.u16_entry_pos_sel_file = u16_ptr_save_entry;
         return true;
      }

      if ( FS_NO_LAST_LFN_ENTRY != fs_g_status )
8000e6d6:	c0 f1       	brne	8000e6f4 <nav_file_getname+0x58>
8000e6d8:	01 88       	ld.ub	r8,r0[0x0]
8000e6da:	e4 08 18 00 	cp.b	r8,r2
      {
         // Go to the main entry file (=short name entry)
         fs_g_nav_fast.u16_entry_pos_sel_file = u16_ptr_save_entry;

         if ( FS_ERR_ENTRY_BAD == fs_g_status )
8000e6de:	c1 d0       	breq	8000e718 <nav_file_getname+0x7c>
8000e6e0:	a8 13       	st.h	r4[0x2],r3
8000e6e2:	30 b9       	mov	r9,11
8000e6e4:	f2 08 18 00 	cp.b	r8,r9

   // Loop in directory entry
   u16_lgt = 0;
   while( 1 )
   {
      if ( !fat_read_dir())
8000e6e8:	c0 51       	brne	8000e6f2 <nav_file_getname+0x56>
8000e6ea:	30 16       	mov	r6,1
8000e6ec:	fe b0 f7 d6 	rcall	8000d698 <fat_read_dir>
      }

      // Check or read the part of long file name in this entry
      if ( fat_entry_longname( sz_name , u8_size_max , b_mode , b_match_case  ))
      {
         if( g_b_string_length )
8000e6f0:	ce b1       	brne	8000e6c6 <nav_file_getname+0x2a>
8000e6f2:	d8 3a       	popm	r0-r7,pc,r12=0
         {
            ((FS_STR_UNICODE)sz_name )[0] += u16_lgt;
8000e6f4:	e0 68 0f 7d 	mov	r8,3965
8000e6f8:	11 88       	ld.ub	r8,r8[0x0]
8000e6fa:	ec 08 18 00 	cp.b	r8,r6
8000e6fe:	eb f8 12 00 	ld.shne	r8,r5[0x0]
8000e702:	f1 d1 e1 01 	addne	r1,r8,r1
         }
         fs_g_nav_fast.u16_entry_pos_sel_file = u16_ptr_save_entry;
8000e706:	eb f1 1c 00 	st.hne	r5[0x0],r1
   {
      b_readshortname = true;                   // It isn't possible to have a long name
   }
   else
   {
      fs_g_nav_fast.u16_entry_pos_sel_file--;   // Initialize entry position to search the first long name entry
8000e70a:	a8 13       	st.h	r4[0x2],r3
8000e70c:	da 3a       	popm	r0-r7,pc,r12=1
8000e70e:	e6 c8 00 01 	sub	r8,r3,1
            continue;                 // restart the loop
         }
         // here, it is a error system or the string don't match with the file name
         break;
      }
      if( g_b_string_length )
8000e712:	30 06       	mov	r6,0
8000e714:	a8 18       	st.h	r4[0x2],r8
8000e716:	cd 1b       	rjmp	8000e6b8 <nav_file_getname+0x1c>
8000e718:	e0 69 0f 7d 	mov	r9,3965
8000e71c:	13 88       	ld.ub	r8,r9[0x0]
      {
         u16_lgt += FS_SIZE_LFN_ENTRY;
8000e71e:	30 09       	mov	r9,0
8000e720:	f2 08 18 00 	cp.b	r8,r9
      {
         // Increment the string to store the next part of file name
         sz_name += FS_SIZE_LFN_ENTRY * (Is_unicode? 2 : 1 );
         u8_size_max -= FS_SIZE_LFN_ENTRY;
      }
      fs_g_nav_fast.u16_entry_pos_sel_file--;   // Go to the next part of long file name
8000e724:	c0 70       	breq	8000e732 <nav_file_getname+0x96>
8000e726:	2f 31       	sub	r1,-13
8000e728:	5c 81       	casts.h	r1
      }
      else
      {
         // Increment the string to store the next part of file name
         sz_name += FS_SIZE_LFN_ENTRY * (Is_unicode? 2 : 1 );
         u8_size_max -= FS_SIZE_LFN_ENTRY;
8000e72a:	88 18       	ld.sh	r8,r4[0x2]
         u16_lgt += FS_SIZE_LFN_ENTRY;
      }
      else
      {
         // Increment the string to store the next part of file name
         sz_name += FS_SIZE_LFN_ENTRY * (Is_unicode? 2 : 1 );
8000e72c:	20 18       	sub	r8,1
         u8_size_max -= FS_SIZE_LFN_ENTRY;
8000e72e:	a8 18       	st.h	r4[0x2],r8
8000e730:	cc 8b       	rjmp	8000e6c0 <nav_file_getname+0x24>
         break; // error

      if ( b_readshortname )
      {
         // No long name present then read short name
         return fat_entry_shortname( sz_name , u8_size_max , b_mode  );
8000e732:	20 d7       	sub	r7,13
8000e734:	2f 35       	sub	r5,-13
8000e736:	5c 57       	castu.b	r7
8000e738:	cf 9b       	rjmp	8000e72a <nav_file_getname+0x8e>
8000e73a:	0e 9b       	mov	r11,r7
8000e73c:	0a 9c       	mov	r12,r5
8000e73e:	30 1a       	mov	r10,1
8000e740:	fe b0 ed 0c 	rcall	8000c158 <fat_entry_shortname>
8000e744:	d8 32       	popm	r0-r7,pc
8000e746:	d7 03       	nop

8000e748 <nav_filterlist_root>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filterlist_root( void )
{
8000e748:	d4 01       	pushm	lr
   fs_g_nav.u16_pos_filterlist = FS_NO_SEL;
8000e74a:	3f f9       	mov	r9,-1
8000e74c:	e0 68 0f 2c 	mov	r8,3884
8000e750:	f1 59 00 26 	st.h	r8[38],r9
   return nav_dir_root();
8000e754:	c1 af       	rcall	8000e588 <nav_dir_root>
}
8000e756:	d8 02       	popm	pc

8000e758 <nav_filterlist_reset>:
8000e758:	d4 01       	pushm	lr
8000e75a:	3f f9       	mov	r9,-1
8000e75c:	e0 68 0f 2c 	mov	r8,3884
//! @return  false in case of an error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filterlist_reset( void )
{
   fs_g_nav.u16_pos_filterlist = FS_NO_SEL;
8000e760:	f1 59 00 26 	st.h	r8[38],r9
   return nav_filelist_reset();
8000e764:	c5 ae       	rcall	8000e418 <nav_filelist_reset>
}
8000e766:	d8 02       	popm	pc

8000e768 <nav_filterlist_setfilter>:
8000e768:	d4 01       	pushm	lr
8000e76a:	e0 68 0f 2c 	mov	r8,3884
8000e76e:	3f f9       	mov	r9,-1
//! @return  false in case of an error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filterlist_reset( void )
{
   fs_g_nav.u16_pos_filterlist = FS_NO_SEL;
8000e770:	91 ac       	st.w	r8[0x28],r12
8000e772:	f1 59 00 26 	st.h	r8[38],r9
   return nav_filelist_reset();
8000e776:	c5 1e       	rcall	8000e418 <nav_filelist_reset>
//!
void  nav_filterlist_setfilter( const FS_STRING sz_filterext  )
{
   fs_g_nav.sz_filterext = sz_filterext;
   nav_filterlist_reset();
}
8000e778:	d8 02       	popm	pc
8000e77a:	d7 03       	nop

8000e77c <nav_filterlist_goto>:
8000e77c:	eb cd 40 f8 	pushm	r3-r7,lr
8000e780:	3f f9       	mov	r9,-1
8000e782:	18 96       	mov	r6,r12
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_filterlist_goto( uint16_t u16_newpos )
{
   if (u16_newpos == FS_NO_SEL)
8000e784:	f2 0c 19 00 	cp.h	r12,r9
8000e788:	e0 80 00 8e 	breq	8000e8a4 <nav_filterlist_goto+0x128>
     return nav_filterlist_reset();

   if( u16_newpos < (fs_g_nav.u16_pos_filterlist/2) )
8000e78c:	e0 67 0f 2c 	mov	r7,3884
8000e790:	ef 08 00 26 	ld.sh	r8,r7[38]
8000e794:	f5 d8 c0 2f 	bfextu	r10,r8,0x1,0xf
8000e798:	f4 0c 19 00 	cp.h	r12,r10
   {
      // Restart at the beginning of list to accelerate search
      if( !nav_filterlist_reset() )
         return false;
   }
   if( FS_NO_SEL == fs_g_nav.u16_pos_filterlist )
8000e79c:	c5 83       	brcs	8000e84c <nav_filterlist_goto+0xd0>
8000e79e:	3f f9       	mov	r9,-1
8000e7a0:	f2 08 19 00 	cp.h	r8,r9
   while( nav_filelist_set( 0, FS_FIND_NEXT ) )
   {
      if( nav_file_isdir()
      ||  nav_file_checkext( fs_g_nav.sz_filterext ) )
      {
         if( FS_NO_SEL == u16_current_pos )
8000e7a4:	c5 f0       	breq	8000e862 <nav_filterlist_goto+0xe6>
         {
            fs_g_nav.u16_pos_filterlist = 0;
8000e7a6:	3f f4       	mov	r4,-1
         return false;
   }
   if( FS_NO_SEL == fs_g_nav.u16_pos_filterlist )
      if( !nav_filterlist_next() )
         return false;  // No file available
   while( u16_newpos > fs_g_nav.u16_pos_filterlist )
8000e7a8:	30 03       	mov	r3,0
8000e7aa:	f0 06 19 00 	cp.h	r6,r8
8000e7ae:	e0 88 00 22 	brls	8000e7f2 <nav_filterlist_goto+0x76>
//! @return    true otherwise
//!
bool  nav_filterlist_next( void )
{
   uint16_t u16_current_pos;
   u16_current_pos = nav_filelist_get();
8000e7b2:	fe b0 fd 5f 	rcall	8000e270 <nav_filelist_get>
8000e7b6:	eb dc b0 10 	bfexts	r5,r12,0x0,0x10
   while( nav_filelist_set( 0, FS_FIND_NEXT ) )
8000e7ba:	30 1b       	mov	r11,1
8000e7bc:	30 0c       	mov	r12,0
8000e7be:	fe b0 fd 77 	rcall	8000e2ac <nav_filelist_set>
   {
      if( nav_file_isdir()
8000e7c2:	c3 f0       	breq	8000e840 <nav_filterlist_goto+0xc4>
8000e7c4:	fe b0 fd 70 	rcall	8000e2a4 <nav_file_isdir>
8000e7c8:	c0 51       	brne	8000e7d2 <nav_filterlist_goto+0x56>
8000e7ca:	6e ac       	ld.w	r12,r7[0x28]
8000e7cc:	fe b0 fd 5c 	rcall	8000e284 <nav_file_checkext>
      ||  nav_file_checkext( fs_g_nav.sz_filterext ) )
      {
         if( FS_NO_SEL == u16_current_pos )
         {
            fs_g_nav.u16_pos_filterlist = 0;
8000e7d0:	cf 50       	breq	8000e7ba <nav_filterlist_goto+0x3e>
8000e7d2:	e8 05 19 00 	cp.h	r5,r4
8000e7d6:	ef f3 0c 13 	st.heq	r7[0x26],r3
         }else{
            fs_g_nav.u16_pos_filterlist++;
8000e7da:	ef f8 12 13 	ld.shne	r8,r7[0x26]
8000e7de:	f7 b8 01 ff 	subne	r8,-1
8000e7e2:	ef f8 1c 13 	st.hne	r7[0x26],r8
         }
         return true;
      }
   }
   nav_filelist_goto( u16_current_pos );
8000e7e6:	ef 08 00 26 	ld.sh	r8,r7[38]
         return false;
   }
   if( FS_NO_SEL == fs_g_nav.u16_pos_filterlist )
      if( !nav_filterlist_next() )
         return false;  // No file available
   while( u16_newpos > fs_g_nav.u16_pos_filterlist )
8000e7ea:	f0 06 19 00 	cp.h	r6,r8
8000e7ee:	fe 9b ff e2 	brhi	8000e7b2 <nav_filterlist_goto+0x36>
   {
      if( !nav_filterlist_next() )
         break;
   }
   while( u16_newpos < fs_g_nav.u16_pos_filterlist )
8000e7f2:	f0 06 19 00 	cp.h	r6,r8
//! @return    true otherwise
//!
bool  nav_filterlist_previous( void )
{
   uint16_t u16_current_pos;
   u16_current_pos = nav_filelist_get();
8000e7f6:	c1 a2       	brcc	8000e82a <nav_filterlist_goto+0xae>
8000e7f8:	fe b0 fd 3c 	rcall	8000e270 <nav_filelist_get>
8000e7fc:	eb dc b0 10 	bfexts	r5,r12,0x0,0x10
   while( nav_filelist_set( 0, FS_FIND_PREV ) )
8000e800:	30 0b       	mov	r11,0
8000e802:	16 9c       	mov	r12,r11
8000e804:	fe b0 fd 54 	rcall	8000e2ac <nav_filelist_set>
   {
      if( nav_file_isdir()
8000e808:	c1 60       	breq	8000e834 <nav_filterlist_goto+0xb8>
8000e80a:	fe b0 fd 4d 	rcall	8000e2a4 <nav_file_isdir>
8000e80e:	c0 51       	brne	8000e818 <nav_filterlist_goto+0x9c>
8000e810:	6e ac       	ld.w	r12,r7[0x28]
8000e812:	fe b0 fd 39 	rcall	8000e284 <nav_file_checkext>
      ||  nav_file_checkext( fs_g_nav.sz_filterext ) )
      {
         fs_g_nav.u16_pos_filterlist--;
8000e816:	cf 50       	breq	8000e800 <nav_filterlist_goto+0x84>
8000e818:	ef 08 00 26 	ld.sh	r8,r7[38]
8000e81c:	20 18       	sub	r8,1
8000e81e:	5c 88       	casts.h	r8
8000e820:	ef 58 00 26 	st.h	r7[38],r8
   while( u16_newpos > fs_g_nav.u16_pos_filterlist )
   {
      if( !nav_filterlist_next() )
         break;
   }
   while( u16_newpos < fs_g_nav.u16_pos_filterlist )
8000e824:	f0 06 19 00 	cp.h	r6,r8
   {
      if( !nav_filterlist_previous() )
         break;
   }
   return (u16_newpos == fs_g_nav.u16_pos_filterlist);
8000e828:	ce 83       	brcs	8000e7f8 <nav_filterlist_goto+0x7c>
8000e82a:	f0 06 19 00 	cp.h	r6,r8
}
8000e82e:	5f 0c       	sreq	r12
8000e830:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
      {
         fs_g_nav.u16_pos_filterlist--;
         return true;
      }
   }
   nav_filelist_goto( u16_current_pos );
8000e834:	f9 d5 c0 10 	bfextu	r12,r5,0x0,0x10
8000e838:	cf 6e       	rcall	8000e624 <nav_filelist_goto>
8000e83a:	ef 08 00 26 	ld.sh	r8,r7[38]
8000e83e:	cf 6b       	rjmp	8000e82a <nav_filterlist_goto+0xae>
            fs_g_nav.u16_pos_filterlist++;
         }
         return true;
      }
   }
   nav_filelist_goto( u16_current_pos );
8000e840:	f9 d5 c0 10 	bfextu	r12,r5,0x0,0x10
8000e844:	cf 0e       	rcall	8000e624 <nav_filelist_goto>
8000e846:	ef 08 00 26 	ld.sh	r8,r7[38]
8000e84a:	cd 4b       	rjmp	8000e7f2 <nav_filterlist_goto+0x76>
8000e84c:	ef 59 00 26 	st.h	r7[38],r9
//! @return  false in case of an error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filterlist_reset( void )
{
   fs_g_nav.u16_pos_filterlist = FS_NO_SEL;
8000e850:	fe b0 fd e4 	rcall	8000e418 <nav_filelist_reset>
   return nav_filelist_reset();
8000e854:	ce e0       	breq	8000e830 <nav_filterlist_goto+0xb4>
     return nav_filterlist_reset();

   if( u16_newpos < (fs_g_nav.u16_pos_filterlist/2) )
   {
      // Restart at the beginning of list to accelerate search
      if( !nav_filterlist_reset() )
8000e856:	ef 08 00 26 	ld.sh	r8,r7[38]
8000e85a:	3f f9       	mov	r9,-1
         return false;
   }
   if( FS_NO_SEL == fs_g_nav.u16_pos_filterlist )
8000e85c:	f2 08 19 00 	cp.h	r8,r9
8000e860:	ca 31       	brne	8000e7a6 <nav_filterlist_goto+0x2a>
8000e862:	fe b0 fd 07 	rcall	8000e270 <nav_filelist_get>
//! @return    true otherwise
//!
bool  nav_filterlist_next( void )
{
   uint16_t u16_current_pos;
   u16_current_pos = nav_filelist_get();
8000e866:	eb dc b0 10 	bfexts	r5,r12,0x0,0x10
8000e86a:	30 1b       	mov	r11,1
   while( nav_filelist_set( 0, FS_FIND_NEXT ) )
8000e86c:	30 0c       	mov	r12,0
8000e86e:	fe b0 fd 1f 	rcall	8000e2ac <nav_filelist_set>
8000e872:	18 94       	mov	r4,r12
8000e874:	c1 b0       	breq	8000e8aa <nav_filterlist_goto+0x12e>
8000e876:	fe b0 fd 17 	rcall	8000e2a4 <nav_file_isdir>
   {
      if( nav_file_isdir()
8000e87a:	c0 51       	brne	8000e884 <nav_filterlist_goto+0x108>
8000e87c:	6e ac       	ld.w	r12,r7[0x28]
8000e87e:	fe b0 fd 03 	rcall	8000e284 <nav_file_checkext>
8000e882:	cf 40       	breq	8000e86a <nav_filterlist_goto+0xee>
8000e884:	3f f8       	mov	r8,-1
      ||  nav_file_checkext( fs_g_nav.sz_filterext ) )
      {
         if( FS_NO_SEL == u16_current_pos )
8000e886:	f0 05 19 00 	cp.h	r5,r8
         {
            fs_g_nav.u16_pos_filterlist = 0;
8000e88a:	f9 b8 00 00 	moveq	r8,0
8000e88e:	ef f8 0c 13 	st.heq	r7[0x26],r8
8000e892:	ef f8 12 13 	ld.shne	r8,r7[0x26]
         }else{
            fs_g_nav.u16_pos_filterlist++;
8000e896:	f7 b8 01 ff 	subne	r8,-1
8000e89a:	ef f8 1c 13 	st.hne	r7[0x26],r8
8000e89e:	ef 08 00 26 	ld.sh	r8,r7[38]
         }
         return true;
      }
   }
   nav_filelist_goto( u16_current_pos );
8000e8a2:	c8 2b       	rjmp	8000e7a6 <nav_filterlist_goto+0x2a>
8000e8a4:	c5 af       	rcall	8000e758 <nav_filterlist_reset>
//! @return    true otherwise
//!
bool  nav_filterlist_goto( uint16_t u16_newpos )
{
   if (u16_newpos == FS_NO_SEL)
     return nav_filterlist_reset();
8000e8a6:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000e8aa:	f9 d5 c0 10 	bfextu	r12,r5,0x0,0x10
            fs_g_nav.u16_pos_filterlist++;
         }
         return true;
      }
   }
   nav_filelist_goto( u16_current_pos );
8000e8ae:	cb be       	rcall	8000e624 <nav_filelist_goto>
8000e8b0:	08 9c       	mov	r12,r4
8000e8b2:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000e8b6:	d7 03       	nop

8000e8b8 <nav_filterlist_nb>:
8000e8b8:	eb cd 40 fc 	pushm	r2-r7,lr
8000e8bc:	16 96       	mov	r6,r11
8000e8be:	58 0c       	cp.w	r12,0
8000e8c0:	c2 c1       	brne	8000e918 <nav_filterlist_nb+0x60>
8000e8c2:	58 0b       	cp.w	r11,0
8000e8c4:	e0 80 00 7c 	breq	8000e9bc <nav_filterlist_nb+0x104>
8000e8c8:	3f f7       	mov	r7,-1
8000e8ca:	e0 65 0a 7c 	mov	r5,2684
8000e8ce:	0e 94       	mov	r4,r7
8000e8d0:	e0 63 0f 2c 	mov	r3,3884
8000e8d4:	e8 07 19 00 	cp.h	r7,r4
8000e8d8:	c1 70       	breq	8000e906 <nav_filterlist_nb+0x4e>
8000e8da:	30 1b       	mov	r11,1

      *p_total = 0;
   }

   // Scan all
   while( nav_filelist_set( 0, FS_FIND_NEXT ) )
8000e8dc:	30 0c       	mov	r12,0
   {
      b_is_dir = nav_file_isdir();
8000e8de:	fe b0 fc e7 	rcall	8000e2ac <nav_filelist_set>
8000e8e2:	c4 60       	breq	8000e96e <nav_filterlist_nb+0xb6>

      // Check if its a file for FL_FILE mode
      if (fl_type == FL_FILE && b_is_dir)
8000e8e4:	fe b0 fc e0 	rcall	8000e2a4 <nav_file_isdir>
      }
      // If the selection is on a file
      if (!b_is_dir)
      {
        // Check the extension of the file
        if (!((sz_filterext)?nav_file_checkext(sz_filterext):nav_file_checkext(fs_g_nav.sz_filterext)))
8000e8e8:	18 92       	mov	r2,r12
8000e8ea:	cf 51       	brne	8000e8d4 <nav_filterlist_nb+0x1c>
8000e8ec:	0c 9c       	mov	r12,r6
8000e8ee:	fe b0 fc cb 	rcall	8000e284 <nav_file_checkext>
8000e8f2:	ec 1c 00 01 	eorl	r12,0x1
          if (!update_counter(&retry))
            return false;
      }

      (*p_total)++;
8000e8f6:	e4 0c 18 00 	cp.b	r12,r2
{
   static uint16_t   u16_save_position;
   bool   b_is_dir;

   // save current position
   if( *p_total==(uint16_t) -1 )
8000e8fa:	ce d1       	brne	8000e8d4 <nav_filterlist_nb+0x1c>
8000e8fc:	2f f7       	sub	r7,-1
8000e8fe:	5c 87       	casts.h	r7
   {
      u16_save_position = fs_g_nav.u16_pos_filterlist;
8000e900:	e8 07 19 00 	cp.h	r7,r4
8000e904:	ce b1       	brne	8000e8da <nav_filterlist_nb+0x22>

      // Reset position
      if ( !nav_filterlist_reset())
8000e906:	e7 08 00 26 	ld.sh	r8,r3[38]
8000e90a:	aa 08       	st.h	r5[0x0],r8
         return true;

      if (fl_type == FL_DIR)
        nav_filelist_single_enable(FS_DIR);
      else if (fl_type == FL_FILE)
        nav_filelist_single_enable(FS_FILE);
8000e90c:	c2 6f       	rcall	8000e758 <nav_filterlist_reset>
8000e90e:	c3 80       	breq	8000e97e <nav_filterlist_nb+0xc6>
8000e910:	30 07       	mov	r7,0
8000e912:	30 1c       	mov	r12,1
8000e914:	c2 8e       	rcall	8000e564 <nav_filelist_single_enable>
//!                           This argument is also ignored for b_type == FS_DIR.
//!
//! @return     number of files and/or directories present in filtered file list.
//!
uint16_t   nav_filterlist_nb( fl_type_t fl_type, const FS_STRING sz_filterext )
{
8000e916:	ce 2b       	rjmp	8000e8da <nav_filterlist_nb+0x22>
8000e918:	58 1c       	cp.w	r12,1
8000e91a:	c3 b0       	breq	8000e990 <nav_filterlist_nb+0xd8>
8000e91c:	58 0b       	cp.w	r11,0
        if (!((sz_filterext)?nav_file_checkext(sz_filterext):nav_file_checkext(fs_g_nav.sz_filterext)))
          if (!update_counter(&retry))
            return false;
      }

      (*p_total)++;
8000e91e:	c6 c0       	breq	8000e9f6 <nav_filterlist_nb+0x13e>
8000e920:	3f f7       	mov	r7,-1
{
   static uint16_t   u16_save_position;
   bool   b_is_dir;

   // save current position
   if( *p_total==(uint16_t) -1 )
8000e922:	e0 65 0a 7c 	mov	r5,2684
   {
      u16_save_position = fs_g_nav.u16_pos_filterlist;
8000e926:	0e 94       	mov	r4,r7
        if (!((sz_filterext)?nav_file_checkext(sz_filterext):nav_file_checkext(fs_g_nav.sz_filterext)))
          if (!update_counter(&retry))
            return false;
      }

      (*p_total)++;
8000e928:	e0 63 0f 2c 	mov	r3,3884
{
   static uint16_t   u16_save_position;
   bool   b_is_dir;

   // save current position
   if( *p_total==(uint16_t) -1 )
8000e92c:	c0 38       	rjmp	8000e932 <nav_filterlist_nb+0x7a>
8000e92e:	2f f7       	sub	r7,-1
8000e930:	5c 87       	casts.h	r7

      *p_total = 0;
   }

   // Scan all
   while( nav_filelist_set( 0, FS_FIND_NEXT ) )
8000e932:	e8 07 19 00 	cp.h	r7,r4
8000e936:	c1 50       	breq	8000e960 <nav_filterlist_nb+0xa8>
8000e938:	30 1b       	mov	r11,1
8000e93a:	30 0c       	mov	r12,0
   {
      b_is_dir = nav_file_isdir();
8000e93c:	fe b0 fc b8 	rcall	8000e2ac <nav_filelist_set>
8000e940:	c1 70       	breq	8000e96e <nav_filterlist_nb+0xb6>
        if (!update_counter(&retry))
          return false;
        continue;
      }
      // If the selection is on a file
      if (!b_is_dir)
8000e942:	fe b0 fc b1 	rcall	8000e2a4 <nav_file_isdir>
      {
        // Check the extension of the file
        if (!((sz_filterext)?nav_file_checkext(sz_filterext):nav_file_checkext(fs_g_nav.sz_filterext)))
8000e946:	18 92       	mov	r2,r12
8000e948:	cf 31       	brne	8000e92e <nav_filterlist_nb+0x76>
8000e94a:	0c 9c       	mov	r12,r6
8000e94c:	fe b0 fc 9c 	rcall	8000e284 <nav_file_checkext>
8000e950:	ec 1c 00 01 	eorl	r12,0x1
{
   static uint16_t   u16_save_position;
   bool   b_is_dir;

   // save current position
   if( *p_total==(uint16_t) -1 )
8000e954:	e4 0c 18 00 	cp.b	r12,r2
8000e958:	ce b0       	breq	8000e92e <nav_filterlist_nb+0x76>
   {
      u16_save_position = fs_g_nav.u16_pos_filterlist;
8000e95a:	e8 07 19 00 	cp.h	r7,r4
8000e95e:	ce d1       	brne	8000e938 <nav_filterlist_nb+0x80>

      // Reset position
      if ( !nav_filterlist_reset())
8000e960:	e7 08 00 26 	ld.sh	r8,r3[38]
8000e964:	aa 08       	st.h	r5[0x0],r8
8000e966:	cf 9e       	rcall	8000e758 <nav_filterlist_reset>
8000e968:	c0 b0       	breq	8000e97e <nav_filterlist_nb+0xc6>
      (*p_total)++;
      if (!update_counter(&retry))
         return false;
   }

   nav_filelist_single_disable();
8000e96a:	30 07       	mov	r7,0
8000e96c:	ce 6b       	rjmp	8000e938 <nav_filterlist_nb+0x80>

   // Restore previous position
   if ( u16_save_position != FS_NO_SEL )
8000e96e:	fe b0 fd ed 	rcall	8000e548 <nav_filelist_single_disable>
8000e972:	8a 09       	ld.sh	r9,r5[0x0]
8000e974:	3f f8       	mov	r8,-1
8000e976:	f0 09 19 00 	cp.h	r9,r8
   {
      nav_filterlist_reset();
8000e97a:	c0 50       	breq	8000e984 <nav_filterlist_nb+0xcc>
uint16_t   nav_filterlist_nb( fl_type_t fl_type, const FS_STRING sz_filterext )
{
   uint16_t total=(uint16_t)-1; // Initialization is mandatory
   while( !nav_filterlist_nb_ex( fl_type, sz_filterext, &total, 0 ) );
   return total;
}
8000e97c:	ce ee       	rcall	8000e758 <nav_filterlist_reset>
8000e97e:	0e 9c       	mov	r12,r7
8000e980:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
   if ( u16_save_position != FS_NO_SEL )
   {
      nav_filterlist_reset();
   }else{
      // After operation, there are a file selected
      nav_filterlist_goto( u16_save_position );
8000e984:	e0 6c ff ff 	mov	r12,65535
8000e988:	cf ae       	rcall	8000e77c <nav_filterlist_goto>
uint16_t   nav_filterlist_nb( fl_type_t fl_type, const FS_STRING sz_filterext )
{
   uint16_t total=(uint16_t)-1; // Initialization is mandatory
   while( !nav_filterlist_nb_ex( fl_type, sz_filterext, &total, 0 ) );
   return total;
}
8000e98a:	0e 9c       	mov	r12,r7
8000e98c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
      }
      // If the selection is on a file
      if (!b_is_dir)
      {
        // Check the extension of the file
        if (!((sz_filterext)?nav_file_checkext(sz_filterext):nav_file_checkext(fs_g_nav.sz_filterext)))
8000e990:	58 0b       	cp.w	r11,0
8000e992:	c6 b0       	breq	8000ea68 <nav_filterlist_nb+0x1b0>
          if (!update_counter(&retry))
            return false;
      }

      (*p_total)++;
8000e994:	3f f7       	mov	r7,-1
8000e996:	e0 65 0a 7c 	mov	r5,2684
   bool   b_is_dir;

   // save current position
   if( *p_total==(uint16_t) -1 )
   {
      u16_save_position = fs_g_nav.u16_pos_filterlist;
8000e99a:	0e 96       	mov	r6,r7
{
   static uint16_t   u16_save_position;
   bool   b_is_dir;

   // save current position
   if( *p_total==(uint16_t) -1 )
8000e99c:	e0 64 0f 2c 	mov	r4,3884
8000e9a0:	ec 07 19 00 	cp.h	r7,r6

      *p_total = 0;
   }

   // Scan all
   while( nav_filelist_set( 0, FS_FIND_NEXT ) )
8000e9a4:	c5 80       	breq	8000ea54 <nav_filterlist_nb+0x19c>
8000e9a6:	30 1b       	mov	r11,1
8000e9a8:	30 0c       	mov	r12,0
8000e9aa:	fe b0 fc 81 	rcall	8000e2ac <nav_filelist_set>
   {
      b_is_dir = nav_file_isdir();
8000e9ae:	ce 00       	breq	8000e96e <nav_filterlist_nb+0xb6>
        if (!update_counter(&retry))
          return false;
        continue;
      }
      // Check if its a directory for FL_DIR mode
      if (fl_type == FL_DIR && !b_is_dir)
8000e9b0:	fe b0 fc 7a 	rcall	8000e2a4 <nav_file_isdir>
        if (!((sz_filterext)?nav_file_checkext(sz_filterext):nav_file_checkext(fs_g_nav.sz_filterext)))
          if (!update_counter(&retry))
            return false;
      }

      (*p_total)++;
8000e9b4:	cf 60       	breq	8000e9a0 <nav_filterlist_nb+0xe8>
8000e9b6:	2f f7       	sub	r7,-1
8000e9b8:	5c 87       	casts.h	r7
8000e9ba:	cf 3b       	rjmp	8000e9a0 <nav_filterlist_nb+0xe8>
{
   static uint16_t   u16_save_position;
   bool   b_is_dir;

   // save current position
   if( *p_total==(uint16_t) -1 )
8000e9bc:	3f f7       	mov	r7,-1
   {
      u16_save_position = fs_g_nav.u16_pos_filterlist;
8000e9be:	e0 65 0a 7c 	mov	r5,2684
{
   static uint16_t   u16_save_position;
   bool   b_is_dir;

   // save current position
   if( *p_total==(uint16_t) -1 )
8000e9c2:	0e 96       	mov	r6,r7
8000e9c4:	e0 64 0f 2c 	mov	r4,3884

      *p_total = 0;
   }

   // Scan all
   while( nav_filelist_set( 0, FS_FIND_NEXT ) )
8000e9c8:	ec 07 19 00 	cp.h	r7,r6
8000e9cc:	c3 a0       	breq	8000ea40 <nav_filterlist_nb+0x188>
8000e9ce:	30 1b       	mov	r11,1
   {
      b_is_dir = nav_file_isdir();
8000e9d0:	30 0c       	mov	r12,0
8000e9d2:	fe b0 fc 6d 	rcall	8000e2ac <nav_filelist_set>

      // Check if its a file for FL_FILE mode
      if (fl_type == FL_FILE && b_is_dir)
8000e9d6:	cc c0       	breq	8000e96e <nav_filterlist_nb+0xb6>
      }
      // If the selection is on a file
      if (!b_is_dir)
      {
        // Check the extension of the file
        if (!((sz_filterext)?nav_file_checkext(sz_filterext):nav_file_checkext(fs_g_nav.sz_filterext)))
8000e9d8:	fe b0 fc 66 	rcall	8000e2a4 <nav_file_isdir>
8000e9dc:	18 93       	mov	r3,r12
8000e9de:	cf 51       	brne	8000e9c8 <nav_filterlist_nb+0x110>
8000e9e0:	68 ac       	ld.w	r12,r4[0x28]
8000e9e2:	fe b0 fc 51 	rcall	8000e284 <nav_file_checkext>
8000e9e6:	ec 1c 00 01 	eorl	r12,0x1
          if (!update_counter(&retry))
            return false;
      }

      (*p_total)++;
8000e9ea:	e6 0c 18 00 	cp.b	r12,r3
//!                           This argument is also ignored for b_type == FS_DIR.
//!
//! @return     number of files and/or directories present in filtered file list.
//!
uint16_t   nav_filterlist_nb( fl_type_t fl_type, const FS_STRING sz_filterext )
{
8000e9ee:	ce d1       	brne	8000e9c8 <nav_filterlist_nb+0x110>
8000e9f0:	2f f7       	sub	r7,-1
{
   static uint16_t   u16_save_position;
   bool   b_is_dir;

   // save current position
   if( *p_total==(uint16_t) -1 )
8000e9f2:	5c 87       	casts.h	r7
   {
      u16_save_position = fs_g_nav.u16_pos_filterlist;
8000e9f4:	ce ab       	rjmp	8000e9c8 <nav_filterlist_nb+0x110>
8000e9f6:	3f f7       	mov	r7,-1
        if (!((sz_filterext)?nav_file_checkext(sz_filterext):nav_file_checkext(fs_g_nav.sz_filterext)))
          if (!update_counter(&retry))
            return false;
      }

      (*p_total)++;
8000e9f8:	e0 65 0a 7c 	mov	r5,2684
{
   static uint16_t   u16_save_position;
   bool   b_is_dir;

   // save current position
   if( *p_total==(uint16_t) -1 )
8000e9fc:	0e 96       	mov	r6,r7
8000e9fe:	e0 64 0f 2c 	mov	r4,3884

      *p_total = 0;
   }

   // Scan all
   while( nav_filelist_set( 0, FS_FIND_NEXT ) )
8000ea02:	c0 38       	rjmp	8000ea08 <nav_filterlist_nb+0x150>
8000ea04:	2f f7       	sub	r7,-1
8000ea06:	5c 87       	casts.h	r7
8000ea08:	ec 07 19 00 	cp.h	r7,r6
   {
      b_is_dir = nav_file_isdir();
8000ea0c:	c1 30       	breq	8000ea32 <nav_filterlist_nb+0x17a>
8000ea0e:	30 1b       	mov	r11,1
8000ea10:	30 0c       	mov	r12,0
        if (!update_counter(&retry))
          return false;
        continue;
      }
      // If the selection is on a file
      if (!b_is_dir)
8000ea12:	fe b0 fc 4d 	rcall	8000e2ac <nav_filelist_set>
      {
        // Check the extension of the file
        if (!((sz_filterext)?nav_file_checkext(sz_filterext):nav_file_checkext(fs_g_nav.sz_filterext)))
8000ea16:	ca c0       	breq	8000e96e <nav_filterlist_nb+0xb6>
8000ea18:	fe b0 fc 46 	rcall	8000e2a4 <nav_file_isdir>
8000ea1c:	18 93       	mov	r3,r12
8000ea1e:	cf 31       	brne	8000ea04 <nav_filterlist_nb+0x14c>
8000ea20:	68 ac       	ld.w	r12,r4[0x28]
8000ea22:	fe b0 fc 31 	rcall	8000e284 <nav_file_checkext>
   bool   b_is_dir;

   // save current position
   if( *p_total==(uint16_t) -1 )
   {
      u16_save_position = fs_g_nav.u16_pos_filterlist;
8000ea26:	ec 1c 00 01 	eorl	r12,0x1
8000ea2a:	e6 0c 18 00 	cp.b	r12,r3

      // Reset position
      if ( !nav_filterlist_reset())
8000ea2e:	ce d1       	brne	8000ea08 <nav_filterlist_nb+0x150>
8000ea30:	ce ab       	rjmp	8000ea04 <nav_filterlist_nb+0x14c>
8000ea32:	e9 08 00 26 	ld.sh	r8,r4[38]
   bool   b_is_dir;

   // save current position
   if( *p_total==(uint16_t) -1 )
   {
      u16_save_position = fs_g_nav.u16_pos_filterlist;
8000ea36:	aa 08       	st.h	r5[0x0],r8
8000ea38:	c9 0e       	rcall	8000e758 <nav_filterlist_reset>
8000ea3a:	ca 20       	breq	8000e97e <nav_filterlist_nb+0xc6>

      // Reset position
      if ( !nav_filterlist_reset())
8000ea3c:	30 07       	mov	r7,0
8000ea3e:	ce 8b       	rjmp	8000ea0e <nav_filterlist_nb+0x156>
8000ea40:	e9 08 00 26 	ld.sh	r8,r4[38]
         return true;

      if (fl_type == FL_DIR)
        nav_filelist_single_enable(FS_DIR);
      else if (fl_type == FL_FILE)
        nav_filelist_single_enable(FS_FILE);
8000ea44:	aa 08       	st.h	r5[0x0],r8
8000ea46:	c8 9e       	rcall	8000e758 <nav_filterlist_reset>
8000ea48:	c9 b0       	breq	8000e97e <nav_filterlist_nb+0xc6>
8000ea4a:	30 07       	mov	r7,0
   bool   b_is_dir;

   // save current position
   if( *p_total==(uint16_t) -1 )
   {
      u16_save_position = fs_g_nav.u16_pos_filterlist;
8000ea4c:	30 1c       	mov	r12,1
8000ea4e:	fe b0 fd 8b 	rcall	8000e564 <nav_filelist_single_enable>

      // Reset position
      if ( !nav_filterlist_reset())
8000ea52:	cb eb       	rjmp	8000e9ce <nav_filterlist_nb+0x116>
8000ea54:	e9 08 00 26 	ld.sh	r8,r4[38]
         return true;

      if (fl_type == FL_DIR)
        nav_filelist_single_enable(FS_DIR);
8000ea58:	aa 08       	st.h	r5[0x0],r8
8000ea5a:	c7 fe       	rcall	8000e758 <nav_filterlist_reset>
8000ea5c:	c9 10       	breq	8000e97e <nav_filterlist_nb+0xc6>
8000ea5e:	30 07       	mov	r7,0
8000ea60:	0e 9c       	mov	r12,r7
      }
      // If the selection is on a file
      if (!b_is_dir)
      {
        // Check the extension of the file
        if (!((sz_filterext)?nav_file_checkext(sz_filterext):nav_file_checkext(fs_g_nav.sz_filterext)))
8000ea62:	fe b0 fd 81 	rcall	8000e564 <nav_filelist_single_enable>
{
   static uint16_t   u16_save_position;
   bool   b_is_dir;

   // save current position
   if( *p_total==(uint16_t) -1 )
8000ea66:	ca 0b       	rjmp	8000e9a6 <nav_filterlist_nb+0xee>
   {
      u16_save_position = fs_g_nav.u16_pos_filterlist;
8000ea68:	3f f7       	mov	r7,-1
{
   static uint16_t   u16_save_position;
   bool   b_is_dir;

   // save current position
   if( *p_total==(uint16_t) -1 )
8000ea6a:	e0 65 0a 7c 	mov	r5,2684
8000ea6e:	0e 94       	mov	r4,r7

      *p_total = 0;
   }

   // Scan all
   while( nav_filelist_set( 0, FS_FIND_NEXT ) )
8000ea70:	e0 66 0f 2c 	mov	r6,3884
8000ea74:	e8 07 19 00 	cp.h	r7,r4
8000ea78:	c0 d0       	breq	8000ea92 <nav_filterlist_nb+0x1da>
8000ea7a:	30 1b       	mov	r11,1
   {
      b_is_dir = nav_file_isdir();
8000ea7c:	30 0c       	mov	r12,0
8000ea7e:	fe b0 fc 17 	rcall	8000e2ac <nav_filelist_set>
        if (!((sz_filterext)?nav_file_checkext(sz_filterext):nav_file_checkext(fs_g_nav.sz_filterext)))
          if (!update_counter(&retry))
            return false;
      }

      (*p_total)++;
8000ea82:	fe 90 ff 76 	breq	8000e96e <nav_filterlist_nb+0xb6>
8000ea86:	fe b0 fc 0f 	rcall	8000e2a4 <nav_file_isdir>
   bool   b_is_dir;

   // save current position
   if( *p_total==(uint16_t) -1 )
   {
      u16_save_position = fs_g_nav.u16_pos_filterlist;
8000ea8a:	cf 50       	breq	8000ea74 <nav_filterlist_nb+0x1bc>
8000ea8c:	2f f7       	sub	r7,-1

      // Reset position
      if ( !nav_filterlist_reset())
8000ea8e:	5c 87       	casts.h	r7
8000ea90:	cf 2b       	rjmp	8000ea74 <nav_filterlist_nb+0x1bc>
8000ea92:	ed 08 00 26 	ld.sh	r8,r6[38]
         return true;

      if (fl_type == FL_DIR)
        nav_filelist_single_enable(FS_DIR);
8000ea96:	aa 08       	st.h	r5[0x0],r8
8000ea98:	c6 0e       	rcall	8000e758 <nav_filterlist_reset>
8000ea9a:	fe 90 ff 72 	breq	8000e97e <nav_filterlist_nb+0xc6>
8000ea9e:	30 07       	mov	r7,0
8000eaa0:	0e 9c       	mov	r12,r7
8000eaa2:	fe b0 fd 61 	rcall	8000e564 <nav_filelist_single_enable>
8000eaa6:	ce ab       	rjmp	8000ea7a <nav_filterlist_nb+0x1c2>

8000eaa8 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
8000eaa8:	e0 7d 00 00 	mov	sp,65536

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
8000eaac:	48 e0       	lddpc	r0,8000eae4 <udata_clear_loop_end+0x6>
8000eaae:	e3 b0 00 01 	mtsr	0x4,r0

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
8000eab2:	d5 53       	csrf	0x15
  lda.w   r1, _edata
8000eab4:	30 80       	mov	r0,8
  cp      r0, r1
8000eab6:	e0 61 05 60 	mov	r1,1376
  brhs    idata_load_loop_end
  lda.w   r2, _data_lma
8000eaba:	02 30       	cp.w	r0,r1
idata_load_loop:
  ld.d    r4, r2++
8000eabc:	c0 62       	brcc	8000eac8 <idata_load_loop_end>
  st.d    r0++, r4
8000eabe:	48 b2       	lddpc	r2,8000eae8 <udata_clear_loop_end+0xa>

8000eac0 <idata_load_loop>:
  cp      r0, r1
8000eac0:	a5 05       	ld.d	r4,r2++
  brlo    idata_load_loop
8000eac2:	a1 24       	st.d	r0++,r4
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
8000eac4:	02 30       	cp.w	r0,r1
  lda.w   r1, _end
8000eac6:	cf d3       	brcs	8000eac0 <idata_load_loop>

8000eac8 <idata_load_loop_end>:
  cp      r0, r1
8000eac8:	e0 60 05 60 	mov	r0,1376
  brhs    udata_clear_loop_end
  mov     r2, 0
8000eacc:	e0 61 12 18 	mov	r1,4632
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
8000ead0:	02 30       	cp.w	r0,r1
  cp      r0, r1
8000ead2:	c0 62       	brcc	8000eade <udata_clear_loop_end>
  brlo    udata_clear_loop
8000ead4:	30 02       	mov	r2,0
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
8000ead6:	30 03       	mov	r3,0

8000ead8 <udata_clear_loop>:
8000ead8:	a1 22       	st.d	r0++,r2
8000eada:	02 30       	cp.w	r0,r1
8000eadc:	cf e3       	brcs	8000ead8 <udata_clear_loop>

8000eade <udata_clear_loop_end>:
8000eade:	fe cf f9 d6 	sub	pc,pc,-1578
8000eae2:	d7 03       	nop
8000eae4:	80 01       	ld.sh	r1,r0[0x0]
8000eae6:	6c 00       	ld.w	r0,r6[0x0]
8000eae8:	80 01       	ld.sh	r1,r0[0x0]
8000eaea:	8f c0       	st.w	r7[0x30],r0

8000eaec <get_nb_lun>:

  return nb_lun;
#else
  return MAX_LUN;
#endif
}
8000eaec:	5e ff       	retal	1
8000eaee:	d7 03       	nop

8000eaf0 <mem_test_unit_ready>:
  return LUN_ID_0;
}


Ctrl_status mem_test_unit_ready(U8 lun)
{
8000eaf0:	d4 01       	pushm	lr
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
8000eaf2:	58 0c       	cp.w	r12,0
8000eaf4:	c0 20       	breq	8000eaf8 <mem_test_unit_ready+0x8>
8000eaf6:	da 0a       	popm	pc,r12=1
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].test_unit_ready() :
8000eaf8:	fe b0 e4 c0 	rcall	8000b478 <sd_mmc_spi_test_unit_ready>
#endif

  Ctrl_access_unlock();

  return status;
}
8000eafc:	d8 02       	popm	pc
8000eafe:	d7 03       	nop

8000eb00 <mem_sector_size>:
8000eb00:	58 0c       	cp.w	r12,0
8000eb02:	5f 0c       	sreq	r12
#endif

  Ctrl_access_unlock();

  return sector_size;
}
8000eb04:	5e fc       	retal	r12
8000eb06:	d7 03       	nop

8000eb08 <mem_wr_protect>:

  return unloaded;
}

bool mem_wr_protect(U8 lun)
{
8000eb08:	d4 01       	pushm	lr
  bool wr_protect;

  if (!Ctrl_access_lock()) return true;

  wr_protect =
8000eb0a:	58 0c       	cp.w	r12,0
8000eb0c:	c0 20       	breq	8000eb10 <mem_wr_protect+0x8>
8000eb0e:	da 0a       	popm	pc,r12=1
#if MAX_LUN
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
8000eb10:	fe b0 e4 b2 	rcall	8000b474 <sd_mmc_spi_wr_protect>
#endif

  Ctrl_access_unlock();

  return wr_protect;
}
8000eb14:	d8 02       	popm	pc
8000eb16:	d7 03       	nop

8000eb18 <memory_2_ram>:
8000eb18:	d4 01       	pushm	lr
8000eb1a:	16 98       	mov	r8,r11
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
8000eb1c:	58 0c       	cp.w	r12,0
8000eb1e:	c0 20       	breq	8000eb22 <memory_2_ram+0xa>
8000eb20:	da 0a       	popm	pc,r12=1
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].mem_2_ram(addr, ram) :
8000eb22:	14 9b       	mov	r11,r10
8000eb24:	10 9c       	mov	r12,r8
8000eb26:	fe b0 e4 fb 	rcall	8000b51c <sd_mmc_spi_mem_2_ram>
  memory_stop_read_action();

  Ctrl_access_unlock();

  return status;
}
8000eb2a:	d8 02       	popm	pc

8000eb2c <ram_2_memory>:
8000eb2c:	d4 01       	pushm	lr
8000eb2e:	16 98       	mov	r8,r11
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_write_action(1);
  status =
8000eb30:	58 0c       	cp.w	r12,0
8000eb32:	c0 20       	breq	8000eb36 <ram_2_memory+0xa>
8000eb34:	da 0a       	popm	pc,r12=1
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].ram_2_mem(addr, ram) :
8000eb36:	14 9b       	mov	r11,r10
8000eb38:	10 9c       	mov	r12,r8
8000eb3a:	fe b0 e4 cf 	rcall	8000b4d8 <sd_mmc_spi_ram_2_mem>
  memory_stop_write_action();

  Ctrl_access_unlock();

  return status;
}
8000eb3e:	d8 02       	popm	pc

8000eb40 <pdca_int_handler_SD>:



__attribute__((__interrupt__))
static void pdca_int_handler_SD(void)
{
8000eb40:	d4 01       	pushm	lr
8000eb42:	20 1d       	sub	sp,4
  // Disable all interrupts.
  Disable_global_interrupt();
8000eb44:	d3 03       	ssrf	0x10

  // Disable interrupt channel.
  pdca_disable_interrupt_transfer_complete(AVR32_PDCA_CHANNEL_SPI_RX);
8000eb46:	30 0c       	mov	r12,0
8000eb48:	fe b0 e6 cb 	rcall	8000b8de <pdca_disable_interrupt_transfer_complete>

  sd_mmc_spi_read_close_PDCA();//unselects the SD/MMC memory.
8000eb4c:	fe b0 d9 26 	rcall	80009d98 <sd_mmc_spi_read_close_PDCA>

// Software wait
void wait(void)
{
	volatile int i;
	for(i = 0 ; i < 5000; i++);
8000eb50:	30 08       	mov	r8,0
8000eb52:	50 08       	stdsp	sp[0x0],r8
8000eb54:	40 08       	lddsp	r8,sp[0x0]
8000eb56:	e0 48 13 87 	cp.w	r8,4999
8000eb5a:	e0 89 00 0a 	brgt	8000eb6e <pdca_int_handler_SD+0x2e>
8000eb5e:	40 08       	lddsp	r8,sp[0x0]
8000eb60:	2f f8       	sub	r8,-1
8000eb62:	50 08       	stdsp	sp[0x0],r8
8000eb64:	40 08       	lddsp	r8,sp[0x0]
8000eb66:	e0 48 13 87 	cp.w	r8,4999
8000eb6a:	fe 9a ff fa 	brle	8000eb5e <pdca_int_handler_SD+0x1e>
  pdca_disable_interrupt_transfer_complete(AVR32_PDCA_CHANNEL_SPI_RX);

  sd_mmc_spi_read_close_PDCA();//unselects the SD/MMC memory.
  wait();
  // Disable unnecessary channel
  pdca_disable(AVR32_PDCA_CHANNEL_SPI_TX);
8000eb6e:	30 1c       	mov	r12,1
8000eb70:	fe b0 e6 a8 	rcall	8000b8c0 <pdca_disable>
  pdca_disable(AVR32_PDCA_CHANNEL_SPI_RX);
8000eb74:	30 0c       	mov	r12,0
8000eb76:	fe b0 e6 a5 	rcall	8000b8c0 <pdca_disable>

  // Enable all interrupts.
  Enable_global_interrupt();
8000eb7a:	d5 03       	csrf	0x10

  end_of_transfer = 1;
8000eb7c:	30 19       	mov	r9,1
8000eb7e:	e0 68 0a 80 	mov	r8,2688
}
8000eb82:	91 09       	st.w	r8[0x0],r9
8000eb84:	2f fd       	sub	sp,-4
8000eb86:	d4 02       	popm	lr
8000eb88:	d6 03       	rete
8000eb8a:	d7 03       	nop

8000eb8c <pdca_int_handler_USART>:
8000eb8c:	d4 01       	pushm	lr
8000eb8e:	d3 03       	ssrf	0x10
8000eb90:	48 9b       	lddpc	r11,8000ebb4 <pdca_int_handler_USART+0x28>
8000eb92:	fe 7c 14 00 	mov	r12,-60416
8000eb96:	fe b0 e8 fe 	rcall	8000bd92 <usart_write_line>
static void pdca_int_handler_USART(void){
	Disable_global_interrupt();
	
	usart_write_line(&AVR32_USART0,"recibido");
	
	pdca_disable_interrupt_transfer_complete(PDCA_CHANNEL_USART_EXAMPLE);
8000eb9a:	30 2c       	mov	r12,2
8000eb9c:	fe b0 e6 a1 	rcall	8000b8de <pdca_disable_interrupt_transfer_complete>
	pdca_disable(PDCA_CHANNEL_USART_EXAMPLE);
8000eba0:	30 2c       	mov	r12,2
8000eba2:	fe b0 e6 8f 	rcall	8000b8c0 <pdca_disable>
	end_of_transfer=1;
8000eba6:	30 19       	mov	r9,1
8000eba8:	e0 68 0a 80 	mov	r8,2688
	Enable_global_interrupt();
8000ebac:	91 09       	st.w	r8[0x0],r9
	
}
8000ebae:	d5 03       	csrf	0x10
8000ebb0:	d4 02       	popm	lr
8000ebb2:	d6 03       	rete
8000ebb4:	80 01       	ld.sh	r1,r0[0x0]
8000ebb6:	83 00       	st.w	r1[0x0],r0

8000ebb8 <debounce2>:
8000ebb8:	eb cd 40 80 	pushm	r7,lr
8000ebbc:	18 97       	mov	r7,r12
8000ebbe:	fe b0 e5 99 	rcall	8000b6f0 <gpio_get_pin_value>
8000ebc2:	c0 31       	brne	8000ebc8 <debounce2+0x10>
8000ebc4:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000ebc8:	e1 b9 00 42 	mfsr	r9,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000ebcc:	e0 78 d4 c0 	mov	r8,120000
8000ebd0:	f2 08 00 0a 	add	r10,r9,r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000ebd4:	e1 b8 00 42 	mfsr	r8,0x108
8000ebd8:	14 39       	cp.w	r9,r10
8000ebda:	e0 8b 00 2c 	brhi	8000ec32 <debounce2+0x7a>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000ebde:	10 39       	cp.w	r9,r8
8000ebe0:	e0 8b 00 04 	brhi	8000ebe8 <debounce2+0x30>
8000ebe4:	10 3a       	cp.w	r10,r8
8000ebe6:	c3 72       	brcc	8000ec54 <debounce2+0x9c>


uint32_t debounce2( uint32_t GPIO_PIN ){//regresar se presiono el boton o no
	if(gpio_get_pin_value(GPIO_PIN)==1){// se presiono el boton?, sino salir de la funcion
		delay_ms(10);
		if (gpio_get_pin_value(GPIO_PIN)==0){//Si ya se libero, es ruido, salir sin hacer nada
8000ebe8:	0e 9c       	mov	r12,r7
8000ebea:	fe b0 e5 83 	rcall	8000b6f0 <gpio_get_pin_value>
8000ebee:	ce b0       	breq	8000ebc4 <debounce2+0xc>
			goto salir;
		}
		espera://espera a que suelte el botn
		while (gpio_get_pin_value(GPIO_PIN)==1){}
8000ebf0:	0e 9c       	mov	r12,r7
8000ebf2:	fe b0 e5 7f 	rcall	8000b6f0 <gpio_get_pin_value>
8000ebf6:	cf d1       	brne	8000ebf0 <debounce2+0x38>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000ebf8:	e1 b9 00 42 	mfsr	r9,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000ebfc:	e0 78 d4 c0 	mov	r8,120000
8000ec00:	f2 08 00 0a 	add	r10,r9,r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000ec04:	e1 b8 00 42 	mfsr	r8,0x108
8000ec08:	14 39       	cp.w	r9,r10
8000ec0a:	e0 8b 00 1a 	brhi	8000ec3e <debounce2+0x86>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000ec0e:	10 39       	cp.w	r9,r8
8000ec10:	e0 8b 00 09 	brhi	8000ec22 <debounce2+0x6a>
8000ec14:	10 3a       	cp.w	r10,r8
8000ec16:	c0 63       	brcs	8000ec22 <debounce2+0x6a>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000ec18:	e1 b8 00 42 	mfsr	r8,0x108
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000ec1c:	10 39       	cp.w	r9,r8
8000ec1e:	fe 98 ff fb 	brls	8000ec14 <debounce2+0x5c>
		delay_ms(10);
		if (gpio_get_pin_value(GPIO_PIN)==1) {//si ya lo presiono otra vez , es ruido, regresa a esperar
8000ec22:	0e 9c       	mov	r12,r7
8000ec24:	fe b0 e5 66 	rcall	8000b6f0 <gpio_get_pin_value>
8000ec28:	ce 41       	brne	8000ebf0 <debounce2+0x38>
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000ec2a:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000ec2e:	e1 b8 00 42 	mfsr	r8,0x108
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000ec32:	10 39       	cp.w	r9,r8
8000ec34:	fe 98 ff fd 	brls	8000ec2e <debounce2+0x76>
8000ec38:	10 3a       	cp.w	r10,r8
8000ec3a:	cd 73       	brcs	8000ebe8 <debounce2+0x30>
8000ec3c:	cf 9b       	rjmp	8000ec2e <debounce2+0x76>
8000ec3e:	10 39       	cp.w	r9,r8
8000ec40:	e0 88 00 04 	brls	8000ec48 <debounce2+0x90>
8000ec44:	10 3a       	cp.w	r10,r8
8000ec46:	ce e3       	brcs	8000ec22 <debounce2+0x6a>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000ec48:	e1 b8 00 42 	mfsr	r8,0x108
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000ec4c:	10 39       	cp.w	r9,r8
8000ec4e:	fe 98 ff fd 	brls	8000ec48 <debounce2+0x90>
8000ec52:	cf 9b       	rjmp	8000ec44 <debounce2+0x8c>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000ec54:	e1 b8 00 42 	mfsr	r8,0x108
8000ec58:	cc 3b       	rjmp	8000ebde <debounce2+0x26>
8000ec5a:	d7 03       	nop

8000ec5c <lodepng_decode_display>:
8000ec5c:	d4 31       	pushm	r0-r7,lr
8000ec5e:	fa cd 01 50 	sub	sp,sp,336
  * PNG decoder, decodes the .PNG image and display it on ET024006 display device
  * with various scaling factors.
  */
 
 void lodepng_decode_display(unsigned char* table,size_t buffersize,int scale)
 {
8000ec62:	18 97       	mov	r7,r12
8000ec64:	16 96       	mov	r6,r11
8000ec66:	51 0a       	stdsp	sp[0x40],r10
     LodePNG_Decoder decoder;
     unsigned int i,j;
     uint16_t color;
     uint16_t* temp16;
 
     LodePNG_Decoder_init(&decoder);
8000ec68:	fa cc ff 8c 	sub	r12,sp,-116
8000ec6c:	fe b0 a7 9c 	rcall	80003ba4 <LodePNG_Decoder_init>
     //decode the png
     LodePNG_decode(&decoder, &image, &imagesize, table, buffersize);
8000ec70:	0e 99       	mov	r9,r7
8000ec72:	0c 98       	mov	r8,r6
8000ec74:	fa ca fe b8 	sub	r10,sp,-328
8000ec78:	fa cb fe b4 	sub	r11,sp,-332
8000ec7c:	fa cc ff 8c 	sub	r12,sp,-116
8000ec80:	fe b0 ba 84 	rcall	80006188 <LodePNG_decode>
     usart_write_line(&AVR32_USART0,"Decoding completed \r\n");
8000ec84:	fe fb 04 74 	ld.w	r11,pc[1140]
8000ec88:	fe 7c 14 00 	mov	r12,-60416
8000ec8c:	fe b0 e8 83 	rcall	8000bd92 <usart_write_line>
 
     /* if there's an error, display it, otherwise display
      * information about the image
      */
     if(decoder.error) {
8000ec90:	45 17       	lddsp	r7,sp[0x144]
8000ec92:	58 07       	cp.w	r7,0
8000ec94:	e0 81 02 2b 	brne	8000f0ea <lodepng_decode_display+0x48e>
         usart_write_line(&AVR32_USART0,"error: Decoding\r\n");
         return;
     }
     else {
 #if (defined __GNUC__)
         usart_write_line(&AVR32_USART0,"Decoding Successful\r\n");
8000ec98:	fe fb 04 64 	ld.w	r11,pc[1124]
8000ec9c:	fe 7c 14 00 	mov	r12,-60416
8000eca0:	fe b0 e8 79 	rcall	8000bd92 <usart_write_line>
                 decoder.infoPng.phys_y, (int)decoder.infoPng.phys_unit);
         }
 #endif
 
     }
    usart_write_line(&AVR32_USART0,"sending to display\r\n");
8000eca4:	fe fb 04 5c 	ld.w	r11,pc[1116]
8000eca8:	fe 7c 14 00 	mov	r12,-60416
8000ecac:	fe b0 e8 73 	rcall	8000bd92 <usart_write_line>
 
     // changing to 16-bit 565
     temp16 = (uint16_t *) image;
8000ecb0:	45 3a       	lddsp	r10,sp[0x14c]
8000ecb2:	51 aa       	stdsp	sp[0x68],r10
     for(i=0,j=0;i<(decoder.infoPng.width*decoder.infoPng.height*4);i=i+4,j++) {
8000ecb4:	42 a8       	lddsp	r8,sp[0xa8]
8000ecb6:	42 b9       	lddsp	r9,sp[0xac]
8000ecb8:	f2 08 02 48 	mul	r8,r9,r8
8000ecbc:	a3 68       	lsl	r8,0x2
8000ecbe:	c1 60       	breq	8000ecea <lodepng_decode_display+0x8e>
8000ecc0:	14 96       	mov	r6,r10
8000ecc2:	14 98       	mov	r8,r10
8000ecc4:	c0 28       	rjmp	8000ecc8 <lodepng_decode_display+0x6c>
8000ecc6:	45 38       	lddsp	r8,sp[0x14c]
         r= (uint8_t)*(image+i);
         g = (uint8_t)*(image+i+1);
         b = (uint8_t)*(image+i+2);
         color = et024006_Color(r,g,b);
8000ecc8:	f0 07 07 0c 	ld.ub	r12,r8[r7]
8000eccc:	0e 08       	add	r8,r7
8000ecce:	11 9b       	ld.ub	r11,r8[0x1]
8000ecd0:	11 aa       	ld.ub	r10,r8[0x2]
8000ecd2:	fe b0 d2 c5 	rcall	8000925c <et024006_Color>
         temp16[j] = color;
8000ecd6:	0c bc       	st.h	r6++,r12
     }
    usart_write_line(&AVR32_USART0,"sending to display\r\n");
 
     // changing to 16-bit 565
     temp16 = (uint16_t *) image;
     for(i=0,j=0;i<(decoder.infoPng.width*decoder.infoPng.height*4);i=i+4,j++) {
8000ecd8:	2f c7       	sub	r7,-4
8000ecda:	42 b8       	lddsp	r8,sp[0xac]
8000ecdc:	42 a9       	lddsp	r9,sp[0xa8]
8000ecde:	f2 08 02 48 	mul	r8,r9,r8
8000ece2:	a3 68       	lsl	r8,0x2
8000ece4:	0e 38       	cp.w	r8,r7
8000ece6:	fe 9b ff f0 	brhi	8000ecc6 <lodepng_decode_display+0x6a>
         color = et024006_Color(r,g,b);
         temp16[j] = color;
     }
 
     //call scaling if required -supports only 1/2,1/4,1/8
     if(scale>1) {
8000ecea:	41 09       	lddsp	r9,sp[0x40]
8000ecec:	58 19       	cp.w	r9,1
8000ecee:	e0 8a 01 14 	brle	8000ef16 <lodepng_decode_display+0x2ba>
8000ecf2:	12 96       	mov	r6,r9
 {
     int x, y, x2, y2;
     int TgtWidth, TgtHeight;
     PIXEL p,p1,q,q1,r,r1,s,s1;
 
     TgtWidth = SrcWidth / denom;
8000ecf4:	e0 69 01 40 	mov	r9,320
8000ecf8:	f2 06 0c 08 	divs	r8,r9,r6
     TgtHeight = SrcHeight / denom;
8000ecfc:	e0 69 00 f0 	mov	r9,240
 {
     int x, y, x2, y2;
     int TgtWidth, TgtHeight;
     PIXEL p,p1,q,q1,r,r1,s,s1;
 
     TgtWidth = SrcWidth / denom;
8000ed00:	51 28       	stdsp	sp[0x48],r8
     TgtHeight = SrcHeight / denom;
8000ed02:	f2 06 0c 08 	divs	r8,r9,r6
8000ed06:	51 c8       	stdsp	sp[0x70],r8
 
     // Box filter method
     for (y = 0; y < TgtHeight; y++) {
8000ed08:	58 08       	cp.w	r8,0
8000ed0a:	e0 80 01 06 	breq	8000ef16 <lodepng_decode_display+0x2ba>
  * \brief lodepng_decode_display function : This function initialise the
  * PNG decoder, decodes the .PNG image and display it on ET024006 display device
  * with various scaling factors.
  */
 
 void lodepng_decode_display(unsigned char* table,size_t buffersize,int scale)
8000ed0e:	ec 06 00 28 	add	r8,r6,r6<<0x2
8000ed12:	a7 78       	lsl	r8,0x7
8000ed14:	41 a0       	lddsp	r0,sp[0x68]
8000ed16:	51 48       	stdsp	sp[0x50],r8
8000ed18:	41 21       	lddsp	r1,sp[0x48]
8000ed1a:	e0 c8 fb 00 	sub	r8,r0,-1280
8000ed1e:	a1 71       	lsl	r1,0x1
8000ed20:	e0 ca f8 80 	sub	r10,r0,-1920
8000ed24:	51 b1       	stdsp	sp[0x6c],r1
8000ed26:	e0 c9 f8 7e 	sub	r9,r0,-1922
8000ed2a:	51 68       	stdsp	sp[0x58],r8
8000ed2c:	e0 c6 fa fe 	sub	r6,r0,-1282
8000ed30:	30 01       	mov	r1,0
8000ed32:	41 08       	lddsp	r8,sp[0x40]
8000ed34:	51 90       	stdsp	sp[0x64],r0
8000ed36:	51 1a       	stdsp	sp[0x44],r10
8000ed38:	51 59       	stdsp	sp[0x54],r9
8000ed3a:	51 76       	stdsp	sp[0x5c],r6
8000ed3c:	51 81       	stdsp	sp[0x60],r1
8000ed3e:	a1 78       	lsl	r8,0x1
     TgtHeight = SrcHeight / denom;
 
     // Box filter method
     for (y = 0; y < TgtHeight; y++) {
         y2 = denom * y;
         for (x = 0; x < TgtWidth; x++) {
8000ed40:	41 20       	lddsp	r0,sp[0x48]
8000ed42:	58 00       	cp.w	r0,0
8000ed44:	e0 80 00 d0 	breq	8000eee4 <lodepng_decode_display+0x288>
  * \brief lodepng_decode_display function : This function initialise the
  * PNG decoder, decodes the .PNG image and display it on ET024006 display device
  * with various scaling factors.
  */
 
 void lodepng_decode_display(unsigned char* table,size_t buffersize,int scale)
8000ed48:	41 1a       	lddsp	r10,sp[0x44]
8000ed4a:	f4 c9 f5 fe 	sub	r9,r10,-2562
8000ed4e:	f4 c0 f8 80 	sub	r0,r10,-1920
8000ed52:	f4 c1 f6 00 	sub	r1,r10,-2560
8000ed56:	f4 c6 07 80 	sub	r6,r10,1920
8000ed5a:	f4 c7 07 7e 	sub	r7,r10,1918
8000ed5e:	f4 ce 05 00 	sub	lr,r10,1280
8000ed62:	f4 cc 04 fe 	sub	r12,r10,1278
8000ed66:	f4 ca f8 7e 	sub	r10,r10,-1922
8000ed6a:	50 e9       	stdsp	sp[0x38],r9
8000ed6c:	50 d0       	stdsp	sp[0x34],r0
8000ed6e:	50 ca       	stdsp	sp[0x30],r10
8000ed70:	41 19       	lddsp	r9,sp[0x44]
8000ed72:	41 10       	lddsp	r0,sp[0x44]
8000ed74:	f2 c9 fb 00 	sub	r9,r9,-1280
8000ed78:	e0 c0 fa fe 	sub	r0,r0,-1282
8000ed7c:	41 1a       	lddsp	r10,sp[0x44]
8000ed7e:	f4 ca fd 80 	sub	r10,r10,-640
8000ed82:	50 b9       	stdsp	sp[0x2c],r9
8000ed84:	50 a0       	stdsp	sp[0x28],r0
8000ed86:	50 9a       	stdsp	sp[0x24],r10
8000ed88:	41 70       	lddsp	r0,sp[0x5c]
8000ed8a:	41 6a       	lddsp	r10,sp[0x58]
8000ed8c:	41 19       	lddsp	r9,sp[0x44]
8000ed8e:	f2 c9 fd 7e 	sub	r9,r9,-642
8000ed92:	50 40       	stdsp	sp[0x10],r0
8000ed94:	50 89       	stdsp	sp[0x20],r9
8000ed96:	41 10       	lddsp	r0,sp[0x44]
8000ed98:	41 59       	lddsp	r9,sp[0x54]
8000ed9a:	50 5a       	stdsp	sp[0x14],r10
8000ed9c:	14 93       	mov	r3,r10
8000ed9e:	50 69       	stdsp	sp[0x18],r9
8000eda0:	41 9a       	lddsp	r10,sp[0x64]
8000eda2:	50 70       	stdsp	sp[0x1c],r0
8000eda4:	41 72       	lddsp	r2,sp[0x5c]
8000eda6:	12 94       	mov	r4,r9
8000eda8:	00 95       	mov	r5,r0
8000edaa:	50 fa       	stdsp	sp[0x3c],r10
8000edac:	30 0b       	mov	r11,0
8000edae:	50 01       	stdsp	sp[0x0],r1
8000edb0:	c4 28       	rjmp	8000ee34 <lodepng_decode_display+0x1d8>
                 s = AVERAGE(Source[(y2+3)*SrcWidth + x2],
                     Source[(y2+3)*SrcWidth + x2 + 1]);
                 p = AVERAGE(p,r);
                 q = AVERAGE(q,s);
             }
             else if(denom==8) {
8000edb2:	58 81       	cp.w	r1,8
8000edb4:	e0 80 00 e2 	breq	8000ef78 <lodepng_decode_display+0x31c>
                 p1 = AVERAGE(p1,r1);
                 q1 = AVERAGE(q1,s1);
                 p =  AVERAGE(p,p1);
                 q = AVERAGE(q,q1);
             }
             Target[y*TgtWidth + x] = AVERAGE(p, q);
8000edb8:	f4 09 19 00 	cp.h	r9,r10
8000edbc:	c0 90       	breq	8000edce <lodepng_decode_display+0x172>
8000edbe:	e2 19 f7 df 	andl	r9,0xf7df,COH
8000edc2:	e2 1a f7 df 	andl	r10,0xf7df,COH
8000edc6:	f4 09 00 09 	add	r9,r10,r9
8000edca:	f3 d9 b0 30 	bfexts	r9,r9,0x1,0x10
8000edce:	40 fa       	lddsp	r10,sp[0x3c]
8000edd0:	14 b9       	st.h	r10++,r9
     TgtHeight = SrcHeight / denom;
 
     // Box filter method
     for (y = 0; y < TgtHeight; y++) {
         y2 = denom * y;
         for (x = 0; x < TgtWidth; x++) {
8000edd2:	40 09       	lddsp	r9,sp[0x0]
8000edd4:	40 e1       	lddsp	r1,sp[0x38]
8000edd6:	10 09       	add	r9,r8
8000edd8:	10 01       	add	r1,r8
8000edda:	40 d0       	lddsp	r0,sp[0x34]
                 p1 = AVERAGE(p1,r1);
                 q1 = AVERAGE(q1,s1);
                 p =  AVERAGE(p,p1);
                 q = AVERAGE(q,q1);
             }
             Target[y*TgtWidth + x] = AVERAGE(p, q);
8000eddc:	50 fa       	stdsp	sp[0x3c],r10
     TgtHeight = SrcHeight / denom;
 
     // Box filter method
     for (y = 0; y < TgtHeight; y++) {
         y2 = denom * y;
         for (x = 0; x < TgtWidth; x++) {
8000edde:	10 00       	add	r0,r8
8000ede0:	40 ca       	lddsp	r10,sp[0x30]
8000ede2:	10 0a       	add	r10,r8
8000ede4:	50 09       	stdsp	sp[0x0],r9
8000ede6:	50 e1       	stdsp	sp[0x38],r1
8000ede8:	40 b9       	lddsp	r9,sp[0x2c]
8000edea:	40 a1       	lddsp	r1,sp[0x28]
8000edec:	10 09       	add	r9,r8
8000edee:	10 01       	add	r1,r8
8000edf0:	50 d0       	stdsp	sp[0x34],r0
8000edf2:	50 ca       	stdsp	sp[0x30],r10
8000edf4:	40 90       	lddsp	r0,sp[0x24]
8000edf6:	40 8a       	lddsp	r10,sp[0x20]
8000edf8:	10 00       	add	r0,r8
8000edfa:	10 0a       	add	r10,r8
8000edfc:	50 b9       	stdsp	sp[0x2c],r9
8000edfe:	50 a1       	stdsp	sp[0x28],r1
8000ee00:	40 79       	lddsp	r9,sp[0x1c]
8000ee02:	40 61       	lddsp	r1,sp[0x18]
8000ee04:	10 09       	add	r9,r8
8000ee06:	50 90       	stdsp	sp[0x24],r0
8000ee08:	50 8a       	stdsp	sp[0x20],r10
8000ee0a:	40 50       	lddsp	r0,sp[0x14]
8000ee0c:	40 4a       	lddsp	r10,sp[0x10]
8000ee0e:	50 79       	stdsp	sp[0x1c],r9
8000ee10:	10 01       	add	r1,r8
8000ee12:	10 00       	add	r0,r8
8000ee14:	10 0a       	add	r10,r8
8000ee16:	50 61       	stdsp	sp[0x18],r1
8000ee18:	50 50       	stdsp	sp[0x14],r0
8000ee1a:	50 4a       	stdsp	sp[0x10],r10
8000ee1c:	2f fb       	sub	r11,-1
8000ee1e:	10 06       	add	r6,r8
8000ee20:	10 07       	add	r7,r8
8000ee22:	10 05       	add	r5,r8
8000ee24:	10 04       	add	r4,r8
8000ee26:	10 03       	add	r3,r8
8000ee28:	10 02       	add	r2,r8
8000ee2a:	10 0e       	add	lr,r8
8000ee2c:	10 0c       	add	r12,r8
8000ee2e:	41 29       	lddsp	r9,sp[0x48]
8000ee30:	12 3b       	cp.w	r11,r9
8000ee32:	c5 90       	breq	8000eee4 <lodepng_decode_display+0x288>
             x2 = denom * x;
             p = AVERAGE(Source[y2*SrcWidth + x2], Source[y2*SrcWidth +
8000ee34:	8c 09       	ld.sh	r9,r6[0x0]
8000ee36:	8e 0a       	ld.sh	r10,r7[0x0]
8000ee38:	f4 09 19 00 	cp.h	r9,r10
8000ee3c:	c0 90       	breq	8000ee4e <lodepng_decode_display+0x1f2>
8000ee3e:	e2 19 f7 df 	andl	r9,0xf7df,COH
8000ee42:	e2 1a f7 df 	andl	r10,0xf7df,COH
8000ee46:	f4 09 00 09 	add	r9,r10,r9
8000ee4a:	f3 d9 b0 30 	bfexts	r9,r9,0x1,0x10
                 x2 + 1]);
             q = AVERAGE(Source[(y2+1)*SrcWidth + x2], Source[(y2+1)*SrcWidth +
8000ee4e:	9c 0a       	ld.sh	r10,lr[0x0]
8000ee50:	98 00       	ld.sh	r0,r12[0x0]
8000ee52:	e0 0a 19 00 	cp.h	r10,r0
8000ee56:	c0 90       	breq	8000ee68 <lodepng_decode_display+0x20c>
8000ee58:	e2 1a f7 df 	andl	r10,0xf7df,COH
8000ee5c:	e2 10 f7 df 	andl	r0,0xf7df,COH
8000ee60:	e0 0a 00 0a 	add	r10,r0,r10
8000ee64:	f5 da b0 30 	bfexts	r10,r10,0x1,0x10
                 x2 + 1]);
 
             if (denom==4) {
8000ee68:	41 01       	lddsp	r1,sp[0x40]
8000ee6a:	58 41       	cp.w	r1,4
8000ee6c:	ca 31       	brne	8000edb2 <lodepng_decode_display+0x156>
                 r = AVERAGE(Source[(y2+2)*SrcWidth + x2],
8000ee6e:	86 00       	ld.sh	r0,r3[0x0]
8000ee70:	50 10       	stdsp	sp[0x4],r0
8000ee72:	84 01       	ld.sh	r1,r2[0x0]
8000ee74:	e2 00 19 00 	cp.h	r0,r1
8000ee78:	c0 90       	breq	8000ee8a <lodepng_decode_display+0x22e>
8000ee7a:	e2 10 f7 df 	andl	r0,0xf7df,COH
8000ee7e:	e2 11 f7 df 	andl	r1,0xf7df,COH
8000ee82:	00 01       	add	r1,r0
8000ee84:	e3 d1 b0 30 	bfexts	r1,r1,0x1,0x10
8000ee88:	50 11       	stdsp	sp[0x4],r1
                     Source[(y2+2)*SrcWidth + x2 + 1]);
                 s = AVERAGE(Source[(y2+3)*SrcWidth + x2],
8000ee8a:	8a 01       	ld.sh	r1,r5[0x0]
8000ee8c:	88 00       	ld.sh	r0,r4[0x0]
8000ee8e:	50 20       	stdsp	sp[0x8],r0
8000ee90:	e0 01 19 00 	cp.h	r1,r0
8000ee94:	c0 b0       	breq	8000eeaa <lodepng_decode_display+0x24e>
8000ee96:	e2 11 f7 df 	andl	r1,0xf7df,COH
8000ee9a:	50 31       	stdsp	sp[0xc],r1
8000ee9c:	00 91       	mov	r1,r0
8000ee9e:	40 30       	lddsp	r0,sp[0xc]
8000eea0:	e2 11 f7 df 	andl	r1,0xf7df,COH
8000eea4:	00 01       	add	r1,r0
8000eea6:	e3 d1 b0 30 	bfexts	r1,r1,0x1,0x10
                     Source[(y2+3)*SrcWidth + x2 + 1]);
                 p = AVERAGE(p,r);
8000eeaa:	40 10       	lddsp	r0,sp[0x4]
8000eeac:	e0 09 19 00 	cp.h	r9,r0
8000eeb0:	c0 b0       	breq	8000eec6 <lodepng_decode_display+0x26a>
8000eeb2:	e2 19 f7 df 	andl	r9,0xf7df,COH
8000eeb6:	50 29       	stdsp	sp[0x8],r9
8000eeb8:	00 99       	mov	r9,r0
8000eeba:	40 20       	lddsp	r0,sp[0x8]
8000eebc:	e2 19 f7 df 	andl	r9,0xf7df,COH
8000eec0:	00 09       	add	r9,r0
8000eec2:	f3 d9 b0 30 	bfexts	r9,r9,0x1,0x10
                 q = AVERAGE(q,s);
8000eec6:	e2 0a 19 00 	cp.h	r10,r1
8000eeca:	fe 90 ff 77 	breq	8000edb8 <lodepng_decode_display+0x15c>
8000eece:	e2 1a f7 df 	andl	r10,0xf7df,COH
8000eed2:	50 1a       	stdsp	sp[0x4],r10
8000eed4:	02 9a       	mov	r10,r1
8000eed6:	40 11       	lddsp	r1,sp[0x4]
8000eed8:	e2 1a f7 df 	andl	r10,0xf7df,COH
8000eedc:	02 0a       	add	r10,r1
8000eede:	f5 da b0 30 	bfexts	r10,r10,0x1,0x10
8000eee2:	c6 bb       	rjmp	8000edb8 <lodepng_decode_display+0x15c>
 
     TgtWidth = SrcWidth / denom;
     TgtHeight = SrcHeight / denom;
 
     // Box filter method
     for (y = 0; y < TgtHeight; y++) {
8000eee4:	41 86       	lddsp	r6,sp[0x60]
8000eee6:	41 91       	lddsp	r1,sp[0x64]
8000eee8:	2f f6       	sub	r6,-1
8000eeea:	41 b0       	lddsp	r0,sp[0x6c]
8000eeec:	00 01       	add	r1,r0
8000eeee:	41 49       	lddsp	r9,sp[0x50]
8000eef0:	51 86       	stdsp	sp[0x60],r6
8000eef2:	41 1a       	lddsp	r10,sp[0x44]
8000eef4:	41 56       	lddsp	r6,sp[0x54]
8000eef6:	12 0a       	add	r10,r9
8000eef8:	12 06       	add	r6,r9
8000eefa:	41 70       	lddsp	r0,sp[0x5c]
8000eefc:	51 91       	stdsp	sp[0x64],r1
8000eefe:	12 00       	add	r0,r9
8000ef00:	41 61       	lddsp	r1,sp[0x58]
8000ef02:	51 1a       	stdsp	sp[0x44],r10
8000ef04:	12 01       	add	r1,r9
8000ef06:	51 56       	stdsp	sp[0x54],r6
8000ef08:	51 61       	stdsp	sp[0x58],r1
8000ef0a:	51 70       	stdsp	sp[0x5c],r0
8000ef0c:	41 8a       	lddsp	r10,sp[0x60]
8000ef0e:	41 c9       	lddsp	r9,sp[0x70]
8000ef10:	12 3a       	cp.w	r10,r9
8000ef12:	fe 91 ff 17 	brne	8000ed40 <lodepng_decode_display+0xe4>
     //call scaling if required -supports only 1/2,1/4,1/8
     if(scale>1) {
         scale_by_denom(temp16,temp16,320,240,scale);
     }
 
     et024006_DrawFilledRect(0,0,ET024006_WIDTH,ET024006_HEIGHT,0x2458 );
8000ef16:	e0 68 24 58 	mov	r8,9304
8000ef1a:	e0 69 00 f0 	mov	r9,240
8000ef1e:	e0 6a 01 40 	mov	r10,320
8000ef22:	30 0b       	mov	r11,0
8000ef24:	16 9c       	mov	r12,r11
8000ef26:	fe b0 d5 93 	rcall	80009a4c <et024006_DrawFilledRect>
 
     usart_write_line(&AVR32_USART0,"sending to display\r\n");
8000ef2a:	4f 6b       	lddpc	r11,8000f100 <lodepng_decode_display+0x4a4>
8000ef2c:	fe 7c 14 00 	mov	r12,-60416
8000ef30:	fe b0 e7 31 	rcall	8000bd92 <usart_write_line>
     et024006_PutPixmap( (uint16_t *)temp16, 320/scale, 0, 0, 0, 0, 320/scale,
8000ef34:	30 0e       	mov	lr,0
8000ef36:	41 06       	lddsp	r6,sp[0x40]
8000ef38:	e0 6b 01 40 	mov	r11,320
8000ef3c:	f6 06 0c 0a 	divs	r10,r11,r6
8000ef40:	41 ac       	lddsp	r12,sp[0x68]
8000ef42:	ef da c0 10 	bfextu	r7,r10,0x0,0x10
8000ef46:	1c 98       	mov	r8,lr
8000ef48:	0e 9b       	mov	r11,r7
8000ef4a:	1c 99       	mov	r9,lr
8000ef4c:	1c 9a       	mov	r10,lr
8000ef4e:	e0 65 00 f0 	mov	r5,240
8000ef52:	ea 06 0c 04 	divs	r4,r5,r6
8000ef56:	ed d4 c0 10 	bfextu	r6,r4,0x0,0x10
8000ef5a:	1a d6       	st.w	--sp,r6
8000ef5c:	1a d7       	st.w	--sp,r7
8000ef5e:	1a de       	st.w	--sp,lr
8000ef60:	fe b0 d5 c7 	rcall	80009aee <et024006_PutPixmap>
         240/scale );
     free(image);
8000ef64:	45 6c       	lddsp	r12,sp[0x158]
8000ef66:	e0 a0 07 c3 	rcall	8000feec <free>
 
     // cleanup decoder
     LodePNG_Decoder_cleanup(&decoder);
8000ef6a:	fa cc ff 80 	sub	r12,sp,-128
8000ef6e:	fe b0 a6 ab 	rcall	80003cc4 <LodePNG_Decoder_cleanup>
     return;
8000ef72:	2f dd       	sub	sp,-12
 }
8000ef74:	2a cd       	sub	sp,-336
8000ef76:	d8 32       	popm	r0-r7,pc
                     Source[(y2+3)*SrcWidth + x2 + 1]);
                 p = AVERAGE(p,r);
                 q = AVERAGE(q,s);
             }
             else if(denom==8) {
                 r = AVERAGE(Source[(y2+2)*SrcWidth + x2],
8000ef78:	40 40       	lddsp	r0,sp[0x10]
8000ef7a:	40 51       	lddsp	r1,sp[0x14]
8000ef7c:	82 01       	ld.sh	r1,r1[0x0]
8000ef7e:	50 11       	stdsp	sp[0x4],r1
8000ef80:	80 01       	ld.sh	r1,r0[0x0]
8000ef82:	40 10       	lddsp	r0,sp[0x4]
8000ef84:	e2 00 19 00 	cp.h	r0,r1
8000ef88:	c0 90       	breq	8000ef9a <lodepng_decode_display+0x33e>
8000ef8a:	e2 10 f7 df 	andl	r0,0xf7df,COH
8000ef8e:	e2 11 f7 df 	andl	r1,0xf7df,COH
8000ef92:	00 01       	add	r1,r0
8000ef94:	e3 d1 b0 30 	bfexts	r1,r1,0x1,0x10
8000ef98:	50 11       	stdsp	sp[0x4],r1
                     Source[(y2+2)*SrcWidth + x2 + 1]);
                 s = AVERAGE(Source[(y2+3)*SrcWidth + x2],
8000ef9a:	40 70       	lddsp	r0,sp[0x1c]
8000ef9c:	80 01       	ld.sh	r1,r0[0x0]
8000ef9e:	40 60       	lddsp	r0,sp[0x18]
8000efa0:	80 00       	ld.sh	r0,r0[0x0]
8000efa2:	50 20       	stdsp	sp[0x8],r0
8000efa4:	e0 01 19 00 	cp.h	r1,r0
8000efa8:	c0 b0       	breq	8000efbe <lodepng_decode_display+0x362>
8000efaa:	e2 11 f7 df 	andl	r1,0xf7df,COH
8000efae:	50 31       	stdsp	sp[0xc],r1
8000efb0:	00 91       	mov	r1,r0
8000efb2:	40 30       	lddsp	r0,sp[0xc]
8000efb4:	e2 11 f7 df 	andl	r1,0xf7df,COH
8000efb8:	00 01       	add	r1,r0
8000efba:	e3 d1 b0 30 	bfexts	r1,r1,0x1,0x10
                     Source[(y2+3)*SrcWidth + x2 + 1]);
                 p = AVERAGE(p,r);
8000efbe:	40 10       	lddsp	r0,sp[0x4]
8000efc0:	e0 09 19 00 	cp.h	r9,r0
8000efc4:	c0 b0       	breq	8000efda <lodepng_decode_display+0x37e>
8000efc6:	e2 19 f7 df 	andl	r9,0xf7df,COH
8000efca:	50 29       	stdsp	sp[0x8],r9
8000efcc:	00 99       	mov	r9,r0
8000efce:	40 20       	lddsp	r0,sp[0x8]
8000efd0:	e2 19 f7 df 	andl	r9,0xf7df,COH
8000efd4:	00 09       	add	r9,r0
8000efd6:	f3 d9 b0 30 	bfexts	r9,r9,0x1,0x10
                 q = AVERAGE(q,s);
8000efda:	e2 0a 19 00 	cp.h	r10,r1
8000efde:	c0 b0       	breq	8000eff4 <lodepng_decode_display+0x398>
8000efe0:	e2 1a f7 df 	andl	r10,0xf7df,COH
8000efe4:	50 1a       	stdsp	sp[0x4],r10
8000efe6:	02 9a       	mov	r10,r1
8000efe8:	40 11       	lddsp	r1,sp[0x4]
8000efea:	e2 1a f7 df 	andl	r10,0xf7df,COH
8000efee:	02 0a       	add	r10,r1
8000eff0:	f5 da b0 30 	bfexts	r10,r10,0x1,0x10
                 p1 = AVERAGE(Source[(y2+4)*SrcWidth + x2],
8000eff4:	40 90       	lddsp	r0,sp[0x24]
8000eff6:	80 00       	ld.sh	r0,r0[0x0]
8000eff8:	50 20       	stdsp	sp[0x8],r0
8000effa:	40 80       	lddsp	r0,sp[0x20]
8000effc:	80 01       	ld.sh	r1,r0[0x0]
8000effe:	40 20       	lddsp	r0,sp[0x8]
8000f000:	e2 00 19 00 	cp.h	r0,r1
8000f004:	c0 90       	breq	8000f016 <lodepng_decode_display+0x3ba>
8000f006:	e2 10 f7 df 	andl	r0,0xf7df,COH
8000f00a:	e2 11 f7 df 	andl	r1,0xf7df,COH
8000f00e:	00 01       	add	r1,r0
8000f010:	e3 d1 b0 30 	bfexts	r1,r1,0x1,0x10
8000f014:	50 21       	stdsp	sp[0x8],r1
                     Source[(y2+4)*SrcWidth + x2 + 1]);
                 q1 = AVERAGE(Source[(y2+5)*SrcWidth + x2],
8000f016:	40 a0       	lddsp	r0,sp[0x28]
8000f018:	40 b1       	lddsp	r1,sp[0x2c]
8000f01a:	82 01       	ld.sh	r1,r1[0x0]
8000f01c:	50 11       	stdsp	sp[0x4],r1
8000f01e:	80 01       	ld.sh	r1,r0[0x0]
8000f020:	40 10       	lddsp	r0,sp[0x4]
8000f022:	e2 00 19 00 	cp.h	r0,r1
8000f026:	c0 90       	breq	8000f038 <lodepng_decode_display+0x3dc>
8000f028:	e2 10 f7 df 	andl	r0,0xf7df,COH
8000f02c:	e2 11 f7 df 	andl	r1,0xf7df,COH
8000f030:	00 01       	add	r1,r0
8000f032:	e3 d1 b0 30 	bfexts	r1,r1,0x1,0x10
8000f036:	50 11       	stdsp	sp[0x4],r1
                     Source[(y2+5)*SrcWidth + x2 + 1]);
                 r1 = AVERAGE(Source[(y2+6)*SrcWidth + x2],
8000f038:	40 c0       	lddsp	r0,sp[0x30]
8000f03a:	40 d1       	lddsp	r1,sp[0x34]
8000f03c:	82 01       	ld.sh	r1,r1[0x0]
8000f03e:	51 31       	stdsp	sp[0x4c],r1
8000f040:	80 01       	ld.sh	r1,r0[0x0]
8000f042:	41 30       	lddsp	r0,sp[0x4c]
8000f044:	e2 00 19 00 	cp.h	r0,r1
8000f048:	c0 90       	breq	8000f05a <lodepng_decode_display+0x3fe>
8000f04a:	e2 10 f7 df 	andl	r0,0xf7df,COH
8000f04e:	e2 11 f7 df 	andl	r1,0xf7df,COH
8000f052:	00 01       	add	r1,r0
8000f054:	e3 d1 b0 30 	bfexts	r1,r1,0x1,0x10
8000f058:	51 31       	stdsp	sp[0x4c],r1
                     Source[(y2+6)*SrcWidth + x2 + 1]);
                 s1 = AVERAGE(Source[(y2+7)*SrcWidth + x2],
8000f05a:	40 e0       	lddsp	r0,sp[0x38]
8000f05c:	40 01       	lddsp	r1,sp[0x0]
8000f05e:	82 01       	ld.sh	r1,r1[0x0]
8000f060:	50 31       	stdsp	sp[0xc],r1
8000f062:	80 01       	ld.sh	r1,r0[0x0]
8000f064:	40 30       	lddsp	r0,sp[0xc]
8000f066:	e2 00 19 00 	cp.h	r0,r1
8000f06a:	c0 90       	breq	8000f07c <lodepng_decode_display+0x420>
8000f06c:	e2 10 f7 df 	andl	r0,0xf7df,COH
8000f070:	e2 11 f7 df 	andl	r1,0xf7df,COH
8000f074:	00 01       	add	r1,r0
8000f076:	e3 d1 b0 30 	bfexts	r1,r1,0x1,0x10
8000f07a:	50 31       	stdsp	sp[0xc],r1
                     Source[(y2+7)*SrcWidth + x2 + 1]);
                 p1 = AVERAGE(p1,r1);
8000f07c:	40 21       	lddsp	r1,sp[0x8]
8000f07e:	41 30       	lddsp	r0,sp[0x4c]
8000f080:	e0 01 19 00 	cp.h	r1,r0
8000f084:	c0 90       	breq	8000f096 <lodepng_decode_display+0x43a>
8000f086:	e2 11 f7 df 	andl	r1,0xf7df,COH
8000f08a:	e2 10 f7 df 	andl	r0,0xf7df,COH
8000f08e:	02 00       	add	r0,r1
8000f090:	e1 d0 b0 30 	bfexts	r0,r0,0x1,0x10
8000f094:	50 20       	stdsp	sp[0x8],r0
                 q1 = AVERAGE(q1,s1);
8000f096:	40 11       	lddsp	r1,sp[0x4]
8000f098:	40 30       	lddsp	r0,sp[0xc]
8000f09a:	e0 01 19 00 	cp.h	r1,r0
8000f09e:	c0 90       	breq	8000f0b0 <lodepng_decode_display+0x454>
8000f0a0:	e2 11 f7 df 	andl	r1,0xf7df,COH
8000f0a4:	e2 10 f7 df 	andl	r0,0xf7df,COH
8000f0a8:	02 00       	add	r0,r1
8000f0aa:	e1 d0 b0 30 	bfexts	r0,r0,0x1,0x10
8000f0ae:	50 10       	stdsp	sp[0x4],r0
                 p =  AVERAGE(p,p1);
8000f0b0:	40 21       	lddsp	r1,sp[0x8]
8000f0b2:	e2 09 19 00 	cp.h	r9,r1
8000f0b6:	c0 a0       	breq	8000f0ca <lodepng_decode_display+0x46e>
8000f0b8:	12 90       	mov	r0,r9
8000f0ba:	02 99       	mov	r9,r1
8000f0bc:	e2 10 f7 df 	andl	r0,0xf7df,COH
8000f0c0:	e2 19 f7 df 	andl	r9,0xf7df,COH
8000f0c4:	00 09       	add	r9,r0
8000f0c6:	f3 d9 b0 30 	bfexts	r9,r9,0x1,0x10
                 q = AVERAGE(q,q1);
8000f0ca:	40 10       	lddsp	r0,sp[0x4]
8000f0cc:	e0 0a 19 00 	cp.h	r10,r0
8000f0d0:	fe 90 fe 74 	breq	8000edb8 <lodepng_decode_display+0x15c>
8000f0d4:	14 90       	mov	r0,r10
8000f0d6:	40 1a       	lddsp	r10,sp[0x4]
8000f0d8:	e2 10 f7 df 	andl	r0,0xf7df,COH
8000f0dc:	e2 1a f7 df 	andl	r10,0xf7df,COH
8000f0e0:	00 0a       	add	r10,r0
8000f0e2:	f5 da b0 30 	bfexts	r10,r10,0x1,0x10
8000f0e6:	fe 9f fe 69 	bral	8000edb8 <lodepng_decode_display+0x15c>
 
     /* if there's an error, display it, otherwise display
      * information about the image
      */
     if(decoder.error) {
         usart_write_line(&AVR32_USART0,"error: Decoding\r\n");
8000f0ea:	48 7b       	lddpc	r11,8000f104 <lodepng_decode_display+0x4a8>
8000f0ec:	fe 7c 14 00 	mov	r12,-60416
8000f0f0:	fe b0 e6 51 	rcall	8000bd92 <usart_write_line>
     free(image);
 
     // cleanup decoder
     LodePNG_Decoder_cleanup(&decoder);
     return;
 }
8000f0f4:	2a cd       	sub	sp,-336
8000f0f6:	d8 32       	popm	r0-r7,pc
8000f0f8:	80 01       	ld.sh	r1,r0[0x0]
8000f0fa:	83 0c       	st.w	r1[0x0],r12
8000f0fc:	80 01       	ld.sh	r1,r0[0x0]
8000f0fe:	83 38       	st.w	r1[0xc],r8
8000f100:	80 01       	ld.sh	r1,r0[0x0]
8000f102:	83 50       	st.w	r1[0x14],r0
8000f104:	80 01       	ld.sh	r1,r0[0x0]
8000f106:	83 24       	st.w	r1[0x8],r4

8000f108 <main>:
8000f108:	d4 31       	pushm	r0-r7,lr
8000f10a:	21 0d       	sub	sp,64
8000f10c:	30 3a       	mov	r10,3
8000f10e:	e0 6b 1b 00 	mov	r11,6912
8000f112:	ea 1b 00 b7 	orh	r11,0xb7
8000f116:	fe 7c 0c 00 	mov	r12,-62464
8000f11a:	fe b0 e4 8a 	rcall	8000ba2e <pm_switch_to_osc0>
8000f11e:	31 09       	mov	r9,16
8000f120:	30 08       	mov	r8,0
8000f122:	1a d9       	st.w	--sp,r9
8000f124:	10 9b       	mov	r11,r8
8000f126:	30 19       	mov	r9,1

	
	// Set PLL0 (fed from OSC0 = 12 MHz) to 132 MHz
	// We use OSC1 since we need a correct master clock for the SSC module to generate
	// the correct sample rate
	pm_pll_setup(&AVR32_PM, 0,  // pll.
8000f128:	30 aa       	mov	r10,10
8000f12a:	fe 7c 0c 00 	mov	r12,-62464
8000f12e:	fe b0 e4 52 	rcall	8000b9d2 <pm_pll_setup>
	0,   // osc.
	16); // lockcount.

	// Set PLL operating range and divider (fpll = fvco/2)
	// -> PLL0 output = 66 MHz
	pm_pll_set_option(&AVR32_PM, 0, // pll.
8000f132:	30 08       	mov	r8,0
8000f134:	30 19       	mov	r9,1
8000f136:	10 9b       	mov	r11,r8
8000f138:	12 9a       	mov	r10,r9
8000f13a:	fe 7c 0c 00 	mov	r12,-62464
8000f13e:	fe b0 e4 5b 	rcall	8000b9f4 <pm_pll_set_option>
	1,  // pll_freq.
	1,  // pll_div2.
	0); // pll_wbwdisable.

	// start PLL0 and wait for the lock
	pm_pll_enable(&AVR32_PM, 0);
8000f142:	30 0b       	mov	r11,0
8000f144:	fe 7c 0c 00 	mov	r12,-62464
8000f148:	fe b0 e4 62 	rcall	8000ba0c <pm_pll_enable>
	pm_wait_for_pll0_locked(&AVR32_PM);
8000f14c:	fe 7c 0c 00 	mov	r12,-62464
8000f150:	fe b0 e4 65 	rcall	8000ba1a <pm_wait_for_pll0_locked>
	// Set all peripheral clocks torun at master clock rate
	pm_cksel(&AVR32_PM,
8000f154:	fe 7c 0c 00 	mov	r12,-62464
8000f158:	30 07       	mov	r7,0
8000f15a:	1a d7       	st.w	--sp,r7
8000f15c:	0e 99       	mov	r9,r7
8000f15e:	1a d7       	st.w	--sp,r7
8000f160:	0e 9a       	mov	r10,r7
8000f162:	0e 98       	mov	r8,r7
8000f164:	0e 9b       	mov	r11,r7
8000f166:	fe b0 e4 14 	rcall	8000b98e <pm_cksel>
	0,   // pbbsel.
	0,   // hsbdiv.
	0);  // hsbsel.

	// Set one waitstate for the flash
	flashc_set_wait_state(1);
8000f16a:	30 1c       	mov	r12,1
8000f16c:	fe b0 e2 88 	rcall	8000b67c <flashc_set_wait_state>

	// Switch to PLL0 as the master clock
	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCCTRL_MCSEL_PLL0);
8000f170:	30 2b       	mov	r11,2
8000f172:	fe 7c 0c 00 	mov	r12,-62464
8000f176:	fe b0 e4 57 	rcall	8000ba24 <pm_switch_to_clock>
  };


*/

  gpio_enable_gpio_pin(LED0_GPIO);
8000f17a:	33 bc       	mov	r12,59
8000f17c:	fe b0 e2 af 	rcall	8000b6da <gpio_enable_gpio_pin>
  gpio_enable_gpio_pin(LED1_GPIO);
8000f180:	33 cc       	mov	r12,60
8000f182:	fe b0 e2 ac 	rcall	8000b6da <gpio_enable_gpio_pin>
  gpio_enable_gpio_pin(LED2_GPIO);
8000f186:	30 5c       	mov	r12,5
8000f188:	fe b0 e2 a9 	rcall	8000b6da <gpio_enable_gpio_pin>
  gpio_enable_gpio_pin(LED3_GPIO);
8000f18c:	30 6c       	mov	r12,6
8000f18e:	fe b0 e2 a6 	rcall	8000b6da <gpio_enable_gpio_pin>

 // et024006_Init( FOSC0, FOSC0 );
  et024006_Init( FREQ, FREQ );
8000f192:	e0 6b 14 80 	mov	r11,5248
8000f196:	ea 1b 03 ef 	orh	r11,0x3ef
8000f19a:	16 9c       	mov	r12,r11
8000f19c:	fe b0 d0 ae 	rcall	800092f8 <et024006_Init>
   * Chosen MCK_DIV_2
   * CPRD = 12MHz / (60kHz * 2) = 100
   *
   * The duty cycle is 100% (CPRD = CDTY)
   * */
  pwm_init(&opt);
8000f1a0:	fa c6 ff c4 	sub	r6,sp,-60
  pwm_opt_t opt = {
    .diva = 0,
    .divb = 0,
    .prea = 0,
    .preb = 0
  };
8000f1a4:	50 f7       	stdsp	sp[0x3c],r7
8000f1a6:	51 07       	stdsp	sp[0x40],r7
8000f1a8:	51 17       	stdsp	sp[0x44],r7
8000f1aa:	51 27       	stdsp	sp[0x48],r7
   * Chosen MCK_DIV_2
   * CPRD = 12MHz / (60kHz * 2) = 100
   *
   * The duty cycle is 100% (CPRD = CDTY)
   * */
  pwm_init(&opt);
8000f1ac:	0c 9c       	mov	r12,r6
8000f1ae:	fe b0 e4 9e 	rcall	8000baea <pwm_init>
  pwm_channel6.CMR.calg = PWM_MODE_LEFT_ALIGNED;
8000f1b2:	31 05       	mov	r5,16
8000f1b4:	30 14       	mov	r4,1
  pwm_channel6.CMR.cpol = PWM_POLARITY_HIGH; //PWM_POLARITY_LOW;//PWM_POLARITY_HIGH;
8000f1b6:	6a 08       	ld.w	r8,r5[0x0]
   * CPRD = 12MHz / (60kHz * 2) = 100
   *
   * The duty cycle is 100% (CPRD = CDTY)
   * */
  pwm_init(&opt);
  pwm_channel6.CMR.calg = PWM_MODE_LEFT_ALIGNED;
8000f1b8:	e0 18 f8 ff 	andl	r8,0xf8ff
  pwm_channel6.CMR.cpol = PWM_POLARITY_HIGH; //PWM_POLARITY_LOW;//PWM_POLARITY_HIGH;
  pwm_channel6.CMR.cpd = PWM_UPDATE_DUTY;
8000f1bc:	a9 b8       	sbr	r8,0x9
  pwm_channel6.CMR.cpre = AVR32_PWM_CMR_CPRE_MCK_DIV_2;
8000f1be:	f1 d4 d0 04 	bfins	r8,r4,0x0,0x4
8000f1c2:	0a 9b       	mov	r11,r5

  pwm_channel_init(6, &pwm_channel6);
8000f1c4:	8b 08       	st.w	r5[0x0],r8
   * */
  pwm_init(&opt);
  pwm_channel6.CMR.calg = PWM_MODE_LEFT_ALIGNED;
  pwm_channel6.CMR.cpol = PWM_POLARITY_HIGH; //PWM_POLARITY_LOW;//PWM_POLARITY_HIGH;
  pwm_channel6.CMR.cpd = PWM_UPDATE_DUTY;
  pwm_channel6.CMR.cpre = AVR32_PWM_CMR_CPRE_MCK_DIV_2;
8000f1c6:	30 6c       	mov	r12,6

  pwm_channel_init(6, &pwm_channel6);
8000f1c8:	fe b0 e4 60 	rcall	8000ba88 <pwm_channel_init>
8000f1cc:	34 0c       	mov	r12,64
  pwm_start_channels(AVR32_PWM_ENA_CHID6_MASK);
8000f1ce:	fe b0 e4 75 	rcall	8000bab8 <pwm_start_channels>
8000f1d2:	0e 98       	mov	r8,r7
#elif BOARD == EVK1104 || BOARD == UC3C_EK
  gpio_set_gpio_pin(ET024006DHU_BL_PIN);
#endif

  // Clear the display i.e. make it black
  et024006_DrawFilledRect(0 , 0, ET024006_WIDTH, ET024006_HEIGHT, BLACK );
8000f1d4:	e0 69 00 f0 	mov	r9,240
8000f1d8:	e0 6a 01 40 	mov	r10,320
8000f1dc:	0e 9b       	mov	r11,r7
8000f1de:	0e 9c       	mov	r12,r7
8000f1e0:	fe b0 d4 36 	rcall	80009a4c <et024006_DrawFilledRect>
8000f1e4:	d3 03       	ssrf	0x10
  
  //Interrupciones
  
  Disable_global_interrupt();
8000f1e6:	fe b0 e3 2b 	rcall	8000b83c <INTC_init_interrupts>

  INTC_init_interrupts();
8000f1ea:	fe f8 04 8e 	ld.w	r8,pc[1166]

		/* Next memory address */
		.r_addr = NULL,
		/* Next transfer counter */
		.r_size = 0,
	};
8000f1ee:	50 37       	stdsp	sp[0xc],r7
void init_Usart_DMA_RX(void){
	
	const gpio_map_t usart_gpio_map = {
		{EXAMPLE_USART_RX_PIN, EXAMPLE_USART_RX_FUNCTION},
		{EXAMPLE_USART_TX_PIN, EXAMPLE_USART_TX_FUNCTION}
	};
8000f1f0:	50 47       	stdsp	sp[0x10],r7
8000f1f2:	50 54       	stdsp	sp[0x14],r4
8000f1f4:	50 67       	stdsp	sp[0x18],r7
8000f1f6:	f0 ea 00 10 	ld.d	r10,r8[16]

		/* Next memory address */
		.r_addr = NULL,
		/* Next transfer counter */
		.r_size = 0,
	};
8000f1fa:	fa c3 ff dc 	sub	r3,sp,-36
8000f1fe:	fe f9 04 7e 	ld.w	r9,pc[1150]
		.baudrate     = 57600,
		.charlength   = 8,
		.paritytype   = USART_NO_PARITY,
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE,
	};
8000f202:	e6 eb 00 10 	st.d	r3[16],r10

		/* Next memory address */
		.r_addr = NULL,
		/* Next transfer counter */
		.r_size = 0,
	};
8000f206:	72 2a       	ld.w	r10,r9[0x8]
		.baudrate     = 57600,
		.charlength   = 8,
		.paritytype   = USART_NO_PARITY,
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE,
	};
8000f208:	8d 2a       	st.w	r6[0x8],r10
8000f20a:	f2 ea 00 00 	ld.d	r10,r9[0]
8000f20e:	ec eb 00 00 	st.d	r6[0],r10
8000f212:	f0 ea 00 00 	ld.d	r10,r8[0]

		/* Next memory address */
		.r_addr = NULL,
		/* Next transfer counter */
		.r_size = 0,
	};
8000f216:	e6 eb 00 00 	st.d	r3[0],r10
8000f21a:	f0 e8 00 08 	ld.d	r8,r8[8]
8000f21e:	fa c2 ff f4 	sub	r2,sp,-12

	/* Assign GPIO pins to USART. */
	gpio_enable_module(usart_gpio_map,
8000f222:	e6 e9 00 08 	st.d	r3[8],r8

		/* Next memory address */
		.r_addr = NULL,
		/* Next transfer counter */
		.r_size = 0,
	};
8000f226:	30 2b       	mov	r11,2

	/* Assign GPIO pins to USART. */
	gpio_enable_module(usart_gpio_map,
8000f228:	04 9c       	mov	r12,r2
8000f22a:	fe b0 e2 88 	rcall	8000b73a <gpio_enable_module>
8000f22e:	e0 6a 14 80 	mov	r10,5248
			sizeof(usart_gpio_map) / sizeof(usart_gpio_map[0]));

	/* Initialize the USART in RS232 mode. */
	//usart_init_rs232(EXAMPLE_USART, &usart_options,FOSC0);
	usart_init_rs232(EXAMPLE_USART, &usart_options,FREQ);
8000f232:	ea 1a 03 ef 	orh	r10,0x3ef
8000f236:	0c 9b       	mov	r11,r6
8000f238:	fe 7c 14 00 	mov	r12,-60416
8000f23c:	fe b0 e5 c2 	rcall	8000bdc0 <usart_init_rs232>
8000f240:	06 9b       	mov	r11,r3

	//usart_write_line(EXAMPLE_USART, "PDCA Example.\r\n");

	/* Initialize the PDCA channel with the requested options. */
	pdca_init_channel(PDCA_CHANNEL_USART_EXAMPLE, &PDCA_OPTIONS);
8000f242:	30 2c       	mov	r12,2
8000f244:	fe b0 e3 62 	rcall	8000b908 <pdca_init_channel>
8000f248:	30 3a       	mov	r10,3
	
	INTC_register_interrupt(&pdca_int_handler_USART, AVR32_PDCA_IRQ_2,
8000f24a:	36 2b       	mov	r11,98
8000f24c:	fe cc 06 c0 	sub	r12,pc,1728
8000f250:	fe b0 e2 b2 	rcall	8000b7b4 <INTC_register_interrupt>
8000f254:	fe f9 04 2c 	ld.w	r9,pc[1068]
    .size = 512,                              // transfer counter: here the size of the string
    .r_addr = NULL,                           // next memory address after 1st transfer complete
    .r_size = 0,                              // next transfer counter not used here
    .pid = AVR32_PDCA_PID_SPI0_RX,        // select peripheral ID - data are on reception from SPI1 RX line
    .transfer_size = 8 // select size of the transfer: 8,16,32 bits
  };
8000f258:	f2 e0 00 10 	ld.d	r0,r9[16]
8000f25c:	fe f8 04 28 	ld.w	r8,pc[1064]
    .size = 512,                              // transfer counter: here the size of the string
    .r_addr = NULL,                           // next memory address after 1st transfer complete
    .r_size = 0,                              // next transfer counter not used here
    .pid = AVR32_PDCA_PID_SPI0_TX,        // select peripheral ID - data are on reception from SPI1 RX line
    .transfer_size = 8 // select size of the transfer: 8,16,32 bits
  };
8000f260:	e6 e1 00 10 	st.d	r3[16],r0
    .size = 512,                              // transfer counter: here the size of the string
    .r_addr = NULL,                           // next memory address after 1st transfer complete
    .r_size = 0,                              // next transfer counter not used here
    .pid = AVR32_PDCA_PID_SPI0_RX,        // select peripheral ID - data are on reception from SPI1 RX line
    .transfer_size = 8 // select size of the transfer: 8,16,32 bits
  };
8000f264:	f0 e0 00 10 	ld.d	r0,r8[16]
    .size = 512,                              // transfer counter: here the size of the string
    .r_addr = NULL,                           // next memory address after 1st transfer complete
    .r_size = 0,                              // next transfer counter not used here
    .pid = AVR32_PDCA_PID_SPI0_TX,        // select peripheral ID - data are on reception from SPI1 RX line
    .transfer_size = 8 // select size of the transfer: 8,16,32 bits
  };
8000f268:	e4 e1 00 10 	st.d	r2[16],r0
8000f26c:	f2 e0 00 00 	ld.d	r0,r9[0]
    .size = 512,                              // transfer counter: here the size of the string
    .r_addr = NULL,                           // next memory address after 1st transfer complete
    .r_size = 0,                              // next transfer counter not used here
    .pid = AVR32_PDCA_PID_SPI0_RX,        // select peripheral ID - data are on reception from SPI1 RX line
    .transfer_size = 8 // select size of the transfer: 8,16,32 bits
  };
8000f270:	e6 e1 00 00 	st.d	r3[0],r0
8000f274:	f2 e0 00 08 	ld.d	r0,r9[8]
8000f278:	e6 e1 00 08 	st.d	r3[8],r0
8000f27c:	f0 e0 00 00 	ld.d	r0,r8[0]
    .size = 512,                              // transfer counter: here the size of the string
    .r_addr = NULL,                           // next memory address after 1st transfer complete
    .r_size = 0,                              // next transfer counter not used here
    .pid = AVR32_PDCA_PID_SPI0_TX,        // select peripheral ID - data are on reception from SPI1 RX line
    .transfer_size = 8 // select size of the transfer: 8,16,32 bits
  };
8000f280:	e4 e1 00 00 	st.d	r2[0],r0
8000f284:	f0 e8 00 08 	ld.d	r8,r8[8]
8000f288:	04 9b       	mov	r11,r2

  // Init PDCA transmission channel
  pdca_init_channel(AVR32_PDCA_CHANNEL_SPI_TX, &pdca_options_SPI_TX);
8000f28a:	e4 e9 00 08 	st.d	r2[8],r8
    .size = 512,                              // transfer counter: here the size of the string
    .r_addr = NULL,                           // next memory address after 1st transfer complete
    .r_size = 0,                              // next transfer counter not used here
    .pid = AVR32_PDCA_PID_SPI0_TX,        // select peripheral ID - data are on reception from SPI1 RX line
    .transfer_size = 8 // select size of the transfer: 8,16,32 bits
  };
8000f28e:	08 9c       	mov	r12,r4

  // Init PDCA transmission channel
  pdca_init_channel(AVR32_PDCA_CHANNEL_SPI_TX, &pdca_options_SPI_TX);
8000f290:	fe b0 e3 3c 	rcall	8000b908 <pdca_init_channel>
8000f294:	06 9b       	mov	r11,r3

  // Init PDCA Reception channel
  pdca_init_channel(AVR32_PDCA_CHANNEL_SPI_RX, &pdca_options_SPI_RX);
8000f296:	0e 9c       	mov	r12,r7
8000f298:	fe b0 e3 38 	rcall	8000b908 <pdca_init_channel>
8000f29c:	08 9a       	mov	r10,r4

  //! \brief Enable pdca transfer interrupt when completed
  INTC_register_interrupt(&pdca_int_handler_SD, AVR32_PDCA_IRQ_0, AVR32_INTC_INT1);  // pdca_channel_spi1_RX = 0
8000f29e:	36 0b       	mov	r11,96
8000f2a0:	fe cc 07 60 	sub	r12,pc,1888
8000f2a4:	fe b0 e2 88 	rcall	8000b7b4 <INTC_register_interrupt>
8000f2a8:	e0 6c 14 80 	mov	r12,5248
 // INTC_register_interrupt(&tc_irq, AVR32_TC_IRQ0, AVR32_INTC_INT0);
  init_Usart_DMA_RX();
  init_SD_DMA_RX();
  
  //sdramc_init(FOSC0);
  sdramc_init(FREQ);
8000f2ac:	ea 1c 03 ef 	orh	r12,0x3ef
8000f2b0:	fe b0 96 ac 	rcall	80002008 <sdramc_init>
8000f2b4:	d5 03       	csrf	0x10
  Enable_global_interrupt();
8000f2b6:	2f dd       	sub	sp,-12
  // Start the timer/counter.
 // tc_start(tc, TC_CHANNEL);                    // And start the timer/counter.
  


  while(pwm_channel6.cdty < pwm_channel6.cprd)
8000f2b8:	0a 97       	mov	r7,r5
8000f2ba:	6a 18       	ld.w	r8,r5[0x4]
8000f2bc:	6a 29       	ld.w	r9,r5[0x8]
8000f2be:	12 38       	cp.w	r8,r9
8000f2c0:	c2 32       	brcc	8000f306 <main+0x1fe>
8000f2c2:	2f f8       	sub	r8,-1
  {
	  pwm_channel6.cdty++;
8000f2c4:	31 0b       	mov	r11,16
	  pwm_channel6.cupd = pwm_channel6.cdty;
	  //pwm_channel6.cdty--;
	  pwm_async_update_channel(AVR32_PWM_ENA_CHID6, &pwm_channel6);
8000f2c6:	8f 48       	st.w	r7[0x10],r8
8000f2c8:	8f 18       	st.w	r7[0x4],r8


  while(pwm_channel6.cdty < pwm_channel6.cprd)
  {
	  pwm_channel6.cdty++;
	  pwm_channel6.cupd = pwm_channel6.cdty;
8000f2ca:	30 6c       	mov	r12,6
  


  while(pwm_channel6.cdty < pwm_channel6.cprd)
  {
	  pwm_channel6.cdty++;
8000f2cc:	fe b0 e3 ff 	rcall	8000baca <pwm_async_update_channel>
	  pwm_channel6.cupd = pwm_channel6.cdty;
	  //pwm_channel6.cdty--;
	  pwm_async_update_channel(AVR32_PWM_ENA_CHID6, &pwm_channel6);
8000f2d0:	e1 b9 00 42 	mfsr	r9,0x108
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000f2d4:	e0 78 d4 c0 	mov	r8,120000
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000f2d8:	f2 08 00 0a 	add	r10,r9,r8
8000f2dc:	e1 b8 00 42 	mfsr	r8,0x108
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000f2e0:	14 39       	cp.w	r9,r10
8000f2e2:	e0 8b 00 0a 	brhi	8000f2f6 <main+0x1ee>
8000f2e6:	12 38       	cp.w	r8,r9
8000f2e8:	ce 93       	brcs	8000f2ba <main+0x1b2>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000f2ea:	14 38       	cp.w	r8,r10
8000f2ec:	fe 9b ff e7 	brhi	8000f2ba <main+0x1b2>
8000f2f0:	e1 b8 00 42 	mfsr	r8,0x108
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000f2f4:	cf 9b       	rjmp	8000f2e6 <main+0x1de>
8000f2f6:	10 39       	cp.w	r9,r8
8000f2f8:	e0 88 00 04 	brls	8000f300 <main+0x1f8>
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000f2fc:	10 3a       	cp.w	r10,r8
8000f2fe:	cd e3       	brcs	8000f2ba <main+0x1b2>
8000f300:	e1 b8 00 42 	mfsr	r8,0x108
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000f304:	cf 9b       	rjmp	8000f2f6 <main+0x1ee>
8000f306:	fe f8 03 82 	ld.w	r8,pc[898]
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
8000f30a:	f0 ea 00 08 	ld.d	r10,r8[8]
8000f30e:	ec eb 00 08 	st.d	r6[8],r10
8000f312:	f0 e8 00 00 	ld.d	r8,r8[0]
8000f316:	30 4b       	mov	r11,4
8000f318:	ec e9 00 00 	st.d	r6[0],r8
8000f31c:	fe fc 03 70 	ld.w	r12,pc[880]

	// Assign I/Os to SPI.
	gpio_enable_module(SD_MMC_SPI_GPIO_MAP,
8000f320:	fe b0 e2 0d 	rcall	8000b73a <gpio_enable_module>
8000f324:	0c 9b       	mov	r11,r6
8000f326:	fe 7c 24 00 	mov	r12,-56320
	sizeof(SD_MMC_SPI_GPIO_MAP) / sizeof(SD_MMC_SPI_GPIO_MAP[0]));

	// Initialize as master.
	spi_initMaster(SD_MMC_SPI, &spiOptions);
8000f32a:	fe b0 e4 14 	rcall	8000bb52 <spi_initMaster>
8000f32e:	30 09       	mov	r9,0
8000f330:	fe 7c 24 00 	mov	r12,-56320

	// Set SPI selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(SD_MMC_SPI, 0, 0, 0);
8000f334:	12 9a       	mov	r10,r9
8000f336:	12 9b       	mov	r11,r9
8000f338:	fe b0 e4 2c 	rcall	8000bb90 <spi_selectionMode>
8000f33c:	fe 7c 24 00 	mov	r12,-56320

	// Enable SPI module.
	spi_enable(SD_MMC_SPI);
8000f340:	fe b0 e4 ce 	rcall	8000bcdc <spi_enable>
8000f344:	ec e8 00 08 	ld.d	r8,r6[8]

	// Initialize SD/MMC driver with SPI clock (PBA).
	//sd_mmc_spi_init(spiOptions, PBA_HZ);
	sd_mmc_spi_init(spiOptions, FREQ);
8000f348:	20 4d       	sub	sp,16
8000f34a:	fa e9 00 08 	st.d	sp[8],r8
8000f34e:	ec e8 00 00 	ld.d	r8,r6[0]
8000f352:	e0 6c 14 80 	mov	r12,5248
8000f356:	ea 1c 03 ef 	orh	r12,0x3ef
8000f35a:	fa e9 00 00 	st.d	sp[0],r8
8000f35e:	fe b0 df 97 	rcall	8000b28c <sd_mmc_spi_init>
8000f362:	fe b0 f8 a3 	rcall	8000e4a8 <nav_reset>
  uint32_t sector =10;
  char disp[50];
  char clave[7];
  
  // Mount file system.
  nav_reset();
8000f366:	fe b0 f8 9d 	rcall	8000e4a0 <nav_drive_nb>

  // Display # of drives
  int drives = nav_drive_nb();
8000f36a:	fe fb 03 26 	ld.w	r11,pc[806]
  sprintf(mensaje,"%d",drives);
8000f36e:	1a dc       	st.w	--sp,r12
8000f370:	35 8c       	mov	r12,88
8000f372:	e0 a0 0a 0b 	rcall	80010788 <sprintf>
8000f376:	31 f8       	mov	r8,31
8000f378:	3f f7       	mov	r7,-1
8000f37a:	34 69       	mov	r9,70
  et024006_PrintString(mensaje,(const unsigned char*)&FONT8x8,50,70,BLUE,-1);
8000f37c:	1a d7       	st.w	--sp,r7
8000f37e:	33 2a       	mov	r10,50
8000f380:	fe fb 03 14 	ld.w	r11,pc[788]
8000f384:	35 8c       	mov	r12,88
8000f386:	fe b0 d2 2b 	rcall	800097dc <et024006_PrintString>
8000f38a:	30 0c       	mov	r12,0
8000f38c:	fe b0 f8 64 	rcall	8000e454 <nav_drive_set>
8000f390:	fe b0 f7 6c 	rcall	8000e268 <nav_drive_get>

  // Set Drive #
  nav_drive_set(0);
8000f394:	fe fb 02 fc 	ld.w	r11,pc[764]

  // Display Drive #
  drives = nav_drive_get();
8000f398:	1a dc       	st.w	--sp,r12
8000f39a:	35 8c       	mov	r12,88
  sprintf(mensaje,"%d",drives);
8000f39c:	e0 a0 09 f6 	rcall	80010788 <sprintf>
8000f3a0:	34 69       	mov	r9,70
8000f3a2:	1a d7       	st.w	--sp,r7
8000f3a4:	31 f8       	mov	r8,31
8000f3a6:	12 9a       	mov	r10,r9
8000f3a8:	fe fb 02 ec 	ld.w	r11,pc[748]
  et024006_PrintString(mensaje,(const unsigned char*)&FONT8x8,70,70,BLUE,-1);
8000f3ac:	35 8c       	mov	r12,88
8000f3ae:	fe b0 d2 17 	rcall	800097dc <et024006_PrintString>
8000f3b2:	2f 8d       	sub	sp,-32
8000f3b4:	fe b0 f8 3a 	rcall	8000e428 <nav_partition_mount>
8000f3b8:	cf e0       	breq	8000f3b4 <main+0x2ac>
8000f3ba:	fe b0 f7 51 	rcall	8000e25c <nav_checkdisk_disable>
8000f3be:	30 1c       	mov	r12,1

  while(!nav_partition_mount()); // If we're unable to mount the partition, halt here.
8000f3c0:	fe b0 f8 fa 	rcall	8000e5b4 <nav_filelist_nb>
8000f3c4:	5c 7c       	castu.h	r12

  nav_checkdisk_disable(); // Skip fat_check_device() for every read.
8000f3c6:	fe fb 02 ca 	ld.w	r11,pc[714]

  // Display # of files in drive
  drives = nav_filelist_nb(FS_FILE);
8000f3ca:	1a dc       	st.w	--sp,r12
8000f3cc:	35 8c       	mov	r12,88
8000f3ce:	e0 a0 09 dd 	rcall	80010788 <sprintf>
  sprintf(mensaje,"%d",drives);
8000f3d2:	31 f8       	mov	r8,31
8000f3d4:	3f f7       	mov	r7,-1
8000f3d6:	34 69       	mov	r9,70
8000f3d8:	1a d7       	st.w	--sp,r7
8000f3da:	35 aa       	mov	r10,90
8000f3dc:	fe fb 02 b8 	ld.w	r11,pc[696]
  et024006_PrintString(mensaje,(const unsigned char*)&FONT8x8,90,70,BLUE,-1);
8000f3e0:	35 8c       	mov	r12,88
8000f3e2:	fe b0 d1 fd 	rcall	800097dc <et024006_PrintString>
8000f3e6:	30 1c       	mov	r12,1
8000f3e8:	fe b0 f8 94 	rcall	8000e510 <nav_filelist_first>
8000f3ec:	2f ed       	sub	sp,-8
8000f3ee:	58 0c       	cp.w	r12,0
8000f3f0:	e0 81 01 31 	brne	8000f652 <main+0x54a>
8000f3f4:	fe fc 02 a4 	ld.w	r12,pc[676]

  // Display # of bytes in file
  if(nav_filelist_first(FS_FILE))
8000f3f8:	fe b0 f9 b8 	rcall	8000e768 <nav_filterlist_setfilter>
8000f3fc:	fe b0 f9 a6 	rcall	8000e748 <nav_filterlist_root>
8000f400:	30 0c       	mov	r12,0
8000f402:	fe b0 f9 bd 	rcall	8000e77c <nav_filterlist_goto>
  
 

 
   
   nav_filterlist_setfilter("png");
8000f406:	32 8b       	mov	r11,40
8000f408:	33 0c       	mov	r12,48
8000f40a:	fe b0 f9 49 	rcall	8000e69c <nav_file_getname>
   nav_filterlist_root();
8000f40e:	fe b0 f7 37 	rcall	8000e27c <nav_file_lgt>
    nav_filterlist_goto(0);
8000f412:	18 95       	mov	r5,r12
8000f414:	fe b0 f5 88 	rcall	8000df24 <file_bof>
    nav_file_getname((FS_STRING) str_buff, 40);
8000f418:	30 9c       	mov	r12,9
8000f41a:	fe b0 f6 27 	rcall	8000e068 <file_open>
8000f41e:	0a 9c       	mov	r12,r5
	uint32_t size1= nav_file_lgt(); //tamao de la imagen a cargar
8000f420:	e0 a0 05 6e 	rcall	8000fefc <malloc>
8000f424:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
	file_bof();
8000f428:	fe f7 02 74 	ld.w	r7,pc[628]
	file_open(FOPEN_MODE_R);
8000f42c:	8f 0c       	st.w	r7[0x0],r12
8000f42e:	fe b0 f6 65 	rcall	8000e0f8 <file_read_buf>
	imagen=(char*)malloc(size1);
8000f432:	30 1a       	mov	r10,1
8000f434:	0a 9b       	mov	r11,r5
	file_read_buf(imagen,size1);
8000f436:	6e 0c       	ld.w	r12,r7[0x0]
8000f438:	fe b0 fc 12 	rcall	8000ec5c <lodepng_decode_display>
    nav_filterlist_goto(0);
    nav_file_getname((FS_STRING) str_buff, 40);
	uint32_t size1= nav_file_lgt(); //tamao de la imagen a cargar
	file_bof();
	file_open(FOPEN_MODE_R);
	imagen=(char*)malloc(size1);
8000f43c:	fe b0 f5 c6 	rcall	8000dfc8 <file_close>
	file_read_buf(imagen,size1);
8000f440:	30 1c       	mov	r12,1
8000f442:	fe b0 f9 9d 	rcall	8000e77c <nav_filterlist_goto>
	lodepng_decode_display((unsigned char *)imagen,size1,1);//decodifca la PNG
8000f446:	32 8b       	mov	r11,40
8000f448:	33 0c       	mov	r12,48
8000f44a:	fe b0 f9 29 	rcall	8000e69c <nav_file_getname>
	file_close();
8000f44e:	fe b0 f7 17 	rcall	8000e27c <nav_file_lgt>
	
	nav_filterlist_goto(1);
8000f452:	18 93       	mov	r3,r12
8000f454:	fe b0 f5 68 	rcall	8000df24 <file_bof>
	nav_file_getname((FS_STRING) str_buff, 40);
8000f458:	30 9c       	mov	r12,9
8000f45a:	fe b0 f6 07 	rcall	8000e068 <file_open>
8000f45e:	06 9c       	mov	r12,r3
8000f460:	e0 a0 05 4e 	rcall	8000fefc <malloc>
	uint32_t size2= nav_file_lgt(); //tamao de la imagen a cargar
8000f464:	f7 d3 c0 10 	bfextu	r11,r3,0x0,0x10
	file_bof();
8000f468:	8f 1c       	st.w	r7[0x4],r12
8000f46a:	fe b0 f6 47 	rcall	8000e0f8 <file_read_buf>
	file_open(FOPEN_MODE_R);
8000f46e:	fe b0 f5 ad 	rcall	8000dfc8 <file_close>
	imagen1=(char*)malloc(size2);
8000f472:	fe fb 02 2e 	ld.w	r11,pc[558]
8000f476:	30 0c       	mov	r12,0
	file_read_buf(imagen1,size2);
8000f478:	fe b0 fa 20 	rcall	8000e8b8 <nav_filterlist_nb>
	nav_filterlist_goto(1);
	nav_file_getname((FS_STRING) str_buff, 40);
	uint32_t size2= nav_file_lgt(); //tamao de la imagen a cargar
	file_bof();
	file_open(FOPEN_MODE_R);
	imagen1=(char*)malloc(size2);
8000f47c:	e5 dc b0 10 	bfexts	r2,r12,0x0,0x10
	file_read_buf(imagen1,size2);
8000f480:	fe fc 02 20 	ld.w	r12,pc[544]
	file_close();
8000f484:	fe b0 f9 72 	rcall	8000e768 <nav_filterlist_setfilter>


  //Apply a filter for *.txt files and display number of files with this file extension
  int wave = nav_filterlist_nb(FL_FILE,"nes");
8000f488:	5c 72       	castu.h	r2
8000f48a:	fe b0 f9 5f 	rcall	8000e748 <nav_filterlist_root>
8000f48e:	58 02       	cp.w	r2,0
8000f490:	c4 b0       	breq	8000f526 <main+0x41e>
8000f492:	30 06       	mov	r6,0
  nav_filterlist_setfilter("nes");
8000f494:	3f f1       	mov	r1,-1
8000f496:	0c 94       	mov	r4,r6
8000f498:	c0 38       	rjmp	8000f49e <main+0x396>
8000f49a:	04 34       	cp.w	r4,r2
  int l=0;
 

  nav_filterlist_root();
//soccer , donkey , test , mario
  for(i=0;i<wave;i++)
8000f49c:	c4 52       	brcc	8000f526 <main+0x41e>
  
  //et024006_DrawFilledRect(0,0,320,240,BLACK);
  int l=0;
 

  nav_filterlist_root();
8000f49e:	08 9c       	mov	r12,r4
8000f4a0:	5c 7c       	castu.h	r12
//soccer , donkey , test , mario
  for(i=0;i<wave;i++)
8000f4a2:	fe b0 f9 6d 	rcall	8000e77c <nav_filterlist_goto>
8000f4a6:	2f f4       	sub	r4,-1
  {
	  nav_filterlist_goto(i);
	  if(nav_file_getname((FS_STRING) str_buff, 40))
	  et024006_PrintString(str_buff,(const unsigned char*)&FONT8x8,40,80+(l+=10),BLUE,-1);
8000f4a8:	32 8b       	mov	r11,40
  int l=0;
 

  nav_filterlist_root();
//soccer , donkey , test , mario
  for(i=0;i<wave;i++)
8000f4aa:	33 0c       	mov	r12,48
8000f4ac:	fe b0 f8 f8 	rcall	8000e69c <nav_file_getname>
8000f4b0:	cf 50       	breq	8000f49a <main+0x392>
  {
	  nav_filterlist_goto(i);
8000f4b2:	1a d1       	st.w	--sp,r1
8000f4b4:	2f 66       	sub	r6,-10
8000f4b6:	31 f8       	mov	r8,31
8000f4b8:	ec c9 ff b0 	sub	r9,r6,-80
	  if(nav_file_getname((FS_STRING) str_buff, 40))
8000f4bc:	32 8a       	mov	r10,40
8000f4be:	5c 79       	castu.h	r9
8000f4c0:	4f 5b       	lddpc	r11,8000f694 <main+0x58c>
8000f4c2:	33 0c       	mov	r12,48
8000f4c4:	fe b0 d1 8c 	rcall	800097dc <et024006_PrintString>
	  et024006_PrintString(str_buff,(const unsigned char*)&FONT8x8,40,80+(l+=10),BLUE,-1);
8000f4c8:	2f fd       	sub	sp,-4
8000f4ca:	ce 8b       	rjmp	8000f49a <main+0x392>
8000f4cc:	0c 98       	mov	r8,r6
8000f4ce:	e0 69 00 f0 	mov	r9,240
8000f4d2:	e0 6a 01 40 	mov	r10,320
8000f4d6:	0c 9b       	mov	r11,r6
8000f4d8:	0c 9c       	mov	r12,r6
8000f4da:	fe b0 d2 b9 	rcall	80009a4c <et024006_DrawFilledRect>
8000f4de:	0a 9b       	mov	r11,r5
8000f4e0:	30 2a       	mov	r10,2
8000f4e2:	6e 0c       	ld.w	r12,r7[0x0]
8000f4e4:	fe b0 fb bc 	rcall	8000ec5c <lodepng_decode_display>


void CLR_disp(void)
{
	// Clear the display i.e. make it black
	et024006_DrawFilledRect(0 , 0, ET024006_WIDTH, ET024006_HEIGHT, BLACK );
8000f4e8:	0c 9c       	mov	r12,r6
8000f4ea:	fe b0 f9 49 	rcall	8000e77c <nav_filterlist_goto>
8000f4ee:	32 8b       	mov	r11,40
8000f4f0:	33 0c       	mov	r12,48
8000f4f2:	fe b0 f8 d5 	rcall	8000e69c <nav_file_getname>
8000f4f6:	c0 c0       	breq	8000f50e <main+0x406>
  {
	  
	  if (debounce2(QT1081_TOUCH_SENSOR_UP))
	  {
		  CLR_disp();
		  lodepng_decode_display((unsigned char *)imagen,size1,2);//decodifca la PNG
8000f4f8:	3f f8       	mov	r8,-1
8000f4fa:	35 09       	mov	r9,80
8000f4fc:	1a d8       	st.w	--sp,r8
8000f4fe:	32 8a       	mov	r10,40
8000f500:	e0 68 f8 00 	mov	r8,63488
		  nav_filterlist_goto(0);
8000f504:	4e 4b       	lddpc	r11,8000f694 <main+0x58c>
8000f506:	33 0c       	mov	r12,48
		  if(nav_file_getname((FS_STRING) str_buff, 40))
8000f508:	fe b0 d1 6a 	rcall	800097dc <et024006_PrintString>
8000f50c:	2f fd       	sub	sp,-4
8000f50e:	33 7c       	mov	r12,55
8000f510:	fe b0 fb 54 	rcall	8000ebb8 <debounce2>
		  et024006_PrintString(str_buff,(const unsigned char*)&FONT8x8,40,80,RED,-1);
8000f514:	c1 61       	brne	8000f540 <main+0x438>
8000f516:	33 8c       	mov	r12,56
8000f518:	fe b0 fb 50 	rcall	8000ebb8 <debounce2>
8000f51c:	c3 41       	brne	8000f584 <main+0x47c>
8000f51e:	33 9c       	mov	r12,57
8000f520:	fe b0 fb 4c 	rcall	8000ebb8 <debounce2>
8000f524:	c5 21       	brne	8000f5c8 <main+0x4c0>
8000f526:	33 ac       	mov	r12,58
8000f528:	fe b0 e0 e4 	rcall	8000b6f0 <gpio_get_pin_value>
8000f52c:	18 96       	mov	r6,r12
	  }
	  
	   if (debounce2(QT1081_TOUCH_SENSOR_DOWN))
8000f52e:	c6 f1       	brne	8000f60c <main+0x504>
8000f530:	33 6c       	mov	r12,54
8000f532:	fe b0 fb 43 	rcall	8000ebb8 <debounce2>
		   lodepng_decode_display((unsigned char *)imagen1,size2,1);//decodifca la PNG
		   nav_filterlist_goto(1);
		   if(nav_file_getname((FS_STRING) str_buff, 40))
		   et024006_PrintString(str_buff,(const unsigned char*)&FONT8x8,40,80,RED,-1);
	   }
	    if (debounce2(QT1081_TOUCH_SENSOR_RIGHT))
8000f536:	cc b1       	brne	8000f4cc <main+0x3c4>
8000f538:	33 7c       	mov	r12,55
8000f53a:	fe b0 fb 3f 	rcall	8000ebb8 <debounce2>
			lodepng_decode_display((unsigned char *)imagen1,size2,1);//decodifca la PNG
		    nav_filterlist_goto(2);
		    if(nav_file_getname((FS_STRING) str_buff, 40))
		    et024006_PrintString(str_buff,(const unsigned char*)&FONT8x8,40,80,RED,-1);
	    }
		 if (debounce2(QT1081_TOUCH_SENSOR_LEFT))
8000f53e:	ce c0       	breq	8000f516 <main+0x40e>
8000f540:	30 08       	mov	r8,0
8000f542:	e0 69 00 f0 	mov	r9,240
	  if(nav_file_getname((FS_STRING) str_buff, 40))
	  et024006_PrintString(str_buff,(const unsigned char*)&FONT8x8,40,80+(l+=10),BLUE,-1);
  }
  
  
  while (!gpio_get_pin_value(QT1081_TOUCH_SENSOR_ENTER))
8000f546:	10 9b       	mov	r11,r8
8000f548:	10 9c       	mov	r12,r8
8000f54a:	e0 6a 01 40 	mov	r10,320
8000f54e:	fe b0 d2 7f 	rcall	80009a4c <et024006_DrawFilledRect>
  {
	  
	  if (debounce2(QT1081_TOUCH_SENSOR_UP))
8000f552:	06 9b       	mov	r11,r3
8000f554:	30 1a       	mov	r10,1
8000f556:	6e 1c       	ld.w	r12,r7[0x4]
		  nav_filterlist_goto(0);
		  if(nav_file_getname((FS_STRING) str_buff, 40))
		  et024006_PrintString(str_buff,(const unsigned char*)&FONT8x8,40,80,RED,-1);
	  }
	  
	   if (debounce2(QT1081_TOUCH_SENSOR_DOWN))
8000f558:	fe b0 fb 82 	rcall	8000ec5c <lodepng_decode_display>
8000f55c:	30 1c       	mov	r12,1
8000f55e:	fe b0 f9 0f 	rcall	8000e77c <nav_filterlist_goto>


void CLR_disp(void)
{
	// Clear the display i.e. make it black
	et024006_DrawFilledRect(0 , 0, ET024006_WIDTH, ET024006_HEIGHT, BLACK );
8000f562:	32 8b       	mov	r11,40
8000f564:	33 0c       	mov	r12,48
8000f566:	fe b0 f8 9b 	rcall	8000e69c <nav_file_getname>
8000f56a:	cd 60       	breq	8000f516 <main+0x40e>
8000f56c:	3f f8       	mov	r8,-1
8000f56e:	35 09       	mov	r9,80
8000f570:	1a d8       	st.w	--sp,r8
	  }
	  
	   if (debounce2(QT1081_TOUCH_SENSOR_DOWN))
	   {
		   CLR_disp();
		   lodepng_decode_display((unsigned char *)imagen1,size2,1);//decodifca la PNG
8000f572:	32 8a       	mov	r10,40
8000f574:	e0 68 f8 00 	mov	r8,63488
8000f578:	4c 7b       	lddpc	r11,8000f694 <main+0x58c>
8000f57a:	33 0c       	mov	r12,48
		   nav_filterlist_goto(1);
8000f57c:	fe b0 d1 30 	rcall	800097dc <et024006_PrintString>
8000f580:	2f fd       	sub	sp,-4
		   if(nav_file_getname((FS_STRING) str_buff, 40))
8000f582:	cc ab       	rjmp	8000f516 <main+0x40e>
8000f584:	30 08       	mov	r8,0
8000f586:	e0 69 00 f0 	mov	r9,240
8000f58a:	10 9b       	mov	r11,r8
		   et024006_PrintString(str_buff,(const unsigned char*)&FONT8x8,40,80,RED,-1);
8000f58c:	10 9c       	mov	r12,r8
8000f58e:	e0 6a 01 40 	mov	r10,320
8000f592:	fe b0 d2 5d 	rcall	80009a4c <et024006_DrawFilledRect>
8000f596:	06 9b       	mov	r11,r3
8000f598:	30 1a       	mov	r10,1
8000f59a:	6e 1c       	ld.w	r12,r7[0x4]
8000f59c:	fe b0 fb 60 	rcall	8000ec5c <lodepng_decode_display>
8000f5a0:	30 2c       	mov	r12,2
8000f5a2:	fe b0 f8 ed 	rcall	8000e77c <nav_filterlist_goto>


void CLR_disp(void)
{
	// Clear the display i.e. make it black
	et024006_DrawFilledRect(0 , 0, ET024006_WIDTH, ET024006_HEIGHT, BLACK );
8000f5a6:	32 8b       	mov	r11,40
8000f5a8:	33 0c       	mov	r12,48
8000f5aa:	fe b0 f8 79 	rcall	8000e69c <nav_file_getname>
8000f5ae:	cb 80       	breq	8000f51e <main+0x416>
8000f5b0:	3f f8       	mov	r8,-1
8000f5b2:	35 09       	mov	r9,80
8000f5b4:	1a d8       	st.w	--sp,r8
		   et024006_PrintString(str_buff,(const unsigned char*)&FONT8x8,40,80,RED,-1);
	   }
	    if (debounce2(QT1081_TOUCH_SENSOR_RIGHT))
	    {
		    CLR_disp();
			lodepng_decode_display((unsigned char *)imagen1,size2,1);//decodifca la PNG
8000f5b6:	32 8a       	mov	r10,40
8000f5b8:	e0 68 f8 00 	mov	r8,63488
8000f5bc:	4b 6b       	lddpc	r11,8000f694 <main+0x58c>
8000f5be:	33 0c       	mov	r12,48
		    nav_filterlist_goto(2);
8000f5c0:	fe b0 d1 0e 	rcall	800097dc <et024006_PrintString>
8000f5c4:	2f fd       	sub	sp,-4
		    if(nav_file_getname((FS_STRING) str_buff, 40))
8000f5c6:	ca cb       	rjmp	8000f51e <main+0x416>
8000f5c8:	30 08       	mov	r8,0
8000f5ca:	e0 69 00 f0 	mov	r9,240
8000f5ce:	10 9b       	mov	r11,r8
		    et024006_PrintString(str_buff,(const unsigned char*)&FONT8x8,40,80,RED,-1);
8000f5d0:	10 9c       	mov	r12,r8
8000f5d2:	e0 6a 01 40 	mov	r10,320
8000f5d6:	fe b0 d2 3b 	rcall	80009a4c <et024006_DrawFilledRect>
8000f5da:	0a 9b       	mov	r11,r5
8000f5dc:	30 2a       	mov	r10,2
8000f5de:	6e 0c       	ld.w	r12,r7[0x0]
8000f5e0:	fe b0 fb 3e 	rcall	8000ec5c <lodepng_decode_display>
8000f5e4:	30 3c       	mov	r12,3
8000f5e6:	fe b0 f8 cb 	rcall	8000e77c <nav_filterlist_goto>


void CLR_disp(void)
{
	// Clear the display i.e. make it black
	et024006_DrawFilledRect(0 , 0, ET024006_WIDTH, ET024006_HEIGHT, BLACK );
8000f5ea:	32 8b       	mov	r11,40
8000f5ec:	33 0c       	mov	r12,48
8000f5ee:	fe b0 f8 57 	rcall	8000e69c <nav_file_getname>
8000f5f2:	c9 a0       	breq	8000f526 <main+0x41e>
8000f5f4:	3f f8       	mov	r8,-1
8000f5f6:	35 09       	mov	r9,80
8000f5f8:	1a d8       	st.w	--sp,r8
		    et024006_PrintString(str_buff,(const unsigned char*)&FONT8x8,40,80,RED,-1);
	    }
		 if (debounce2(QT1081_TOUCH_SENSOR_LEFT))
		 {
			 CLR_disp();
			 lodepng_decode_display((unsigned char *)imagen,size1,2);//decodifca la PNG
8000f5fa:	32 8a       	mov	r10,40
8000f5fc:	e0 68 f8 00 	mov	r8,63488
8000f600:	4a 5b       	lddpc	r11,8000f694 <main+0x58c>
8000f602:	33 0c       	mov	r12,48
			 nav_filterlist_goto(3);
8000f604:	fe b0 d0 ec 	rcall	800097dc <et024006_PrintString>
8000f608:	2f fd       	sub	sp,-4
			 if(nav_file_getname((FS_STRING) str_buff, 40))
8000f60a:	c8 eb       	rjmp	8000f526 <main+0x41e>
8000f60c:	6e 0c       	ld.w	r12,r7[0x0]
8000f60e:	e0 a0 04 6f 	rcall	8000feec <free>
8000f612:	6e 1c       	ld.w	r12,r7[0x4]
			 et024006_PrintString(str_buff,(const unsigned char*)&FONT8x8,40,80,RED,-1);
8000f614:	e0 a0 04 6c 	rcall	8000feec <free>
8000f618:	36 4b       	mov	r11,100
8000f61a:	fe 7c 14 00 	mov	r12,-60416
8000f61e:	fe b0 e3 b0 	rcall	8000bd7e <usart_write_char>
8000f622:	fe b0 f4 81 	rcall	8000df24 <file_bof>
8000f626:	30 9c       	mov	r12,9
8000f628:	fe b0 f5 20 	rcall	8000e068 <file_open>
	  
	  
	  
  }
  
  free(imagen);
8000f62c:	e0 68 0f 7c 	mov	r8,3964
8000f630:	fe 7c 14 00 	mov	r12,-60416
  free(imagen1);
8000f634:	11 8b       	ld.ub	r11,r8[0x0]
8000f636:	fe b0 e3 a4 	rcall	8000bd7e <usart_write_char>
 char z;
 /*
 nav_filterlist_goto(2);
 nav_file_getname((FS_STRING) str_buff, 40);
 */
 usart_write_char(&AVR32_USART0,'d');
8000f63a:	e0 6a 00 f0 	mov	r10,240
8000f63e:	e0 6b 01 00 	mov	r11,256
 
//  nav_filterlist_goto(0); //primer archivo, megaman.nes
//  nav_file_getname((FS_STRING) str_buff, 40);
 file_bof();
8000f642:	30 3c       	mov	r12,3
8000f644:	fe b0 c6 fc 	rcall	8000843c <nes_init>
file_open(FOPEN_MODE_R);
8000f648:	8f 2c       	st.w	r7[0x8],r12
8000f64a:	fe b0 c6 8f 	rcall	80008368 <nes_run>
usart_write_char(&AVR32_USART0,fs_g_status);
8000f64e:	6e 2c       	ld.w	r12,r7[0x8]
8000f650:	cf db       	rjmp	8000f64a <main+0x542>
8000f652:	fe b0 f6 15 	rcall	8000e27c <nav_file_lgt>
8000f656:	48 fb       	lddpc	r11,8000f690 <main+0x588>
 int filename =3;
 #define DEFAULT_RESOLUTION_WIDTH 256
 #define DEFAULT_RESOLUTION_HEIGHT 240
 int width = DEFAULT_RESOLUTION_WIDTH;
 int height = DEFAULT_RESOLUTION_HEIGHT;
  nes = nes_init(filename, width, height);
8000f658:	1a dc       	st.w	--sp,r12
8000f65a:	35 8c       	mov	r12,88
8000f65c:	e0 a0 08 96 	rcall	80010788 <sprintf>
8000f660:	31 f8       	mov	r8,31
8000f662:	1a d7       	st.w	--sp,r7
8000f664:	34 69       	mov	r9,70
8000f666:	36 ea       	mov	r10,110
  while (1)
  {
	   nes_run(nes);
8000f668:	48 bb       	lddpc	r11,8000f694 <main+0x58c>
8000f66a:	35 8c       	mov	r12,88
8000f66c:	fe b0 d0 b8 	rcall	800097dc <et024006_PrintString>
  et024006_PrintString(mensaje,(const unsigned char*)&FONT8x8,90,70,BLUE,-1);

  // Display # of bytes in file
  if(nav_filelist_first(FS_FILE))
  {
	  drives = nav_file_lgt();
8000f670:	2f ed       	sub	sp,-8
8000f672:	fe 9f fe c1 	bral	8000f3f4 <main+0x2ec>
	  sprintf(mensaje,"%d",drives);
8000f676:	d7 03       	nop
8000f678:	80 01       	ld.sh	r1,r0[0x0]
8000f67a:	82 e8       	ld.uh	r8,r1[0xc]
8000f67c:	80 01       	ld.sh	r1,r0[0x0]
	  et024006_PrintString(mensaje,(const unsigned char*)&FONT8x8,110,70,BLUE,-1);
8000f67e:	82 c4       	ld.uh	r4,r1[0x8]
8000f680:	80 01       	ld.sh	r1,r0[0x0]
8000f682:	82 d0       	ld.uh	r0,r1[0xa]
8000f684:	80 01       	ld.sh	r1,r0[0x0]
8000f686:	83 74       	st.w	r1[0x1c],r4
8000f688:	80 01       	ld.sh	r1,r0[0x0]
8000f68a:	87 90       	st.w	r3[0x24],r0
8000f68c:	80 01       	ld.sh	r1,r0[0x0]
8000f68e:	87 a0       	st.w	r3[0x28],r0
8000f690:	80 01       	ld.sh	r1,r0[0x0]
8000f692:	83 68       	st.w	r1[0x18],r8
8000f694:	80 01       	ld.sh	r1,r0[0x0]
8000f696:	7e 74       	ld.w	r4,pc[0x1c]
8000f698:	80 01       	ld.sh	r1,r0[0x0]
8000f69a:	83 6c       	st.w	r1[0x18],r12
8000f69c:	d0 00       	acall	0x0
8000f69e:	00 00       	add	r0,r0
8000f6a0:	80 01       	ld.sh	r1,r0[0x0]
8000f6a2:	83 70       	st.w	r1[0x1c],r0

8000f6a4 <__avr32_f64_mul>:
8000f6a4:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000f6a8:	e0 80 00 dc 	breq	8000f860 <__avr32_f64_mul_op1_zero>
8000f6ac:	d4 21       	pushm	r4-r7,lr
8000f6ae:	f7 e9 20 0e 	eor	lr,r11,r9
8000f6b2:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000f6b6:	30 15       	mov	r5,1
8000f6b8:	c4 30       	breq	8000f73e <__avr32_f64_mul_op1_subnormal>
8000f6ba:	ab 6b       	lsl	r11,0xa
8000f6bc:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000f6c0:	ab 6a       	lsl	r10,0xa
8000f6c2:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000f6c6:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000f6ca:	c5 c0       	breq	8000f782 <__avr32_f64_mul_op2_subnormal>
8000f6cc:	a1 78       	lsl	r8,0x1
8000f6ce:	5c f9       	rol	r9
8000f6d0:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000f6d4:	e0 47 07 ff 	cp.w	r7,2047
8000f6d8:	c7 70       	breq	8000f7c6 <__avr32_f64_mul_op_nan_or_inf>
8000f6da:	e0 46 07 ff 	cp.w	r6,2047
8000f6de:	c7 40       	breq	8000f7c6 <__avr32_f64_mul_op_nan_or_inf>
8000f6e0:	ee 06 00 0c 	add	r12,r7,r6
8000f6e4:	e0 2c 03 fe 	sub	r12,1022
8000f6e8:	f6 08 06 44 	mulu.d	r4,r11,r8
8000f6ec:	f4 09 07 44 	macu.d	r4,r10,r9
8000f6f0:	f4 08 06 46 	mulu.d	r6,r10,r8
8000f6f4:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000f6f8:	08 07       	add	r7,r4
8000f6fa:	f4 05 00 4a 	adc	r10,r10,r5
8000f6fe:	5c 0b       	acr	r11
8000f700:	ed bb 00 14 	bld	r11,0x14
8000f704:	c0 50       	breq	8000f70e <__avr32_f64_mul+0x6a>
8000f706:	a1 77       	lsl	r7,0x1
8000f708:	5c fa       	rol	r10
8000f70a:	5c fb       	rol	r11
8000f70c:	20 1c       	sub	r12,1
8000f70e:	58 0c       	cp.w	r12,0
8000f710:	e0 8a 00 6f 	brle	8000f7ee <__avr32_f64_mul_res_subnormal>
8000f714:	e0 4c 07 ff 	cp.w	r12,2047
8000f718:	e0 84 00 9c 	brge	8000f850 <__avr32_f64_mul_res_inf>
8000f71c:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000f720:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000f724:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000f728:	ee 17 80 00 	eorh	r7,0x8000
8000f72c:	f1 b7 04 20 	satu	r7,0x1
8000f730:	0e 0a       	add	r10,r7
8000f732:	5c 0b       	acr	r11
8000f734:	ed be 00 1f 	bld	lr,0x1f
8000f738:	ef bb 00 1f 	bst	r11,0x1f
8000f73c:	d8 22       	popm	r4-r7,pc

8000f73e <__avr32_f64_mul_op1_subnormal>:
8000f73e:	e4 1b 00 0f 	andh	r11,0xf
8000f742:	f4 0c 12 00 	clz	r12,r10
8000f746:	f6 06 12 00 	clz	r6,r11
8000f74a:	f7 bc 03 e1 	sublo	r12,-31
8000f74e:	f8 06 17 30 	movlo	r6,r12
8000f752:	f7 b6 02 01 	subhs	r6,1
8000f756:	e0 46 00 20 	cp.w	r6,32
8000f75a:	c0 d4       	brge	8000f774 <__avr32_f64_mul_op1_subnormal+0x36>
8000f75c:	ec 0c 11 20 	rsub	r12,r6,32
8000f760:	f6 06 09 4b 	lsl	r11,r11,r6
8000f764:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000f768:	18 4b       	or	r11,r12
8000f76a:	f4 06 09 4a 	lsl	r10,r10,r6
8000f76e:	20 b6       	sub	r6,11
8000f770:	0c 17       	sub	r7,r6
8000f772:	ca ab       	rjmp	8000f6c6 <__avr32_f64_mul+0x22>
8000f774:	f4 06 09 4b 	lsl	r11,r10,r6
8000f778:	c6 40       	breq	8000f840 <__avr32_f64_mul_res_zero>
8000f77a:	30 0a       	mov	r10,0
8000f77c:	20 b6       	sub	r6,11
8000f77e:	0c 17       	sub	r7,r6
8000f780:	ca 3b       	rjmp	8000f6c6 <__avr32_f64_mul+0x22>

8000f782 <__avr32_f64_mul_op2_subnormal>:
8000f782:	e4 19 00 0f 	andh	r9,0xf
8000f786:	f0 0c 12 00 	clz	r12,r8
8000f78a:	f2 05 12 00 	clz	r5,r9
8000f78e:	f7 bc 03 ea 	sublo	r12,-22
8000f792:	f8 05 17 30 	movlo	r5,r12
8000f796:	f7 b5 02 0a 	subhs	r5,10
8000f79a:	e0 45 00 20 	cp.w	r5,32
8000f79e:	c0 d4       	brge	8000f7b8 <__avr32_f64_mul_op2_subnormal+0x36>
8000f7a0:	ea 0c 11 20 	rsub	r12,r5,32
8000f7a4:	f2 05 09 49 	lsl	r9,r9,r5
8000f7a8:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000f7ac:	18 49       	or	r9,r12
8000f7ae:	f0 05 09 48 	lsl	r8,r8,r5
8000f7b2:	20 25       	sub	r5,2
8000f7b4:	0a 16       	sub	r6,r5
8000f7b6:	c8 fb       	rjmp	8000f6d4 <__avr32_f64_mul+0x30>
8000f7b8:	f0 05 09 49 	lsl	r9,r8,r5
8000f7bc:	c4 20       	breq	8000f840 <__avr32_f64_mul_res_zero>
8000f7be:	30 08       	mov	r8,0
8000f7c0:	20 25       	sub	r5,2
8000f7c2:	0a 16       	sub	r6,r5
8000f7c4:	c8 8b       	rjmp	8000f6d4 <__avr32_f64_mul+0x30>

8000f7c6 <__avr32_f64_mul_op_nan_or_inf>:
8000f7c6:	e4 19 00 0f 	andh	r9,0xf
8000f7ca:	e4 1b 00 0f 	andh	r11,0xf
8000f7ce:	14 4b       	or	r11,r10
8000f7d0:	10 49       	or	r9,r8
8000f7d2:	e0 47 07 ff 	cp.w	r7,2047
8000f7d6:	c0 91       	brne	8000f7e8 <__avr32_f64_mul_op1_not_naninf>
8000f7d8:	58 0b       	cp.w	r11,0
8000f7da:	c3 81       	brne	8000f84a <__avr32_f64_mul_res_nan>
8000f7dc:	e0 46 07 ff 	cp.w	r6,2047
8000f7e0:	c3 81       	brne	8000f850 <__avr32_f64_mul_res_inf>
8000f7e2:	58 09       	cp.w	r9,0
8000f7e4:	c3 60       	breq	8000f850 <__avr32_f64_mul_res_inf>
8000f7e6:	c3 28       	rjmp	8000f84a <__avr32_f64_mul_res_nan>

8000f7e8 <__avr32_f64_mul_op1_not_naninf>:
8000f7e8:	58 09       	cp.w	r9,0
8000f7ea:	c3 30       	breq	8000f850 <__avr32_f64_mul_res_inf>
8000f7ec:	c2 f8       	rjmp	8000f84a <__avr32_f64_mul_res_nan>

8000f7ee <__avr32_f64_mul_res_subnormal>:
8000f7ee:	5c 3c       	neg	r12
8000f7f0:	2f fc       	sub	r12,-1
8000f7f2:	f1 bc 04 c0 	satu	r12,0x6
8000f7f6:	e0 4c 00 20 	cp.w	r12,32
8000f7fa:	c1 14       	brge	8000f81c <__avr32_f64_mul_res_subnormal+0x2e>
8000f7fc:	f8 08 11 20 	rsub	r8,r12,32
8000f800:	0e 46       	or	r6,r7
8000f802:	ee 0c 0a 47 	lsr	r7,r7,r12
8000f806:	f4 08 09 49 	lsl	r9,r10,r8
8000f80a:	12 47       	or	r7,r9
8000f80c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000f810:	f6 08 09 49 	lsl	r9,r11,r8
8000f814:	12 4a       	or	r10,r9
8000f816:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000f81a:	c8 3b       	rjmp	8000f720 <__avr32_f64_mul+0x7c>
8000f81c:	f8 08 11 20 	rsub	r8,r12,32
8000f820:	f9 b9 00 00 	moveq	r9,0
8000f824:	c0 30       	breq	8000f82a <__avr32_f64_mul_res_subnormal+0x3c>
8000f826:	f6 08 09 49 	lsl	r9,r11,r8
8000f82a:	0e 46       	or	r6,r7
8000f82c:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000f830:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000f834:	f3 ea 10 07 	or	r7,r9,r10
8000f838:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000f83c:	30 0b       	mov	r11,0
8000f83e:	c7 1b       	rjmp	8000f720 <__avr32_f64_mul+0x7c>

8000f840 <__avr32_f64_mul_res_zero>:
8000f840:	1c 9b       	mov	r11,lr
8000f842:	e6 1b 80 00 	andh	r11,0x8000,COH
8000f846:	30 0a       	mov	r10,0
8000f848:	d8 22       	popm	r4-r7,pc

8000f84a <__avr32_f64_mul_res_nan>:
8000f84a:	3f fb       	mov	r11,-1
8000f84c:	3f fa       	mov	r10,-1
8000f84e:	d8 22       	popm	r4-r7,pc

8000f850 <__avr32_f64_mul_res_inf>:
8000f850:	f0 6b 00 00 	mov	r11,-1048576
8000f854:	ed be 00 1f 	bld	lr,0x1f
8000f858:	ef bb 00 1f 	bst	r11,0x1f
8000f85c:	30 0a       	mov	r10,0
8000f85e:	d8 22       	popm	r4-r7,pc

8000f860 <__avr32_f64_mul_op1_zero>:
8000f860:	f7 e9 20 0b 	eor	r11,r11,r9
8000f864:	e6 1b 80 00 	andh	r11,0x8000,COH
8000f868:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000f86c:	e0 4c 07 ff 	cp.w	r12,2047
8000f870:	5e 1c       	retne	r12
8000f872:	3f fa       	mov	r10,-1
8000f874:	3f fb       	mov	r11,-1
8000f876:	5e fc       	retal	r12

8000f878 <__avr32_f64_sub_from_add>:
8000f878:	ee 19 80 00 	eorh	r9,0x8000

8000f87c <__avr32_f64_sub>:
8000f87c:	f7 e9 20 0c 	eor	r12,r11,r9
8000f880:	e0 86 00 ca 	brmi	8000fa14 <__avr32_f64_add_from_sub>
8000f884:	eb cd 40 e0 	pushm	r5-r7,lr
8000f888:	16 9c       	mov	r12,r11
8000f88a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000f88e:	bf db       	cbr	r11,0x1f
8000f890:	bf d9       	cbr	r9,0x1f
8000f892:	10 3a       	cp.w	r10,r8
8000f894:	f2 0b 13 00 	cpc	r11,r9
8000f898:	c0 92       	brcc	8000f8aa <__avr32_f64_sub+0x2e>
8000f89a:	16 97       	mov	r7,r11
8000f89c:	12 9b       	mov	r11,r9
8000f89e:	0e 99       	mov	r9,r7
8000f8a0:	14 97       	mov	r7,r10
8000f8a2:	10 9a       	mov	r10,r8
8000f8a4:	0e 98       	mov	r8,r7
8000f8a6:	ee 1c 80 00 	eorh	r12,0x8000
8000f8aa:	f6 07 16 14 	lsr	r7,r11,0x14
8000f8ae:	ab 7b       	lsl	r11,0xb
8000f8b0:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000f8b4:	ab 7a       	lsl	r10,0xb
8000f8b6:	bf bb       	sbr	r11,0x1f
8000f8b8:	f2 06 16 14 	lsr	r6,r9,0x14
8000f8bc:	c4 40       	breq	8000f944 <__avr32_f64_sub_opL_subnormal>
8000f8be:	ab 79       	lsl	r9,0xb
8000f8c0:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000f8c4:	ab 78       	lsl	r8,0xb
8000f8c6:	bf b9       	sbr	r9,0x1f

8000f8c8 <__avr32_f64_sub_opL_subnormal_done>:
8000f8c8:	e0 47 07 ff 	cp.w	r7,2047
8000f8cc:	c4 f0       	breq	8000f96a <__avr32_f64_sub_opH_nan_or_inf>
8000f8ce:	0e 26       	rsub	r6,r7
8000f8d0:	c1 20       	breq	8000f8f4 <__avr32_f64_sub_shift_done>
8000f8d2:	ec 05 11 20 	rsub	r5,r6,32
8000f8d6:	e0 46 00 20 	cp.w	r6,32
8000f8da:	c7 c2       	brcc	8000f9d2 <__avr32_f64_sub_longshift>
8000f8dc:	f0 05 09 4e 	lsl	lr,r8,r5
8000f8e0:	f2 05 09 45 	lsl	r5,r9,r5
8000f8e4:	f0 06 0a 48 	lsr	r8,r8,r6
8000f8e8:	f2 06 0a 49 	lsr	r9,r9,r6
8000f8ec:	0a 48       	or	r8,r5
8000f8ee:	58 0e       	cp.w	lr,0
8000f8f0:	5f 1e       	srne	lr
8000f8f2:	1c 48       	or	r8,lr

8000f8f4 <__avr32_f64_sub_shift_done>:
8000f8f4:	10 1a       	sub	r10,r8
8000f8f6:	f6 09 01 4b 	sbc	r11,r11,r9
8000f8fa:	f6 06 12 00 	clz	r6,r11
8000f8fe:	c0 e0       	breq	8000f91a <__avr32_f64_sub_longnormalize_done>
8000f900:	c7 83       	brcs	8000f9f0 <__avr32_f64_sub_longnormalize>
8000f902:	ec 0e 11 20 	rsub	lr,r6,32
8000f906:	f6 06 09 4b 	lsl	r11,r11,r6
8000f90a:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000f90e:	1c 4b       	or	r11,lr
8000f910:	f4 06 09 4a 	lsl	r10,r10,r6
8000f914:	0c 17       	sub	r7,r6
8000f916:	e0 8a 00 39 	brle	8000f988 <__avr32_f64_sub_subnormal_result>

8000f91a <__avr32_f64_sub_longnormalize_done>:
8000f91a:	f4 09 15 15 	lsl	r9,r10,0x15
8000f91e:	ab 9a       	lsr	r10,0xb
8000f920:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000f924:	ab 9b       	lsr	r11,0xb
8000f926:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000f92a:	18 4b       	or	r11,r12

8000f92c <__avr32_f64_sub_round>:
8000f92c:	fc 17 80 00 	movh	r7,0x8000
8000f930:	ed ba 00 00 	bld	r10,0x0
8000f934:	f7 b7 01 ff 	subne	r7,-1
8000f938:	0e 39       	cp.w	r9,r7
8000f93a:	5f 29       	srhs	r9
8000f93c:	12 0a       	add	r10,r9
8000f93e:	5c 0b       	acr	r11
8000f940:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f944 <__avr32_f64_sub_opL_subnormal>:
8000f944:	ab 79       	lsl	r9,0xb
8000f946:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000f94a:	ab 78       	lsl	r8,0xb
8000f94c:	f3 e8 10 0e 	or	lr,r9,r8
8000f950:	f9 b6 01 01 	movne	r6,1
8000f954:	ee 0e 11 00 	rsub	lr,r7,0
8000f958:	f9 b7 00 01 	moveq	r7,1
8000f95c:	ef bb 00 1f 	bst	r11,0x1f
8000f960:	f7 ea 10 0e 	or	lr,r11,r10
8000f964:	f9 b7 00 00 	moveq	r7,0
8000f968:	cb 0b       	rjmp	8000f8c8 <__avr32_f64_sub_opL_subnormal_done>

8000f96a <__avr32_f64_sub_opH_nan_or_inf>:
8000f96a:	bf db       	cbr	r11,0x1f
8000f96c:	f7 ea 10 0e 	or	lr,r11,r10
8000f970:	c0 81       	brne	8000f980 <__avr32_f64_sub_return_nan>
8000f972:	e0 46 07 ff 	cp.w	r6,2047
8000f976:	c0 50       	breq	8000f980 <__avr32_f64_sub_return_nan>
8000f978:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000f97c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f980 <__avr32_f64_sub_return_nan>:
8000f980:	3f fa       	mov	r10,-1
8000f982:	3f fb       	mov	r11,-1
8000f984:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f988 <__avr32_f64_sub_subnormal_result>:
8000f988:	5c 37       	neg	r7
8000f98a:	2f f7       	sub	r7,-1
8000f98c:	f1 b7 04 c0 	satu	r7,0x6
8000f990:	e0 47 00 20 	cp.w	r7,32
8000f994:	c1 14       	brge	8000f9b6 <__avr32_f64_sub_subnormal_result+0x2e>
8000f996:	ee 08 11 20 	rsub	r8,r7,32
8000f99a:	f4 08 09 49 	lsl	r9,r10,r8
8000f99e:	5f 16       	srne	r6
8000f9a0:	f4 07 0a 4a 	lsr	r10,r10,r7
8000f9a4:	0c 4a       	or	r10,r6
8000f9a6:	f6 08 09 49 	lsl	r9,r11,r8
8000f9aa:	f5 e9 10 0a 	or	r10,r10,r9
8000f9ae:	f4 07 0a 4b 	lsr	r11,r10,r7
8000f9b2:	30 07       	mov	r7,0
8000f9b4:	cb 3b       	rjmp	8000f91a <__avr32_f64_sub_longnormalize_done>
8000f9b6:	ee 08 11 40 	rsub	r8,r7,64
8000f9ba:	f6 08 09 49 	lsl	r9,r11,r8
8000f9be:	14 49       	or	r9,r10
8000f9c0:	5f 16       	srne	r6
8000f9c2:	f6 07 0a 4a 	lsr	r10,r11,r7
8000f9c6:	0c 4a       	or	r10,r6
8000f9c8:	30 0b       	mov	r11,0
8000f9ca:	30 07       	mov	r7,0
8000f9cc:	ca 7b       	rjmp	8000f91a <__avr32_f64_sub_longnormalize_done>
8000f9ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f9d2 <__avr32_f64_sub_longshift>:
8000f9d2:	f1 b6 04 c0 	satu	r6,0x6
8000f9d6:	f0 0e 17 00 	moveq	lr,r8
8000f9da:	c0 40       	breq	8000f9e2 <__avr32_f64_sub_longshift+0x10>
8000f9dc:	f2 05 09 4e 	lsl	lr,r9,r5
8000f9e0:	10 4e       	or	lr,r8
8000f9e2:	f2 06 0a 48 	lsr	r8,r9,r6
8000f9e6:	30 09       	mov	r9,0
8000f9e8:	58 0e       	cp.w	lr,0
8000f9ea:	5f 1e       	srne	lr
8000f9ec:	1c 48       	or	r8,lr
8000f9ee:	c8 3b       	rjmp	8000f8f4 <__avr32_f64_sub_shift_done>

8000f9f0 <__avr32_f64_sub_longnormalize>:
8000f9f0:	f4 06 12 00 	clz	r6,r10
8000f9f4:	f9 b7 03 00 	movlo	r7,0
8000f9f8:	f9 b6 03 00 	movlo	r6,0
8000f9fc:	f9 bc 03 00 	movlo	r12,0
8000fa00:	f7 b6 02 e0 	subhs	r6,-32
8000fa04:	f4 06 09 4b 	lsl	r11,r10,r6
8000fa08:	30 0a       	mov	r10,0
8000fa0a:	0c 17       	sub	r7,r6
8000fa0c:	fe 9a ff be 	brle	8000f988 <__avr32_f64_sub_subnormal_result>
8000fa10:	c8 5b       	rjmp	8000f91a <__avr32_f64_sub_longnormalize_done>
8000fa12:	d7 03       	nop

8000fa14 <__avr32_f64_add_from_sub>:
8000fa14:	ee 19 80 00 	eorh	r9,0x8000

8000fa18 <__avr32_f64_add>:
8000fa18:	f7 e9 20 0c 	eor	r12,r11,r9
8000fa1c:	fe 96 ff 2e 	brmi	8000f878 <__avr32_f64_sub_from_add>
8000fa20:	eb cd 40 e0 	pushm	r5-r7,lr
8000fa24:	16 9c       	mov	r12,r11
8000fa26:	e6 1c 80 00 	andh	r12,0x8000,COH
8000fa2a:	bf db       	cbr	r11,0x1f
8000fa2c:	bf d9       	cbr	r9,0x1f
8000fa2e:	12 3b       	cp.w	r11,r9
8000fa30:	c0 72       	brcc	8000fa3e <__avr32_f64_add+0x26>
8000fa32:	16 97       	mov	r7,r11
8000fa34:	12 9b       	mov	r11,r9
8000fa36:	0e 99       	mov	r9,r7
8000fa38:	14 97       	mov	r7,r10
8000fa3a:	10 9a       	mov	r10,r8
8000fa3c:	0e 98       	mov	r8,r7
8000fa3e:	30 0e       	mov	lr,0
8000fa40:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000fa44:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000fa48:	b5 ab       	sbr	r11,0x14
8000fa4a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000fa4e:	c6 20       	breq	8000fb12 <__avr32_f64_add_op2_subnormal>
8000fa50:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000fa54:	b5 a9       	sbr	r9,0x14
8000fa56:	e0 47 07 ff 	cp.w	r7,2047
8000fa5a:	c2 80       	breq	8000faaa <__avr32_f64_add_opH_nan_or_inf>
8000fa5c:	0e 26       	rsub	r6,r7
8000fa5e:	c1 20       	breq	8000fa82 <__avr32_f64_add_shift_done>
8000fa60:	e0 46 00 36 	cp.w	r6,54
8000fa64:	c1 52       	brcc	8000fa8e <__avr32_f64_add_res_of_done>
8000fa66:	ec 05 11 20 	rsub	r5,r6,32
8000fa6a:	e0 46 00 20 	cp.w	r6,32
8000fa6e:	c3 52       	brcc	8000fad8 <__avr32_f64_add_longshift>
8000fa70:	f0 05 09 4e 	lsl	lr,r8,r5
8000fa74:	f2 05 09 45 	lsl	r5,r9,r5
8000fa78:	f0 06 0a 48 	lsr	r8,r8,r6
8000fa7c:	f2 06 0a 49 	lsr	r9,r9,r6
8000fa80:	0a 48       	or	r8,r5

8000fa82 <__avr32_f64_add_shift_done>:
8000fa82:	10 0a       	add	r10,r8
8000fa84:	f6 09 00 4b 	adc	r11,r11,r9
8000fa88:	ed bb 00 15 	bld	r11,0x15
8000fa8c:	c3 40       	breq	8000faf4 <__avr32_f64_add_res_of>

8000fa8e <__avr32_f64_add_res_of_done>:
8000fa8e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000fa92:	18 4b       	or	r11,r12

8000fa94 <__avr32_f64_add_round>:
8000fa94:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000fa98:	18 4e       	or	lr,r12
8000fa9a:	ee 1e 80 00 	eorh	lr,0x8000
8000fa9e:	f1 be 04 20 	satu	lr,0x1
8000faa2:	1c 0a       	add	r10,lr
8000faa4:	5c 0b       	acr	r11
8000faa6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000faaa <__avr32_f64_add_opH_nan_or_inf>:
8000faaa:	b5 cb       	cbr	r11,0x14
8000faac:	f7 ea 10 0e 	or	lr,r11,r10
8000fab0:	c1 01       	brne	8000fad0 <__avr32_f64_add_return_nan>
8000fab2:	e0 46 07 ff 	cp.w	r6,2047
8000fab6:	c0 30       	breq	8000fabc <__avr32_f64_add_opL_nan_or_inf>
8000fab8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000fabc <__avr32_f64_add_opL_nan_or_inf>:
8000fabc:	b5 c9       	cbr	r9,0x14
8000fabe:	f3 e8 10 0e 	or	lr,r9,r8
8000fac2:	c0 71       	brne	8000fad0 <__avr32_f64_add_return_nan>
8000fac4:	30 0a       	mov	r10,0
8000fac6:	fc 1b 7f f0 	movh	r11,0x7ff0
8000faca:	18 4b       	or	r11,r12
8000facc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000fad0 <__avr32_f64_add_return_nan>:
8000fad0:	3f fa       	mov	r10,-1
8000fad2:	3f fb       	mov	r11,-1
8000fad4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000fad8 <__avr32_f64_add_longshift>:
8000fad8:	f1 b6 04 c0 	satu	r6,0x6
8000fadc:	f0 0e 17 00 	moveq	lr,r8
8000fae0:	c0 60       	breq	8000faec <__avr32_f64_add_longshift+0x14>
8000fae2:	f2 05 09 4e 	lsl	lr,r9,r5
8000fae6:	58 08       	cp.w	r8,0
8000fae8:	5f 18       	srne	r8
8000faea:	10 4e       	or	lr,r8
8000faec:	f2 06 0a 48 	lsr	r8,r9,r6
8000faf0:	30 09       	mov	r9,0
8000faf2:	cc 8b       	rjmp	8000fa82 <__avr32_f64_add_shift_done>

8000faf4 <__avr32_f64_add_res_of>:
8000faf4:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000faf8:	a1 9b       	lsr	r11,0x1
8000fafa:	5d 0a       	ror	r10
8000fafc:	5d 0e       	ror	lr
8000fafe:	2f f7       	sub	r7,-1
8000fb00:	e0 47 07 ff 	cp.w	r7,2047
8000fb04:	f9 ba 00 00 	moveq	r10,0
8000fb08:	f9 bb 00 00 	moveq	r11,0
8000fb0c:	f9 be 00 00 	moveq	lr,0
8000fb10:	cb fb       	rjmp	8000fa8e <__avr32_f64_add_res_of_done>

8000fb12 <__avr32_f64_add_op2_subnormal>:
8000fb12:	30 16       	mov	r6,1
8000fb14:	58 07       	cp.w	r7,0
8000fb16:	ca 01       	brne	8000fa56 <__avr32_f64_add+0x3e>
8000fb18:	b5 cb       	cbr	r11,0x14
8000fb1a:	10 0a       	add	r10,r8
8000fb1c:	f6 09 00 4b 	adc	r11,r11,r9
8000fb20:	18 4b       	or	r11,r12
8000fb22:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000fb26:	d7 03       	nop

8000fb28 <__avr32_f64_to_u32>:
8000fb28:	58 0b       	cp.w	r11,0
8000fb2a:	5e 6d       	retmi	0

8000fb2c <__avr32_f64_to_s32>:
8000fb2c:	f6 0c 15 01 	lsl	r12,r11,0x1
8000fb30:	b5 9c       	lsr	r12,0x15
8000fb32:	e0 2c 03 ff 	sub	r12,1023
8000fb36:	5e 3d       	retlo	0
8000fb38:	f8 0c 11 1f 	rsub	r12,r12,31
8000fb3c:	16 99       	mov	r9,r11
8000fb3e:	ab 7b       	lsl	r11,0xb
8000fb40:	bf bb       	sbr	r11,0x1f
8000fb42:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000fb46:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000fb4a:	a1 79       	lsl	r9,0x1
8000fb4c:	5e 2b       	reths	r11
8000fb4e:	5c 3b       	neg	r11
8000fb50:	5e fb       	retal	r11

8000fb52 <__avr32_u32_to_f64>:
8000fb52:	f8 cb 00 00 	sub	r11,r12,0
8000fb56:	30 0c       	mov	r12,0
8000fb58:	c0 38       	rjmp	8000fb5e <__avr32_s32_to_f64+0x4>

8000fb5a <__avr32_s32_to_f64>:
8000fb5a:	18 9b       	mov	r11,r12
8000fb5c:	5c 4b       	abs	r11
8000fb5e:	30 0a       	mov	r10,0
8000fb60:	5e 0b       	reteq	r11
8000fb62:	d4 01       	pushm	lr
8000fb64:	e0 69 04 1e 	mov	r9,1054
8000fb68:	f6 08 12 00 	clz	r8,r11
8000fb6c:	c1 70       	breq	8000fb9a <__avr32_s32_to_f64+0x40>
8000fb6e:	c0 c3       	brcs	8000fb86 <__avr32_s32_to_f64+0x2c>
8000fb70:	f0 0e 11 20 	rsub	lr,r8,32
8000fb74:	f6 08 09 4b 	lsl	r11,r11,r8
8000fb78:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000fb7c:	1c 4b       	or	r11,lr
8000fb7e:	f4 08 09 4a 	lsl	r10,r10,r8
8000fb82:	10 19       	sub	r9,r8
8000fb84:	c0 b8       	rjmp	8000fb9a <__avr32_s32_to_f64+0x40>
8000fb86:	f4 08 12 00 	clz	r8,r10
8000fb8a:	f9 b8 03 00 	movlo	r8,0
8000fb8e:	f7 b8 02 e0 	subhs	r8,-32
8000fb92:	f4 08 09 4b 	lsl	r11,r10,r8
8000fb96:	30 0a       	mov	r10,0
8000fb98:	10 19       	sub	r9,r8
8000fb9a:	58 09       	cp.w	r9,0
8000fb9c:	e0 89 00 30 	brgt	8000fbfc <__avr32_s32_to_f64+0xa2>
8000fba0:	5c 39       	neg	r9
8000fba2:	2f f9       	sub	r9,-1
8000fba4:	e0 49 00 36 	cp.w	r9,54
8000fba8:	c0 43       	brcs	8000fbb0 <__avr32_s32_to_f64+0x56>
8000fbaa:	30 0b       	mov	r11,0
8000fbac:	30 0a       	mov	r10,0
8000fbae:	c2 68       	rjmp	8000fbfa <__avr32_s32_to_f64+0xa0>
8000fbb0:	2f 69       	sub	r9,-10
8000fbb2:	f2 08 11 20 	rsub	r8,r9,32
8000fbb6:	e0 49 00 20 	cp.w	r9,32
8000fbba:	c0 b2       	brcc	8000fbd0 <__avr32_s32_to_f64+0x76>
8000fbbc:	f4 08 09 4e 	lsl	lr,r10,r8
8000fbc0:	f6 08 09 48 	lsl	r8,r11,r8
8000fbc4:	f4 09 0a 4a 	lsr	r10,r10,r9
8000fbc8:	f6 09 0a 4b 	lsr	r11,r11,r9
8000fbcc:	10 4b       	or	r11,r8
8000fbce:	c0 88       	rjmp	8000fbde <__avr32_s32_to_f64+0x84>
8000fbd0:	f6 08 09 4e 	lsl	lr,r11,r8
8000fbd4:	14 4e       	or	lr,r10
8000fbd6:	16 9a       	mov	r10,r11
8000fbd8:	30 0b       	mov	r11,0
8000fbda:	f4 09 0a 4a 	lsr	r10,r10,r9
8000fbde:	ed ba 00 00 	bld	r10,0x0
8000fbe2:	c0 92       	brcc	8000fbf4 <__avr32_s32_to_f64+0x9a>
8000fbe4:	1c 7e       	tst	lr,lr
8000fbe6:	c0 41       	brne	8000fbee <__avr32_s32_to_f64+0x94>
8000fbe8:	ed ba 00 01 	bld	r10,0x1
8000fbec:	c0 42       	brcc	8000fbf4 <__avr32_s32_to_f64+0x9a>
8000fbee:	2f fa       	sub	r10,-1
8000fbf0:	f7 bb 02 ff 	subhs	r11,-1
8000fbf4:	5c fc       	rol	r12
8000fbf6:	5d 0b       	ror	r11
8000fbf8:	5d 0a       	ror	r10
8000fbfa:	d8 02       	popm	pc
8000fbfc:	e0 68 03 ff 	mov	r8,1023
8000fc00:	ed ba 00 0b 	bld	r10,0xb
8000fc04:	f7 b8 00 ff 	subeq	r8,-1
8000fc08:	10 0a       	add	r10,r8
8000fc0a:	5c 0b       	acr	r11
8000fc0c:	f7 b9 03 fe 	sublo	r9,-2
8000fc10:	e0 49 07 ff 	cp.w	r9,2047
8000fc14:	c0 55       	brlt	8000fc1e <__avr32_s32_to_f64+0xc4>
8000fc16:	30 0a       	mov	r10,0
8000fc18:	fc 1b ff e0 	movh	r11,0xffe0
8000fc1c:	c0 c8       	rjmp	8000fc34 <__floatsidf_return_op1>
8000fc1e:	ed bb 00 1f 	bld	r11,0x1f
8000fc22:	f7 b9 01 01 	subne	r9,1
8000fc26:	ab 9a       	lsr	r10,0xb
8000fc28:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000fc2c:	a1 7b       	lsl	r11,0x1
8000fc2e:	ab 9b       	lsr	r11,0xb
8000fc30:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000fc34 <__floatsidf_return_op1>:
8000fc34:	a1 7c       	lsl	r12,0x1
8000fc36:	5d 0b       	ror	r11
8000fc38:	d8 02       	popm	pc

8000fc3a <__avr32_udiv64>:
8000fc3a:	d4 31       	pushm	r0-r7,lr
8000fc3c:	1a 97       	mov	r7,sp
8000fc3e:	20 3d       	sub	sp,12
8000fc40:	10 9c       	mov	r12,r8
8000fc42:	12 9e       	mov	lr,r9
8000fc44:	14 93       	mov	r3,r10
8000fc46:	58 09       	cp.w	r9,0
8000fc48:	e0 81 00 bd 	brne	8000fdc2 <__avr32_udiv64+0x188>
8000fc4c:	16 38       	cp.w	r8,r11
8000fc4e:	e0 88 00 40 	brls	8000fcce <__avr32_udiv64+0x94>
8000fc52:	f0 08 12 00 	clz	r8,r8
8000fc56:	c0 d0       	breq	8000fc70 <__avr32_udiv64+0x36>
8000fc58:	f6 08 09 4b 	lsl	r11,r11,r8
8000fc5c:	f0 09 11 20 	rsub	r9,r8,32
8000fc60:	f8 08 09 4c 	lsl	r12,r12,r8
8000fc64:	f4 09 0a 49 	lsr	r9,r10,r9
8000fc68:	f4 08 09 43 	lsl	r3,r10,r8
8000fc6c:	f3 eb 10 0b 	or	r11,r9,r11
8000fc70:	f8 0e 16 10 	lsr	lr,r12,0x10
8000fc74:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000fc78:	f6 0e 0d 00 	divu	r0,r11,lr
8000fc7c:	e6 0b 16 10 	lsr	r11,r3,0x10
8000fc80:	00 99       	mov	r9,r0
8000fc82:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000fc86:	e0 0a 02 48 	mul	r8,r0,r10
8000fc8a:	10 3b       	cp.w	r11,r8
8000fc8c:	c0 a2       	brcc	8000fca0 <__avr32_udiv64+0x66>
8000fc8e:	20 19       	sub	r9,1
8000fc90:	18 0b       	add	r11,r12
8000fc92:	18 3b       	cp.w	r11,r12
8000fc94:	c0 63       	brcs	8000fca0 <__avr32_udiv64+0x66>
8000fc96:	10 3b       	cp.w	r11,r8
8000fc98:	f7 b9 03 01 	sublo	r9,1
8000fc9c:	f7 dc e3 0b 	addcs	r11,r11,r12
8000fca0:	f6 08 01 01 	sub	r1,r11,r8
8000fca4:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000fca8:	e2 0e 0d 00 	divu	r0,r1,lr
8000fcac:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000fcb0:	00 98       	mov	r8,r0
8000fcb2:	e0 0a 02 4a 	mul	r10,r0,r10
8000fcb6:	14 33       	cp.w	r3,r10
8000fcb8:	c0 82       	brcc	8000fcc8 <__avr32_udiv64+0x8e>
8000fcba:	20 18       	sub	r8,1
8000fcbc:	18 03       	add	r3,r12
8000fcbe:	18 33       	cp.w	r3,r12
8000fcc0:	c0 43       	brcs	8000fcc8 <__avr32_udiv64+0x8e>
8000fcc2:	14 33       	cp.w	r3,r10
8000fcc4:	f7 b8 03 01 	sublo	r8,1
8000fcc8:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000fccc:	cd f8       	rjmp	8000fe8a <__avr32_udiv64+0x250>
8000fcce:	58 08       	cp.w	r8,0
8000fcd0:	c0 51       	brne	8000fcda <__avr32_udiv64+0xa0>
8000fcd2:	30 19       	mov	r9,1
8000fcd4:	f2 08 0d 08 	divu	r8,r9,r8
8000fcd8:	10 9c       	mov	r12,r8
8000fcda:	f8 06 12 00 	clz	r6,r12
8000fcde:	c0 41       	brne	8000fce6 <__avr32_udiv64+0xac>
8000fce0:	18 1b       	sub	r11,r12
8000fce2:	30 19       	mov	r9,1
8000fce4:	c4 08       	rjmp	8000fd64 <__avr32_udiv64+0x12a>
8000fce6:	ec 01 11 20 	rsub	r1,r6,32
8000fcea:	f4 01 0a 49 	lsr	r9,r10,r1
8000fcee:	f8 06 09 4c 	lsl	r12,r12,r6
8000fcf2:	f6 06 09 48 	lsl	r8,r11,r6
8000fcf6:	f6 01 0a 41 	lsr	r1,r11,r1
8000fcfa:	f3 e8 10 08 	or	r8,r9,r8
8000fcfe:	f8 03 16 10 	lsr	r3,r12,0x10
8000fd02:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000fd06:	e2 03 0d 00 	divu	r0,r1,r3
8000fd0a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000fd0e:	00 9e       	mov	lr,r0
8000fd10:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000fd14:	e0 05 02 49 	mul	r9,r0,r5
8000fd18:	12 3b       	cp.w	r11,r9
8000fd1a:	c0 a2       	brcc	8000fd2e <__avr32_udiv64+0xf4>
8000fd1c:	20 1e       	sub	lr,1
8000fd1e:	18 0b       	add	r11,r12
8000fd20:	18 3b       	cp.w	r11,r12
8000fd22:	c0 63       	brcs	8000fd2e <__avr32_udiv64+0xf4>
8000fd24:	12 3b       	cp.w	r11,r9
8000fd26:	f7 be 03 01 	sublo	lr,1
8000fd2a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000fd2e:	12 1b       	sub	r11,r9
8000fd30:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000fd34:	f6 03 0d 02 	divu	r2,r11,r3
8000fd38:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000fd3c:	04 99       	mov	r9,r2
8000fd3e:	e4 05 02 4b 	mul	r11,r2,r5
8000fd42:	16 38       	cp.w	r8,r11
8000fd44:	c0 a2       	brcc	8000fd58 <__avr32_udiv64+0x11e>
8000fd46:	20 19       	sub	r9,1
8000fd48:	18 08       	add	r8,r12
8000fd4a:	18 38       	cp.w	r8,r12
8000fd4c:	c0 63       	brcs	8000fd58 <__avr32_udiv64+0x11e>
8000fd4e:	16 38       	cp.w	r8,r11
8000fd50:	f7 b9 03 01 	sublo	r9,1
8000fd54:	f1 dc e3 08 	addcs	r8,r8,r12
8000fd58:	f4 06 09 43 	lsl	r3,r10,r6
8000fd5c:	f0 0b 01 0b 	sub	r11,r8,r11
8000fd60:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000fd64:	f8 06 16 10 	lsr	r6,r12,0x10
8000fd68:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000fd6c:	f6 06 0d 00 	divu	r0,r11,r6
8000fd70:	e6 0b 16 10 	lsr	r11,r3,0x10
8000fd74:	00 9a       	mov	r10,r0
8000fd76:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000fd7a:	e0 0e 02 48 	mul	r8,r0,lr
8000fd7e:	10 3b       	cp.w	r11,r8
8000fd80:	c0 a2       	brcc	8000fd94 <__avr32_udiv64+0x15a>
8000fd82:	20 1a       	sub	r10,1
8000fd84:	18 0b       	add	r11,r12
8000fd86:	18 3b       	cp.w	r11,r12
8000fd88:	c0 63       	brcs	8000fd94 <__avr32_udiv64+0x15a>
8000fd8a:	10 3b       	cp.w	r11,r8
8000fd8c:	f7 ba 03 01 	sublo	r10,1
8000fd90:	f7 dc e3 0b 	addcs	r11,r11,r12
8000fd94:	f6 08 01 01 	sub	r1,r11,r8
8000fd98:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000fd9c:	e2 06 0d 00 	divu	r0,r1,r6
8000fda0:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000fda4:	00 98       	mov	r8,r0
8000fda6:	e0 0e 02 4b 	mul	r11,r0,lr
8000fdaa:	16 33       	cp.w	r3,r11
8000fdac:	c0 82       	brcc	8000fdbc <__avr32_udiv64+0x182>
8000fdae:	20 18       	sub	r8,1
8000fdb0:	18 03       	add	r3,r12
8000fdb2:	18 33       	cp.w	r3,r12
8000fdb4:	c0 43       	brcs	8000fdbc <__avr32_udiv64+0x182>
8000fdb6:	16 33       	cp.w	r3,r11
8000fdb8:	f7 b8 03 01 	sublo	r8,1
8000fdbc:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000fdc0:	c6 98       	rjmp	8000fe92 <__avr32_udiv64+0x258>
8000fdc2:	16 39       	cp.w	r9,r11
8000fdc4:	e0 8b 00 65 	brhi	8000fe8e <__avr32_udiv64+0x254>
8000fdc8:	f2 09 12 00 	clz	r9,r9
8000fdcc:	c0 b1       	brne	8000fde2 <__avr32_udiv64+0x1a8>
8000fdce:	10 3a       	cp.w	r10,r8
8000fdd0:	5f 2a       	srhs	r10
8000fdd2:	1c 3b       	cp.w	r11,lr
8000fdd4:	5f b8       	srhi	r8
8000fdd6:	10 4a       	or	r10,r8
8000fdd8:	f2 0a 18 00 	cp.b	r10,r9
8000fddc:	c5 90       	breq	8000fe8e <__avr32_udiv64+0x254>
8000fdde:	30 18       	mov	r8,1
8000fde0:	c5 98       	rjmp	8000fe92 <__avr32_udiv64+0x258>
8000fde2:	f0 09 09 46 	lsl	r6,r8,r9
8000fde6:	f2 03 11 20 	rsub	r3,r9,32
8000fdea:	fc 09 09 4e 	lsl	lr,lr,r9
8000fdee:	f0 03 0a 48 	lsr	r8,r8,r3
8000fdf2:	f6 09 09 4c 	lsl	r12,r11,r9
8000fdf6:	f4 03 0a 42 	lsr	r2,r10,r3
8000fdfa:	ef 46 ff f4 	st.w	r7[-12],r6
8000fdfe:	f6 03 0a 43 	lsr	r3,r11,r3
8000fe02:	18 42       	or	r2,r12
8000fe04:	f1 ee 10 0c 	or	r12,r8,lr
8000fe08:	f8 01 16 10 	lsr	r1,r12,0x10
8000fe0c:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000fe10:	e6 01 0d 04 	divu	r4,r3,r1
8000fe14:	e4 03 16 10 	lsr	r3,r2,0x10
8000fe18:	08 9e       	mov	lr,r4
8000fe1a:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000fe1e:	e8 06 02 48 	mul	r8,r4,r6
8000fe22:	10 33       	cp.w	r3,r8
8000fe24:	c0 a2       	brcc	8000fe38 <__avr32_udiv64+0x1fe>
8000fe26:	20 1e       	sub	lr,1
8000fe28:	18 03       	add	r3,r12
8000fe2a:	18 33       	cp.w	r3,r12
8000fe2c:	c0 63       	brcs	8000fe38 <__avr32_udiv64+0x1fe>
8000fe2e:	10 33       	cp.w	r3,r8
8000fe30:	f7 be 03 01 	sublo	lr,1
8000fe34:	e7 dc e3 03 	addcs	r3,r3,r12
8000fe38:	10 13       	sub	r3,r8
8000fe3a:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000fe3e:	e6 01 0d 00 	divu	r0,r3,r1
8000fe42:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000fe46:	00 98       	mov	r8,r0
8000fe48:	e0 06 02 46 	mul	r6,r0,r6
8000fe4c:	0c 3b       	cp.w	r11,r6
8000fe4e:	c0 a2       	brcc	8000fe62 <__avr32_udiv64+0x228>
8000fe50:	20 18       	sub	r8,1
8000fe52:	18 0b       	add	r11,r12
8000fe54:	18 3b       	cp.w	r11,r12
8000fe56:	c0 63       	brcs	8000fe62 <__avr32_udiv64+0x228>
8000fe58:	0c 3b       	cp.w	r11,r6
8000fe5a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000fe5e:	f7 b8 03 01 	sublo	r8,1
8000fe62:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000fe66:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000fe6a:	0c 1b       	sub	r11,r6
8000fe6c:	f0 04 06 42 	mulu.d	r2,r8,r4
8000fe70:	06 95       	mov	r5,r3
8000fe72:	16 35       	cp.w	r5,r11
8000fe74:	e0 8b 00 0a 	brhi	8000fe88 <__avr32_udiv64+0x24e>
8000fe78:	5f 0b       	sreq	r11
8000fe7a:	f4 09 09 49 	lsl	r9,r10,r9
8000fe7e:	12 32       	cp.w	r2,r9
8000fe80:	5f b9       	srhi	r9
8000fe82:	f7 e9 00 09 	and	r9,r11,r9
8000fe86:	c0 60       	breq	8000fe92 <__avr32_udiv64+0x258>
8000fe88:	20 18       	sub	r8,1
8000fe8a:	30 09       	mov	r9,0
8000fe8c:	c0 38       	rjmp	8000fe92 <__avr32_udiv64+0x258>
8000fe8e:	30 09       	mov	r9,0
8000fe90:	12 98       	mov	r8,r9
8000fe92:	10 9a       	mov	r10,r8
8000fe94:	12 93       	mov	r3,r9
8000fe96:	10 92       	mov	r2,r8
8000fe98:	12 9b       	mov	r11,r9
8000fe9a:	2f dd       	sub	sp,-12
8000fe9c:	d8 32       	popm	r0-r7,pc
8000fe9e:	d7 03       	nop

8000fea0 <__assert_func>:
8000fea0:	d4 01       	pushm	lr
8000fea2:	58 0a       	cp.w	r10,0
8000fea4:	c0 30       	breq	8000feaa <__assert_func+0xa>
8000fea6:	48 98       	lddpc	r8,8000fec8 <__assert_func+0x28>
8000fea8:	c0 38       	rjmp	8000feae <__assert_func+0xe>
8000feaa:	48 9a       	lddpc	r10,8000fecc <__assert_func+0x2c>
8000feac:	14 98       	mov	r8,r10
8000feae:	1a da       	st.w	--sp,r10
8000feb0:	1a d8       	st.w	--sp,r8
8000feb2:	e0 68 01 4c 	mov	r8,332
8000feb6:	1a db       	st.w	--sp,r11
8000feb8:	1a dc       	st.w	--sp,r12
8000feba:	1a d9       	st.w	--sp,r9
8000febc:	70 08       	ld.w	r8,r8[0x0]
8000febe:	48 5b       	lddpc	r11,8000fed0 <__assert_func+0x30>
8000fec0:	70 2c       	ld.w	r12,r8[0x8]
8000fec2:	c0 9c       	rcall	8000fed4 <fiprintf>
8000fec4:	e0 a0 23 8e 	rcall	800145e0 <abort>
8000fec8:	80 01       	ld.sh	r1,r0[0x0]
8000feca:	87 c0       	st.w	r3[0x30],r0
8000fecc:	80 01       	ld.sh	r1,r0[0x0]
8000fece:	83 64       	st.w	r1[0x18],r4
8000fed0:	80 01       	ld.sh	r1,r0[0x0]
8000fed2:	87 d0       	st.w	r3[0x34],r0

8000fed4 <fiprintf>:
8000fed4:	d4 01       	pushm	lr
8000fed6:	e0 68 01 4c 	mov	r8,332
8000feda:	16 9a       	mov	r10,r11
8000fedc:	fa c9 ff fc 	sub	r9,sp,-4
8000fee0:	18 9b       	mov	r11,r12
8000fee2:	70 0c       	ld.w	r12,r8[0x0]
8000fee4:	e0 a0 06 9c 	rcall	80010c1c <_vfiprintf_r>
8000fee8:	d8 02       	popm	pc
8000feea:	d7 03       	nop

8000feec <free>:
8000feec:	d4 01       	pushm	lr
8000feee:	e0 68 01 4c 	mov	r8,332
8000fef2:	18 9b       	mov	r11,r12
8000fef4:	70 0c       	ld.w	r12,r8[0x0]
8000fef6:	e0 a0 2b 73 	rcall	800155dc <_free_r>
8000fefa:	d8 02       	popm	pc

8000fefc <malloc>:
8000fefc:	d4 01       	pushm	lr
8000fefe:	e0 68 01 4c 	mov	r8,332
8000ff02:	18 9b       	mov	r11,r12
8000ff04:	70 0c       	ld.w	r12,r8[0x0]
8000ff06:	c0 3c       	rcall	8000ff0c <_malloc_r>
8000ff08:	d8 02       	popm	pc
8000ff0a:	d7 03       	nop

8000ff0c <_malloc_r>:
8000ff0c:	d4 31       	pushm	r0-r7,lr
8000ff0e:	f6 c8 ff f5 	sub	r8,r11,-11
8000ff12:	18 95       	mov	r5,r12
8000ff14:	10 97       	mov	r7,r8
8000ff16:	e0 17 ff f8 	andl	r7,0xfff8
8000ff1a:	59 68       	cp.w	r8,22
8000ff1c:	f9 b7 08 10 	movls	r7,16
8000ff20:	16 37       	cp.w	r7,r11
8000ff22:	5f 38       	srlo	r8
8000ff24:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
8000ff28:	c0 50       	breq	8000ff32 <_malloc_r+0x26>
8000ff2a:	30 c8       	mov	r8,12
8000ff2c:	99 38       	st.w	r12[0xc],r8
8000ff2e:	e0 8f 01 f7 	bral	8001031c <_malloc_r+0x410>
8000ff32:	e0 a0 02 b0 	rcall	80010492 <__malloc_lock>
8000ff36:	e0 47 01 f7 	cp.w	r7,503
8000ff3a:	e0 8b 00 1d 	brhi	8000ff74 <_malloc_r+0x68>
8000ff3e:	ee 03 16 03 	lsr	r3,r7,0x3
8000ff42:	e0 68 01 50 	mov	r8,336
8000ff46:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000ff4a:	70 36       	ld.w	r6,r8[0xc]
8000ff4c:	10 36       	cp.w	r6,r8
8000ff4e:	c0 61       	brne	8000ff5a <_malloc_r+0x4e>
8000ff50:	ec c8 ff f8 	sub	r8,r6,-8
8000ff54:	70 36       	ld.w	r6,r8[0xc]
8000ff56:	10 36       	cp.w	r6,r8
8000ff58:	c0 c0       	breq	8000ff70 <_malloc_r+0x64>
8000ff5a:	6c 18       	ld.w	r8,r6[0x4]
8000ff5c:	e0 18 ff fc 	andl	r8,0xfffc
8000ff60:	6c 3a       	ld.w	r10,r6[0xc]
8000ff62:	ec 08 00 09 	add	r9,r6,r8
8000ff66:	0a 9c       	mov	r12,r5
8000ff68:	6c 28       	ld.w	r8,r6[0x8]
8000ff6a:	95 28       	st.w	r10[0x8],r8
8000ff6c:	91 3a       	st.w	r8[0xc],r10
8000ff6e:	c4 78       	rjmp	8000fffc <_malloc_r+0xf0>
8000ff70:	2f e3       	sub	r3,-2
8000ff72:	c4 d8       	rjmp	8001000c <_malloc_r+0x100>
8000ff74:	ee 03 16 09 	lsr	r3,r7,0x9
8000ff78:	c0 41       	brne	8000ff80 <_malloc_r+0x74>
8000ff7a:	ee 03 16 03 	lsr	r3,r7,0x3
8000ff7e:	c2 68       	rjmp	8000ffca <_malloc_r+0xbe>
8000ff80:	58 43       	cp.w	r3,4
8000ff82:	e0 8b 00 06 	brhi	8000ff8e <_malloc_r+0x82>
8000ff86:	ee 03 16 06 	lsr	r3,r7,0x6
8000ff8a:	2c 83       	sub	r3,-56
8000ff8c:	c1 f8       	rjmp	8000ffca <_malloc_r+0xbe>
8000ff8e:	59 43       	cp.w	r3,20
8000ff90:	e0 8b 00 04 	brhi	8000ff98 <_malloc_r+0x8c>
8000ff94:	2a 53       	sub	r3,-91
8000ff96:	c1 a8       	rjmp	8000ffca <_malloc_r+0xbe>
8000ff98:	e0 43 00 54 	cp.w	r3,84
8000ff9c:	e0 8b 00 06 	brhi	8000ffa8 <_malloc_r+0x9c>
8000ffa0:	ee 03 16 0c 	lsr	r3,r7,0xc
8000ffa4:	29 23       	sub	r3,-110
8000ffa6:	c1 28       	rjmp	8000ffca <_malloc_r+0xbe>
8000ffa8:	e0 43 01 54 	cp.w	r3,340
8000ffac:	e0 8b 00 06 	brhi	8000ffb8 <_malloc_r+0xac>
8000ffb0:	ee 03 16 0f 	lsr	r3,r7,0xf
8000ffb4:	28 93       	sub	r3,-119
8000ffb6:	c0 a8       	rjmp	8000ffca <_malloc_r+0xbe>
8000ffb8:	e0 43 05 54 	cp.w	r3,1364
8000ffbc:	e0 88 00 04 	brls	8000ffc4 <_malloc_r+0xb8>
8000ffc0:	37 e3       	mov	r3,126
8000ffc2:	c0 48       	rjmp	8000ffca <_malloc_r+0xbe>
8000ffc4:	ee 03 16 12 	lsr	r3,r7,0x12
8000ffc8:	28 43       	sub	r3,-124
8000ffca:	e0 6a 01 50 	mov	r10,336
8000ffce:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000ffd2:	74 36       	ld.w	r6,r10[0xc]
8000ffd4:	c1 98       	rjmp	80010006 <_malloc_r+0xfa>
8000ffd6:	6c 19       	ld.w	r9,r6[0x4]
8000ffd8:	e0 19 ff fc 	andl	r9,0xfffc
8000ffdc:	f2 07 01 0b 	sub	r11,r9,r7
8000ffe0:	58 fb       	cp.w	r11,15
8000ffe2:	e0 8a 00 04 	brle	8000ffea <_malloc_r+0xde>
8000ffe6:	20 13       	sub	r3,1
8000ffe8:	c1 18       	rjmp	8001000a <_malloc_r+0xfe>
8000ffea:	6c 38       	ld.w	r8,r6[0xc]
8000ffec:	58 0b       	cp.w	r11,0
8000ffee:	c0 b5       	brlt	80010004 <_malloc_r+0xf8>
8000fff0:	6c 2a       	ld.w	r10,r6[0x8]
8000fff2:	ec 09 00 09 	add	r9,r6,r9
8000fff6:	0a 9c       	mov	r12,r5
8000fff8:	91 2a       	st.w	r8[0x8],r10
8000fffa:	95 38       	st.w	r10[0xc],r8
8000fffc:	72 18       	ld.w	r8,r9[0x4]
8000fffe:	a1 a8       	sbr	r8,0x0
80010000:	93 18       	st.w	r9[0x4],r8
80010002:	cb c8       	rjmp	8001017a <_malloc_r+0x26e>
80010004:	10 96       	mov	r6,r8
80010006:	14 36       	cp.w	r6,r10
80010008:	ce 71       	brne	8000ffd6 <_malloc_r+0xca>
8001000a:	2f f3       	sub	r3,-1
8001000c:	e0 6a 01 50 	mov	r10,336
80010010:	f4 cc ff f8 	sub	r12,r10,-8
80010014:	78 26       	ld.w	r6,r12[0x8]
80010016:	18 36       	cp.w	r6,r12
80010018:	c6 c0       	breq	800100f0 <_malloc_r+0x1e4>
8001001a:	6c 19       	ld.w	r9,r6[0x4]
8001001c:	e0 19 ff fc 	andl	r9,0xfffc
80010020:	f2 07 01 08 	sub	r8,r9,r7
80010024:	58 f8       	cp.w	r8,15
80010026:	e0 89 00 8f 	brgt	80010144 <_malloc_r+0x238>
8001002a:	99 3c       	st.w	r12[0xc],r12
8001002c:	99 2c       	st.w	r12[0x8],r12
8001002e:	58 08       	cp.w	r8,0
80010030:	c0 55       	brlt	8001003a <_malloc_r+0x12e>
80010032:	ec 09 00 09 	add	r9,r6,r9
80010036:	0a 9c       	mov	r12,r5
80010038:	ce 2b       	rjmp	8000fffc <_malloc_r+0xf0>
8001003a:	e0 49 01 ff 	cp.w	r9,511
8001003e:	e0 8b 00 13 	brhi	80010064 <_malloc_r+0x158>
80010042:	a3 99       	lsr	r9,0x3
80010044:	f4 09 00 38 	add	r8,r10,r9<<0x3
80010048:	70 2b       	ld.w	r11,r8[0x8]
8001004a:	8d 38       	st.w	r6[0xc],r8
8001004c:	8d 2b       	st.w	r6[0x8],r11
8001004e:	97 36       	st.w	r11[0xc],r6
80010050:	91 26       	st.w	r8[0x8],r6
80010052:	a3 49       	asr	r9,0x2
80010054:	74 18       	ld.w	r8,r10[0x4]
80010056:	30 1b       	mov	r11,1
80010058:	f6 09 09 49 	lsl	r9,r11,r9
8001005c:	f1 e9 10 09 	or	r9,r8,r9
80010060:	95 19       	st.w	r10[0x4],r9
80010062:	c4 78       	rjmp	800100f0 <_malloc_r+0x1e4>
80010064:	f2 0a 16 09 	lsr	r10,r9,0x9
80010068:	58 4a       	cp.w	r10,4
8001006a:	e0 8b 00 07 	brhi	80010078 <_malloc_r+0x16c>
8001006e:	f2 0a 16 06 	lsr	r10,r9,0x6
80010072:	2c 8a       	sub	r10,-56
80010074:	c2 08       	rjmp	800100b4 <_malloc_r+0x1a8>
80010076:	d7 03       	nop
80010078:	59 4a       	cp.w	r10,20
8001007a:	e0 8b 00 04 	brhi	80010082 <_malloc_r+0x176>
8001007e:	2a 5a       	sub	r10,-91
80010080:	c1 a8       	rjmp	800100b4 <_malloc_r+0x1a8>
80010082:	e0 4a 00 54 	cp.w	r10,84
80010086:	e0 8b 00 06 	brhi	80010092 <_malloc_r+0x186>
8001008a:	f2 0a 16 0c 	lsr	r10,r9,0xc
8001008e:	29 2a       	sub	r10,-110
80010090:	c1 28       	rjmp	800100b4 <_malloc_r+0x1a8>
80010092:	e0 4a 01 54 	cp.w	r10,340
80010096:	e0 8b 00 06 	brhi	800100a2 <_malloc_r+0x196>
8001009a:	f2 0a 16 0f 	lsr	r10,r9,0xf
8001009e:	28 9a       	sub	r10,-119
800100a0:	c0 a8       	rjmp	800100b4 <_malloc_r+0x1a8>
800100a2:	e0 4a 05 54 	cp.w	r10,1364
800100a6:	e0 88 00 04 	brls	800100ae <_malloc_r+0x1a2>
800100aa:	37 ea       	mov	r10,126
800100ac:	c0 48       	rjmp	800100b4 <_malloc_r+0x1a8>
800100ae:	f2 0a 16 12 	lsr	r10,r9,0x12
800100b2:	28 4a       	sub	r10,-124
800100b4:	e0 6b 01 50 	mov	r11,336
800100b8:	f6 0a 00 34 	add	r4,r11,r10<<0x3
800100bc:	68 28       	ld.w	r8,r4[0x8]
800100be:	08 38       	cp.w	r8,r4
800100c0:	c0 e1       	brne	800100dc <_malloc_r+0x1d0>
800100c2:	76 19       	ld.w	r9,r11[0x4]
800100c4:	a3 4a       	asr	r10,0x2
800100c6:	30 1e       	mov	lr,1
800100c8:	fc 0a 09 4a 	lsl	r10,lr,r10
800100cc:	f3 ea 10 0a 	or	r10,r9,r10
800100d0:	10 99       	mov	r9,r8
800100d2:	97 1a       	st.w	r11[0x4],r10
800100d4:	c0 a8       	rjmp	800100e8 <_malloc_r+0x1dc>
800100d6:	70 28       	ld.w	r8,r8[0x8]
800100d8:	08 38       	cp.w	r8,r4
800100da:	c0 60       	breq	800100e6 <_malloc_r+0x1da>
800100dc:	70 1a       	ld.w	r10,r8[0x4]
800100de:	e0 1a ff fc 	andl	r10,0xfffc
800100e2:	14 39       	cp.w	r9,r10
800100e4:	cf 93       	brcs	800100d6 <_malloc_r+0x1ca>
800100e6:	70 39       	ld.w	r9,r8[0xc]
800100e8:	8d 39       	st.w	r6[0xc],r9
800100ea:	8d 28       	st.w	r6[0x8],r8
800100ec:	91 36       	st.w	r8[0xc],r6
800100ee:	93 26       	st.w	r9[0x8],r6
800100f0:	e6 08 14 02 	asr	r8,r3,0x2
800100f4:	30 1b       	mov	r11,1
800100f6:	e0 64 01 50 	mov	r4,336
800100fa:	f6 08 09 4b 	lsl	r11,r11,r8
800100fe:	68 18       	ld.w	r8,r4[0x4]
80010100:	10 3b       	cp.w	r11,r8
80010102:	e0 8b 00 69 	brhi	800101d4 <_malloc_r+0x2c8>
80010106:	f7 e8 00 09 	and	r9,r11,r8
8001010a:	c0 b1       	brne	80010120 <_malloc_r+0x214>
8001010c:	e0 13 ff fc 	andl	r3,0xfffc
80010110:	a1 7b       	lsl	r11,0x1
80010112:	2f c3       	sub	r3,-4
80010114:	c0 38       	rjmp	8001011a <_malloc_r+0x20e>
80010116:	2f c3       	sub	r3,-4
80010118:	a1 7b       	lsl	r11,0x1
8001011a:	f7 e8 00 09 	and	r9,r11,r8
8001011e:	cf c0       	breq	80010116 <_malloc_r+0x20a>
80010120:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80010124:	06 92       	mov	r2,r3
80010126:	1c 91       	mov	r1,lr
80010128:	62 36       	ld.w	r6,r1[0xc]
8001012a:	c2 d8       	rjmp	80010184 <_malloc_r+0x278>
8001012c:	6c 1a       	ld.w	r10,r6[0x4]
8001012e:	e0 1a ff fc 	andl	r10,0xfffc
80010132:	f4 07 01 08 	sub	r8,r10,r7
80010136:	58 f8       	cp.w	r8,15
80010138:	e0 8a 00 15 	brle	80010162 <_malloc_r+0x256>
8001013c:	6c 3a       	ld.w	r10,r6[0xc]
8001013e:	6c 29       	ld.w	r9,r6[0x8]
80010140:	95 29       	st.w	r10[0x8],r9
80010142:	93 3a       	st.w	r9[0xc],r10
80010144:	0e 99       	mov	r9,r7
80010146:	ec 07 00 07 	add	r7,r6,r7
8001014a:	a1 a9       	sbr	r9,0x0
8001014c:	99 37       	st.w	r12[0xc],r7
8001014e:	99 27       	st.w	r12[0x8],r7
80010150:	8d 19       	st.w	r6[0x4],r9
80010152:	ee 08 09 08 	st.w	r7[r8],r8
80010156:	8f 2c       	st.w	r7[0x8],r12
80010158:	8f 3c       	st.w	r7[0xc],r12
8001015a:	a1 a8       	sbr	r8,0x0
8001015c:	0a 9c       	mov	r12,r5
8001015e:	8f 18       	st.w	r7[0x4],r8
80010160:	c0 d8       	rjmp	8001017a <_malloc_r+0x26e>
80010162:	6c 39       	ld.w	r9,r6[0xc]
80010164:	58 08       	cp.w	r8,0
80010166:	c0 e5       	brlt	80010182 <_malloc_r+0x276>
80010168:	ec 0a 00 0a 	add	r10,r6,r10
8001016c:	74 18       	ld.w	r8,r10[0x4]
8001016e:	a1 a8       	sbr	r8,0x0
80010170:	0a 9c       	mov	r12,r5
80010172:	95 18       	st.w	r10[0x4],r8
80010174:	6c 28       	ld.w	r8,r6[0x8]
80010176:	93 28       	st.w	r9[0x8],r8
80010178:	91 39       	st.w	r8[0xc],r9
8001017a:	c8 dd       	rcall	80010494 <__malloc_unlock>
8001017c:	ec cc ff f8 	sub	r12,r6,-8
80010180:	d8 32       	popm	r0-r7,pc
80010182:	12 96       	mov	r6,r9
80010184:	02 36       	cp.w	r6,r1
80010186:	cd 31       	brne	8001012c <_malloc_r+0x220>
80010188:	2f f2       	sub	r2,-1
8001018a:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
8001018e:	c0 30       	breq	80010194 <_malloc_r+0x288>
80010190:	2f 81       	sub	r1,-8
80010192:	cc bb       	rjmp	80010128 <_malloc_r+0x21c>
80010194:	1c 98       	mov	r8,lr
80010196:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
8001019a:	c0 81       	brne	800101aa <_malloc_r+0x29e>
8001019c:	68 19       	ld.w	r9,r4[0x4]
8001019e:	f6 08 11 ff 	rsub	r8,r11,-1
800101a2:	f3 e8 00 08 	and	r8,r9,r8
800101a6:	89 18       	st.w	r4[0x4],r8
800101a8:	c0 78       	rjmp	800101b6 <_malloc_r+0x2aa>
800101aa:	f0 c9 00 08 	sub	r9,r8,8
800101ae:	20 13       	sub	r3,1
800101b0:	70 08       	ld.w	r8,r8[0x0]
800101b2:	12 38       	cp.w	r8,r9
800101b4:	cf 10       	breq	80010196 <_malloc_r+0x28a>
800101b6:	a1 7b       	lsl	r11,0x1
800101b8:	68 18       	ld.w	r8,r4[0x4]
800101ba:	10 3b       	cp.w	r11,r8
800101bc:	e0 8b 00 0c 	brhi	800101d4 <_malloc_r+0x2c8>
800101c0:	58 0b       	cp.w	r11,0
800101c2:	c0 90       	breq	800101d4 <_malloc_r+0x2c8>
800101c4:	04 93       	mov	r3,r2
800101c6:	c0 38       	rjmp	800101cc <_malloc_r+0x2c0>
800101c8:	2f c3       	sub	r3,-4
800101ca:	a1 7b       	lsl	r11,0x1
800101cc:	f7 e8 00 09 	and	r9,r11,r8
800101d0:	ca 81       	brne	80010120 <_malloc_r+0x214>
800101d2:	cf bb       	rjmp	800101c8 <_malloc_r+0x2bc>
800101d4:	68 23       	ld.w	r3,r4[0x8]
800101d6:	66 12       	ld.w	r2,r3[0x4]
800101d8:	e0 12 ff fc 	andl	r2,0xfffc
800101dc:	0e 32       	cp.w	r2,r7
800101de:	5f 39       	srlo	r9
800101e0:	e4 07 01 08 	sub	r8,r2,r7
800101e4:	58 f8       	cp.w	r8,15
800101e6:	5f aa       	srle	r10
800101e8:	f5 e9 10 09 	or	r9,r10,r9
800101ec:	e0 80 00 9a 	breq	80010320 <_malloc_r+0x414>
800101f0:	e0 68 0a 8c 	mov	r8,2700
800101f4:	70 01       	ld.w	r1,r8[0x0]
800101f6:	e0 68 05 5c 	mov	r8,1372
800101fa:	2f 01       	sub	r1,-16
800101fc:	70 08       	ld.w	r8,r8[0x0]
800101fe:	0e 01       	add	r1,r7
80010200:	5b f8       	cp.w	r8,-1
80010202:	c0 40       	breq	8001020a <_malloc_r+0x2fe>
80010204:	28 11       	sub	r1,-127
80010206:	e0 11 ff 80 	andl	r1,0xff80
8001020a:	02 9b       	mov	r11,r1
8001020c:	0a 9c       	mov	r12,r5
8001020e:	e0 a0 02 ad 	rcall	80010768 <_sbrk_r>
80010212:	18 96       	mov	r6,r12
80010214:	5b fc       	cp.w	r12,-1
80010216:	c7 50       	breq	80010300 <_malloc_r+0x3f4>
80010218:	e6 02 00 08 	add	r8,r3,r2
8001021c:	10 3c       	cp.w	r12,r8
8001021e:	c0 32       	brcc	80010224 <_malloc_r+0x318>
80010220:	08 33       	cp.w	r3,r4
80010222:	c6 f1       	brne	80010300 <_malloc_r+0x3f4>
80010224:	e0 6a 0a 90 	mov	r10,2704
80010228:	74 09       	ld.w	r9,r10[0x0]
8001022a:	e2 09 00 09 	add	r9,r1,r9
8001022e:	95 09       	st.w	r10[0x0],r9
80010230:	10 36       	cp.w	r6,r8
80010232:	c0 a1       	brne	80010246 <_malloc_r+0x33a>
80010234:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80010238:	c0 71       	brne	80010246 <_malloc_r+0x33a>
8001023a:	e2 02 00 02 	add	r2,r1,r2
8001023e:	68 28       	ld.w	r8,r4[0x8]
80010240:	a1 a2       	sbr	r2,0x0
80010242:	91 12       	st.w	r8[0x4],r2
80010244:	c4 f8       	rjmp	800102e2 <_malloc_r+0x3d6>
80010246:	e0 6a 05 5c 	mov	r10,1372
8001024a:	74 0b       	ld.w	r11,r10[0x0]
8001024c:	5b fb       	cp.w	r11,-1
8001024e:	c0 31       	brne	80010254 <_malloc_r+0x348>
80010250:	95 06       	st.w	r10[0x0],r6
80010252:	c0 78       	rjmp	80010260 <_malloc_r+0x354>
80010254:	ec 09 00 09 	add	r9,r6,r9
80010258:	e0 6a 0a 90 	mov	r10,2704
8001025c:	10 19       	sub	r9,r8
8001025e:	95 09       	st.w	r10[0x0],r9
80010260:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80010264:	f0 09 11 08 	rsub	r9,r8,8
80010268:	58 08       	cp.w	r8,0
8001026a:	f2 08 17 10 	movne	r8,r9
8001026e:	ed d8 e1 06 	addne	r6,r6,r8
80010272:	28 08       	sub	r8,-128
80010274:	ec 01 00 01 	add	r1,r6,r1
80010278:	0a 9c       	mov	r12,r5
8001027a:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8001027e:	f0 01 01 01 	sub	r1,r8,r1
80010282:	02 9b       	mov	r11,r1
80010284:	e0 a0 02 72 	rcall	80010768 <_sbrk_r>
80010288:	e0 68 0a 90 	mov	r8,2704
8001028c:	5b fc       	cp.w	r12,-1
8001028e:	ec 0c 17 00 	moveq	r12,r6
80010292:	f9 b1 00 00 	moveq	r1,0
80010296:	70 09       	ld.w	r9,r8[0x0]
80010298:	0c 1c       	sub	r12,r6
8001029a:	89 26       	st.w	r4[0x8],r6
8001029c:	02 0c       	add	r12,r1
8001029e:	12 01       	add	r1,r9
800102a0:	a1 ac       	sbr	r12,0x0
800102a2:	91 01       	st.w	r8[0x0],r1
800102a4:	8d 1c       	st.w	r6[0x4],r12
800102a6:	08 33       	cp.w	r3,r4
800102a8:	c1 d0       	breq	800102e2 <_malloc_r+0x3d6>
800102aa:	58 f2       	cp.w	r2,15
800102ac:	e0 8b 00 05 	brhi	800102b6 <_malloc_r+0x3aa>
800102b0:	30 18       	mov	r8,1
800102b2:	8d 18       	st.w	r6[0x4],r8
800102b4:	c2 68       	rjmp	80010300 <_malloc_r+0x3f4>
800102b6:	30 59       	mov	r9,5
800102b8:	20 c2       	sub	r2,12
800102ba:	e0 12 ff f8 	andl	r2,0xfff8
800102be:	e6 02 00 08 	add	r8,r3,r2
800102c2:	91 29       	st.w	r8[0x8],r9
800102c4:	91 19       	st.w	r8[0x4],r9
800102c6:	66 18       	ld.w	r8,r3[0x4]
800102c8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800102cc:	e5 e8 10 08 	or	r8,r2,r8
800102d0:	87 18       	st.w	r3[0x4],r8
800102d2:	58 f2       	cp.w	r2,15
800102d4:	e0 88 00 07 	brls	800102e2 <_malloc_r+0x3d6>
800102d8:	e6 cb ff f8 	sub	r11,r3,-8
800102dc:	0a 9c       	mov	r12,r5
800102de:	e0 a0 29 7f 	rcall	800155dc <_free_r>
800102e2:	e0 69 0a 88 	mov	r9,2696
800102e6:	72 0a       	ld.w	r10,r9[0x0]
800102e8:	e0 68 0a 90 	mov	r8,2704
800102ec:	70 08       	ld.w	r8,r8[0x0]
800102ee:	14 38       	cp.w	r8,r10
800102f0:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800102f4:	e0 69 0a 84 	mov	r9,2692
800102f8:	72 0a       	ld.w	r10,r9[0x0]
800102fa:	14 38       	cp.w	r8,r10
800102fc:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80010300:	68 28       	ld.w	r8,r4[0x8]
80010302:	70 18       	ld.w	r8,r8[0x4]
80010304:	e0 18 ff fc 	andl	r8,0xfffc
80010308:	0e 38       	cp.w	r8,r7
8001030a:	5f 39       	srlo	r9
8001030c:	0e 18       	sub	r8,r7
8001030e:	58 f8       	cp.w	r8,15
80010310:	5f aa       	srle	r10
80010312:	f5 e9 10 09 	or	r9,r10,r9
80010316:	c0 50       	breq	80010320 <_malloc_r+0x414>
80010318:	0a 9c       	mov	r12,r5
8001031a:	cb dc       	rcall	80010494 <__malloc_unlock>
8001031c:	d8 3a       	popm	r0-r7,pc,r12=0
8001031e:	d7 03       	nop
80010320:	68 26       	ld.w	r6,r4[0x8]
80010322:	a1 a8       	sbr	r8,0x0
80010324:	0e 99       	mov	r9,r7
80010326:	a1 a9       	sbr	r9,0x0
80010328:	8d 19       	st.w	r6[0x4],r9
8001032a:	ec 07 00 07 	add	r7,r6,r7
8001032e:	0a 9c       	mov	r12,r5
80010330:	89 27       	st.w	r4[0x8],r7
80010332:	8f 18       	st.w	r7[0x4],r8
80010334:	cb 0c       	rcall	80010494 <__malloc_unlock>
80010336:	ec cc ff f8 	sub	r12,r6,-8
8001033a:	d8 32       	popm	r0-r7,pc

8001033c <memcpy>:
8001033c:	58 8a       	cp.w	r10,8
8001033e:	c2 f5       	brlt	8001039c <memcpy+0x60>
80010340:	f9 eb 10 09 	or	r9,r12,r11
80010344:	e2 19 00 03 	andl	r9,0x3,COH
80010348:	e0 81 00 97 	brne	80010476 <memcpy+0x13a>
8001034c:	e0 4a 00 20 	cp.w	r10,32
80010350:	c3 b4       	brge	800103c6 <memcpy+0x8a>
80010352:	f4 08 14 02 	asr	r8,r10,0x2
80010356:	f0 09 11 08 	rsub	r9,r8,8
8001035a:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8001035e:	76 69       	ld.w	r9,r11[0x18]
80010360:	99 69       	st.w	r12[0x18],r9
80010362:	76 59       	ld.w	r9,r11[0x14]
80010364:	99 59       	st.w	r12[0x14],r9
80010366:	76 49       	ld.w	r9,r11[0x10]
80010368:	99 49       	st.w	r12[0x10],r9
8001036a:	76 39       	ld.w	r9,r11[0xc]
8001036c:	99 39       	st.w	r12[0xc],r9
8001036e:	76 29       	ld.w	r9,r11[0x8]
80010370:	99 29       	st.w	r12[0x8],r9
80010372:	76 19       	ld.w	r9,r11[0x4]
80010374:	99 19       	st.w	r12[0x4],r9
80010376:	76 09       	ld.w	r9,r11[0x0]
80010378:	99 09       	st.w	r12[0x0],r9
8001037a:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8001037e:	f8 08 00 28 	add	r8,r12,r8<<0x2
80010382:	e0 1a 00 03 	andl	r10,0x3
80010386:	f4 0a 11 04 	rsub	r10,r10,4
8001038a:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8001038e:	17 a9       	ld.ub	r9,r11[0x2]
80010390:	b0 a9       	st.b	r8[0x2],r9
80010392:	17 99       	ld.ub	r9,r11[0x1]
80010394:	b0 99       	st.b	r8[0x1],r9
80010396:	17 89       	ld.ub	r9,r11[0x0]
80010398:	b0 89       	st.b	r8[0x0],r9
8001039a:	5e fc       	retal	r12
8001039c:	f4 0a 11 09 	rsub	r10,r10,9
800103a0:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800103a4:	17 f9       	ld.ub	r9,r11[0x7]
800103a6:	b8 f9       	st.b	r12[0x7],r9
800103a8:	17 e9       	ld.ub	r9,r11[0x6]
800103aa:	b8 e9       	st.b	r12[0x6],r9
800103ac:	17 d9       	ld.ub	r9,r11[0x5]
800103ae:	b8 d9       	st.b	r12[0x5],r9
800103b0:	17 c9       	ld.ub	r9,r11[0x4]
800103b2:	b8 c9       	st.b	r12[0x4],r9
800103b4:	17 b9       	ld.ub	r9,r11[0x3]
800103b6:	b8 b9       	st.b	r12[0x3],r9
800103b8:	17 a9       	ld.ub	r9,r11[0x2]
800103ba:	b8 a9       	st.b	r12[0x2],r9
800103bc:	17 99       	ld.ub	r9,r11[0x1]
800103be:	b8 99       	st.b	r12[0x1],r9
800103c0:	17 89       	ld.ub	r9,r11[0x0]
800103c2:	b8 89       	st.b	r12[0x0],r9
800103c4:	5e fc       	retal	r12
800103c6:	eb cd 40 c0 	pushm	r6-r7,lr
800103ca:	18 99       	mov	r9,r12
800103cc:	22 0a       	sub	r10,32
800103ce:	b7 07       	ld.d	r6,r11++
800103d0:	b3 26       	st.d	r9++,r6
800103d2:	b7 07       	ld.d	r6,r11++
800103d4:	b3 26       	st.d	r9++,r6
800103d6:	b7 07       	ld.d	r6,r11++
800103d8:	b3 26       	st.d	r9++,r6
800103da:	b7 07       	ld.d	r6,r11++
800103dc:	b3 26       	st.d	r9++,r6
800103de:	22 0a       	sub	r10,32
800103e0:	cf 74       	brge	800103ce <memcpy+0x92>
800103e2:	2f 0a       	sub	r10,-16
800103e4:	c0 65       	brlt	800103f0 <memcpy+0xb4>
800103e6:	b7 07       	ld.d	r6,r11++
800103e8:	b3 26       	st.d	r9++,r6
800103ea:	b7 07       	ld.d	r6,r11++
800103ec:	b3 26       	st.d	r9++,r6
800103ee:	21 0a       	sub	r10,16
800103f0:	5c 3a       	neg	r10
800103f2:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800103f6:	d7 03       	nop
800103f8:	d7 03       	nop
800103fa:	f7 36 00 0e 	ld.ub	r6,r11[14]
800103fe:	f3 66 00 0e 	st.b	r9[14],r6
80010402:	f7 36 00 0d 	ld.ub	r6,r11[13]
80010406:	f3 66 00 0d 	st.b	r9[13],r6
8001040a:	f7 36 00 0c 	ld.ub	r6,r11[12]
8001040e:	f3 66 00 0c 	st.b	r9[12],r6
80010412:	f7 36 00 0b 	ld.ub	r6,r11[11]
80010416:	f3 66 00 0b 	st.b	r9[11],r6
8001041a:	f7 36 00 0a 	ld.ub	r6,r11[10]
8001041e:	f3 66 00 0a 	st.b	r9[10],r6
80010422:	f7 36 00 09 	ld.ub	r6,r11[9]
80010426:	f3 66 00 09 	st.b	r9[9],r6
8001042a:	f7 36 00 08 	ld.ub	r6,r11[8]
8001042e:	f3 66 00 08 	st.b	r9[8],r6
80010432:	f7 36 00 07 	ld.ub	r6,r11[7]
80010436:	f3 66 00 07 	st.b	r9[7],r6
8001043a:	f7 36 00 06 	ld.ub	r6,r11[6]
8001043e:	f3 66 00 06 	st.b	r9[6],r6
80010442:	f7 36 00 05 	ld.ub	r6,r11[5]
80010446:	f3 66 00 05 	st.b	r9[5],r6
8001044a:	f7 36 00 04 	ld.ub	r6,r11[4]
8001044e:	f3 66 00 04 	st.b	r9[4],r6
80010452:	f7 36 00 03 	ld.ub	r6,r11[3]
80010456:	f3 66 00 03 	st.b	r9[3],r6
8001045a:	f7 36 00 02 	ld.ub	r6,r11[2]
8001045e:	f3 66 00 02 	st.b	r9[2],r6
80010462:	f7 36 00 01 	ld.ub	r6,r11[1]
80010466:	f3 66 00 01 	st.b	r9[1],r6
8001046a:	f7 36 00 00 	ld.ub	r6,r11[0]
8001046e:	f3 66 00 00 	st.b	r9[0],r6
80010472:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80010476:	20 1a       	sub	r10,1
80010478:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8001047c:	f8 0a 0b 09 	st.b	r12[r10],r9
80010480:	cf b1       	brne	80010476 <memcpy+0x13a>
80010482:	5e fc       	retal	r12

80010484 <memset>:
80010484:	18 98       	mov	r8,r12
80010486:	c0 38       	rjmp	8001048c <memset+0x8>
80010488:	10 cb       	st.b	r8++,r11
8001048a:	20 1a       	sub	r10,1
8001048c:	58 0a       	cp.w	r10,0
8001048e:	cf d1       	brne	80010488 <memset+0x4>
80010490:	5e fc       	retal	r12

80010492 <__malloc_lock>:
80010492:	5e fc       	retal	r12

80010494 <__malloc_unlock>:
80010494:	5e fc       	retal	r12
80010496:	d7 03       	nop

80010498 <realloc>:
80010498:	d4 01       	pushm	lr
8001049a:	e0 68 01 4c 	mov	r8,332
8001049e:	16 9a       	mov	r10,r11
800104a0:	18 9b       	mov	r11,r12
800104a2:	70 0c       	ld.w	r12,r8[0x0]
800104a4:	c0 2c       	rcall	800104a8 <_realloc_r>
800104a6:	d8 02       	popm	pc

800104a8 <_realloc_r>:
800104a8:	d4 31       	pushm	r0-r7,lr
800104aa:	20 1d       	sub	sp,4
800104ac:	16 94       	mov	r4,r11
800104ae:	18 92       	mov	r2,r12
800104b0:	14 9b       	mov	r11,r10
800104b2:	58 04       	cp.w	r4,0
800104b4:	c0 51       	brne	800104be <_realloc_r+0x16>
800104b6:	fe b0 fd 2b 	rcall	8000ff0c <_malloc_r>
800104ba:	18 95       	mov	r5,r12
800104bc:	c5 29       	rjmp	80010760 <_realloc_r+0x2b8>
800104be:	50 0a       	stdsp	sp[0x0],r10
800104c0:	ce 9f       	rcall	80010492 <__malloc_lock>
800104c2:	40 0b       	lddsp	r11,sp[0x0]
800104c4:	f6 c8 ff f5 	sub	r8,r11,-11
800104c8:	e8 c1 00 08 	sub	r1,r4,8
800104cc:	10 96       	mov	r6,r8
800104ce:	62 1c       	ld.w	r12,r1[0x4]
800104d0:	e0 16 ff f8 	andl	r6,0xfff8
800104d4:	59 68       	cp.w	r8,22
800104d6:	f9 b6 08 10 	movls	r6,16
800104da:	16 36       	cp.w	r6,r11
800104dc:	5f 38       	srlo	r8
800104de:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
800104e2:	c0 50       	breq	800104ec <_realloc_r+0x44>
800104e4:	30 c8       	mov	r8,12
800104e6:	30 05       	mov	r5,0
800104e8:	85 38       	st.w	r2[0xc],r8
800104ea:	c3 b9       	rjmp	80010760 <_realloc_r+0x2b8>
800104ec:	18 90       	mov	r0,r12
800104ee:	e0 10 ff fc 	andl	r0,0xfffc
800104f2:	0c 30       	cp.w	r0,r6
800104f4:	e0 84 01 0c 	brge	8001070c <_realloc_r+0x264>
800104f8:	e0 68 01 50 	mov	r8,336
800104fc:	e2 00 00 09 	add	r9,r1,r0
80010500:	70 25       	ld.w	r5,r8[0x8]
80010502:	0a 39       	cp.w	r9,r5
80010504:	c0 90       	breq	80010516 <_realloc_r+0x6e>
80010506:	72 1a       	ld.w	r10,r9[0x4]
80010508:	a1 ca       	cbr	r10,0x0
8001050a:	f2 0a 00 0a 	add	r10,r9,r10
8001050e:	74 1a       	ld.w	r10,r10[0x4]
80010510:	ed ba 00 00 	bld	r10,0x0
80010514:	c2 20       	breq	80010558 <_realloc_r+0xb0>
80010516:	72 1a       	ld.w	r10,r9[0x4]
80010518:	e0 1a ff fc 	andl	r10,0xfffc
8001051c:	f4 00 00 03 	add	r3,r10,r0
80010520:	0a 39       	cp.w	r9,r5
80010522:	c1 31       	brne	80010548 <_realloc_r+0xa0>
80010524:	ec c7 ff f0 	sub	r7,r6,-16
80010528:	0e 33       	cp.w	r3,r7
8001052a:	c1 95       	brlt	8001055c <_realloc_r+0xb4>
8001052c:	e2 06 00 09 	add	r9,r1,r6
80010530:	0c 13       	sub	r3,r6
80010532:	a1 a3       	sbr	r3,0x0
80010534:	93 13       	st.w	r9[0x4],r3
80010536:	91 29       	st.w	r8[0x8],r9
80010538:	04 9c       	mov	r12,r2
8001053a:	62 18       	ld.w	r8,r1[0x4]
8001053c:	08 95       	mov	r5,r4
8001053e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80010542:	10 46       	or	r6,r8
80010544:	83 16       	st.w	r1[0x4],r6
80010546:	c0 c9       	rjmp	8001075e <_realloc_r+0x2b6>
80010548:	0c 33       	cp.w	r3,r6
8001054a:	c0 95       	brlt	8001055c <_realloc_r+0xb4>
8001054c:	72 28       	ld.w	r8,r9[0x8]
8001054e:	02 97       	mov	r7,r1
80010550:	72 39       	ld.w	r9,r9[0xc]
80010552:	93 28       	st.w	r9[0x8],r8
80010554:	91 39       	st.w	r8[0xc],r9
80010556:	cd d8       	rjmp	80010710 <_realloc_r+0x268>
80010558:	30 0a       	mov	r10,0
8001055a:	14 99       	mov	r9,r10
8001055c:	ed bc 00 00 	bld	r12,0x0
80010560:	e0 80 00 96 	breq	8001068c <_realloc_r+0x1e4>
80010564:	62 07       	ld.w	r7,r1[0x0]
80010566:	e2 07 01 07 	sub	r7,r1,r7
8001056a:	6e 1c       	ld.w	r12,r7[0x4]
8001056c:	e0 1c ff fc 	andl	r12,0xfffc
80010570:	58 09       	cp.w	r9,0
80010572:	c5 70       	breq	80010620 <_realloc_r+0x178>
80010574:	f8 00 00 03 	add	r3,r12,r0
80010578:	0a 39       	cp.w	r9,r5
8001057a:	c4 81       	brne	8001060a <_realloc_r+0x162>
8001057c:	14 03       	add	r3,r10
8001057e:	ec c9 ff f0 	sub	r9,r6,-16
80010582:	12 33       	cp.w	r3,r9
80010584:	c4 e5       	brlt	80010620 <_realloc_r+0x178>
80010586:	6e 3a       	ld.w	r10,r7[0xc]
80010588:	6e 29       	ld.w	r9,r7[0x8]
8001058a:	95 29       	st.w	r10[0x8],r9
8001058c:	93 3a       	st.w	r9[0xc],r10
8001058e:	ee c5 ff f8 	sub	r5,r7,-8
80010592:	e0 ca 00 04 	sub	r10,r0,4
80010596:	e0 4a 00 24 	cp.w	r10,36
8001059a:	e0 8b 00 25 	brhi	800105e4 <_realloc_r+0x13c>
8001059e:	0a 99       	mov	r9,r5
800105a0:	59 3a       	cp.w	r10,19
800105a2:	e0 88 00 1a 	brls	800105d6 <_realloc_r+0x12e>
800105a6:	09 09       	ld.w	r9,r4++
800105a8:	8b 09       	st.w	r5[0x0],r9
800105aa:	09 09       	ld.w	r9,r4++
800105ac:	8f 39       	st.w	r7[0xc],r9
800105ae:	ee c9 ff f0 	sub	r9,r7,-16
800105b2:	59 ba       	cp.w	r10,27
800105b4:	e0 88 00 11 	brls	800105d6 <_realloc_r+0x12e>
800105b8:	09 0b       	ld.w	r11,r4++
800105ba:	93 0b       	st.w	r9[0x0],r11
800105bc:	09 09       	ld.w	r9,r4++
800105be:	8f 59       	st.w	r7[0x14],r9
800105c0:	ee c9 ff e8 	sub	r9,r7,-24
800105c4:	e0 4a 00 24 	cp.w	r10,36
800105c8:	c0 71       	brne	800105d6 <_realloc_r+0x12e>
800105ca:	09 0a       	ld.w	r10,r4++
800105cc:	93 0a       	st.w	r9[0x0],r10
800105ce:	ee c9 ff e0 	sub	r9,r7,-32
800105d2:	09 0a       	ld.w	r10,r4++
800105d4:	8f 7a       	st.w	r7[0x1c],r10
800105d6:	09 0a       	ld.w	r10,r4++
800105d8:	12 aa       	st.w	r9++,r10
800105da:	68 0a       	ld.w	r10,r4[0x0]
800105dc:	93 0a       	st.w	r9[0x0],r10
800105de:	68 1a       	ld.w	r10,r4[0x4]
800105e0:	93 1a       	st.w	r9[0x4],r10
800105e2:	c0 78       	rjmp	800105f0 <_realloc_r+0x148>
800105e4:	50 08       	stdsp	sp[0x0],r8
800105e6:	08 9b       	mov	r11,r4
800105e8:	0a 9c       	mov	r12,r5
800105ea:	e0 a0 2a 9c 	rcall	80015b22 <memmove>
800105ee:	40 08       	lddsp	r8,sp[0x0]
800105f0:	ee 06 00 09 	add	r9,r7,r6
800105f4:	0c 13       	sub	r3,r6
800105f6:	a1 a3       	sbr	r3,0x0
800105f8:	93 13       	st.w	r9[0x4],r3
800105fa:	91 29       	st.w	r8[0x8],r9
800105fc:	04 9c       	mov	r12,r2
800105fe:	6e 18       	ld.w	r8,r7[0x4]
80010600:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80010604:	10 46       	or	r6,r8
80010606:	8f 16       	st.w	r7[0x4],r6
80010608:	ca b8       	rjmp	8001075e <_realloc_r+0x2b6>
8001060a:	14 03       	add	r3,r10
8001060c:	0c 33       	cp.w	r3,r6
8001060e:	c0 95       	brlt	80010620 <_realloc_r+0x178>
80010610:	72 28       	ld.w	r8,r9[0x8]
80010612:	72 39       	ld.w	r9,r9[0xc]
80010614:	93 28       	st.w	r9[0x8],r8
80010616:	91 39       	st.w	r8[0xc],r9
80010618:	6e 28       	ld.w	r8,r7[0x8]
8001061a:	6e 39       	ld.w	r9,r7[0xc]
8001061c:	c0 88       	rjmp	8001062c <_realloc_r+0x184>
8001061e:	d7 03       	nop
80010620:	f8 00 00 03 	add	r3,r12,r0
80010624:	0c 33       	cp.w	r3,r6
80010626:	c3 35       	brlt	8001068c <_realloc_r+0x1e4>
80010628:	6e 39       	ld.w	r9,r7[0xc]
8001062a:	6e 28       	ld.w	r8,r7[0x8]
8001062c:	93 28       	st.w	r9[0x8],r8
8001062e:	91 39       	st.w	r8[0xc],r9
80010630:	e0 ca 00 04 	sub	r10,r0,4
80010634:	ee cc ff f8 	sub	r12,r7,-8
80010638:	e0 4a 00 24 	cp.w	r10,36
8001063c:	e0 8b 00 24 	brhi	80010684 <_realloc_r+0x1dc>
80010640:	59 3a       	cp.w	r10,19
80010642:	e0 88 00 1a 	brls	80010676 <_realloc_r+0x1ce>
80010646:	09 08       	ld.w	r8,r4++
80010648:	99 08       	st.w	r12[0x0],r8
8001064a:	09 08       	ld.w	r8,r4++
8001064c:	8f 38       	st.w	r7[0xc],r8
8001064e:	ee cc ff f0 	sub	r12,r7,-16
80010652:	59 ba       	cp.w	r10,27
80010654:	e0 88 00 11 	brls	80010676 <_realloc_r+0x1ce>
80010658:	09 08       	ld.w	r8,r4++
8001065a:	99 08       	st.w	r12[0x0],r8
8001065c:	09 08       	ld.w	r8,r4++
8001065e:	8f 58       	st.w	r7[0x14],r8
80010660:	ee cc ff e8 	sub	r12,r7,-24
80010664:	e0 4a 00 24 	cp.w	r10,36
80010668:	c0 71       	brne	80010676 <_realloc_r+0x1ce>
8001066a:	09 08       	ld.w	r8,r4++
8001066c:	99 08       	st.w	r12[0x0],r8
8001066e:	ee cc ff e0 	sub	r12,r7,-32
80010672:	09 08       	ld.w	r8,r4++
80010674:	8f 78       	st.w	r7[0x1c],r8
80010676:	09 08       	ld.w	r8,r4++
80010678:	18 a8       	st.w	r12++,r8
8001067a:	68 08       	ld.w	r8,r4[0x0]
8001067c:	99 08       	st.w	r12[0x0],r8
8001067e:	68 18       	ld.w	r8,r4[0x4]
80010680:	99 18       	st.w	r12[0x4],r8
80010682:	c4 78       	rjmp	80010710 <_realloc_r+0x268>
80010684:	08 9b       	mov	r11,r4
80010686:	e0 a0 2a 4e 	rcall	80015b22 <memmove>
8001068a:	c4 38       	rjmp	80010710 <_realloc_r+0x268>
8001068c:	04 9c       	mov	r12,r2
8001068e:	fe b0 fc 3f 	rcall	8000ff0c <_malloc_r>
80010692:	18 95       	mov	r5,r12
80010694:	c3 a0       	breq	80010708 <_realloc_r+0x260>
80010696:	62 18       	ld.w	r8,r1[0x4]
80010698:	f8 c9 00 08 	sub	r9,r12,8
8001069c:	a1 c8       	cbr	r8,0x0
8001069e:	e2 08 00 08 	add	r8,r1,r8
800106a2:	10 39       	cp.w	r9,r8
800106a4:	c0 71       	brne	800106b2 <_realloc_r+0x20a>
800106a6:	72 13       	ld.w	r3,r9[0x4]
800106a8:	02 97       	mov	r7,r1
800106aa:	e0 13 ff fc 	andl	r3,0xfffc
800106ae:	00 03       	add	r3,r0
800106b0:	c3 08       	rjmp	80010710 <_realloc_r+0x268>
800106b2:	e0 ca 00 04 	sub	r10,r0,4
800106b6:	e0 4a 00 24 	cp.w	r10,36
800106ba:	e0 8b 00 20 	brhi	800106fa <_realloc_r+0x252>
800106be:	08 99       	mov	r9,r4
800106c0:	18 98       	mov	r8,r12
800106c2:	59 3a       	cp.w	r10,19
800106c4:	e0 88 00 14 	brls	800106ec <_realloc_r+0x244>
800106c8:	13 0b       	ld.w	r11,r9++
800106ca:	10 ab       	st.w	r8++,r11
800106cc:	13 0b       	ld.w	r11,r9++
800106ce:	10 ab       	st.w	r8++,r11
800106d0:	59 ba       	cp.w	r10,27
800106d2:	e0 88 00 0d 	brls	800106ec <_realloc_r+0x244>
800106d6:	13 0b       	ld.w	r11,r9++
800106d8:	10 ab       	st.w	r8++,r11
800106da:	13 0b       	ld.w	r11,r9++
800106dc:	10 ab       	st.w	r8++,r11
800106de:	e0 4a 00 24 	cp.w	r10,36
800106e2:	c0 51       	brne	800106ec <_realloc_r+0x244>
800106e4:	13 0a       	ld.w	r10,r9++
800106e6:	10 aa       	st.w	r8++,r10
800106e8:	13 0a       	ld.w	r10,r9++
800106ea:	10 aa       	st.w	r8++,r10
800106ec:	13 0a       	ld.w	r10,r9++
800106ee:	10 aa       	st.w	r8++,r10
800106f0:	72 0a       	ld.w	r10,r9[0x0]
800106f2:	91 0a       	st.w	r8[0x0],r10
800106f4:	72 19       	ld.w	r9,r9[0x4]
800106f6:	91 19       	st.w	r8[0x4],r9
800106f8:	c0 48       	rjmp	80010700 <_realloc_r+0x258>
800106fa:	08 9b       	mov	r11,r4
800106fc:	e0 a0 2a 13 	rcall	80015b22 <memmove>
80010700:	08 9b       	mov	r11,r4
80010702:	04 9c       	mov	r12,r2
80010704:	e0 a0 27 6c 	rcall	800155dc <_free_r>
80010708:	04 9c       	mov	r12,r2
8001070a:	c2 a8       	rjmp	8001075e <_realloc_r+0x2b6>
8001070c:	00 93       	mov	r3,r0
8001070e:	02 97       	mov	r7,r1
80010710:	e6 06 01 09 	sub	r9,r3,r6
80010714:	6e 18       	ld.w	r8,r7[0x4]
80010716:	58 f9       	cp.w	r9,15
80010718:	e0 88 00 16 	brls	80010744 <_realloc_r+0x29c>
8001071c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80010720:	ed e8 10 08 	or	r8,r6,r8
80010724:	8f 18       	st.w	r7[0x4],r8
80010726:	12 98       	mov	r8,r9
80010728:	a1 a8       	sbr	r8,0x0
8001072a:	ee 06 00 0b 	add	r11,r7,r6
8001072e:	f6 09 00 09 	add	r9,r11,r9
80010732:	97 18       	st.w	r11[0x4],r8
80010734:	72 18       	ld.w	r8,r9[0x4]
80010736:	a1 a8       	sbr	r8,0x0
80010738:	2f 8b       	sub	r11,-8
8001073a:	93 18       	st.w	r9[0x4],r8
8001073c:	04 9c       	mov	r12,r2
8001073e:	e0 a0 27 4f 	rcall	800155dc <_free_r>
80010742:	c0 b8       	rjmp	80010758 <_realloc_r+0x2b0>
80010744:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80010748:	e7 e8 10 08 	or	r8,r3,r8
8001074c:	8f 18       	st.w	r7[0x4],r8
8001074e:	ee 03 00 03 	add	r3,r7,r3
80010752:	66 18       	ld.w	r8,r3[0x4]
80010754:	a1 a8       	sbr	r8,0x0
80010756:	87 18       	st.w	r3[0x4],r8
80010758:	04 9c       	mov	r12,r2
8001075a:	ee c5 ff f8 	sub	r5,r7,-8
8001075e:	c9 be       	rcall	80010494 <__malloc_unlock>
80010760:	0a 9c       	mov	r12,r5
80010762:	2f fd       	sub	sp,-4
80010764:	d8 32       	popm	r0-r7,pc
80010766:	d7 03       	nop

80010768 <_sbrk_r>:
80010768:	d4 21       	pushm	r4-r7,lr
8001076a:	30 08       	mov	r8,0
8001076c:	18 97       	mov	r7,r12
8001076e:	e0 66 12 10 	mov	r6,4624
80010772:	16 9c       	mov	r12,r11
80010774:	8d 08       	st.w	r6[0x0],r8
80010776:	c9 bc       	rcall	800108ac <_sbrk>
80010778:	5b fc       	cp.w	r12,-1
8001077a:	c0 51       	brne	80010784 <_sbrk_r+0x1c>
8001077c:	6c 08       	ld.w	r8,r6[0x0]
8001077e:	58 08       	cp.w	r8,0
80010780:	ef f8 1a 03 	st.wne	r7[0xc],r8
80010784:	d8 22       	popm	r4-r7,pc
80010786:	d7 03       	nop

80010788 <sprintf>:
80010788:	d4 01       	pushm	lr
8001078a:	21 7d       	sub	sp,92
8001078c:	e0 68 ff ff 	mov	r8,65535
80010790:	ea 18 7f ff 	orh	r8,0x7fff
80010794:	50 58       	stdsp	sp[0x14],r8
80010796:	50 28       	stdsp	sp[0x8],r8
80010798:	e0 68 02 08 	mov	r8,520
8001079c:	ba 68       	st.h	sp[0xc],r8
8001079e:	3f f8       	mov	r8,-1
800107a0:	ba 78       	st.h	sp[0xe],r8
800107a2:	e0 68 01 4c 	mov	r8,332
800107a6:	50 4c       	stdsp	sp[0x10],r12
800107a8:	16 9a       	mov	r10,r11
800107aa:	50 0c       	stdsp	sp[0x0],r12
800107ac:	fa c9 ff a0 	sub	r9,sp,-96
800107b0:	70 0c       	ld.w	r12,r8[0x0]
800107b2:	1a 9b       	mov	r11,sp
800107b4:	e0 a0 0f 1e 	rcall	800125f0 <_vfprintf_r>
800107b8:	30 09       	mov	r9,0
800107ba:	40 08       	lddsp	r8,sp[0x0]
800107bc:	b0 89       	st.b	r8[0x0],r9
800107be:	2e 9d       	sub	sp,-92
800107c0:	d8 02       	popm	pc
800107c2:	d7 03       	nop

800107c4 <strlen>:
800107c4:	30 09       	mov	r9,0
800107c6:	18 98       	mov	r8,r12
800107c8:	c0 28       	rjmp	800107cc <strlen+0x8>
800107ca:	2f f8       	sub	r8,-1
800107cc:	11 8a       	ld.ub	r10,r8[0x0]
800107ce:	f2 0a 18 00 	cp.b	r10,r9
800107d2:	cf c1       	brne	800107ca <strlen+0x6>
800107d4:	f0 0c 01 0c 	sub	r12,r8,r12
800107d8:	5e fc       	retal	r12

800107da <_exit>:
800107da:	30 d8       	mov	r8,13
800107dc:	d6 73       	breakpoint
800107de:	3f fc       	mov	r12,-1
800107e0:	35 8b       	mov	r11,88
800107e2:	c0 08       	rjmp	800107e2 <_exit+0x8>

800107e4 <_close>:
800107e4:	30 28       	mov	r8,2
800107e6:	d6 73       	breakpoint
800107e8:	3f fc       	mov	r12,-1
800107ea:	35 8b       	mov	r11,88
800107ec:	58 0c       	cp.w	r12,0
800107ee:	5e 4c       	retge	r12
800107f0:	e0 6a 12 10 	mov	r10,4624
800107f4:	95 0b       	st.w	r10[0x0],r11
800107f6:	5e fc       	retal	r12

800107f8 <_lseek>:
800107f8:	30 58       	mov	r8,5
800107fa:	d6 73       	breakpoint
800107fc:	3f fc       	mov	r12,-1
800107fe:	35 8b       	mov	r11,88
80010800:	58 0c       	cp.w	r12,0
80010802:	5e 4c       	retge	r12
80010804:	e0 6a 12 10 	mov	r10,4624
80010808:	95 0b       	st.w	r10[0x0],r11
8001080a:	5e fc       	retal	r12

8001080c <_read>:
8001080c:	30 38       	mov	r8,3
8001080e:	d6 73       	breakpoint
80010810:	3f fc       	mov	r12,-1
80010812:	35 8b       	mov	r11,88
80010814:	58 0c       	cp.w	r12,0
80010816:	5e 4c       	retge	r12
80010818:	e0 6a 12 10 	mov	r10,4624
8001081c:	95 0b       	st.w	r10[0x0],r11
8001081e:	5e fc       	retal	r12

80010820 <_write>:
80010820:	30 48       	mov	r8,4
80010822:	d6 73       	breakpoint
80010824:	3f fc       	mov	r12,-1
80010826:	35 8b       	mov	r11,88
80010828:	58 0c       	cp.w	r12,0
8001082a:	5e 4c       	retge	r12
8001082c:	e0 6a 12 10 	mov	r10,4624
80010830:	95 0b       	st.w	r10[0x0],r11
80010832:	5e fc       	retal	r12

80010834 <isatty>:
80010834:	30 b8       	mov	r8,11
80010836:	d6 73       	breakpoint
80010838:	3f fc       	mov	r12,-1
8001083a:	35 8b       	mov	r11,88
8001083c:	58 0c       	cp.w	r12,0
8001083e:	5e 4c       	retge	r12
80010840:	e0 6a 12 10 	mov	r10,4624
80010844:	95 0b       	st.w	r10[0x0],r11
80010846:	5e fc       	retal	r12

80010848 <_fstat_host>:
80010848:	30 98       	mov	r8,9
8001084a:	d6 73       	breakpoint
8001084c:	3f fc       	mov	r12,-1
8001084e:	35 8b       	mov	r11,88
80010850:	58 0c       	cp.w	r12,0
80010852:	5e 4c       	retge	r12
80010854:	e0 6a 12 10 	mov	r10,4624
80010858:	95 0b       	st.w	r10[0x0],r11
8001085a:	5e fc       	retal	r12

8001085c <_fstat>:
8001085c:	d4 21       	pushm	r4-r7,lr
8001085e:	21 0d       	sub	sp,64
80010860:	16 97       	mov	r7,r11
80010862:	1a 9b       	mov	r11,sp
80010864:	cf 2f       	rcall	80010848 <_fstat_host>
80010866:	c0 34       	brge	8001086c <_fstat+0x10>
80010868:	3f fc       	mov	r12,-1
8001086a:	c1 c8       	rjmp	800108a2 <_fstat+0x46>
8001086c:	40 08       	lddsp	r8,sp[0x0]
8001086e:	ae 08       	st.h	r7[0x0],r8
80010870:	40 18       	lddsp	r8,sp[0x4]
80010872:	ae 18       	st.h	r7[0x2],r8
80010874:	40 28       	lddsp	r8,sp[0x8]
80010876:	8f 18       	st.w	r7[0x4],r8
80010878:	40 38       	lddsp	r8,sp[0xc]
8001087a:	ae 48       	st.h	r7[0x8],r8
8001087c:	40 48       	lddsp	r8,sp[0x10]
8001087e:	ae 58       	st.h	r7[0xa],r8
80010880:	40 58       	lddsp	r8,sp[0x14]
80010882:	ae 68       	st.h	r7[0xc],r8
80010884:	40 68       	lddsp	r8,sp[0x18]
80010886:	ae 78       	st.h	r7[0xe],r8
80010888:	40 88       	lddsp	r8,sp[0x20]
8001088a:	8f 48       	st.w	r7[0x10],r8
8001088c:	40 a8       	lddsp	r8,sp[0x28]
8001088e:	8f b8       	st.w	r7[0x2c],r8
80010890:	40 c8       	lddsp	r8,sp[0x30]
80010892:	8f c8       	st.w	r7[0x30],r8
80010894:	40 d8       	lddsp	r8,sp[0x34]
80010896:	8f 58       	st.w	r7[0x14],r8
80010898:	40 e8       	lddsp	r8,sp[0x38]
8001089a:	30 0c       	mov	r12,0
8001089c:	8f 78       	st.w	r7[0x1c],r8
8001089e:	40 f8       	lddsp	r8,sp[0x3c]
800108a0:	8f 98       	st.w	r7[0x24],r8
800108a2:	2f 0d       	sub	sp,-64
800108a4:	d8 22       	popm	r4-r7,pc
800108a6:	d7 03       	nop

800108a8 <_kill>:
800108a8:	5e fe       	retal	-1

800108aa <_getpid>:
800108aa:	5e fe       	retal	-1

800108ac <_sbrk>:
800108ac:	d4 01       	pushm	lr
800108ae:	e0 68 0a b8 	mov	r8,2744
800108b2:	70 09       	ld.w	r9,r8[0x0]
800108b4:	58 09       	cp.w	r9,0
800108b6:	c0 31       	brne	800108bc <_sbrk+0x10>
800108b8:	48 a9       	lddpc	r9,800108e0 <_sbrk+0x34>
800108ba:	91 09       	st.w	r8[0x0],r9
800108bc:	e0 69 0a b8 	mov	r9,2744
800108c0:	48 9a       	lddpc	r10,800108e4 <_sbrk+0x38>
800108c2:	72 08       	ld.w	r8,r9[0x0]
800108c4:	f0 0c 00 0c 	add	r12,r8,r12
800108c8:	14 3c       	cp.w	r12,r10
800108ca:	e0 8b 00 04 	brhi	800108d2 <_sbrk+0x26>
800108ce:	93 0c       	st.w	r9[0x0],r12
800108d0:	c0 68       	rjmp	800108dc <_sbrk+0x30>
800108d2:	e0 a0 25 0d 	rcall	800152ec <__errno>
800108d6:	30 c8       	mov	r8,12
800108d8:	99 08       	st.w	r12[0x0],r8
800108da:	3f f8       	mov	r8,-1
800108dc:	10 9c       	mov	r12,r8
800108de:	d8 02       	popm	pc
800108e0:	d0 00       	acall	0x0
800108e2:	00 0c       	add	r12,r0
800108e4:	d1 ff       	*unknown*
800108e6:	ff f8 d4 31 	ld.shvc	r8,pc[0x62]

800108e8 <get_arg>:
800108e8:	d4 31       	pushm	r0-r7,lr
800108ea:	20 8d       	sub	sp,32
800108ec:	fa c4 ff bc 	sub	r4,sp,-68
800108f0:	50 4b       	stdsp	sp[0x10],r11
800108f2:	68 2e       	ld.w	lr,r4[0x8]
800108f4:	50 58       	stdsp	sp[0x14],r8
800108f6:	12 96       	mov	r6,r9
800108f8:	7c 0b       	ld.w	r11,lr[0x0]
800108fa:	70 05       	ld.w	r5,r8[0x0]
800108fc:	50 6e       	stdsp	sp[0x18],lr
800108fe:	58 0b       	cp.w	r11,0
80010900:	f4 0b 17 00 	moveq	r11,r10
80010904:	68 03       	ld.w	r3,r4[0x0]
80010906:	68 11       	ld.w	r1,r4[0x4]
80010908:	40 49       	lddsp	r9,sp[0x10]
8001090a:	30 08       	mov	r8,0
8001090c:	c2 a9       	rjmp	80010b60 <get_arg+0x278>
8001090e:	2f fb       	sub	r11,-1
80010910:	32 5c       	mov	r12,37
80010912:	17 8a       	ld.ub	r10,r11[0x0]
80010914:	f8 0a 18 00 	cp.b	r10,r12
80010918:	5f 1e       	srne	lr
8001091a:	f0 0a 18 00 	cp.b	r10,r8
8001091e:	5f 1c       	srne	r12
80010920:	fd ec 00 0c 	and	r12,lr,r12
80010924:	f0 0c 18 00 	cp.b	r12,r8
80010928:	cf 31       	brne	8001090e <get_arg+0x26>
8001092a:	58 0a       	cp.w	r10,0
8001092c:	e0 80 01 27 	breq	80010b7a <get_arg+0x292>
80010930:	30 0c       	mov	r12,0
80010932:	3f fa       	mov	r10,-1
80010934:	18 90       	mov	r0,r12
80010936:	50 3a       	stdsp	sp[0xc],r10
80010938:	18 94       	mov	r4,r12
8001093a:	18 92       	mov	r2,r12
8001093c:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80010940:	16 97       	mov	r7,r11
80010942:	50 7c       	stdsp	sp[0x1c],r12
80010944:	4d 0c       	lddpc	r12,80010a84 <get_arg+0x19c>
80010946:	0f 3a       	ld.ub	r10,r7++
80010948:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
8001094c:	40 7c       	lddsp	r12,sp[0x1c]
8001094e:	1c 0c       	add	r12,lr
80010950:	fe ce 80 90 	sub	lr,pc,-32624
80010954:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80010958:	20 1e       	sub	lr,1
8001095a:	50 0e       	stdsp	sp[0x0],lr
8001095c:	fe ce 81 08 	sub	lr,pc,-32504
80010960:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80010964:	50 7c       	stdsp	sp[0x1c],r12
80010966:	40 0c       	lddsp	r12,sp[0x0]
80010968:	58 7c       	cp.w	r12,7
8001096a:	e0 8b 00 f4 	brhi	80010b52 <get_arg+0x26a>
8001096e:	fe ce 81 66 	sub	lr,pc,-32410
80010972:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80010976:	36 8b       	mov	r11,104
80010978:	f6 0a 18 00 	cp.b	r10,r11
8001097c:	e0 80 00 eb 	breq	80010b52 <get_arg+0x26a>
80010980:	37 1b       	mov	r11,113
80010982:	f6 0a 18 00 	cp.b	r10,r11
80010986:	c0 70       	breq	80010994 <get_arg+0xac>
80010988:	34 cb       	mov	r11,76
8001098a:	f6 0a 18 00 	cp.b	r10,r11
8001098e:	c0 51       	brne	80010998 <get_arg+0xb0>
80010990:	a3 b4       	sbr	r4,0x3
80010992:	ce 08       	rjmp	80010b52 <get_arg+0x26a>
80010994:	a5 b4       	sbr	r4,0x5
80010996:	cd e8       	rjmp	80010b52 <get_arg+0x26a>
80010998:	08 9a       	mov	r10,r4
8001099a:	0e 9b       	mov	r11,r7
8001099c:	a5 aa       	sbr	r10,0x4
8001099e:	17 3c       	ld.ub	r12,r11++
800109a0:	a5 b4       	sbr	r4,0x5
800109a2:	36 ce       	mov	lr,108
800109a4:	fc 0c 18 00 	cp.b	r12,lr
800109a8:	e0 80 00 d6 	breq	80010b54 <get_arg+0x26c>
800109ac:	14 94       	mov	r4,r10
800109ae:	cd 28       	rjmp	80010b52 <get_arg+0x26a>
800109b0:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
800109b4:	36 7c       	mov	r12,103
800109b6:	f8 0a 18 00 	cp.b	r10,r12
800109ba:	e0 8b 00 27 	brhi	80010a08 <get_arg+0x120>
800109be:	36 5b       	mov	r11,101
800109c0:	f6 0a 18 00 	cp.b	r10,r11
800109c4:	c4 82       	brcc	80010a54 <get_arg+0x16c>
800109c6:	34 fb       	mov	r11,79
800109c8:	f6 0a 18 00 	cp.b	r10,r11
800109cc:	c4 80       	breq	80010a5c <get_arg+0x174>
800109ce:	e0 8b 00 0c 	brhi	800109e6 <get_arg+0xfe>
800109d2:	34 5b       	mov	r11,69
800109d4:	f6 0a 18 00 	cp.b	r10,r11
800109d8:	c3 e0       	breq	80010a54 <get_arg+0x16c>
800109da:	34 7b       	mov	r11,71
800109dc:	f6 0a 18 00 	cp.b	r10,r11
800109e0:	c3 a0       	breq	80010a54 <get_arg+0x16c>
800109e2:	34 4b       	mov	r11,68
800109e4:	c0 88       	rjmp	800109f4 <get_arg+0x10c>
800109e6:	35 8b       	mov	r11,88
800109e8:	f6 0a 18 00 	cp.b	r10,r11
800109ec:	c2 c0       	breq	80010a44 <get_arg+0x15c>
800109ee:	e0 8b 00 07 	brhi	800109fc <get_arg+0x114>
800109f2:	35 5b       	mov	r11,85
800109f4:	f6 0a 18 00 	cp.b	r10,r11
800109f8:	c3 51       	brne	80010a62 <get_arg+0x17a>
800109fa:	c3 18       	rjmp	80010a5c <get_arg+0x174>
800109fc:	36 3b       	mov	r11,99
800109fe:	f6 0a 18 00 	cp.b	r10,r11
80010a02:	c2 f0       	breq	80010a60 <get_arg+0x178>
80010a04:	36 4b       	mov	r11,100
80010a06:	c0 e8       	rjmp	80010a22 <get_arg+0x13a>
80010a08:	37 0b       	mov	r11,112
80010a0a:	f6 0a 18 00 	cp.b	r10,r11
80010a0e:	c2 50       	breq	80010a58 <get_arg+0x170>
80010a10:	e0 8b 00 0d 	brhi	80010a2a <get_arg+0x142>
80010a14:	36 eb       	mov	r11,110
80010a16:	f6 0a 18 00 	cp.b	r10,r11
80010a1a:	c1 f0       	breq	80010a58 <get_arg+0x170>
80010a1c:	e0 8b 00 14 	brhi	80010a44 <get_arg+0x15c>
80010a20:	36 9b       	mov	r11,105
80010a22:	f6 0a 18 00 	cp.b	r10,r11
80010a26:	c1 e1       	brne	80010a62 <get_arg+0x17a>
80010a28:	c0 e8       	rjmp	80010a44 <get_arg+0x15c>
80010a2a:	37 5b       	mov	r11,117
80010a2c:	f6 0a 18 00 	cp.b	r10,r11
80010a30:	c0 a0       	breq	80010a44 <get_arg+0x15c>
80010a32:	37 8b       	mov	r11,120
80010a34:	f6 0a 18 00 	cp.b	r10,r11
80010a38:	c0 60       	breq	80010a44 <get_arg+0x15c>
80010a3a:	37 3b       	mov	r11,115
80010a3c:	f6 0a 18 00 	cp.b	r10,r11
80010a40:	c1 11       	brne	80010a62 <get_arg+0x17a>
80010a42:	c0 b8       	rjmp	80010a58 <get_arg+0x170>
80010a44:	ed b4 00 04 	bld	r4,0x4
80010a48:	c0 a0       	breq	80010a5c <get_arg+0x174>
80010a4a:	ed b4 00 05 	bld	r4,0x5
80010a4e:	c0 91       	brne	80010a60 <get_arg+0x178>
80010a50:	30 20       	mov	r0,2
80010a52:	c0 88       	rjmp	80010a62 <get_arg+0x17a>
80010a54:	30 40       	mov	r0,4
80010a56:	c0 68       	rjmp	80010a62 <get_arg+0x17a>
80010a58:	30 30       	mov	r0,3
80010a5a:	c0 48       	rjmp	80010a62 <get_arg+0x17a>
80010a5c:	30 10       	mov	r0,1
80010a5e:	c0 28       	rjmp	80010a62 <get_arg+0x17a>
80010a60:	30 00       	mov	r0,0
80010a62:	40 3b       	lddsp	r11,sp[0xc]
80010a64:	5b fb       	cp.w	r11,-1
80010a66:	c0 40       	breq	80010a6e <get_arg+0x186>
80010a68:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80010a6c:	c7 38       	rjmp	80010b52 <get_arg+0x26a>
80010a6e:	58 60       	cp.w	r0,6
80010a70:	e0 8b 00 71 	brhi	80010b52 <get_arg+0x26a>
80010a74:	6c 0a       	ld.w	r10,r6[0x0]
80010a76:	ea cc ff ff 	sub	r12,r5,-1
80010a7a:	fe ce 82 52 	sub	lr,pc,-32174
80010a7e:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80010a82:	d7 03       	nop
80010a84:	80 01       	ld.sh	r1,r0[0x0]
80010a86:	89 64       	st.w	r4[0x18],r4
80010a88:	f4 cb ff f8 	sub	r11,r10,-8
80010a8c:	8d 0b       	st.w	r6[0x0],r11
80010a8e:	f4 ea 00 00 	ld.d	r10,r10[0]
80010a92:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80010a96:	c0 f8       	rjmp	80010ab4 <get_arg+0x1cc>
80010a98:	f4 cb ff fc 	sub	r11,r10,-4
80010a9c:	8d 0b       	st.w	r6[0x0],r11
80010a9e:	74 0a       	ld.w	r10,r10[0x0]
80010aa0:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80010aa4:	c0 88       	rjmp	80010ab4 <get_arg+0x1cc>
80010aa6:	f4 cb ff f8 	sub	r11,r10,-8
80010aaa:	8d 0b       	st.w	r6[0x0],r11
80010aac:	f4 ea 00 00 	ld.d	r10,r10[0]
80010ab0:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80010ab4:	0e 9b       	mov	r11,r7
80010ab6:	18 95       	mov	r5,r12
80010ab8:	c4 e8       	rjmp	80010b54 <get_arg+0x26c>
80010aba:	62 0a       	ld.w	r10,r1[0x0]
80010abc:	5b fa       	cp.w	r10,-1
80010abe:	c0 b1       	brne	80010ad4 <get_arg+0x1ec>
80010ac0:	50 19       	stdsp	sp[0x4],r9
80010ac2:	50 28       	stdsp	sp[0x8],r8
80010ac4:	e0 6a 00 80 	mov	r10,128
80010ac8:	30 0b       	mov	r11,0
80010aca:	02 9c       	mov	r12,r1
80010acc:	fe b0 fc dc 	rcall	80010484 <memset>
80010ad0:	40 28       	lddsp	r8,sp[0x8]
80010ad2:	40 19       	lddsp	r9,sp[0x4]
80010ad4:	e4 cc 00 01 	sub	r12,r2,1
80010ad8:	0e 9b       	mov	r11,r7
80010ada:	50 3c       	stdsp	sp[0xc],r12
80010adc:	f2 0c 0c 49 	max	r9,r9,r12
80010ae0:	c3 a8       	rjmp	80010b54 <get_arg+0x26c>
80010ae2:	62 0a       	ld.w	r10,r1[0x0]
80010ae4:	5b fa       	cp.w	r10,-1
80010ae6:	c0 b1       	brne	80010afc <get_arg+0x214>
80010ae8:	50 19       	stdsp	sp[0x4],r9
80010aea:	50 28       	stdsp	sp[0x8],r8
80010aec:	e0 6a 00 80 	mov	r10,128
80010af0:	30 0b       	mov	r11,0
80010af2:	02 9c       	mov	r12,r1
80010af4:	fe b0 fc c8 	rcall	80010484 <memset>
80010af8:	40 28       	lddsp	r8,sp[0x8]
80010afa:	40 19       	lddsp	r9,sp[0x4]
80010afc:	20 12       	sub	r2,1
80010afe:	30 0a       	mov	r10,0
80010b00:	0e 9b       	mov	r11,r7
80010b02:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80010b06:	f2 02 0c 49 	max	r9,r9,r2
80010b0a:	c2 58       	rjmp	80010b54 <get_arg+0x26c>
80010b0c:	16 97       	mov	r7,r11
80010b0e:	6c 0a       	ld.w	r10,r6[0x0]
80010b10:	f4 cb ff fc 	sub	r11,r10,-4
80010b14:	8d 0b       	st.w	r6[0x0],r11
80010b16:	74 0a       	ld.w	r10,r10[0x0]
80010b18:	0e 9b       	mov	r11,r7
80010b1a:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80010b1e:	2f f5       	sub	r5,-1
80010b20:	c1 a8       	rjmp	80010b54 <get_arg+0x26c>
80010b22:	f4 c2 00 30 	sub	r2,r10,48
80010b26:	c0 68       	rjmp	80010b32 <get_arg+0x24a>
80010b28:	e4 02 00 22 	add	r2,r2,r2<<0x2
80010b2c:	2f f7       	sub	r7,-1
80010b2e:	f4 02 00 12 	add	r2,r10,r2<<0x1
80010b32:	0f 8a       	ld.ub	r10,r7[0x0]
80010b34:	58 0a       	cp.w	r10,0
80010b36:	c0 e0       	breq	80010b52 <get_arg+0x26a>
80010b38:	23 0a       	sub	r10,48
80010b3a:	58 9a       	cp.w	r10,9
80010b3c:	fe 98 ff f6 	brls	80010b28 <get_arg+0x240>
80010b40:	c0 98       	rjmp	80010b52 <get_arg+0x26a>
80010b42:	2f f7       	sub	r7,-1
80010b44:	0f 8a       	ld.ub	r10,r7[0x0]
80010b46:	58 0a       	cp.w	r10,0
80010b48:	c0 50       	breq	80010b52 <get_arg+0x26a>
80010b4a:	23 0a       	sub	r10,48
80010b4c:	58 9a       	cp.w	r10,9
80010b4e:	fe 98 ff fa 	brls	80010b42 <get_arg+0x25a>
80010b52:	0e 9b       	mov	r11,r7
80010b54:	40 7c       	lddsp	r12,sp[0x1c]
80010b56:	30 ba       	mov	r10,11
80010b58:	f4 0c 18 00 	cp.b	r12,r10
80010b5c:	fe 91 fe f0 	brne	8001093c <get_arg+0x54>
80010b60:	40 42       	lddsp	r2,sp[0x10]
80010b62:	17 8c       	ld.ub	r12,r11[0x0]
80010b64:	0a 32       	cp.w	r2,r5
80010b66:	5f 4a       	srge	r10
80010b68:	f0 0c 18 00 	cp.b	r12,r8
80010b6c:	5f 1c       	srne	r12
80010b6e:	f9 ea 00 0a 	and	r10,r12,r10
80010b72:	f0 0a 18 00 	cp.b	r10,r8
80010b76:	fe 91 fe cd 	brne	80010910 <get_arg+0x28>
80010b7a:	30 08       	mov	r8,0
80010b7c:	40 4e       	lddsp	lr,sp[0x10]
80010b7e:	17 8a       	ld.ub	r10,r11[0x0]
80010b80:	e2 05 00 21 	add	r1,r1,r5<<0x2
80010b84:	f0 0a 18 00 	cp.b	r10,r8
80010b88:	fc 09 17 10 	movne	r9,lr
80010b8c:	e6 05 00 38 	add	r8,r3,r5<<0x3
80010b90:	06 9e       	mov	lr,r3
80010b92:	c2 a8       	rjmp	80010be6 <get_arg+0x2fe>
80010b94:	62 0a       	ld.w	r10,r1[0x0]
80010b96:	58 3a       	cp.w	r10,3
80010b98:	c1 e0       	breq	80010bd4 <get_arg+0x2ec>
80010b9a:	e0 89 00 07 	brgt	80010ba8 <get_arg+0x2c0>
80010b9e:	58 1a       	cp.w	r10,1
80010ba0:	c1 a0       	breq	80010bd4 <get_arg+0x2ec>
80010ba2:	58 2a       	cp.w	r10,2
80010ba4:	c1 81       	brne	80010bd4 <get_arg+0x2ec>
80010ba6:	c0 58       	rjmp	80010bb0 <get_arg+0x2c8>
80010ba8:	58 5a       	cp.w	r10,5
80010baa:	c0 c0       	breq	80010bc2 <get_arg+0x2da>
80010bac:	c0 b5       	brlt	80010bc2 <get_arg+0x2da>
80010bae:	c1 38       	rjmp	80010bd4 <get_arg+0x2ec>
80010bb0:	6c 0a       	ld.w	r10,r6[0x0]
80010bb2:	f4 cc ff f8 	sub	r12,r10,-8
80010bb6:	8d 0c       	st.w	r6[0x0],r12
80010bb8:	f4 e2 00 00 	ld.d	r2,r10[0]
80010bbc:	f0 e3 00 00 	st.d	r8[0],r2
80010bc0:	c1 08       	rjmp	80010be0 <get_arg+0x2f8>
80010bc2:	6c 0a       	ld.w	r10,r6[0x0]
80010bc4:	f4 cc ff f8 	sub	r12,r10,-8
80010bc8:	8d 0c       	st.w	r6[0x0],r12
80010bca:	f4 e2 00 00 	ld.d	r2,r10[0]
80010bce:	f0 e3 00 00 	st.d	r8[0],r2
80010bd2:	c0 78       	rjmp	80010be0 <get_arg+0x2f8>
80010bd4:	6c 0a       	ld.w	r10,r6[0x0]
80010bd6:	f4 cc ff fc 	sub	r12,r10,-4
80010bda:	8d 0c       	st.w	r6[0x0],r12
80010bdc:	74 0a       	ld.w	r10,r10[0x0]
80010bde:	91 0a       	st.w	r8[0x0],r10
80010be0:	2f f5       	sub	r5,-1
80010be2:	2f 88       	sub	r8,-8
80010be4:	2f c1       	sub	r1,-4
80010be6:	12 35       	cp.w	r5,r9
80010be8:	fe 9a ff d6 	brle	80010b94 <get_arg+0x2ac>
80010bec:	1c 93       	mov	r3,lr
80010bee:	40 52       	lddsp	r2,sp[0x14]
80010bf0:	40 6e       	lddsp	lr,sp[0x18]
80010bf2:	85 05       	st.w	r2[0x0],r5
80010bf4:	9d 0b       	st.w	lr[0x0],r11
80010bf6:	40 4b       	lddsp	r11,sp[0x10]
80010bf8:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80010bfc:	2f 8d       	sub	sp,-32
80010bfe:	d8 32       	popm	r0-r7,pc

80010c00 <__sprint_r>:
80010c00:	d4 21       	pushm	r4-r7,lr
80010c02:	14 97       	mov	r7,r10
80010c04:	74 28       	ld.w	r8,r10[0x8]
80010c06:	58 08       	cp.w	r8,0
80010c08:	c0 41       	brne	80010c10 <__sprint_r+0x10>
80010c0a:	95 18       	st.w	r10[0x4],r8
80010c0c:	10 9c       	mov	r12,r8
80010c0e:	d8 22       	popm	r4-r7,pc
80010c10:	e0 a0 25 ac 	rcall	80015768 <__sfvwrite_r>
80010c14:	30 08       	mov	r8,0
80010c16:	8f 18       	st.w	r7[0x4],r8
80010c18:	8f 28       	st.w	r7[0x8],r8
80010c1a:	d8 22       	popm	r4-r7,pc

80010c1c <_vfiprintf_r>:
80010c1c:	d4 31       	pushm	r0-r7,lr
80010c1e:	fa cd 06 88 	sub	sp,sp,1672
80010c22:	50 a9       	stdsp	sp[0x28],r9
80010c24:	16 90       	mov	r0,r11
80010c26:	14 97       	mov	r7,r10
80010c28:	18 92       	mov	r2,r12
80010c2a:	58 0c       	cp.w	r12,0
80010c2c:	c0 60       	breq	80010c38 <_vfiprintf_r+0x1c>
80010c2e:	78 68       	ld.w	r8,r12[0x18]
80010c30:	58 08       	cp.w	r8,0
80010c32:	c0 31       	brne	80010c38 <_vfiprintf_r+0x1c>
80010c34:	e0 a0 24 3a 	rcall	800154a8 <__sinit>
80010c38:	4c c8       	lddpc	r8,80010d68 <_vfiprintf_r+0x14c>
80010c3a:	10 30       	cp.w	r0,r8
80010c3c:	c0 31       	brne	80010c42 <_vfiprintf_r+0x26>
80010c3e:	64 00       	ld.w	r0,r2[0x0]
80010c40:	c0 a8       	rjmp	80010c54 <_vfiprintf_r+0x38>
80010c42:	4c b8       	lddpc	r8,80010d6c <_vfiprintf_r+0x150>
80010c44:	10 30       	cp.w	r0,r8
80010c46:	c0 31       	brne	80010c4c <_vfiprintf_r+0x30>
80010c48:	64 10       	ld.w	r0,r2[0x4]
80010c4a:	c0 58       	rjmp	80010c54 <_vfiprintf_r+0x38>
80010c4c:	4c 98       	lddpc	r8,80010d70 <_vfiprintf_r+0x154>
80010c4e:	10 30       	cp.w	r0,r8
80010c50:	e5 f0 00 02 	ld.weq	r0,r2[0x8]
80010c54:	80 68       	ld.sh	r8,r0[0xc]
80010c56:	ed b8 00 03 	bld	r8,0x3
80010c5a:	c0 41       	brne	80010c62 <_vfiprintf_r+0x46>
80010c5c:	60 48       	ld.w	r8,r0[0x10]
80010c5e:	58 08       	cp.w	r8,0
80010c60:	c0 71       	brne	80010c6e <_vfiprintf_r+0x52>
80010c62:	00 9b       	mov	r11,r0
80010c64:	04 9c       	mov	r12,r2
80010c66:	e0 a0 1c 4f 	rcall	80014504 <__swsetup_r>
80010c6a:	e0 81 0b 24 	brne	800122b2 <_vfiprintf_r+0x1696>
80010c6e:	80 68       	ld.sh	r8,r0[0xc]
80010c70:	10 99       	mov	r9,r8
80010c72:	e2 19 00 1a 	andl	r9,0x1a,COH
80010c76:	58 a9       	cp.w	r9,10
80010c78:	c3 c1       	brne	80010cf0 <_vfiprintf_r+0xd4>
80010c7a:	80 79       	ld.sh	r9,r0[0xe]
80010c7c:	30 0a       	mov	r10,0
80010c7e:	f4 09 19 00 	cp.h	r9,r10
80010c82:	c3 75       	brlt	80010cf0 <_vfiprintf_r+0xd4>
80010c84:	a1 d8       	cbr	r8,0x1
80010c86:	fb 58 05 b8 	st.h	sp[1464],r8
80010c8a:	60 88       	ld.w	r8,r0[0x20]
80010c8c:	fb 48 05 cc 	st.w	sp[1484],r8
80010c90:	60 a8       	ld.w	r8,r0[0x28]
80010c92:	fb 48 05 d4 	st.w	sp[1492],r8
80010c96:	fa c8 ff d4 	sub	r8,sp,-44
80010c9a:	fb 48 05 bc 	st.w	sp[1468],r8
80010c9e:	fb 48 05 ac 	st.w	sp[1452],r8
80010ca2:	e0 68 04 00 	mov	r8,1024
80010ca6:	fb 48 05 c0 	st.w	sp[1472],r8
80010caa:	fb 48 05 b4 	st.w	sp[1460],r8
80010cae:	30 08       	mov	r8,0
80010cb0:	fb 59 05 ba 	st.h	sp[1466],r9
80010cb4:	0e 9a       	mov	r10,r7
80010cb6:	40 a9       	lddsp	r9,sp[0x28]
80010cb8:	fa c7 fa 54 	sub	r7,sp,-1452
80010cbc:	fb 48 05 c4 	st.w	sp[1476],r8
80010cc0:	04 9c       	mov	r12,r2
80010cc2:	0e 9b       	mov	r11,r7
80010cc4:	ca cf       	rcall	80010c1c <_vfiprintf_r>
80010cc6:	50 6c       	stdsp	sp[0x18],r12
80010cc8:	c0 95       	brlt	80010cda <_vfiprintf_r+0xbe>
80010cca:	0e 9b       	mov	r11,r7
80010ccc:	04 9c       	mov	r12,r2
80010cce:	e0 a0 23 15 	rcall	800152f8 <_fflush_r>
80010cd2:	40 6e       	lddsp	lr,sp[0x18]
80010cd4:	f9 be 01 ff 	movne	lr,-1
80010cd8:	50 6e       	stdsp	sp[0x18],lr
80010cda:	fb 08 05 b8 	ld.sh	r8,sp[1464]
80010cde:	ed b8 00 06 	bld	r8,0x6
80010ce2:	e0 81 0a ea 	brne	800122b6 <_vfiprintf_r+0x169a>
80010ce6:	80 68       	ld.sh	r8,r0[0xc]
80010ce8:	a7 a8       	sbr	r8,0x6
80010cea:	a0 68       	st.h	r0[0xc],r8
80010cec:	e0 8f 0a e5 	bral	800122b6 <_vfiprintf_r+0x169a>
80010cf0:	30 08       	mov	r8,0
80010cf2:	fa c4 f9 f8 	sub	r4,sp,-1544
80010cf6:	50 98       	stdsp	sp[0x24],r8
80010cf8:	fb 48 06 78 	st.w	sp[1656],r8
80010cfc:	40 9c       	lddsp	r12,sp[0x24]
80010cfe:	fb 48 06 74 	st.w	sp[1652],r8
80010d02:	fb 48 06 7c 	st.w	sp[1660],r8
80010d06:	fb 48 06 80 	st.w	sp[1664],r8
80010d0a:	50 57       	stdsp	sp[0x14],r7
80010d0c:	3f f8       	mov	r8,-1
80010d0e:	fb 44 06 70 	st.w	sp[1648],r4
80010d12:	fb 48 05 2c 	st.w	sp[1324],r8
80010d16:	50 6c       	stdsp	sp[0x18],r12
80010d18:	18 96       	mov	r6,r12
80010d1a:	04 91       	mov	r1,r2
80010d1c:	50 20       	stdsp	sp[0x8],r0
80010d1e:	40 55       	lddsp	r5,sp[0x14]
80010d20:	c0 28       	rjmp	80010d24 <_vfiprintf_r+0x108>
80010d22:	2f f5       	sub	r5,-1
80010d24:	0b 88       	ld.ub	r8,r5[0x0]
80010d26:	30 0b       	mov	r11,0
80010d28:	32 5a       	mov	r10,37
80010d2a:	f6 08 18 00 	cp.b	r8,r11
80010d2e:	5f 19       	srne	r9
80010d30:	f4 08 18 00 	cp.b	r8,r10
80010d34:	5f 18       	srne	r8
80010d36:	12 68       	and	r8,r9
80010d38:	f6 08 18 00 	cp.b	r8,r11
80010d3c:	cf 31       	brne	80010d22 <_vfiprintf_r+0x106>
80010d3e:	40 59       	lddsp	r9,sp[0x14]
80010d40:	ea 09 01 07 	sub	r7,r5,r9
80010d44:	c2 40       	breq	80010d8c <_vfiprintf_r+0x170>
80010d46:	fa f8 06 78 	ld.w	r8,sp[1656]
80010d4a:	0e 08       	add	r8,r7
80010d4c:	89 09       	st.w	r4[0x0],r9
80010d4e:	fb 48 06 78 	st.w	sp[1656],r8
80010d52:	89 17       	st.w	r4[0x4],r7
80010d54:	fa f8 06 74 	ld.w	r8,sp[1652]
80010d58:	2f f8       	sub	r8,-1
80010d5a:	fb 48 06 74 	st.w	sp[1652],r8
80010d5e:	58 78       	cp.w	r8,7
80010d60:	e0 89 00 0a 	brgt	80010d74 <_vfiprintf_r+0x158>
80010d64:	2f 84       	sub	r4,-8
80010d66:	c1 08       	rjmp	80010d86 <_vfiprintf_r+0x16a>
80010d68:	80 01       	ld.sh	r1,r0[0x0]
80010d6a:	8e 20       	ld.sh	r0,r7[0x4]
80010d6c:	80 01       	ld.sh	r1,r0[0x0]
80010d6e:	8e 40       	ld.sh	r0,r7[0x8]
80010d70:	80 01       	ld.sh	r1,r0[0x0]
80010d72:	8e 60       	ld.sh	r0,r7[0xc]
80010d74:	fa ca f9 90 	sub	r10,sp,-1648
80010d78:	40 2b       	lddsp	r11,sp[0x8]
80010d7a:	02 9c       	mov	r12,r1
80010d7c:	c4 2f       	rcall	80010c00 <__sprint_r>
80010d7e:	e0 81 0a 95 	brne	800122a8 <_vfiprintf_r+0x168c>
80010d82:	fa c4 f9 f8 	sub	r4,sp,-1544
80010d86:	40 68       	lddsp	r8,sp[0x18]
80010d88:	0e 08       	add	r8,r7
80010d8a:	50 68       	stdsp	sp[0x18],r8
80010d8c:	0b 88       	ld.ub	r8,r5[0x0]
80010d8e:	30 07       	mov	r7,0
80010d90:	ee 08 18 00 	cp.b	r8,r7
80010d94:	e0 80 0a 79 	breq	80012286 <_vfiprintf_r+0x166a>
80010d98:	ea c2 ff ff 	sub	r2,r5,-1
80010d9c:	30 03       	mov	r3,0
80010d9e:	50 52       	stdsp	sp[0x14],r2
80010da0:	fb 67 06 87 	st.b	sp[1671],r7
80010da4:	3f fe       	mov	lr,-1
80010da6:	50 74       	stdsp	sp[0x1c],r4
80010da8:	50 43       	stdsp	sp[0x10],r3
80010daa:	50 3e       	stdsp	sp[0xc],lr
80010dac:	06 90       	mov	r0,r3
80010dae:	50 85       	stdsp	sp[0x20],r5
80010db0:	06 92       	mov	r2,r3
80010db2:	0c 94       	mov	r4,r6
80010db4:	40 57       	lddsp	r7,sp[0x14]
80010db6:	c0 68       	rjmp	80010dc2 <_vfiprintf_r+0x1a6>
80010db8:	3f fc       	mov	r12,-1
80010dba:	0a 97       	mov	r7,r5
80010dbc:	50 3c       	stdsp	sp[0xc],r12
80010dbe:	c0 28       	rjmp	80010dc2 <_vfiprintf_r+0x1a6>
80010dc0:	30 00       	mov	r0,0
80010dc2:	0f 38       	ld.ub	r8,r7++
80010dc4:	c0 28       	rjmp	80010dc8 <_vfiprintf_r+0x1ac>
80010dc6:	12 92       	mov	r2,r9
80010dc8:	e0 48 00 63 	cp.w	r8,99
80010dcc:	e0 80 01 c8 	breq	8001115c <_vfiprintf_r+0x540>
80010dd0:	e0 89 00 45 	brgt	80010e5a <_vfiprintf_r+0x23e>
80010dd4:	e0 48 00 39 	cp.w	r8,57
80010dd8:	e0 89 00 26 	brgt	80010e24 <_vfiprintf_r+0x208>
80010ddc:	e0 48 00 31 	cp.w	r8,49
80010de0:	e0 84 01 93 	brge	80011106 <_vfiprintf_r+0x4ea>
80010de4:	e0 48 00 2b 	cp.w	r8,43
80010de8:	e0 80 01 02 	breq	80010fec <_vfiprintf_r+0x3d0>
80010dec:	e0 89 00 0f 	brgt	80010e0a <_vfiprintf_r+0x1ee>
80010df0:	e0 48 00 23 	cp.w	r8,35
80010df4:	e0 80 00 8f 	breq	80010f12 <_vfiprintf_r+0x2f6>
80010df8:	e0 48 00 2a 	cp.w	r8,42
80010dfc:	e0 80 00 8d 	breq	80010f16 <_vfiprintf_r+0x2fa>
80010e00:	e0 48 00 20 	cp.w	r8,32
80010e04:	e0 81 08 8c 	brne	80011f1c <_vfiprintf_r+0x1300>
80010e08:	c7 c8       	rjmp	80010f00 <_vfiprintf_r+0x2e4>
80010e0a:	e0 48 00 2e 	cp.w	r8,46
80010e0e:	e0 80 00 f2 	breq	80010ff2 <_vfiprintf_r+0x3d6>
80010e12:	e0 48 00 30 	cp.w	r8,48
80010e16:	e0 80 01 76 	breq	80011102 <_vfiprintf_r+0x4e6>
80010e1a:	e0 48 00 2d 	cp.w	r8,45
80010e1e:	e0 81 08 7f 	brne	80011f1c <_vfiprintf_r+0x1300>
80010e22:	ce 38       	rjmp	80010fe8 <_vfiprintf_r+0x3cc>
80010e24:	50 57       	stdsp	sp[0x14],r7
80010e26:	50 42       	stdsp	sp[0x10],r2
80010e28:	08 97       	mov	r7,r4
80010e2a:	40 85       	lddsp	r5,sp[0x20]
80010e2c:	40 74       	lddsp	r4,sp[0x1c]
80010e2e:	10 92       	mov	r2,r8
80010e30:	e0 48 00 4f 	cp.w	r8,79
80010e34:	e0 80 04 35 	breq	8001169e <_vfiprintf_r+0xa82>
80010e38:	e0 89 00 08 	brgt	80010e48 <_vfiprintf_r+0x22c>
80010e3c:	e0 48 00 44 	cp.w	r8,68
80010e40:	e0 81 08 72 	brne	80011f24 <_vfiprintf_r+0x1308>
80010e44:	e0 8f 01 da 	bral	800111f8 <_vfiprintf_r+0x5dc>
80010e48:	e0 48 00 55 	cp.w	r8,85
80010e4c:	e0 80 05 dc 	breq	80011a04 <_vfiprintf_r+0xde8>
80010e50:	e0 48 00 58 	cp.w	r8,88
80010e54:	e0 81 08 68 	brne	80011f24 <_vfiprintf_r+0x1308>
80010e58:	c4 28       	rjmp	80010edc <_vfiprintf_r+0x2c0>
80010e5a:	e0 48 00 6f 	cp.w	r8,111
80010e5e:	c4 40       	breq	80010ee6 <_vfiprintf_r+0x2ca>
80010e60:	e0 89 00 1f 	brgt	80010e9e <_vfiprintf_r+0x282>
80010e64:	e0 48 00 69 	cp.w	r8,105
80010e68:	c4 60       	breq	80010ef4 <_vfiprintf_r+0x2d8>
80010e6a:	e0 89 00 0a 	brgt	80010e7e <_vfiprintf_r+0x262>
80010e6e:	e0 48 00 64 	cp.w	r8,100
80010e72:	c4 10       	breq	80010ef4 <_vfiprintf_r+0x2d8>
80010e74:	e0 48 00 68 	cp.w	r8,104
80010e78:	e0 81 08 52 	brne	80011f1c <_vfiprintf_r+0x1300>
80010e7c:	c5 e9       	rjmp	80011138 <_vfiprintf_r+0x51c>
80010e7e:	e0 48 00 6c 	cp.w	r8,108
80010e82:	e0 80 01 5e 	breq	8001113e <_vfiprintf_r+0x522>
80010e86:	50 57       	stdsp	sp[0x14],r7
80010e88:	50 42       	stdsp	sp[0x10],r2
80010e8a:	08 97       	mov	r7,r4
80010e8c:	40 85       	lddsp	r5,sp[0x20]
80010e8e:	40 74       	lddsp	r4,sp[0x1c]
80010e90:	10 92       	mov	r2,r8
80010e92:	e0 48 00 6e 	cp.w	r8,110
80010e96:	e0 81 08 47 	brne	80011f24 <_vfiprintf_r+0x1308>
80010e9a:	e0 8f 02 e9 	bral	8001146c <_vfiprintf_r+0x850>
80010e9e:	e0 48 00 73 	cp.w	r8,115
80010ea2:	e0 80 05 50 	breq	80011942 <_vfiprintf_r+0xd26>
80010ea6:	e0 89 00 0b 	brgt	80010ebc <_vfiprintf_r+0x2a0>
80010eaa:	e0 48 00 70 	cp.w	r8,112
80010eae:	e0 80 04 f5 	breq	80011898 <_vfiprintf_r+0xc7c>
80010eb2:	e0 48 00 71 	cp.w	r8,113
80010eb6:	e0 81 08 33 	brne	80011f1c <_vfiprintf_r+0x1300>
80010eba:	c4 e9       	rjmp	80011156 <_vfiprintf_r+0x53a>
80010ebc:	50 57       	stdsp	sp[0x14],r7
80010ebe:	50 42       	stdsp	sp[0x10],r2
80010ec0:	08 97       	mov	r7,r4
80010ec2:	40 85       	lddsp	r5,sp[0x20]
80010ec4:	40 74       	lddsp	r4,sp[0x1c]
80010ec6:	10 92       	mov	r2,r8
80010ec8:	e0 48 00 75 	cp.w	r8,117
80010ecc:	e0 80 05 9d 	breq	80011a06 <_vfiprintf_r+0xdea>
80010ed0:	e0 48 00 78 	cp.w	r8,120
80010ed4:	e0 81 08 28 	brne	80011f24 <_vfiprintf_r+0x1308>
80010ed8:	e0 8f 06 8b 	bral	80011bee <_vfiprintf_r+0xfd2>
80010edc:	fe cb 85 b0 	sub	r11,pc,-31312
80010ee0:	50 9b       	stdsp	sp[0x24],r11
80010ee2:	e0 8f 06 89 	bral	80011bf4 <_vfiprintf_r+0xfd8>
80010ee6:	50 57       	stdsp	sp[0x14],r7
80010ee8:	40 85       	lddsp	r5,sp[0x20]
80010eea:	08 97       	mov	r7,r4
80010eec:	50 42       	stdsp	sp[0x10],r2
80010eee:	40 74       	lddsp	r4,sp[0x1c]
80010ef0:	e0 8f 03 d8 	bral	800116a0 <_vfiprintf_r+0xa84>
80010ef4:	50 57       	stdsp	sp[0x14],r7
80010ef6:	40 85       	lddsp	r5,sp[0x20]
80010ef8:	08 97       	mov	r7,r4
80010efa:	50 42       	stdsp	sp[0x10],r2
80010efc:	40 74       	lddsp	r4,sp[0x1c]
80010efe:	c7 e9       	rjmp	800111fa <_vfiprintf_r+0x5de>
80010f00:	fb 38 06 87 	ld.ub	r8,sp[1671]
80010f04:	30 0a       	mov	r10,0
80010f06:	f4 08 18 00 	cp.b	r8,r10
80010f0a:	fe 91 ff 5c 	brne	80010dc2 <_vfiprintf_r+0x1a6>
80010f0e:	32 08       	mov	r8,32
80010f10:	c6 e8       	rjmp	80010fec <_vfiprintf_r+0x3d0>
80010f12:	a1 a3       	sbr	r3,0x0
80010f14:	c5 7b       	rjmp	80010dc2 <_vfiprintf_r+0x1a6>
80010f16:	0f 89       	ld.ub	r9,r7[0x0]
80010f18:	f2 c8 00 30 	sub	r8,r9,48
80010f1c:	58 98       	cp.w	r8,9
80010f1e:	e0 8b 00 1e 	brhi	80010f5a <_vfiprintf_r+0x33e>
80010f22:	ee c8 ff ff 	sub	r8,r7,-1
80010f26:	30 0b       	mov	r11,0
80010f28:	23 09       	sub	r9,48
80010f2a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80010f2e:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80010f32:	11 39       	ld.ub	r9,r8++
80010f34:	f2 ca 00 30 	sub	r10,r9,48
80010f38:	58 9a       	cp.w	r10,9
80010f3a:	fe 98 ff f7 	brls	80010f28 <_vfiprintf_r+0x30c>
80010f3e:	e0 49 00 24 	cp.w	r9,36
80010f42:	fe 91 ff 3f 	brne	80010dc0 <_vfiprintf_r+0x1a4>
80010f46:	e0 4b 00 20 	cp.w	r11,32
80010f4a:	e0 89 09 af 	brgt	800122a8 <_vfiprintf_r+0x168c>
80010f4e:	20 1b       	sub	r11,1
80010f50:	fa f9 06 80 	ld.w	r9,sp[1664]
80010f54:	12 3b       	cp.w	r11,r9
80010f56:	c0 95       	brlt	80010f68 <_vfiprintf_r+0x34c>
80010f58:	c1 08       	rjmp	80010f78 <_vfiprintf_r+0x35c>
80010f5a:	fa f9 06 80 	ld.w	r9,sp[1664]
80010f5e:	ec ca ff ff 	sub	r10,r6,-1
80010f62:	12 36       	cp.w	r6,r9
80010f64:	c1 f5       	brlt	80010fa2 <_vfiprintf_r+0x386>
80010f66:	c2 68       	rjmp	80010fb2 <_vfiprintf_r+0x396>
80010f68:	fa c9 f9 78 	sub	r9,sp,-1672
80010f6c:	10 97       	mov	r7,r8
80010f6e:	f2 0b 00 3b 	add	r11,r9,r11<<0x3
80010f72:	f6 f2 fd a4 	ld.w	r2,r11[-604]
80010f76:	c3 58       	rjmp	80010fe0 <_vfiprintf_r+0x3c4>
80010f78:	fa c7 f9 84 	sub	r7,sp,-1660
80010f7c:	1a d7       	st.w	--sp,r7
80010f7e:	10 97       	mov	r7,r8
80010f80:	fa c2 fa d0 	sub	r2,sp,-1328
80010f84:	1a d2       	st.w	--sp,r2
80010f86:	fa c8 fb cc 	sub	r8,sp,-1076
80010f8a:	02 9c       	mov	r12,r1
80010f8c:	1a d8       	st.w	--sp,r8
80010f8e:	fa c8 f9 74 	sub	r8,sp,-1676
80010f92:	fa c9 ff cc 	sub	r9,sp,-52
80010f96:	40 ba       	lddsp	r10,sp[0x2c]
80010f98:	fe b0 fc a8 	rcall	800108e8 <get_arg>
80010f9c:	2f dd       	sub	sp,-12
80010f9e:	78 02       	ld.w	r2,r12[0x0]
80010fa0:	c2 08       	rjmp	80010fe0 <_vfiprintf_r+0x3c4>
80010fa2:	fa ce f9 78 	sub	lr,sp,-1672
80010fa6:	14 96       	mov	r6,r10
80010fa8:	fc 04 00 38 	add	r8,lr,r4<<0x3
80010fac:	f0 f2 fd a4 	ld.w	r2,r8[-604]
80010fb0:	c1 88       	rjmp	80010fe0 <_vfiprintf_r+0x3c4>
80010fb2:	40 a8       	lddsp	r8,sp[0x28]
80010fb4:	59 f9       	cp.w	r9,31
80010fb6:	e0 89 00 11 	brgt	80010fd8 <_vfiprintf_r+0x3bc>
80010fba:	f0 cb ff fc 	sub	r11,r8,-4
80010fbe:	50 ab       	stdsp	sp[0x28],r11
80010fc0:	70 02       	ld.w	r2,r8[0x0]
80010fc2:	fa cc f9 78 	sub	r12,sp,-1672
80010fc6:	f8 09 00 38 	add	r8,r12,r9<<0x3
80010fca:	f1 42 fd a4 	st.w	r8[-604],r2
80010fce:	2f f9       	sub	r9,-1
80010fd0:	14 96       	mov	r6,r10
80010fd2:	fb 49 06 80 	st.w	sp[1664],r9
80010fd6:	c0 58       	rjmp	80010fe0 <_vfiprintf_r+0x3c4>
80010fd8:	70 02       	ld.w	r2,r8[0x0]
80010fda:	14 96       	mov	r6,r10
80010fdc:	2f c8       	sub	r8,-4
80010fde:	50 a8       	stdsp	sp[0x28],r8
80010fe0:	58 02       	cp.w	r2,0
80010fe2:	fe 94 fe f0 	brge	80010dc2 <_vfiprintf_r+0x1a6>
80010fe6:	5c 32       	neg	r2
80010fe8:	a3 a3       	sbr	r3,0x2
80010fea:	ce ca       	rjmp	80010dc2 <_vfiprintf_r+0x1a6>
80010fec:	fb 68 06 87 	st.b	sp[1671],r8
80010ff0:	ce 9a       	rjmp	80010dc2 <_vfiprintf_r+0x1a6>
80010ff2:	0f 38       	ld.ub	r8,r7++
80010ff4:	e0 48 00 2a 	cp.w	r8,42
80010ff8:	c0 40       	breq	80011000 <_vfiprintf_r+0x3e4>
80010ffa:	30 09       	mov	r9,0
80010ffc:	c7 78       	rjmp	800110ea <_vfiprintf_r+0x4ce>
80010ffe:	d7 03       	nop
80011000:	0f 88       	ld.ub	r8,r7[0x0]
80011002:	f0 c9 00 30 	sub	r9,r8,48
80011006:	58 99       	cp.w	r9,9
80011008:	e0 8b 00 1e 	brhi	80011044 <_vfiprintf_r+0x428>
8001100c:	ee c5 ff ff 	sub	r5,r7,-1
80011010:	30 0b       	mov	r11,0
80011012:	23 08       	sub	r8,48
80011014:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80011018:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8001101c:	0b 38       	ld.ub	r8,r5++
8001101e:	f0 c9 00 30 	sub	r9,r8,48
80011022:	58 99       	cp.w	r9,9
80011024:	fe 98 ff f7 	brls	80011012 <_vfiprintf_r+0x3f6>
80011028:	e0 48 00 24 	cp.w	r8,36
8001102c:	fe 91 fe ca 	brne	80010dc0 <_vfiprintf_r+0x1a4>
80011030:	e0 4b 00 20 	cp.w	r11,32
80011034:	e0 89 09 3a 	brgt	800122a8 <_vfiprintf_r+0x168c>
80011038:	20 1b       	sub	r11,1
8001103a:	fa f8 06 80 	ld.w	r8,sp[1664]
8001103e:	10 3b       	cp.w	r11,r8
80011040:	c0 95       	brlt	80011052 <_vfiprintf_r+0x436>
80011042:	c1 08       	rjmp	80011062 <_vfiprintf_r+0x446>
80011044:	fa f9 06 80 	ld.w	r9,sp[1664]
80011048:	ec ca ff ff 	sub	r10,r6,-1
8001104c:	12 36       	cp.w	r6,r9
8001104e:	c1 f5       	brlt	8001108c <_vfiprintf_r+0x470>
80011050:	c2 88       	rjmp	800110a0 <_vfiprintf_r+0x484>
80011052:	fa ca f9 78 	sub	r10,sp,-1672
80011056:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8001105a:	f6 fb fd a4 	ld.w	r11,r11[-604]
8001105e:	50 3b       	stdsp	sp[0xc],r11
80011060:	c3 c8       	rjmp	800110d8 <_vfiprintf_r+0x4bc>
80011062:	fa c9 f9 84 	sub	r9,sp,-1660
80011066:	1a d9       	st.w	--sp,r9
80011068:	fa c8 fa d0 	sub	r8,sp,-1328
8001106c:	1a d8       	st.w	--sp,r8
8001106e:	fa c8 fb cc 	sub	r8,sp,-1076
80011072:	02 9c       	mov	r12,r1
80011074:	1a d8       	st.w	--sp,r8
80011076:	fa c8 f9 74 	sub	r8,sp,-1676
8001107a:	fa c9 ff cc 	sub	r9,sp,-52
8001107e:	40 ba       	lddsp	r10,sp[0x2c]
80011080:	fe b0 fc 34 	rcall	800108e8 <get_arg>
80011084:	2f dd       	sub	sp,-12
80011086:	78 0c       	ld.w	r12,r12[0x0]
80011088:	50 3c       	stdsp	sp[0xc],r12
8001108a:	c2 78       	rjmp	800110d8 <_vfiprintf_r+0x4bc>
8001108c:	fa ce f9 78 	sub	lr,sp,-1672
80011090:	0e 95       	mov	r5,r7
80011092:	fc 04 00 38 	add	r8,lr,r4<<0x3
80011096:	14 96       	mov	r6,r10
80011098:	f0 f8 fd a4 	ld.w	r8,r8[-604]
8001109c:	50 38       	stdsp	sp[0xc],r8
8001109e:	c1 d8       	rjmp	800110d8 <_vfiprintf_r+0x4bc>
800110a0:	40 a8       	lddsp	r8,sp[0x28]
800110a2:	59 f9       	cp.w	r9,31
800110a4:	e0 89 00 14 	brgt	800110cc <_vfiprintf_r+0x4b0>
800110a8:	f0 cb ff fc 	sub	r11,r8,-4
800110ac:	70 08       	ld.w	r8,r8[0x0]
800110ae:	50 ab       	stdsp	sp[0x28],r11
800110b0:	50 38       	stdsp	sp[0xc],r8
800110b2:	fa cc f9 78 	sub	r12,sp,-1672
800110b6:	40 3b       	lddsp	r11,sp[0xc]
800110b8:	f8 09 00 38 	add	r8,r12,r9<<0x3
800110bc:	f1 4b fd a4 	st.w	r8[-604],r11
800110c0:	2f f9       	sub	r9,-1
800110c2:	0e 95       	mov	r5,r7
800110c4:	fb 49 06 80 	st.w	sp[1664],r9
800110c8:	14 96       	mov	r6,r10
800110ca:	c0 78       	rjmp	800110d8 <_vfiprintf_r+0x4bc>
800110cc:	70 09       	ld.w	r9,r8[0x0]
800110ce:	0e 95       	mov	r5,r7
800110d0:	2f c8       	sub	r8,-4
800110d2:	50 39       	stdsp	sp[0xc],r9
800110d4:	14 96       	mov	r6,r10
800110d6:	50 a8       	stdsp	sp[0x28],r8
800110d8:	40 38       	lddsp	r8,sp[0xc]
800110da:	58 08       	cp.w	r8,0
800110dc:	fe 95 fe 6e 	brlt	80010db8 <_vfiprintf_r+0x19c>
800110e0:	0a 97       	mov	r7,r5
800110e2:	c7 0a       	rjmp	80010dc2 <_vfiprintf_r+0x1a6>
800110e4:	f4 0b 00 19 	add	r9,r10,r11<<0x1
800110e8:	0f 38       	ld.ub	r8,r7++
800110ea:	f2 09 00 2b 	add	r11,r9,r9<<0x2
800110ee:	f0 ca 00 30 	sub	r10,r8,48
800110f2:	58 9a       	cp.w	r10,9
800110f4:	fe 98 ff f8 	brls	800110e4 <_vfiprintf_r+0x4c8>
800110f8:	3f fe       	mov	lr,-1
800110fa:	f2 0e 0c 49 	max	r9,r9,lr
800110fe:	50 39       	stdsp	sp[0xc],r9
80011100:	c6 4a       	rjmp	80010dc8 <_vfiprintf_r+0x1ac>
80011102:	a7 b3       	sbr	r3,0x7
80011104:	c5 fa       	rjmp	80010dc2 <_vfiprintf_r+0x1a6>
80011106:	30 09       	mov	r9,0
80011108:	23 08       	sub	r8,48
8001110a:	f2 09 00 29 	add	r9,r9,r9<<0x2
8001110e:	f0 09 00 19 	add	r9,r8,r9<<0x1
80011112:	0f 38       	ld.ub	r8,r7++
80011114:	f0 ca 00 30 	sub	r10,r8,48
80011118:	58 9a       	cp.w	r10,9
8001111a:	fe 98 ff f7 	brls	80011108 <_vfiprintf_r+0x4ec>
8001111e:	e0 48 00 24 	cp.w	r8,36
80011122:	fe 91 fe 52 	brne	80010dc6 <_vfiprintf_r+0x1aa>
80011126:	e0 49 00 20 	cp.w	r9,32
8001112a:	e0 89 08 bf 	brgt	800122a8 <_vfiprintf_r+0x168c>
8001112e:	f2 c4 00 01 	sub	r4,r9,1
80011132:	30 10       	mov	r0,1
80011134:	fe 9f fe 47 	bral	80010dc2 <_vfiprintf_r+0x1a6>
80011138:	a7 a3       	sbr	r3,0x6
8001113a:	fe 9f fe 44 	bral	80010dc2 <_vfiprintf_r+0x1a6>
8001113e:	06 99       	mov	r9,r3
80011140:	a5 b3       	sbr	r3,0x5
80011142:	a5 a9       	sbr	r9,0x4
80011144:	0f 8a       	ld.ub	r10,r7[0x0]
80011146:	f0 0a 18 00 	cp.b	r10,r8
8001114a:	f7 b7 00 ff 	subeq	r7,-1
8001114e:	f2 03 17 10 	movne	r3,r9
80011152:	fe 9f fe 38 	bral	80010dc2 <_vfiprintf_r+0x1a6>
80011156:	a5 b3       	sbr	r3,0x5
80011158:	fe 9f fe 35 	bral	80010dc2 <_vfiprintf_r+0x1a6>
8001115c:	50 57       	stdsp	sp[0x14],r7
8001115e:	50 42       	stdsp	sp[0x10],r2
80011160:	08 97       	mov	r7,r4
80011162:	40 85       	lddsp	r5,sp[0x20]
80011164:	40 74       	lddsp	r4,sp[0x1c]
80011166:	0c 99       	mov	r9,r6
80011168:	fa f8 06 80 	ld.w	r8,sp[1664]
8001116c:	58 00       	cp.w	r0,0
8001116e:	c1 d0       	breq	800111a8 <_vfiprintf_r+0x58c>
80011170:	10 37       	cp.w	r7,r8
80011172:	c0 64       	brge	8001117e <_vfiprintf_r+0x562>
80011174:	fa cc f9 78 	sub	r12,sp,-1672
80011178:	f8 07 00 37 	add	r7,r12,r7<<0x3
8001117c:	c1 d8       	rjmp	800111b6 <_vfiprintf_r+0x59a>
8001117e:	fa c8 f9 84 	sub	r8,sp,-1660
80011182:	1a d8       	st.w	--sp,r8
80011184:	fa c8 fa d0 	sub	r8,sp,-1328
80011188:	1a d8       	st.w	--sp,r8
8001118a:	fa c8 fb cc 	sub	r8,sp,-1076
8001118e:	1a d8       	st.w	--sp,r8
80011190:	fa c8 f9 74 	sub	r8,sp,-1676
80011194:	fa c9 ff cc 	sub	r9,sp,-52
80011198:	0a 9a       	mov	r10,r5
8001119a:	0e 9b       	mov	r11,r7
8001119c:	02 9c       	mov	r12,r1
8001119e:	fe b0 fb a5 	rcall	800108e8 <get_arg>
800111a2:	2f dd       	sub	sp,-12
800111a4:	19 b8       	ld.ub	r8,r12[0x3]
800111a6:	c2 28       	rjmp	800111ea <_vfiprintf_r+0x5ce>
800111a8:	2f f6       	sub	r6,-1
800111aa:	10 39       	cp.w	r9,r8
800111ac:	c0 84       	brge	800111bc <_vfiprintf_r+0x5a0>
800111ae:	fa cb f9 78 	sub	r11,sp,-1672
800111b2:	f6 07 00 37 	add	r7,r11,r7<<0x3
800111b6:	ef 38 fd a7 	ld.ub	r8,r7[-601]
800111ba:	c1 88       	rjmp	800111ea <_vfiprintf_r+0x5ce>
800111bc:	40 a9       	lddsp	r9,sp[0x28]
800111be:	59 f8       	cp.w	r8,31
800111c0:	e0 89 00 12 	brgt	800111e4 <_vfiprintf_r+0x5c8>
800111c4:	f2 ca ff fc 	sub	r10,r9,-4
800111c8:	50 aa       	stdsp	sp[0x28],r10
800111ca:	72 09       	ld.w	r9,r9[0x0]
800111cc:	fa c2 f9 78 	sub	r2,sp,-1672
800111d0:	e4 08 00 3a 	add	r10,r2,r8<<0x3
800111d4:	2f f8       	sub	r8,-1
800111d6:	f5 49 fd a4 	st.w	r10[-604],r9
800111da:	fb 48 06 80 	st.w	sp[1664],r8
800111de:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800111e2:	c0 48       	rjmp	800111ea <_vfiprintf_r+0x5ce>
800111e4:	13 b8       	ld.ub	r8,r9[0x3]
800111e6:	2f c9       	sub	r9,-4
800111e8:	50 a9       	stdsp	sp[0x28],r9
800111ea:	30 0e       	mov	lr,0
800111ec:	fb 68 06 48 	st.b	sp[1608],r8
800111f0:	fb 6e 06 87 	st.b	sp[1671],lr
800111f4:	e0 8f 06 a0 	bral	80011f34 <_vfiprintf_r+0x1318>
800111f8:	a5 a3       	sbr	r3,0x4
800111fa:	0c 92       	mov	r2,r6
800111fc:	ed b3 00 05 	bld	r3,0x5
80011200:	c4 d1       	brne	8001129a <_vfiprintf_r+0x67e>
80011202:	fa f8 06 80 	ld.w	r8,sp[1664]
80011206:	58 00       	cp.w	r0,0
80011208:	c1 e0       	breq	80011244 <_vfiprintf_r+0x628>
8001120a:	10 37       	cp.w	r7,r8
8001120c:	c0 64       	brge	80011218 <_vfiprintf_r+0x5fc>
8001120e:	fa cc f9 78 	sub	r12,sp,-1672
80011212:	f8 07 00 37 	add	r7,r12,r7<<0x3
80011216:	c1 f8       	rjmp	80011254 <_vfiprintf_r+0x638>
80011218:	fa c8 f9 84 	sub	r8,sp,-1660
8001121c:	1a d8       	st.w	--sp,r8
8001121e:	fa c8 fa d0 	sub	r8,sp,-1328
80011222:	0a 9a       	mov	r10,r5
80011224:	1a d8       	st.w	--sp,r8
80011226:	fa c8 fb cc 	sub	r8,sp,-1076
8001122a:	1a d8       	st.w	--sp,r8
8001122c:	fa c9 ff cc 	sub	r9,sp,-52
80011230:	fa c8 f9 74 	sub	r8,sp,-1676
80011234:	0e 9b       	mov	r11,r7
80011236:	02 9c       	mov	r12,r1
80011238:	fe b0 fb 58 	rcall	800108e8 <get_arg>
8001123c:	2f dd       	sub	sp,-12
8001123e:	78 1a       	ld.w	r10,r12[0x4]
80011240:	78 09       	ld.w	r9,r12[0x0]
80011242:	c2 88       	rjmp	80011292 <_vfiprintf_r+0x676>
80011244:	ec c2 ff ff 	sub	r2,r6,-1
80011248:	10 36       	cp.w	r6,r8
8001124a:	c0 a4       	brge	8001125e <_vfiprintf_r+0x642>
8001124c:	fa cb f9 78 	sub	r11,sp,-1672
80011250:	f6 07 00 37 	add	r7,r11,r7<<0x3
80011254:	ee fa fd a8 	ld.w	r10,r7[-600]
80011258:	ee f9 fd a4 	ld.w	r9,r7[-604]
8001125c:	c1 b8       	rjmp	80011292 <_vfiprintf_r+0x676>
8001125e:	40 a9       	lddsp	r9,sp[0x28]
80011260:	59 f8       	cp.w	r8,31
80011262:	e0 89 00 13 	brgt	80011288 <_vfiprintf_r+0x66c>
80011266:	f2 ca ff f8 	sub	r10,r9,-8
8001126a:	50 aa       	stdsp	sp[0x28],r10
8001126c:	fa c6 f9 78 	sub	r6,sp,-1672
80011270:	72 1a       	ld.w	r10,r9[0x4]
80011272:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80011276:	72 09       	ld.w	r9,r9[0x0]
80011278:	f7 4a fd a8 	st.w	r11[-600],r10
8001127c:	f7 49 fd a4 	st.w	r11[-604],r9
80011280:	2f f8       	sub	r8,-1
80011282:	fb 48 06 80 	st.w	sp[1664],r8
80011286:	c0 68       	rjmp	80011292 <_vfiprintf_r+0x676>
80011288:	f2 c8 ff f8 	sub	r8,r9,-8
8001128c:	72 1a       	ld.w	r10,r9[0x4]
8001128e:	50 a8       	stdsp	sp[0x28],r8
80011290:	72 09       	ld.w	r9,r9[0x0]
80011292:	04 96       	mov	r6,r2
80011294:	50 09       	stdsp	sp[0x0],r9
80011296:	50 1a       	stdsp	sp[0x4],r10
80011298:	cd 58       	rjmp	80011442 <_vfiprintf_r+0x826>
8001129a:	ed b3 00 04 	bld	r3,0x4
8001129e:	c4 41       	brne	80011326 <_vfiprintf_r+0x70a>
800112a0:	fa f8 06 80 	ld.w	r8,sp[1664]
800112a4:	58 00       	cp.w	r0,0
800112a6:	c1 d0       	breq	800112e0 <_vfiprintf_r+0x6c4>
800112a8:	10 37       	cp.w	r7,r8
800112aa:	c0 64       	brge	800112b6 <_vfiprintf_r+0x69a>
800112ac:	fa ce f9 78 	sub	lr,sp,-1672
800112b0:	fc 07 00 37 	add	r7,lr,r7<<0x3
800112b4:	c1 e8       	rjmp	800112f0 <_vfiprintf_r+0x6d4>
800112b6:	fa c8 f9 84 	sub	r8,sp,-1660
800112ba:	1a d8       	st.w	--sp,r8
800112bc:	fa c8 fa d0 	sub	r8,sp,-1328
800112c0:	0a 9a       	mov	r10,r5
800112c2:	1a d8       	st.w	--sp,r8
800112c4:	fa c8 fb cc 	sub	r8,sp,-1076
800112c8:	0e 9b       	mov	r11,r7
800112ca:	1a d8       	st.w	--sp,r8
800112cc:	02 9c       	mov	r12,r1
800112ce:	fa c8 f9 74 	sub	r8,sp,-1676
800112d2:	fa c9 ff cc 	sub	r9,sp,-52
800112d6:	fe b0 fb 09 	rcall	800108e8 <get_arg>
800112da:	2f dd       	sub	sp,-12
800112dc:	78 0a       	ld.w	r10,r12[0x0]
800112de:	c2 18       	rjmp	80011320 <_vfiprintf_r+0x704>
800112e0:	ec c2 ff ff 	sub	r2,r6,-1
800112e4:	10 36       	cp.w	r6,r8
800112e6:	c0 84       	brge	800112f6 <_vfiprintf_r+0x6da>
800112e8:	fa cc f9 78 	sub	r12,sp,-1672
800112ec:	f8 07 00 37 	add	r7,r12,r7<<0x3
800112f0:	ee fa fd a4 	ld.w	r10,r7[-604]
800112f4:	c1 68       	rjmp	80011320 <_vfiprintf_r+0x704>
800112f6:	40 a9       	lddsp	r9,sp[0x28]
800112f8:	59 f8       	cp.w	r8,31
800112fa:	e0 89 00 10 	brgt	8001131a <_vfiprintf_r+0x6fe>
800112fe:	f2 ca ff fc 	sub	r10,r9,-4
80011302:	50 aa       	stdsp	sp[0x28],r10
80011304:	fa cb f9 78 	sub	r11,sp,-1672
80011308:	72 0a       	ld.w	r10,r9[0x0]
8001130a:	f6 08 00 39 	add	r9,r11,r8<<0x3
8001130e:	f3 4a fd a4 	st.w	r9[-604],r10
80011312:	2f f8       	sub	r8,-1
80011314:	fb 48 06 80 	st.w	sp[1664],r8
80011318:	c0 48       	rjmp	80011320 <_vfiprintf_r+0x704>
8001131a:	72 0a       	ld.w	r10,r9[0x0]
8001131c:	2f c9       	sub	r9,-4
8001131e:	50 a9       	stdsp	sp[0x28],r9
80011320:	04 96       	mov	r6,r2
80011322:	50 1a       	stdsp	sp[0x4],r10
80011324:	c8 d8       	rjmp	8001143e <_vfiprintf_r+0x822>
80011326:	ed b3 00 06 	bld	r3,0x6
8001132a:	c4 81       	brne	800113ba <_vfiprintf_r+0x79e>
8001132c:	fa f8 06 80 	ld.w	r8,sp[1664]
80011330:	58 00       	cp.w	r0,0
80011332:	c1 d0       	breq	8001136c <_vfiprintf_r+0x750>
80011334:	10 37       	cp.w	r7,r8
80011336:	c0 64       	brge	80011342 <_vfiprintf_r+0x726>
80011338:	fa c8 f9 78 	sub	r8,sp,-1672
8001133c:	f0 07 00 37 	add	r7,r8,r7<<0x3
80011340:	c1 e8       	rjmp	8001137c <_vfiprintf_r+0x760>
80011342:	fa c8 f9 84 	sub	r8,sp,-1660
80011346:	1a d8       	st.w	--sp,r8
80011348:	fa c8 fa d0 	sub	r8,sp,-1328
8001134c:	1a d8       	st.w	--sp,r8
8001134e:	fa c8 fb cc 	sub	r8,sp,-1076
80011352:	1a d8       	st.w	--sp,r8
80011354:	fa c8 f9 74 	sub	r8,sp,-1676
80011358:	fa c9 ff cc 	sub	r9,sp,-52
8001135c:	0a 9a       	mov	r10,r5
8001135e:	0e 9b       	mov	r11,r7
80011360:	02 9c       	mov	r12,r1
80011362:	fe b0 fa c3 	rcall	800108e8 <get_arg>
80011366:	2f dd       	sub	sp,-12
80011368:	98 18       	ld.sh	r8,r12[0x2]
8001136a:	c2 38       	rjmp	800113b0 <_vfiprintf_r+0x794>
8001136c:	ec c2 ff ff 	sub	r2,r6,-1
80011370:	10 36       	cp.w	r6,r8
80011372:	c0 84       	brge	80011382 <_vfiprintf_r+0x766>
80011374:	fa c6 f9 78 	sub	r6,sp,-1672
80011378:	ec 07 00 37 	add	r7,r6,r7<<0x3
8001137c:	ef 08 fd a6 	ld.sh	r8,r7[-602]
80011380:	c1 88       	rjmp	800113b0 <_vfiprintf_r+0x794>
80011382:	40 a9       	lddsp	r9,sp[0x28]
80011384:	59 f8       	cp.w	r8,31
80011386:	e0 89 00 12 	brgt	800113aa <_vfiprintf_r+0x78e>
8001138a:	f2 ca ff fc 	sub	r10,r9,-4
8001138e:	50 aa       	stdsp	sp[0x28],r10
80011390:	72 09       	ld.w	r9,r9[0x0]
80011392:	fa ce f9 78 	sub	lr,sp,-1672
80011396:	fc 08 00 3a 	add	r10,lr,r8<<0x3
8001139a:	2f f8       	sub	r8,-1
8001139c:	f5 49 fd a4 	st.w	r10[-604],r9
800113a0:	fb 48 06 80 	st.w	sp[1664],r8
800113a4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800113a8:	c0 48       	rjmp	800113b0 <_vfiprintf_r+0x794>
800113aa:	92 18       	ld.sh	r8,r9[0x2]
800113ac:	2f c9       	sub	r9,-4
800113ae:	50 a9       	stdsp	sp[0x28],r9
800113b0:	50 18       	stdsp	sp[0x4],r8
800113b2:	04 96       	mov	r6,r2
800113b4:	bf 58       	asr	r8,0x1f
800113b6:	50 08       	stdsp	sp[0x0],r8
800113b8:	c4 58       	rjmp	80011442 <_vfiprintf_r+0x826>
800113ba:	fa f8 06 80 	ld.w	r8,sp[1664]
800113be:	58 00       	cp.w	r0,0
800113c0:	c1 d0       	breq	800113fa <_vfiprintf_r+0x7de>
800113c2:	10 37       	cp.w	r7,r8
800113c4:	c0 64       	brge	800113d0 <_vfiprintf_r+0x7b4>
800113c6:	fa cb f9 78 	sub	r11,sp,-1672
800113ca:	f6 07 00 37 	add	r7,r11,r7<<0x3
800113ce:	c1 e8       	rjmp	8001140a <_vfiprintf_r+0x7ee>
800113d0:	fa c8 f9 84 	sub	r8,sp,-1660
800113d4:	1a d8       	st.w	--sp,r8
800113d6:	fa c8 fa d0 	sub	r8,sp,-1328
800113da:	0a 9a       	mov	r10,r5
800113dc:	1a d8       	st.w	--sp,r8
800113de:	fa c8 fb cc 	sub	r8,sp,-1076
800113e2:	0e 9b       	mov	r11,r7
800113e4:	1a d8       	st.w	--sp,r8
800113e6:	02 9c       	mov	r12,r1
800113e8:	fa c8 f9 74 	sub	r8,sp,-1676
800113ec:	fa c9 ff cc 	sub	r9,sp,-52
800113f0:	fe b0 fa 7c 	rcall	800108e8 <get_arg>
800113f4:	2f dd       	sub	sp,-12
800113f6:	78 0a       	ld.w	r10,r12[0x0]
800113f8:	c2 18       	rjmp	8001143a <_vfiprintf_r+0x81e>
800113fa:	ec c2 ff ff 	sub	r2,r6,-1
800113fe:	10 36       	cp.w	r6,r8
80011400:	c0 84       	brge	80011410 <_vfiprintf_r+0x7f4>
80011402:	fa ca f9 78 	sub	r10,sp,-1672
80011406:	f4 07 00 37 	add	r7,r10,r7<<0x3
8001140a:	ee fa fd a4 	ld.w	r10,r7[-604]
8001140e:	c1 68       	rjmp	8001143a <_vfiprintf_r+0x81e>
80011410:	40 a9       	lddsp	r9,sp[0x28]
80011412:	59 f8       	cp.w	r8,31
80011414:	e0 89 00 10 	brgt	80011434 <_vfiprintf_r+0x818>
80011418:	f2 ca ff fc 	sub	r10,r9,-4
8001141c:	50 aa       	stdsp	sp[0x28],r10
8001141e:	fa c6 f9 78 	sub	r6,sp,-1672
80011422:	72 0a       	ld.w	r10,r9[0x0]
80011424:	ec 08 00 39 	add	r9,r6,r8<<0x3
80011428:	f3 4a fd a4 	st.w	r9[-604],r10
8001142c:	2f f8       	sub	r8,-1
8001142e:	fb 48 06 80 	st.w	sp[1664],r8
80011432:	c0 48       	rjmp	8001143a <_vfiprintf_r+0x81e>
80011434:	72 0a       	ld.w	r10,r9[0x0]
80011436:	2f c9       	sub	r9,-4
80011438:	50 a9       	stdsp	sp[0x28],r9
8001143a:	04 96       	mov	r6,r2
8001143c:	50 1a       	stdsp	sp[0x4],r10
8001143e:	bf 5a       	asr	r10,0x1f
80011440:	50 0a       	stdsp	sp[0x0],r10
80011442:	fa ea 00 00 	ld.d	r10,sp[0]
80011446:	58 0a       	cp.w	r10,0
80011448:	5c 2b       	cpc	r11
8001144a:	c0 e4       	brge	80011466 <_vfiprintf_r+0x84a>
8001144c:	30 08       	mov	r8,0
8001144e:	fa ea 00 00 	ld.d	r10,sp[0]
80011452:	30 09       	mov	r9,0
80011454:	f0 0a 01 0a 	sub	r10,r8,r10
80011458:	f2 0b 01 4b 	sbc	r11,r9,r11
8001145c:	32 d8       	mov	r8,45
8001145e:	fa eb 00 00 	st.d	sp[0],r10
80011462:	fb 68 06 87 	st.b	sp[1671],r8
80011466:	30 10       	mov	r0,1
80011468:	e0 8f 04 da 	bral	80011e1c <_vfiprintf_r+0x1200>
8001146c:	0c 99       	mov	r9,r6
8001146e:	ed b3 00 05 	bld	r3,0x5
80011472:	c4 71       	brne	80011500 <_vfiprintf_r+0x8e4>
80011474:	fa f8 06 80 	ld.w	r8,sp[1664]
80011478:	58 00       	cp.w	r0,0
8001147a:	c1 d0       	breq	800114b4 <_vfiprintf_r+0x898>
8001147c:	10 37       	cp.w	r7,r8
8001147e:	c0 64       	brge	8001148a <_vfiprintf_r+0x86e>
80011480:	fa ca f9 78 	sub	r10,sp,-1672
80011484:	f4 07 00 37 	add	r7,r10,r7<<0x3
80011488:	c1 d8       	rjmp	800114c2 <_vfiprintf_r+0x8a6>
8001148a:	fa c8 f9 84 	sub	r8,sp,-1660
8001148e:	1a d8       	st.w	--sp,r8
80011490:	fa c8 fa d0 	sub	r8,sp,-1328
80011494:	0a 9a       	mov	r10,r5
80011496:	1a d8       	st.w	--sp,r8
80011498:	fa c8 fb cc 	sub	r8,sp,-1076
8001149c:	0e 9b       	mov	r11,r7
8001149e:	1a d8       	st.w	--sp,r8
800114a0:	02 9c       	mov	r12,r1
800114a2:	fa c8 f9 74 	sub	r8,sp,-1676
800114a6:	fa c9 ff cc 	sub	r9,sp,-52
800114aa:	fe b0 fa 1f 	rcall	800108e8 <get_arg>
800114ae:	2f dd       	sub	sp,-12
800114b0:	78 0a       	ld.w	r10,r12[0x0]
800114b2:	c2 08       	rjmp	800114f2 <_vfiprintf_r+0x8d6>
800114b4:	2f f6       	sub	r6,-1
800114b6:	10 39       	cp.w	r9,r8
800114b8:	c0 84       	brge	800114c8 <_vfiprintf_r+0x8ac>
800114ba:	fa c9 f9 78 	sub	r9,sp,-1672
800114be:	f2 07 00 37 	add	r7,r9,r7<<0x3
800114c2:	ee fa fd a4 	ld.w	r10,r7[-604]
800114c6:	c1 68       	rjmp	800114f2 <_vfiprintf_r+0x8d6>
800114c8:	40 a9       	lddsp	r9,sp[0x28]
800114ca:	59 f8       	cp.w	r8,31
800114cc:	e0 89 00 10 	brgt	800114ec <_vfiprintf_r+0x8d0>
800114d0:	f2 ca ff fc 	sub	r10,r9,-4
800114d4:	50 aa       	stdsp	sp[0x28],r10
800114d6:	fa c3 f9 78 	sub	r3,sp,-1672
800114da:	72 0a       	ld.w	r10,r9[0x0]
800114dc:	e6 08 00 39 	add	r9,r3,r8<<0x3
800114e0:	f3 4a fd a4 	st.w	r9[-604],r10
800114e4:	2f f8       	sub	r8,-1
800114e6:	fb 48 06 80 	st.w	sp[1664],r8
800114ea:	c0 48       	rjmp	800114f2 <_vfiprintf_r+0x8d6>
800114ec:	72 0a       	ld.w	r10,r9[0x0]
800114ee:	2f c9       	sub	r9,-4
800114f0:	50 a9       	stdsp	sp[0x28],r9
800114f2:	40 62       	lddsp	r2,sp[0x18]
800114f4:	04 98       	mov	r8,r2
800114f6:	95 12       	st.w	r10[0x4],r2
800114f8:	bf 58       	asr	r8,0x1f
800114fa:	95 08       	st.w	r10[0x0],r8
800114fc:	fe 9f fc 11 	bral	80010d1e <_vfiprintf_r+0x102>
80011500:	ed b3 00 04 	bld	r3,0x4
80011504:	c4 41       	brne	8001158c <_vfiprintf_r+0x970>
80011506:	fa f8 06 80 	ld.w	r8,sp[1664]
8001150a:	58 00       	cp.w	r0,0
8001150c:	c1 d0       	breq	80011546 <_vfiprintf_r+0x92a>
8001150e:	10 37       	cp.w	r7,r8
80011510:	c0 64       	brge	8001151c <_vfiprintf_r+0x900>
80011512:	fa ce f9 78 	sub	lr,sp,-1672
80011516:	fc 07 00 37 	add	r7,lr,r7<<0x3
8001151a:	c1 d8       	rjmp	80011554 <_vfiprintf_r+0x938>
8001151c:	fa c8 f9 84 	sub	r8,sp,-1660
80011520:	1a d8       	st.w	--sp,r8
80011522:	fa c8 fa d0 	sub	r8,sp,-1328
80011526:	0a 9a       	mov	r10,r5
80011528:	1a d8       	st.w	--sp,r8
8001152a:	fa c8 fb cc 	sub	r8,sp,-1076
8001152e:	0e 9b       	mov	r11,r7
80011530:	1a d8       	st.w	--sp,r8
80011532:	02 9c       	mov	r12,r1
80011534:	fa c8 f9 74 	sub	r8,sp,-1676
80011538:	fa c9 ff cc 	sub	r9,sp,-52
8001153c:	fe b0 f9 d6 	rcall	800108e8 <get_arg>
80011540:	2f dd       	sub	sp,-12
80011542:	78 0a       	ld.w	r10,r12[0x0]
80011544:	c2 08       	rjmp	80011584 <_vfiprintf_r+0x968>
80011546:	2f f6       	sub	r6,-1
80011548:	10 39       	cp.w	r9,r8
8001154a:	c0 84       	brge	8001155a <_vfiprintf_r+0x93e>
8001154c:	fa cc f9 78 	sub	r12,sp,-1672
80011550:	f8 07 00 37 	add	r7,r12,r7<<0x3
80011554:	ee fa fd a4 	ld.w	r10,r7[-604]
80011558:	c1 68       	rjmp	80011584 <_vfiprintf_r+0x968>
8001155a:	40 a9       	lddsp	r9,sp[0x28]
8001155c:	59 f8       	cp.w	r8,31
8001155e:	e0 89 00 10 	brgt	8001157e <_vfiprintf_r+0x962>
80011562:	f2 ca ff fc 	sub	r10,r9,-4
80011566:	50 aa       	stdsp	sp[0x28],r10
80011568:	fa cb f9 78 	sub	r11,sp,-1672
8001156c:	72 0a       	ld.w	r10,r9[0x0]
8001156e:	f6 08 00 39 	add	r9,r11,r8<<0x3
80011572:	f3 4a fd a4 	st.w	r9[-604],r10
80011576:	2f f8       	sub	r8,-1
80011578:	fb 48 06 80 	st.w	sp[1664],r8
8001157c:	c0 48       	rjmp	80011584 <_vfiprintf_r+0x968>
8001157e:	72 0a       	ld.w	r10,r9[0x0]
80011580:	2f c9       	sub	r9,-4
80011582:	50 a9       	stdsp	sp[0x28],r9
80011584:	40 69       	lddsp	r9,sp[0x18]
80011586:	95 09       	st.w	r10[0x0],r9
80011588:	fe 9f fb cb 	bral	80010d1e <_vfiprintf_r+0x102>
8001158c:	e2 13 00 40 	andl	r3,0x40,COH
80011590:	c4 40       	breq	80011618 <_vfiprintf_r+0x9fc>
80011592:	fa f8 06 80 	ld.w	r8,sp[1664]
80011596:	58 00       	cp.w	r0,0
80011598:	c1 d0       	breq	800115d2 <_vfiprintf_r+0x9b6>
8001159a:	10 37       	cp.w	r7,r8
8001159c:	c0 64       	brge	800115a8 <_vfiprintf_r+0x98c>
8001159e:	fa c8 f9 78 	sub	r8,sp,-1672
800115a2:	f0 07 00 37 	add	r7,r8,r7<<0x3
800115a6:	c1 d8       	rjmp	800115e0 <_vfiprintf_r+0x9c4>
800115a8:	fa c8 f9 84 	sub	r8,sp,-1660
800115ac:	1a d8       	st.w	--sp,r8
800115ae:	fa c8 fa d0 	sub	r8,sp,-1328
800115b2:	0a 9a       	mov	r10,r5
800115b4:	1a d8       	st.w	--sp,r8
800115b6:	fa c8 fb cc 	sub	r8,sp,-1076
800115ba:	0e 9b       	mov	r11,r7
800115bc:	1a d8       	st.w	--sp,r8
800115be:	02 9c       	mov	r12,r1
800115c0:	fa c8 f9 74 	sub	r8,sp,-1676
800115c4:	fa c9 ff cc 	sub	r9,sp,-52
800115c8:	fe b0 f9 90 	rcall	800108e8 <get_arg>
800115cc:	2f dd       	sub	sp,-12
800115ce:	78 0a       	ld.w	r10,r12[0x0]
800115d0:	c2 08       	rjmp	80011610 <_vfiprintf_r+0x9f4>
800115d2:	2f f6       	sub	r6,-1
800115d4:	10 39       	cp.w	r9,r8
800115d6:	c0 84       	brge	800115e6 <_vfiprintf_r+0x9ca>
800115d8:	fa c3 f9 78 	sub	r3,sp,-1672
800115dc:	e6 07 00 37 	add	r7,r3,r7<<0x3
800115e0:	ee fa fd a4 	ld.w	r10,r7[-604]
800115e4:	c1 68       	rjmp	80011610 <_vfiprintf_r+0x9f4>
800115e6:	40 a9       	lddsp	r9,sp[0x28]
800115e8:	59 f8       	cp.w	r8,31
800115ea:	e0 89 00 10 	brgt	8001160a <_vfiprintf_r+0x9ee>
800115ee:	f2 ca ff fc 	sub	r10,r9,-4
800115f2:	50 aa       	stdsp	sp[0x28],r10
800115f4:	fa c2 f9 78 	sub	r2,sp,-1672
800115f8:	72 0a       	ld.w	r10,r9[0x0]
800115fa:	e4 08 00 39 	add	r9,r2,r8<<0x3
800115fe:	f3 4a fd a4 	st.w	r9[-604],r10
80011602:	2f f8       	sub	r8,-1
80011604:	fb 48 06 80 	st.w	sp[1664],r8
80011608:	c0 48       	rjmp	80011610 <_vfiprintf_r+0x9f4>
8001160a:	72 0a       	ld.w	r10,r9[0x0]
8001160c:	2f c9       	sub	r9,-4
8001160e:	50 a9       	stdsp	sp[0x28],r9
80011610:	40 6e       	lddsp	lr,sp[0x18]
80011612:	b4 0e       	st.h	r10[0x0],lr
80011614:	fe 9f fb 85 	bral	80010d1e <_vfiprintf_r+0x102>
80011618:	fa f8 06 80 	ld.w	r8,sp[1664]
8001161c:	58 00       	cp.w	r0,0
8001161e:	c1 d0       	breq	80011658 <_vfiprintf_r+0xa3c>
80011620:	10 37       	cp.w	r7,r8
80011622:	c0 64       	brge	8001162e <_vfiprintf_r+0xa12>
80011624:	fa cc f9 78 	sub	r12,sp,-1672
80011628:	f8 07 00 37 	add	r7,r12,r7<<0x3
8001162c:	c1 d8       	rjmp	80011666 <_vfiprintf_r+0xa4a>
8001162e:	fa c8 f9 84 	sub	r8,sp,-1660
80011632:	1a d8       	st.w	--sp,r8
80011634:	fa c8 fa d0 	sub	r8,sp,-1328
80011638:	0a 9a       	mov	r10,r5
8001163a:	1a d8       	st.w	--sp,r8
8001163c:	fa c8 fb cc 	sub	r8,sp,-1076
80011640:	0e 9b       	mov	r11,r7
80011642:	1a d8       	st.w	--sp,r8
80011644:	02 9c       	mov	r12,r1
80011646:	fa c8 f9 74 	sub	r8,sp,-1676
8001164a:	fa c9 ff cc 	sub	r9,sp,-52
8001164e:	fe b0 f9 4d 	rcall	800108e8 <get_arg>
80011652:	2f dd       	sub	sp,-12
80011654:	78 0a       	ld.w	r10,r12[0x0]
80011656:	c2 08       	rjmp	80011696 <_vfiprintf_r+0xa7a>
80011658:	2f f6       	sub	r6,-1
8001165a:	10 39       	cp.w	r9,r8
8001165c:	c0 84       	brge	8001166c <_vfiprintf_r+0xa50>
8001165e:	fa cb f9 78 	sub	r11,sp,-1672
80011662:	f6 07 00 37 	add	r7,r11,r7<<0x3
80011666:	ee fa fd a4 	ld.w	r10,r7[-604]
8001166a:	c1 68       	rjmp	80011696 <_vfiprintf_r+0xa7a>
8001166c:	40 a9       	lddsp	r9,sp[0x28]
8001166e:	59 f8       	cp.w	r8,31
80011670:	e0 89 00 10 	brgt	80011690 <_vfiprintf_r+0xa74>
80011674:	f2 ca ff fc 	sub	r10,r9,-4
80011678:	50 aa       	stdsp	sp[0x28],r10
8001167a:	fa c3 f9 78 	sub	r3,sp,-1672
8001167e:	72 0a       	ld.w	r10,r9[0x0]
80011680:	e6 08 00 39 	add	r9,r3,r8<<0x3
80011684:	f3 4a fd a4 	st.w	r9[-604],r10
80011688:	2f f8       	sub	r8,-1
8001168a:	fb 48 06 80 	st.w	sp[1664],r8
8001168e:	c0 48       	rjmp	80011696 <_vfiprintf_r+0xa7a>
80011690:	72 0a       	ld.w	r10,r9[0x0]
80011692:	2f c9       	sub	r9,-4
80011694:	50 a9       	stdsp	sp[0x28],r9
80011696:	40 62       	lddsp	r2,sp[0x18]
80011698:	95 02       	st.w	r10[0x0],r2
8001169a:	fe 9f fb 42 	bral	80010d1e <_vfiprintf_r+0x102>
8001169e:	a5 a3       	sbr	r3,0x4
800116a0:	0c 99       	mov	r9,r6
800116a2:	ed b3 00 05 	bld	r3,0x5
800116a6:	c5 71       	brne	80011754 <_vfiprintf_r+0xb38>
800116a8:	fa f8 06 80 	ld.w	r8,sp[1664]
800116ac:	58 00       	cp.w	r0,0
800116ae:	c2 60       	breq	800116fa <_vfiprintf_r+0xade>
800116b0:	10 37       	cp.w	r7,r8
800116b2:	c0 a4       	brge	800116c6 <_vfiprintf_r+0xaaa>
800116b4:	fa ce f9 78 	sub	lr,sp,-1672
800116b8:	fc 07 00 37 	add	r7,lr,r7<<0x3
800116bc:	ee ea fd a4 	ld.d	r10,r7[-604]
800116c0:	fa eb 00 00 	st.d	sp[0],r10
800116c4:	c1 88       	rjmp	800116f4 <_vfiprintf_r+0xad8>
800116c6:	fa c8 f9 84 	sub	r8,sp,-1660
800116ca:	1a d8       	st.w	--sp,r8
800116cc:	fa c8 fa d0 	sub	r8,sp,-1328
800116d0:	1a d8       	st.w	--sp,r8
800116d2:	fa c8 fb cc 	sub	r8,sp,-1076
800116d6:	1a d8       	st.w	--sp,r8
800116d8:	fa c8 f9 74 	sub	r8,sp,-1676
800116dc:	fa c9 ff cc 	sub	r9,sp,-52
800116e0:	0a 9a       	mov	r10,r5
800116e2:	0e 9b       	mov	r11,r7
800116e4:	02 9c       	mov	r12,r1
800116e6:	fe b0 f9 01 	rcall	800108e8 <get_arg>
800116ea:	2f dd       	sub	sp,-12
800116ec:	f8 e8 00 00 	ld.d	r8,r12[0]
800116f0:	fa e9 00 00 	st.d	sp[0],r8
800116f4:	30 00       	mov	r0,0
800116f6:	e0 8f 03 90 	bral	80011e16 <_vfiprintf_r+0x11fa>
800116fa:	2f f6       	sub	r6,-1
800116fc:	10 39       	cp.w	r9,r8
800116fe:	c0 b4       	brge	80011714 <_vfiprintf_r+0xaf8>
80011700:	fa c8 f9 78 	sub	r8,sp,-1672
80011704:	f0 07 00 37 	add	r7,r8,r7<<0x3
80011708:	ee ea fd a4 	ld.d	r10,r7[-604]
8001170c:	fa eb 00 00 	st.d	sp[0],r10
80011710:	e0 8f 03 83 	bral	80011e16 <_vfiprintf_r+0x11fa>
80011714:	40 a9       	lddsp	r9,sp[0x28]
80011716:	59 f8       	cp.w	r8,31
80011718:	e0 89 00 16 	brgt	80011744 <_vfiprintf_r+0xb28>
8001171c:	f2 ca ff f8 	sub	r10,r9,-8
80011720:	50 aa       	stdsp	sp[0x28],r10
80011722:	f2 ea 00 00 	ld.d	r10,r9[0]
80011726:	fa eb 00 00 	st.d	sp[0],r10
8001172a:	fa ca f9 78 	sub	r10,sp,-1672
8001172e:	f4 08 00 39 	add	r9,r10,r8<<0x3
80011732:	fa ea 00 00 	ld.d	r10,sp[0]
80011736:	f2 eb fd a4 	st.d	r9[-604],r10
8001173a:	2f f8       	sub	r8,-1
8001173c:	fb 48 06 80 	st.w	sp[1664],r8
80011740:	e0 8f 03 6b 	bral	80011e16 <_vfiprintf_r+0x11fa>
80011744:	f2 ea 00 00 	ld.d	r10,r9[0]
80011748:	2f 89       	sub	r9,-8
8001174a:	fa eb 00 00 	st.d	sp[0],r10
8001174e:	50 a9       	stdsp	sp[0x28],r9
80011750:	e0 8f 03 63 	bral	80011e16 <_vfiprintf_r+0x11fa>
80011754:	ed b3 00 04 	bld	r3,0x4
80011758:	c1 41       	brne	80011780 <_vfiprintf_r+0xb64>
8001175a:	fa f8 06 80 	ld.w	r8,sp[1664]
8001175e:	58 00       	cp.w	r0,0
80011760:	c0 80       	breq	80011770 <_vfiprintf_r+0xb54>
80011762:	10 37       	cp.w	r7,r8
80011764:	c6 04       	brge	80011824 <_vfiprintf_r+0xc08>
80011766:	fa ca f9 78 	sub	r10,sp,-1672
8001176a:	f4 07 00 37 	add	r7,r10,r7<<0x3
8001176e:	c7 78       	rjmp	8001185c <_vfiprintf_r+0xc40>
80011770:	2f f6       	sub	r6,-1
80011772:	10 39       	cp.w	r9,r8
80011774:	c7 74       	brge	80011862 <_vfiprintf_r+0xc46>
80011776:	fa c9 f9 78 	sub	r9,sp,-1672
8001177a:	f2 07 00 37 	add	r7,r9,r7<<0x3
8001177e:	c6 f8       	rjmp	8001185c <_vfiprintf_r+0xc40>
80011780:	ed b3 00 06 	bld	r3,0x6
80011784:	c4 51       	brne	8001180e <_vfiprintf_r+0xbf2>
80011786:	fa f8 06 80 	ld.w	r8,sp[1664]
8001178a:	58 00       	cp.w	r0,0
8001178c:	c1 d0       	breq	800117c6 <_vfiprintf_r+0xbaa>
8001178e:	10 37       	cp.w	r7,r8
80011790:	c0 64       	brge	8001179c <_vfiprintf_r+0xb80>
80011792:	fa cc f9 78 	sub	r12,sp,-1672
80011796:	f8 07 00 37 	add	r7,r12,r7<<0x3
8001179a:	c1 d8       	rjmp	800117d4 <_vfiprintf_r+0xbb8>
8001179c:	fa c8 f9 84 	sub	r8,sp,-1660
800117a0:	1a d8       	st.w	--sp,r8
800117a2:	fa c8 fa d0 	sub	r8,sp,-1328
800117a6:	1a d8       	st.w	--sp,r8
800117a8:	fa c8 fb cc 	sub	r8,sp,-1076
800117ac:	1a d8       	st.w	--sp,r8
800117ae:	fa c8 f9 74 	sub	r8,sp,-1676
800117b2:	fa c9 ff cc 	sub	r9,sp,-52
800117b6:	0a 9a       	mov	r10,r5
800117b8:	0e 9b       	mov	r11,r7
800117ba:	02 9c       	mov	r12,r1
800117bc:	fe b0 f8 96 	rcall	800108e8 <get_arg>
800117c0:	2f dd       	sub	sp,-12
800117c2:	98 18       	ld.sh	r8,r12[0x2]
800117c4:	c2 28       	rjmp	80011808 <_vfiprintf_r+0xbec>
800117c6:	2f f6       	sub	r6,-1
800117c8:	10 39       	cp.w	r9,r8
800117ca:	c0 84       	brge	800117da <_vfiprintf_r+0xbbe>
800117cc:	fa cb f9 78 	sub	r11,sp,-1672
800117d0:	f6 07 00 37 	add	r7,r11,r7<<0x3
800117d4:	ef 08 fd a6 	ld.sh	r8,r7[-602]
800117d8:	c1 88       	rjmp	80011808 <_vfiprintf_r+0xbec>
800117da:	40 a9       	lddsp	r9,sp[0x28]
800117dc:	59 f8       	cp.w	r8,31
800117de:	e0 89 00 12 	brgt	80011802 <_vfiprintf_r+0xbe6>
800117e2:	f2 ca ff fc 	sub	r10,r9,-4
800117e6:	50 aa       	stdsp	sp[0x28],r10
800117e8:	72 09       	ld.w	r9,r9[0x0]
800117ea:	fa c2 f9 78 	sub	r2,sp,-1672
800117ee:	e4 08 00 3a 	add	r10,r2,r8<<0x3
800117f2:	2f f8       	sub	r8,-1
800117f4:	f5 49 fd a4 	st.w	r10[-604],r9
800117f8:	fb 48 06 80 	st.w	sp[1664],r8
800117fc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80011800:	c0 48       	rjmp	80011808 <_vfiprintf_r+0xbec>
80011802:	92 18       	ld.sh	r8,r9[0x2]
80011804:	2f c9       	sub	r9,-4
80011806:	50 a9       	stdsp	sp[0x28],r9
80011808:	5c 78       	castu.h	r8
8001180a:	50 18       	stdsp	sp[0x4],r8
8001180c:	c4 18       	rjmp	8001188e <_vfiprintf_r+0xc72>
8001180e:	fa f8 06 80 	ld.w	r8,sp[1664]
80011812:	58 00       	cp.w	r0,0
80011814:	c1 d0       	breq	8001184e <_vfiprintf_r+0xc32>
80011816:	10 37       	cp.w	r7,r8
80011818:	c0 64       	brge	80011824 <_vfiprintf_r+0xc08>
8001181a:	fa cc f9 78 	sub	r12,sp,-1672
8001181e:	f8 07 00 37 	add	r7,r12,r7<<0x3
80011822:	c1 d8       	rjmp	8001185c <_vfiprintf_r+0xc40>
80011824:	fa c8 f9 84 	sub	r8,sp,-1660
80011828:	1a d8       	st.w	--sp,r8
8001182a:	fa c8 fa d0 	sub	r8,sp,-1328
8001182e:	0a 9a       	mov	r10,r5
80011830:	1a d8       	st.w	--sp,r8
80011832:	fa c8 fb cc 	sub	r8,sp,-1076
80011836:	0e 9b       	mov	r11,r7
80011838:	1a d8       	st.w	--sp,r8
8001183a:	02 9c       	mov	r12,r1
8001183c:	fa c8 f9 74 	sub	r8,sp,-1676
80011840:	fa c9 ff cc 	sub	r9,sp,-52
80011844:	fe b0 f8 52 	rcall	800108e8 <get_arg>
80011848:	2f dd       	sub	sp,-12
8001184a:	78 0a       	ld.w	r10,r12[0x0]
8001184c:	c2 08       	rjmp	8001188c <_vfiprintf_r+0xc70>
8001184e:	2f f6       	sub	r6,-1
80011850:	10 39       	cp.w	r9,r8
80011852:	c0 84       	brge	80011862 <_vfiprintf_r+0xc46>
80011854:	fa cb f9 78 	sub	r11,sp,-1672
80011858:	f6 07 00 37 	add	r7,r11,r7<<0x3
8001185c:	ee fa fd a4 	ld.w	r10,r7[-604]
80011860:	c1 68       	rjmp	8001188c <_vfiprintf_r+0xc70>
80011862:	40 a9       	lddsp	r9,sp[0x28]
80011864:	59 f8       	cp.w	r8,31
80011866:	e0 89 00 10 	brgt	80011886 <_vfiprintf_r+0xc6a>
8001186a:	f2 ca ff fc 	sub	r10,r9,-4
8001186e:	50 aa       	stdsp	sp[0x28],r10
80011870:	fa c2 f9 78 	sub	r2,sp,-1672
80011874:	72 0a       	ld.w	r10,r9[0x0]
80011876:	e4 08 00 39 	add	r9,r2,r8<<0x3
8001187a:	f3 4a fd a4 	st.w	r9[-604],r10
8001187e:	2f f8       	sub	r8,-1
80011880:	fb 48 06 80 	st.w	sp[1664],r8
80011884:	c0 48       	rjmp	8001188c <_vfiprintf_r+0xc70>
80011886:	72 0a       	ld.w	r10,r9[0x0]
80011888:	2f c9       	sub	r9,-4
8001188a:	50 a9       	stdsp	sp[0x28],r9
8001188c:	50 1a       	stdsp	sp[0x4],r10
8001188e:	30 0e       	mov	lr,0
80011890:	50 0e       	stdsp	sp[0x0],lr
80011892:	1c 90       	mov	r0,lr
80011894:	e0 8f 02 c1 	bral	80011e16 <_vfiprintf_r+0x11fa>
80011898:	50 57       	stdsp	sp[0x14],r7
8001189a:	50 42       	stdsp	sp[0x10],r2
8001189c:	08 97       	mov	r7,r4
8001189e:	40 85       	lddsp	r5,sp[0x20]
800118a0:	40 74       	lddsp	r4,sp[0x1c]
800118a2:	0c 99       	mov	r9,r6
800118a4:	fa f8 06 80 	ld.w	r8,sp[1664]
800118a8:	58 00       	cp.w	r0,0
800118aa:	c1 d0       	breq	800118e4 <_vfiprintf_r+0xcc8>
800118ac:	10 37       	cp.w	r7,r8
800118ae:	c0 64       	brge	800118ba <_vfiprintf_r+0xc9e>
800118b0:	fa cc f9 78 	sub	r12,sp,-1672
800118b4:	f8 07 00 37 	add	r7,r12,r7<<0x3
800118b8:	c1 d8       	rjmp	800118f2 <_vfiprintf_r+0xcd6>
800118ba:	fa c8 f9 84 	sub	r8,sp,-1660
800118be:	1a d8       	st.w	--sp,r8
800118c0:	fa c8 fa d0 	sub	r8,sp,-1328
800118c4:	1a d8       	st.w	--sp,r8
800118c6:	fa c8 fb cc 	sub	r8,sp,-1076
800118ca:	1a d8       	st.w	--sp,r8
800118cc:	fa c9 ff cc 	sub	r9,sp,-52
800118d0:	fa c8 f9 74 	sub	r8,sp,-1676
800118d4:	0a 9a       	mov	r10,r5
800118d6:	0e 9b       	mov	r11,r7
800118d8:	02 9c       	mov	r12,r1
800118da:	fe b0 f8 07 	rcall	800108e8 <get_arg>
800118de:	2f dd       	sub	sp,-12
800118e0:	78 09       	ld.w	r9,r12[0x0]
800118e2:	c2 18       	rjmp	80011924 <_vfiprintf_r+0xd08>
800118e4:	2f f6       	sub	r6,-1
800118e6:	10 39       	cp.w	r9,r8
800118e8:	c0 84       	brge	800118f8 <_vfiprintf_r+0xcdc>
800118ea:	fa cb f9 78 	sub	r11,sp,-1672
800118ee:	f6 07 00 37 	add	r7,r11,r7<<0x3
800118f2:	ee f9 fd a4 	ld.w	r9,r7[-604]
800118f6:	c1 78       	rjmp	80011924 <_vfiprintf_r+0xd08>
800118f8:	40 a9       	lddsp	r9,sp[0x28]
800118fa:	59 f8       	cp.w	r8,31
800118fc:	e0 89 00 10 	brgt	8001191c <_vfiprintf_r+0xd00>
80011900:	f2 ca ff fc 	sub	r10,r9,-4
80011904:	50 aa       	stdsp	sp[0x28],r10
80011906:	fa c2 f9 78 	sub	r2,sp,-1672
8001190a:	72 09       	ld.w	r9,r9[0x0]
8001190c:	e4 08 00 3a 	add	r10,r2,r8<<0x3
80011910:	f5 49 fd a4 	st.w	r10[-604],r9
80011914:	2f f8       	sub	r8,-1
80011916:	fb 48 06 80 	st.w	sp[1664],r8
8001191a:	c0 58       	rjmp	80011924 <_vfiprintf_r+0xd08>
8001191c:	f2 c8 ff fc 	sub	r8,r9,-4
80011920:	50 a8       	stdsp	sp[0x28],r8
80011922:	72 09       	ld.w	r9,r9[0x0]
80011924:	33 08       	mov	r8,48
80011926:	30 0e       	mov	lr,0
80011928:	fb 68 06 84 	st.b	sp[1668],r8
8001192c:	fe cc 8f ec 	sub	r12,pc,-28692
80011930:	37 88       	mov	r8,120
80011932:	50 19       	stdsp	sp[0x4],r9
80011934:	a1 b3       	sbr	r3,0x1
80011936:	fb 68 06 85 	st.b	sp[1669],r8
8001193a:	50 0e       	stdsp	sp[0x0],lr
8001193c:	50 9c       	stdsp	sp[0x24],r12
8001193e:	e0 8f 02 6b 	bral	80011e14 <_vfiprintf_r+0x11f8>
80011942:	50 57       	stdsp	sp[0x14],r7
80011944:	30 0b       	mov	r11,0
80011946:	50 42       	stdsp	sp[0x10],r2
80011948:	fb 6b 06 87 	st.b	sp[1671],r11
8001194c:	08 97       	mov	r7,r4
8001194e:	40 85       	lddsp	r5,sp[0x20]
80011950:	40 74       	lddsp	r4,sp[0x1c]
80011952:	0c 99       	mov	r9,r6
80011954:	fa f8 06 80 	ld.w	r8,sp[1664]
80011958:	58 00       	cp.w	r0,0
8001195a:	c1 d0       	breq	80011994 <_vfiprintf_r+0xd78>
8001195c:	10 37       	cp.w	r7,r8
8001195e:	c0 64       	brge	8001196a <_vfiprintf_r+0xd4e>
80011960:	fa ca f9 78 	sub	r10,sp,-1672
80011964:	f4 07 00 37 	add	r7,r10,r7<<0x3
80011968:	c1 d8       	rjmp	800119a2 <_vfiprintf_r+0xd86>
8001196a:	fa c8 f9 84 	sub	r8,sp,-1660
8001196e:	1a d8       	st.w	--sp,r8
80011970:	fa c8 fa d0 	sub	r8,sp,-1328
80011974:	1a d8       	st.w	--sp,r8
80011976:	fa c8 fb cc 	sub	r8,sp,-1076
8001197a:	0e 9b       	mov	r11,r7
8001197c:	1a d8       	st.w	--sp,r8
8001197e:	0a 9a       	mov	r10,r5
80011980:	fa c8 f9 74 	sub	r8,sp,-1676
80011984:	fa c9 ff cc 	sub	r9,sp,-52
80011988:	02 9c       	mov	r12,r1
8001198a:	fe b0 f7 af 	rcall	800108e8 <get_arg>
8001198e:	2f dd       	sub	sp,-12
80011990:	78 07       	ld.w	r7,r12[0x0]
80011992:	c2 08       	rjmp	800119d2 <_vfiprintf_r+0xdb6>
80011994:	2f f6       	sub	r6,-1
80011996:	10 39       	cp.w	r9,r8
80011998:	c0 84       	brge	800119a8 <_vfiprintf_r+0xd8c>
8001199a:	fa c9 f9 78 	sub	r9,sp,-1672
8001199e:	f2 07 00 37 	add	r7,r9,r7<<0x3
800119a2:	ee f7 fd a4 	ld.w	r7,r7[-604]
800119a6:	c1 68       	rjmp	800119d2 <_vfiprintf_r+0xdb6>
800119a8:	40 a9       	lddsp	r9,sp[0x28]
800119aa:	59 f8       	cp.w	r8,31
800119ac:	e0 89 00 10 	brgt	800119cc <_vfiprintf_r+0xdb0>
800119b0:	f2 ca ff fc 	sub	r10,r9,-4
800119b4:	50 aa       	stdsp	sp[0x28],r10
800119b6:	72 07       	ld.w	r7,r9[0x0]
800119b8:	fa c2 f9 78 	sub	r2,sp,-1672
800119bc:	e4 08 00 39 	add	r9,r2,r8<<0x3
800119c0:	f3 47 fd a4 	st.w	r9[-604],r7
800119c4:	2f f8       	sub	r8,-1
800119c6:	fb 48 06 80 	st.w	sp[1664],r8
800119ca:	c0 48       	rjmp	800119d2 <_vfiprintf_r+0xdb6>
800119cc:	72 07       	ld.w	r7,r9[0x0]
800119ce:	2f c9       	sub	r9,-4
800119d0:	50 a9       	stdsp	sp[0x28],r9
800119d2:	40 3e       	lddsp	lr,sp[0xc]
800119d4:	58 0e       	cp.w	lr,0
800119d6:	c1 05       	brlt	800119f6 <_vfiprintf_r+0xdda>
800119d8:	1c 9a       	mov	r10,lr
800119da:	30 0b       	mov	r11,0
800119dc:	0e 9c       	mov	r12,r7
800119de:	e0 a0 20 97 	rcall	80015b0c <memchr>
800119e2:	e0 80 02 ae 	breq	80011f3e <_vfiprintf_r+0x1322>
800119e6:	f8 07 01 05 	sub	r5,r12,r7
800119ea:	40 3c       	lddsp	r12,sp[0xc]
800119ec:	18 35       	cp.w	r5,r12
800119ee:	e0 89 02 a8 	brgt	80011f3e <_vfiprintf_r+0x1322>
800119f2:	e0 8f 02 a7 	bral	80011f40 <_vfiprintf_r+0x1324>
800119f6:	0e 9c       	mov	r12,r7
800119f8:	30 00       	mov	r0,0
800119fa:	fe b0 f6 e5 	rcall	800107c4 <strlen>
800119fe:	18 95       	mov	r5,r12
80011a00:	e0 8f 02 a1 	bral	80011f42 <_vfiprintf_r+0x1326>
80011a04:	a5 a3       	sbr	r3,0x4
80011a06:	0c 99       	mov	r9,r6
80011a08:	ed b3 00 05 	bld	r3,0x5
80011a0c:	c5 01       	brne	80011aac <_vfiprintf_r+0xe90>
80011a0e:	fa f8 06 80 	ld.w	r8,sp[1664]
80011a12:	58 00       	cp.w	r0,0
80011a14:	c2 00       	breq	80011a54 <_vfiprintf_r+0xe38>
80011a16:	10 37       	cp.w	r7,r8
80011a18:	c0 64       	brge	80011a24 <_vfiprintf_r+0xe08>
80011a1a:	fa cb f9 78 	sub	r11,sp,-1672
80011a1e:	f6 07 00 37 	add	r7,r11,r7<<0x3
80011a22:	c2 08       	rjmp	80011a62 <_vfiprintf_r+0xe46>
80011a24:	fa c8 f9 84 	sub	r8,sp,-1660
80011a28:	1a d8       	st.w	--sp,r8
80011a2a:	fa c8 fa d0 	sub	r8,sp,-1328
80011a2e:	0a 9a       	mov	r10,r5
80011a30:	1a d8       	st.w	--sp,r8
80011a32:	0e 9b       	mov	r11,r7
80011a34:	fa c8 fb cc 	sub	r8,sp,-1076
80011a38:	02 9c       	mov	r12,r1
80011a3a:	1a d8       	st.w	--sp,r8
80011a3c:	fa c8 f9 74 	sub	r8,sp,-1676
80011a40:	fa c9 ff cc 	sub	r9,sp,-52
80011a44:	fe b0 f7 52 	rcall	800108e8 <get_arg>
80011a48:	2f dd       	sub	sp,-12
80011a4a:	f8 ea 00 00 	ld.d	r10,r12[0]
80011a4e:	fa eb 00 00 	st.d	sp[0],r10
80011a52:	c2 a8       	rjmp	80011aa6 <_vfiprintf_r+0xe8a>
80011a54:	2f f6       	sub	r6,-1
80011a56:	10 39       	cp.w	r9,r8
80011a58:	c0 a4       	brge	80011a6c <_vfiprintf_r+0xe50>
80011a5a:	fa ca f9 78 	sub	r10,sp,-1672
80011a5e:	f4 07 00 37 	add	r7,r10,r7<<0x3
80011a62:	ee e8 fd a4 	ld.d	r8,r7[-604]
80011a66:	fa e9 00 00 	st.d	sp[0],r8
80011a6a:	c1 e8       	rjmp	80011aa6 <_vfiprintf_r+0xe8a>
80011a6c:	40 a9       	lddsp	r9,sp[0x28]
80011a6e:	59 f8       	cp.w	r8,31
80011a70:	e0 89 00 15 	brgt	80011a9a <_vfiprintf_r+0xe7e>
80011a74:	f2 ca ff f8 	sub	r10,r9,-8
80011a78:	50 aa       	stdsp	sp[0x28],r10
80011a7a:	f2 ea 00 00 	ld.d	r10,r9[0]
80011a7e:	fa eb 00 00 	st.d	sp[0],r10
80011a82:	fa ca f9 78 	sub	r10,sp,-1672
80011a86:	f4 08 00 39 	add	r9,r10,r8<<0x3
80011a8a:	fa ea 00 00 	ld.d	r10,sp[0]
80011a8e:	f2 eb fd a4 	st.d	r9[-604],r10
80011a92:	2f f8       	sub	r8,-1
80011a94:	fb 48 06 80 	st.w	sp[1664],r8
80011a98:	c0 78       	rjmp	80011aa6 <_vfiprintf_r+0xe8a>
80011a9a:	f2 ea 00 00 	ld.d	r10,r9[0]
80011a9e:	2f 89       	sub	r9,-8
80011aa0:	fa eb 00 00 	st.d	sp[0],r10
80011aa4:	50 a9       	stdsp	sp[0x28],r9
80011aa6:	30 10       	mov	r0,1
80011aa8:	e0 8f 01 b7 	bral	80011e16 <_vfiprintf_r+0x11fa>
80011aac:	ed b3 00 04 	bld	r3,0x4
80011ab0:	c1 41       	brne	80011ad8 <_vfiprintf_r+0xebc>
80011ab2:	fa f8 06 80 	ld.w	r8,sp[1664]
80011ab6:	58 00       	cp.w	r0,0
80011ab8:	c0 80       	breq	80011ac8 <_vfiprintf_r+0xeac>
80011aba:	10 37       	cp.w	r7,r8
80011abc:	c6 04       	brge	80011b7c <_vfiprintf_r+0xf60>
80011abe:	fa ca f9 78 	sub	r10,sp,-1672
80011ac2:	f4 07 00 37 	add	r7,r10,r7<<0x3
80011ac6:	c7 78       	rjmp	80011bb4 <_vfiprintf_r+0xf98>
80011ac8:	2f f6       	sub	r6,-1
80011aca:	10 39       	cp.w	r9,r8
80011acc:	c7 74       	brge	80011bba <_vfiprintf_r+0xf9e>
80011ace:	fa c9 f9 78 	sub	r9,sp,-1672
80011ad2:	f2 07 00 37 	add	r7,r9,r7<<0x3
80011ad6:	c6 f8       	rjmp	80011bb4 <_vfiprintf_r+0xf98>
80011ad8:	ed b3 00 06 	bld	r3,0x6
80011adc:	c4 51       	brne	80011b66 <_vfiprintf_r+0xf4a>
80011ade:	fa f8 06 80 	ld.w	r8,sp[1664]
80011ae2:	58 00       	cp.w	r0,0
80011ae4:	c1 d0       	breq	80011b1e <_vfiprintf_r+0xf02>
80011ae6:	10 37       	cp.w	r7,r8
80011ae8:	c0 64       	brge	80011af4 <_vfiprintf_r+0xed8>
80011aea:	fa cc f9 78 	sub	r12,sp,-1672
80011aee:	f8 07 00 37 	add	r7,r12,r7<<0x3
80011af2:	c1 d8       	rjmp	80011b2c <_vfiprintf_r+0xf10>
80011af4:	fa c8 f9 84 	sub	r8,sp,-1660
80011af8:	1a d8       	st.w	--sp,r8
80011afa:	fa c8 fa d0 	sub	r8,sp,-1328
80011afe:	1a d8       	st.w	--sp,r8
80011b00:	fa c8 fb cc 	sub	r8,sp,-1076
80011b04:	1a d8       	st.w	--sp,r8
80011b06:	fa c8 f9 74 	sub	r8,sp,-1676
80011b0a:	fa c9 ff cc 	sub	r9,sp,-52
80011b0e:	0a 9a       	mov	r10,r5
80011b10:	0e 9b       	mov	r11,r7
80011b12:	02 9c       	mov	r12,r1
80011b14:	fe b0 f6 ea 	rcall	800108e8 <get_arg>
80011b18:	2f dd       	sub	sp,-12
80011b1a:	98 18       	ld.sh	r8,r12[0x2]
80011b1c:	c2 28       	rjmp	80011b60 <_vfiprintf_r+0xf44>
80011b1e:	2f f6       	sub	r6,-1
80011b20:	10 39       	cp.w	r9,r8
80011b22:	c0 84       	brge	80011b32 <_vfiprintf_r+0xf16>
80011b24:	fa cb f9 78 	sub	r11,sp,-1672
80011b28:	f6 07 00 37 	add	r7,r11,r7<<0x3
80011b2c:	ef 08 fd a6 	ld.sh	r8,r7[-602]
80011b30:	c1 88       	rjmp	80011b60 <_vfiprintf_r+0xf44>
80011b32:	40 a9       	lddsp	r9,sp[0x28]
80011b34:	59 f8       	cp.w	r8,31
80011b36:	e0 89 00 12 	brgt	80011b5a <_vfiprintf_r+0xf3e>
80011b3a:	f2 ca ff fc 	sub	r10,r9,-4
80011b3e:	50 aa       	stdsp	sp[0x28],r10
80011b40:	72 09       	ld.w	r9,r9[0x0]
80011b42:	fa c2 f9 78 	sub	r2,sp,-1672
80011b46:	e4 08 00 3a 	add	r10,r2,r8<<0x3
80011b4a:	2f f8       	sub	r8,-1
80011b4c:	f5 49 fd a4 	st.w	r10[-604],r9
80011b50:	fb 48 06 80 	st.w	sp[1664],r8
80011b54:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80011b58:	c0 48       	rjmp	80011b60 <_vfiprintf_r+0xf44>
80011b5a:	92 18       	ld.sh	r8,r9[0x2]
80011b5c:	2f c9       	sub	r9,-4
80011b5e:	50 a9       	stdsp	sp[0x28],r9
80011b60:	5c 78       	castu.h	r8
80011b62:	50 18       	stdsp	sp[0x4],r8
80011b64:	c4 18       	rjmp	80011be6 <_vfiprintf_r+0xfca>
80011b66:	fa f8 06 80 	ld.w	r8,sp[1664]
80011b6a:	58 00       	cp.w	r0,0
80011b6c:	c1 d0       	breq	80011ba6 <_vfiprintf_r+0xf8a>
80011b6e:	10 37       	cp.w	r7,r8
80011b70:	c0 64       	brge	80011b7c <_vfiprintf_r+0xf60>
80011b72:	fa cc f9 78 	sub	r12,sp,-1672
80011b76:	f8 07 00 37 	add	r7,r12,r7<<0x3
80011b7a:	c1 d8       	rjmp	80011bb4 <_vfiprintf_r+0xf98>
80011b7c:	fa c8 f9 84 	sub	r8,sp,-1660
80011b80:	1a d8       	st.w	--sp,r8
80011b82:	fa c8 fa d0 	sub	r8,sp,-1328
80011b86:	0a 9a       	mov	r10,r5
80011b88:	1a d8       	st.w	--sp,r8
80011b8a:	fa c8 fb cc 	sub	r8,sp,-1076
80011b8e:	0e 9b       	mov	r11,r7
80011b90:	1a d8       	st.w	--sp,r8
80011b92:	02 9c       	mov	r12,r1
80011b94:	fa c8 f9 74 	sub	r8,sp,-1676
80011b98:	fa c9 ff cc 	sub	r9,sp,-52
80011b9c:	fe b0 f6 a6 	rcall	800108e8 <get_arg>
80011ba0:	2f dd       	sub	sp,-12
80011ba2:	78 0a       	ld.w	r10,r12[0x0]
80011ba4:	c2 08       	rjmp	80011be4 <_vfiprintf_r+0xfc8>
80011ba6:	2f f6       	sub	r6,-1
80011ba8:	10 39       	cp.w	r9,r8
80011baa:	c0 84       	brge	80011bba <_vfiprintf_r+0xf9e>
80011bac:	fa cb f9 78 	sub	r11,sp,-1672
80011bb0:	f6 07 00 37 	add	r7,r11,r7<<0x3
80011bb4:	ee fa fd a4 	ld.w	r10,r7[-604]
80011bb8:	c1 68       	rjmp	80011be4 <_vfiprintf_r+0xfc8>
80011bba:	40 a9       	lddsp	r9,sp[0x28]
80011bbc:	59 f8       	cp.w	r8,31
80011bbe:	e0 89 00 10 	brgt	80011bde <_vfiprintf_r+0xfc2>
80011bc2:	f2 ca ff fc 	sub	r10,r9,-4
80011bc6:	50 aa       	stdsp	sp[0x28],r10
80011bc8:	fa c2 f9 78 	sub	r2,sp,-1672
80011bcc:	72 0a       	ld.w	r10,r9[0x0]
80011bce:	e4 08 00 39 	add	r9,r2,r8<<0x3
80011bd2:	f3 4a fd a4 	st.w	r9[-604],r10
80011bd6:	2f f8       	sub	r8,-1
80011bd8:	fb 48 06 80 	st.w	sp[1664],r8
80011bdc:	c0 48       	rjmp	80011be4 <_vfiprintf_r+0xfc8>
80011bde:	72 0a       	ld.w	r10,r9[0x0]
80011be0:	2f c9       	sub	r9,-4
80011be2:	50 a9       	stdsp	sp[0x28],r9
80011be4:	50 1a       	stdsp	sp[0x4],r10
80011be6:	30 0e       	mov	lr,0
80011be8:	30 10       	mov	r0,1
80011bea:	50 0e       	stdsp	sp[0x0],lr
80011bec:	c1 59       	rjmp	80011e16 <_vfiprintf_r+0x11fa>
80011bee:	fe cc 92 ae 	sub	r12,pc,-27986
80011bf2:	50 9c       	stdsp	sp[0x24],r12
80011bf4:	ed b3 00 05 	bld	r3,0x5
80011bf8:	c5 41       	brne	80011ca0 <_vfiprintf_r+0x1084>
80011bfa:	fa f8 06 80 	ld.w	r8,sp[1664]
80011bfe:	58 00       	cp.w	r0,0
80011c00:	c2 20       	breq	80011c44 <_vfiprintf_r+0x1028>
80011c02:	10 37       	cp.w	r7,r8
80011c04:	c0 a4       	brge	80011c18 <_vfiprintf_r+0xffc>
80011c06:	fa cb f9 78 	sub	r11,sp,-1672
80011c0a:	f6 07 00 37 	add	r7,r11,r7<<0x3
80011c0e:	ee e8 fd a4 	ld.d	r8,r7[-604]
80011c12:	fa e9 00 00 	st.d	sp[0],r8
80011c16:	ce d8       	rjmp	80011df0 <_vfiprintf_r+0x11d4>
80011c18:	fa c8 f9 84 	sub	r8,sp,-1660
80011c1c:	1a d8       	st.w	--sp,r8
80011c1e:	fa c8 fa d0 	sub	r8,sp,-1328
80011c22:	0a 9a       	mov	r10,r5
80011c24:	1a d8       	st.w	--sp,r8
80011c26:	0e 9b       	mov	r11,r7
80011c28:	fa c8 fb cc 	sub	r8,sp,-1076
80011c2c:	02 9c       	mov	r12,r1
80011c2e:	1a d8       	st.w	--sp,r8
80011c30:	fa c8 f9 74 	sub	r8,sp,-1676
80011c34:	fa c9 ff cc 	sub	r9,sp,-52
80011c38:	fe b0 f6 58 	rcall	800108e8 <get_arg>
80011c3c:	2f dd       	sub	sp,-12
80011c3e:	f8 ea 00 00 	ld.d	r10,r12[0]
80011c42:	c0 c8       	rjmp	80011c5a <_vfiprintf_r+0x103e>
80011c44:	ec ca ff ff 	sub	r10,r6,-1
80011c48:	10 36       	cp.w	r6,r8
80011c4a:	c0 b4       	brge	80011c60 <_vfiprintf_r+0x1044>
80011c4c:	fa c9 f9 78 	sub	r9,sp,-1672
80011c50:	14 96       	mov	r6,r10
80011c52:	f2 07 00 37 	add	r7,r9,r7<<0x3
80011c56:	ee ea fd a4 	ld.d	r10,r7[-604]
80011c5a:	fa eb 00 00 	st.d	sp[0],r10
80011c5e:	cc 98       	rjmp	80011df0 <_vfiprintf_r+0x11d4>
80011c60:	40 a9       	lddsp	r9,sp[0x28]
80011c62:	59 f8       	cp.w	r8,31
80011c64:	e0 89 00 16 	brgt	80011c90 <_vfiprintf_r+0x1074>
80011c68:	f2 e6 00 00 	ld.d	r6,r9[0]
80011c6c:	f2 cb ff f8 	sub	r11,r9,-8
80011c70:	fa e7 00 00 	st.d	sp[0],r6
80011c74:	50 ab       	stdsp	sp[0x28],r11
80011c76:	fa c6 f9 78 	sub	r6,sp,-1672
80011c7a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80011c7e:	fa e6 00 00 	ld.d	r6,sp[0]
80011c82:	f2 e7 fd a4 	st.d	r9[-604],r6
80011c86:	2f f8       	sub	r8,-1
80011c88:	14 96       	mov	r6,r10
80011c8a:	fb 48 06 80 	st.w	sp[1664],r8
80011c8e:	cb 18       	rjmp	80011df0 <_vfiprintf_r+0x11d4>
80011c90:	f2 e6 00 00 	ld.d	r6,r9[0]
80011c94:	2f 89       	sub	r9,-8
80011c96:	fa e7 00 00 	st.d	sp[0],r6
80011c9a:	50 a9       	stdsp	sp[0x28],r9
80011c9c:	14 96       	mov	r6,r10
80011c9e:	ca 98       	rjmp	80011df0 <_vfiprintf_r+0x11d4>
80011ca0:	ed b3 00 04 	bld	r3,0x4
80011ca4:	c1 51       	brne	80011cce <_vfiprintf_r+0x10b2>
80011ca6:	fa f8 06 80 	ld.w	r8,sp[1664]
80011caa:	58 00       	cp.w	r0,0
80011cac:	c0 80       	breq	80011cbc <_vfiprintf_r+0x10a0>
80011cae:	10 37       	cp.w	r7,r8
80011cb0:	c6 54       	brge	80011d7a <_vfiprintf_r+0x115e>
80011cb2:	fa ce f9 78 	sub	lr,sp,-1672
80011cb6:	fc 07 00 37 	add	r7,lr,r7<<0x3
80011cba:	c7 e8       	rjmp	80011db6 <_vfiprintf_r+0x119a>
80011cbc:	ec ca ff ff 	sub	r10,r6,-1
80011cc0:	10 36       	cp.w	r6,r8
80011cc2:	c7 d4       	brge	80011dbc <_vfiprintf_r+0x11a0>
80011cc4:	fa cc f9 78 	sub	r12,sp,-1672
80011cc8:	f8 07 00 37 	add	r7,r12,r7<<0x3
80011ccc:	c7 48       	rjmp	80011db4 <_vfiprintf_r+0x1198>
80011cce:	ed b3 00 06 	bld	r3,0x6
80011cd2:	c4 91       	brne	80011d64 <_vfiprintf_r+0x1148>
80011cd4:	fa f8 06 80 	ld.w	r8,sp[1664]
80011cd8:	58 00       	cp.w	r0,0
80011cda:	c1 d0       	breq	80011d14 <_vfiprintf_r+0x10f8>
80011cdc:	10 37       	cp.w	r7,r8
80011cde:	c0 64       	brge	80011cea <_vfiprintf_r+0x10ce>
80011ce0:	fa cc f9 78 	sub	r12,sp,-1672
80011ce4:	f8 07 00 37 	add	r7,r12,r7<<0x3
80011ce8:	c1 f8       	rjmp	80011d26 <_vfiprintf_r+0x110a>
80011cea:	fa c8 f9 84 	sub	r8,sp,-1660
80011cee:	1a d8       	st.w	--sp,r8
80011cf0:	fa c8 fa d0 	sub	r8,sp,-1328
80011cf4:	1a d8       	st.w	--sp,r8
80011cf6:	fa c8 fb cc 	sub	r8,sp,-1076
80011cfa:	1a d8       	st.w	--sp,r8
80011cfc:	fa c8 f9 74 	sub	r8,sp,-1676
80011d00:	fa c9 ff cc 	sub	r9,sp,-52
80011d04:	0a 9a       	mov	r10,r5
80011d06:	0e 9b       	mov	r11,r7
80011d08:	02 9c       	mov	r12,r1
80011d0a:	fe b0 f5 ef 	rcall	800108e8 <get_arg>
80011d0e:	2f dd       	sub	sp,-12
80011d10:	98 18       	ld.sh	r8,r12[0x2]
80011d12:	c2 68       	rjmp	80011d5e <_vfiprintf_r+0x1142>
80011d14:	ec ca ff ff 	sub	r10,r6,-1
80011d18:	10 36       	cp.w	r6,r8
80011d1a:	c0 94       	brge	80011d2c <_vfiprintf_r+0x1110>
80011d1c:	fa cb f9 78 	sub	r11,sp,-1672
80011d20:	14 96       	mov	r6,r10
80011d22:	f6 07 00 37 	add	r7,r11,r7<<0x3
80011d26:	ef 08 fd a6 	ld.sh	r8,r7[-602]
80011d2a:	c1 a8       	rjmp	80011d5e <_vfiprintf_r+0x1142>
80011d2c:	40 a9       	lddsp	r9,sp[0x28]
80011d2e:	59 f8       	cp.w	r8,31
80011d30:	e0 89 00 13 	brgt	80011d56 <_vfiprintf_r+0x113a>
80011d34:	f2 cb ff fc 	sub	r11,r9,-4
80011d38:	50 ab       	stdsp	sp[0x28],r11
80011d3a:	72 09       	ld.w	r9,r9[0x0]
80011d3c:	fa c6 f9 78 	sub	r6,sp,-1672
80011d40:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80011d44:	2f f8       	sub	r8,-1
80011d46:	f7 49 fd a4 	st.w	r11[-604],r9
80011d4a:	fb 48 06 80 	st.w	sp[1664],r8
80011d4e:	14 96       	mov	r6,r10
80011d50:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80011d54:	c0 58       	rjmp	80011d5e <_vfiprintf_r+0x1142>
80011d56:	92 18       	ld.sh	r8,r9[0x2]
80011d58:	14 96       	mov	r6,r10
80011d5a:	2f c9       	sub	r9,-4
80011d5c:	50 a9       	stdsp	sp[0x28],r9
80011d5e:	5c 78       	castu.h	r8
80011d60:	50 18       	stdsp	sp[0x4],r8
80011d62:	c4 58       	rjmp	80011dec <_vfiprintf_r+0x11d0>
80011d64:	fa f8 06 80 	ld.w	r8,sp[1664]
80011d68:	58 00       	cp.w	r0,0
80011d6a:	c1 d0       	breq	80011da4 <_vfiprintf_r+0x1188>
80011d6c:	10 37       	cp.w	r7,r8
80011d6e:	c0 64       	brge	80011d7a <_vfiprintf_r+0x115e>
80011d70:	fa cc f9 78 	sub	r12,sp,-1672
80011d74:	f8 07 00 37 	add	r7,r12,r7<<0x3
80011d78:	c1 f8       	rjmp	80011db6 <_vfiprintf_r+0x119a>
80011d7a:	fa c8 f9 84 	sub	r8,sp,-1660
80011d7e:	1a d8       	st.w	--sp,r8
80011d80:	fa c8 fa d0 	sub	r8,sp,-1328
80011d84:	0e 9b       	mov	r11,r7
80011d86:	1a d8       	st.w	--sp,r8
80011d88:	fa c8 fb cc 	sub	r8,sp,-1076
80011d8c:	0a 9a       	mov	r10,r5
80011d8e:	1a d8       	st.w	--sp,r8
80011d90:	02 9c       	mov	r12,r1
80011d92:	fa c8 f9 74 	sub	r8,sp,-1676
80011d96:	fa c9 ff cc 	sub	r9,sp,-52
80011d9a:	fe b0 f5 a7 	rcall	800108e8 <get_arg>
80011d9e:	2f dd       	sub	sp,-12
80011da0:	78 0b       	ld.w	r11,r12[0x0]
80011da2:	c2 48       	rjmp	80011dea <_vfiprintf_r+0x11ce>
80011da4:	ec ca ff ff 	sub	r10,r6,-1
80011da8:	10 36       	cp.w	r6,r8
80011daa:	c0 94       	brge	80011dbc <_vfiprintf_r+0x11a0>
80011dac:	fa cb f9 78 	sub	r11,sp,-1672
80011db0:	f6 07 00 37 	add	r7,r11,r7<<0x3
80011db4:	14 96       	mov	r6,r10
80011db6:	ee fb fd a4 	ld.w	r11,r7[-604]
80011dba:	c1 88       	rjmp	80011dea <_vfiprintf_r+0x11ce>
80011dbc:	40 a9       	lddsp	r9,sp[0x28]
80011dbe:	59 f8       	cp.w	r8,31
80011dc0:	e0 89 00 11 	brgt	80011de2 <_vfiprintf_r+0x11c6>
80011dc4:	f2 cb ff fc 	sub	r11,r9,-4
80011dc8:	50 ab       	stdsp	sp[0x28],r11
80011dca:	fa c6 f9 78 	sub	r6,sp,-1672
80011dce:	72 0b       	ld.w	r11,r9[0x0]
80011dd0:	ec 08 00 39 	add	r9,r6,r8<<0x3
80011dd4:	f3 4b fd a4 	st.w	r9[-604],r11
80011dd8:	2f f8       	sub	r8,-1
80011dda:	14 96       	mov	r6,r10
80011ddc:	fb 48 06 80 	st.w	sp[1664],r8
80011de0:	c0 58       	rjmp	80011dea <_vfiprintf_r+0x11ce>
80011de2:	72 0b       	ld.w	r11,r9[0x0]
80011de4:	14 96       	mov	r6,r10
80011de6:	2f c9       	sub	r9,-4
80011de8:	50 a9       	stdsp	sp[0x28],r9
80011dea:	50 1b       	stdsp	sp[0x4],r11
80011dec:	30 0e       	mov	lr,0
80011dee:	50 0e       	stdsp	sp[0x0],lr
80011df0:	40 08       	lddsp	r8,sp[0x0]
80011df2:	40 1c       	lddsp	r12,sp[0x4]
80011df4:	18 48       	or	r8,r12
80011df6:	30 0b       	mov	r11,0
80011df8:	5f 19       	srne	r9
80011dfa:	06 98       	mov	r8,r3
80011dfc:	e7 e9 00 09 	and	r9,r3,r9
80011e00:	a1 b8       	sbr	r8,0x1
80011e02:	f6 09 18 00 	cp.b	r9,r11
80011e06:	c0 70       	breq	80011e14 <_vfiprintf_r+0x11f8>
80011e08:	10 93       	mov	r3,r8
80011e0a:	fb 62 06 85 	st.b	sp[1669],r2
80011e0e:	33 08       	mov	r8,48
80011e10:	fb 68 06 84 	st.b	sp[1668],r8
80011e14:	30 20       	mov	r0,2
80011e16:	30 0a       	mov	r10,0
80011e18:	fb 6a 06 87 	st.b	sp[1671],r10
80011e1c:	06 98       	mov	r8,r3
80011e1e:	a7 d8       	cbr	r8,0x7
80011e20:	40 39       	lddsp	r9,sp[0xc]
80011e22:	40 37       	lddsp	r7,sp[0xc]
80011e24:	58 09       	cp.w	r9,0
80011e26:	5f 19       	srne	r9
80011e28:	58 07       	cp.w	r7,0
80011e2a:	f0 03 17 40 	movge	r3,r8
80011e2e:	40 12       	lddsp	r2,sp[0x4]
80011e30:	40 08       	lddsp	r8,sp[0x0]
80011e32:	fa c5 f9 90 	sub	r5,sp,-1648
80011e36:	04 48       	or	r8,r2
80011e38:	30 0e       	mov	lr,0
80011e3a:	5f 18       	srne	r8
80011e3c:	f3 e8 10 08 	or	r8,r9,r8
80011e40:	fc 08 18 00 	cp.b	r8,lr
80011e44:	c5 e0       	breq	80011f00 <_vfiprintf_r+0x12e4>
80011e46:	30 18       	mov	r8,1
80011e48:	f0 00 18 00 	cp.b	r0,r8
80011e4c:	c0 60       	breq	80011e58 <_vfiprintf_r+0x123c>
80011e4e:	30 28       	mov	r8,2
80011e50:	f0 00 18 00 	cp.b	r0,r8
80011e54:	c0 51       	brne	80011e5e <_vfiprintf_r+0x1242>
80011e56:	c3 e8       	rjmp	80011ed2 <_vfiprintf_r+0x12b6>
80011e58:	0a 97       	mov	r7,r5
80011e5a:	06 90       	mov	r0,r3
80011e5c:	c2 c8       	rjmp	80011eb4 <_vfiprintf_r+0x1298>
80011e5e:	0a 97       	mov	r7,r5
80011e60:	fa e8 00 00 	ld.d	r8,sp[0]
80011e64:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80011e68:	2d 0a       	sub	r10,-48
80011e6a:	0e fa       	st.b	--r7,r10
80011e6c:	f0 0b 16 03 	lsr	r11,r8,0x3
80011e70:	f2 0c 16 03 	lsr	r12,r9,0x3
80011e74:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80011e78:	18 99       	mov	r9,r12
80011e7a:	16 98       	mov	r8,r11
80011e7c:	58 08       	cp.w	r8,0
80011e7e:	5c 29       	cpc	r9
80011e80:	cf 21       	brne	80011e64 <_vfiprintf_r+0x1248>
80011e82:	fa e9 00 00 	st.d	sp[0],r8
80011e86:	ed b3 00 00 	bld	r3,0x0
80011e8a:	c4 61       	brne	80011f16 <_vfiprintf_r+0x12fa>
80011e8c:	33 09       	mov	r9,48
80011e8e:	f2 0a 18 00 	cp.b	r10,r9
80011e92:	c4 20       	breq	80011f16 <_vfiprintf_r+0x12fa>
80011e94:	0e f9       	st.b	--r7,r9
80011e96:	c4 08       	rjmp	80011f16 <_vfiprintf_r+0x12fa>
80011e98:	e0 a0 24 e4 	rcall	80016860 <__avr32_umod64>
80011e9c:	30 a8       	mov	r8,10
80011e9e:	2d 0a       	sub	r10,-48
80011ea0:	30 09       	mov	r9,0
80011ea2:	ae 8a       	st.b	r7[0x0],r10
80011ea4:	fa ea 00 00 	ld.d	r10,sp[0]
80011ea8:	fe b0 ee c9 	rcall	8000fc3a <__avr32_udiv64>
80011eac:	16 99       	mov	r9,r11
80011eae:	14 98       	mov	r8,r10
80011eb0:	fa e9 00 00 	st.d	sp[0],r8
80011eb4:	ee cc 00 01 	sub	r12,r7,1
80011eb8:	30 a8       	mov	r8,10
80011eba:	30 09       	mov	r9,0
80011ebc:	fa ea 00 00 	ld.d	r10,sp[0]
80011ec0:	18 97       	mov	r7,r12
80011ec2:	58 9a       	cp.w	r10,9
80011ec4:	5c 2b       	cpc	r11
80011ec6:	fe 9b ff e9 	brhi	80011e98 <_vfiprintf_r+0x127c>
80011eca:	1b f8       	ld.ub	r8,sp[0x7]
80011ecc:	00 93       	mov	r3,r0
80011ece:	2d 08       	sub	r8,-48
80011ed0:	c2 08       	rjmp	80011f10 <_vfiprintf_r+0x12f4>
80011ed2:	0a 97       	mov	r7,r5
80011ed4:	fa e8 00 00 	ld.d	r8,sp[0]
80011ed8:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80011edc:	40 9c       	lddsp	r12,sp[0x24]
80011ede:	f8 0a 07 0a 	ld.ub	r10,r12[r10]
80011ee2:	0e fa       	st.b	--r7,r10
80011ee4:	f2 0b 16 04 	lsr	r11,r9,0x4
80011ee8:	f0 0a 16 04 	lsr	r10,r8,0x4
80011eec:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80011ef0:	16 99       	mov	r9,r11
80011ef2:	14 98       	mov	r8,r10
80011ef4:	58 08       	cp.w	r8,0
80011ef6:	5c 29       	cpc	r9
80011ef8:	cf 01       	brne	80011ed8 <_vfiprintf_r+0x12bc>
80011efa:	fa e9 00 00 	st.d	sp[0],r8
80011efe:	c0 c8       	rjmp	80011f16 <_vfiprintf_r+0x12fa>
80011f00:	58 00       	cp.w	r0,0
80011f02:	c0 91       	brne	80011f14 <_vfiprintf_r+0x12f8>
80011f04:	ed b3 00 00 	bld	r3,0x0
80011f08:	c0 61       	brne	80011f14 <_vfiprintf_r+0x12f8>
80011f0a:	fa c7 f9 91 	sub	r7,sp,-1647
80011f0e:	33 08       	mov	r8,48
80011f10:	ae 88       	st.b	r7[0x0],r8
80011f12:	c0 28       	rjmp	80011f16 <_vfiprintf_r+0x12fa>
80011f14:	0a 97       	mov	r7,r5
80011f16:	0e 15       	sub	r5,r7
80011f18:	40 30       	lddsp	r0,sp[0xc]
80011f1a:	c1 48       	rjmp	80011f42 <_vfiprintf_r+0x1326>
80011f1c:	50 42       	stdsp	sp[0x10],r2
80011f1e:	50 57       	stdsp	sp[0x14],r7
80011f20:	40 74       	lddsp	r4,sp[0x1c]
80011f22:	10 92       	mov	r2,r8
80011f24:	58 02       	cp.w	r2,0
80011f26:	e0 80 01 b0 	breq	80012286 <_vfiprintf_r+0x166a>
80011f2a:	30 0b       	mov	r11,0
80011f2c:	fb 62 06 48 	st.b	sp[1608],r2
80011f30:	fb 6b 06 87 	st.b	sp[1671],r11
80011f34:	30 15       	mov	r5,1
80011f36:	30 00       	mov	r0,0
80011f38:	fa c7 f9 b8 	sub	r7,sp,-1608
80011f3c:	c0 38       	rjmp	80011f42 <_vfiprintf_r+0x1326>
80011f3e:	40 35       	lddsp	r5,sp[0xc]
80011f40:	30 00       	mov	r0,0
80011f42:	fb 38 06 87 	ld.ub	r8,sp[1671]
80011f46:	ea 00 0c 42 	max	r2,r5,r0
80011f4a:	30 0a       	mov	r10,0
80011f4c:	06 99       	mov	r9,r3
80011f4e:	f4 08 18 00 	cp.b	r8,r10
80011f52:	f7 b2 01 ff 	subne	r2,-1
80011f56:	e2 19 00 02 	andl	r9,0x2,COH
80011f5a:	06 98       	mov	r8,r3
80011f5c:	50 89       	stdsp	sp[0x20],r9
80011f5e:	e2 18 00 84 	andl	r8,0x84,COH
80011f62:	50 78       	stdsp	sp[0x1c],r8
80011f64:	58 09       	cp.w	r9,0
80011f66:	f7 b2 01 fe 	subne	r2,-2
80011f6a:	58 08       	cp.w	r8,0
80011f6c:	c4 71       	brne	80011ffa <_vfiprintf_r+0x13de>
80011f6e:	40 4e       	lddsp	lr,sp[0x10]
80011f70:	04 1e       	sub	lr,r2
80011f72:	50 3e       	stdsp	sp[0xc],lr
80011f74:	58 0e       	cp.w	lr,0
80011f76:	e0 89 00 1e 	brgt	80011fb2 <_vfiprintf_r+0x1396>
80011f7a:	c4 08       	rjmp	80011ffa <_vfiprintf_r+0x13de>
80011f7c:	fb 4c 06 78 	st.w	sp[1656],r12
80011f80:	31 0a       	mov	r10,16
80011f82:	fe cc 96 2e 	sub	r12,pc,-27090
80011f86:	89 1a       	st.w	r4[0x4],r10
80011f88:	89 0c       	st.w	r4[0x0],r12
80011f8a:	fb 4b 06 74 	st.w	sp[1652],r11
80011f8e:	58 7b       	cp.w	r11,7
80011f90:	e0 89 00 04 	brgt	80011f98 <_vfiprintf_r+0x137c>
80011f94:	2f 84       	sub	r4,-8
80011f96:	c0 b8       	rjmp	80011fac <_vfiprintf_r+0x1390>
80011f98:	fa ca f9 90 	sub	r10,sp,-1648
80011f9c:	40 2b       	lddsp	r11,sp[0x8]
80011f9e:	02 9c       	mov	r12,r1
80011fa0:	fe b0 f6 30 	rcall	80010c00 <__sprint_r>
80011fa4:	e0 81 01 82 	brne	800122a8 <_vfiprintf_r+0x168c>
80011fa8:	fa c4 f9 f8 	sub	r4,sp,-1544
80011fac:	40 39       	lddsp	r9,sp[0xc]
80011fae:	21 09       	sub	r9,16
80011fb0:	50 39       	stdsp	sp[0xc],r9
80011fb2:	fa f9 06 78 	ld.w	r9,sp[1656]
80011fb6:	fa f8 06 74 	ld.w	r8,sp[1652]
80011fba:	f2 cc ff f0 	sub	r12,r9,-16
80011fbe:	f0 cb ff ff 	sub	r11,r8,-1
80011fc2:	fe ca 96 6e 	sub	r10,pc,-27026
80011fc6:	40 3e       	lddsp	lr,sp[0xc]
80011fc8:	59 0e       	cp.w	lr,16
80011fca:	fe 99 ff d9 	brgt	80011f7c <_vfiprintf_r+0x1360>
80011fce:	1c 09       	add	r9,lr
80011fd0:	89 0a       	st.w	r4[0x0],r10
80011fd2:	fb 49 06 78 	st.w	sp[1656],r9
80011fd6:	89 1e       	st.w	r4[0x4],lr
80011fd8:	fb 4b 06 74 	st.w	sp[1652],r11
80011fdc:	58 7b       	cp.w	r11,7
80011fde:	e0 89 00 04 	brgt	80011fe6 <_vfiprintf_r+0x13ca>
80011fe2:	2f 84       	sub	r4,-8
80011fe4:	c0 b8       	rjmp	80011ffa <_vfiprintf_r+0x13de>
80011fe6:	fa ca f9 90 	sub	r10,sp,-1648
80011fea:	40 2b       	lddsp	r11,sp[0x8]
80011fec:	02 9c       	mov	r12,r1
80011fee:	fe b0 f6 09 	rcall	80010c00 <__sprint_r>
80011ff2:	e0 81 01 5b 	brne	800122a8 <_vfiprintf_r+0x168c>
80011ff6:	fa c4 f9 f8 	sub	r4,sp,-1544
80011ffa:	fb 38 06 87 	ld.ub	r8,sp[1671]
80011ffe:	30 0c       	mov	r12,0
80012000:	f8 08 18 00 	cp.b	r8,r12
80012004:	c1 f0       	breq	80012042 <_vfiprintf_r+0x1426>
80012006:	fa f8 06 78 	ld.w	r8,sp[1656]
8001200a:	fa c9 f9 79 	sub	r9,sp,-1671
8001200e:	2f f8       	sub	r8,-1
80012010:	89 09       	st.w	r4[0x0],r9
80012012:	fb 48 06 78 	st.w	sp[1656],r8
80012016:	30 19       	mov	r9,1
80012018:	fa f8 06 74 	ld.w	r8,sp[1652]
8001201c:	89 19       	st.w	r4[0x4],r9
8001201e:	2f f8       	sub	r8,-1
80012020:	fb 48 06 74 	st.w	sp[1652],r8
80012024:	58 78       	cp.w	r8,7
80012026:	e0 89 00 04 	brgt	8001202e <_vfiprintf_r+0x1412>
8001202a:	2f 84       	sub	r4,-8
8001202c:	c0 b8       	rjmp	80012042 <_vfiprintf_r+0x1426>
8001202e:	fa ca f9 90 	sub	r10,sp,-1648
80012032:	40 2b       	lddsp	r11,sp[0x8]
80012034:	02 9c       	mov	r12,r1
80012036:	fe b0 f5 e5 	rcall	80010c00 <__sprint_r>
8001203a:	e0 81 01 37 	brne	800122a8 <_vfiprintf_r+0x168c>
8001203e:	fa c4 f9 f8 	sub	r4,sp,-1544
80012042:	40 8b       	lddsp	r11,sp[0x20]
80012044:	58 0b       	cp.w	r11,0
80012046:	c1 f0       	breq	80012084 <_vfiprintf_r+0x1468>
80012048:	fa f8 06 78 	ld.w	r8,sp[1656]
8001204c:	fa c9 f9 7c 	sub	r9,sp,-1668
80012050:	2f e8       	sub	r8,-2
80012052:	89 09       	st.w	r4[0x0],r9
80012054:	fb 48 06 78 	st.w	sp[1656],r8
80012058:	30 29       	mov	r9,2
8001205a:	fa f8 06 74 	ld.w	r8,sp[1652]
8001205e:	89 19       	st.w	r4[0x4],r9
80012060:	2f f8       	sub	r8,-1
80012062:	fb 48 06 74 	st.w	sp[1652],r8
80012066:	58 78       	cp.w	r8,7
80012068:	e0 89 00 04 	brgt	80012070 <_vfiprintf_r+0x1454>
8001206c:	2f 84       	sub	r4,-8
8001206e:	c0 b8       	rjmp	80012084 <_vfiprintf_r+0x1468>
80012070:	fa ca f9 90 	sub	r10,sp,-1648
80012074:	40 2b       	lddsp	r11,sp[0x8]
80012076:	02 9c       	mov	r12,r1
80012078:	fe b0 f5 c4 	rcall	80010c00 <__sprint_r>
8001207c:	e0 81 01 16 	brne	800122a8 <_vfiprintf_r+0x168c>
80012080:	fa c4 f9 f8 	sub	r4,sp,-1544
80012084:	40 7a       	lddsp	r10,sp[0x1c]
80012086:	e0 4a 00 80 	cp.w	r10,128
8001208a:	c4 81       	brne	8001211a <_vfiprintf_r+0x14fe>
8001208c:	40 49       	lddsp	r9,sp[0x10]
8001208e:	04 19       	sub	r9,r2
80012090:	50 39       	stdsp	sp[0xc],r9
80012092:	58 09       	cp.w	r9,0
80012094:	e0 89 00 1f 	brgt	800120d2 <_vfiprintf_r+0x14b6>
80012098:	c4 18       	rjmp	8001211a <_vfiprintf_r+0x14fe>
8001209a:	fe c8 98 56 	sub	r8,pc,-26538
8001209e:	31 0e       	mov	lr,16
800120a0:	fb 4c 06 78 	st.w	sp[1656],r12
800120a4:	89 08       	st.w	r4[0x0],r8
800120a6:	89 1e       	st.w	r4[0x4],lr
800120a8:	fb 4b 06 74 	st.w	sp[1652],r11
800120ac:	58 7b       	cp.w	r11,7
800120ae:	e0 89 00 05 	brgt	800120b8 <_vfiprintf_r+0x149c>
800120b2:	2f 84       	sub	r4,-8
800120b4:	c0 c8       	rjmp	800120cc <_vfiprintf_r+0x14b0>
800120b6:	d7 03       	nop
800120b8:	fa ca f9 90 	sub	r10,sp,-1648
800120bc:	40 2b       	lddsp	r11,sp[0x8]
800120be:	02 9c       	mov	r12,r1
800120c0:	fe b0 f5 a0 	rcall	80010c00 <__sprint_r>
800120c4:	e0 81 00 f2 	brne	800122a8 <_vfiprintf_r+0x168c>
800120c8:	fa c4 f9 f8 	sub	r4,sp,-1544
800120cc:	40 3c       	lddsp	r12,sp[0xc]
800120ce:	21 0c       	sub	r12,16
800120d0:	50 3c       	stdsp	sp[0xc],r12
800120d2:	fa f9 06 78 	ld.w	r9,sp[1656]
800120d6:	fa f8 06 74 	ld.w	r8,sp[1652]
800120da:	f2 cc ff f0 	sub	r12,r9,-16
800120de:	f0 cb ff ff 	sub	r11,r8,-1
800120e2:	fe ca 98 9e 	sub	r10,pc,-26466
800120e6:	40 3e       	lddsp	lr,sp[0xc]
800120e8:	59 0e       	cp.w	lr,16
800120ea:	fe 99 ff d8 	brgt	8001209a <_vfiprintf_r+0x147e>
800120ee:	1c 09       	add	r9,lr
800120f0:	89 0a       	st.w	r4[0x0],r10
800120f2:	fb 49 06 78 	st.w	sp[1656],r9
800120f6:	89 1e       	st.w	r4[0x4],lr
800120f8:	fb 4b 06 74 	st.w	sp[1652],r11
800120fc:	58 7b       	cp.w	r11,7
800120fe:	e0 89 00 04 	brgt	80012106 <_vfiprintf_r+0x14ea>
80012102:	2f 84       	sub	r4,-8
80012104:	c0 b8       	rjmp	8001211a <_vfiprintf_r+0x14fe>
80012106:	fa ca f9 90 	sub	r10,sp,-1648
8001210a:	40 2b       	lddsp	r11,sp[0x8]
8001210c:	02 9c       	mov	r12,r1
8001210e:	fe b0 f5 79 	rcall	80010c00 <__sprint_r>
80012112:	e0 81 00 cb 	brne	800122a8 <_vfiprintf_r+0x168c>
80012116:	fa c4 f9 f8 	sub	r4,sp,-1544
8001211a:	0a 10       	sub	r0,r5
8001211c:	58 00       	cp.w	r0,0
8001211e:	e0 89 00 1c 	brgt	80012156 <_vfiprintf_r+0x153a>
80012122:	c3 d8       	rjmp	8001219c <_vfiprintf_r+0x1580>
80012124:	fb 4c 06 78 	st.w	sp[1656],r12
80012128:	31 0a       	mov	r10,16
8001212a:	fe cc 98 e6 	sub	r12,pc,-26394
8001212e:	89 1a       	st.w	r4[0x4],r10
80012130:	89 0c       	st.w	r4[0x0],r12
80012132:	fb 4b 06 74 	st.w	sp[1652],r11
80012136:	58 7b       	cp.w	r11,7
80012138:	e0 89 00 04 	brgt	80012140 <_vfiprintf_r+0x1524>
8001213c:	2f 84       	sub	r4,-8
8001213e:	c0 b8       	rjmp	80012154 <_vfiprintf_r+0x1538>
80012140:	fa ca f9 90 	sub	r10,sp,-1648
80012144:	40 2b       	lddsp	r11,sp[0x8]
80012146:	02 9c       	mov	r12,r1
80012148:	fe b0 f5 5c 	rcall	80010c00 <__sprint_r>
8001214c:	e0 81 00 ae 	brne	800122a8 <_vfiprintf_r+0x168c>
80012150:	fa c4 f9 f8 	sub	r4,sp,-1544
80012154:	21 00       	sub	r0,16
80012156:	fa f9 06 78 	ld.w	r9,sp[1656]
8001215a:	fa f8 06 74 	ld.w	r8,sp[1652]
8001215e:	f2 cc ff f0 	sub	r12,r9,-16
80012162:	f0 cb ff ff 	sub	r11,r8,-1
80012166:	fe ca 99 22 	sub	r10,pc,-26334
8001216a:	59 00       	cp.w	r0,16
8001216c:	fe 99 ff dc 	brgt	80012124 <_vfiprintf_r+0x1508>
80012170:	00 09       	add	r9,r0
80012172:	89 0a       	st.w	r4[0x0],r10
80012174:	fb 49 06 78 	st.w	sp[1656],r9
80012178:	89 10       	st.w	r4[0x4],r0
8001217a:	fb 4b 06 74 	st.w	sp[1652],r11
8001217e:	58 7b       	cp.w	r11,7
80012180:	e0 89 00 04 	brgt	80012188 <_vfiprintf_r+0x156c>
80012184:	2f 84       	sub	r4,-8
80012186:	c0 b8       	rjmp	8001219c <_vfiprintf_r+0x1580>
80012188:	fa ca f9 90 	sub	r10,sp,-1648
8001218c:	40 2b       	lddsp	r11,sp[0x8]
8001218e:	02 9c       	mov	r12,r1
80012190:	fe b0 f5 38 	rcall	80010c00 <__sprint_r>
80012194:	e0 81 00 8a 	brne	800122a8 <_vfiprintf_r+0x168c>
80012198:	fa c4 f9 f8 	sub	r4,sp,-1544
8001219c:	fa f8 06 78 	ld.w	r8,sp[1656]
800121a0:	89 15       	st.w	r4[0x4],r5
800121a2:	89 07       	st.w	r4[0x0],r7
800121a4:	f0 05 00 05 	add	r5,r8,r5
800121a8:	fa f8 06 74 	ld.w	r8,sp[1652]
800121ac:	fb 45 06 78 	st.w	sp[1656],r5
800121b0:	2f f8       	sub	r8,-1
800121b2:	fb 48 06 74 	st.w	sp[1652],r8
800121b6:	58 78       	cp.w	r8,7
800121b8:	e0 89 00 04 	brgt	800121c0 <_vfiprintf_r+0x15a4>
800121bc:	2f 84       	sub	r4,-8
800121be:	c0 a8       	rjmp	800121d2 <_vfiprintf_r+0x15b6>
800121c0:	fa ca f9 90 	sub	r10,sp,-1648
800121c4:	40 2b       	lddsp	r11,sp[0x8]
800121c6:	02 9c       	mov	r12,r1
800121c8:	fe b0 f5 1c 	rcall	80010c00 <__sprint_r>
800121cc:	c6 e1       	brne	800122a8 <_vfiprintf_r+0x168c>
800121ce:	fa c4 f9 f8 	sub	r4,sp,-1544
800121d2:	e2 13 00 04 	andl	r3,0x4,COH
800121d6:	c4 00       	breq	80012256 <_vfiprintf_r+0x163a>
800121d8:	40 47       	lddsp	r7,sp[0x10]
800121da:	04 17       	sub	r7,r2
800121dc:	58 07       	cp.w	r7,0
800121de:	e0 89 00 19 	brgt	80012210 <_vfiprintf_r+0x15f4>
800121e2:	c3 a8       	rjmp	80012256 <_vfiprintf_r+0x163a>
800121e4:	fb 4c 06 78 	st.w	sp[1656],r12
800121e8:	89 05       	st.w	r4[0x0],r5
800121ea:	89 13       	st.w	r4[0x4],r3
800121ec:	fb 4b 06 74 	st.w	sp[1652],r11
800121f0:	58 7b       	cp.w	r11,7
800121f2:	e0 89 00 04 	brgt	800121fa <_vfiprintf_r+0x15de>
800121f6:	2f 84       	sub	r4,-8
800121f8:	c0 98       	rjmp	8001220a <_vfiprintf_r+0x15ee>
800121fa:	00 9a       	mov	r10,r0
800121fc:	40 2b       	lddsp	r11,sp[0x8]
800121fe:	02 9c       	mov	r12,r1
80012200:	fe b0 f5 00 	rcall	80010c00 <__sprint_r>
80012204:	c5 21       	brne	800122a8 <_vfiprintf_r+0x168c>
80012206:	fa c4 f9 f8 	sub	r4,sp,-1544
8001220a:	21 07       	sub	r7,16
8001220c:	c0 78       	rjmp	8001221a <_vfiprintf_r+0x15fe>
8001220e:	d7 03       	nop
80012210:	fe c5 98 bc 	sub	r5,pc,-26436
80012214:	31 03       	mov	r3,16
80012216:	fa c0 f9 90 	sub	r0,sp,-1648
8001221a:	fa f9 06 78 	ld.w	r9,sp[1656]
8001221e:	fa f8 06 74 	ld.w	r8,sp[1652]
80012222:	f2 cc ff f0 	sub	r12,r9,-16
80012226:	f0 cb ff ff 	sub	r11,r8,-1
8001222a:	fe ca 98 d6 	sub	r10,pc,-26410
8001222e:	59 07       	cp.w	r7,16
80012230:	fe 99 ff da 	brgt	800121e4 <_vfiprintf_r+0x15c8>
80012234:	0e 09       	add	r9,r7
80012236:	89 0a       	st.w	r4[0x0],r10
80012238:	89 17       	st.w	r4[0x4],r7
8001223a:	fb 49 06 78 	st.w	sp[1656],r9
8001223e:	fb 4b 06 74 	st.w	sp[1652],r11
80012242:	58 7b       	cp.w	r11,7
80012244:	e0 8a 00 09 	brle	80012256 <_vfiprintf_r+0x163a>
80012248:	fa ca f9 90 	sub	r10,sp,-1648
8001224c:	40 2b       	lddsp	r11,sp[0x8]
8001224e:	02 9c       	mov	r12,r1
80012250:	fe b0 f4 d8 	rcall	80010c00 <__sprint_r>
80012254:	c2 a1       	brne	800122a8 <_vfiprintf_r+0x168c>
80012256:	40 68       	lddsp	r8,sp[0x18]
80012258:	40 49       	lddsp	r9,sp[0x10]
8001225a:	e4 09 0c 42 	max	r2,r2,r9
8001225e:	04 08       	add	r8,r2
80012260:	50 68       	stdsp	sp[0x18],r8
80012262:	fa f8 06 78 	ld.w	r8,sp[1656]
80012266:	58 08       	cp.w	r8,0
80012268:	c0 80       	breq	80012278 <_vfiprintf_r+0x165c>
8001226a:	fa ca f9 90 	sub	r10,sp,-1648
8001226e:	40 2b       	lddsp	r11,sp[0x8]
80012270:	02 9c       	mov	r12,r1
80012272:	fe b0 f4 c7 	rcall	80010c00 <__sprint_r>
80012276:	c1 91       	brne	800122a8 <_vfiprintf_r+0x168c>
80012278:	30 03       	mov	r3,0
8001227a:	fa c4 f9 f8 	sub	r4,sp,-1544
8001227e:	fb 43 06 74 	st.w	sp[1652],r3
80012282:	fe 9f f5 4e 	bral	80010d1e <_vfiprintf_r+0x102>
80012286:	02 92       	mov	r2,r1
80012288:	40 20       	lddsp	r0,sp[0x8]
8001228a:	fa f8 06 78 	ld.w	r8,sp[1656]
8001228e:	58 08       	cp.w	r8,0
80012290:	c0 80       	breq	800122a0 <_vfiprintf_r+0x1684>
80012292:	02 9c       	mov	r12,r1
80012294:	fa ca f9 90 	sub	r10,sp,-1648
80012298:	00 9b       	mov	r11,r0
8001229a:	fe b0 f4 b3 	rcall	80010c00 <__sprint_r>
8001229e:	c0 61       	brne	800122aa <_vfiprintf_r+0x168e>
800122a0:	30 08       	mov	r8,0
800122a2:	fb 48 06 74 	st.w	sp[1652],r8
800122a6:	c0 28       	rjmp	800122aa <_vfiprintf_r+0x168e>
800122a8:	40 20       	lddsp	r0,sp[0x8]
800122aa:	80 68       	ld.sh	r8,r0[0xc]
800122ac:	ed b8 00 06 	bld	r8,0x6
800122b0:	c0 31       	brne	800122b6 <_vfiprintf_r+0x169a>
800122b2:	3f f2       	mov	r2,-1
800122b4:	50 62       	stdsp	sp[0x18],r2
800122b6:	40 6c       	lddsp	r12,sp[0x18]
800122b8:	fe 3d f9 78 	sub	sp,-1672
800122bc:	d8 32       	popm	r0-r7,pc
800122be:	d7 03       	nop

800122c0 <get_arg>:
800122c0:	d4 31       	pushm	r0-r7,lr
800122c2:	20 8d       	sub	sp,32
800122c4:	fa c4 ff bc 	sub	r4,sp,-68
800122c8:	50 4b       	stdsp	sp[0x10],r11
800122ca:	68 2e       	ld.w	lr,r4[0x8]
800122cc:	50 58       	stdsp	sp[0x14],r8
800122ce:	12 96       	mov	r6,r9
800122d0:	7c 0b       	ld.w	r11,lr[0x0]
800122d2:	70 05       	ld.w	r5,r8[0x0]
800122d4:	50 6e       	stdsp	sp[0x18],lr
800122d6:	58 0b       	cp.w	r11,0
800122d8:	f4 0b 17 00 	moveq	r11,r10
800122dc:	68 03       	ld.w	r3,r4[0x0]
800122de:	68 11       	ld.w	r1,r4[0x4]
800122e0:	40 49       	lddsp	r9,sp[0x10]
800122e2:	30 08       	mov	r8,0
800122e4:	c2 89       	rjmp	80012534 <get_arg+0x274>
800122e6:	2f fb       	sub	r11,-1
800122e8:	32 5c       	mov	r12,37
800122ea:	17 8a       	ld.ub	r10,r11[0x0]
800122ec:	f8 0a 18 00 	cp.b	r10,r12
800122f0:	5f 1e       	srne	lr
800122f2:	f0 0a 18 00 	cp.b	r10,r8
800122f6:	5f 1c       	srne	r12
800122f8:	fd ec 00 0c 	and	r12,lr,r12
800122fc:	f0 0c 18 00 	cp.b	r12,r8
80012300:	cf 31       	brne	800122e6 <get_arg+0x26>
80012302:	58 0a       	cp.w	r10,0
80012304:	e0 80 01 25 	breq	8001254e <get_arg+0x28e>
80012308:	30 0c       	mov	r12,0
8001230a:	3f fa       	mov	r10,-1
8001230c:	18 90       	mov	r0,r12
8001230e:	50 3a       	stdsp	sp[0xc],r10
80012310:	18 94       	mov	r4,r12
80012312:	18 92       	mov	r2,r12
80012314:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80012318:	16 97       	mov	r7,r11
8001231a:	50 7c       	stdsp	sp[0x1c],r12
8001231c:	fe cc 96 0c 	sub	r12,pc,-27124
80012320:	0f 3a       	ld.ub	r10,r7++
80012322:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80012326:	40 7c       	lddsp	r12,sp[0x1c]
80012328:	1c 0c       	add	r12,lr
8001232a:	fe ce 96 ba 	sub	lr,pc,-26950
8001232e:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80012332:	20 1e       	sub	lr,1
80012334:	50 0e       	stdsp	sp[0x0],lr
80012336:	fe ce 97 32 	sub	lr,pc,-26830
8001233a:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8001233e:	50 7c       	stdsp	sp[0x1c],r12
80012340:	40 0c       	lddsp	r12,sp[0x0]
80012342:	58 7c       	cp.w	r12,7
80012344:	e0 8b 00 f1 	brhi	80012526 <get_arg+0x266>
80012348:	fe ce 98 e4 	sub	lr,pc,-26396
8001234c:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80012350:	36 8b       	mov	r11,104
80012352:	f6 0a 18 00 	cp.b	r10,r11
80012356:	e0 80 00 e8 	breq	80012526 <get_arg+0x266>
8001235a:	37 1b       	mov	r11,113
8001235c:	f6 0a 18 00 	cp.b	r10,r11
80012360:	c0 70       	breq	8001236e <get_arg+0xae>
80012362:	34 cb       	mov	r11,76
80012364:	f6 0a 18 00 	cp.b	r10,r11
80012368:	c0 51       	brne	80012372 <get_arg+0xb2>
8001236a:	a3 b4       	sbr	r4,0x3
8001236c:	cd d8       	rjmp	80012526 <get_arg+0x266>
8001236e:	a5 b4       	sbr	r4,0x5
80012370:	cd b8       	rjmp	80012526 <get_arg+0x266>
80012372:	08 9a       	mov	r10,r4
80012374:	0e 9b       	mov	r11,r7
80012376:	a5 aa       	sbr	r10,0x4
80012378:	17 3c       	ld.ub	r12,r11++
8001237a:	a5 b4       	sbr	r4,0x5
8001237c:	36 ce       	mov	lr,108
8001237e:	fc 0c 18 00 	cp.b	r12,lr
80012382:	e0 80 00 d3 	breq	80012528 <get_arg+0x268>
80012386:	14 94       	mov	r4,r10
80012388:	cc f8       	rjmp	80012526 <get_arg+0x266>
8001238a:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8001238e:	36 7c       	mov	r12,103
80012390:	f8 0a 18 00 	cp.b	r10,r12
80012394:	e0 8b 00 27 	brhi	800123e2 <get_arg+0x122>
80012398:	36 5b       	mov	r11,101
8001239a:	f6 0a 18 00 	cp.b	r10,r11
8001239e:	c4 82       	brcc	8001242e <get_arg+0x16e>
800123a0:	34 fb       	mov	r11,79
800123a2:	f6 0a 18 00 	cp.b	r10,r11
800123a6:	c4 80       	breq	80012436 <get_arg+0x176>
800123a8:	e0 8b 00 0c 	brhi	800123c0 <get_arg+0x100>
800123ac:	34 5b       	mov	r11,69
800123ae:	f6 0a 18 00 	cp.b	r10,r11
800123b2:	c3 e0       	breq	8001242e <get_arg+0x16e>
800123b4:	34 7b       	mov	r11,71
800123b6:	f6 0a 18 00 	cp.b	r10,r11
800123ba:	c3 a0       	breq	8001242e <get_arg+0x16e>
800123bc:	34 4b       	mov	r11,68
800123be:	c0 88       	rjmp	800123ce <get_arg+0x10e>
800123c0:	35 8b       	mov	r11,88
800123c2:	f6 0a 18 00 	cp.b	r10,r11
800123c6:	c2 c0       	breq	8001241e <get_arg+0x15e>
800123c8:	e0 8b 00 07 	brhi	800123d6 <get_arg+0x116>
800123cc:	35 5b       	mov	r11,85
800123ce:	f6 0a 18 00 	cp.b	r10,r11
800123d2:	c3 51       	brne	8001243c <get_arg+0x17c>
800123d4:	c3 18       	rjmp	80012436 <get_arg+0x176>
800123d6:	36 3b       	mov	r11,99
800123d8:	f6 0a 18 00 	cp.b	r10,r11
800123dc:	c2 f0       	breq	8001243a <get_arg+0x17a>
800123de:	36 4b       	mov	r11,100
800123e0:	c0 e8       	rjmp	800123fc <get_arg+0x13c>
800123e2:	37 0b       	mov	r11,112
800123e4:	f6 0a 18 00 	cp.b	r10,r11
800123e8:	c2 50       	breq	80012432 <get_arg+0x172>
800123ea:	e0 8b 00 0d 	brhi	80012404 <get_arg+0x144>
800123ee:	36 eb       	mov	r11,110
800123f0:	f6 0a 18 00 	cp.b	r10,r11
800123f4:	c1 f0       	breq	80012432 <get_arg+0x172>
800123f6:	e0 8b 00 14 	brhi	8001241e <get_arg+0x15e>
800123fa:	36 9b       	mov	r11,105
800123fc:	f6 0a 18 00 	cp.b	r10,r11
80012400:	c1 e1       	brne	8001243c <get_arg+0x17c>
80012402:	c0 e8       	rjmp	8001241e <get_arg+0x15e>
80012404:	37 5b       	mov	r11,117
80012406:	f6 0a 18 00 	cp.b	r10,r11
8001240a:	c0 a0       	breq	8001241e <get_arg+0x15e>
8001240c:	37 8b       	mov	r11,120
8001240e:	f6 0a 18 00 	cp.b	r10,r11
80012412:	c0 60       	breq	8001241e <get_arg+0x15e>
80012414:	37 3b       	mov	r11,115
80012416:	f6 0a 18 00 	cp.b	r10,r11
8001241a:	c1 11       	brne	8001243c <get_arg+0x17c>
8001241c:	c0 b8       	rjmp	80012432 <get_arg+0x172>
8001241e:	ed b4 00 04 	bld	r4,0x4
80012422:	c0 a0       	breq	80012436 <get_arg+0x176>
80012424:	ed b4 00 05 	bld	r4,0x5
80012428:	c0 91       	brne	8001243a <get_arg+0x17a>
8001242a:	30 20       	mov	r0,2
8001242c:	c0 88       	rjmp	8001243c <get_arg+0x17c>
8001242e:	30 40       	mov	r0,4
80012430:	c0 68       	rjmp	8001243c <get_arg+0x17c>
80012432:	30 30       	mov	r0,3
80012434:	c0 48       	rjmp	8001243c <get_arg+0x17c>
80012436:	30 10       	mov	r0,1
80012438:	c0 28       	rjmp	8001243c <get_arg+0x17c>
8001243a:	30 00       	mov	r0,0
8001243c:	40 3b       	lddsp	r11,sp[0xc]
8001243e:	5b fb       	cp.w	r11,-1
80012440:	c0 40       	breq	80012448 <get_arg+0x188>
80012442:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80012446:	c7 08       	rjmp	80012526 <get_arg+0x266>
80012448:	58 60       	cp.w	r0,6
8001244a:	e0 8b 00 6e 	brhi	80012526 <get_arg+0x266>
8001244e:	6c 0a       	ld.w	r10,r6[0x0]
80012450:	ea cc ff ff 	sub	r12,r5,-1
80012454:	fe ce 99 d0 	sub	lr,pc,-26160
80012458:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
8001245c:	f4 cb ff f8 	sub	r11,r10,-8
80012460:	8d 0b       	st.w	r6[0x0],r11
80012462:	f4 ea 00 00 	ld.d	r10,r10[0]
80012466:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8001246a:	c0 f8       	rjmp	80012488 <get_arg+0x1c8>
8001246c:	f4 cb ff fc 	sub	r11,r10,-4
80012470:	8d 0b       	st.w	r6[0x0],r11
80012472:	74 0a       	ld.w	r10,r10[0x0]
80012474:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80012478:	c0 88       	rjmp	80012488 <get_arg+0x1c8>
8001247a:	f4 cb ff f8 	sub	r11,r10,-8
8001247e:	8d 0b       	st.w	r6[0x0],r11
80012480:	f4 ea 00 00 	ld.d	r10,r10[0]
80012484:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80012488:	0e 9b       	mov	r11,r7
8001248a:	18 95       	mov	r5,r12
8001248c:	c4 e8       	rjmp	80012528 <get_arg+0x268>
8001248e:	62 0a       	ld.w	r10,r1[0x0]
80012490:	5b fa       	cp.w	r10,-1
80012492:	c0 b1       	brne	800124a8 <get_arg+0x1e8>
80012494:	50 19       	stdsp	sp[0x4],r9
80012496:	50 28       	stdsp	sp[0x8],r8
80012498:	e0 6a 00 80 	mov	r10,128
8001249c:	30 0b       	mov	r11,0
8001249e:	02 9c       	mov	r12,r1
800124a0:	fe b0 ef f2 	rcall	80010484 <memset>
800124a4:	40 28       	lddsp	r8,sp[0x8]
800124a6:	40 19       	lddsp	r9,sp[0x4]
800124a8:	e4 cc 00 01 	sub	r12,r2,1
800124ac:	0e 9b       	mov	r11,r7
800124ae:	50 3c       	stdsp	sp[0xc],r12
800124b0:	f2 0c 0c 49 	max	r9,r9,r12
800124b4:	c3 a8       	rjmp	80012528 <get_arg+0x268>
800124b6:	62 0a       	ld.w	r10,r1[0x0]
800124b8:	5b fa       	cp.w	r10,-1
800124ba:	c0 b1       	brne	800124d0 <get_arg+0x210>
800124bc:	50 19       	stdsp	sp[0x4],r9
800124be:	50 28       	stdsp	sp[0x8],r8
800124c0:	e0 6a 00 80 	mov	r10,128
800124c4:	30 0b       	mov	r11,0
800124c6:	02 9c       	mov	r12,r1
800124c8:	fe b0 ef de 	rcall	80010484 <memset>
800124cc:	40 28       	lddsp	r8,sp[0x8]
800124ce:	40 19       	lddsp	r9,sp[0x4]
800124d0:	20 12       	sub	r2,1
800124d2:	30 0a       	mov	r10,0
800124d4:	0e 9b       	mov	r11,r7
800124d6:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
800124da:	f2 02 0c 49 	max	r9,r9,r2
800124de:	c2 58       	rjmp	80012528 <get_arg+0x268>
800124e0:	16 97       	mov	r7,r11
800124e2:	6c 0a       	ld.w	r10,r6[0x0]
800124e4:	f4 cb ff fc 	sub	r11,r10,-4
800124e8:	8d 0b       	st.w	r6[0x0],r11
800124ea:	74 0a       	ld.w	r10,r10[0x0]
800124ec:	0e 9b       	mov	r11,r7
800124ee:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800124f2:	2f f5       	sub	r5,-1
800124f4:	c1 a8       	rjmp	80012528 <get_arg+0x268>
800124f6:	f4 c2 00 30 	sub	r2,r10,48
800124fa:	c0 68       	rjmp	80012506 <get_arg+0x246>
800124fc:	e4 02 00 22 	add	r2,r2,r2<<0x2
80012500:	2f f7       	sub	r7,-1
80012502:	f4 02 00 12 	add	r2,r10,r2<<0x1
80012506:	0f 8a       	ld.ub	r10,r7[0x0]
80012508:	58 0a       	cp.w	r10,0
8001250a:	c0 e0       	breq	80012526 <get_arg+0x266>
8001250c:	23 0a       	sub	r10,48
8001250e:	58 9a       	cp.w	r10,9
80012510:	fe 98 ff f6 	brls	800124fc <get_arg+0x23c>
80012514:	c0 98       	rjmp	80012526 <get_arg+0x266>
80012516:	2f f7       	sub	r7,-1
80012518:	0f 8a       	ld.ub	r10,r7[0x0]
8001251a:	58 0a       	cp.w	r10,0
8001251c:	c0 50       	breq	80012526 <get_arg+0x266>
8001251e:	23 0a       	sub	r10,48
80012520:	58 9a       	cp.w	r10,9
80012522:	fe 98 ff fa 	brls	80012516 <get_arg+0x256>
80012526:	0e 9b       	mov	r11,r7
80012528:	40 7c       	lddsp	r12,sp[0x1c]
8001252a:	30 ba       	mov	r10,11
8001252c:	f4 0c 18 00 	cp.b	r12,r10
80012530:	fe 91 fe f2 	brne	80012314 <get_arg+0x54>
80012534:	40 42       	lddsp	r2,sp[0x10]
80012536:	17 8c       	ld.ub	r12,r11[0x0]
80012538:	0a 32       	cp.w	r2,r5
8001253a:	5f 4a       	srge	r10
8001253c:	f0 0c 18 00 	cp.b	r12,r8
80012540:	5f 1c       	srne	r12
80012542:	f9 ea 00 0a 	and	r10,r12,r10
80012546:	f0 0a 18 00 	cp.b	r10,r8
8001254a:	fe 91 fe cf 	brne	800122e8 <get_arg+0x28>
8001254e:	30 08       	mov	r8,0
80012550:	40 4e       	lddsp	lr,sp[0x10]
80012552:	17 8a       	ld.ub	r10,r11[0x0]
80012554:	e2 05 00 21 	add	r1,r1,r5<<0x2
80012558:	f0 0a 18 00 	cp.b	r10,r8
8001255c:	fc 09 17 10 	movne	r9,lr
80012560:	e6 05 00 38 	add	r8,r3,r5<<0x3
80012564:	06 9e       	mov	lr,r3
80012566:	c2 a8       	rjmp	800125ba <get_arg+0x2fa>
80012568:	62 0a       	ld.w	r10,r1[0x0]
8001256a:	58 3a       	cp.w	r10,3
8001256c:	c1 e0       	breq	800125a8 <get_arg+0x2e8>
8001256e:	e0 89 00 07 	brgt	8001257c <get_arg+0x2bc>
80012572:	58 1a       	cp.w	r10,1
80012574:	c1 a0       	breq	800125a8 <get_arg+0x2e8>
80012576:	58 2a       	cp.w	r10,2
80012578:	c1 81       	brne	800125a8 <get_arg+0x2e8>
8001257a:	c0 58       	rjmp	80012584 <get_arg+0x2c4>
8001257c:	58 5a       	cp.w	r10,5
8001257e:	c0 c0       	breq	80012596 <get_arg+0x2d6>
80012580:	c0 b5       	brlt	80012596 <get_arg+0x2d6>
80012582:	c1 38       	rjmp	800125a8 <get_arg+0x2e8>
80012584:	6c 0a       	ld.w	r10,r6[0x0]
80012586:	f4 cc ff f8 	sub	r12,r10,-8
8001258a:	8d 0c       	st.w	r6[0x0],r12
8001258c:	f4 e2 00 00 	ld.d	r2,r10[0]
80012590:	f0 e3 00 00 	st.d	r8[0],r2
80012594:	c1 08       	rjmp	800125b4 <get_arg+0x2f4>
80012596:	6c 0a       	ld.w	r10,r6[0x0]
80012598:	f4 cc ff f8 	sub	r12,r10,-8
8001259c:	8d 0c       	st.w	r6[0x0],r12
8001259e:	f4 e2 00 00 	ld.d	r2,r10[0]
800125a2:	f0 e3 00 00 	st.d	r8[0],r2
800125a6:	c0 78       	rjmp	800125b4 <get_arg+0x2f4>
800125a8:	6c 0a       	ld.w	r10,r6[0x0]
800125aa:	f4 cc ff fc 	sub	r12,r10,-4
800125ae:	8d 0c       	st.w	r6[0x0],r12
800125b0:	74 0a       	ld.w	r10,r10[0x0]
800125b2:	91 0a       	st.w	r8[0x0],r10
800125b4:	2f f5       	sub	r5,-1
800125b6:	2f 88       	sub	r8,-8
800125b8:	2f c1       	sub	r1,-4
800125ba:	12 35       	cp.w	r5,r9
800125bc:	fe 9a ff d6 	brle	80012568 <get_arg+0x2a8>
800125c0:	1c 93       	mov	r3,lr
800125c2:	40 52       	lddsp	r2,sp[0x14]
800125c4:	40 6e       	lddsp	lr,sp[0x18]
800125c6:	85 05       	st.w	r2[0x0],r5
800125c8:	9d 0b       	st.w	lr[0x0],r11
800125ca:	40 4b       	lddsp	r11,sp[0x10]
800125cc:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
800125d0:	2f 8d       	sub	sp,-32
800125d2:	d8 32       	popm	r0-r7,pc

800125d4 <__sprint_r>:
800125d4:	d4 21       	pushm	r4-r7,lr
800125d6:	14 97       	mov	r7,r10
800125d8:	74 28       	ld.w	r8,r10[0x8]
800125da:	58 08       	cp.w	r8,0
800125dc:	c0 41       	brne	800125e4 <__sprint_r+0x10>
800125de:	95 18       	st.w	r10[0x4],r8
800125e0:	10 9c       	mov	r12,r8
800125e2:	d8 22       	popm	r4-r7,pc
800125e4:	e0 a0 18 c2 	rcall	80015768 <__sfvwrite_r>
800125e8:	30 08       	mov	r8,0
800125ea:	8f 18       	st.w	r7[0x4],r8
800125ec:	8f 28       	st.w	r7[0x8],r8
800125ee:	d8 22       	popm	r4-r7,pc

800125f0 <_vfprintf_r>:
800125f0:	d4 31       	pushm	r0-r7,lr
800125f2:	fa cd 06 bc 	sub	sp,sp,1724
800125f6:	51 09       	stdsp	sp[0x40],r9
800125f8:	16 91       	mov	r1,r11
800125fa:	14 97       	mov	r7,r10
800125fc:	18 95       	mov	r5,r12
800125fe:	e0 a0 1a 25 	rcall	80015a48 <_localeconv_r>
80012602:	78 0c       	ld.w	r12,r12[0x0]
80012604:	50 cc       	stdsp	sp[0x30],r12
80012606:	58 05       	cp.w	r5,0
80012608:	c0 70       	breq	80012616 <_vfprintf_r+0x26>
8001260a:	6a 68       	ld.w	r8,r5[0x18]
8001260c:	58 08       	cp.w	r8,0
8001260e:	c0 41       	brne	80012616 <_vfprintf_r+0x26>
80012610:	0a 9c       	mov	r12,r5
80012612:	e0 a0 17 4b 	rcall	800154a8 <__sinit>
80012616:	fe c8 97 f6 	sub	r8,pc,-26634
8001261a:	10 31       	cp.w	r1,r8
8001261c:	c0 31       	brne	80012622 <_vfprintf_r+0x32>
8001261e:	6a 01       	ld.w	r1,r5[0x0]
80012620:	c0 c8       	rjmp	80012638 <_vfprintf_r+0x48>
80012622:	fe c8 97 e2 	sub	r8,pc,-26654
80012626:	10 31       	cp.w	r1,r8
80012628:	c0 31       	brne	8001262e <_vfprintf_r+0x3e>
8001262a:	6a 11       	ld.w	r1,r5[0x4]
8001262c:	c0 68       	rjmp	80012638 <_vfprintf_r+0x48>
8001262e:	fe c8 97 ce 	sub	r8,pc,-26674
80012632:	10 31       	cp.w	r1,r8
80012634:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80012638:	82 68       	ld.sh	r8,r1[0xc]
8001263a:	ed b8 00 03 	bld	r8,0x3
8001263e:	c0 41       	brne	80012646 <_vfprintf_r+0x56>
80012640:	62 48       	ld.w	r8,r1[0x10]
80012642:	58 08       	cp.w	r8,0
80012644:	c0 71       	brne	80012652 <_vfprintf_r+0x62>
80012646:	02 9b       	mov	r11,r1
80012648:	0a 9c       	mov	r12,r5
8001264a:	e0 a0 0f 5d 	rcall	80014504 <__swsetup_r>
8001264e:	e0 81 0f 54 	brne	800144f6 <_vfprintf_r+0x1f06>
80012652:	82 68       	ld.sh	r8,r1[0xc]
80012654:	10 99       	mov	r9,r8
80012656:	e2 19 00 1a 	andl	r9,0x1a,COH
8001265a:	58 a9       	cp.w	r9,10
8001265c:	c3 c1       	brne	800126d4 <_vfprintf_r+0xe4>
8001265e:	82 79       	ld.sh	r9,r1[0xe]
80012660:	30 0a       	mov	r10,0
80012662:	f4 09 19 00 	cp.h	r9,r10
80012666:	c3 75       	brlt	800126d4 <_vfprintf_r+0xe4>
80012668:	a1 d8       	cbr	r8,0x1
8001266a:	fb 58 05 d0 	st.h	sp[1488],r8
8001266e:	62 88       	ld.w	r8,r1[0x20]
80012670:	fb 48 05 e4 	st.w	sp[1508],r8
80012674:	62 a8       	ld.w	r8,r1[0x28]
80012676:	fb 48 05 ec 	st.w	sp[1516],r8
8001267a:	fa c8 ff bc 	sub	r8,sp,-68
8001267e:	fb 48 05 d4 	st.w	sp[1492],r8
80012682:	fb 48 05 c4 	st.w	sp[1476],r8
80012686:	e0 68 04 00 	mov	r8,1024
8001268a:	fb 48 05 d8 	st.w	sp[1496],r8
8001268e:	fb 48 05 cc 	st.w	sp[1484],r8
80012692:	30 08       	mov	r8,0
80012694:	fb 59 05 d2 	st.h	sp[1490],r9
80012698:	0e 9a       	mov	r10,r7
8001269a:	41 09       	lddsp	r9,sp[0x40]
8001269c:	fa c7 fa 3c 	sub	r7,sp,-1476
800126a0:	fb 48 05 dc 	st.w	sp[1500],r8
800126a4:	0a 9c       	mov	r12,r5
800126a6:	0e 9b       	mov	r11,r7
800126a8:	ca 4f       	rcall	800125f0 <_vfprintf_r>
800126aa:	50 bc       	stdsp	sp[0x2c],r12
800126ac:	c0 95       	brlt	800126be <_vfprintf_r+0xce>
800126ae:	0e 9b       	mov	r11,r7
800126b0:	0a 9c       	mov	r12,r5
800126b2:	e0 a0 16 23 	rcall	800152f8 <_fflush_r>
800126b6:	40 be       	lddsp	lr,sp[0x2c]
800126b8:	f9 be 01 ff 	movne	lr,-1
800126bc:	50 be       	stdsp	sp[0x2c],lr
800126be:	fb 08 05 d0 	ld.sh	r8,sp[1488]
800126c2:	ed b8 00 06 	bld	r8,0x6
800126c6:	e0 81 0f 1a 	brne	800144fa <_vfprintf_r+0x1f0a>
800126ca:	82 68       	ld.sh	r8,r1[0xc]
800126cc:	a7 a8       	sbr	r8,0x6
800126ce:	a2 68       	st.h	r1[0xc],r8
800126d0:	e0 8f 0f 15 	bral	800144fa <_vfprintf_r+0x1f0a>
800126d4:	30 08       	mov	r8,0
800126d6:	fb 48 06 b4 	st.w	sp[1716],r8
800126da:	fb 48 06 90 	st.w	sp[1680],r8
800126de:	fb 48 06 8c 	st.w	sp[1676],r8
800126e2:	fb 48 06 b0 	st.w	sp[1712],r8
800126e6:	30 08       	mov	r8,0
800126e8:	30 09       	mov	r9,0
800126ea:	50 a7       	stdsp	sp[0x28],r7
800126ec:	50 78       	stdsp	sp[0x1c],r8
800126ee:	fa c3 f9 e0 	sub	r3,sp,-1568
800126f2:	3f f8       	mov	r8,-1
800126f4:	50 59       	stdsp	sp[0x14],r9
800126f6:	fb 43 06 88 	st.w	sp[1672],r3
800126fa:	fb 48 05 44 	st.w	sp[1348],r8
800126fe:	12 9c       	mov	r12,r9
80012700:	50 69       	stdsp	sp[0x18],r9
80012702:	50 d9       	stdsp	sp[0x34],r9
80012704:	50 e9       	stdsp	sp[0x38],r9
80012706:	50 b9       	stdsp	sp[0x2c],r9
80012708:	12 97       	mov	r7,r9
8001270a:	0a 94       	mov	r4,r5
8001270c:	40 a2       	lddsp	r2,sp[0x28]
8001270e:	32 5a       	mov	r10,37
80012710:	30 08       	mov	r8,0
80012712:	c0 28       	rjmp	80012716 <_vfprintf_r+0x126>
80012714:	2f f2       	sub	r2,-1
80012716:	05 89       	ld.ub	r9,r2[0x0]
80012718:	f0 09 18 00 	cp.b	r9,r8
8001271c:	5f 1b       	srne	r11
8001271e:	f4 09 18 00 	cp.b	r9,r10
80012722:	5f 19       	srne	r9
80012724:	f3 eb 00 0b 	and	r11,r9,r11
80012728:	f0 0b 18 00 	cp.b	r11,r8
8001272c:	cf 41       	brne	80012714 <_vfprintf_r+0x124>
8001272e:	40 ab       	lddsp	r11,sp[0x28]
80012730:	e4 0b 01 06 	sub	r6,r2,r11
80012734:	c1 e0       	breq	80012770 <_vfprintf_r+0x180>
80012736:	fa f8 06 90 	ld.w	r8,sp[1680]
8001273a:	0c 08       	add	r8,r6
8001273c:	87 0b       	st.w	r3[0x0],r11
8001273e:	fb 48 06 90 	st.w	sp[1680],r8
80012742:	87 16       	st.w	r3[0x4],r6
80012744:	fa f8 06 8c 	ld.w	r8,sp[1676]
80012748:	2f f8       	sub	r8,-1
8001274a:	fb 48 06 8c 	st.w	sp[1676],r8
8001274e:	58 78       	cp.w	r8,7
80012750:	e0 89 00 04 	brgt	80012758 <_vfprintf_r+0x168>
80012754:	2f 83       	sub	r3,-8
80012756:	c0 a8       	rjmp	8001276a <_vfprintf_r+0x17a>
80012758:	fa ca f9 78 	sub	r10,sp,-1672
8001275c:	02 9b       	mov	r11,r1
8001275e:	08 9c       	mov	r12,r4
80012760:	c3 af       	rcall	800125d4 <__sprint_r>
80012762:	e0 81 0e c6 	brne	800144ee <_vfprintf_r+0x1efe>
80012766:	fa c3 f9 e0 	sub	r3,sp,-1568
8001276a:	40 ba       	lddsp	r10,sp[0x2c]
8001276c:	0c 0a       	add	r10,r6
8001276e:	50 ba       	stdsp	sp[0x2c],r10
80012770:	05 89       	ld.ub	r9,r2[0x0]
80012772:	30 08       	mov	r8,0
80012774:	f0 09 18 00 	cp.b	r9,r8
80012778:	e0 80 0e aa 	breq	800144cc <_vfprintf_r+0x1edc>
8001277c:	30 09       	mov	r9,0
8001277e:	fb 68 06 bb 	st.b	sp[1723],r8
80012782:	0e 96       	mov	r6,r7
80012784:	e4 c8 ff ff 	sub	r8,r2,-1
80012788:	3f fe       	mov	lr,-1
8001278a:	50 93       	stdsp	sp[0x24],r3
8001278c:	50 41       	stdsp	sp[0x10],r1
8001278e:	0e 93       	mov	r3,r7
80012790:	04 91       	mov	r1,r2
80012792:	50 89       	stdsp	sp[0x20],r9
80012794:	50 a8       	stdsp	sp[0x28],r8
80012796:	50 2e       	stdsp	sp[0x8],lr
80012798:	50 39       	stdsp	sp[0xc],r9
8001279a:	12 95       	mov	r5,r9
8001279c:	12 90       	mov	r0,r9
8001279e:	10 97       	mov	r7,r8
800127a0:	08 92       	mov	r2,r4
800127a2:	c0 78       	rjmp	800127b0 <_vfprintf_r+0x1c0>
800127a4:	3f fc       	mov	r12,-1
800127a6:	08 97       	mov	r7,r4
800127a8:	50 2c       	stdsp	sp[0x8],r12
800127aa:	c0 38       	rjmp	800127b0 <_vfprintf_r+0x1c0>
800127ac:	30 0b       	mov	r11,0
800127ae:	50 3b       	stdsp	sp[0xc],r11
800127b0:	0f 38       	ld.ub	r8,r7++
800127b2:	c0 28       	rjmp	800127b6 <_vfprintf_r+0x1c6>
800127b4:	12 90       	mov	r0,r9
800127b6:	f0 c9 00 20 	sub	r9,r8,32
800127ba:	e0 49 00 58 	cp.w	r9,88
800127be:	e0 8b 0a 30 	brhi	80013c1e <_vfprintf_r+0x162e>
800127c2:	fe ca 9d 22 	sub	r10,pc,-25310
800127c6:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
800127ca:	50 a7       	stdsp	sp[0x28],r7
800127cc:	50 80       	stdsp	sp[0x20],r0
800127ce:	0c 97       	mov	r7,r6
800127d0:	04 94       	mov	r4,r2
800127d2:	06 96       	mov	r6,r3
800127d4:	02 92       	mov	r2,r1
800127d6:	fe c9 9e aa 	sub	r9,pc,-24918
800127da:	40 93       	lddsp	r3,sp[0x24]
800127dc:	10 90       	mov	r0,r8
800127de:	40 41       	lddsp	r1,sp[0x10]
800127e0:	50 d9       	stdsp	sp[0x34],r9
800127e2:	e0 8f 08 8e 	bral	800138fe <_vfprintf_r+0x130e>
800127e6:	30 08       	mov	r8,0
800127e8:	fb 39 06 bb 	ld.ub	r9,sp[1723]
800127ec:	f0 09 18 00 	cp.b	r9,r8
800127f0:	ce 01       	brne	800127b0 <_vfprintf_r+0x1c0>
800127f2:	32 08       	mov	r8,32
800127f4:	c6 e8       	rjmp	800128d0 <_vfprintf_r+0x2e0>
800127f6:	a1 a5       	sbr	r5,0x0
800127f8:	cd cb       	rjmp	800127b0 <_vfprintf_r+0x1c0>
800127fa:	0f 89       	ld.ub	r9,r7[0x0]
800127fc:	f2 c8 00 30 	sub	r8,r9,48
80012800:	58 98       	cp.w	r8,9
80012802:	e0 8b 00 1d 	brhi	8001283c <_vfprintf_r+0x24c>
80012806:	ee c8 ff ff 	sub	r8,r7,-1
8001280a:	30 0b       	mov	r11,0
8001280c:	23 09       	sub	r9,48
8001280e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80012812:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80012816:	11 39       	ld.ub	r9,r8++
80012818:	f2 ca 00 30 	sub	r10,r9,48
8001281c:	58 9a       	cp.w	r10,9
8001281e:	fe 98 ff f7 	brls	8001280c <_vfprintf_r+0x21c>
80012822:	e0 49 00 24 	cp.w	r9,36
80012826:	cc 31       	brne	800127ac <_vfprintf_r+0x1bc>
80012828:	e0 4b 00 20 	cp.w	r11,32
8001282c:	e0 89 0e 60 	brgt	800144ec <_vfprintf_r+0x1efc>
80012830:	20 1b       	sub	r11,1
80012832:	fa f9 06 b4 	ld.w	r9,sp[1716]
80012836:	12 3b       	cp.w	r11,r9
80012838:	c0 95       	brlt	8001284a <_vfprintf_r+0x25a>
8001283a:	c1 08       	rjmp	8001285a <_vfprintf_r+0x26a>
8001283c:	fa f9 06 b4 	ld.w	r9,sp[1716]
80012840:	ec ca ff ff 	sub	r10,r6,-1
80012844:	12 36       	cp.w	r6,r9
80012846:	c1 f5       	brlt	80012884 <_vfprintf_r+0x294>
80012848:	c2 68       	rjmp	80012894 <_vfprintf_r+0x2a4>
8001284a:	fa ce f9 44 	sub	lr,sp,-1724
8001284e:	10 97       	mov	r7,r8
80012850:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80012854:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80012858:	c3 58       	rjmp	800128c2 <_vfprintf_r+0x2d2>
8001285a:	10 97       	mov	r7,r8
8001285c:	fa c8 f9 50 	sub	r8,sp,-1712
80012860:	1a d8       	st.w	--sp,r8
80012862:	fa c8 fa b8 	sub	r8,sp,-1352
80012866:	1a d8       	st.w	--sp,r8
80012868:	fa c8 fb b4 	sub	r8,sp,-1100
8001286c:	02 9a       	mov	r10,r1
8001286e:	1a d8       	st.w	--sp,r8
80012870:	04 9c       	mov	r12,r2
80012872:	fa c8 f9 40 	sub	r8,sp,-1728
80012876:	fa c9 ff b4 	sub	r9,sp,-76
8001287a:	fe b0 fd 23 	rcall	800122c0 <get_arg>
8001287e:	2f dd       	sub	sp,-12
80012880:	78 00       	ld.w	r0,r12[0x0]
80012882:	c2 08       	rjmp	800128c2 <_vfprintf_r+0x2d2>
80012884:	fa cc f9 44 	sub	r12,sp,-1724
80012888:	14 96       	mov	r6,r10
8001288a:	f8 03 00 38 	add	r8,r12,r3<<0x3
8001288e:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80012892:	c1 88       	rjmp	800128c2 <_vfprintf_r+0x2d2>
80012894:	41 08       	lddsp	r8,sp[0x40]
80012896:	59 f9       	cp.w	r9,31
80012898:	e0 89 00 11 	brgt	800128ba <_vfprintf_r+0x2ca>
8001289c:	f0 cb ff fc 	sub	r11,r8,-4
800128a0:	51 0b       	stdsp	sp[0x40],r11
800128a2:	70 00       	ld.w	r0,r8[0x0]
800128a4:	fa cb f9 44 	sub	r11,sp,-1724
800128a8:	f6 09 00 38 	add	r8,r11,r9<<0x3
800128ac:	f1 40 fd 88 	st.w	r8[-632],r0
800128b0:	2f f9       	sub	r9,-1
800128b2:	14 96       	mov	r6,r10
800128b4:	fb 49 06 b4 	st.w	sp[1716],r9
800128b8:	c0 58       	rjmp	800128c2 <_vfprintf_r+0x2d2>
800128ba:	70 00       	ld.w	r0,r8[0x0]
800128bc:	14 96       	mov	r6,r10
800128be:	2f c8       	sub	r8,-4
800128c0:	51 08       	stdsp	sp[0x40],r8
800128c2:	58 00       	cp.w	r0,0
800128c4:	fe 94 ff 76 	brge	800127b0 <_vfprintf_r+0x1c0>
800128c8:	5c 30       	neg	r0
800128ca:	a3 a5       	sbr	r5,0x2
800128cc:	c7 2b       	rjmp	800127b0 <_vfprintf_r+0x1c0>
800128ce:	32 b8       	mov	r8,43
800128d0:	fb 68 06 bb 	st.b	sp[1723],r8
800128d4:	c6 eb       	rjmp	800127b0 <_vfprintf_r+0x1c0>
800128d6:	0f 38       	ld.ub	r8,r7++
800128d8:	e0 48 00 2a 	cp.w	r8,42
800128dc:	c0 30       	breq	800128e2 <_vfprintf_r+0x2f2>
800128de:	30 09       	mov	r9,0
800128e0:	c7 98       	rjmp	800129d2 <_vfprintf_r+0x3e2>
800128e2:	0f 88       	ld.ub	r8,r7[0x0]
800128e4:	f0 c9 00 30 	sub	r9,r8,48
800128e8:	58 99       	cp.w	r9,9
800128ea:	e0 8b 00 1f 	brhi	80012928 <_vfprintf_r+0x338>
800128ee:	ee c4 ff ff 	sub	r4,r7,-1
800128f2:	30 0b       	mov	r11,0
800128f4:	23 08       	sub	r8,48
800128f6:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800128fa:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
800128fe:	09 38       	ld.ub	r8,r4++
80012900:	f0 c9 00 30 	sub	r9,r8,48
80012904:	58 99       	cp.w	r9,9
80012906:	fe 98 ff f7 	brls	800128f4 <_vfprintf_r+0x304>
8001290a:	e0 48 00 24 	cp.w	r8,36
8001290e:	fe 91 ff 4f 	brne	800127ac <_vfprintf_r+0x1bc>
80012912:	e0 4b 00 20 	cp.w	r11,32
80012916:	e0 89 0d eb 	brgt	800144ec <_vfprintf_r+0x1efc>
8001291a:	20 1b       	sub	r11,1
8001291c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80012920:	10 3b       	cp.w	r11,r8
80012922:	c0 a5       	brlt	80012936 <_vfprintf_r+0x346>
80012924:	c1 18       	rjmp	80012946 <_vfprintf_r+0x356>
80012926:	d7 03       	nop
80012928:	fa fa 06 b4 	ld.w	r10,sp[1716]
8001292c:	ec c9 ff ff 	sub	r9,r6,-1
80012930:	14 36       	cp.w	r6,r10
80012932:	c1 f5       	brlt	80012970 <_vfprintf_r+0x380>
80012934:	c2 88       	rjmp	80012984 <_vfprintf_r+0x394>
80012936:	fa ca f9 44 	sub	r10,sp,-1724
8001293a:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8001293e:	f6 fb fd 88 	ld.w	r11,r11[-632]
80012942:	50 2b       	stdsp	sp[0x8],r11
80012944:	c3 c8       	rjmp	800129bc <_vfprintf_r+0x3cc>
80012946:	fa c8 f9 50 	sub	r8,sp,-1712
8001294a:	1a d8       	st.w	--sp,r8
8001294c:	fa c8 fa b8 	sub	r8,sp,-1352
80012950:	1a d8       	st.w	--sp,r8
80012952:	fa c8 fb b4 	sub	r8,sp,-1100
80012956:	02 9a       	mov	r10,r1
80012958:	1a d8       	st.w	--sp,r8
8001295a:	04 9c       	mov	r12,r2
8001295c:	fa c8 f9 40 	sub	r8,sp,-1728
80012960:	fa c9 ff b4 	sub	r9,sp,-76
80012964:	fe b0 fc ae 	rcall	800122c0 <get_arg>
80012968:	2f dd       	sub	sp,-12
8001296a:	78 0c       	ld.w	r12,r12[0x0]
8001296c:	50 2c       	stdsp	sp[0x8],r12
8001296e:	c2 78       	rjmp	800129bc <_vfprintf_r+0x3cc>
80012970:	12 96       	mov	r6,r9
80012972:	0e 94       	mov	r4,r7
80012974:	fa c9 f9 44 	sub	r9,sp,-1724
80012978:	f2 03 00 38 	add	r8,r9,r3<<0x3
8001297c:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80012980:	50 28       	stdsp	sp[0x8],r8
80012982:	c1 d8       	rjmp	800129bc <_vfprintf_r+0x3cc>
80012984:	41 08       	lddsp	r8,sp[0x40]
80012986:	59 fa       	cp.w	r10,31
80012988:	e0 89 00 14 	brgt	800129b0 <_vfprintf_r+0x3c0>
8001298c:	f0 cb ff fc 	sub	r11,r8,-4
80012990:	70 08       	ld.w	r8,r8[0x0]
80012992:	51 0b       	stdsp	sp[0x40],r11
80012994:	50 28       	stdsp	sp[0x8],r8
80012996:	fa c6 f9 44 	sub	r6,sp,-1724
8001299a:	40 2e       	lddsp	lr,sp[0x8]
8001299c:	ec 0a 00 38 	add	r8,r6,r10<<0x3
800129a0:	f1 4e fd 88 	st.w	r8[-632],lr
800129a4:	2f fa       	sub	r10,-1
800129a6:	0e 94       	mov	r4,r7
800129a8:	fb 4a 06 b4 	st.w	sp[1716],r10
800129ac:	12 96       	mov	r6,r9
800129ae:	c0 78       	rjmp	800129bc <_vfprintf_r+0x3cc>
800129b0:	70 0c       	ld.w	r12,r8[0x0]
800129b2:	0e 94       	mov	r4,r7
800129b4:	2f c8       	sub	r8,-4
800129b6:	50 2c       	stdsp	sp[0x8],r12
800129b8:	12 96       	mov	r6,r9
800129ba:	51 08       	stdsp	sp[0x40],r8
800129bc:	40 2b       	lddsp	r11,sp[0x8]
800129be:	58 0b       	cp.w	r11,0
800129c0:	fe 95 fe f2 	brlt	800127a4 <_vfprintf_r+0x1b4>
800129c4:	08 97       	mov	r7,r4
800129c6:	cf 5a       	rjmp	800127b0 <_vfprintf_r+0x1c0>
800129c8:	f2 09 00 29 	add	r9,r9,r9<<0x2
800129cc:	0f 38       	ld.ub	r8,r7++
800129ce:	f4 09 00 19 	add	r9,r10,r9<<0x1
800129d2:	f0 ca 00 30 	sub	r10,r8,48
800129d6:	58 9a       	cp.w	r10,9
800129d8:	fe 98 ff f8 	brls	800129c8 <_vfprintf_r+0x3d8>
800129dc:	3f fa       	mov	r10,-1
800129de:	f2 0a 0c 49 	max	r9,r9,r10
800129e2:	50 29       	stdsp	sp[0x8],r9
800129e4:	ce 9a       	rjmp	800127b6 <_vfprintf_r+0x1c6>
800129e6:	a7 b5       	sbr	r5,0x7
800129e8:	ce 4a       	rjmp	800127b0 <_vfprintf_r+0x1c0>
800129ea:	30 09       	mov	r9,0
800129ec:	23 08       	sub	r8,48
800129ee:	f2 09 00 29 	add	r9,r9,r9<<0x2
800129f2:	f0 09 00 19 	add	r9,r8,r9<<0x1
800129f6:	0f 38       	ld.ub	r8,r7++
800129f8:	f0 ca 00 30 	sub	r10,r8,48
800129fc:	58 9a       	cp.w	r10,9
800129fe:	fe 98 ff f7 	brls	800129ec <_vfprintf_r+0x3fc>
80012a02:	e0 48 00 24 	cp.w	r8,36
80012a06:	fe 91 fe d7 	brne	800127b4 <_vfprintf_r+0x1c4>
80012a0a:	e0 49 00 20 	cp.w	r9,32
80012a0e:	e0 89 0d 6f 	brgt	800144ec <_vfprintf_r+0x1efc>
80012a12:	f2 c3 00 01 	sub	r3,r9,1
80012a16:	30 19       	mov	r9,1
80012a18:	50 39       	stdsp	sp[0xc],r9
80012a1a:	cc ba       	rjmp	800127b0 <_vfprintf_r+0x1c0>
80012a1c:	a3 b5       	sbr	r5,0x3
80012a1e:	cc 9a       	rjmp	800127b0 <_vfprintf_r+0x1c0>
80012a20:	a7 a5       	sbr	r5,0x6
80012a22:	cc 7a       	rjmp	800127b0 <_vfprintf_r+0x1c0>
80012a24:	0a 98       	mov	r8,r5
80012a26:	a5 b5       	sbr	r5,0x5
80012a28:	a5 a8       	sbr	r8,0x4
80012a2a:	0f 89       	ld.ub	r9,r7[0x0]
80012a2c:	36 ce       	mov	lr,108
80012a2e:	fc 09 18 00 	cp.b	r9,lr
80012a32:	f7 b7 00 ff 	subeq	r7,-1
80012a36:	f0 05 17 10 	movne	r5,r8
80012a3a:	cb ba       	rjmp	800127b0 <_vfprintf_r+0x1c0>
80012a3c:	a5 b5       	sbr	r5,0x5
80012a3e:	cb 9a       	rjmp	800127b0 <_vfprintf_r+0x1c0>
80012a40:	50 a7       	stdsp	sp[0x28],r7
80012a42:	50 80       	stdsp	sp[0x20],r0
80012a44:	0c 97       	mov	r7,r6
80012a46:	10 90       	mov	r0,r8
80012a48:	06 96       	mov	r6,r3
80012a4a:	04 94       	mov	r4,r2
80012a4c:	40 93       	lddsp	r3,sp[0x24]
80012a4e:	02 92       	mov	r2,r1
80012a50:	0e 99       	mov	r9,r7
80012a52:	40 41       	lddsp	r1,sp[0x10]
80012a54:	fa f8 06 b4 	ld.w	r8,sp[1716]
80012a58:	40 3c       	lddsp	r12,sp[0xc]
80012a5a:	58 0c       	cp.w	r12,0
80012a5c:	c1 d0       	breq	80012a96 <_vfprintf_r+0x4a6>
80012a5e:	10 36       	cp.w	r6,r8
80012a60:	c0 64       	brge	80012a6c <_vfprintf_r+0x47c>
80012a62:	fa cb f9 44 	sub	r11,sp,-1724
80012a66:	f6 06 00 36 	add	r6,r11,r6<<0x3
80012a6a:	c1 d8       	rjmp	80012aa4 <_vfprintf_r+0x4b4>
80012a6c:	fa c8 f9 50 	sub	r8,sp,-1712
80012a70:	1a d8       	st.w	--sp,r8
80012a72:	fa c8 fa b8 	sub	r8,sp,-1352
80012a76:	1a d8       	st.w	--sp,r8
80012a78:	fa c8 fb b4 	sub	r8,sp,-1100
80012a7c:	1a d8       	st.w	--sp,r8
80012a7e:	fa c8 f9 40 	sub	r8,sp,-1728
80012a82:	fa c9 ff b4 	sub	r9,sp,-76
80012a86:	04 9a       	mov	r10,r2
80012a88:	0c 9b       	mov	r11,r6
80012a8a:	08 9c       	mov	r12,r4
80012a8c:	fe b0 fc 1a 	rcall	800122c0 <get_arg>
80012a90:	2f dd       	sub	sp,-12
80012a92:	19 b8       	ld.ub	r8,r12[0x3]
80012a94:	c2 28       	rjmp	80012ad8 <_vfprintf_r+0x4e8>
80012a96:	2f f7       	sub	r7,-1
80012a98:	10 39       	cp.w	r9,r8
80012a9a:	c0 84       	brge	80012aaa <_vfprintf_r+0x4ba>
80012a9c:	fa ca f9 44 	sub	r10,sp,-1724
80012aa0:	f4 06 00 36 	add	r6,r10,r6<<0x3
80012aa4:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80012aa8:	c1 88       	rjmp	80012ad8 <_vfprintf_r+0x4e8>
80012aaa:	41 09       	lddsp	r9,sp[0x40]
80012aac:	59 f8       	cp.w	r8,31
80012aae:	e0 89 00 12 	brgt	80012ad2 <_vfprintf_r+0x4e2>
80012ab2:	f2 ca ff fc 	sub	r10,r9,-4
80012ab6:	51 0a       	stdsp	sp[0x40],r10
80012ab8:	72 09       	ld.w	r9,r9[0x0]
80012aba:	fa c6 f9 44 	sub	r6,sp,-1724
80012abe:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80012ac2:	2f f8       	sub	r8,-1
80012ac4:	f5 49 fd 88 	st.w	r10[-632],r9
80012ac8:	fb 48 06 b4 	st.w	sp[1716],r8
80012acc:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80012ad0:	c0 48       	rjmp	80012ad8 <_vfprintf_r+0x4e8>
80012ad2:	13 b8       	ld.ub	r8,r9[0x3]
80012ad4:	2f c9       	sub	r9,-4
80012ad6:	51 09       	stdsp	sp[0x40],r9
80012ad8:	fb 68 06 60 	st.b	sp[1632],r8
80012adc:	30 0e       	mov	lr,0
80012ade:	30 08       	mov	r8,0
80012ae0:	30 12       	mov	r2,1
80012ae2:	fb 68 06 bb 	st.b	sp[1723],r8
80012ae6:	50 2e       	stdsp	sp[0x8],lr
80012ae8:	e0 8f 08 ad 	bral	80013c42 <_vfprintf_r+0x1652>
80012aec:	50 a7       	stdsp	sp[0x28],r7
80012aee:	50 80       	stdsp	sp[0x20],r0
80012af0:	0c 97       	mov	r7,r6
80012af2:	04 94       	mov	r4,r2
80012af4:	06 96       	mov	r6,r3
80012af6:	02 92       	mov	r2,r1
80012af8:	40 93       	lddsp	r3,sp[0x24]
80012afa:	10 90       	mov	r0,r8
80012afc:	40 41       	lddsp	r1,sp[0x10]
80012afe:	a5 a5       	sbr	r5,0x4
80012b00:	c0 a8       	rjmp	80012b14 <_vfprintf_r+0x524>
80012b02:	50 a7       	stdsp	sp[0x28],r7
80012b04:	50 80       	stdsp	sp[0x20],r0
80012b06:	0c 97       	mov	r7,r6
80012b08:	04 94       	mov	r4,r2
80012b0a:	06 96       	mov	r6,r3
80012b0c:	02 92       	mov	r2,r1
80012b0e:	40 93       	lddsp	r3,sp[0x24]
80012b10:	10 90       	mov	r0,r8
80012b12:	40 41       	lddsp	r1,sp[0x10]
80012b14:	ed b5 00 05 	bld	r5,0x5
80012b18:	c5 11       	brne	80012bba <_vfprintf_r+0x5ca>
80012b1a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80012b1e:	40 3c       	lddsp	r12,sp[0xc]
80012b20:	58 0c       	cp.w	r12,0
80012b22:	c1 e0       	breq	80012b5e <_vfprintf_r+0x56e>
80012b24:	10 36       	cp.w	r6,r8
80012b26:	c0 64       	brge	80012b32 <_vfprintf_r+0x542>
80012b28:	fa cb f9 44 	sub	r11,sp,-1724
80012b2c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80012b30:	c2 08       	rjmp	80012b70 <_vfprintf_r+0x580>
80012b32:	fa c8 f9 50 	sub	r8,sp,-1712
80012b36:	1a d8       	st.w	--sp,r8
80012b38:	fa c8 fa b8 	sub	r8,sp,-1352
80012b3c:	0c 9b       	mov	r11,r6
80012b3e:	1a d8       	st.w	--sp,r8
80012b40:	fa c8 fb b4 	sub	r8,sp,-1100
80012b44:	1a d8       	st.w	--sp,r8
80012b46:	fa c9 ff b4 	sub	r9,sp,-76
80012b4a:	fa c8 f9 40 	sub	r8,sp,-1728
80012b4e:	04 9a       	mov	r10,r2
80012b50:	08 9c       	mov	r12,r4
80012b52:	fe b0 fb b7 	rcall	800122c0 <get_arg>
80012b56:	2f dd       	sub	sp,-12
80012b58:	78 1b       	ld.w	r11,r12[0x4]
80012b5a:	78 09       	ld.w	r9,r12[0x0]
80012b5c:	c2 b8       	rjmp	80012bb2 <_vfprintf_r+0x5c2>
80012b5e:	ee ca ff ff 	sub	r10,r7,-1
80012b62:	10 37       	cp.w	r7,r8
80012b64:	c0 b4       	brge	80012b7a <_vfprintf_r+0x58a>
80012b66:	fa c9 f9 44 	sub	r9,sp,-1724
80012b6a:	14 97       	mov	r7,r10
80012b6c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80012b70:	ec fb fd 8c 	ld.w	r11,r6[-628]
80012b74:	ec f9 fd 88 	ld.w	r9,r6[-632]
80012b78:	c1 d8       	rjmp	80012bb2 <_vfprintf_r+0x5c2>
80012b7a:	41 09       	lddsp	r9,sp[0x40]
80012b7c:	59 f8       	cp.w	r8,31
80012b7e:	e0 89 00 14 	brgt	80012ba6 <_vfprintf_r+0x5b6>
80012b82:	f2 cb ff f8 	sub	r11,r9,-8
80012b86:	51 0b       	stdsp	sp[0x40],r11
80012b88:	fa c6 f9 44 	sub	r6,sp,-1724
80012b8c:	72 1b       	ld.w	r11,r9[0x4]
80012b8e:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80012b92:	72 09       	ld.w	r9,r9[0x0]
80012b94:	f9 4b fd 8c 	st.w	r12[-628],r11
80012b98:	f9 49 fd 88 	st.w	r12[-632],r9
80012b9c:	2f f8       	sub	r8,-1
80012b9e:	14 97       	mov	r7,r10
80012ba0:	fb 48 06 b4 	st.w	sp[1716],r8
80012ba4:	c0 78       	rjmp	80012bb2 <_vfprintf_r+0x5c2>
80012ba6:	f2 c8 ff f8 	sub	r8,r9,-8
80012baa:	72 1b       	ld.w	r11,r9[0x4]
80012bac:	14 97       	mov	r7,r10
80012bae:	51 08       	stdsp	sp[0x40],r8
80012bb0:	72 09       	ld.w	r9,r9[0x0]
80012bb2:	16 98       	mov	r8,r11
80012bb4:	fa e9 00 00 	st.d	sp[0],r8
80012bb8:	ca e8       	rjmp	80012d14 <_vfprintf_r+0x724>
80012bba:	ed b5 00 04 	bld	r5,0x4
80012bbe:	c1 71       	brne	80012bec <_vfprintf_r+0x5fc>
80012bc0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80012bc4:	40 3e       	lddsp	lr,sp[0xc]
80012bc6:	58 0e       	cp.w	lr,0
80012bc8:	c0 80       	breq	80012bd8 <_vfprintf_r+0x5e8>
80012bca:	10 36       	cp.w	r6,r8
80012bcc:	c6 94       	brge	80012c9e <_vfprintf_r+0x6ae>
80012bce:	fa cc f9 44 	sub	r12,sp,-1724
80012bd2:	f8 06 00 36 	add	r6,r12,r6<<0x3
80012bd6:	c8 28       	rjmp	80012cda <_vfprintf_r+0x6ea>
80012bd8:	ee ca ff ff 	sub	r10,r7,-1
80012bdc:	10 37       	cp.w	r7,r8
80012bde:	e0 84 00 81 	brge	80012ce0 <_vfprintf_r+0x6f0>
80012be2:	fa cb f9 44 	sub	r11,sp,-1724
80012be6:	f6 06 00 36 	add	r6,r11,r6<<0x3
80012bea:	c7 78       	rjmp	80012cd8 <_vfprintf_r+0x6e8>
80012bec:	ed b5 00 06 	bld	r5,0x6
80012bf0:	c4 b1       	brne	80012c86 <_vfprintf_r+0x696>
80012bf2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80012bf6:	40 3c       	lddsp	r12,sp[0xc]
80012bf8:	58 0c       	cp.w	r12,0
80012bfa:	c1 d0       	breq	80012c34 <_vfprintf_r+0x644>
80012bfc:	10 36       	cp.w	r6,r8
80012bfe:	c0 64       	brge	80012c0a <_vfprintf_r+0x61a>
80012c00:	fa cb f9 44 	sub	r11,sp,-1724
80012c04:	f6 06 00 36 	add	r6,r11,r6<<0x3
80012c08:	c1 f8       	rjmp	80012c46 <_vfprintf_r+0x656>
80012c0a:	fa c8 f9 50 	sub	r8,sp,-1712
80012c0e:	1a d8       	st.w	--sp,r8
80012c10:	fa c8 fa b8 	sub	r8,sp,-1352
80012c14:	1a d8       	st.w	--sp,r8
80012c16:	fa c8 fb b4 	sub	r8,sp,-1100
80012c1a:	1a d8       	st.w	--sp,r8
80012c1c:	fa c8 f9 40 	sub	r8,sp,-1728
80012c20:	fa c9 ff b4 	sub	r9,sp,-76
80012c24:	04 9a       	mov	r10,r2
80012c26:	0c 9b       	mov	r11,r6
80012c28:	08 9c       	mov	r12,r4
80012c2a:	fe b0 fb 4b 	rcall	800122c0 <get_arg>
80012c2e:	2f dd       	sub	sp,-12
80012c30:	98 18       	ld.sh	r8,r12[0x2]
80012c32:	c2 68       	rjmp	80012c7e <_vfprintf_r+0x68e>
80012c34:	ee ca ff ff 	sub	r10,r7,-1
80012c38:	10 37       	cp.w	r7,r8
80012c3a:	c0 94       	brge	80012c4c <_vfprintf_r+0x65c>
80012c3c:	fa c9 f9 44 	sub	r9,sp,-1724
80012c40:	14 97       	mov	r7,r10
80012c42:	f2 06 00 36 	add	r6,r9,r6<<0x3
80012c46:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80012c4a:	c1 a8       	rjmp	80012c7e <_vfprintf_r+0x68e>
80012c4c:	41 09       	lddsp	r9,sp[0x40]
80012c4e:	59 f8       	cp.w	r8,31
80012c50:	e0 89 00 13 	brgt	80012c76 <_vfprintf_r+0x686>
80012c54:	f2 cb ff fc 	sub	r11,r9,-4
80012c58:	51 0b       	stdsp	sp[0x40],r11
80012c5a:	72 09       	ld.w	r9,r9[0x0]
80012c5c:	fa c6 f9 44 	sub	r6,sp,-1724
80012c60:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80012c64:	2f f8       	sub	r8,-1
80012c66:	f7 49 fd 88 	st.w	r11[-632],r9
80012c6a:	fb 48 06 b4 	st.w	sp[1716],r8
80012c6e:	14 97       	mov	r7,r10
80012c70:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80012c74:	c0 58       	rjmp	80012c7e <_vfprintf_r+0x68e>
80012c76:	92 18       	ld.sh	r8,r9[0x2]
80012c78:	14 97       	mov	r7,r10
80012c7a:	2f c9       	sub	r9,-4
80012c7c:	51 09       	stdsp	sp[0x40],r9
80012c7e:	50 18       	stdsp	sp[0x4],r8
80012c80:	bf 58       	asr	r8,0x1f
80012c82:	50 08       	stdsp	sp[0x0],r8
80012c84:	c4 88       	rjmp	80012d14 <_vfprintf_r+0x724>
80012c86:	fa f8 06 b4 	ld.w	r8,sp[1716]
80012c8a:	40 3c       	lddsp	r12,sp[0xc]
80012c8c:	58 0c       	cp.w	r12,0
80012c8e:	c1 d0       	breq	80012cc8 <_vfprintf_r+0x6d8>
80012c90:	10 36       	cp.w	r6,r8
80012c92:	c0 64       	brge	80012c9e <_vfprintf_r+0x6ae>
80012c94:	fa cb f9 44 	sub	r11,sp,-1724
80012c98:	f6 06 00 36 	add	r6,r11,r6<<0x3
80012c9c:	c1 f8       	rjmp	80012cda <_vfprintf_r+0x6ea>
80012c9e:	fa c8 f9 50 	sub	r8,sp,-1712
80012ca2:	1a d8       	st.w	--sp,r8
80012ca4:	fa c8 fa b8 	sub	r8,sp,-1352
80012ca8:	0c 9b       	mov	r11,r6
80012caa:	1a d8       	st.w	--sp,r8
80012cac:	fa c8 fb b4 	sub	r8,sp,-1100
80012cb0:	04 9a       	mov	r10,r2
80012cb2:	1a d8       	st.w	--sp,r8
80012cb4:	08 9c       	mov	r12,r4
80012cb6:	fa c8 f9 40 	sub	r8,sp,-1728
80012cba:	fa c9 ff b4 	sub	r9,sp,-76
80012cbe:	fe b0 fb 01 	rcall	800122c0 <get_arg>
80012cc2:	2f dd       	sub	sp,-12
80012cc4:	78 0b       	ld.w	r11,r12[0x0]
80012cc6:	c2 48       	rjmp	80012d0e <_vfprintf_r+0x71e>
80012cc8:	ee ca ff ff 	sub	r10,r7,-1
80012ccc:	10 37       	cp.w	r7,r8
80012cce:	c0 94       	brge	80012ce0 <_vfprintf_r+0x6f0>
80012cd0:	fa c9 f9 44 	sub	r9,sp,-1724
80012cd4:	f2 06 00 36 	add	r6,r9,r6<<0x3
80012cd8:	14 97       	mov	r7,r10
80012cda:	ec fb fd 88 	ld.w	r11,r6[-632]
80012cde:	c1 88       	rjmp	80012d0e <_vfprintf_r+0x71e>
80012ce0:	41 09       	lddsp	r9,sp[0x40]
80012ce2:	59 f8       	cp.w	r8,31
80012ce4:	e0 89 00 11 	brgt	80012d06 <_vfprintf_r+0x716>
80012ce8:	f2 cb ff fc 	sub	r11,r9,-4
80012cec:	51 0b       	stdsp	sp[0x40],r11
80012cee:	fa c6 f9 44 	sub	r6,sp,-1724
80012cf2:	72 0b       	ld.w	r11,r9[0x0]
80012cf4:	ec 08 00 39 	add	r9,r6,r8<<0x3
80012cf8:	f3 4b fd 88 	st.w	r9[-632],r11
80012cfc:	2f f8       	sub	r8,-1
80012cfe:	14 97       	mov	r7,r10
80012d00:	fb 48 06 b4 	st.w	sp[1716],r8
80012d04:	c0 58       	rjmp	80012d0e <_vfprintf_r+0x71e>
80012d06:	72 0b       	ld.w	r11,r9[0x0]
80012d08:	14 97       	mov	r7,r10
80012d0a:	2f c9       	sub	r9,-4
80012d0c:	51 09       	stdsp	sp[0x40],r9
80012d0e:	50 1b       	stdsp	sp[0x4],r11
80012d10:	bf 5b       	asr	r11,0x1f
80012d12:	50 0b       	stdsp	sp[0x0],r11
80012d14:	fa ea 00 00 	ld.d	r10,sp[0]
80012d18:	58 0a       	cp.w	r10,0
80012d1a:	5c 2b       	cpc	r11
80012d1c:	c0 e4       	brge	80012d38 <_vfprintf_r+0x748>
80012d1e:	30 08       	mov	r8,0
80012d20:	fa ea 00 00 	ld.d	r10,sp[0]
80012d24:	30 09       	mov	r9,0
80012d26:	f0 0a 01 0a 	sub	r10,r8,r10
80012d2a:	f2 0b 01 4b 	sbc	r11,r9,r11
80012d2e:	32 d8       	mov	r8,45
80012d30:	fa eb 00 00 	st.d	sp[0],r10
80012d34:	fb 68 06 bb 	st.b	sp[1723],r8
80012d38:	30 18       	mov	r8,1
80012d3a:	e0 8f 06 fa 	bral	80013b2e <_vfprintf_r+0x153e>
80012d3e:	50 a7       	stdsp	sp[0x28],r7
80012d40:	50 80       	stdsp	sp[0x20],r0
80012d42:	0c 97       	mov	r7,r6
80012d44:	04 94       	mov	r4,r2
80012d46:	06 96       	mov	r6,r3
80012d48:	02 92       	mov	r2,r1
80012d4a:	40 93       	lddsp	r3,sp[0x24]
80012d4c:	10 90       	mov	r0,r8
80012d4e:	40 41       	lddsp	r1,sp[0x10]
80012d50:	0e 99       	mov	r9,r7
80012d52:	ed b5 00 03 	bld	r5,0x3
80012d56:	c4 11       	brne	80012dd8 <_vfprintf_r+0x7e8>
80012d58:	fa f8 06 b4 	ld.w	r8,sp[1716]
80012d5c:	40 3a       	lddsp	r10,sp[0xc]
80012d5e:	58 0a       	cp.w	r10,0
80012d60:	c1 90       	breq	80012d92 <_vfprintf_r+0x7a2>
80012d62:	10 36       	cp.w	r6,r8
80012d64:	c6 45       	brlt	80012e2c <_vfprintf_r+0x83c>
80012d66:	fa c8 f9 50 	sub	r8,sp,-1712
80012d6a:	1a d8       	st.w	--sp,r8
80012d6c:	fa c8 fa b8 	sub	r8,sp,-1352
80012d70:	1a d8       	st.w	--sp,r8
80012d72:	fa c8 fb b4 	sub	r8,sp,-1100
80012d76:	0c 9b       	mov	r11,r6
80012d78:	1a d8       	st.w	--sp,r8
80012d7a:	04 9a       	mov	r10,r2
80012d7c:	fa c8 f9 40 	sub	r8,sp,-1728
80012d80:	fa c9 ff b4 	sub	r9,sp,-76
80012d84:	08 9c       	mov	r12,r4
80012d86:	fe b0 fa 9d 	rcall	800122c0 <get_arg>
80012d8a:	2f dd       	sub	sp,-12
80012d8c:	78 16       	ld.w	r6,r12[0x4]
80012d8e:	50 76       	stdsp	sp[0x1c],r6
80012d90:	c4 88       	rjmp	80012e20 <_vfprintf_r+0x830>
80012d92:	2f f7       	sub	r7,-1
80012d94:	10 39       	cp.w	r9,r8
80012d96:	c0 c4       	brge	80012dae <_vfprintf_r+0x7be>
80012d98:	fa ce f9 44 	sub	lr,sp,-1724
80012d9c:	fc 06 00 36 	add	r6,lr,r6<<0x3
80012da0:	ec fc fd 8c 	ld.w	r12,r6[-628]
80012da4:	50 7c       	stdsp	sp[0x1c],r12
80012da6:	ec f6 fd 88 	ld.w	r6,r6[-632]
80012daa:	50 56       	stdsp	sp[0x14],r6
80012dac:	c6 68       	rjmp	80012e78 <_vfprintf_r+0x888>
80012dae:	41 09       	lddsp	r9,sp[0x40]
80012db0:	59 f8       	cp.w	r8,31
80012db2:	e0 89 00 10 	brgt	80012dd2 <_vfprintf_r+0x7e2>
80012db6:	f2 ca ff f8 	sub	r10,r9,-8
80012dba:	72 1b       	ld.w	r11,r9[0x4]
80012dbc:	51 0a       	stdsp	sp[0x40],r10
80012dbe:	72 09       	ld.w	r9,r9[0x0]
80012dc0:	fa ca f9 44 	sub	r10,sp,-1724
80012dc4:	50 7b       	stdsp	sp[0x1c],r11
80012dc6:	50 59       	stdsp	sp[0x14],r9
80012dc8:	f4 08 00 39 	add	r9,r10,r8<<0x3
80012dcc:	40 5b       	lddsp	r11,sp[0x14]
80012dce:	40 7a       	lddsp	r10,sp[0x1c]
80012dd0:	c4 78       	rjmp	80012e5e <_vfprintf_r+0x86e>
80012dd2:	72 18       	ld.w	r8,r9[0x4]
80012dd4:	50 78       	stdsp	sp[0x1c],r8
80012dd6:	c4 c8       	rjmp	80012e6e <_vfprintf_r+0x87e>
80012dd8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80012ddc:	40 3e       	lddsp	lr,sp[0xc]
80012dde:	58 0e       	cp.w	lr,0
80012de0:	c2 30       	breq	80012e26 <_vfprintf_r+0x836>
80012de2:	10 36       	cp.w	r6,r8
80012de4:	c0 94       	brge	80012df6 <_vfprintf_r+0x806>
80012de6:	fa cc f9 44 	sub	r12,sp,-1724
80012dea:	f8 06 00 36 	add	r6,r12,r6<<0x3
80012dee:	ec fb fd 8c 	ld.w	r11,r6[-628]
80012df2:	50 7b       	stdsp	sp[0x1c],r11
80012df4:	cd 9b       	rjmp	80012da6 <_vfprintf_r+0x7b6>
80012df6:	fa c8 f9 50 	sub	r8,sp,-1712
80012dfa:	1a d8       	st.w	--sp,r8
80012dfc:	fa c8 fa b8 	sub	r8,sp,-1352
80012e00:	04 9a       	mov	r10,r2
80012e02:	1a d8       	st.w	--sp,r8
80012e04:	fa c8 fb b4 	sub	r8,sp,-1100
80012e08:	0c 9b       	mov	r11,r6
80012e0a:	1a d8       	st.w	--sp,r8
80012e0c:	08 9c       	mov	r12,r4
80012e0e:	fa c8 f9 40 	sub	r8,sp,-1728
80012e12:	fa c9 ff b4 	sub	r9,sp,-76
80012e16:	fe b0 fa 55 	rcall	800122c0 <get_arg>
80012e1a:	2f dd       	sub	sp,-12
80012e1c:	78 1a       	ld.w	r10,r12[0x4]
80012e1e:	50 7a       	stdsp	sp[0x1c],r10
80012e20:	78 0c       	ld.w	r12,r12[0x0]
80012e22:	50 5c       	stdsp	sp[0x14],r12
80012e24:	c2 a8       	rjmp	80012e78 <_vfprintf_r+0x888>
80012e26:	2f f7       	sub	r7,-1
80012e28:	10 39       	cp.w	r9,r8
80012e2a:	c0 94       	brge	80012e3c <_vfprintf_r+0x84c>
80012e2c:	fa c9 f9 44 	sub	r9,sp,-1724
80012e30:	f2 06 00 36 	add	r6,r9,r6<<0x3
80012e34:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80012e38:	50 78       	stdsp	sp[0x1c],r8
80012e3a:	cb 6b       	rjmp	80012da6 <_vfprintf_r+0x7b6>
80012e3c:	41 09       	lddsp	r9,sp[0x40]
80012e3e:	59 f8       	cp.w	r8,31
80012e40:	e0 89 00 15 	brgt	80012e6a <_vfprintf_r+0x87a>
80012e44:	f2 ca ff f8 	sub	r10,r9,-8
80012e48:	72 16       	ld.w	r6,r9[0x4]
80012e4a:	72 09       	ld.w	r9,r9[0x0]
80012e4c:	51 0a       	stdsp	sp[0x40],r10
80012e4e:	50 59       	stdsp	sp[0x14],r9
80012e50:	fa ce f9 44 	sub	lr,sp,-1724
80012e54:	50 76       	stdsp	sp[0x1c],r6
80012e56:	fc 08 00 39 	add	r9,lr,r8<<0x3
80012e5a:	40 5b       	lddsp	r11,sp[0x14]
80012e5c:	0c 9a       	mov	r10,r6
80012e5e:	f2 eb fd 88 	st.d	r9[-632],r10
80012e62:	2f f8       	sub	r8,-1
80012e64:	fb 48 06 b4 	st.w	sp[1716],r8
80012e68:	c0 88       	rjmp	80012e78 <_vfprintf_r+0x888>
80012e6a:	72 1c       	ld.w	r12,r9[0x4]
80012e6c:	50 7c       	stdsp	sp[0x1c],r12
80012e6e:	f2 c8 ff f8 	sub	r8,r9,-8
80012e72:	51 08       	stdsp	sp[0x40],r8
80012e74:	72 09       	ld.w	r9,r9[0x0]
80012e76:	50 59       	stdsp	sp[0x14],r9
80012e78:	40 5b       	lddsp	r11,sp[0x14]
80012e7a:	40 7a       	lddsp	r10,sp[0x1c]
80012e7c:	e0 a0 19 5c 	rcall	80016134 <__isinfd>
80012e80:	18 96       	mov	r6,r12
80012e82:	c1 70       	breq	80012eb0 <_vfprintf_r+0x8c0>
80012e84:	30 08       	mov	r8,0
80012e86:	30 09       	mov	r9,0
80012e88:	40 5b       	lddsp	r11,sp[0x14]
80012e8a:	40 7a       	lddsp	r10,sp[0x1c]
80012e8c:	e0 a0 1b 29 	rcall	800164de <__avr32_f64_cmp_lt>
80012e90:	c0 40       	breq	80012e98 <_vfprintf_r+0x8a8>
80012e92:	32 d8       	mov	r8,45
80012e94:	fb 68 06 bb 	st.b	sp[1723],r8
80012e98:	fe c8 a1 bc 	sub	r8,pc,-24132
80012e9c:	fe c6 a1 bc 	sub	r6,pc,-24132
80012ea0:	a7 d5       	cbr	r5,0x7
80012ea2:	e0 40 00 47 	cp.w	r0,71
80012ea6:	f0 06 17 a0 	movle	r6,r8
80012eaa:	30 32       	mov	r2,3
80012eac:	e0 8f 06 ce 	bral	80013c48 <_vfprintf_r+0x1658>
80012eb0:	40 5b       	lddsp	r11,sp[0x14]
80012eb2:	40 7a       	lddsp	r10,sp[0x1c]
80012eb4:	e0 a0 19 55 	rcall	8001615e <__isnand>
80012eb8:	c0 e0       	breq	80012ed4 <_vfprintf_r+0x8e4>
80012eba:	50 26       	stdsp	sp[0x8],r6
80012ebc:	fe c8 a1 d8 	sub	r8,pc,-24104
80012ec0:	fe c6 a1 d8 	sub	r6,pc,-24104
80012ec4:	a7 d5       	cbr	r5,0x7
80012ec6:	e0 40 00 47 	cp.w	r0,71
80012eca:	f0 06 17 a0 	movle	r6,r8
80012ece:	30 32       	mov	r2,3
80012ed0:	e0 8f 06 c2 	bral	80013c54 <_vfprintf_r+0x1664>
80012ed4:	40 2a       	lddsp	r10,sp[0x8]
80012ed6:	5b fa       	cp.w	r10,-1
80012ed8:	c0 41       	brne	80012ee0 <_vfprintf_r+0x8f0>
80012eda:	30 69       	mov	r9,6
80012edc:	50 29       	stdsp	sp[0x8],r9
80012ede:	c1 18       	rjmp	80012f00 <_vfprintf_r+0x910>
80012ee0:	e0 40 00 47 	cp.w	r0,71
80012ee4:	5f 09       	sreq	r9
80012ee6:	e0 40 00 67 	cp.w	r0,103
80012eea:	5f 08       	sreq	r8
80012eec:	f3 e8 10 08 	or	r8,r9,r8
80012ef0:	f8 08 18 00 	cp.b	r8,r12
80012ef4:	c0 60       	breq	80012f00 <_vfprintf_r+0x910>
80012ef6:	40 28       	lddsp	r8,sp[0x8]
80012ef8:	58 08       	cp.w	r8,0
80012efa:	f9 b8 00 01 	moveq	r8,1
80012efe:	50 28       	stdsp	sp[0x8],r8
80012f00:	40 78       	lddsp	r8,sp[0x1c]
80012f02:	40 59       	lddsp	r9,sp[0x14]
80012f04:	fa e9 06 94 	st.d	sp[1684],r8
80012f08:	a9 a5       	sbr	r5,0x8
80012f0a:	fa f8 06 94 	ld.w	r8,sp[1684]
80012f0e:	58 08       	cp.w	r8,0
80012f10:	c0 65       	brlt	80012f1c <_vfprintf_r+0x92c>
80012f12:	40 5e       	lddsp	lr,sp[0x14]
80012f14:	30 0c       	mov	r12,0
80012f16:	50 6e       	stdsp	sp[0x18],lr
80012f18:	50 9c       	stdsp	sp[0x24],r12
80012f1a:	c0 78       	rjmp	80012f28 <_vfprintf_r+0x938>
80012f1c:	40 5b       	lddsp	r11,sp[0x14]
80012f1e:	32 da       	mov	r10,45
80012f20:	ee 1b 80 00 	eorh	r11,0x8000
80012f24:	50 9a       	stdsp	sp[0x24],r10
80012f26:	50 6b       	stdsp	sp[0x18],r11
80012f28:	e0 40 00 46 	cp.w	r0,70
80012f2c:	5f 09       	sreq	r9
80012f2e:	e0 40 00 66 	cp.w	r0,102
80012f32:	5f 08       	sreq	r8
80012f34:	f3 e8 10 08 	or	r8,r9,r8
80012f38:	50 48       	stdsp	sp[0x10],r8
80012f3a:	c0 40       	breq	80012f42 <_vfprintf_r+0x952>
80012f3c:	40 22       	lddsp	r2,sp[0x8]
80012f3e:	30 39       	mov	r9,3
80012f40:	c1 08       	rjmp	80012f60 <_vfprintf_r+0x970>
80012f42:	e0 40 00 45 	cp.w	r0,69
80012f46:	5f 09       	sreq	r9
80012f48:	e0 40 00 65 	cp.w	r0,101
80012f4c:	5f 08       	sreq	r8
80012f4e:	40 22       	lddsp	r2,sp[0x8]
80012f50:	10 49       	or	r9,r8
80012f52:	2f f2       	sub	r2,-1
80012f54:	40 46       	lddsp	r6,sp[0x10]
80012f56:	ec 09 18 00 	cp.b	r9,r6
80012f5a:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80012f5e:	30 29       	mov	r9,2
80012f60:	fa c8 f9 5c 	sub	r8,sp,-1700
80012f64:	1a d8       	st.w	--sp,r8
80012f66:	fa c8 f9 54 	sub	r8,sp,-1708
80012f6a:	1a d8       	st.w	--sp,r8
80012f6c:	fa c8 f9 4c 	sub	r8,sp,-1716
80012f70:	08 9c       	mov	r12,r4
80012f72:	1a d8       	st.w	--sp,r8
80012f74:	04 98       	mov	r8,r2
80012f76:	40 9b       	lddsp	r11,sp[0x24]
80012f78:	40 aa       	lddsp	r10,sp[0x28]
80012f7a:	e0 a0 0b cb 	rcall	80014710 <_dtoa_r>
80012f7e:	e0 40 00 47 	cp.w	r0,71
80012f82:	5f 19       	srne	r9
80012f84:	e0 40 00 67 	cp.w	r0,103
80012f88:	5f 18       	srne	r8
80012f8a:	18 96       	mov	r6,r12
80012f8c:	2f dd       	sub	sp,-12
80012f8e:	f3 e8 00 08 	and	r8,r9,r8
80012f92:	c0 41       	brne	80012f9a <_vfprintf_r+0x9aa>
80012f94:	ed b5 00 00 	bld	r5,0x0
80012f98:	c3 01       	brne	80012ff8 <_vfprintf_r+0xa08>
80012f9a:	ec 02 00 0e 	add	lr,r6,r2
80012f9e:	50 3e       	stdsp	sp[0xc],lr
80012fa0:	40 4c       	lddsp	r12,sp[0x10]
80012fa2:	58 0c       	cp.w	r12,0
80012fa4:	c1 50       	breq	80012fce <_vfprintf_r+0x9de>
80012fa6:	0d 89       	ld.ub	r9,r6[0x0]
80012fa8:	33 08       	mov	r8,48
80012faa:	f0 09 18 00 	cp.b	r9,r8
80012fae:	c0 b1       	brne	80012fc4 <_vfprintf_r+0x9d4>
80012fb0:	30 08       	mov	r8,0
80012fb2:	30 09       	mov	r9,0
80012fb4:	40 6b       	lddsp	r11,sp[0x18]
80012fb6:	40 7a       	lddsp	r10,sp[0x1c]
80012fb8:	e0 a0 1a 4c 	rcall	80016450 <__avr32_f64_cmp_eq>
80012fbc:	fb b2 00 01 	rsubeq	r2,1
80012fc0:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80012fc4:	40 3b       	lddsp	r11,sp[0xc]
80012fc6:	fa f8 06 ac 	ld.w	r8,sp[1708]
80012fca:	10 0b       	add	r11,r8
80012fcc:	50 3b       	stdsp	sp[0xc],r11
80012fce:	40 6b       	lddsp	r11,sp[0x18]
80012fd0:	30 08       	mov	r8,0
80012fd2:	30 09       	mov	r9,0
80012fd4:	40 7a       	lddsp	r10,sp[0x1c]
80012fd6:	e0 a0 1a 3d 	rcall	80016450 <__avr32_f64_cmp_eq>
80012fda:	c0 90       	breq	80012fec <_vfprintf_r+0x9fc>
80012fdc:	40 3a       	lddsp	r10,sp[0xc]
80012fde:	fb 4a 06 a4 	st.w	sp[1700],r10
80012fe2:	c0 58       	rjmp	80012fec <_vfprintf_r+0x9fc>
80012fe4:	10 c9       	st.b	r8++,r9
80012fe6:	fb 48 06 a4 	st.w	sp[1700],r8
80012fea:	c0 28       	rjmp	80012fee <_vfprintf_r+0x9fe>
80012fec:	33 09       	mov	r9,48
80012fee:	fa f8 06 a4 	ld.w	r8,sp[1700]
80012ff2:	40 3e       	lddsp	lr,sp[0xc]
80012ff4:	1c 38       	cp.w	r8,lr
80012ff6:	cf 73       	brcs	80012fe4 <_vfprintf_r+0x9f4>
80012ff8:	e0 40 00 47 	cp.w	r0,71
80012ffc:	5f 09       	sreq	r9
80012ffe:	e0 40 00 67 	cp.w	r0,103
80013002:	5f 08       	sreq	r8
80013004:	f3 e8 10 08 	or	r8,r9,r8
80013008:	fa f9 06 a4 	ld.w	r9,sp[1700]
8001300c:	0c 19       	sub	r9,r6
8001300e:	50 69       	stdsp	sp[0x18],r9
80013010:	58 08       	cp.w	r8,0
80013012:	c0 b0       	breq	80013028 <_vfprintf_r+0xa38>
80013014:	fa f8 06 ac 	ld.w	r8,sp[1708]
80013018:	5b d8       	cp.w	r8,-3
8001301a:	c0 55       	brlt	80013024 <_vfprintf_r+0xa34>
8001301c:	40 2c       	lddsp	r12,sp[0x8]
8001301e:	18 38       	cp.w	r8,r12
80013020:	e0 8a 00 6a 	brle	800130f4 <_vfprintf_r+0xb04>
80013024:	20 20       	sub	r0,2
80013026:	c0 58       	rjmp	80013030 <_vfprintf_r+0xa40>
80013028:	e0 40 00 65 	cp.w	r0,101
8001302c:	e0 89 00 46 	brgt	800130b8 <_vfprintf_r+0xac8>
80013030:	fa fb 06 ac 	ld.w	r11,sp[1708]
80013034:	fb 60 06 9c 	st.b	sp[1692],r0
80013038:	20 1b       	sub	r11,1
8001303a:	fb 4b 06 ac 	st.w	sp[1708],r11
8001303e:	c0 47       	brpl	80013046 <_vfprintf_r+0xa56>
80013040:	5c 3b       	neg	r11
80013042:	32 d8       	mov	r8,45
80013044:	c0 28       	rjmp	80013048 <_vfprintf_r+0xa58>
80013046:	32 b8       	mov	r8,43
80013048:	fb 68 06 9d 	st.b	sp[1693],r8
8001304c:	58 9b       	cp.w	r11,9
8001304e:	e0 8a 00 1d 	brle	80013088 <_vfprintf_r+0xa98>
80013052:	fa c9 fa 35 	sub	r9,sp,-1483
80013056:	30 aa       	mov	r10,10
80013058:	12 98       	mov	r8,r9
8001305a:	0e 9c       	mov	r12,r7
8001305c:	0c 92       	mov	r2,r6
8001305e:	f6 0a 0c 06 	divs	r6,r11,r10
80013062:	0e 9b       	mov	r11,r7
80013064:	2d 0b       	sub	r11,-48
80013066:	10 fb       	st.b	--r8,r11
80013068:	0c 9b       	mov	r11,r6
8001306a:	58 96       	cp.w	r6,9
8001306c:	fe 99 ff f9 	brgt	8001305e <_vfprintf_r+0xa6e>
80013070:	2d 0b       	sub	r11,-48
80013072:	18 97       	mov	r7,r12
80013074:	04 96       	mov	r6,r2
80013076:	10 fb       	st.b	--r8,r11
80013078:	fa ca f9 62 	sub	r10,sp,-1694
8001307c:	c0 38       	rjmp	80013082 <_vfprintf_r+0xa92>
8001307e:	11 3b       	ld.ub	r11,r8++
80013080:	14 cb       	st.b	r10++,r11
80013082:	12 38       	cp.w	r8,r9
80013084:	cf d3       	brcs	8001307e <_vfprintf_r+0xa8e>
80013086:	c0 98       	rjmp	80013098 <_vfprintf_r+0xaa8>
80013088:	2d 0b       	sub	r11,-48
8001308a:	33 08       	mov	r8,48
8001308c:	fb 6b 06 9f 	st.b	sp[1695],r11
80013090:	fb 68 06 9e 	st.b	sp[1694],r8
80013094:	fa ca f9 60 	sub	r10,sp,-1696
80013098:	fa c8 f9 64 	sub	r8,sp,-1692
8001309c:	f4 08 01 08 	sub	r8,r10,r8
800130a0:	50 e8       	stdsp	sp[0x38],r8
800130a2:	10 92       	mov	r2,r8
800130a4:	40 6b       	lddsp	r11,sp[0x18]
800130a6:	16 02       	add	r2,r11
800130a8:	58 1b       	cp.w	r11,1
800130aa:	e0 89 00 05 	brgt	800130b4 <_vfprintf_r+0xac4>
800130ae:	ed b5 00 00 	bld	r5,0x0
800130b2:	c3 51       	brne	8001311c <_vfprintf_r+0xb2c>
800130b4:	2f f2       	sub	r2,-1
800130b6:	c3 38       	rjmp	8001311c <_vfprintf_r+0xb2c>
800130b8:	e0 40 00 66 	cp.w	r0,102
800130bc:	c1 c1       	brne	800130f4 <_vfprintf_r+0xb04>
800130be:	fa f2 06 ac 	ld.w	r2,sp[1708]
800130c2:	58 02       	cp.w	r2,0
800130c4:	e0 8a 00 0c 	brle	800130dc <_vfprintf_r+0xaec>
800130c8:	40 2a       	lddsp	r10,sp[0x8]
800130ca:	58 0a       	cp.w	r10,0
800130cc:	c0 41       	brne	800130d4 <_vfprintf_r+0xae4>
800130ce:	ed b5 00 00 	bld	r5,0x0
800130d2:	c2 51       	brne	8001311c <_vfprintf_r+0xb2c>
800130d4:	2f f2       	sub	r2,-1
800130d6:	40 29       	lddsp	r9,sp[0x8]
800130d8:	12 02       	add	r2,r9
800130da:	c0 b8       	rjmp	800130f0 <_vfprintf_r+0xb00>
800130dc:	40 28       	lddsp	r8,sp[0x8]
800130de:	58 08       	cp.w	r8,0
800130e0:	c0 61       	brne	800130ec <_vfprintf_r+0xafc>
800130e2:	ed b5 00 00 	bld	r5,0x0
800130e6:	c0 30       	breq	800130ec <_vfprintf_r+0xafc>
800130e8:	30 12       	mov	r2,1
800130ea:	c1 98       	rjmp	8001311c <_vfprintf_r+0xb2c>
800130ec:	40 22       	lddsp	r2,sp[0x8]
800130ee:	2f e2       	sub	r2,-2
800130f0:	36 60       	mov	r0,102
800130f2:	c1 58       	rjmp	8001311c <_vfprintf_r+0xb2c>
800130f4:	fa f2 06 ac 	ld.w	r2,sp[1708]
800130f8:	40 6e       	lddsp	lr,sp[0x18]
800130fa:	1c 32       	cp.w	r2,lr
800130fc:	c0 65       	brlt	80013108 <_vfprintf_r+0xb18>
800130fe:	ed b5 00 00 	bld	r5,0x0
80013102:	f7 b2 00 ff 	subeq	r2,-1
80013106:	c0 a8       	rjmp	8001311a <_vfprintf_r+0xb2a>
80013108:	e4 08 11 02 	rsub	r8,r2,2
8001310c:	40 6c       	lddsp	r12,sp[0x18]
8001310e:	58 02       	cp.w	r2,0
80013110:	f0 02 17 a0 	movle	r2,r8
80013114:	f9 b2 09 01 	movgt	r2,1
80013118:	18 02       	add	r2,r12
8001311a:	36 70       	mov	r0,103
8001311c:	40 9b       	lddsp	r11,sp[0x24]
8001311e:	58 0b       	cp.w	r11,0
80013120:	e0 80 05 94 	breq	80013c48 <_vfprintf_r+0x1658>
80013124:	32 d8       	mov	r8,45
80013126:	fb 68 06 bb 	st.b	sp[1723],r8
8001312a:	e0 8f 05 93 	bral	80013c50 <_vfprintf_r+0x1660>
8001312e:	50 a7       	stdsp	sp[0x28],r7
80013130:	04 94       	mov	r4,r2
80013132:	0c 97       	mov	r7,r6
80013134:	02 92       	mov	r2,r1
80013136:	06 96       	mov	r6,r3
80013138:	40 41       	lddsp	r1,sp[0x10]
8001313a:	40 93       	lddsp	r3,sp[0x24]
8001313c:	0e 99       	mov	r9,r7
8001313e:	ed b5 00 05 	bld	r5,0x5
80013142:	c4 81       	brne	800131d2 <_vfprintf_r+0xbe2>
80013144:	fa f8 06 b4 	ld.w	r8,sp[1716]
80013148:	40 3e       	lddsp	lr,sp[0xc]
8001314a:	58 0e       	cp.w	lr,0
8001314c:	c1 d0       	breq	80013186 <_vfprintf_r+0xb96>
8001314e:	10 36       	cp.w	r6,r8
80013150:	c0 64       	brge	8001315c <_vfprintf_r+0xb6c>
80013152:	fa cc f9 44 	sub	r12,sp,-1724
80013156:	f8 06 00 36 	add	r6,r12,r6<<0x3
8001315a:	c1 d8       	rjmp	80013194 <_vfprintf_r+0xba4>
8001315c:	fa c8 f9 50 	sub	r8,sp,-1712
80013160:	1a d8       	st.w	--sp,r8
80013162:	fa c8 fa b8 	sub	r8,sp,-1352
80013166:	04 9a       	mov	r10,r2
80013168:	1a d8       	st.w	--sp,r8
8001316a:	fa c8 fb b4 	sub	r8,sp,-1100
8001316e:	0c 9b       	mov	r11,r6
80013170:	1a d8       	st.w	--sp,r8
80013172:	08 9c       	mov	r12,r4
80013174:	fa c8 f9 40 	sub	r8,sp,-1728
80013178:	fa c9 ff b4 	sub	r9,sp,-76
8001317c:	fe b0 f8 a2 	rcall	800122c0 <get_arg>
80013180:	2f dd       	sub	sp,-12
80013182:	78 0a       	ld.w	r10,r12[0x0]
80013184:	c2 08       	rjmp	800131c4 <_vfprintf_r+0xbd4>
80013186:	2f f7       	sub	r7,-1
80013188:	10 39       	cp.w	r9,r8
8001318a:	c0 84       	brge	8001319a <_vfprintf_r+0xbaa>
8001318c:	fa cb f9 44 	sub	r11,sp,-1724
80013190:	f6 06 00 36 	add	r6,r11,r6<<0x3
80013194:	ec fa fd 88 	ld.w	r10,r6[-632]
80013198:	c1 68       	rjmp	800131c4 <_vfprintf_r+0xbd4>
8001319a:	41 09       	lddsp	r9,sp[0x40]
8001319c:	59 f8       	cp.w	r8,31
8001319e:	e0 89 00 10 	brgt	800131be <_vfprintf_r+0xbce>
800131a2:	f2 ca ff fc 	sub	r10,r9,-4
800131a6:	51 0a       	stdsp	sp[0x40],r10
800131a8:	fa c6 f9 44 	sub	r6,sp,-1724
800131ac:	72 0a       	ld.w	r10,r9[0x0]
800131ae:	ec 08 00 39 	add	r9,r6,r8<<0x3
800131b2:	f3 4a fd 88 	st.w	r9[-632],r10
800131b6:	2f f8       	sub	r8,-1
800131b8:	fb 48 06 b4 	st.w	sp[1716],r8
800131bc:	c0 48       	rjmp	800131c4 <_vfprintf_r+0xbd4>
800131be:	72 0a       	ld.w	r10,r9[0x0]
800131c0:	2f c9       	sub	r9,-4
800131c2:	51 09       	stdsp	sp[0x40],r9
800131c4:	40 be       	lddsp	lr,sp[0x2c]
800131c6:	1c 98       	mov	r8,lr
800131c8:	95 1e       	st.w	r10[0x4],lr
800131ca:	bf 58       	asr	r8,0x1f
800131cc:	95 08       	st.w	r10[0x0],r8
800131ce:	fe 9f fa 9f 	bral	8001270c <_vfprintf_r+0x11c>
800131d2:	ed b5 00 04 	bld	r5,0x4
800131d6:	c4 80       	breq	80013266 <_vfprintf_r+0xc76>
800131d8:	e2 15 00 40 	andl	r5,0x40,COH
800131dc:	c4 50       	breq	80013266 <_vfprintf_r+0xc76>
800131de:	fa f8 06 b4 	ld.w	r8,sp[1716]
800131e2:	40 3c       	lddsp	r12,sp[0xc]
800131e4:	58 0c       	cp.w	r12,0
800131e6:	c1 d0       	breq	80013220 <_vfprintf_r+0xc30>
800131e8:	10 36       	cp.w	r6,r8
800131ea:	c0 64       	brge	800131f6 <_vfprintf_r+0xc06>
800131ec:	fa cb f9 44 	sub	r11,sp,-1724
800131f0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800131f4:	c1 d8       	rjmp	8001322e <_vfprintf_r+0xc3e>
800131f6:	fa c8 f9 50 	sub	r8,sp,-1712
800131fa:	1a d8       	st.w	--sp,r8
800131fc:	fa c8 fa b8 	sub	r8,sp,-1352
80013200:	04 9a       	mov	r10,r2
80013202:	1a d8       	st.w	--sp,r8
80013204:	fa c8 fb b4 	sub	r8,sp,-1100
80013208:	0c 9b       	mov	r11,r6
8001320a:	1a d8       	st.w	--sp,r8
8001320c:	08 9c       	mov	r12,r4
8001320e:	fa c8 f9 40 	sub	r8,sp,-1728
80013212:	fa c9 ff b4 	sub	r9,sp,-76
80013216:	fe b0 f8 55 	rcall	800122c0 <get_arg>
8001321a:	2f dd       	sub	sp,-12
8001321c:	78 0a       	ld.w	r10,r12[0x0]
8001321e:	c2 08       	rjmp	8001325e <_vfprintf_r+0xc6e>
80013220:	2f f7       	sub	r7,-1
80013222:	10 39       	cp.w	r9,r8
80013224:	c0 84       	brge	80013234 <_vfprintf_r+0xc44>
80013226:	fa ca f9 44 	sub	r10,sp,-1724
8001322a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8001322e:	ec fa fd 88 	ld.w	r10,r6[-632]
80013232:	c1 68       	rjmp	8001325e <_vfprintf_r+0xc6e>
80013234:	41 09       	lddsp	r9,sp[0x40]
80013236:	59 f8       	cp.w	r8,31
80013238:	e0 89 00 10 	brgt	80013258 <_vfprintf_r+0xc68>
8001323c:	f2 ca ff fc 	sub	r10,r9,-4
80013240:	51 0a       	stdsp	sp[0x40],r10
80013242:	fa c6 f9 44 	sub	r6,sp,-1724
80013246:	72 0a       	ld.w	r10,r9[0x0]
80013248:	ec 08 00 39 	add	r9,r6,r8<<0x3
8001324c:	f3 4a fd 88 	st.w	r9[-632],r10
80013250:	2f f8       	sub	r8,-1
80013252:	fb 48 06 b4 	st.w	sp[1716],r8
80013256:	c0 48       	rjmp	8001325e <_vfprintf_r+0xc6e>
80013258:	72 0a       	ld.w	r10,r9[0x0]
8001325a:	2f c9       	sub	r9,-4
8001325c:	51 09       	stdsp	sp[0x40],r9
8001325e:	40 be       	lddsp	lr,sp[0x2c]
80013260:	b4 0e       	st.h	r10[0x0],lr
80013262:	fe 9f fa 55 	bral	8001270c <_vfprintf_r+0x11c>
80013266:	fa f8 06 b4 	ld.w	r8,sp[1716]
8001326a:	40 3c       	lddsp	r12,sp[0xc]
8001326c:	58 0c       	cp.w	r12,0
8001326e:	c1 d0       	breq	800132a8 <_vfprintf_r+0xcb8>
80013270:	10 36       	cp.w	r6,r8
80013272:	c0 64       	brge	8001327e <_vfprintf_r+0xc8e>
80013274:	fa cb f9 44 	sub	r11,sp,-1724
80013278:	f6 06 00 36 	add	r6,r11,r6<<0x3
8001327c:	c1 d8       	rjmp	800132b6 <_vfprintf_r+0xcc6>
8001327e:	fa c8 f9 50 	sub	r8,sp,-1712
80013282:	1a d8       	st.w	--sp,r8
80013284:	fa c8 fa b8 	sub	r8,sp,-1352
80013288:	04 9a       	mov	r10,r2
8001328a:	1a d8       	st.w	--sp,r8
8001328c:	fa c8 fb b4 	sub	r8,sp,-1100
80013290:	0c 9b       	mov	r11,r6
80013292:	1a d8       	st.w	--sp,r8
80013294:	08 9c       	mov	r12,r4
80013296:	fa c8 f9 40 	sub	r8,sp,-1728
8001329a:	fa c9 ff b4 	sub	r9,sp,-76
8001329e:	fe b0 f8 11 	rcall	800122c0 <get_arg>
800132a2:	2f dd       	sub	sp,-12
800132a4:	78 0a       	ld.w	r10,r12[0x0]
800132a6:	c2 08       	rjmp	800132e6 <_vfprintf_r+0xcf6>
800132a8:	2f f7       	sub	r7,-1
800132aa:	10 39       	cp.w	r9,r8
800132ac:	c0 84       	brge	800132bc <_vfprintf_r+0xccc>
800132ae:	fa ca f9 44 	sub	r10,sp,-1724
800132b2:	f4 06 00 36 	add	r6,r10,r6<<0x3
800132b6:	ec fa fd 88 	ld.w	r10,r6[-632]
800132ba:	c1 68       	rjmp	800132e6 <_vfprintf_r+0xcf6>
800132bc:	41 09       	lddsp	r9,sp[0x40]
800132be:	59 f8       	cp.w	r8,31
800132c0:	e0 89 00 10 	brgt	800132e0 <_vfprintf_r+0xcf0>
800132c4:	f2 ca ff fc 	sub	r10,r9,-4
800132c8:	51 0a       	stdsp	sp[0x40],r10
800132ca:	fa c6 f9 44 	sub	r6,sp,-1724
800132ce:	72 0a       	ld.w	r10,r9[0x0]
800132d0:	ec 08 00 39 	add	r9,r6,r8<<0x3
800132d4:	f3 4a fd 88 	st.w	r9[-632],r10
800132d8:	2f f8       	sub	r8,-1
800132da:	fb 48 06 b4 	st.w	sp[1716],r8
800132de:	c0 48       	rjmp	800132e6 <_vfprintf_r+0xcf6>
800132e0:	72 0a       	ld.w	r10,r9[0x0]
800132e2:	2f c9       	sub	r9,-4
800132e4:	51 09       	stdsp	sp[0x40],r9
800132e6:	40 be       	lddsp	lr,sp[0x2c]
800132e8:	95 0e       	st.w	r10[0x0],lr
800132ea:	fe 9f fa 11 	bral	8001270c <_vfprintf_r+0x11c>
800132ee:	50 a7       	stdsp	sp[0x28],r7
800132f0:	50 80       	stdsp	sp[0x20],r0
800132f2:	0c 97       	mov	r7,r6
800132f4:	04 94       	mov	r4,r2
800132f6:	06 96       	mov	r6,r3
800132f8:	02 92       	mov	r2,r1
800132fa:	40 93       	lddsp	r3,sp[0x24]
800132fc:	10 90       	mov	r0,r8
800132fe:	40 41       	lddsp	r1,sp[0x10]
80013300:	a5 a5       	sbr	r5,0x4
80013302:	c0 a8       	rjmp	80013316 <_vfprintf_r+0xd26>
80013304:	50 a7       	stdsp	sp[0x28],r7
80013306:	50 80       	stdsp	sp[0x20],r0
80013308:	0c 97       	mov	r7,r6
8001330a:	04 94       	mov	r4,r2
8001330c:	06 96       	mov	r6,r3
8001330e:	02 92       	mov	r2,r1
80013310:	40 93       	lddsp	r3,sp[0x24]
80013312:	10 90       	mov	r0,r8
80013314:	40 41       	lddsp	r1,sp[0x10]
80013316:	ed b5 00 05 	bld	r5,0x5
8001331a:	c5 d1       	brne	800133d4 <_vfprintf_r+0xde4>
8001331c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80013320:	40 3c       	lddsp	r12,sp[0xc]
80013322:	58 0c       	cp.w	r12,0
80013324:	c2 60       	breq	80013370 <_vfprintf_r+0xd80>
80013326:	10 36       	cp.w	r6,r8
80013328:	c0 a4       	brge	8001333c <_vfprintf_r+0xd4c>
8001332a:	fa cb f9 44 	sub	r11,sp,-1724
8001332e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80013332:	ec e8 fd 88 	ld.d	r8,r6[-632]
80013336:	fa e9 00 00 	st.d	sp[0],r8
8001333a:	c1 88       	rjmp	8001336a <_vfprintf_r+0xd7a>
8001333c:	fa c8 f9 50 	sub	r8,sp,-1712
80013340:	1a d8       	st.w	--sp,r8
80013342:	fa c8 fa b8 	sub	r8,sp,-1352
80013346:	04 9a       	mov	r10,r2
80013348:	1a d8       	st.w	--sp,r8
8001334a:	0c 9b       	mov	r11,r6
8001334c:	fa c8 fb b4 	sub	r8,sp,-1100
80013350:	08 9c       	mov	r12,r4
80013352:	1a d8       	st.w	--sp,r8
80013354:	fa c8 f9 40 	sub	r8,sp,-1728
80013358:	fa c9 ff b4 	sub	r9,sp,-76
8001335c:	fe b0 f7 b2 	rcall	800122c0 <get_arg>
80013360:	2f dd       	sub	sp,-12
80013362:	f8 ea 00 00 	ld.d	r10,r12[0]
80013366:	fa eb 00 00 	st.d	sp[0],r10
8001336a:	30 08       	mov	r8,0
8001336c:	e0 8f 03 de 	bral	80013b28 <_vfprintf_r+0x1538>
80013370:	ee ca ff ff 	sub	r10,r7,-1
80013374:	10 37       	cp.w	r7,r8
80013376:	c0 b4       	brge	8001338c <_vfprintf_r+0xd9c>
80013378:	fa c9 f9 44 	sub	r9,sp,-1724
8001337c:	14 97       	mov	r7,r10
8001337e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80013382:	ec ea fd 88 	ld.d	r10,r6[-632]
80013386:	fa eb 00 00 	st.d	sp[0],r10
8001338a:	c1 88       	rjmp	800133ba <_vfprintf_r+0xdca>
8001338c:	41 09       	lddsp	r9,sp[0x40]
8001338e:	59 f8       	cp.w	r8,31
80013390:	e0 89 00 18 	brgt	800133c0 <_vfprintf_r+0xdd0>
80013394:	f2 e6 00 00 	ld.d	r6,r9[0]
80013398:	f2 cb ff f8 	sub	r11,r9,-8
8001339c:	fa e7 00 00 	st.d	sp[0],r6
800133a0:	51 0b       	stdsp	sp[0x40],r11
800133a2:	fa c6 f9 44 	sub	r6,sp,-1724
800133a6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800133aa:	fa e6 00 00 	ld.d	r6,sp[0]
800133ae:	f2 e7 fd 88 	st.d	r9[-632],r6
800133b2:	2f f8       	sub	r8,-1
800133b4:	14 97       	mov	r7,r10
800133b6:	fb 48 06 b4 	st.w	sp[1716],r8
800133ba:	40 38       	lddsp	r8,sp[0xc]
800133bc:	e0 8f 03 b6 	bral	80013b28 <_vfprintf_r+0x1538>
800133c0:	f2 e6 00 00 	ld.d	r6,r9[0]
800133c4:	40 38       	lddsp	r8,sp[0xc]
800133c6:	fa e7 00 00 	st.d	sp[0],r6
800133ca:	2f 89       	sub	r9,-8
800133cc:	14 97       	mov	r7,r10
800133ce:	51 09       	stdsp	sp[0x40],r9
800133d0:	e0 8f 03 ac 	bral	80013b28 <_vfprintf_r+0x1538>
800133d4:	ed b5 00 04 	bld	r5,0x4
800133d8:	c1 61       	brne	80013404 <_vfprintf_r+0xe14>
800133da:	fa f8 06 b4 	ld.w	r8,sp[1716]
800133de:	40 3e       	lddsp	lr,sp[0xc]
800133e0:	58 0e       	cp.w	lr,0
800133e2:	c0 80       	breq	800133f2 <_vfprintf_r+0xe02>
800133e4:	10 36       	cp.w	r6,r8
800133e6:	c6 74       	brge	800134b4 <_vfprintf_r+0xec4>
800133e8:	fa cc f9 44 	sub	r12,sp,-1724
800133ec:	f8 06 00 36 	add	r6,r12,r6<<0x3
800133f0:	c8 08       	rjmp	800134f0 <_vfprintf_r+0xf00>
800133f2:	ee ca ff ff 	sub	r10,r7,-1
800133f6:	10 37       	cp.w	r7,r8
800133f8:	c7 f4       	brge	800134f6 <_vfprintf_r+0xf06>
800133fa:	fa cb f9 44 	sub	r11,sp,-1724
800133fe:	f6 06 00 36 	add	r6,r11,r6<<0x3
80013402:	c7 68       	rjmp	800134ee <_vfprintf_r+0xefe>
80013404:	ed b5 00 06 	bld	r5,0x6
80013408:	c4 a1       	brne	8001349c <_vfprintf_r+0xeac>
8001340a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8001340e:	40 3c       	lddsp	r12,sp[0xc]
80013410:	58 0c       	cp.w	r12,0
80013412:	c1 d0       	breq	8001344c <_vfprintf_r+0xe5c>
80013414:	10 36       	cp.w	r6,r8
80013416:	c0 64       	brge	80013422 <_vfprintf_r+0xe32>
80013418:	fa cb f9 44 	sub	r11,sp,-1724
8001341c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80013420:	c1 f8       	rjmp	8001345e <_vfprintf_r+0xe6e>
80013422:	fa c8 f9 50 	sub	r8,sp,-1712
80013426:	1a d8       	st.w	--sp,r8
80013428:	fa c8 fa b8 	sub	r8,sp,-1352
8001342c:	1a d8       	st.w	--sp,r8
8001342e:	fa c8 fb b4 	sub	r8,sp,-1100
80013432:	1a d8       	st.w	--sp,r8
80013434:	fa c8 f9 40 	sub	r8,sp,-1728
80013438:	fa c9 ff b4 	sub	r9,sp,-76
8001343c:	04 9a       	mov	r10,r2
8001343e:	0c 9b       	mov	r11,r6
80013440:	08 9c       	mov	r12,r4
80013442:	fe b0 f7 3f 	rcall	800122c0 <get_arg>
80013446:	2f dd       	sub	sp,-12
80013448:	98 18       	ld.sh	r8,r12[0x2]
8001344a:	c2 68       	rjmp	80013496 <_vfprintf_r+0xea6>
8001344c:	ee ca ff ff 	sub	r10,r7,-1
80013450:	10 37       	cp.w	r7,r8
80013452:	c0 94       	brge	80013464 <_vfprintf_r+0xe74>
80013454:	fa c9 f9 44 	sub	r9,sp,-1724
80013458:	14 97       	mov	r7,r10
8001345a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8001345e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80013462:	c1 a8       	rjmp	80013496 <_vfprintf_r+0xea6>
80013464:	41 09       	lddsp	r9,sp[0x40]
80013466:	59 f8       	cp.w	r8,31
80013468:	e0 89 00 13 	brgt	8001348e <_vfprintf_r+0xe9e>
8001346c:	f2 cb ff fc 	sub	r11,r9,-4
80013470:	51 0b       	stdsp	sp[0x40],r11
80013472:	72 09       	ld.w	r9,r9[0x0]
80013474:	fa c6 f9 44 	sub	r6,sp,-1724
80013478:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8001347c:	2f f8       	sub	r8,-1
8001347e:	f7 49 fd 88 	st.w	r11[-632],r9
80013482:	fb 48 06 b4 	st.w	sp[1716],r8
80013486:	14 97       	mov	r7,r10
80013488:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8001348c:	c0 58       	rjmp	80013496 <_vfprintf_r+0xea6>
8001348e:	92 18       	ld.sh	r8,r9[0x2]
80013490:	14 97       	mov	r7,r10
80013492:	2f c9       	sub	r9,-4
80013494:	51 09       	stdsp	sp[0x40],r9
80013496:	5c 78       	castu.h	r8
80013498:	50 18       	stdsp	sp[0x4],r8
8001349a:	c4 68       	rjmp	80013526 <_vfprintf_r+0xf36>
8001349c:	fa f8 06 b4 	ld.w	r8,sp[1716]
800134a0:	40 3c       	lddsp	r12,sp[0xc]
800134a2:	58 0c       	cp.w	r12,0
800134a4:	c1 d0       	breq	800134de <_vfprintf_r+0xeee>
800134a6:	10 36       	cp.w	r6,r8
800134a8:	c0 64       	brge	800134b4 <_vfprintf_r+0xec4>
800134aa:	fa cb f9 44 	sub	r11,sp,-1724
800134ae:	f6 06 00 36 	add	r6,r11,r6<<0x3
800134b2:	c1 f8       	rjmp	800134f0 <_vfprintf_r+0xf00>
800134b4:	fa c8 f9 50 	sub	r8,sp,-1712
800134b8:	1a d8       	st.w	--sp,r8
800134ba:	fa c8 fa b8 	sub	r8,sp,-1352
800134be:	0c 9b       	mov	r11,r6
800134c0:	1a d8       	st.w	--sp,r8
800134c2:	fa c8 fb b4 	sub	r8,sp,-1100
800134c6:	04 9a       	mov	r10,r2
800134c8:	1a d8       	st.w	--sp,r8
800134ca:	08 9c       	mov	r12,r4
800134cc:	fa c8 f9 40 	sub	r8,sp,-1728
800134d0:	fa c9 ff b4 	sub	r9,sp,-76
800134d4:	fe b0 f6 f6 	rcall	800122c0 <get_arg>
800134d8:	2f dd       	sub	sp,-12
800134da:	78 0b       	ld.w	r11,r12[0x0]
800134dc:	c2 48       	rjmp	80013524 <_vfprintf_r+0xf34>
800134de:	ee ca ff ff 	sub	r10,r7,-1
800134e2:	10 37       	cp.w	r7,r8
800134e4:	c0 94       	brge	800134f6 <_vfprintf_r+0xf06>
800134e6:	fa c9 f9 44 	sub	r9,sp,-1724
800134ea:	f2 06 00 36 	add	r6,r9,r6<<0x3
800134ee:	14 97       	mov	r7,r10
800134f0:	ec fb fd 88 	ld.w	r11,r6[-632]
800134f4:	c1 88       	rjmp	80013524 <_vfprintf_r+0xf34>
800134f6:	41 09       	lddsp	r9,sp[0x40]
800134f8:	59 f8       	cp.w	r8,31
800134fa:	e0 89 00 11 	brgt	8001351c <_vfprintf_r+0xf2c>
800134fe:	f2 cb ff fc 	sub	r11,r9,-4
80013502:	51 0b       	stdsp	sp[0x40],r11
80013504:	fa c6 f9 44 	sub	r6,sp,-1724
80013508:	72 0b       	ld.w	r11,r9[0x0]
8001350a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8001350e:	f3 4b fd 88 	st.w	r9[-632],r11
80013512:	2f f8       	sub	r8,-1
80013514:	14 97       	mov	r7,r10
80013516:	fb 48 06 b4 	st.w	sp[1716],r8
8001351a:	c0 58       	rjmp	80013524 <_vfprintf_r+0xf34>
8001351c:	72 0b       	ld.w	r11,r9[0x0]
8001351e:	14 97       	mov	r7,r10
80013520:	2f c9       	sub	r9,-4
80013522:	51 09       	stdsp	sp[0x40],r9
80013524:	50 1b       	stdsp	sp[0x4],r11
80013526:	30 0e       	mov	lr,0
80013528:	50 0e       	stdsp	sp[0x0],lr
8001352a:	1c 98       	mov	r8,lr
8001352c:	e0 8f 02 fe 	bral	80013b28 <_vfprintf_r+0x1538>
80013530:	50 a7       	stdsp	sp[0x28],r7
80013532:	50 80       	stdsp	sp[0x20],r0
80013534:	0c 97       	mov	r7,r6
80013536:	04 94       	mov	r4,r2
80013538:	06 96       	mov	r6,r3
8001353a:	02 92       	mov	r2,r1
8001353c:	40 93       	lddsp	r3,sp[0x24]
8001353e:	40 41       	lddsp	r1,sp[0x10]
80013540:	0e 99       	mov	r9,r7
80013542:	fa f8 06 b4 	ld.w	r8,sp[1716]
80013546:	40 3c       	lddsp	r12,sp[0xc]
80013548:	58 0c       	cp.w	r12,0
8001354a:	c1 d0       	breq	80013584 <_vfprintf_r+0xf94>
8001354c:	10 36       	cp.w	r6,r8
8001354e:	c0 64       	brge	8001355a <_vfprintf_r+0xf6a>
80013550:	fa cb f9 44 	sub	r11,sp,-1724
80013554:	f6 06 00 36 	add	r6,r11,r6<<0x3
80013558:	c1 d8       	rjmp	80013592 <_vfprintf_r+0xfa2>
8001355a:	fa c8 f9 50 	sub	r8,sp,-1712
8001355e:	1a d8       	st.w	--sp,r8
80013560:	fa c8 fa b8 	sub	r8,sp,-1352
80013564:	1a d8       	st.w	--sp,r8
80013566:	fa c8 fb b4 	sub	r8,sp,-1100
8001356a:	1a d8       	st.w	--sp,r8
8001356c:	fa c9 ff b4 	sub	r9,sp,-76
80013570:	fa c8 f9 40 	sub	r8,sp,-1728
80013574:	04 9a       	mov	r10,r2
80013576:	0c 9b       	mov	r11,r6
80013578:	08 9c       	mov	r12,r4
8001357a:	fe b0 f6 a3 	rcall	800122c0 <get_arg>
8001357e:	2f dd       	sub	sp,-12
80013580:	78 09       	ld.w	r9,r12[0x0]
80013582:	c2 18       	rjmp	800135c4 <_vfprintf_r+0xfd4>
80013584:	2f f7       	sub	r7,-1
80013586:	10 39       	cp.w	r9,r8
80013588:	c0 84       	brge	80013598 <_vfprintf_r+0xfa8>
8001358a:	fa ca f9 44 	sub	r10,sp,-1724
8001358e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80013592:	ec f9 fd 88 	ld.w	r9,r6[-632]
80013596:	c1 78       	rjmp	800135c4 <_vfprintf_r+0xfd4>
80013598:	41 09       	lddsp	r9,sp[0x40]
8001359a:	59 f8       	cp.w	r8,31
8001359c:	e0 89 00 10 	brgt	800135bc <_vfprintf_r+0xfcc>
800135a0:	f2 ca ff fc 	sub	r10,r9,-4
800135a4:	51 0a       	stdsp	sp[0x40],r10
800135a6:	fa c6 f9 44 	sub	r6,sp,-1724
800135aa:	72 09       	ld.w	r9,r9[0x0]
800135ac:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800135b0:	f5 49 fd 88 	st.w	r10[-632],r9
800135b4:	2f f8       	sub	r8,-1
800135b6:	fb 48 06 b4 	st.w	sp[1716],r8
800135ba:	c0 58       	rjmp	800135c4 <_vfprintf_r+0xfd4>
800135bc:	f2 c8 ff fc 	sub	r8,r9,-4
800135c0:	51 08       	stdsp	sp[0x40],r8
800135c2:	72 09       	ld.w	r9,r9[0x0]
800135c4:	33 08       	mov	r8,48
800135c6:	fb 68 06 b8 	st.b	sp[1720],r8
800135ca:	37 88       	mov	r8,120
800135cc:	30 0e       	mov	lr,0
800135ce:	fb 68 06 b9 	st.b	sp[1721],r8
800135d2:	fe cc ac 92 	sub	r12,pc,-21358
800135d6:	50 19       	stdsp	sp[0x4],r9
800135d8:	a1 b5       	sbr	r5,0x1
800135da:	50 0e       	stdsp	sp[0x0],lr
800135dc:	50 dc       	stdsp	sp[0x34],r12
800135de:	30 28       	mov	r8,2
800135e0:	37 80       	mov	r0,120
800135e2:	e0 8f 02 a3 	bral	80013b28 <_vfprintf_r+0x1538>
800135e6:	50 a7       	stdsp	sp[0x28],r7
800135e8:	50 80       	stdsp	sp[0x20],r0
800135ea:	10 90       	mov	r0,r8
800135ec:	30 08       	mov	r8,0
800135ee:	fb 68 06 bb 	st.b	sp[1723],r8
800135f2:	0c 97       	mov	r7,r6
800135f4:	04 94       	mov	r4,r2
800135f6:	06 96       	mov	r6,r3
800135f8:	02 92       	mov	r2,r1
800135fa:	40 93       	lddsp	r3,sp[0x24]
800135fc:	40 41       	lddsp	r1,sp[0x10]
800135fe:	0e 99       	mov	r9,r7
80013600:	fa f8 06 b4 	ld.w	r8,sp[1716]
80013604:	40 3b       	lddsp	r11,sp[0xc]
80013606:	58 0b       	cp.w	r11,0
80013608:	c1 d0       	breq	80013642 <_vfprintf_r+0x1052>
8001360a:	10 36       	cp.w	r6,r8
8001360c:	c0 64       	brge	80013618 <_vfprintf_r+0x1028>
8001360e:	fa ca f9 44 	sub	r10,sp,-1724
80013612:	f4 06 00 36 	add	r6,r10,r6<<0x3
80013616:	c1 d8       	rjmp	80013650 <_vfprintf_r+0x1060>
80013618:	fa c8 f9 50 	sub	r8,sp,-1712
8001361c:	1a d8       	st.w	--sp,r8
8001361e:	fa c8 fa b8 	sub	r8,sp,-1352
80013622:	1a d8       	st.w	--sp,r8
80013624:	fa c8 fb b4 	sub	r8,sp,-1100
80013628:	0c 9b       	mov	r11,r6
8001362a:	1a d8       	st.w	--sp,r8
8001362c:	04 9a       	mov	r10,r2
8001362e:	fa c8 f9 40 	sub	r8,sp,-1728
80013632:	fa c9 ff b4 	sub	r9,sp,-76
80013636:	08 9c       	mov	r12,r4
80013638:	fe b0 f6 44 	rcall	800122c0 <get_arg>
8001363c:	2f dd       	sub	sp,-12
8001363e:	78 06       	ld.w	r6,r12[0x0]
80013640:	c2 08       	rjmp	80013680 <_vfprintf_r+0x1090>
80013642:	2f f7       	sub	r7,-1
80013644:	10 39       	cp.w	r9,r8
80013646:	c0 84       	brge	80013656 <_vfprintf_r+0x1066>
80013648:	fa c9 f9 44 	sub	r9,sp,-1724
8001364c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80013650:	ec f6 fd 88 	ld.w	r6,r6[-632]
80013654:	c1 68       	rjmp	80013680 <_vfprintf_r+0x1090>
80013656:	41 09       	lddsp	r9,sp[0x40]
80013658:	59 f8       	cp.w	r8,31
8001365a:	e0 89 00 10 	brgt	8001367a <_vfprintf_r+0x108a>
8001365e:	f2 ca ff fc 	sub	r10,r9,-4
80013662:	51 0a       	stdsp	sp[0x40],r10
80013664:	72 06       	ld.w	r6,r9[0x0]
80013666:	fa ce f9 44 	sub	lr,sp,-1724
8001366a:	fc 08 00 39 	add	r9,lr,r8<<0x3
8001366e:	f3 46 fd 88 	st.w	r9[-632],r6
80013672:	2f f8       	sub	r8,-1
80013674:	fb 48 06 b4 	st.w	sp[1716],r8
80013678:	c0 48       	rjmp	80013680 <_vfprintf_r+0x1090>
8001367a:	72 06       	ld.w	r6,r9[0x0]
8001367c:	2f c9       	sub	r9,-4
8001367e:	51 09       	stdsp	sp[0x40],r9
80013680:	40 2c       	lddsp	r12,sp[0x8]
80013682:	58 0c       	cp.w	r12,0
80013684:	c1 05       	brlt	800136a4 <_vfprintf_r+0x10b4>
80013686:	18 9a       	mov	r10,r12
80013688:	30 0b       	mov	r11,0
8001368a:	0c 9c       	mov	r12,r6
8001368c:	e0 a0 12 40 	rcall	80015b0c <memchr>
80013690:	e0 80 02 df 	breq	80013c4e <_vfprintf_r+0x165e>
80013694:	f8 06 01 02 	sub	r2,r12,r6
80013698:	40 2b       	lddsp	r11,sp[0x8]
8001369a:	16 32       	cp.w	r2,r11
8001369c:	e0 89 02 d9 	brgt	80013c4e <_vfprintf_r+0x165e>
800136a0:	e0 8f 02 d4 	bral	80013c48 <_vfprintf_r+0x1658>
800136a4:	30 0a       	mov	r10,0
800136a6:	0c 9c       	mov	r12,r6
800136a8:	50 2a       	stdsp	sp[0x8],r10
800136aa:	fe b0 e8 8d 	rcall	800107c4 <strlen>
800136ae:	18 92       	mov	r2,r12
800136b0:	e0 8f 02 d2 	bral	80013c54 <_vfprintf_r+0x1664>
800136b4:	50 a7       	stdsp	sp[0x28],r7
800136b6:	50 80       	stdsp	sp[0x20],r0
800136b8:	0c 97       	mov	r7,r6
800136ba:	04 94       	mov	r4,r2
800136bc:	06 96       	mov	r6,r3
800136be:	02 92       	mov	r2,r1
800136c0:	40 93       	lddsp	r3,sp[0x24]
800136c2:	10 90       	mov	r0,r8
800136c4:	40 41       	lddsp	r1,sp[0x10]
800136c6:	a5 a5       	sbr	r5,0x4
800136c8:	c0 a8       	rjmp	800136dc <_vfprintf_r+0x10ec>
800136ca:	50 a7       	stdsp	sp[0x28],r7
800136cc:	50 80       	stdsp	sp[0x20],r0
800136ce:	0c 97       	mov	r7,r6
800136d0:	04 94       	mov	r4,r2
800136d2:	06 96       	mov	r6,r3
800136d4:	02 92       	mov	r2,r1
800136d6:	40 93       	lddsp	r3,sp[0x24]
800136d8:	10 90       	mov	r0,r8
800136da:	40 41       	lddsp	r1,sp[0x10]
800136dc:	ed b5 00 05 	bld	r5,0x5
800136e0:	c5 61       	brne	8001378c <_vfprintf_r+0x119c>
800136e2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800136e6:	40 39       	lddsp	r9,sp[0xc]
800136e8:	58 09       	cp.w	r9,0
800136ea:	c2 10       	breq	8001372c <_vfprintf_r+0x113c>
800136ec:	10 36       	cp.w	r6,r8
800136ee:	c0 74       	brge	800136fc <_vfprintf_r+0x110c>
800136f0:	fa c8 f9 44 	sub	r8,sp,-1724
800136f4:	f0 06 00 36 	add	r6,r8,r6<<0x3
800136f8:	c2 38       	rjmp	8001373e <_vfprintf_r+0x114e>
800136fa:	d7 03       	nop
800136fc:	fa c8 f9 50 	sub	r8,sp,-1712
80013700:	1a d8       	st.w	--sp,r8
80013702:	fa c8 fa b8 	sub	r8,sp,-1352
80013706:	1a d8       	st.w	--sp,r8
80013708:	fa c8 fb b4 	sub	r8,sp,-1100
8001370c:	1a d8       	st.w	--sp,r8
8001370e:	fa c8 f9 40 	sub	r8,sp,-1728
80013712:	fa c9 ff b4 	sub	r9,sp,-76
80013716:	04 9a       	mov	r10,r2
80013718:	0c 9b       	mov	r11,r6
8001371a:	08 9c       	mov	r12,r4
8001371c:	fe b0 f5 d2 	rcall	800122c0 <get_arg>
80013720:	2f dd       	sub	sp,-12
80013722:	f8 e8 00 00 	ld.d	r8,r12[0]
80013726:	fa e9 00 00 	st.d	sp[0],r8
8001372a:	c2 e8       	rjmp	80013786 <_vfprintf_r+0x1196>
8001372c:	ee ca ff ff 	sub	r10,r7,-1
80013730:	10 37       	cp.w	r7,r8
80013732:	c0 b4       	brge	80013748 <_vfprintf_r+0x1158>
80013734:	fa c8 f9 44 	sub	r8,sp,-1724
80013738:	14 97       	mov	r7,r10
8001373a:	f0 06 00 36 	add	r6,r8,r6<<0x3
8001373e:	ec ea fd 88 	ld.d	r10,r6[-632]
80013742:	fa eb 00 00 	st.d	sp[0],r10
80013746:	c2 08       	rjmp	80013786 <_vfprintf_r+0x1196>
80013748:	41 09       	lddsp	r9,sp[0x40]
8001374a:	59 f8       	cp.w	r8,31
8001374c:	e0 89 00 16 	brgt	80013778 <_vfprintf_r+0x1188>
80013750:	f2 e6 00 00 	ld.d	r6,r9[0]
80013754:	f2 cb ff f8 	sub	r11,r9,-8
80013758:	fa e7 00 00 	st.d	sp[0],r6
8001375c:	51 0b       	stdsp	sp[0x40],r11
8001375e:	fa c6 f9 44 	sub	r6,sp,-1724
80013762:	ec 08 00 39 	add	r9,r6,r8<<0x3
80013766:	fa e6 00 00 	ld.d	r6,sp[0]
8001376a:	f2 e7 fd 88 	st.d	r9[-632],r6
8001376e:	2f f8       	sub	r8,-1
80013770:	14 97       	mov	r7,r10
80013772:	fb 48 06 b4 	st.w	sp[1716],r8
80013776:	c0 88       	rjmp	80013786 <_vfprintf_r+0x1196>
80013778:	f2 e6 00 00 	ld.d	r6,r9[0]
8001377c:	2f 89       	sub	r9,-8
8001377e:	fa e7 00 00 	st.d	sp[0],r6
80013782:	51 09       	stdsp	sp[0x40],r9
80013784:	14 97       	mov	r7,r10
80013786:	30 18       	mov	r8,1
80013788:	e0 8f 01 d0 	bral	80013b28 <_vfprintf_r+0x1538>
8001378c:	ed b5 00 04 	bld	r5,0x4
80013790:	c1 61       	brne	800137bc <_vfprintf_r+0x11cc>
80013792:	fa f8 06 b4 	ld.w	r8,sp[1716]
80013796:	40 3e       	lddsp	lr,sp[0xc]
80013798:	58 0e       	cp.w	lr,0
8001379a:	c0 80       	breq	800137aa <_vfprintf_r+0x11ba>
8001379c:	10 36       	cp.w	r6,r8
8001379e:	c6 74       	brge	8001386c <_vfprintf_r+0x127c>
800137a0:	fa cc f9 44 	sub	r12,sp,-1724
800137a4:	f8 06 00 36 	add	r6,r12,r6<<0x3
800137a8:	c8 08       	rjmp	800138a8 <_vfprintf_r+0x12b8>
800137aa:	ee ca ff ff 	sub	r10,r7,-1
800137ae:	10 37       	cp.w	r7,r8
800137b0:	c7 f4       	brge	800138ae <_vfprintf_r+0x12be>
800137b2:	fa cb f9 44 	sub	r11,sp,-1724
800137b6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800137ba:	c7 68       	rjmp	800138a6 <_vfprintf_r+0x12b6>
800137bc:	ed b5 00 06 	bld	r5,0x6
800137c0:	c4 a1       	brne	80013854 <_vfprintf_r+0x1264>
800137c2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800137c6:	40 3c       	lddsp	r12,sp[0xc]
800137c8:	58 0c       	cp.w	r12,0
800137ca:	c1 d0       	breq	80013804 <_vfprintf_r+0x1214>
800137cc:	10 36       	cp.w	r6,r8
800137ce:	c0 64       	brge	800137da <_vfprintf_r+0x11ea>
800137d0:	fa cb f9 44 	sub	r11,sp,-1724
800137d4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800137d8:	c1 f8       	rjmp	80013816 <_vfprintf_r+0x1226>
800137da:	fa c8 f9 50 	sub	r8,sp,-1712
800137de:	1a d8       	st.w	--sp,r8
800137e0:	fa c8 fa b8 	sub	r8,sp,-1352
800137e4:	1a d8       	st.w	--sp,r8
800137e6:	fa c8 fb b4 	sub	r8,sp,-1100
800137ea:	1a d8       	st.w	--sp,r8
800137ec:	fa c8 f9 40 	sub	r8,sp,-1728
800137f0:	fa c9 ff b4 	sub	r9,sp,-76
800137f4:	04 9a       	mov	r10,r2
800137f6:	0c 9b       	mov	r11,r6
800137f8:	08 9c       	mov	r12,r4
800137fa:	fe b0 f5 63 	rcall	800122c0 <get_arg>
800137fe:	2f dd       	sub	sp,-12
80013800:	98 18       	ld.sh	r8,r12[0x2]
80013802:	c2 68       	rjmp	8001384e <_vfprintf_r+0x125e>
80013804:	ee ca ff ff 	sub	r10,r7,-1
80013808:	10 37       	cp.w	r7,r8
8001380a:	c0 94       	brge	8001381c <_vfprintf_r+0x122c>
8001380c:	fa c9 f9 44 	sub	r9,sp,-1724
80013810:	14 97       	mov	r7,r10
80013812:	f2 06 00 36 	add	r6,r9,r6<<0x3
80013816:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8001381a:	c1 a8       	rjmp	8001384e <_vfprintf_r+0x125e>
8001381c:	41 09       	lddsp	r9,sp[0x40]
8001381e:	59 f8       	cp.w	r8,31
80013820:	e0 89 00 13 	brgt	80013846 <_vfprintf_r+0x1256>
80013824:	f2 cb ff fc 	sub	r11,r9,-4
80013828:	51 0b       	stdsp	sp[0x40],r11
8001382a:	72 09       	ld.w	r9,r9[0x0]
8001382c:	fa c6 f9 44 	sub	r6,sp,-1724
80013830:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80013834:	2f f8       	sub	r8,-1
80013836:	f7 49 fd 88 	st.w	r11[-632],r9
8001383a:	fb 48 06 b4 	st.w	sp[1716],r8
8001383e:	14 97       	mov	r7,r10
80013840:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80013844:	c0 58       	rjmp	8001384e <_vfprintf_r+0x125e>
80013846:	92 18       	ld.sh	r8,r9[0x2]
80013848:	14 97       	mov	r7,r10
8001384a:	2f c9       	sub	r9,-4
8001384c:	51 09       	stdsp	sp[0x40],r9
8001384e:	5c 78       	castu.h	r8
80013850:	50 18       	stdsp	sp[0x4],r8
80013852:	c4 68       	rjmp	800138de <_vfprintf_r+0x12ee>
80013854:	fa f8 06 b4 	ld.w	r8,sp[1716]
80013858:	40 3c       	lddsp	r12,sp[0xc]
8001385a:	58 0c       	cp.w	r12,0
8001385c:	c1 d0       	breq	80013896 <_vfprintf_r+0x12a6>
8001385e:	10 36       	cp.w	r6,r8
80013860:	c0 64       	brge	8001386c <_vfprintf_r+0x127c>
80013862:	fa cb f9 44 	sub	r11,sp,-1724
80013866:	f6 06 00 36 	add	r6,r11,r6<<0x3
8001386a:	c1 f8       	rjmp	800138a8 <_vfprintf_r+0x12b8>
8001386c:	fa c8 f9 50 	sub	r8,sp,-1712
80013870:	1a d8       	st.w	--sp,r8
80013872:	fa c8 fa b8 	sub	r8,sp,-1352
80013876:	0c 9b       	mov	r11,r6
80013878:	1a d8       	st.w	--sp,r8
8001387a:	fa c8 fb b4 	sub	r8,sp,-1100
8001387e:	04 9a       	mov	r10,r2
80013880:	1a d8       	st.w	--sp,r8
80013882:	08 9c       	mov	r12,r4
80013884:	fa c8 f9 40 	sub	r8,sp,-1728
80013888:	fa c9 ff b4 	sub	r9,sp,-76
8001388c:	fe b0 f5 1a 	rcall	800122c0 <get_arg>
80013890:	2f dd       	sub	sp,-12
80013892:	78 0b       	ld.w	r11,r12[0x0]
80013894:	c2 48       	rjmp	800138dc <_vfprintf_r+0x12ec>
80013896:	ee ca ff ff 	sub	r10,r7,-1
8001389a:	10 37       	cp.w	r7,r8
8001389c:	c0 94       	brge	800138ae <_vfprintf_r+0x12be>
8001389e:	fa c9 f9 44 	sub	r9,sp,-1724
800138a2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800138a6:	14 97       	mov	r7,r10
800138a8:	ec fb fd 88 	ld.w	r11,r6[-632]
800138ac:	c1 88       	rjmp	800138dc <_vfprintf_r+0x12ec>
800138ae:	41 09       	lddsp	r9,sp[0x40]
800138b0:	59 f8       	cp.w	r8,31
800138b2:	e0 89 00 11 	brgt	800138d4 <_vfprintf_r+0x12e4>
800138b6:	f2 cb ff fc 	sub	r11,r9,-4
800138ba:	51 0b       	stdsp	sp[0x40],r11
800138bc:	fa c6 f9 44 	sub	r6,sp,-1724
800138c0:	72 0b       	ld.w	r11,r9[0x0]
800138c2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800138c6:	f3 4b fd 88 	st.w	r9[-632],r11
800138ca:	2f f8       	sub	r8,-1
800138cc:	14 97       	mov	r7,r10
800138ce:	fb 48 06 b4 	st.w	sp[1716],r8
800138d2:	c0 58       	rjmp	800138dc <_vfprintf_r+0x12ec>
800138d4:	72 0b       	ld.w	r11,r9[0x0]
800138d6:	14 97       	mov	r7,r10
800138d8:	2f c9       	sub	r9,-4
800138da:	51 09       	stdsp	sp[0x40],r9
800138dc:	50 1b       	stdsp	sp[0x4],r11
800138de:	30 0e       	mov	lr,0
800138e0:	30 18       	mov	r8,1
800138e2:	50 0e       	stdsp	sp[0x0],lr
800138e4:	c2 29       	rjmp	80013b28 <_vfprintf_r+0x1538>
800138e6:	50 a7       	stdsp	sp[0x28],r7
800138e8:	50 80       	stdsp	sp[0x20],r0
800138ea:	0c 97       	mov	r7,r6
800138ec:	04 94       	mov	r4,r2
800138ee:	06 96       	mov	r6,r3
800138f0:	02 92       	mov	r2,r1
800138f2:	fe cc af b2 	sub	r12,pc,-20558
800138f6:	40 93       	lddsp	r3,sp[0x24]
800138f8:	10 90       	mov	r0,r8
800138fa:	40 41       	lddsp	r1,sp[0x10]
800138fc:	50 dc       	stdsp	sp[0x34],r12
800138fe:	ed b5 00 05 	bld	r5,0x5
80013902:	c5 51       	brne	800139ac <_vfprintf_r+0x13bc>
80013904:	fa f8 06 b4 	ld.w	r8,sp[1716]
80013908:	40 3b       	lddsp	r11,sp[0xc]
8001390a:	58 0b       	cp.w	r11,0
8001390c:	c2 20       	breq	80013950 <_vfprintf_r+0x1360>
8001390e:	10 36       	cp.w	r6,r8
80013910:	c0 a4       	brge	80013924 <_vfprintf_r+0x1334>
80013912:	fa ca f9 44 	sub	r10,sp,-1724
80013916:	f4 06 00 36 	add	r6,r10,r6<<0x3
8001391a:	ec e8 fd 88 	ld.d	r8,r6[-632]
8001391e:	fa e9 00 00 	st.d	sp[0],r8
80013922:	cf 28       	rjmp	80013b06 <_vfprintf_r+0x1516>
80013924:	fa c8 f9 50 	sub	r8,sp,-1712
80013928:	1a d8       	st.w	--sp,r8
8001392a:	fa c8 fa b8 	sub	r8,sp,-1352
8001392e:	04 9a       	mov	r10,r2
80013930:	1a d8       	st.w	--sp,r8
80013932:	0c 9b       	mov	r11,r6
80013934:	fa c8 fb b4 	sub	r8,sp,-1100
80013938:	08 9c       	mov	r12,r4
8001393a:	1a d8       	st.w	--sp,r8
8001393c:	fa c8 f9 40 	sub	r8,sp,-1728
80013940:	fa c9 ff b4 	sub	r9,sp,-76
80013944:	fe b0 f4 be 	rcall	800122c0 <get_arg>
80013948:	2f dd       	sub	sp,-12
8001394a:	f8 ea 00 00 	ld.d	r10,r12[0]
8001394e:	c0 c8       	rjmp	80013966 <_vfprintf_r+0x1376>
80013950:	ee ca ff ff 	sub	r10,r7,-1
80013954:	10 37       	cp.w	r7,r8
80013956:	c0 b4       	brge	8001396c <_vfprintf_r+0x137c>
80013958:	fa c9 f9 44 	sub	r9,sp,-1724
8001395c:	14 97       	mov	r7,r10
8001395e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80013962:	ec ea fd 88 	ld.d	r10,r6[-632]
80013966:	fa eb 00 00 	st.d	sp[0],r10
8001396a:	cc e8       	rjmp	80013b06 <_vfprintf_r+0x1516>
8001396c:	41 09       	lddsp	r9,sp[0x40]
8001396e:	59 f8       	cp.w	r8,31
80013970:	e0 89 00 16 	brgt	8001399c <_vfprintf_r+0x13ac>
80013974:	f2 e6 00 00 	ld.d	r6,r9[0]
80013978:	f2 cb ff f8 	sub	r11,r9,-8
8001397c:	fa e7 00 00 	st.d	sp[0],r6
80013980:	51 0b       	stdsp	sp[0x40],r11
80013982:	fa c6 f9 44 	sub	r6,sp,-1724
80013986:	ec 08 00 39 	add	r9,r6,r8<<0x3
8001398a:	fa e6 00 00 	ld.d	r6,sp[0]
8001398e:	f2 e7 fd 88 	st.d	r9[-632],r6
80013992:	2f f8       	sub	r8,-1
80013994:	14 97       	mov	r7,r10
80013996:	fb 48 06 b4 	st.w	sp[1716],r8
8001399a:	cb 68       	rjmp	80013b06 <_vfprintf_r+0x1516>
8001399c:	f2 e6 00 00 	ld.d	r6,r9[0]
800139a0:	2f 89       	sub	r9,-8
800139a2:	fa e7 00 00 	st.d	sp[0],r6
800139a6:	51 09       	stdsp	sp[0x40],r9
800139a8:	14 97       	mov	r7,r10
800139aa:	ca e8       	rjmp	80013b06 <_vfprintf_r+0x1516>
800139ac:	ed b5 00 04 	bld	r5,0x4
800139b0:	c1 71       	brne	800139de <_vfprintf_r+0x13ee>
800139b2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800139b6:	40 3e       	lddsp	lr,sp[0xc]
800139b8:	58 0e       	cp.w	lr,0
800139ba:	c0 80       	breq	800139ca <_vfprintf_r+0x13da>
800139bc:	10 36       	cp.w	r6,r8
800139be:	c6 94       	brge	80013a90 <_vfprintf_r+0x14a0>
800139c0:	fa cc f9 44 	sub	r12,sp,-1724
800139c4:	f8 06 00 36 	add	r6,r12,r6<<0x3
800139c8:	c8 28       	rjmp	80013acc <_vfprintf_r+0x14dc>
800139ca:	ee ca ff ff 	sub	r10,r7,-1
800139ce:	10 37       	cp.w	r7,r8
800139d0:	e0 84 00 81 	brge	80013ad2 <_vfprintf_r+0x14e2>
800139d4:	fa cb f9 44 	sub	r11,sp,-1724
800139d8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800139dc:	c7 78       	rjmp	80013aca <_vfprintf_r+0x14da>
800139de:	ed b5 00 06 	bld	r5,0x6
800139e2:	c4 b1       	brne	80013a78 <_vfprintf_r+0x1488>
800139e4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800139e8:	40 3c       	lddsp	r12,sp[0xc]
800139ea:	58 0c       	cp.w	r12,0
800139ec:	c1 d0       	breq	80013a26 <_vfprintf_r+0x1436>
800139ee:	10 36       	cp.w	r6,r8
800139f0:	c0 64       	brge	800139fc <_vfprintf_r+0x140c>
800139f2:	fa cb f9 44 	sub	r11,sp,-1724
800139f6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800139fa:	c1 f8       	rjmp	80013a38 <_vfprintf_r+0x1448>
800139fc:	fa c8 f9 50 	sub	r8,sp,-1712
80013a00:	1a d8       	st.w	--sp,r8
80013a02:	fa c8 fa b8 	sub	r8,sp,-1352
80013a06:	1a d8       	st.w	--sp,r8
80013a08:	fa c8 fb b4 	sub	r8,sp,-1100
80013a0c:	1a d8       	st.w	--sp,r8
80013a0e:	fa c8 f9 40 	sub	r8,sp,-1728
80013a12:	fa c9 ff b4 	sub	r9,sp,-76
80013a16:	04 9a       	mov	r10,r2
80013a18:	0c 9b       	mov	r11,r6
80013a1a:	08 9c       	mov	r12,r4
80013a1c:	fe b0 f4 52 	rcall	800122c0 <get_arg>
80013a20:	2f dd       	sub	sp,-12
80013a22:	98 18       	ld.sh	r8,r12[0x2]
80013a24:	c2 78       	rjmp	80013a72 <_vfprintf_r+0x1482>
80013a26:	ee ca ff ff 	sub	r10,r7,-1
80013a2a:	10 37       	cp.w	r7,r8
80013a2c:	c0 a4       	brge	80013a40 <_vfprintf_r+0x1450>
80013a2e:	fa c9 f9 44 	sub	r9,sp,-1724
80013a32:	14 97       	mov	r7,r10
80013a34:	f2 06 00 36 	add	r6,r9,r6<<0x3
80013a38:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80013a3c:	c1 b8       	rjmp	80013a72 <_vfprintf_r+0x1482>
80013a3e:	d7 03       	nop
80013a40:	41 09       	lddsp	r9,sp[0x40]
80013a42:	59 f8       	cp.w	r8,31
80013a44:	e0 89 00 13 	brgt	80013a6a <_vfprintf_r+0x147a>
80013a48:	f2 cb ff fc 	sub	r11,r9,-4
80013a4c:	51 0b       	stdsp	sp[0x40],r11
80013a4e:	72 09       	ld.w	r9,r9[0x0]
80013a50:	fa c6 f9 44 	sub	r6,sp,-1724
80013a54:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80013a58:	2f f8       	sub	r8,-1
80013a5a:	f7 49 fd 88 	st.w	r11[-632],r9
80013a5e:	fb 48 06 b4 	st.w	sp[1716],r8
80013a62:	14 97       	mov	r7,r10
80013a64:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80013a68:	c0 58       	rjmp	80013a72 <_vfprintf_r+0x1482>
80013a6a:	92 18       	ld.sh	r8,r9[0x2]
80013a6c:	14 97       	mov	r7,r10
80013a6e:	2f c9       	sub	r9,-4
80013a70:	51 09       	stdsp	sp[0x40],r9
80013a72:	5c 78       	castu.h	r8
80013a74:	50 18       	stdsp	sp[0x4],r8
80013a76:	c4 68       	rjmp	80013b02 <_vfprintf_r+0x1512>
80013a78:	fa f8 06 b4 	ld.w	r8,sp[1716]
80013a7c:	40 3c       	lddsp	r12,sp[0xc]
80013a7e:	58 0c       	cp.w	r12,0
80013a80:	c1 d0       	breq	80013aba <_vfprintf_r+0x14ca>
80013a82:	10 36       	cp.w	r6,r8
80013a84:	c0 64       	brge	80013a90 <_vfprintf_r+0x14a0>
80013a86:	fa cb f9 44 	sub	r11,sp,-1724
80013a8a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80013a8e:	c1 f8       	rjmp	80013acc <_vfprintf_r+0x14dc>
80013a90:	fa c8 f9 50 	sub	r8,sp,-1712
80013a94:	1a d8       	st.w	--sp,r8
80013a96:	fa c8 fa b8 	sub	r8,sp,-1352
80013a9a:	0c 9b       	mov	r11,r6
80013a9c:	1a d8       	st.w	--sp,r8
80013a9e:	fa c8 fb b4 	sub	r8,sp,-1100
80013aa2:	04 9a       	mov	r10,r2
80013aa4:	1a d8       	st.w	--sp,r8
80013aa6:	08 9c       	mov	r12,r4
80013aa8:	fa c8 f9 40 	sub	r8,sp,-1728
80013aac:	fa c9 ff b4 	sub	r9,sp,-76
80013ab0:	fe b0 f4 08 	rcall	800122c0 <get_arg>
80013ab4:	2f dd       	sub	sp,-12
80013ab6:	78 0b       	ld.w	r11,r12[0x0]
80013ab8:	c2 48       	rjmp	80013b00 <_vfprintf_r+0x1510>
80013aba:	ee ca ff ff 	sub	r10,r7,-1
80013abe:	10 37       	cp.w	r7,r8
80013ac0:	c0 94       	brge	80013ad2 <_vfprintf_r+0x14e2>
80013ac2:	fa c9 f9 44 	sub	r9,sp,-1724
80013ac6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80013aca:	14 97       	mov	r7,r10
80013acc:	ec fb fd 88 	ld.w	r11,r6[-632]
80013ad0:	c1 88       	rjmp	80013b00 <_vfprintf_r+0x1510>
80013ad2:	41 09       	lddsp	r9,sp[0x40]
80013ad4:	59 f8       	cp.w	r8,31
80013ad6:	e0 89 00 11 	brgt	80013af8 <_vfprintf_r+0x1508>
80013ada:	f2 cb ff fc 	sub	r11,r9,-4
80013ade:	51 0b       	stdsp	sp[0x40],r11
80013ae0:	fa c6 f9 44 	sub	r6,sp,-1724
80013ae4:	72 0b       	ld.w	r11,r9[0x0]
80013ae6:	ec 08 00 39 	add	r9,r6,r8<<0x3
80013aea:	f3 4b fd 88 	st.w	r9[-632],r11
80013aee:	2f f8       	sub	r8,-1
80013af0:	14 97       	mov	r7,r10
80013af2:	fb 48 06 b4 	st.w	sp[1716],r8
80013af6:	c0 58       	rjmp	80013b00 <_vfprintf_r+0x1510>
80013af8:	72 0b       	ld.w	r11,r9[0x0]
80013afa:	14 97       	mov	r7,r10
80013afc:	2f c9       	sub	r9,-4
80013afe:	51 09       	stdsp	sp[0x40],r9
80013b00:	50 1b       	stdsp	sp[0x4],r11
80013b02:	30 0e       	mov	lr,0
80013b04:	50 0e       	stdsp	sp[0x0],lr
80013b06:	40 08       	lddsp	r8,sp[0x0]
80013b08:	40 1c       	lddsp	r12,sp[0x4]
80013b0a:	18 48       	or	r8,r12
80013b0c:	5f 19       	srne	r9
80013b0e:	0a 98       	mov	r8,r5
80013b10:	eb e9 00 09 	and	r9,r5,r9
80013b14:	a1 b8       	sbr	r8,0x1
80013b16:	58 09       	cp.w	r9,0
80013b18:	c0 70       	breq	80013b26 <_vfprintf_r+0x1536>
80013b1a:	10 95       	mov	r5,r8
80013b1c:	fb 60 06 b9 	st.b	sp[1721],r0
80013b20:	33 08       	mov	r8,48
80013b22:	fb 68 06 b8 	st.b	sp[1720],r8
80013b26:	30 28       	mov	r8,2
80013b28:	30 09       	mov	r9,0
80013b2a:	fb 69 06 bb 	st.b	sp[1723],r9
80013b2e:	0a 99       	mov	r9,r5
80013b30:	a7 d9       	cbr	r9,0x7
80013b32:	40 2b       	lddsp	r11,sp[0x8]
80013b34:	40 16       	lddsp	r6,sp[0x4]
80013b36:	58 0b       	cp.w	r11,0
80013b38:	5f 1a       	srne	r10
80013b3a:	f2 05 17 40 	movge	r5,r9
80013b3e:	fa c2 f9 78 	sub	r2,sp,-1672
80013b42:	40 09       	lddsp	r9,sp[0x0]
80013b44:	0c 49       	or	r9,r6
80013b46:	5f 19       	srne	r9
80013b48:	f5 e9 10 09 	or	r9,r10,r9
80013b4c:	c5 c0       	breq	80013c04 <_vfprintf_r+0x1614>
80013b4e:	30 19       	mov	r9,1
80013b50:	f2 08 18 00 	cp.b	r8,r9
80013b54:	c0 60       	breq	80013b60 <_vfprintf_r+0x1570>
80013b56:	30 29       	mov	r9,2
80013b58:	f2 08 18 00 	cp.b	r8,r9
80013b5c:	c0 41       	brne	80013b64 <_vfprintf_r+0x1574>
80013b5e:	c3 c8       	rjmp	80013bd6 <_vfprintf_r+0x15e6>
80013b60:	04 96       	mov	r6,r2
80013b62:	c3 08       	rjmp	80013bc2 <_vfprintf_r+0x15d2>
80013b64:	04 96       	mov	r6,r2
80013b66:	fa e8 00 00 	ld.d	r8,sp[0]
80013b6a:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80013b6e:	2d 0a       	sub	r10,-48
80013b70:	0c fa       	st.b	--r6,r10
80013b72:	f0 0b 16 03 	lsr	r11,r8,0x3
80013b76:	f2 0c 16 03 	lsr	r12,r9,0x3
80013b7a:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80013b7e:	18 99       	mov	r9,r12
80013b80:	16 98       	mov	r8,r11
80013b82:	58 08       	cp.w	r8,0
80013b84:	5c 29       	cpc	r9
80013b86:	cf 21       	brne	80013b6a <_vfprintf_r+0x157a>
80013b88:	fa e9 00 00 	st.d	sp[0],r8
80013b8c:	ed b5 00 00 	bld	r5,0x0
80013b90:	c4 51       	brne	80013c1a <_vfprintf_r+0x162a>
80013b92:	33 09       	mov	r9,48
80013b94:	f2 0a 18 00 	cp.b	r10,r9
80013b98:	c4 10       	breq	80013c1a <_vfprintf_r+0x162a>
80013b9a:	0c f9       	st.b	--r6,r9
80013b9c:	c3 f8       	rjmp	80013c1a <_vfprintf_r+0x162a>
80013b9e:	fa ea 00 00 	ld.d	r10,sp[0]
80013ba2:	30 a8       	mov	r8,10
80013ba4:	30 09       	mov	r9,0
80013ba6:	e0 a0 16 5d 	rcall	80016860 <__avr32_umod64>
80013baa:	30 a8       	mov	r8,10
80013bac:	2d 0a       	sub	r10,-48
80013bae:	30 09       	mov	r9,0
80013bb0:	ac 8a       	st.b	r6[0x0],r10
80013bb2:	fa ea 00 00 	ld.d	r10,sp[0]
80013bb6:	fe b0 e0 42 	rcall	8000fc3a <__avr32_udiv64>
80013bba:	16 99       	mov	r9,r11
80013bbc:	14 98       	mov	r8,r10
80013bbe:	fa e9 00 00 	st.d	sp[0],r8
80013bc2:	20 16       	sub	r6,1
80013bc4:	fa ea 00 00 	ld.d	r10,sp[0]
80013bc8:	58 9a       	cp.w	r10,9
80013bca:	5c 2b       	cpc	r11
80013bcc:	fe 9b ff e9 	brhi	80013b9e <_vfprintf_r+0x15ae>
80013bd0:	1b f8       	ld.ub	r8,sp[0x7]
80013bd2:	2d 08       	sub	r8,-48
80013bd4:	c2 08       	rjmp	80013c14 <_vfprintf_r+0x1624>
80013bd6:	04 96       	mov	r6,r2
80013bd8:	fa e8 00 00 	ld.d	r8,sp[0]
80013bdc:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80013be0:	40 de       	lddsp	lr,sp[0x34]
80013be2:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80013be6:	0c fa       	st.b	--r6,r10
80013be8:	f2 0b 16 04 	lsr	r11,r9,0x4
80013bec:	f0 0a 16 04 	lsr	r10,r8,0x4
80013bf0:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80013bf4:	16 99       	mov	r9,r11
80013bf6:	14 98       	mov	r8,r10
80013bf8:	58 08       	cp.w	r8,0
80013bfa:	5c 29       	cpc	r9
80013bfc:	cf 01       	brne	80013bdc <_vfprintf_r+0x15ec>
80013bfe:	fa e9 00 00 	st.d	sp[0],r8
80013c02:	c0 c8       	rjmp	80013c1a <_vfprintf_r+0x162a>
80013c04:	58 08       	cp.w	r8,0
80013c06:	c0 91       	brne	80013c18 <_vfprintf_r+0x1628>
80013c08:	ed b5 00 00 	bld	r5,0x0
80013c0c:	c0 61       	brne	80013c18 <_vfprintf_r+0x1628>
80013c0e:	fa c6 f9 79 	sub	r6,sp,-1671
80013c12:	33 08       	mov	r8,48
80013c14:	ac 88       	st.b	r6[0x0],r8
80013c16:	c0 28       	rjmp	80013c1a <_vfprintf_r+0x162a>
80013c18:	04 96       	mov	r6,r2
80013c1a:	0c 12       	sub	r2,r6
80013c1c:	c1 c8       	rjmp	80013c54 <_vfprintf_r+0x1664>
80013c1e:	50 a7       	stdsp	sp[0x28],r7
80013c20:	50 80       	stdsp	sp[0x20],r0
80013c22:	40 93       	lddsp	r3,sp[0x24]
80013c24:	0c 97       	mov	r7,r6
80013c26:	10 90       	mov	r0,r8
80013c28:	04 94       	mov	r4,r2
80013c2a:	40 41       	lddsp	r1,sp[0x10]
80013c2c:	58 08       	cp.w	r8,0
80013c2e:	e0 80 04 4f 	breq	800144cc <_vfprintf_r+0x1edc>
80013c32:	fb 68 06 60 	st.b	sp[1632],r8
80013c36:	30 0c       	mov	r12,0
80013c38:	30 08       	mov	r8,0
80013c3a:	30 12       	mov	r2,1
80013c3c:	fb 68 06 bb 	st.b	sp[1723],r8
80013c40:	50 2c       	stdsp	sp[0x8],r12
80013c42:	fa c6 f9 a0 	sub	r6,sp,-1632
80013c46:	c0 78       	rjmp	80013c54 <_vfprintf_r+0x1664>
80013c48:	30 0b       	mov	r11,0
80013c4a:	50 2b       	stdsp	sp[0x8],r11
80013c4c:	c0 48       	rjmp	80013c54 <_vfprintf_r+0x1664>
80013c4e:	40 22       	lddsp	r2,sp[0x8]
80013c50:	30 0a       	mov	r10,0
80013c52:	50 2a       	stdsp	sp[0x8],r10
80013c54:	40 29       	lddsp	r9,sp[0x8]
80013c56:	e4 09 0c 49 	max	r9,r2,r9
80013c5a:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80013c5e:	50 39       	stdsp	sp[0xc],r9
80013c60:	0a 9e       	mov	lr,r5
80013c62:	30 09       	mov	r9,0
80013c64:	e2 1e 00 02 	andl	lr,0x2,COH
80013c68:	f2 08 18 00 	cp.b	r8,r9
80013c6c:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80013c70:	f7 b8 01 ff 	subne	r8,-1
80013c74:	fb f8 1a 03 	st.wne	sp[0xc],r8
80013c78:	0a 9b       	mov	r11,r5
80013c7a:	58 0e       	cp.w	lr,0
80013c7c:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80013c80:	f7 bc 01 fe 	subne	r12,-2
80013c84:	fb fc 1a 03 	st.wne	sp[0xc],r12
80013c88:	e2 1b 00 84 	andl	r11,0x84,COH
80013c8c:	50 fe       	stdsp	sp[0x3c],lr
80013c8e:	50 9b       	stdsp	sp[0x24],r11
80013c90:	c4 71       	brne	80013d1e <_vfprintf_r+0x172e>
80013c92:	40 8a       	lddsp	r10,sp[0x20]
80013c94:	40 39       	lddsp	r9,sp[0xc]
80013c96:	12 1a       	sub	r10,r9
80013c98:	50 4a       	stdsp	sp[0x10],r10
80013c9a:	58 0a       	cp.w	r10,0
80013c9c:	e0 89 00 20 	brgt	80013cdc <_vfprintf_r+0x16ec>
80013ca0:	c3 f8       	rjmp	80013d1e <_vfprintf_r+0x172e>
80013ca2:	2f 09       	sub	r9,-16
80013ca4:	2f f8       	sub	r8,-1
80013ca6:	fe ce af b6 	sub	lr,pc,-20554
80013caa:	31 0c       	mov	r12,16
80013cac:	fb 49 06 90 	st.w	sp[1680],r9
80013cb0:	87 0e       	st.w	r3[0x0],lr
80013cb2:	87 1c       	st.w	r3[0x4],r12
80013cb4:	fb 48 06 8c 	st.w	sp[1676],r8
80013cb8:	58 78       	cp.w	r8,7
80013cba:	e0 89 00 04 	brgt	80013cc2 <_vfprintf_r+0x16d2>
80013cbe:	2f 83       	sub	r3,-8
80013cc0:	c0 b8       	rjmp	80013cd6 <_vfprintf_r+0x16e6>
80013cc2:	fa ca f9 78 	sub	r10,sp,-1672
80013cc6:	02 9b       	mov	r11,r1
80013cc8:	08 9c       	mov	r12,r4
80013cca:	fe b0 f4 85 	rcall	800125d4 <__sprint_r>
80013cce:	e0 81 04 10 	brne	800144ee <_vfprintf_r+0x1efe>
80013cd2:	fa c3 f9 e0 	sub	r3,sp,-1568
80013cd6:	40 4b       	lddsp	r11,sp[0x10]
80013cd8:	21 0b       	sub	r11,16
80013cda:	50 4b       	stdsp	sp[0x10],r11
80013cdc:	fa f9 06 90 	ld.w	r9,sp[1680]
80013ce0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80013ce4:	fe ca af f4 	sub	r10,pc,-20492
80013ce8:	40 4e       	lddsp	lr,sp[0x10]
80013cea:	59 0e       	cp.w	lr,16
80013cec:	fe 99 ff db 	brgt	80013ca2 <_vfprintf_r+0x16b2>
80013cf0:	1c 09       	add	r9,lr
80013cf2:	2f f8       	sub	r8,-1
80013cf4:	87 0a       	st.w	r3[0x0],r10
80013cf6:	fb 49 06 90 	st.w	sp[1680],r9
80013cfa:	87 1e       	st.w	r3[0x4],lr
80013cfc:	fb 48 06 8c 	st.w	sp[1676],r8
80013d00:	58 78       	cp.w	r8,7
80013d02:	e0 89 00 04 	brgt	80013d0a <_vfprintf_r+0x171a>
80013d06:	2f 83       	sub	r3,-8
80013d08:	c0 b8       	rjmp	80013d1e <_vfprintf_r+0x172e>
80013d0a:	fa ca f9 78 	sub	r10,sp,-1672
80013d0e:	02 9b       	mov	r11,r1
80013d10:	08 9c       	mov	r12,r4
80013d12:	fe b0 f4 61 	rcall	800125d4 <__sprint_r>
80013d16:	e0 81 03 ec 	brne	800144ee <_vfprintf_r+0x1efe>
80013d1a:	fa c3 f9 e0 	sub	r3,sp,-1568
80013d1e:	30 09       	mov	r9,0
80013d20:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80013d24:	f2 08 18 00 	cp.b	r8,r9
80013d28:	c1 f0       	breq	80013d66 <_vfprintf_r+0x1776>
80013d2a:	fa f8 06 90 	ld.w	r8,sp[1680]
80013d2e:	fa c9 f9 45 	sub	r9,sp,-1723
80013d32:	2f f8       	sub	r8,-1
80013d34:	87 09       	st.w	r3[0x0],r9
80013d36:	fb 48 06 90 	st.w	sp[1680],r8
80013d3a:	30 19       	mov	r9,1
80013d3c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80013d40:	87 19       	st.w	r3[0x4],r9
80013d42:	2f f8       	sub	r8,-1
80013d44:	fb 48 06 8c 	st.w	sp[1676],r8
80013d48:	58 78       	cp.w	r8,7
80013d4a:	e0 89 00 04 	brgt	80013d52 <_vfprintf_r+0x1762>
80013d4e:	2f 83       	sub	r3,-8
80013d50:	c0 b8       	rjmp	80013d66 <_vfprintf_r+0x1776>
80013d52:	fa ca f9 78 	sub	r10,sp,-1672
80013d56:	02 9b       	mov	r11,r1
80013d58:	08 9c       	mov	r12,r4
80013d5a:	fe b0 f4 3d 	rcall	800125d4 <__sprint_r>
80013d5e:	e0 81 03 c8 	brne	800144ee <_vfprintf_r+0x1efe>
80013d62:	fa c3 f9 e0 	sub	r3,sp,-1568
80013d66:	40 fc       	lddsp	r12,sp[0x3c]
80013d68:	58 0c       	cp.w	r12,0
80013d6a:	c1 f0       	breq	80013da8 <_vfprintf_r+0x17b8>
80013d6c:	fa f8 06 90 	ld.w	r8,sp[1680]
80013d70:	fa c9 f9 48 	sub	r9,sp,-1720
80013d74:	2f e8       	sub	r8,-2
80013d76:	87 09       	st.w	r3[0x0],r9
80013d78:	fb 48 06 90 	st.w	sp[1680],r8
80013d7c:	30 29       	mov	r9,2
80013d7e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80013d82:	87 19       	st.w	r3[0x4],r9
80013d84:	2f f8       	sub	r8,-1
80013d86:	fb 48 06 8c 	st.w	sp[1676],r8
80013d8a:	58 78       	cp.w	r8,7
80013d8c:	e0 89 00 04 	brgt	80013d94 <_vfprintf_r+0x17a4>
80013d90:	2f 83       	sub	r3,-8
80013d92:	c0 b8       	rjmp	80013da8 <_vfprintf_r+0x17b8>
80013d94:	fa ca f9 78 	sub	r10,sp,-1672
80013d98:	02 9b       	mov	r11,r1
80013d9a:	08 9c       	mov	r12,r4
80013d9c:	fe b0 f4 1c 	rcall	800125d4 <__sprint_r>
80013da0:	e0 81 03 a7 	brne	800144ee <_vfprintf_r+0x1efe>
80013da4:	fa c3 f9 e0 	sub	r3,sp,-1568
80013da8:	40 9b       	lddsp	r11,sp[0x24]
80013daa:	e0 4b 00 80 	cp.w	r11,128
80013dae:	c4 71       	brne	80013e3c <_vfprintf_r+0x184c>
80013db0:	40 8a       	lddsp	r10,sp[0x20]
80013db2:	40 39       	lddsp	r9,sp[0xc]
80013db4:	12 1a       	sub	r10,r9
80013db6:	50 4a       	stdsp	sp[0x10],r10
80013db8:	58 0a       	cp.w	r10,0
80013dba:	e0 89 00 20 	brgt	80013dfa <_vfprintf_r+0x180a>
80013dbe:	c3 f8       	rjmp	80013e3c <_vfprintf_r+0x184c>
80013dc0:	2f 09       	sub	r9,-16
80013dc2:	2f f8       	sub	r8,-1
80013dc4:	fe ce b0 c4 	sub	lr,pc,-20284
80013dc8:	31 0c       	mov	r12,16
80013dca:	fb 49 06 90 	st.w	sp[1680],r9
80013dce:	87 0e       	st.w	r3[0x0],lr
80013dd0:	87 1c       	st.w	r3[0x4],r12
80013dd2:	fb 48 06 8c 	st.w	sp[1676],r8
80013dd6:	58 78       	cp.w	r8,7
80013dd8:	e0 89 00 04 	brgt	80013de0 <_vfprintf_r+0x17f0>
80013ddc:	2f 83       	sub	r3,-8
80013dde:	c0 b8       	rjmp	80013df4 <_vfprintf_r+0x1804>
80013de0:	fa ca f9 78 	sub	r10,sp,-1672
80013de4:	02 9b       	mov	r11,r1
80013de6:	08 9c       	mov	r12,r4
80013de8:	fe b0 f3 f6 	rcall	800125d4 <__sprint_r>
80013dec:	e0 81 03 81 	brne	800144ee <_vfprintf_r+0x1efe>
80013df0:	fa c3 f9 e0 	sub	r3,sp,-1568
80013df4:	40 4b       	lddsp	r11,sp[0x10]
80013df6:	21 0b       	sub	r11,16
80013df8:	50 4b       	stdsp	sp[0x10],r11
80013dfa:	fa f9 06 90 	ld.w	r9,sp[1680]
80013dfe:	fa f8 06 8c 	ld.w	r8,sp[1676]
80013e02:	fe ca b1 02 	sub	r10,pc,-20222
80013e06:	40 4e       	lddsp	lr,sp[0x10]
80013e08:	59 0e       	cp.w	lr,16
80013e0a:	fe 99 ff db 	brgt	80013dc0 <_vfprintf_r+0x17d0>
80013e0e:	1c 09       	add	r9,lr
80013e10:	2f f8       	sub	r8,-1
80013e12:	87 0a       	st.w	r3[0x0],r10
80013e14:	fb 49 06 90 	st.w	sp[1680],r9
80013e18:	87 1e       	st.w	r3[0x4],lr
80013e1a:	fb 48 06 8c 	st.w	sp[1676],r8
80013e1e:	58 78       	cp.w	r8,7
80013e20:	e0 89 00 04 	brgt	80013e28 <_vfprintf_r+0x1838>
80013e24:	2f 83       	sub	r3,-8
80013e26:	c0 b8       	rjmp	80013e3c <_vfprintf_r+0x184c>
80013e28:	fa ca f9 78 	sub	r10,sp,-1672
80013e2c:	02 9b       	mov	r11,r1
80013e2e:	08 9c       	mov	r12,r4
80013e30:	fe b0 f3 d2 	rcall	800125d4 <__sprint_r>
80013e34:	e0 81 03 5d 	brne	800144ee <_vfprintf_r+0x1efe>
80013e38:	fa c3 f9 e0 	sub	r3,sp,-1568
80013e3c:	40 2c       	lddsp	r12,sp[0x8]
80013e3e:	04 1c       	sub	r12,r2
80013e40:	50 2c       	stdsp	sp[0x8],r12
80013e42:	58 0c       	cp.w	r12,0
80013e44:	e0 89 00 20 	brgt	80013e84 <_vfprintf_r+0x1894>
80013e48:	c3 f8       	rjmp	80013ec6 <_vfprintf_r+0x18d6>
80013e4a:	2f 09       	sub	r9,-16
80013e4c:	2f f8       	sub	r8,-1
80013e4e:	fe cb b1 4e 	sub	r11,pc,-20146
80013e52:	31 0a       	mov	r10,16
80013e54:	fb 49 06 90 	st.w	sp[1680],r9
80013e58:	87 0b       	st.w	r3[0x0],r11
80013e5a:	87 1a       	st.w	r3[0x4],r10
80013e5c:	fb 48 06 8c 	st.w	sp[1676],r8
80013e60:	58 78       	cp.w	r8,7
80013e62:	e0 89 00 04 	brgt	80013e6a <_vfprintf_r+0x187a>
80013e66:	2f 83       	sub	r3,-8
80013e68:	c0 b8       	rjmp	80013e7e <_vfprintf_r+0x188e>
80013e6a:	fa ca f9 78 	sub	r10,sp,-1672
80013e6e:	02 9b       	mov	r11,r1
80013e70:	08 9c       	mov	r12,r4
80013e72:	fe b0 f3 b1 	rcall	800125d4 <__sprint_r>
80013e76:	e0 81 03 3c 	brne	800144ee <_vfprintf_r+0x1efe>
80013e7a:	fa c3 f9 e0 	sub	r3,sp,-1568
80013e7e:	40 29       	lddsp	r9,sp[0x8]
80013e80:	21 09       	sub	r9,16
80013e82:	50 29       	stdsp	sp[0x8],r9
80013e84:	fa f9 06 90 	ld.w	r9,sp[1680]
80013e88:	fa f8 06 8c 	ld.w	r8,sp[1676]
80013e8c:	fe ca b1 8c 	sub	r10,pc,-20084
80013e90:	40 2e       	lddsp	lr,sp[0x8]
80013e92:	59 0e       	cp.w	lr,16
80013e94:	fe 99 ff db 	brgt	80013e4a <_vfprintf_r+0x185a>
80013e98:	1c 09       	add	r9,lr
80013e9a:	2f f8       	sub	r8,-1
80013e9c:	87 0a       	st.w	r3[0x0],r10
80013e9e:	fb 49 06 90 	st.w	sp[1680],r9
80013ea2:	87 1e       	st.w	r3[0x4],lr
80013ea4:	fb 48 06 8c 	st.w	sp[1676],r8
80013ea8:	58 78       	cp.w	r8,7
80013eaa:	e0 89 00 04 	brgt	80013eb2 <_vfprintf_r+0x18c2>
80013eae:	2f 83       	sub	r3,-8
80013eb0:	c0 b8       	rjmp	80013ec6 <_vfprintf_r+0x18d6>
80013eb2:	fa ca f9 78 	sub	r10,sp,-1672
80013eb6:	02 9b       	mov	r11,r1
80013eb8:	08 9c       	mov	r12,r4
80013eba:	fe b0 f3 8d 	rcall	800125d4 <__sprint_r>
80013ebe:	e0 81 03 18 	brne	800144ee <_vfprintf_r+0x1efe>
80013ec2:	fa c3 f9 e0 	sub	r3,sp,-1568
80013ec6:	ed b5 00 08 	bld	r5,0x8
80013eca:	c0 b0       	breq	80013ee0 <_vfprintf_r+0x18f0>
80013ecc:	fa f8 06 90 	ld.w	r8,sp[1680]
80013ed0:	87 12       	st.w	r3[0x4],r2
80013ed2:	87 06       	st.w	r3[0x0],r6
80013ed4:	f0 02 00 02 	add	r2,r8,r2
80013ed8:	fb 42 06 90 	st.w	sp[1680],r2
80013edc:	e0 8f 01 d4 	bral	80014284 <_vfprintf_r+0x1c94>
80013ee0:	e0 40 00 65 	cp.w	r0,101
80013ee4:	e0 8a 01 d6 	brle	80014290 <_vfprintf_r+0x1ca0>
80013ee8:	30 08       	mov	r8,0
80013eea:	30 09       	mov	r9,0
80013eec:	40 5b       	lddsp	r11,sp[0x14]
80013eee:	40 7a       	lddsp	r10,sp[0x1c]
80013ef0:	e0 a0 12 b0 	rcall	80016450 <__avr32_f64_cmp_eq>
80013ef4:	c7 90       	breq	80013fe6 <_vfprintf_r+0x19f6>
80013ef6:	fa f8 06 90 	ld.w	r8,sp[1680]
80013efa:	fe c9 b2 0e 	sub	r9,pc,-19954
80013efe:	2f f8       	sub	r8,-1
80013f00:	87 09       	st.w	r3[0x0],r9
80013f02:	fb 48 06 90 	st.w	sp[1680],r8
80013f06:	30 19       	mov	r9,1
80013f08:	fa f8 06 8c 	ld.w	r8,sp[1676]
80013f0c:	87 19       	st.w	r3[0x4],r9
80013f0e:	2f f8       	sub	r8,-1
80013f10:	fb 48 06 8c 	st.w	sp[1676],r8
80013f14:	58 78       	cp.w	r8,7
80013f16:	e0 89 00 05 	brgt	80013f20 <_vfprintf_r+0x1930>
80013f1a:	2f 83       	sub	r3,-8
80013f1c:	c0 c8       	rjmp	80013f34 <_vfprintf_r+0x1944>
80013f1e:	d7 03       	nop
80013f20:	fa ca f9 78 	sub	r10,sp,-1672
80013f24:	02 9b       	mov	r11,r1
80013f26:	08 9c       	mov	r12,r4
80013f28:	fe b0 f3 56 	rcall	800125d4 <__sprint_r>
80013f2c:	e0 81 02 e1 	brne	800144ee <_vfprintf_r+0x1efe>
80013f30:	fa c3 f9 e0 	sub	r3,sp,-1568
80013f34:	fa f8 06 ac 	ld.w	r8,sp[1708]
80013f38:	40 6c       	lddsp	r12,sp[0x18]
80013f3a:	18 38       	cp.w	r8,r12
80013f3c:	c0 55       	brlt	80013f46 <_vfprintf_r+0x1956>
80013f3e:	ed b5 00 00 	bld	r5,0x0
80013f42:	e0 81 02 6b 	brne	80014418 <_vfprintf_r+0x1e28>
80013f46:	fa f8 06 90 	ld.w	r8,sp[1680]
80013f4a:	2f f8       	sub	r8,-1
80013f4c:	40 cb       	lddsp	r11,sp[0x30]
80013f4e:	fb 48 06 90 	st.w	sp[1680],r8
80013f52:	30 19       	mov	r9,1
80013f54:	fa f8 06 8c 	ld.w	r8,sp[1676]
80013f58:	87 0b       	st.w	r3[0x0],r11
80013f5a:	2f f8       	sub	r8,-1
80013f5c:	87 19       	st.w	r3[0x4],r9
80013f5e:	fb 48 06 8c 	st.w	sp[1676],r8
80013f62:	58 78       	cp.w	r8,7
80013f64:	e0 89 00 04 	brgt	80013f6c <_vfprintf_r+0x197c>
80013f68:	2f 83       	sub	r3,-8
80013f6a:	c0 b8       	rjmp	80013f80 <_vfprintf_r+0x1990>
80013f6c:	fa ca f9 78 	sub	r10,sp,-1672
80013f70:	02 9b       	mov	r11,r1
80013f72:	08 9c       	mov	r12,r4
80013f74:	fe b0 f3 30 	rcall	800125d4 <__sprint_r>
80013f78:	e0 81 02 bb 	brne	800144ee <_vfprintf_r+0x1efe>
80013f7c:	fa c3 f9 e0 	sub	r3,sp,-1568
80013f80:	40 66       	lddsp	r6,sp[0x18]
80013f82:	20 16       	sub	r6,1
80013f84:	58 06       	cp.w	r6,0
80013f86:	e0 89 00 1d 	brgt	80013fc0 <_vfprintf_r+0x19d0>
80013f8a:	e0 8f 02 47 	bral	80014418 <_vfprintf_r+0x1e28>
80013f8e:	2f 09       	sub	r9,-16
80013f90:	2f f8       	sub	r8,-1
80013f92:	fb 49 06 90 	st.w	sp[1680],r9
80013f96:	87 02       	st.w	r3[0x0],r2
80013f98:	87 10       	st.w	r3[0x4],r0
80013f9a:	fb 48 06 8c 	st.w	sp[1676],r8
80013f9e:	58 78       	cp.w	r8,7
80013fa0:	e0 89 00 04 	brgt	80013fa8 <_vfprintf_r+0x19b8>
80013fa4:	2f 83       	sub	r3,-8
80013fa6:	c0 b8       	rjmp	80013fbc <_vfprintf_r+0x19cc>
80013fa8:	fa ca f9 78 	sub	r10,sp,-1672
80013fac:	02 9b       	mov	r11,r1
80013fae:	08 9c       	mov	r12,r4
80013fb0:	fe b0 f3 12 	rcall	800125d4 <__sprint_r>
80013fb4:	e0 81 02 9d 	brne	800144ee <_vfprintf_r+0x1efe>
80013fb8:	fa c3 f9 e0 	sub	r3,sp,-1568
80013fbc:	21 06       	sub	r6,16
80013fbe:	c0 48       	rjmp	80013fc6 <_vfprintf_r+0x19d6>
80013fc0:	fe c2 b2 c0 	sub	r2,pc,-19776
80013fc4:	31 00       	mov	r0,16
80013fc6:	fa f9 06 90 	ld.w	r9,sp[1680]
80013fca:	fa f8 06 8c 	ld.w	r8,sp[1676]
80013fce:	fe ca b2 ce 	sub	r10,pc,-19762
80013fd2:	59 06       	cp.w	r6,16
80013fd4:	fe 99 ff dd 	brgt	80013f8e <_vfprintf_r+0x199e>
80013fd8:	0c 09       	add	r9,r6
80013fda:	87 0a       	st.w	r3[0x0],r10
80013fdc:	fb 49 06 90 	st.w	sp[1680],r9
80013fe0:	2f f8       	sub	r8,-1
80013fe2:	87 16       	st.w	r3[0x4],r6
80013fe4:	c5 39       	rjmp	8001428a <_vfprintf_r+0x1c9a>
80013fe6:	fa fa 06 ac 	ld.w	r10,sp[1708]
80013fea:	58 0a       	cp.w	r10,0
80013fec:	e0 89 00 92 	brgt	80014110 <_vfprintf_r+0x1b20>
80013ff0:	fa f8 06 90 	ld.w	r8,sp[1680]
80013ff4:	fe c9 b3 08 	sub	r9,pc,-19704
80013ff8:	2f f8       	sub	r8,-1
80013ffa:	87 09       	st.w	r3[0x0],r9
80013ffc:	fb 48 06 90 	st.w	sp[1680],r8
80014000:	30 19       	mov	r9,1
80014002:	fa f8 06 8c 	ld.w	r8,sp[1676]
80014006:	87 19       	st.w	r3[0x4],r9
80014008:	2f f8       	sub	r8,-1
8001400a:	fb 48 06 8c 	st.w	sp[1676],r8
8001400e:	58 78       	cp.w	r8,7
80014010:	e0 89 00 04 	brgt	80014018 <_vfprintf_r+0x1a28>
80014014:	2f 83       	sub	r3,-8
80014016:	c0 b8       	rjmp	8001402c <_vfprintf_r+0x1a3c>
80014018:	fa ca f9 78 	sub	r10,sp,-1672
8001401c:	02 9b       	mov	r11,r1
8001401e:	08 9c       	mov	r12,r4
80014020:	fe b0 f2 da 	rcall	800125d4 <__sprint_r>
80014024:	e0 81 02 65 	brne	800144ee <_vfprintf_r+0x1efe>
80014028:	fa c3 f9 e0 	sub	r3,sp,-1568
8001402c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80014030:	58 08       	cp.w	r8,0
80014032:	c0 81       	brne	80014042 <_vfprintf_r+0x1a52>
80014034:	40 6a       	lddsp	r10,sp[0x18]
80014036:	58 0a       	cp.w	r10,0
80014038:	c0 51       	brne	80014042 <_vfprintf_r+0x1a52>
8001403a:	ed b5 00 00 	bld	r5,0x0
8001403e:	e0 81 01 ed 	brne	80014418 <_vfprintf_r+0x1e28>
80014042:	40 c9       	lddsp	r9,sp[0x30]
80014044:	fa f8 06 90 	ld.w	r8,sp[1680]
80014048:	2f f8       	sub	r8,-1
8001404a:	87 09       	st.w	r3[0x0],r9
8001404c:	fb 48 06 90 	st.w	sp[1680],r8
80014050:	30 19       	mov	r9,1
80014052:	fa f8 06 8c 	ld.w	r8,sp[1676]
80014056:	87 19       	st.w	r3[0x4],r9
80014058:	2f f8       	sub	r8,-1
8001405a:	fb 48 06 8c 	st.w	sp[1676],r8
8001405e:	58 78       	cp.w	r8,7
80014060:	e0 89 00 04 	brgt	80014068 <_vfprintf_r+0x1a78>
80014064:	2f 83       	sub	r3,-8
80014066:	c0 b8       	rjmp	8001407c <_vfprintf_r+0x1a8c>
80014068:	fa ca f9 78 	sub	r10,sp,-1672
8001406c:	02 9b       	mov	r11,r1
8001406e:	08 9c       	mov	r12,r4
80014070:	fe b0 f2 b2 	rcall	800125d4 <__sprint_r>
80014074:	e0 81 02 3d 	brne	800144ee <_vfprintf_r+0x1efe>
80014078:	fa c3 f9 e0 	sub	r3,sp,-1568
8001407c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80014080:	5c 32       	neg	r2
80014082:	58 02       	cp.w	r2,0
80014084:	e0 89 00 1d 	brgt	800140be <_vfprintf_r+0x1ace>
80014088:	c3 d8       	rjmp	80014102 <_vfprintf_r+0x1b12>
8001408a:	2f 09       	sub	r9,-16
8001408c:	2f f8       	sub	r8,-1
8001408e:	31 0e       	mov	lr,16
80014090:	fb 49 06 90 	st.w	sp[1680],r9
80014094:	87 00       	st.w	r3[0x0],r0
80014096:	87 1e       	st.w	r3[0x4],lr
80014098:	fb 48 06 8c 	st.w	sp[1676],r8
8001409c:	58 78       	cp.w	r8,7
8001409e:	e0 89 00 04 	brgt	800140a6 <_vfprintf_r+0x1ab6>
800140a2:	2f 83       	sub	r3,-8
800140a4:	c0 b8       	rjmp	800140ba <_vfprintf_r+0x1aca>
800140a6:	fa ca f9 78 	sub	r10,sp,-1672
800140aa:	02 9b       	mov	r11,r1
800140ac:	08 9c       	mov	r12,r4
800140ae:	fe b0 f2 93 	rcall	800125d4 <__sprint_r>
800140b2:	e0 81 02 1e 	brne	800144ee <_vfprintf_r+0x1efe>
800140b6:	fa c3 f9 e0 	sub	r3,sp,-1568
800140ba:	21 02       	sub	r2,16
800140bc:	c0 38       	rjmp	800140c2 <_vfprintf_r+0x1ad2>
800140be:	fe c0 b3 be 	sub	r0,pc,-19522
800140c2:	fa f9 06 90 	ld.w	r9,sp[1680]
800140c6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800140ca:	fe ca b3 ca 	sub	r10,pc,-19510
800140ce:	59 02       	cp.w	r2,16
800140d0:	fe 99 ff dd 	brgt	8001408a <_vfprintf_r+0x1a9a>
800140d4:	04 09       	add	r9,r2
800140d6:	2f f8       	sub	r8,-1
800140d8:	87 0a       	st.w	r3[0x0],r10
800140da:	fb 49 06 90 	st.w	sp[1680],r9
800140de:	87 12       	st.w	r3[0x4],r2
800140e0:	fb 48 06 8c 	st.w	sp[1676],r8
800140e4:	58 78       	cp.w	r8,7
800140e6:	e0 89 00 04 	brgt	800140ee <_vfprintf_r+0x1afe>
800140ea:	2f 83       	sub	r3,-8
800140ec:	c0 b8       	rjmp	80014102 <_vfprintf_r+0x1b12>
800140ee:	fa ca f9 78 	sub	r10,sp,-1672
800140f2:	02 9b       	mov	r11,r1
800140f4:	08 9c       	mov	r12,r4
800140f6:	fe b0 f2 6f 	rcall	800125d4 <__sprint_r>
800140fa:	e0 81 01 fa 	brne	800144ee <_vfprintf_r+0x1efe>
800140fe:	fa c3 f9 e0 	sub	r3,sp,-1568
80014102:	40 6c       	lddsp	r12,sp[0x18]
80014104:	fa f8 06 90 	ld.w	r8,sp[1680]
80014108:	87 06       	st.w	r3[0x0],r6
8001410a:	87 1c       	st.w	r3[0x4],r12
8001410c:	18 08       	add	r8,r12
8001410e:	cb 98       	rjmp	80014280 <_vfprintf_r+0x1c90>
80014110:	fa f9 06 90 	ld.w	r9,sp[1680]
80014114:	fa f8 06 8c 	ld.w	r8,sp[1676]
80014118:	40 6b       	lddsp	r11,sp[0x18]
8001411a:	16 3a       	cp.w	r10,r11
8001411c:	c6 f5       	brlt	800141fa <_vfprintf_r+0x1c0a>
8001411e:	16 09       	add	r9,r11
80014120:	2f f8       	sub	r8,-1
80014122:	87 06       	st.w	r3[0x0],r6
80014124:	fb 49 06 90 	st.w	sp[1680],r9
80014128:	87 1b       	st.w	r3[0x4],r11
8001412a:	fb 48 06 8c 	st.w	sp[1676],r8
8001412e:	58 78       	cp.w	r8,7
80014130:	e0 89 00 04 	brgt	80014138 <_vfprintf_r+0x1b48>
80014134:	2f 83       	sub	r3,-8
80014136:	c0 b8       	rjmp	8001414c <_vfprintf_r+0x1b5c>
80014138:	fa ca f9 78 	sub	r10,sp,-1672
8001413c:	02 9b       	mov	r11,r1
8001413e:	08 9c       	mov	r12,r4
80014140:	fe b0 f2 4a 	rcall	800125d4 <__sprint_r>
80014144:	e0 81 01 d5 	brne	800144ee <_vfprintf_r+0x1efe>
80014148:	fa c3 f9 e0 	sub	r3,sp,-1568
8001414c:	fa f6 06 ac 	ld.w	r6,sp[1708]
80014150:	40 6a       	lddsp	r10,sp[0x18]
80014152:	14 16       	sub	r6,r10
80014154:	58 06       	cp.w	r6,0
80014156:	e0 89 00 1c 	brgt	8001418e <_vfprintf_r+0x1b9e>
8001415a:	c3 d8       	rjmp	800141d4 <_vfprintf_r+0x1be4>
8001415c:	2f 09       	sub	r9,-16
8001415e:	2f f8       	sub	r8,-1
80014160:	fb 49 06 90 	st.w	sp[1680],r9
80014164:	87 02       	st.w	r3[0x0],r2
80014166:	87 10       	st.w	r3[0x4],r0
80014168:	fb 48 06 8c 	st.w	sp[1676],r8
8001416c:	58 78       	cp.w	r8,7
8001416e:	e0 89 00 04 	brgt	80014176 <_vfprintf_r+0x1b86>
80014172:	2f 83       	sub	r3,-8
80014174:	c0 b8       	rjmp	8001418a <_vfprintf_r+0x1b9a>
80014176:	fa ca f9 78 	sub	r10,sp,-1672
8001417a:	02 9b       	mov	r11,r1
8001417c:	08 9c       	mov	r12,r4
8001417e:	fe b0 f2 2b 	rcall	800125d4 <__sprint_r>
80014182:	e0 81 01 b6 	brne	800144ee <_vfprintf_r+0x1efe>
80014186:	fa c3 f9 e0 	sub	r3,sp,-1568
8001418a:	21 06       	sub	r6,16
8001418c:	c0 48       	rjmp	80014194 <_vfprintf_r+0x1ba4>
8001418e:	fe c2 b4 8e 	sub	r2,pc,-19314
80014192:	31 00       	mov	r0,16
80014194:	fa f9 06 90 	ld.w	r9,sp[1680]
80014198:	fa f8 06 8c 	ld.w	r8,sp[1676]
8001419c:	fe ca b4 9c 	sub	r10,pc,-19300
800141a0:	59 06       	cp.w	r6,16
800141a2:	fe 99 ff dd 	brgt	8001415c <_vfprintf_r+0x1b6c>
800141a6:	0c 09       	add	r9,r6
800141a8:	2f f8       	sub	r8,-1
800141aa:	87 0a       	st.w	r3[0x0],r10
800141ac:	fb 49 06 90 	st.w	sp[1680],r9
800141b0:	87 16       	st.w	r3[0x4],r6
800141b2:	fb 48 06 8c 	st.w	sp[1676],r8
800141b6:	58 78       	cp.w	r8,7
800141b8:	e0 89 00 04 	brgt	800141c0 <_vfprintf_r+0x1bd0>
800141bc:	2f 83       	sub	r3,-8
800141be:	c0 b8       	rjmp	800141d4 <_vfprintf_r+0x1be4>
800141c0:	fa ca f9 78 	sub	r10,sp,-1672
800141c4:	02 9b       	mov	r11,r1
800141c6:	08 9c       	mov	r12,r4
800141c8:	fe b0 f2 06 	rcall	800125d4 <__sprint_r>
800141cc:	e0 81 01 91 	brne	800144ee <_vfprintf_r+0x1efe>
800141d0:	fa c3 f9 e0 	sub	r3,sp,-1568
800141d4:	ed b5 00 00 	bld	r5,0x0
800141d8:	e0 81 01 20 	brne	80014418 <_vfprintf_r+0x1e28>
800141dc:	40 c9       	lddsp	r9,sp[0x30]
800141de:	fa f8 06 90 	ld.w	r8,sp[1680]
800141e2:	2f f8       	sub	r8,-1
800141e4:	87 09       	st.w	r3[0x0],r9
800141e6:	fb 48 06 90 	st.w	sp[1680],r8
800141ea:	30 19       	mov	r9,1
800141ec:	fa f8 06 8c 	ld.w	r8,sp[1676]
800141f0:	87 19       	st.w	r3[0x4],r9
800141f2:	2f f8       	sub	r8,-1
800141f4:	fb 48 06 8c 	st.w	sp[1676],r8
800141f8:	c0 29       	rjmp	800143fc <_vfprintf_r+0x1e0c>
800141fa:	14 09       	add	r9,r10
800141fc:	2f f8       	sub	r8,-1
800141fe:	fb 49 06 90 	st.w	sp[1680],r9
80014202:	87 06       	st.w	r3[0x0],r6
80014204:	87 1a       	st.w	r3[0x4],r10
80014206:	fb 48 06 8c 	st.w	sp[1676],r8
8001420a:	58 78       	cp.w	r8,7
8001420c:	e0 89 00 04 	brgt	80014214 <_vfprintf_r+0x1c24>
80014210:	2f 83       	sub	r3,-8
80014212:	c0 b8       	rjmp	80014228 <_vfprintf_r+0x1c38>
80014214:	fa ca f9 78 	sub	r10,sp,-1672
80014218:	02 9b       	mov	r11,r1
8001421a:	08 9c       	mov	r12,r4
8001421c:	fe b0 f1 dc 	rcall	800125d4 <__sprint_r>
80014220:	e0 81 01 67 	brne	800144ee <_vfprintf_r+0x1efe>
80014224:	fa c3 f9 e0 	sub	r3,sp,-1568
80014228:	40 c8       	lddsp	r8,sp[0x30]
8001422a:	87 08       	st.w	r3[0x0],r8
8001422c:	fa f8 06 90 	ld.w	r8,sp[1680]
80014230:	2f f8       	sub	r8,-1
80014232:	30 19       	mov	r9,1
80014234:	fb 48 06 90 	st.w	sp[1680],r8
80014238:	87 19       	st.w	r3[0x4],r9
8001423a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8001423e:	2f f8       	sub	r8,-1
80014240:	fb 48 06 8c 	st.w	sp[1676],r8
80014244:	fa f2 06 ac 	ld.w	r2,sp[1708]
80014248:	58 78       	cp.w	r8,7
8001424a:	e0 89 00 04 	brgt	80014252 <_vfprintf_r+0x1c62>
8001424e:	2f 83       	sub	r3,-8
80014250:	c0 b8       	rjmp	80014266 <_vfprintf_r+0x1c76>
80014252:	fa ca f9 78 	sub	r10,sp,-1672
80014256:	02 9b       	mov	r11,r1
80014258:	08 9c       	mov	r12,r4
8001425a:	fe b0 f1 bd 	rcall	800125d4 <__sprint_r>
8001425e:	e0 81 01 48 	brne	800144ee <_vfprintf_r+0x1efe>
80014262:	fa c3 f9 e0 	sub	r3,sp,-1568
80014266:	04 06       	add	r6,r2
80014268:	fa f8 06 ac 	ld.w	r8,sp[1708]
8001426c:	87 06       	st.w	r3[0x0],r6
8001426e:	fa f9 06 90 	ld.w	r9,sp[1680]
80014272:	40 66       	lddsp	r6,sp[0x18]
80014274:	40 6e       	lddsp	lr,sp[0x18]
80014276:	10 16       	sub	r6,r8
80014278:	f2 08 01 08 	sub	r8,r9,r8
8001427c:	87 16       	st.w	r3[0x4],r6
8001427e:	1c 08       	add	r8,lr
80014280:	fb 48 06 90 	st.w	sp[1680],r8
80014284:	fa f8 06 8c 	ld.w	r8,sp[1676]
80014288:	2f f8       	sub	r8,-1
8001428a:	fb 48 06 8c 	st.w	sp[1676],r8
8001428e:	cb 78       	rjmp	800143fc <_vfprintf_r+0x1e0c>
80014290:	40 6c       	lddsp	r12,sp[0x18]
80014292:	58 1c       	cp.w	r12,1
80014294:	e0 89 00 06 	brgt	800142a0 <_vfprintf_r+0x1cb0>
80014298:	ed b5 00 00 	bld	r5,0x0
8001429c:	e0 81 00 85 	brne	800143a6 <_vfprintf_r+0x1db6>
800142a0:	fa f8 06 90 	ld.w	r8,sp[1680]
800142a4:	2f f8       	sub	r8,-1
800142a6:	30 19       	mov	r9,1
800142a8:	fb 48 06 90 	st.w	sp[1680],r8
800142ac:	87 06       	st.w	r3[0x0],r6
800142ae:	fa f8 06 8c 	ld.w	r8,sp[1676]
800142b2:	87 19       	st.w	r3[0x4],r9
800142b4:	2f f8       	sub	r8,-1
800142b6:	fb 48 06 8c 	st.w	sp[1676],r8
800142ba:	58 78       	cp.w	r8,7
800142bc:	e0 89 00 04 	brgt	800142c4 <_vfprintf_r+0x1cd4>
800142c0:	2f 83       	sub	r3,-8
800142c2:	c0 b8       	rjmp	800142d8 <_vfprintf_r+0x1ce8>
800142c4:	fa ca f9 78 	sub	r10,sp,-1672
800142c8:	02 9b       	mov	r11,r1
800142ca:	08 9c       	mov	r12,r4
800142cc:	fe b0 f1 84 	rcall	800125d4 <__sprint_r>
800142d0:	e0 81 01 0f 	brne	800144ee <_vfprintf_r+0x1efe>
800142d4:	fa c3 f9 e0 	sub	r3,sp,-1568
800142d8:	fa f8 06 90 	ld.w	r8,sp[1680]
800142dc:	2f f8       	sub	r8,-1
800142de:	40 cb       	lddsp	r11,sp[0x30]
800142e0:	fb 48 06 90 	st.w	sp[1680],r8
800142e4:	30 19       	mov	r9,1
800142e6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800142ea:	87 0b       	st.w	r3[0x0],r11
800142ec:	2f f8       	sub	r8,-1
800142ee:	87 19       	st.w	r3[0x4],r9
800142f0:	fb 48 06 8c 	st.w	sp[1676],r8
800142f4:	58 78       	cp.w	r8,7
800142f6:	e0 89 00 05 	brgt	80014300 <_vfprintf_r+0x1d10>
800142fa:	2f 83       	sub	r3,-8
800142fc:	c0 c8       	rjmp	80014314 <_vfprintf_r+0x1d24>
800142fe:	d7 03       	nop
80014300:	fa ca f9 78 	sub	r10,sp,-1672
80014304:	02 9b       	mov	r11,r1
80014306:	08 9c       	mov	r12,r4
80014308:	fe b0 f1 66 	rcall	800125d4 <__sprint_r>
8001430c:	e0 81 00 f1 	brne	800144ee <_vfprintf_r+0x1efe>
80014310:	fa c3 f9 e0 	sub	r3,sp,-1568
80014314:	30 08       	mov	r8,0
80014316:	30 09       	mov	r9,0
80014318:	40 5b       	lddsp	r11,sp[0x14]
8001431a:	40 7a       	lddsp	r10,sp[0x1c]
8001431c:	e0 a0 10 9a 	rcall	80016450 <__avr32_f64_cmp_eq>
80014320:	40 68       	lddsp	r8,sp[0x18]
80014322:	20 18       	sub	r8,1
80014324:	58 0c       	cp.w	r12,0
80014326:	c0 d1       	brne	80014340 <_vfprintf_r+0x1d50>
80014328:	2f f6       	sub	r6,-1
8001432a:	87 18       	st.w	r3[0x4],r8
8001432c:	87 06       	st.w	r3[0x0],r6
8001432e:	fa f6 06 90 	ld.w	r6,sp[1680]
80014332:	10 06       	add	r6,r8
80014334:	fa f8 06 8c 	ld.w	r8,sp[1676]
80014338:	fb 46 06 90 	st.w	sp[1680],r6
8001433c:	2f f8       	sub	r8,-1
8001433e:	c3 18       	rjmp	800143a0 <_vfprintf_r+0x1db0>
80014340:	10 96       	mov	r6,r8
80014342:	58 08       	cp.w	r8,0
80014344:	e0 89 00 1c 	brgt	8001437c <_vfprintf_r+0x1d8c>
80014348:	c4 b8       	rjmp	800143de <_vfprintf_r+0x1dee>
8001434a:	2f 09       	sub	r9,-16
8001434c:	2f f8       	sub	r8,-1
8001434e:	fb 49 06 90 	st.w	sp[1680],r9
80014352:	87 02       	st.w	r3[0x0],r2
80014354:	87 10       	st.w	r3[0x4],r0
80014356:	fb 48 06 8c 	st.w	sp[1676],r8
8001435a:	58 78       	cp.w	r8,7
8001435c:	e0 89 00 04 	brgt	80014364 <_vfprintf_r+0x1d74>
80014360:	2f 83       	sub	r3,-8
80014362:	c0 b8       	rjmp	80014378 <_vfprintf_r+0x1d88>
80014364:	fa ca f9 78 	sub	r10,sp,-1672
80014368:	02 9b       	mov	r11,r1
8001436a:	08 9c       	mov	r12,r4
8001436c:	fe b0 f1 34 	rcall	800125d4 <__sprint_r>
80014370:	e0 81 00 bf 	brne	800144ee <_vfprintf_r+0x1efe>
80014374:	fa c3 f9 e0 	sub	r3,sp,-1568
80014378:	21 06       	sub	r6,16
8001437a:	c0 48       	rjmp	80014382 <_vfprintf_r+0x1d92>
8001437c:	fe c2 b6 7c 	sub	r2,pc,-18820
80014380:	31 00       	mov	r0,16
80014382:	fa f9 06 90 	ld.w	r9,sp[1680]
80014386:	fa f8 06 8c 	ld.w	r8,sp[1676]
8001438a:	fe ca b6 8a 	sub	r10,pc,-18806
8001438e:	59 06       	cp.w	r6,16
80014390:	fe 99 ff dd 	brgt	8001434a <_vfprintf_r+0x1d5a>
80014394:	0c 09       	add	r9,r6
80014396:	87 0a       	st.w	r3[0x0],r10
80014398:	fb 49 06 90 	st.w	sp[1680],r9
8001439c:	2f f8       	sub	r8,-1
8001439e:	87 16       	st.w	r3[0x4],r6
800143a0:	fb 48 06 8c 	st.w	sp[1676],r8
800143a4:	c0 e8       	rjmp	800143c0 <_vfprintf_r+0x1dd0>
800143a6:	fa f8 06 90 	ld.w	r8,sp[1680]
800143aa:	2f f8       	sub	r8,-1
800143ac:	30 19       	mov	r9,1
800143ae:	fb 48 06 90 	st.w	sp[1680],r8
800143b2:	87 06       	st.w	r3[0x0],r6
800143b4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800143b8:	87 19       	st.w	r3[0x4],r9
800143ba:	2f f8       	sub	r8,-1
800143bc:	fb 48 06 8c 	st.w	sp[1676],r8
800143c0:	58 78       	cp.w	r8,7
800143c2:	e0 89 00 04 	brgt	800143ca <_vfprintf_r+0x1dda>
800143c6:	2f 83       	sub	r3,-8
800143c8:	c0 b8       	rjmp	800143de <_vfprintf_r+0x1dee>
800143ca:	fa ca f9 78 	sub	r10,sp,-1672
800143ce:	02 9b       	mov	r11,r1
800143d0:	08 9c       	mov	r12,r4
800143d2:	fe b0 f1 01 	rcall	800125d4 <__sprint_r>
800143d6:	e0 81 00 8c 	brne	800144ee <_vfprintf_r+0x1efe>
800143da:	fa c3 f9 e0 	sub	r3,sp,-1568
800143de:	40 ea       	lddsp	r10,sp[0x38]
800143e0:	fa f8 06 90 	ld.w	r8,sp[1680]
800143e4:	14 08       	add	r8,r10
800143e6:	fa c9 f9 64 	sub	r9,sp,-1692
800143ea:	fb 48 06 90 	st.w	sp[1680],r8
800143ee:	87 1a       	st.w	r3[0x4],r10
800143f0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800143f4:	87 09       	st.w	r3[0x0],r9
800143f6:	2f f8       	sub	r8,-1
800143f8:	fb 48 06 8c 	st.w	sp[1676],r8
800143fc:	58 78       	cp.w	r8,7
800143fe:	e0 89 00 04 	brgt	80014406 <_vfprintf_r+0x1e16>
80014402:	2f 83       	sub	r3,-8
80014404:	c0 a8       	rjmp	80014418 <_vfprintf_r+0x1e28>
80014406:	fa ca f9 78 	sub	r10,sp,-1672
8001440a:	02 9b       	mov	r11,r1
8001440c:	08 9c       	mov	r12,r4
8001440e:	fe b0 f0 e3 	rcall	800125d4 <__sprint_r>
80014412:	c6 e1       	brne	800144ee <_vfprintf_r+0x1efe>
80014414:	fa c3 f9 e0 	sub	r3,sp,-1568
80014418:	e2 15 00 04 	andl	r5,0x4,COH
8001441c:	c3 f0       	breq	8001449a <_vfprintf_r+0x1eaa>
8001441e:	40 86       	lddsp	r6,sp[0x20]
80014420:	40 39       	lddsp	r9,sp[0xc]
80014422:	12 16       	sub	r6,r9
80014424:	58 06       	cp.w	r6,0
80014426:	e0 89 00 1a 	brgt	8001445a <_vfprintf_r+0x1e6a>
8001442a:	c3 88       	rjmp	8001449a <_vfprintf_r+0x1eaa>
8001442c:	2f 09       	sub	r9,-16
8001442e:	2f f8       	sub	r8,-1
80014430:	fb 49 06 90 	st.w	sp[1680],r9
80014434:	87 05       	st.w	r3[0x0],r5
80014436:	87 12       	st.w	r3[0x4],r2
80014438:	fb 48 06 8c 	st.w	sp[1676],r8
8001443c:	58 78       	cp.w	r8,7
8001443e:	e0 89 00 04 	brgt	80014446 <_vfprintf_r+0x1e56>
80014442:	2f 83       	sub	r3,-8
80014444:	c0 98       	rjmp	80014456 <_vfprintf_r+0x1e66>
80014446:	00 9a       	mov	r10,r0
80014448:	02 9b       	mov	r11,r1
8001444a:	08 9c       	mov	r12,r4
8001444c:	fe b0 f0 c4 	rcall	800125d4 <__sprint_r>
80014450:	c4 f1       	brne	800144ee <_vfprintf_r+0x1efe>
80014452:	fa c3 f9 e0 	sub	r3,sp,-1568
80014456:	21 06       	sub	r6,16
80014458:	c0 68       	rjmp	80014464 <_vfprintf_r+0x1e74>
8001445a:	fe c5 b7 6a 	sub	r5,pc,-18582
8001445e:	31 02       	mov	r2,16
80014460:	fa c0 f9 78 	sub	r0,sp,-1672
80014464:	fa f9 06 90 	ld.w	r9,sp[1680]
80014468:	fa f8 06 8c 	ld.w	r8,sp[1676]
8001446c:	fe ca b7 7c 	sub	r10,pc,-18564
80014470:	59 06       	cp.w	r6,16
80014472:	fe 99 ff dd 	brgt	8001442c <_vfprintf_r+0x1e3c>
80014476:	0c 09       	add	r9,r6
80014478:	2f f8       	sub	r8,-1
8001447a:	87 0a       	st.w	r3[0x0],r10
8001447c:	87 16       	st.w	r3[0x4],r6
8001447e:	fb 49 06 90 	st.w	sp[1680],r9
80014482:	fb 48 06 8c 	st.w	sp[1676],r8
80014486:	58 78       	cp.w	r8,7
80014488:	e0 8a 00 09 	brle	8001449a <_vfprintf_r+0x1eaa>
8001448c:	fa ca f9 78 	sub	r10,sp,-1672
80014490:	02 9b       	mov	r11,r1
80014492:	08 9c       	mov	r12,r4
80014494:	fe b0 f0 a0 	rcall	800125d4 <__sprint_r>
80014498:	c2 b1       	brne	800144ee <_vfprintf_r+0x1efe>
8001449a:	40 bc       	lddsp	r12,sp[0x2c]
8001449c:	40 36       	lddsp	r6,sp[0xc]
8001449e:	40 8e       	lddsp	lr,sp[0x20]
800144a0:	ec 0e 0c 48 	max	r8,r6,lr
800144a4:	10 0c       	add	r12,r8
800144a6:	50 bc       	stdsp	sp[0x2c],r12
800144a8:	fa f8 06 90 	ld.w	r8,sp[1680]
800144ac:	58 08       	cp.w	r8,0
800144ae:	c0 80       	breq	800144be <_vfprintf_r+0x1ece>
800144b0:	fa ca f9 78 	sub	r10,sp,-1672
800144b4:	02 9b       	mov	r11,r1
800144b6:	08 9c       	mov	r12,r4
800144b8:	fe b0 f0 8e 	rcall	800125d4 <__sprint_r>
800144bc:	c1 91       	brne	800144ee <_vfprintf_r+0x1efe>
800144be:	30 0b       	mov	r11,0
800144c0:	fa c3 f9 e0 	sub	r3,sp,-1568
800144c4:	fb 4b 06 8c 	st.w	sp[1676],r11
800144c8:	fe 9f f1 22 	bral	8001270c <_vfprintf_r+0x11c>
800144cc:	08 95       	mov	r5,r4
800144ce:	fa f8 06 90 	ld.w	r8,sp[1680]
800144d2:	58 08       	cp.w	r8,0
800144d4:	c0 80       	breq	800144e4 <_vfprintf_r+0x1ef4>
800144d6:	08 9c       	mov	r12,r4
800144d8:	fa ca f9 78 	sub	r10,sp,-1672
800144dc:	02 9b       	mov	r11,r1
800144de:	fe b0 f0 7b 	rcall	800125d4 <__sprint_r>
800144e2:	c0 61       	brne	800144ee <_vfprintf_r+0x1efe>
800144e4:	30 08       	mov	r8,0
800144e6:	fb 48 06 8c 	st.w	sp[1676],r8
800144ea:	c0 28       	rjmp	800144ee <_vfprintf_r+0x1efe>
800144ec:	40 41       	lddsp	r1,sp[0x10]
800144ee:	82 68       	ld.sh	r8,r1[0xc]
800144f0:	ed b8 00 06 	bld	r8,0x6
800144f4:	c0 31       	brne	800144fa <_vfprintf_r+0x1f0a>
800144f6:	3f fa       	mov	r10,-1
800144f8:	50 ba       	stdsp	sp[0x2c],r10
800144fa:	40 bc       	lddsp	r12,sp[0x2c]
800144fc:	fe 3d f9 44 	sub	sp,-1724
80014500:	d8 32       	popm	r0-r7,pc
80014502:	d7 03       	nop

80014504 <__swsetup_r>:
80014504:	d4 21       	pushm	r4-r7,lr
80014506:	e0 68 01 4c 	mov	r8,332
8001450a:	18 96       	mov	r6,r12
8001450c:	16 97       	mov	r7,r11
8001450e:	70 0c       	ld.w	r12,r8[0x0]
80014510:	58 0c       	cp.w	r12,0
80014512:	c0 60       	breq	8001451e <__swsetup_r+0x1a>
80014514:	78 68       	ld.w	r8,r12[0x18]
80014516:	58 08       	cp.w	r8,0
80014518:	c0 31       	brne	8001451e <__swsetup_r+0x1a>
8001451a:	e0 a0 07 c7 	rcall	800154a8 <__sinit>
8001451e:	fe c8 b6 fe 	sub	r8,pc,-18690
80014522:	10 37       	cp.w	r7,r8
80014524:	c0 61       	brne	80014530 <__swsetup_r+0x2c>
80014526:	e0 68 01 4c 	mov	r8,332
8001452a:	70 08       	ld.w	r8,r8[0x0]
8001452c:	70 07       	ld.w	r7,r8[0x0]
8001452e:	c1 28       	rjmp	80014552 <__swsetup_r+0x4e>
80014530:	fe c8 b6 f0 	sub	r8,pc,-18704
80014534:	10 37       	cp.w	r7,r8
80014536:	c0 61       	brne	80014542 <__swsetup_r+0x3e>
80014538:	e0 68 01 4c 	mov	r8,332
8001453c:	70 08       	ld.w	r8,r8[0x0]
8001453e:	70 17       	ld.w	r7,r8[0x4]
80014540:	c0 98       	rjmp	80014552 <__swsetup_r+0x4e>
80014542:	fe c8 b6 e2 	sub	r8,pc,-18718
80014546:	10 37       	cp.w	r7,r8
80014548:	c0 51       	brne	80014552 <__swsetup_r+0x4e>
8001454a:	e0 68 01 4c 	mov	r8,332
8001454e:	70 08       	ld.w	r8,r8[0x0]
80014550:	70 27       	ld.w	r7,r8[0x8]
80014552:	8e 68       	ld.sh	r8,r7[0xc]
80014554:	ed b8 00 03 	bld	r8,0x3
80014558:	c1 e0       	breq	80014594 <__swsetup_r+0x90>
8001455a:	ed b8 00 04 	bld	r8,0x4
8001455e:	c3 e1       	brne	800145da <__swsetup_r+0xd6>
80014560:	ed b8 00 02 	bld	r8,0x2
80014564:	c1 51       	brne	8001458e <__swsetup_r+0x8a>
80014566:	6e db       	ld.w	r11,r7[0x34]
80014568:	58 0b       	cp.w	r11,0
8001456a:	c0 a0       	breq	8001457e <__swsetup_r+0x7a>
8001456c:	ee c8 ff bc 	sub	r8,r7,-68
80014570:	10 3b       	cp.w	r11,r8
80014572:	c0 40       	breq	8001457a <__swsetup_r+0x76>
80014574:	0c 9c       	mov	r12,r6
80014576:	e0 a0 08 33 	rcall	800155dc <_free_r>
8001457a:	30 08       	mov	r8,0
8001457c:	8f d8       	st.w	r7[0x34],r8
8001457e:	8e 68       	ld.sh	r8,r7[0xc]
80014580:	e0 18 ff db 	andl	r8,0xffdb
80014584:	ae 68       	st.h	r7[0xc],r8
80014586:	30 08       	mov	r8,0
80014588:	8f 18       	st.w	r7[0x4],r8
8001458a:	6e 48       	ld.w	r8,r7[0x10]
8001458c:	8f 08       	st.w	r7[0x0],r8
8001458e:	8e 68       	ld.sh	r8,r7[0xc]
80014590:	a3 b8       	sbr	r8,0x3
80014592:	ae 68       	st.h	r7[0xc],r8
80014594:	6e 48       	ld.w	r8,r7[0x10]
80014596:	58 08       	cp.w	r8,0
80014598:	c0 b1       	brne	800145ae <__swsetup_r+0xaa>
8001459a:	8e 68       	ld.sh	r8,r7[0xc]
8001459c:	e2 18 02 80 	andl	r8,0x280,COH
800145a0:	e0 48 02 00 	cp.w	r8,512
800145a4:	c0 50       	breq	800145ae <__swsetup_r+0xaa>
800145a6:	0c 9c       	mov	r12,r6
800145a8:	0e 9b       	mov	r11,r7
800145aa:	e0 a0 0a 53 	rcall	80015a50 <__smakebuf_r>
800145ae:	8e 69       	ld.sh	r9,r7[0xc]
800145b0:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
800145b4:	c0 70       	breq	800145c2 <__swsetup_r+0xbe>
800145b6:	30 08       	mov	r8,0
800145b8:	8f 28       	st.w	r7[0x8],r8
800145ba:	6e 58       	ld.w	r8,r7[0x14]
800145bc:	5c 38       	neg	r8
800145be:	8f 68       	st.w	r7[0x18],r8
800145c0:	c0 68       	rjmp	800145cc <__swsetup_r+0xc8>
800145c2:	ed b9 00 01 	bld	r9,0x1
800145c6:	ef f8 10 05 	ld.wne	r8,r7[0x14]
800145ca:	8f 28       	st.w	r7[0x8],r8
800145cc:	6e 48       	ld.w	r8,r7[0x10]
800145ce:	58 08       	cp.w	r8,0
800145d0:	c0 61       	brne	800145dc <__swsetup_r+0xd8>
800145d2:	8e 68       	ld.sh	r8,r7[0xc]
800145d4:	ed b8 00 07 	bld	r8,0x7
800145d8:	c0 21       	brne	800145dc <__swsetup_r+0xd8>
800145da:	dc 2a       	popm	r4-r7,pc,r12=-1
800145dc:	d8 2a       	popm	r4-r7,pc,r12=0
800145de:	d7 03       	nop

800145e0 <abort>:
800145e0:	d4 01       	pushm	lr
800145e2:	30 6c       	mov	r12,6
800145e4:	e0 a0 0d f2 	rcall	800161c8 <raise>
800145e8:	30 1c       	mov	r12,1
800145ea:	fe b0 e0 f8 	rcall	800107da <_exit>
800145ee:	d7 03       	nop

800145f0 <quorem>:
800145f0:	d4 31       	pushm	r0-r7,lr
800145f2:	20 2d       	sub	sp,8
800145f4:	18 97       	mov	r7,r12
800145f6:	78 48       	ld.w	r8,r12[0x10]
800145f8:	76 46       	ld.w	r6,r11[0x10]
800145fa:	0c 38       	cp.w	r8,r6
800145fc:	c0 34       	brge	80014602 <quorem+0x12>
800145fe:	30 0c       	mov	r12,0
80014600:	c8 58       	rjmp	8001470a <quorem+0x11a>
80014602:	ec c2 ff fc 	sub	r2,r6,-4
80014606:	f6 c3 ff ec 	sub	r3,r11,-20
8001460a:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8001460e:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80014612:	2f f9       	sub	r9,-1
80014614:	20 16       	sub	r6,1
80014616:	f8 09 0d 08 	divu	r8,r12,r9
8001461a:	f6 02 00 22 	add	r2,r11,r2<<0x2
8001461e:	ee c4 ff ec 	sub	r4,r7,-20
80014622:	10 95       	mov	r5,r8
80014624:	58 08       	cp.w	r8,0
80014626:	c4 10       	breq	800146a8 <quorem+0xb8>
80014628:	30 09       	mov	r9,0
8001462a:	06 9a       	mov	r10,r3
8001462c:	08 98       	mov	r8,r4
8001462e:	12 91       	mov	r1,r9
80014630:	50 0b       	stdsp	sp[0x0],r11
80014632:	70 0e       	ld.w	lr,r8[0x0]
80014634:	b1 8e       	lsr	lr,0x10
80014636:	50 1e       	stdsp	sp[0x4],lr
80014638:	15 0e       	ld.w	lr,r10++
8001463a:	fc 00 16 10 	lsr	r0,lr,0x10
8001463e:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80014642:	ea 0e 03 41 	mac	r1,r5,lr
80014646:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8001464a:	b1 81       	lsr	r1,0x10
8001464c:	40 1b       	lddsp	r11,sp[0x4]
8001464e:	ea 00 02 40 	mul	r0,r5,r0
80014652:	e2 00 00 00 	add	r0,r1,r0
80014656:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8001465a:	02 1b       	sub	r11,r1
8001465c:	50 1b       	stdsp	sp[0x4],r11
8001465e:	70 0b       	ld.w	r11,r8[0x0]
80014660:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80014664:	02 09       	add	r9,r1
80014666:	f2 0e 01 0e 	sub	lr,r9,lr
8001466a:	b0 1e       	st.h	r8[0x2],lr
8001466c:	fc 09 14 10 	asr	r9,lr,0x10
80014670:	40 1e       	lddsp	lr,sp[0x4]
80014672:	fc 09 00 09 	add	r9,lr,r9
80014676:	b0 09       	st.h	r8[0x0],r9
80014678:	e0 01 16 10 	lsr	r1,r0,0x10
8001467c:	2f c8       	sub	r8,-4
8001467e:	b1 49       	asr	r9,0x10
80014680:	04 3a       	cp.w	r10,r2
80014682:	fe 98 ff d8 	brls	80014632 <quorem+0x42>
80014686:	40 0b       	lddsp	r11,sp[0x0]
80014688:	58 0c       	cp.w	r12,0
8001468a:	c0 f1       	brne	800146a8 <quorem+0xb8>
8001468c:	ec c8 ff fb 	sub	r8,r6,-5
80014690:	ee 08 00 28 	add	r8,r7,r8<<0x2
80014694:	c0 28       	rjmp	80014698 <quorem+0xa8>
80014696:	20 16       	sub	r6,1
80014698:	20 48       	sub	r8,4
8001469a:	08 38       	cp.w	r8,r4
8001469c:	e0 88 00 05 	brls	800146a6 <quorem+0xb6>
800146a0:	70 09       	ld.w	r9,r8[0x0]
800146a2:	58 09       	cp.w	r9,0
800146a4:	cf 90       	breq	80014696 <quorem+0xa6>
800146a6:	8f 46       	st.w	r7[0x10],r6
800146a8:	0e 9c       	mov	r12,r7
800146aa:	e0 a0 0a d2 	rcall	80015c4e <__mcmp>
800146ae:	c2 d5       	brlt	80014708 <quorem+0x118>
800146b0:	2f f5       	sub	r5,-1
800146b2:	08 98       	mov	r8,r4
800146b4:	30 09       	mov	r9,0
800146b6:	07 0b       	ld.w	r11,r3++
800146b8:	f6 0a 16 10 	lsr	r10,r11,0x10
800146bc:	70 0c       	ld.w	r12,r8[0x0]
800146be:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
800146c2:	f8 0e 16 10 	lsr	lr,r12,0x10
800146c6:	14 1e       	sub	lr,r10
800146c8:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
800146cc:	16 1a       	sub	r10,r11
800146ce:	12 0a       	add	r10,r9
800146d0:	b0 1a       	st.h	r8[0x2],r10
800146d2:	b1 4a       	asr	r10,0x10
800146d4:	fc 0a 00 09 	add	r9,lr,r10
800146d8:	b0 09       	st.h	r8[0x0],r9
800146da:	2f c8       	sub	r8,-4
800146dc:	b1 49       	asr	r9,0x10
800146de:	04 33       	cp.w	r3,r2
800146e0:	fe 98 ff eb 	brls	800146b6 <quorem+0xc6>
800146e4:	ec c8 ff fb 	sub	r8,r6,-5
800146e8:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
800146ec:	58 09       	cp.w	r9,0
800146ee:	c0 d1       	brne	80014708 <quorem+0x118>
800146f0:	ee 08 00 28 	add	r8,r7,r8<<0x2
800146f4:	c0 28       	rjmp	800146f8 <quorem+0x108>
800146f6:	20 16       	sub	r6,1
800146f8:	20 48       	sub	r8,4
800146fa:	08 38       	cp.w	r8,r4
800146fc:	e0 88 00 05 	brls	80014706 <quorem+0x116>
80014700:	70 09       	ld.w	r9,r8[0x0]
80014702:	58 09       	cp.w	r9,0
80014704:	cf 90       	breq	800146f6 <quorem+0x106>
80014706:	8f 46       	st.w	r7[0x10],r6
80014708:	0a 9c       	mov	r12,r5
8001470a:	2f ed       	sub	sp,-8
8001470c:	d8 32       	popm	r0-r7,pc
8001470e:	d7 03       	nop

80014710 <_dtoa_r>:
80014710:	d4 31       	pushm	r0-r7,lr
80014712:	21 ad       	sub	sp,104
80014714:	fa c4 ff 74 	sub	r4,sp,-140
80014718:	18 97       	mov	r7,r12
8001471a:	16 95       	mov	r5,r11
8001471c:	68 2c       	ld.w	r12,r4[0x8]
8001471e:	50 c9       	stdsp	sp[0x30],r9
80014720:	68 16       	ld.w	r6,r4[0x4]
80014722:	68 09       	ld.w	r9,r4[0x0]
80014724:	50 e8       	stdsp	sp[0x38],r8
80014726:	14 94       	mov	r4,r10
80014728:	51 2c       	stdsp	sp[0x48],r12
8001472a:	fa e5 00 08 	st.d	sp[8],r4
8001472e:	51 59       	stdsp	sp[0x54],r9
80014730:	6e 95       	ld.w	r5,r7[0x24]
80014732:	58 05       	cp.w	r5,0
80014734:	c0 91       	brne	80014746 <_dtoa_r+0x36>
80014736:	31 0c       	mov	r12,16
80014738:	fe b0 db e2 	rcall	8000fefc <malloc>
8001473c:	99 35       	st.w	r12[0xc],r5
8001473e:	8f 9c       	st.w	r7[0x24],r12
80014740:	99 15       	st.w	r12[0x4],r5
80014742:	99 25       	st.w	r12[0x8],r5
80014744:	99 05       	st.w	r12[0x0],r5
80014746:	6e 99       	ld.w	r9,r7[0x24]
80014748:	72 08       	ld.w	r8,r9[0x0]
8001474a:	58 08       	cp.w	r8,0
8001474c:	c0 f0       	breq	8001476a <_dtoa_r+0x5a>
8001474e:	72 1a       	ld.w	r10,r9[0x4]
80014750:	91 1a       	st.w	r8[0x4],r10
80014752:	30 1a       	mov	r10,1
80014754:	72 19       	ld.w	r9,r9[0x4]
80014756:	f4 09 09 49 	lsl	r9,r10,r9
8001475a:	10 9b       	mov	r11,r8
8001475c:	91 29       	st.w	r8[0x8],r9
8001475e:	0e 9c       	mov	r12,r7
80014760:	e0 a0 0a 90 	rcall	80015c80 <_Bfree>
80014764:	6e 98       	ld.w	r8,r7[0x24]
80014766:	30 09       	mov	r9,0
80014768:	91 09       	st.w	r8[0x0],r9
8001476a:	40 28       	lddsp	r8,sp[0x8]
8001476c:	10 94       	mov	r4,r8
8001476e:	58 08       	cp.w	r8,0
80014770:	c0 64       	brge	8001477c <_dtoa_r+0x6c>
80014772:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80014776:	50 28       	stdsp	sp[0x8],r8
80014778:	30 18       	mov	r8,1
8001477a:	c0 28       	rjmp	8001477e <_dtoa_r+0x6e>
8001477c:	30 08       	mov	r8,0
8001477e:	8d 08       	st.w	r6[0x0],r8
80014780:	fc 1c 7f f0 	movh	r12,0x7ff0
80014784:	40 26       	lddsp	r6,sp[0x8]
80014786:	0c 98       	mov	r8,r6
80014788:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8001478c:	18 38       	cp.w	r8,r12
8001478e:	c2 01       	brne	800147ce <_dtoa_r+0xbe>
80014790:	e0 68 27 0f 	mov	r8,9999
80014794:	41 5b       	lddsp	r11,sp[0x54]
80014796:	97 08       	st.w	r11[0x0],r8
80014798:	40 3a       	lddsp	r10,sp[0xc]
8001479a:	58 0a       	cp.w	r10,0
8001479c:	c0 71       	brne	800147aa <_dtoa_r+0x9a>
8001479e:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
800147a2:	c0 41       	brne	800147aa <_dtoa_r+0x9a>
800147a4:	fe cc b9 94 	sub	r12,pc,-18028
800147a8:	c0 38       	rjmp	800147ae <_dtoa_r+0x9e>
800147aa:	fe cc b9 8e 	sub	r12,pc,-18034
800147ae:	41 29       	lddsp	r9,sp[0x48]
800147b0:	58 09       	cp.w	r9,0
800147b2:	e0 80 05 9a 	breq	800152e6 <_dtoa_r+0xbd6>
800147b6:	f8 c8 ff fd 	sub	r8,r12,-3
800147ba:	f8 c9 ff f8 	sub	r9,r12,-8
800147be:	11 8b       	ld.ub	r11,r8[0x0]
800147c0:	30 0a       	mov	r10,0
800147c2:	41 25       	lddsp	r5,sp[0x48]
800147c4:	f4 0b 18 00 	cp.b	r11,r10
800147c8:	f2 08 17 10 	movne	r8,r9
800147cc:	c1 68       	rjmp	800147f8 <_dtoa_r+0xe8>
800147ce:	fa ea 00 08 	ld.d	r10,sp[8]
800147d2:	30 08       	mov	r8,0
800147d4:	fa eb 00 3c 	st.d	sp[60],r10
800147d8:	30 09       	mov	r9,0
800147da:	e0 a0 0e 3b 	rcall	80016450 <__avr32_f64_cmp_eq>
800147de:	c1 00       	breq	800147fe <_dtoa_r+0xee>
800147e0:	30 18       	mov	r8,1
800147e2:	41 5a       	lddsp	r10,sp[0x54]
800147e4:	95 08       	st.w	r10[0x0],r8
800147e6:	fe cc ba fa 	sub	r12,pc,-17670
800147ea:	41 29       	lddsp	r9,sp[0x48]
800147ec:	f8 08 00 08 	add	r8,r12,r8
800147f0:	58 09       	cp.w	r9,0
800147f2:	e0 80 05 7a 	breq	800152e6 <_dtoa_r+0xbd6>
800147f6:	12 95       	mov	r5,r9
800147f8:	8b 08       	st.w	r5[0x0],r8
800147fa:	e0 8f 05 76 	bral	800152e6 <_dtoa_r+0xbd6>
800147fe:	fa c8 ff 9c 	sub	r8,sp,-100
80014802:	fa c9 ff a0 	sub	r9,sp,-96
80014806:	fa ea 00 3c 	ld.d	r10,sp[60]
8001480a:	0e 9c       	mov	r12,r7
8001480c:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80014810:	e0 a0 0a 8a 	rcall	80015d24 <__d2b>
80014814:	18 93       	mov	r3,r12
80014816:	58 05       	cp.w	r5,0
80014818:	c0 d0       	breq	80014832 <_dtoa_r+0x122>
8001481a:	fa ea 00 3c 	ld.d	r10,sp[60]
8001481e:	30 04       	mov	r4,0
80014820:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80014824:	ea c5 03 ff 	sub	r5,r5,1023
80014828:	10 9b       	mov	r11,r8
8001482a:	51 74       	stdsp	sp[0x5c],r4
8001482c:	ea 1b 3f f0 	orh	r11,0x3ff0
80014830:	c2 58       	rjmp	8001487a <_dtoa_r+0x16a>
80014832:	41 88       	lddsp	r8,sp[0x60]
80014834:	41 9c       	lddsp	r12,sp[0x64]
80014836:	10 0c       	add	r12,r8
80014838:	f8 c5 fb ce 	sub	r5,r12,-1074
8001483c:	e0 45 00 20 	cp.w	r5,32
80014840:	e0 8a 00 0e 	brle	8001485c <_dtoa_r+0x14c>
80014844:	f8 cc fb ee 	sub	r12,r12,-1042
80014848:	40 3b       	lddsp	r11,sp[0xc]
8001484a:	ea 08 11 40 	rsub	r8,r5,64
8001484e:	f6 0c 0a 4c 	lsr	r12,r11,r12
80014852:	ec 08 09 46 	lsl	r6,r6,r8
80014856:	0c 4c       	or	r12,r6
80014858:	c0 78       	rjmp	80014866 <_dtoa_r+0x156>
8001485a:	d7 03       	nop
8001485c:	ea 0c 11 20 	rsub	r12,r5,32
80014860:	40 3a       	lddsp	r10,sp[0xc]
80014862:	f4 0c 09 4c 	lsl	r12,r10,r12
80014866:	fe b0 d9 76 	rcall	8000fb52 <__avr32_u32_to_f64>
8001486a:	fc 18 fe 10 	movh	r8,0xfe10
8001486e:	30 19       	mov	r9,1
80014870:	ea c5 04 33 	sub	r5,r5,1075
80014874:	f0 0b 00 0b 	add	r11,r8,r11
80014878:	51 79       	stdsp	sp[0x5c],r9
8001487a:	30 08       	mov	r8,0
8001487c:	fc 19 3f f8 	movh	r9,0x3ff8
80014880:	fe b0 d7 fe 	rcall	8000f87c <__avr32_f64_sub>
80014884:	e0 68 43 61 	mov	r8,17249
80014888:	ea 18 63 6f 	orh	r8,0x636f
8001488c:	e0 69 87 a7 	mov	r9,34727
80014890:	ea 19 3f d2 	orh	r9,0x3fd2
80014894:	fe b0 d7 08 	rcall	8000f6a4 <__avr32_f64_mul>
80014898:	e0 68 c8 b3 	mov	r8,51379
8001489c:	ea 18 8b 60 	orh	r8,0x8b60
800148a0:	e0 69 8a 28 	mov	r9,35368
800148a4:	ea 19 3f c6 	orh	r9,0x3fc6
800148a8:	fe b0 d8 b8 	rcall	8000fa18 <__avr32_f64_add>
800148ac:	0a 9c       	mov	r12,r5
800148ae:	14 90       	mov	r0,r10
800148b0:	16 91       	mov	r1,r11
800148b2:	fe b0 d9 54 	rcall	8000fb5a <__avr32_s32_to_f64>
800148b6:	e0 68 79 fb 	mov	r8,31227
800148ba:	ea 18 50 9f 	orh	r8,0x509f
800148be:	e0 69 44 13 	mov	r9,17427
800148c2:	ea 19 3f d3 	orh	r9,0x3fd3
800148c6:	fe b0 d6 ef 	rcall	8000f6a4 <__avr32_f64_mul>
800148ca:	14 98       	mov	r8,r10
800148cc:	16 99       	mov	r9,r11
800148ce:	00 9a       	mov	r10,r0
800148d0:	02 9b       	mov	r11,r1
800148d2:	fe b0 d8 a3 	rcall	8000fa18 <__avr32_f64_add>
800148d6:	14 90       	mov	r0,r10
800148d8:	16 91       	mov	r1,r11
800148da:	fe b0 d9 29 	rcall	8000fb2c <__avr32_f64_to_s32>
800148de:	30 08       	mov	r8,0
800148e0:	18 96       	mov	r6,r12
800148e2:	30 09       	mov	r9,0
800148e4:	00 9a       	mov	r10,r0
800148e6:	02 9b       	mov	r11,r1
800148e8:	e0 a0 0d fb 	rcall	800164de <__avr32_f64_cmp_lt>
800148ec:	c0 c0       	breq	80014904 <_dtoa_r+0x1f4>
800148ee:	0c 9c       	mov	r12,r6
800148f0:	fe b0 d9 35 	rcall	8000fb5a <__avr32_s32_to_f64>
800148f4:	14 98       	mov	r8,r10
800148f6:	16 99       	mov	r9,r11
800148f8:	00 9a       	mov	r10,r0
800148fa:	02 9b       	mov	r11,r1
800148fc:	e0 a0 0d aa 	rcall	80016450 <__avr32_f64_cmp_eq>
80014900:	f7 b6 00 01 	subeq	r6,1
80014904:	59 66       	cp.w	r6,22
80014906:	e0 88 00 05 	brls	80014910 <_dtoa_r+0x200>
8001490a:	30 18       	mov	r8,1
8001490c:	51 48       	stdsp	sp[0x50],r8
8001490e:	c1 38       	rjmp	80014934 <_dtoa_r+0x224>
80014910:	fe c8 ba 44 	sub	r8,pc,-17852
80014914:	fa ea 00 3c 	ld.d	r10,sp[60]
80014918:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8001491c:	e0 a0 0d e1 	rcall	800164de <__avr32_f64_cmp_lt>
80014920:	f9 b4 00 00 	moveq	r4,0
80014924:	fb f4 0a 14 	st.weq	sp[0x50],r4
80014928:	f7 b6 01 01 	subne	r6,1
8001492c:	f9 bc 01 00 	movne	r12,0
80014930:	fb fc 1a 14 	st.wne	sp[0x50],r12
80014934:	41 90       	lddsp	r0,sp[0x64]
80014936:	20 10       	sub	r0,1
80014938:	0a 10       	sub	r0,r5
8001493a:	c0 46       	brmi	80014942 <_dtoa_r+0x232>
8001493c:	50 40       	stdsp	sp[0x10],r0
8001493e:	30 00       	mov	r0,0
80014940:	c0 48       	rjmp	80014948 <_dtoa_r+0x238>
80014942:	30 0b       	mov	r11,0
80014944:	5c 30       	neg	r0
80014946:	50 4b       	stdsp	sp[0x10],r11
80014948:	ec 02 11 00 	rsub	r2,r6,0
8001494c:	58 06       	cp.w	r6,0
8001494e:	fb fa 40 04 	ld.wge	r10,sp[0x10]
80014952:	f5 d6 e4 0a 	addge	r10,r10,r6
80014956:	fb fa 4a 04 	st.wge	sp[0x10],r10
8001495a:	fb f6 4a 11 	st.wge	sp[0x44],r6
8001495e:	f9 b2 04 00 	movge	r2,0
80014962:	e1 d6 e5 10 	sublt	r0,r0,r6
80014966:	f9 b9 05 00 	movlt	r9,0
8001496a:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8001496e:	40 c8       	lddsp	r8,sp[0x30]
80014970:	58 98       	cp.w	r8,9
80014972:	e0 8b 00 20 	brhi	800149b2 <_dtoa_r+0x2a2>
80014976:	58 58       	cp.w	r8,5
80014978:	f9 b4 0a 01 	movle	r4,1
8001497c:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80014980:	f7 b5 09 04 	subgt	r5,4
80014984:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80014988:	f9 b4 09 00 	movgt	r4,0
8001498c:	40 cc       	lddsp	r12,sp[0x30]
8001498e:	58 3c       	cp.w	r12,3
80014990:	c2 d0       	breq	800149ea <_dtoa_r+0x2da>
80014992:	e0 89 00 05 	brgt	8001499c <_dtoa_r+0x28c>
80014996:	58 2c       	cp.w	r12,2
80014998:	c1 01       	brne	800149b8 <_dtoa_r+0x2a8>
8001499a:	c1 88       	rjmp	800149ca <_dtoa_r+0x2ba>
8001499c:	40 cb       	lddsp	r11,sp[0x30]
8001499e:	58 4b       	cp.w	r11,4
800149a0:	c0 60       	breq	800149ac <_dtoa_r+0x29c>
800149a2:	58 5b       	cp.w	r11,5
800149a4:	c0 a1       	brne	800149b8 <_dtoa_r+0x2a8>
800149a6:	30 1a       	mov	r10,1
800149a8:	50 da       	stdsp	sp[0x34],r10
800149aa:	c2 28       	rjmp	800149ee <_dtoa_r+0x2de>
800149ac:	30 19       	mov	r9,1
800149ae:	50 d9       	stdsp	sp[0x34],r9
800149b0:	c0 f8       	rjmp	800149ce <_dtoa_r+0x2be>
800149b2:	30 08       	mov	r8,0
800149b4:	30 14       	mov	r4,1
800149b6:	50 c8       	stdsp	sp[0x30],r8
800149b8:	3f f5       	mov	r5,-1
800149ba:	30 1c       	mov	r12,1
800149bc:	30 0b       	mov	r11,0
800149be:	50 95       	stdsp	sp[0x24],r5
800149c0:	50 dc       	stdsp	sp[0x34],r12
800149c2:	0a 91       	mov	r1,r5
800149c4:	31 28       	mov	r8,18
800149c6:	50 eb       	stdsp	sp[0x38],r11
800149c8:	c2 08       	rjmp	80014a08 <_dtoa_r+0x2f8>
800149ca:	30 0a       	mov	r10,0
800149cc:	50 da       	stdsp	sp[0x34],r10
800149ce:	40 e9       	lddsp	r9,sp[0x38]
800149d0:	58 09       	cp.w	r9,0
800149d2:	e0 89 00 07 	brgt	800149e0 <_dtoa_r+0x2d0>
800149d6:	30 18       	mov	r8,1
800149d8:	50 98       	stdsp	sp[0x24],r8
800149da:	10 91       	mov	r1,r8
800149dc:	50 e8       	stdsp	sp[0x38],r8
800149de:	c1 58       	rjmp	80014a08 <_dtoa_r+0x2f8>
800149e0:	40 e5       	lddsp	r5,sp[0x38]
800149e2:	50 95       	stdsp	sp[0x24],r5
800149e4:	0a 91       	mov	r1,r5
800149e6:	0a 98       	mov	r8,r5
800149e8:	c1 08       	rjmp	80014a08 <_dtoa_r+0x2f8>
800149ea:	30 0c       	mov	r12,0
800149ec:	50 dc       	stdsp	sp[0x34],r12
800149ee:	40 eb       	lddsp	r11,sp[0x38]
800149f0:	ec 0b 00 0b 	add	r11,r6,r11
800149f4:	50 9b       	stdsp	sp[0x24],r11
800149f6:	16 98       	mov	r8,r11
800149f8:	2f f8       	sub	r8,-1
800149fa:	58 08       	cp.w	r8,0
800149fc:	e0 89 00 05 	brgt	80014a06 <_dtoa_r+0x2f6>
80014a00:	10 91       	mov	r1,r8
80014a02:	30 18       	mov	r8,1
80014a04:	c0 28       	rjmp	80014a08 <_dtoa_r+0x2f8>
80014a06:	10 91       	mov	r1,r8
80014a08:	30 09       	mov	r9,0
80014a0a:	6e 9a       	ld.w	r10,r7[0x24]
80014a0c:	95 19       	st.w	r10[0x4],r9
80014a0e:	30 49       	mov	r9,4
80014a10:	c0 68       	rjmp	80014a1c <_dtoa_r+0x30c>
80014a12:	d7 03       	nop
80014a14:	6a 1a       	ld.w	r10,r5[0x4]
80014a16:	a1 79       	lsl	r9,0x1
80014a18:	2f fa       	sub	r10,-1
80014a1a:	8b 1a       	st.w	r5[0x4],r10
80014a1c:	6e 95       	ld.w	r5,r7[0x24]
80014a1e:	f2 ca ff ec 	sub	r10,r9,-20
80014a22:	10 3a       	cp.w	r10,r8
80014a24:	fe 98 ff f8 	brls	80014a14 <_dtoa_r+0x304>
80014a28:	6a 1b       	ld.w	r11,r5[0x4]
80014a2a:	0e 9c       	mov	r12,r7
80014a2c:	e0 a0 09 44 	rcall	80015cb4 <_Balloc>
80014a30:	58 e1       	cp.w	r1,14
80014a32:	5f 88       	srls	r8
80014a34:	8b 0c       	st.w	r5[0x0],r12
80014a36:	f1 e4 00 04 	and	r4,r8,r4
80014a3a:	6e 98       	ld.w	r8,r7[0x24]
80014a3c:	70 08       	ld.w	r8,r8[0x0]
80014a3e:	50 88       	stdsp	sp[0x20],r8
80014a40:	e0 80 01 82 	breq	80014d44 <_dtoa_r+0x634>
80014a44:	58 06       	cp.w	r6,0
80014a46:	e0 8a 00 43 	brle	80014acc <_dtoa_r+0x3bc>
80014a4a:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
80014a4e:	fe c8 bb 82 	sub	r8,pc,-17534
80014a52:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
80014a56:	fa e5 00 18 	st.d	sp[24],r4
80014a5a:	ec 04 14 04 	asr	r4,r6,0x4
80014a5e:	ed b4 00 04 	bld	r4,0x4
80014a62:	c0 30       	breq	80014a68 <_dtoa_r+0x358>
80014a64:	30 25       	mov	r5,2
80014a66:	c1 08       	rjmp	80014a86 <_dtoa_r+0x376>
80014a68:	fe c8 ba d4 	sub	r8,pc,-17708
80014a6c:	f0 e8 00 20 	ld.d	r8,r8[32]
80014a70:	fa ea 00 3c 	ld.d	r10,sp[60]
80014a74:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80014a78:	e0 a0 0d 68 	rcall	80016548 <__avr32_f64_div>
80014a7c:	30 35       	mov	r5,3
80014a7e:	14 98       	mov	r8,r10
80014a80:	16 99       	mov	r9,r11
80014a82:	fa e9 00 08 	st.d	sp[8],r8
80014a86:	fe cc ba f2 	sub	r12,pc,-17678
80014a8a:	50 a3       	stdsp	sp[0x28],r3
80014a8c:	0c 93       	mov	r3,r6
80014a8e:	18 96       	mov	r6,r12
80014a90:	c0 f8       	rjmp	80014aae <_dtoa_r+0x39e>
80014a92:	fa ea 00 18 	ld.d	r10,sp[24]
80014a96:	ed b4 00 00 	bld	r4,0x0
80014a9a:	c0 81       	brne	80014aaa <_dtoa_r+0x39a>
80014a9c:	ec e8 00 00 	ld.d	r8,r6[0]
80014aa0:	2f f5       	sub	r5,-1
80014aa2:	fe b0 d6 01 	rcall	8000f6a4 <__avr32_f64_mul>
80014aa6:	fa eb 00 18 	st.d	sp[24],r10
80014aaa:	a1 54       	asr	r4,0x1
80014aac:	2f 86       	sub	r6,-8
80014aae:	58 04       	cp.w	r4,0
80014ab0:	cf 11       	brne	80014a92 <_dtoa_r+0x382>
80014ab2:	fa e8 00 18 	ld.d	r8,sp[24]
80014ab6:	fa ea 00 08 	ld.d	r10,sp[8]
80014aba:	06 96       	mov	r6,r3
80014abc:	e0 a0 0d 46 	rcall	80016548 <__avr32_f64_div>
80014ac0:	40 a3       	lddsp	r3,sp[0x28]
80014ac2:	14 98       	mov	r8,r10
80014ac4:	16 99       	mov	r9,r11
80014ac6:	fa e9 00 08 	st.d	sp[8],r8
80014aca:	c2 f8       	rjmp	80014b28 <_dtoa_r+0x418>
80014acc:	ec 08 11 00 	rsub	r8,r6,0
80014ad0:	c0 31       	brne	80014ad6 <_dtoa_r+0x3c6>
80014ad2:	30 25       	mov	r5,2
80014ad4:	c2 a8       	rjmp	80014b28 <_dtoa_r+0x418>
80014ad6:	fe cc bb 42 	sub	r12,pc,-17598
80014ada:	f0 04 14 04 	asr	r4,r8,0x4
80014ade:	50 1c       	stdsp	sp[0x4],r12
80014ae0:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80014ae4:	fe c9 bc 18 	sub	r9,pc,-17384
80014ae8:	fa ea 00 3c 	ld.d	r10,sp[60]
80014aec:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80014af0:	fe b0 d5 da 	rcall	8000f6a4 <__avr32_f64_mul>
80014af4:	40 1c       	lddsp	r12,sp[0x4]
80014af6:	50 63       	stdsp	sp[0x18],r3
80014af8:	30 25       	mov	r5,2
80014afa:	0c 93       	mov	r3,r6
80014afc:	fa eb 00 08 	st.d	sp[8],r10
80014b00:	18 96       	mov	r6,r12
80014b02:	c0 f8       	rjmp	80014b20 <_dtoa_r+0x410>
80014b04:	fa ea 00 08 	ld.d	r10,sp[8]
80014b08:	ed b4 00 00 	bld	r4,0x0
80014b0c:	c0 81       	brne	80014b1c <_dtoa_r+0x40c>
80014b0e:	ec e8 00 00 	ld.d	r8,r6[0]
80014b12:	2f f5       	sub	r5,-1
80014b14:	fe b0 d5 c8 	rcall	8000f6a4 <__avr32_f64_mul>
80014b18:	fa eb 00 08 	st.d	sp[8],r10
80014b1c:	a1 54       	asr	r4,0x1
80014b1e:	2f 86       	sub	r6,-8
80014b20:	58 04       	cp.w	r4,0
80014b22:	cf 11       	brne	80014b04 <_dtoa_r+0x3f4>
80014b24:	06 96       	mov	r6,r3
80014b26:	40 63       	lddsp	r3,sp[0x18]
80014b28:	41 4a       	lddsp	r10,sp[0x50]
80014b2a:	58 0a       	cp.w	r10,0
80014b2c:	c2 a0       	breq	80014b80 <_dtoa_r+0x470>
80014b2e:	fa e8 00 08 	ld.d	r8,sp[8]
80014b32:	58 01       	cp.w	r1,0
80014b34:	5f 94       	srgt	r4
80014b36:	fa e9 00 18 	st.d	sp[24],r8
80014b3a:	30 08       	mov	r8,0
80014b3c:	fc 19 3f f0 	movh	r9,0x3ff0
80014b40:	fa ea 00 18 	ld.d	r10,sp[24]
80014b44:	e0 a0 0c cd 	rcall	800164de <__avr32_f64_cmp_lt>
80014b48:	f9 bc 00 00 	moveq	r12,0
80014b4c:	f9 bc 01 01 	movne	r12,1
80014b50:	e9 ec 00 0c 	and	r12,r4,r12
80014b54:	c1 60       	breq	80014b80 <_dtoa_r+0x470>
80014b56:	40 98       	lddsp	r8,sp[0x24]
80014b58:	58 08       	cp.w	r8,0
80014b5a:	e0 8a 00 f1 	brle	80014d3c <_dtoa_r+0x62c>
80014b5e:	30 08       	mov	r8,0
80014b60:	fc 19 40 24 	movh	r9,0x4024
80014b64:	ec c4 00 01 	sub	r4,r6,1
80014b68:	fa ea 00 18 	ld.d	r10,sp[24]
80014b6c:	2f f5       	sub	r5,-1
80014b6e:	50 64       	stdsp	sp[0x18],r4
80014b70:	fe b0 d5 9a 	rcall	8000f6a4 <__avr32_f64_mul>
80014b74:	40 94       	lddsp	r4,sp[0x24]
80014b76:	14 98       	mov	r8,r10
80014b78:	16 99       	mov	r9,r11
80014b7a:	fa e9 00 08 	st.d	sp[8],r8
80014b7e:	c0 38       	rjmp	80014b84 <_dtoa_r+0x474>
80014b80:	50 66       	stdsp	sp[0x18],r6
80014b82:	02 94       	mov	r4,r1
80014b84:	0a 9c       	mov	r12,r5
80014b86:	fe b0 d7 ea 	rcall	8000fb5a <__avr32_s32_to_f64>
80014b8a:	fa e8 00 08 	ld.d	r8,sp[8]
80014b8e:	fe b0 d5 8b 	rcall	8000f6a4 <__avr32_f64_mul>
80014b92:	30 08       	mov	r8,0
80014b94:	fc 19 40 1c 	movh	r9,0x401c
80014b98:	fe b0 d7 40 	rcall	8000fa18 <__avr32_f64_add>
80014b9c:	14 98       	mov	r8,r10
80014b9e:	16 99       	mov	r9,r11
80014ba0:	fa e9 00 28 	st.d	sp[40],r8
80014ba4:	fc 18 fc c0 	movh	r8,0xfcc0
80014ba8:	40 a5       	lddsp	r5,sp[0x28]
80014baa:	10 05       	add	r5,r8
80014bac:	50 a5       	stdsp	sp[0x28],r5
80014bae:	58 04       	cp.w	r4,0
80014bb0:	c2 11       	brne	80014bf2 <_dtoa_r+0x4e2>
80014bb2:	fa ea 00 08 	ld.d	r10,sp[8]
80014bb6:	30 08       	mov	r8,0
80014bb8:	fc 19 40 14 	movh	r9,0x4014
80014bbc:	fe b0 d6 60 	rcall	8000f87c <__avr32_f64_sub>
80014bc0:	40 bc       	lddsp	r12,sp[0x2c]
80014bc2:	fa eb 00 08 	st.d	sp[8],r10
80014bc6:	14 98       	mov	r8,r10
80014bc8:	16 99       	mov	r9,r11
80014bca:	18 9a       	mov	r10,r12
80014bcc:	0a 9b       	mov	r11,r5
80014bce:	e0 a0 0c 88 	rcall	800164de <__avr32_f64_cmp_lt>
80014bd2:	e0 81 02 54 	brne	8001507a <_dtoa_r+0x96a>
80014bd6:	0a 98       	mov	r8,r5
80014bd8:	40 b9       	lddsp	r9,sp[0x2c]
80014bda:	ee 18 80 00 	eorh	r8,0x8000
80014bde:	fa ea 00 08 	ld.d	r10,sp[8]
80014be2:	10 95       	mov	r5,r8
80014be4:	12 98       	mov	r8,r9
80014be6:	0a 99       	mov	r9,r5
80014be8:	e0 a0 0c 7b 	rcall	800164de <__avr32_f64_cmp_lt>
80014bec:	e0 81 02 3e 	brne	80015068 <_dtoa_r+0x958>
80014bf0:	ca 68       	rjmp	80014d3c <_dtoa_r+0x62c>
80014bf2:	fe c9 bd 26 	sub	r9,pc,-17114
80014bf6:	e8 c8 00 01 	sub	r8,r4,1
80014bfa:	40 d5       	lddsp	r5,sp[0x34]
80014bfc:	58 05       	cp.w	r5,0
80014bfe:	c4 f0       	breq	80014c9c <_dtoa_r+0x58c>
80014c00:	30 0c       	mov	r12,0
80014c02:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80014c06:	51 3c       	stdsp	sp[0x4c],r12
80014c08:	30 0a       	mov	r10,0
80014c0a:	fc 1b 3f e0 	movh	r11,0x3fe0
80014c0e:	e0 a0 0c 9d 	rcall	80016548 <__avr32_f64_div>
80014c12:	fa e8 00 28 	ld.d	r8,sp[40]
80014c16:	40 85       	lddsp	r5,sp[0x20]
80014c18:	fe b0 d6 32 	rcall	8000f87c <__avr32_f64_sub>
80014c1c:	fa eb 00 28 	st.d	sp[40],r10
80014c20:	fa ea 00 08 	ld.d	r10,sp[8]
80014c24:	fe b0 d7 84 	rcall	8000fb2c <__avr32_f64_to_s32>
80014c28:	51 6c       	stdsp	sp[0x58],r12
80014c2a:	fe b0 d7 98 	rcall	8000fb5a <__avr32_s32_to_f64>
80014c2e:	14 98       	mov	r8,r10
80014c30:	16 99       	mov	r9,r11
80014c32:	fa ea 00 08 	ld.d	r10,sp[8]
80014c36:	fe b0 d6 23 	rcall	8000f87c <__avr32_f64_sub>
80014c3a:	fa eb 00 08 	st.d	sp[8],r10
80014c3e:	41 68       	lddsp	r8,sp[0x58]
80014c40:	2d 08       	sub	r8,-48
80014c42:	0a c8       	st.b	r5++,r8
80014c44:	41 39       	lddsp	r9,sp[0x4c]
80014c46:	2f f9       	sub	r9,-1
80014c48:	51 39       	stdsp	sp[0x4c],r9
80014c4a:	fa e8 00 28 	ld.d	r8,sp[40]
80014c4e:	e0 a0 0c 48 	rcall	800164de <__avr32_f64_cmp_lt>
80014c52:	e0 81 03 39 	brne	800152c4 <_dtoa_r+0xbb4>
80014c56:	fa e8 00 08 	ld.d	r8,sp[8]
80014c5a:	30 0a       	mov	r10,0
80014c5c:	fc 1b 3f f0 	movh	r11,0x3ff0
80014c60:	fe b0 d6 0e 	rcall	8000f87c <__avr32_f64_sub>
80014c64:	fa e8 00 28 	ld.d	r8,sp[40]
80014c68:	e0 a0 0c 3b 	rcall	800164de <__avr32_f64_cmp_lt>
80014c6c:	fa ea 00 28 	ld.d	r10,sp[40]
80014c70:	30 08       	mov	r8,0
80014c72:	fc 19 40 24 	movh	r9,0x4024
80014c76:	e0 81 00 da 	brne	80014e2a <_dtoa_r+0x71a>
80014c7a:	41 3c       	lddsp	r12,sp[0x4c]
80014c7c:	08 3c       	cp.w	r12,r4
80014c7e:	c5 f4       	brge	80014d3c <_dtoa_r+0x62c>
80014c80:	fe b0 d5 12 	rcall	8000f6a4 <__avr32_f64_mul>
80014c84:	30 08       	mov	r8,0
80014c86:	fa eb 00 28 	st.d	sp[40],r10
80014c8a:	fc 19 40 24 	movh	r9,0x4024
80014c8e:	fa ea 00 08 	ld.d	r10,sp[8]
80014c92:	fe b0 d5 09 	rcall	8000f6a4 <__avr32_f64_mul>
80014c96:	fa eb 00 08 	st.d	sp[8],r10
80014c9a:	cc 3b       	rjmp	80014c20 <_dtoa_r+0x510>
80014c9c:	40 85       	lddsp	r5,sp[0x20]
80014c9e:	08 05       	add	r5,r4
80014ca0:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80014ca4:	51 35       	stdsp	sp[0x4c],r5
80014ca6:	fa e8 00 28 	ld.d	r8,sp[40]
80014caa:	40 85       	lddsp	r5,sp[0x20]
80014cac:	fe b0 d4 fc 	rcall	8000f6a4 <__avr32_f64_mul>
80014cb0:	fa eb 00 28 	st.d	sp[40],r10
80014cb4:	fa ea 00 08 	ld.d	r10,sp[8]
80014cb8:	fe b0 d7 3a 	rcall	8000fb2c <__avr32_f64_to_s32>
80014cbc:	51 6c       	stdsp	sp[0x58],r12
80014cbe:	fe b0 d7 4e 	rcall	8000fb5a <__avr32_s32_to_f64>
80014cc2:	14 98       	mov	r8,r10
80014cc4:	16 99       	mov	r9,r11
80014cc6:	fa ea 00 08 	ld.d	r10,sp[8]
80014cca:	fe b0 d5 d9 	rcall	8000f87c <__avr32_f64_sub>
80014cce:	fa eb 00 08 	st.d	sp[8],r10
80014cd2:	41 68       	lddsp	r8,sp[0x58]
80014cd4:	2d 08       	sub	r8,-48
80014cd6:	0a c8       	st.b	r5++,r8
80014cd8:	41 3c       	lddsp	r12,sp[0x4c]
80014cda:	18 35       	cp.w	r5,r12
80014cdc:	c2 81       	brne	80014d2c <_dtoa_r+0x61c>
80014cde:	30 08       	mov	r8,0
80014ce0:	fc 19 3f e0 	movh	r9,0x3fe0
80014ce4:	fa ea 00 28 	ld.d	r10,sp[40]
80014ce8:	fe b0 d6 98 	rcall	8000fa18 <__avr32_f64_add>
80014cec:	40 85       	lddsp	r5,sp[0x20]
80014cee:	fa e8 00 08 	ld.d	r8,sp[8]
80014cf2:	08 05       	add	r5,r4
80014cf4:	e0 a0 0b f5 	rcall	800164de <__avr32_f64_cmp_lt>
80014cf8:	e0 81 00 99 	brne	80014e2a <_dtoa_r+0x71a>
80014cfc:	fa e8 00 28 	ld.d	r8,sp[40]
80014d00:	30 0a       	mov	r10,0
80014d02:	fc 1b 3f e0 	movh	r11,0x3fe0
80014d06:	fe b0 d5 bb 	rcall	8000f87c <__avr32_f64_sub>
80014d0a:	14 98       	mov	r8,r10
80014d0c:	16 99       	mov	r9,r11
80014d0e:	fa ea 00 08 	ld.d	r10,sp[8]
80014d12:	e0 a0 0b e6 	rcall	800164de <__avr32_f64_cmp_lt>
80014d16:	c1 30       	breq	80014d3c <_dtoa_r+0x62c>
80014d18:	33 09       	mov	r9,48
80014d1a:	0a 98       	mov	r8,r5
80014d1c:	11 7a       	ld.ub	r10,--r8
80014d1e:	f2 0a 18 00 	cp.b	r10,r9
80014d22:	e0 81 02 d1 	brne	800152c4 <_dtoa_r+0xbb4>
80014d26:	10 95       	mov	r5,r8
80014d28:	cf 9b       	rjmp	80014d1a <_dtoa_r+0x60a>
80014d2a:	d7 03       	nop
80014d2c:	30 08       	mov	r8,0
80014d2e:	fc 19 40 24 	movh	r9,0x4024
80014d32:	fe b0 d4 b9 	rcall	8000f6a4 <__avr32_f64_mul>
80014d36:	fa eb 00 08 	st.d	sp[8],r10
80014d3a:	cb db       	rjmp	80014cb4 <_dtoa_r+0x5a4>
80014d3c:	fa ea 00 3c 	ld.d	r10,sp[60]
80014d40:	fa eb 00 08 	st.d	sp[8],r10
80014d44:	58 e6       	cp.w	r6,14
80014d46:	5f ab       	srle	r11
80014d48:	41 8a       	lddsp	r10,sp[0x60]
80014d4a:	30 08       	mov	r8,0
80014d4c:	f4 09 11 ff 	rsub	r9,r10,-1
80014d50:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
80014d54:	f0 09 18 00 	cp.b	r9,r8
80014d58:	e0 80 00 82 	breq	80014e5c <_dtoa_r+0x74c>
80014d5c:	40 ea       	lddsp	r10,sp[0x38]
80014d5e:	58 01       	cp.w	r1,0
80014d60:	5f a9       	srle	r9
80014d62:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
80014d66:	fe ca be 9a 	sub	r10,pc,-16742
80014d6a:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
80014d6e:	fa e5 00 10 	st.d	sp[16],r4
80014d72:	f0 09 18 00 	cp.b	r9,r8
80014d76:	c1 40       	breq	80014d9e <_dtoa_r+0x68e>
80014d78:	58 01       	cp.w	r1,0
80014d7a:	e0 81 01 77 	brne	80015068 <_dtoa_r+0x958>
80014d7e:	30 08       	mov	r8,0
80014d80:	fc 19 40 14 	movh	r9,0x4014
80014d84:	08 9a       	mov	r10,r4
80014d86:	0a 9b       	mov	r11,r5
80014d88:	fe b0 d4 8e 	rcall	8000f6a4 <__avr32_f64_mul>
80014d8c:	fa e8 00 08 	ld.d	r8,sp[8]
80014d90:	e0 a0 0b 73 	rcall	80016476 <__avr32_f64_cmp_ge>
80014d94:	e0 81 01 6a 	brne	80015068 <_dtoa_r+0x958>
80014d98:	02 92       	mov	r2,r1
80014d9a:	e0 8f 01 72 	bral	8001507e <_dtoa_r+0x96e>
80014d9e:	40 85       	lddsp	r5,sp[0x20]
80014da0:	30 14       	mov	r4,1
80014da2:	fa e8 00 10 	ld.d	r8,sp[16]
80014da6:	fa ea 00 08 	ld.d	r10,sp[8]
80014daa:	e0 a0 0b cf 	rcall	80016548 <__avr32_f64_div>
80014dae:	fe b0 d6 bf 	rcall	8000fb2c <__avr32_f64_to_s32>
80014db2:	18 92       	mov	r2,r12
80014db4:	fe b0 d6 d3 	rcall	8000fb5a <__avr32_s32_to_f64>
80014db8:	fa e8 00 10 	ld.d	r8,sp[16]
80014dbc:	fe b0 d4 74 	rcall	8000f6a4 <__avr32_f64_mul>
80014dc0:	14 98       	mov	r8,r10
80014dc2:	16 99       	mov	r9,r11
80014dc4:	fa ea 00 08 	ld.d	r10,sp[8]
80014dc8:	fe b0 d5 5a 	rcall	8000f87c <__avr32_f64_sub>
80014dcc:	fa eb 00 08 	st.d	sp[8],r10
80014dd0:	e4 c8 ff d0 	sub	r8,r2,-48
80014dd4:	0a c8       	st.b	r5++,r8
80014dd6:	fc 19 40 24 	movh	r9,0x4024
80014dda:	30 08       	mov	r8,0
80014ddc:	02 34       	cp.w	r4,r1
80014dde:	c3 31       	brne	80014e44 <_dtoa_r+0x734>
80014de0:	fa e8 00 08 	ld.d	r8,sp[8]
80014de4:	fe b0 d6 1a 	rcall	8000fa18 <__avr32_f64_add>
80014de8:	16 91       	mov	r1,r11
80014dea:	14 90       	mov	r0,r10
80014dec:	14 98       	mov	r8,r10
80014dee:	02 99       	mov	r9,r1
80014df0:	fa ea 00 10 	ld.d	r10,sp[16]
80014df4:	e0 a0 0b 75 	rcall	800164de <__avr32_f64_cmp_lt>
80014df8:	c1 a1       	brne	80014e2c <_dtoa_r+0x71c>
80014dfa:	fa e8 00 10 	ld.d	r8,sp[16]
80014dfe:	00 9a       	mov	r10,r0
80014e00:	02 9b       	mov	r11,r1
80014e02:	e0 a0 0b 27 	rcall	80016450 <__avr32_f64_cmp_eq>
80014e06:	e0 80 02 5e 	breq	800152c2 <_dtoa_r+0xbb2>
80014e0a:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
80014e0e:	c0 f1       	brne	80014e2c <_dtoa_r+0x71c>
80014e10:	e0 8f 02 59 	bral	800152c2 <_dtoa_r+0xbb2>
80014e14:	40 8a       	lddsp	r10,sp[0x20]
80014e16:	14 38       	cp.w	r8,r10
80014e18:	c0 30       	breq	80014e1e <_dtoa_r+0x70e>
80014e1a:	10 95       	mov	r5,r8
80014e1c:	c0 98       	rjmp	80014e2e <_dtoa_r+0x71e>
80014e1e:	33 08       	mov	r8,48
80014e20:	40 89       	lddsp	r9,sp[0x20]
80014e22:	2f f6       	sub	r6,-1
80014e24:	b2 88       	st.b	r9[0x0],r8
80014e26:	40 88       	lddsp	r8,sp[0x20]
80014e28:	c0 88       	rjmp	80014e38 <_dtoa_r+0x728>
80014e2a:	40 66       	lddsp	r6,sp[0x18]
80014e2c:	33 99       	mov	r9,57
80014e2e:	0a 98       	mov	r8,r5
80014e30:	11 7a       	ld.ub	r10,--r8
80014e32:	f2 0a 18 00 	cp.b	r10,r9
80014e36:	ce f0       	breq	80014e14 <_dtoa_r+0x704>
80014e38:	50 66       	stdsp	sp[0x18],r6
80014e3a:	11 89       	ld.ub	r9,r8[0x0]
80014e3c:	2f f9       	sub	r9,-1
80014e3e:	b0 89       	st.b	r8[0x0],r9
80014e40:	e0 8f 02 42 	bral	800152c4 <_dtoa_r+0xbb4>
80014e44:	fe b0 d4 30 	rcall	8000f6a4 <__avr32_f64_mul>
80014e48:	2f f4       	sub	r4,-1
80014e4a:	fa eb 00 08 	st.d	sp[8],r10
80014e4e:	30 08       	mov	r8,0
80014e50:	30 09       	mov	r9,0
80014e52:	e0 a0 0a ff 	rcall	80016450 <__avr32_f64_cmp_eq>
80014e56:	ca 60       	breq	80014da2 <_dtoa_r+0x692>
80014e58:	e0 8f 02 35 	bral	800152c2 <_dtoa_r+0xbb2>
80014e5c:	40 d8       	lddsp	r8,sp[0x34]
80014e5e:	58 08       	cp.w	r8,0
80014e60:	c0 51       	brne	80014e6a <_dtoa_r+0x75a>
80014e62:	04 98       	mov	r8,r2
80014e64:	00 95       	mov	r5,r0
80014e66:	40 d4       	lddsp	r4,sp[0x34]
80014e68:	c3 78       	rjmp	80014ed6 <_dtoa_r+0x7c6>
80014e6a:	40 c5       	lddsp	r5,sp[0x30]
80014e6c:	58 15       	cp.w	r5,1
80014e6e:	e0 89 00 0f 	brgt	80014e8c <_dtoa_r+0x77c>
80014e72:	41 74       	lddsp	r4,sp[0x5c]
80014e74:	58 04       	cp.w	r4,0
80014e76:	c0 40       	breq	80014e7e <_dtoa_r+0x76e>
80014e78:	f4 c9 fb cd 	sub	r9,r10,-1075
80014e7c:	c0 48       	rjmp	80014e84 <_dtoa_r+0x774>
80014e7e:	41 99       	lddsp	r9,sp[0x64]
80014e80:	f2 09 11 36 	rsub	r9,r9,54
80014e84:	04 98       	mov	r8,r2
80014e86:	00 95       	mov	r5,r0
80014e88:	c1 c8       	rjmp	80014ec0 <_dtoa_r+0x7b0>
80014e8a:	d7 03       	nop
80014e8c:	e2 c8 00 01 	sub	r8,r1,1
80014e90:	58 01       	cp.w	r1,0
80014e92:	e0 05 17 40 	movge	r5,r0
80014e96:	e2 09 17 40 	movge	r9,r1
80014e9a:	e1 d1 e5 15 	sublt	r5,r0,r1
80014e9e:	f9 b9 05 00 	movlt	r9,0
80014ea2:	10 32       	cp.w	r2,r8
80014ea4:	e5 d8 e4 18 	subge	r8,r2,r8
80014ea8:	f1 d2 e5 18 	sublt	r8,r8,r2
80014eac:	e5 d8 e5 02 	addlt	r2,r2,r8
80014eb0:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
80014eb4:	f9 d8 e5 0c 	addlt	r12,r12,r8
80014eb8:	fb fc 5a 11 	st.wlt	sp[0x44],r12
80014ebc:	f9 b8 05 00 	movlt	r8,0
80014ec0:	40 4b       	lddsp	r11,sp[0x10]
80014ec2:	12 0b       	add	r11,r9
80014ec4:	50 08       	stdsp	sp[0x0],r8
80014ec6:	50 4b       	stdsp	sp[0x10],r11
80014ec8:	12 00       	add	r0,r9
80014eca:	30 1b       	mov	r11,1
80014ecc:	0e 9c       	mov	r12,r7
80014ece:	e0 a0 08 a7 	rcall	8001601c <__i2b>
80014ed2:	40 08       	lddsp	r8,sp[0x0]
80014ed4:	18 94       	mov	r4,r12
80014ed6:	40 4a       	lddsp	r10,sp[0x10]
80014ed8:	58 05       	cp.w	r5,0
80014eda:	5f 99       	srgt	r9
80014edc:	58 0a       	cp.w	r10,0
80014ede:	5f 9a       	srgt	r10
80014ee0:	f5 e9 00 09 	and	r9,r10,r9
80014ee4:	c0 80       	breq	80014ef4 <_dtoa_r+0x7e4>
80014ee6:	40 4c       	lddsp	r12,sp[0x10]
80014ee8:	f8 05 0d 49 	min	r9,r12,r5
80014eec:	12 1c       	sub	r12,r9
80014eee:	12 10       	sub	r0,r9
80014ef0:	50 4c       	stdsp	sp[0x10],r12
80014ef2:	12 15       	sub	r5,r9
80014ef4:	58 02       	cp.w	r2,0
80014ef6:	e0 8a 00 27 	brle	80014f44 <_dtoa_r+0x834>
80014efa:	40 db       	lddsp	r11,sp[0x34]
80014efc:	58 0b       	cp.w	r11,0
80014efe:	c1 d0       	breq	80014f38 <_dtoa_r+0x828>
80014f00:	58 08       	cp.w	r8,0
80014f02:	e0 8a 00 17 	brle	80014f30 <_dtoa_r+0x820>
80014f06:	10 9a       	mov	r10,r8
80014f08:	50 08       	stdsp	sp[0x0],r8
80014f0a:	08 9b       	mov	r11,r4
80014f0c:	0e 9c       	mov	r12,r7
80014f0e:	e0 a0 08 cd 	rcall	800160a8 <__pow5mult>
80014f12:	06 9a       	mov	r10,r3
80014f14:	18 9b       	mov	r11,r12
80014f16:	18 94       	mov	r4,r12
80014f18:	0e 9c       	mov	r12,r7
80014f1a:	e0 a0 08 01 	rcall	80015f1c <__multiply>
80014f1e:	18 99       	mov	r9,r12
80014f20:	06 9b       	mov	r11,r3
80014f22:	50 19       	stdsp	sp[0x4],r9
80014f24:	0e 9c       	mov	r12,r7
80014f26:	e0 a0 06 ad 	rcall	80015c80 <_Bfree>
80014f2a:	40 19       	lddsp	r9,sp[0x4]
80014f2c:	40 08       	lddsp	r8,sp[0x0]
80014f2e:	12 93       	mov	r3,r9
80014f30:	e4 08 01 0a 	sub	r10,r2,r8
80014f34:	c0 80       	breq	80014f44 <_dtoa_r+0x834>
80014f36:	c0 28       	rjmp	80014f3a <_dtoa_r+0x82a>
80014f38:	04 9a       	mov	r10,r2
80014f3a:	06 9b       	mov	r11,r3
80014f3c:	0e 9c       	mov	r12,r7
80014f3e:	e0 a0 08 b5 	rcall	800160a8 <__pow5mult>
80014f42:	18 93       	mov	r3,r12
80014f44:	30 1b       	mov	r11,1
80014f46:	0e 9c       	mov	r12,r7
80014f48:	e0 a0 08 6a 	rcall	8001601c <__i2b>
80014f4c:	41 1a       	lddsp	r10,sp[0x44]
80014f4e:	18 92       	mov	r2,r12
80014f50:	58 0a       	cp.w	r10,0
80014f52:	e0 8a 00 07 	brle	80014f60 <_dtoa_r+0x850>
80014f56:	18 9b       	mov	r11,r12
80014f58:	0e 9c       	mov	r12,r7
80014f5a:	e0 a0 08 a7 	rcall	800160a8 <__pow5mult>
80014f5e:	18 92       	mov	r2,r12
80014f60:	40 c9       	lddsp	r9,sp[0x30]
80014f62:	58 19       	cp.w	r9,1
80014f64:	e0 89 00 14 	brgt	80014f8c <_dtoa_r+0x87c>
80014f68:	40 38       	lddsp	r8,sp[0xc]
80014f6a:	58 08       	cp.w	r8,0
80014f6c:	c1 01       	brne	80014f8c <_dtoa_r+0x87c>
80014f6e:	40 29       	lddsp	r9,sp[0x8]
80014f70:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
80014f74:	c0 c1       	brne	80014f8c <_dtoa_r+0x87c>
80014f76:	12 98       	mov	r8,r9
80014f78:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80014f7c:	c0 80       	breq	80014f8c <_dtoa_r+0x87c>
80014f7e:	40 4c       	lddsp	r12,sp[0x10]
80014f80:	30 1b       	mov	r11,1
80014f82:	2f fc       	sub	r12,-1
80014f84:	2f f0       	sub	r0,-1
80014f86:	50 4c       	stdsp	sp[0x10],r12
80014f88:	50 6b       	stdsp	sp[0x18],r11
80014f8a:	c0 38       	rjmp	80014f90 <_dtoa_r+0x880>
80014f8c:	30 0a       	mov	r10,0
80014f8e:	50 6a       	stdsp	sp[0x18],r10
80014f90:	41 19       	lddsp	r9,sp[0x44]
80014f92:	58 09       	cp.w	r9,0
80014f94:	c0 31       	brne	80014f9a <_dtoa_r+0x88a>
80014f96:	30 1c       	mov	r12,1
80014f98:	c0 98       	rjmp	80014faa <_dtoa_r+0x89a>
80014f9a:	64 48       	ld.w	r8,r2[0x10]
80014f9c:	2f c8       	sub	r8,-4
80014f9e:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
80014fa2:	e0 a0 05 df 	rcall	80015b60 <__hi0bits>
80014fa6:	f8 0c 11 20 	rsub	r12,r12,32
80014faa:	40 4b       	lddsp	r11,sp[0x10]
80014fac:	f8 0b 00 08 	add	r8,r12,r11
80014fb0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80014fb4:	c0 c0       	breq	80014fcc <_dtoa_r+0x8bc>
80014fb6:	f0 08 11 20 	rsub	r8,r8,32
80014fba:	58 48       	cp.w	r8,4
80014fbc:	e0 8a 00 06 	brle	80014fc8 <_dtoa_r+0x8b8>
80014fc0:	20 48       	sub	r8,4
80014fc2:	10 0b       	add	r11,r8
80014fc4:	50 4b       	stdsp	sp[0x10],r11
80014fc6:	c0 78       	rjmp	80014fd4 <_dtoa_r+0x8c4>
80014fc8:	58 48       	cp.w	r8,4
80014fca:	c0 70       	breq	80014fd8 <_dtoa_r+0x8c8>
80014fcc:	40 4a       	lddsp	r10,sp[0x10]
80014fce:	2e 48       	sub	r8,-28
80014fd0:	10 0a       	add	r10,r8
80014fd2:	50 4a       	stdsp	sp[0x10],r10
80014fd4:	10 00       	add	r0,r8
80014fd6:	10 05       	add	r5,r8
80014fd8:	58 00       	cp.w	r0,0
80014fda:	e0 8a 00 08 	brle	80014fea <_dtoa_r+0x8da>
80014fde:	06 9b       	mov	r11,r3
80014fe0:	00 9a       	mov	r10,r0
80014fe2:	0e 9c       	mov	r12,r7
80014fe4:	e0 a0 07 58 	rcall	80015e94 <__lshift>
80014fe8:	18 93       	mov	r3,r12
80014fea:	40 49       	lddsp	r9,sp[0x10]
80014fec:	58 09       	cp.w	r9,0
80014fee:	e0 8a 00 08 	brle	80014ffe <_dtoa_r+0x8ee>
80014ff2:	04 9b       	mov	r11,r2
80014ff4:	12 9a       	mov	r10,r9
80014ff6:	0e 9c       	mov	r12,r7
80014ff8:	e0 a0 07 4e 	rcall	80015e94 <__lshift>
80014ffc:	18 92       	mov	r2,r12
80014ffe:	41 48       	lddsp	r8,sp[0x50]
80015000:	58 08       	cp.w	r8,0
80015002:	c1 b0       	breq	80015038 <_dtoa_r+0x928>
80015004:	04 9b       	mov	r11,r2
80015006:	06 9c       	mov	r12,r3
80015008:	e0 a0 06 23 	rcall	80015c4e <__mcmp>
8001500c:	c1 64       	brge	80015038 <_dtoa_r+0x928>
8001500e:	06 9b       	mov	r11,r3
80015010:	30 09       	mov	r9,0
80015012:	30 aa       	mov	r10,10
80015014:	0e 9c       	mov	r12,r7
80015016:	e0 a0 08 0b 	rcall	8001602c <__multadd>
8001501a:	20 16       	sub	r6,1
8001501c:	18 93       	mov	r3,r12
8001501e:	40 dc       	lddsp	r12,sp[0x34]
80015020:	58 0c       	cp.w	r12,0
80015022:	c0 31       	brne	80015028 <_dtoa_r+0x918>
80015024:	40 91       	lddsp	r1,sp[0x24]
80015026:	c0 98       	rjmp	80015038 <_dtoa_r+0x928>
80015028:	08 9b       	mov	r11,r4
8001502a:	40 91       	lddsp	r1,sp[0x24]
8001502c:	30 09       	mov	r9,0
8001502e:	30 aa       	mov	r10,10
80015030:	0e 9c       	mov	r12,r7
80015032:	e0 a0 07 fd 	rcall	8001602c <__multadd>
80015036:	18 94       	mov	r4,r12
80015038:	58 01       	cp.w	r1,0
8001503a:	5f a9       	srle	r9
8001503c:	40 cb       	lddsp	r11,sp[0x30]
8001503e:	58 2b       	cp.w	r11,2
80015040:	5f 98       	srgt	r8
80015042:	f3 e8 00 08 	and	r8,r9,r8
80015046:	c2 50       	breq	80015090 <_dtoa_r+0x980>
80015048:	58 01       	cp.w	r1,0
8001504a:	c1 11       	brne	8001506c <_dtoa_r+0x95c>
8001504c:	04 9b       	mov	r11,r2
8001504e:	02 99       	mov	r9,r1
80015050:	30 5a       	mov	r10,5
80015052:	0e 9c       	mov	r12,r7
80015054:	e0 a0 07 ec 	rcall	8001602c <__multadd>
80015058:	18 92       	mov	r2,r12
8001505a:	18 9b       	mov	r11,r12
8001505c:	06 9c       	mov	r12,r3
8001505e:	e0 a0 05 f8 	rcall	80015c4e <__mcmp>
80015062:	e0 89 00 0f 	brgt	80015080 <_dtoa_r+0x970>
80015066:	c0 38       	rjmp	8001506c <_dtoa_r+0x95c>
80015068:	30 02       	mov	r2,0
8001506a:	04 94       	mov	r4,r2
8001506c:	40 ea       	lddsp	r10,sp[0x38]
8001506e:	30 09       	mov	r9,0
80015070:	5c da       	com	r10
80015072:	40 85       	lddsp	r5,sp[0x20]
80015074:	50 6a       	stdsp	sp[0x18],r10
80015076:	50 49       	stdsp	sp[0x10],r9
80015078:	c0 f9       	rjmp	80015296 <_dtoa_r+0xb86>
8001507a:	08 92       	mov	r2,r4
8001507c:	40 66       	lddsp	r6,sp[0x18]
8001507e:	04 94       	mov	r4,r2
80015080:	2f f6       	sub	r6,-1
80015082:	50 66       	stdsp	sp[0x18],r6
80015084:	33 18       	mov	r8,49
80015086:	40 85       	lddsp	r5,sp[0x20]
80015088:	0a c8       	st.b	r5++,r8
8001508a:	30 08       	mov	r8,0
8001508c:	50 48       	stdsp	sp[0x10],r8
8001508e:	c0 49       	rjmp	80015296 <_dtoa_r+0xb86>
80015090:	40 dc       	lddsp	r12,sp[0x34]
80015092:	58 0c       	cp.w	r12,0
80015094:	e0 80 00 b5 	breq	800151fe <_dtoa_r+0xaee>
80015098:	58 05       	cp.w	r5,0
8001509a:	e0 8a 00 08 	brle	800150aa <_dtoa_r+0x99a>
8001509e:	08 9b       	mov	r11,r4
800150a0:	0a 9a       	mov	r10,r5
800150a2:	0e 9c       	mov	r12,r7
800150a4:	e0 a0 06 f8 	rcall	80015e94 <__lshift>
800150a8:	18 94       	mov	r4,r12
800150aa:	40 6b       	lddsp	r11,sp[0x18]
800150ac:	58 0b       	cp.w	r11,0
800150ae:	c0 31       	brne	800150b4 <_dtoa_r+0x9a4>
800150b0:	08 9c       	mov	r12,r4
800150b2:	c1 38       	rjmp	800150d8 <_dtoa_r+0x9c8>
800150b4:	68 1b       	ld.w	r11,r4[0x4]
800150b6:	0e 9c       	mov	r12,r7
800150b8:	e0 a0 05 fe 	rcall	80015cb4 <_Balloc>
800150bc:	68 4a       	ld.w	r10,r4[0x10]
800150be:	18 95       	mov	r5,r12
800150c0:	e8 cb ff f4 	sub	r11,r4,-12
800150c4:	2f ea       	sub	r10,-2
800150c6:	2f 4c       	sub	r12,-12
800150c8:	a3 6a       	lsl	r10,0x2
800150ca:	fe b0 d9 39 	rcall	8001033c <memcpy>
800150ce:	0a 9b       	mov	r11,r5
800150d0:	30 1a       	mov	r10,1
800150d2:	0e 9c       	mov	r12,r7
800150d4:	e0 a0 06 e0 	rcall	80015e94 <__lshift>
800150d8:	50 44       	stdsp	sp[0x10],r4
800150da:	40 3a       	lddsp	r10,sp[0xc]
800150dc:	30 19       	mov	r9,1
800150de:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
800150e2:	18 94       	mov	r4,r12
800150e4:	50 da       	stdsp	sp[0x34],r10
800150e6:	40 85       	lddsp	r5,sp[0x20]
800150e8:	50 99       	stdsp	sp[0x24],r9
800150ea:	50 26       	stdsp	sp[0x8],r6
800150ec:	50 e1       	stdsp	sp[0x38],r1
800150ee:	04 9b       	mov	r11,r2
800150f0:	06 9c       	mov	r12,r3
800150f2:	fe b0 fa 7f 	rcall	800145f0 <quorem>
800150f6:	40 4b       	lddsp	r11,sp[0x10]
800150f8:	f8 c0 ff d0 	sub	r0,r12,-48
800150fc:	06 9c       	mov	r12,r3
800150fe:	e0 a0 05 a8 	rcall	80015c4e <__mcmp>
80015102:	08 9a       	mov	r10,r4
80015104:	50 6c       	stdsp	sp[0x18],r12
80015106:	04 9b       	mov	r11,r2
80015108:	0e 9c       	mov	r12,r7
8001510a:	e0 a0 06 5d 	rcall	80015dc4 <__mdiff>
8001510e:	18 91       	mov	r1,r12
80015110:	78 38       	ld.w	r8,r12[0xc]
80015112:	58 08       	cp.w	r8,0
80015114:	c0 30       	breq	8001511a <_dtoa_r+0xa0a>
80015116:	30 16       	mov	r6,1
80015118:	c0 68       	rjmp	80015124 <_dtoa_r+0xa14>
8001511a:	18 9b       	mov	r11,r12
8001511c:	06 9c       	mov	r12,r3
8001511e:	e0 a0 05 98 	rcall	80015c4e <__mcmp>
80015122:	18 96       	mov	r6,r12
80015124:	0e 9c       	mov	r12,r7
80015126:	02 9b       	mov	r11,r1
80015128:	e0 a0 05 ac 	rcall	80015c80 <_Bfree>
8001512c:	40 cc       	lddsp	r12,sp[0x30]
8001512e:	ed ec 10 08 	or	r8,r6,r12
80015132:	c0 d1       	brne	8001514c <_dtoa_r+0xa3c>
80015134:	40 db       	lddsp	r11,sp[0x34]
80015136:	58 0b       	cp.w	r11,0
80015138:	c0 a1       	brne	8001514c <_dtoa_r+0xa3c>
8001513a:	40 26       	lddsp	r6,sp[0x8]
8001513c:	e0 40 00 39 	cp.w	r0,57
80015140:	c3 00       	breq	800151a0 <_dtoa_r+0xa90>
80015142:	40 6a       	lddsp	r10,sp[0x18]
80015144:	58 0a       	cp.w	r10,0
80015146:	e0 89 00 24 	brgt	8001518e <_dtoa_r+0xa7e>
8001514a:	c2 f8       	rjmp	800151a8 <_dtoa_r+0xa98>
8001514c:	40 69       	lddsp	r9,sp[0x18]
8001514e:	58 09       	cp.w	r9,0
80015150:	c0 85       	brlt	80015160 <_dtoa_r+0xa50>
80015152:	12 98       	mov	r8,r9
80015154:	40 cc       	lddsp	r12,sp[0x30]
80015156:	18 48       	or	r8,r12
80015158:	c1 d1       	brne	80015192 <_dtoa_r+0xa82>
8001515a:	40 db       	lddsp	r11,sp[0x34]
8001515c:	58 0b       	cp.w	r11,0
8001515e:	c1 a1       	brne	80015192 <_dtoa_r+0xa82>
80015160:	0c 99       	mov	r9,r6
80015162:	40 26       	lddsp	r6,sp[0x8]
80015164:	58 09       	cp.w	r9,0
80015166:	e0 8a 00 21 	brle	800151a8 <_dtoa_r+0xa98>
8001516a:	06 9b       	mov	r11,r3
8001516c:	30 1a       	mov	r10,1
8001516e:	0e 9c       	mov	r12,r7
80015170:	e0 a0 06 92 	rcall	80015e94 <__lshift>
80015174:	04 9b       	mov	r11,r2
80015176:	18 93       	mov	r3,r12
80015178:	e0 a0 05 6b 	rcall	80015c4e <__mcmp>
8001517c:	e0 89 00 06 	brgt	80015188 <_dtoa_r+0xa78>
80015180:	c1 41       	brne	800151a8 <_dtoa_r+0xa98>
80015182:	ed b0 00 00 	bld	r0,0x0
80015186:	c1 11       	brne	800151a8 <_dtoa_r+0xa98>
80015188:	e0 40 00 39 	cp.w	r0,57
8001518c:	c0 a0       	breq	800151a0 <_dtoa_r+0xa90>
8001518e:	2f f0       	sub	r0,-1
80015190:	c0 c8       	rjmp	800151a8 <_dtoa_r+0xa98>
80015192:	58 06       	cp.w	r6,0
80015194:	e0 8a 00 0c 	brle	800151ac <_dtoa_r+0xa9c>
80015198:	40 26       	lddsp	r6,sp[0x8]
8001519a:	e0 40 00 39 	cp.w	r0,57
8001519e:	c0 41       	brne	800151a6 <_dtoa_r+0xa96>
800151a0:	33 98       	mov	r8,57
800151a2:	0a c8       	st.b	r5++,r8
800151a4:	c6 78       	rjmp	80015272 <_dtoa_r+0xb62>
800151a6:	2f f0       	sub	r0,-1
800151a8:	0a c0       	st.b	r5++,r0
800151aa:	c7 58       	rjmp	80015294 <_dtoa_r+0xb84>
800151ac:	0a c0       	st.b	r5++,r0
800151ae:	40 9a       	lddsp	r10,sp[0x24]
800151b0:	40 e9       	lddsp	r9,sp[0x38]
800151b2:	12 3a       	cp.w	r10,r9
800151b4:	c4 30       	breq	8001523a <_dtoa_r+0xb2a>
800151b6:	06 9b       	mov	r11,r3
800151b8:	30 09       	mov	r9,0
800151ba:	30 aa       	mov	r10,10
800151bc:	0e 9c       	mov	r12,r7
800151be:	e0 a0 07 37 	rcall	8001602c <__multadd>
800151c2:	40 48       	lddsp	r8,sp[0x10]
800151c4:	18 93       	mov	r3,r12
800151c6:	08 38       	cp.w	r8,r4
800151c8:	c0 91       	brne	800151da <_dtoa_r+0xaca>
800151ca:	10 9b       	mov	r11,r8
800151cc:	30 09       	mov	r9,0
800151ce:	30 aa       	mov	r10,10
800151d0:	0e 9c       	mov	r12,r7
800151d2:	e0 a0 07 2d 	rcall	8001602c <__multadd>
800151d6:	50 4c       	stdsp	sp[0x10],r12
800151d8:	c0 e8       	rjmp	800151f4 <_dtoa_r+0xae4>
800151da:	40 4b       	lddsp	r11,sp[0x10]
800151dc:	30 09       	mov	r9,0
800151de:	30 aa       	mov	r10,10
800151e0:	0e 9c       	mov	r12,r7
800151e2:	e0 a0 07 25 	rcall	8001602c <__multadd>
800151e6:	08 9b       	mov	r11,r4
800151e8:	50 4c       	stdsp	sp[0x10],r12
800151ea:	30 09       	mov	r9,0
800151ec:	30 aa       	mov	r10,10
800151ee:	0e 9c       	mov	r12,r7
800151f0:	e0 a0 07 1e 	rcall	8001602c <__multadd>
800151f4:	18 94       	mov	r4,r12
800151f6:	40 9c       	lddsp	r12,sp[0x24]
800151f8:	2f fc       	sub	r12,-1
800151fa:	50 9c       	stdsp	sp[0x24],r12
800151fc:	c7 9b       	rjmp	800150ee <_dtoa_r+0x9de>
800151fe:	30 18       	mov	r8,1
80015200:	06 90       	mov	r0,r3
80015202:	40 85       	lddsp	r5,sp[0x20]
80015204:	08 93       	mov	r3,r4
80015206:	0c 94       	mov	r4,r6
80015208:	10 96       	mov	r6,r8
8001520a:	04 9b       	mov	r11,r2
8001520c:	00 9c       	mov	r12,r0
8001520e:	fe b0 f9 f1 	rcall	800145f0 <quorem>
80015212:	2d 0c       	sub	r12,-48
80015214:	0a cc       	st.b	r5++,r12
80015216:	02 36       	cp.w	r6,r1
80015218:	c0 a4       	brge	8001522c <_dtoa_r+0xb1c>
8001521a:	00 9b       	mov	r11,r0
8001521c:	30 09       	mov	r9,0
8001521e:	30 aa       	mov	r10,10
80015220:	0e 9c       	mov	r12,r7
80015222:	2f f6       	sub	r6,-1
80015224:	e0 a0 07 04 	rcall	8001602c <__multadd>
80015228:	18 90       	mov	r0,r12
8001522a:	cf 0b       	rjmp	8001520a <_dtoa_r+0xafa>
8001522c:	08 96       	mov	r6,r4
8001522e:	30 0b       	mov	r11,0
80015230:	06 94       	mov	r4,r3
80015232:	50 4b       	stdsp	sp[0x10],r11
80015234:	00 93       	mov	r3,r0
80015236:	18 90       	mov	r0,r12
80015238:	c0 28       	rjmp	8001523c <_dtoa_r+0xb2c>
8001523a:	40 26       	lddsp	r6,sp[0x8]
8001523c:	06 9b       	mov	r11,r3
8001523e:	30 1a       	mov	r10,1
80015240:	0e 9c       	mov	r12,r7
80015242:	e0 a0 06 29 	rcall	80015e94 <__lshift>
80015246:	04 9b       	mov	r11,r2
80015248:	18 93       	mov	r3,r12
8001524a:	e0 a0 05 02 	rcall	80015c4e <__mcmp>
8001524e:	e0 89 00 12 	brgt	80015272 <_dtoa_r+0xb62>
80015252:	c1 b1       	brne	80015288 <_dtoa_r+0xb78>
80015254:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
80015258:	c0 d1       	brne	80015272 <_dtoa_r+0xb62>
8001525a:	c1 78       	rjmp	80015288 <_dtoa_r+0xb78>
8001525c:	40 89       	lddsp	r9,sp[0x20]
8001525e:	12 38       	cp.w	r8,r9
80015260:	c0 30       	breq	80015266 <_dtoa_r+0xb56>
80015262:	10 95       	mov	r5,r8
80015264:	c0 88       	rjmp	80015274 <_dtoa_r+0xb64>
80015266:	2f f6       	sub	r6,-1
80015268:	50 66       	stdsp	sp[0x18],r6
8001526a:	33 18       	mov	r8,49
8001526c:	40 8c       	lddsp	r12,sp[0x20]
8001526e:	b8 88       	st.b	r12[0x0],r8
80015270:	c1 38       	rjmp	80015296 <_dtoa_r+0xb86>
80015272:	33 9a       	mov	r10,57
80015274:	0a 98       	mov	r8,r5
80015276:	11 79       	ld.ub	r9,--r8
80015278:	f4 09 18 00 	cp.b	r9,r10
8001527c:	cf 00       	breq	8001525c <_dtoa_r+0xb4c>
8001527e:	2f f9       	sub	r9,-1
80015280:	b0 89       	st.b	r8[0x0],r9
80015282:	c0 98       	rjmp	80015294 <_dtoa_r+0xb84>
80015284:	10 95       	mov	r5,r8
80015286:	c0 28       	rjmp	8001528a <_dtoa_r+0xb7a>
80015288:	33 09       	mov	r9,48
8001528a:	0a 98       	mov	r8,r5
8001528c:	11 7a       	ld.ub	r10,--r8
8001528e:	f2 0a 18 00 	cp.b	r10,r9
80015292:	cf 90       	breq	80015284 <_dtoa_r+0xb74>
80015294:	50 66       	stdsp	sp[0x18],r6
80015296:	04 9b       	mov	r11,r2
80015298:	0e 9c       	mov	r12,r7
8001529a:	e0 a0 04 f3 	rcall	80015c80 <_Bfree>
8001529e:	58 04       	cp.w	r4,0
800152a0:	c1 20       	breq	800152c4 <_dtoa_r+0xbb4>
800152a2:	40 4b       	lddsp	r11,sp[0x10]
800152a4:	08 3b       	cp.w	r11,r4
800152a6:	5f 19       	srne	r9
800152a8:	58 0b       	cp.w	r11,0
800152aa:	5f 18       	srne	r8
800152ac:	f3 e8 00 08 	and	r8,r9,r8
800152b0:	c0 40       	breq	800152b8 <_dtoa_r+0xba8>
800152b2:	0e 9c       	mov	r12,r7
800152b4:	e0 a0 04 e6 	rcall	80015c80 <_Bfree>
800152b8:	08 9b       	mov	r11,r4
800152ba:	0e 9c       	mov	r12,r7
800152bc:	e0 a0 04 e2 	rcall	80015c80 <_Bfree>
800152c0:	c0 28       	rjmp	800152c4 <_dtoa_r+0xbb4>
800152c2:	50 66       	stdsp	sp[0x18],r6
800152c4:	0e 9c       	mov	r12,r7
800152c6:	06 9b       	mov	r11,r3
800152c8:	e0 a0 04 dc 	rcall	80015c80 <_Bfree>
800152cc:	30 08       	mov	r8,0
800152ce:	aa 88       	st.b	r5[0x0],r8
800152d0:	40 68       	lddsp	r8,sp[0x18]
800152d2:	41 5a       	lddsp	r10,sp[0x54]
800152d4:	2f f8       	sub	r8,-1
800152d6:	41 29       	lddsp	r9,sp[0x48]
800152d8:	95 08       	st.w	r10[0x0],r8
800152da:	40 8c       	lddsp	r12,sp[0x20]
800152dc:	58 09       	cp.w	r9,0
800152de:	fb f8 10 12 	ld.wne	r8,sp[0x48]
800152e2:	f1 f5 1a 00 	st.wne	r8[0x0],r5
800152e6:	2e 6d       	sub	sp,-104
800152e8:	d8 32       	popm	r0-r7,pc
800152ea:	d7 03       	nop

800152ec <__errno>:
800152ec:	e0 68 01 4c 	mov	r8,332
800152f0:	70 0c       	ld.w	r12,r8[0x0]
800152f2:	2f 4c       	sub	r12,-12
800152f4:	5e fc       	retal	r12
800152f6:	d7 03       	nop

800152f8 <_fflush_r>:
800152f8:	d4 21       	pushm	r4-r7,lr
800152fa:	16 97       	mov	r7,r11
800152fc:	18 96       	mov	r6,r12
800152fe:	76 48       	ld.w	r8,r11[0x10]
80015300:	58 08       	cp.w	r8,0
80015302:	c7 f0       	breq	80015400 <_fflush_r+0x108>
80015304:	58 0c       	cp.w	r12,0
80015306:	c0 50       	breq	80015310 <_fflush_r+0x18>
80015308:	78 68       	ld.w	r8,r12[0x18]
8001530a:	58 08       	cp.w	r8,0
8001530c:	c0 21       	brne	80015310 <_fflush_r+0x18>
8001530e:	cc dc       	rcall	800154a8 <__sinit>
80015310:	fe c8 c4 f0 	sub	r8,pc,-15120
80015314:	10 37       	cp.w	r7,r8
80015316:	c0 31       	brne	8001531c <_fflush_r+0x24>
80015318:	6c 07       	ld.w	r7,r6[0x0]
8001531a:	c0 c8       	rjmp	80015332 <_fflush_r+0x3a>
8001531c:	fe c8 c4 dc 	sub	r8,pc,-15140
80015320:	10 37       	cp.w	r7,r8
80015322:	c0 31       	brne	80015328 <_fflush_r+0x30>
80015324:	6c 17       	ld.w	r7,r6[0x4]
80015326:	c0 68       	rjmp	80015332 <_fflush_r+0x3a>
80015328:	fe c8 c4 c8 	sub	r8,pc,-15160
8001532c:	10 37       	cp.w	r7,r8
8001532e:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80015332:	8e 6a       	ld.sh	r10,r7[0xc]
80015334:	14 98       	mov	r8,r10
80015336:	ed ba 00 03 	bld	r10,0x3
8001533a:	c4 20       	breq	800153be <_fflush_r+0xc6>
8001533c:	ab ba       	sbr	r10,0xb
8001533e:	ae 6a       	st.h	r7[0xc],r10
80015340:	6e 18       	ld.w	r8,r7[0x4]
80015342:	58 08       	cp.w	r8,0
80015344:	e0 89 00 06 	brgt	80015350 <_fflush_r+0x58>
80015348:	6f 08       	ld.w	r8,r7[0x40]
8001534a:	58 08       	cp.w	r8,0
8001534c:	e0 8a 00 5a 	brle	80015400 <_fflush_r+0x108>
80015350:	6e b8       	ld.w	r8,r7[0x2c]
80015352:	58 08       	cp.w	r8,0
80015354:	c5 60       	breq	80015400 <_fflush_r+0x108>
80015356:	e2 1a 10 00 	andl	r10,0x1000,COH
8001535a:	c0 30       	breq	80015360 <_fflush_r+0x68>
8001535c:	6f 55       	ld.w	r5,r7[0x54]
8001535e:	c0 f8       	rjmp	8001537c <_fflush_r+0x84>
80015360:	30 19       	mov	r9,1
80015362:	6e 8b       	ld.w	r11,r7[0x20]
80015364:	0c 9c       	mov	r12,r6
80015366:	5d 18       	icall	r8
80015368:	18 95       	mov	r5,r12
8001536a:	5b fc       	cp.w	r12,-1
8001536c:	c0 81       	brne	8001537c <_fflush_r+0x84>
8001536e:	6c 38       	ld.w	r8,r6[0xc]
80015370:	59 d8       	cp.w	r8,29
80015372:	c4 70       	breq	80015400 <_fflush_r+0x108>
80015374:	8e 68       	ld.sh	r8,r7[0xc]
80015376:	a7 a8       	sbr	r8,0x6
80015378:	ae 68       	st.h	r7[0xc],r8
8001537a:	d8 22       	popm	r4-r7,pc
8001537c:	8e 68       	ld.sh	r8,r7[0xc]
8001537e:	ed b8 00 02 	bld	r8,0x2
80015382:	c0 91       	brne	80015394 <_fflush_r+0x9c>
80015384:	6e 18       	ld.w	r8,r7[0x4]
80015386:	10 15       	sub	r5,r8
80015388:	6e d8       	ld.w	r8,r7[0x34]
8001538a:	58 08       	cp.w	r8,0
8001538c:	ef f8 10 10 	ld.wne	r8,r7[0x40]
80015390:	eb d8 e1 15 	subne	r5,r5,r8
80015394:	6e b8       	ld.w	r8,r7[0x2c]
80015396:	0c 9c       	mov	r12,r6
80015398:	30 09       	mov	r9,0
8001539a:	0a 9a       	mov	r10,r5
8001539c:	6e 8b       	ld.w	r11,r7[0x20]
8001539e:	5d 18       	icall	r8
800153a0:	8e 68       	ld.sh	r8,r7[0xc]
800153a2:	0a 3c       	cp.w	r12,r5
800153a4:	c2 61       	brne	800153f0 <_fflush_r+0xf8>
800153a6:	ab d8       	cbr	r8,0xb
800153a8:	30 0c       	mov	r12,0
800153aa:	6e 49       	ld.w	r9,r7[0x10]
800153ac:	ae 68       	st.h	r7[0xc],r8
800153ae:	8f 1c       	st.w	r7[0x4],r12
800153b0:	8f 09       	st.w	r7[0x0],r9
800153b2:	ed b8 00 0c 	bld	r8,0xc
800153b6:	c2 51       	brne	80015400 <_fflush_r+0x108>
800153b8:	ef 45 00 54 	st.w	r7[84],r5
800153bc:	d8 22       	popm	r4-r7,pc
800153be:	6e 45       	ld.w	r5,r7[0x10]
800153c0:	58 05       	cp.w	r5,0
800153c2:	c1 f0       	breq	80015400 <_fflush_r+0x108>
800153c4:	6e 04       	ld.w	r4,r7[0x0]
800153c6:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
800153ca:	8f 05       	st.w	r7[0x0],r5
800153cc:	f9 b8 01 00 	movne	r8,0
800153d0:	ef f8 00 05 	ld.weq	r8,r7[0x14]
800153d4:	0a 14       	sub	r4,r5
800153d6:	8f 28       	st.w	r7[0x8],r8
800153d8:	c1 18       	rjmp	800153fa <_fflush_r+0x102>
800153da:	08 99       	mov	r9,r4
800153dc:	0a 9a       	mov	r10,r5
800153de:	6e a8       	ld.w	r8,r7[0x28]
800153e0:	6e 8b       	ld.w	r11,r7[0x20]
800153e2:	0c 9c       	mov	r12,r6
800153e4:	5d 18       	icall	r8
800153e6:	18 14       	sub	r4,r12
800153e8:	58 0c       	cp.w	r12,0
800153ea:	e0 89 00 07 	brgt	800153f8 <_fflush_r+0x100>
800153ee:	8e 68       	ld.sh	r8,r7[0xc]
800153f0:	a7 a8       	sbr	r8,0x6
800153f2:	3f fc       	mov	r12,-1
800153f4:	ae 68       	st.h	r7[0xc],r8
800153f6:	d8 22       	popm	r4-r7,pc
800153f8:	18 05       	add	r5,r12
800153fa:	58 04       	cp.w	r4,0
800153fc:	fe 99 ff ef 	brgt	800153da <_fflush_r+0xe2>
80015400:	d8 2a       	popm	r4-r7,pc,r12=0
80015402:	d7 03       	nop

80015404 <__sfp_lock_acquire>:
80015404:	5e fc       	retal	r12

80015406 <__sfp_lock_release>:
80015406:	5e fc       	retal	r12

80015408 <_cleanup_r>:
80015408:	d4 01       	pushm	lr
8001540a:	fe cb f0 3e 	sub	r11,pc,-4034
8001540e:	e0 a0 02 f7 	rcall	800159fc <_fwalk>
80015412:	d8 02       	popm	pc

80015414 <__sfmoreglue>:
80015414:	d4 21       	pushm	r4-r7,lr
80015416:	16 95       	mov	r5,r11
80015418:	f6 06 10 5c 	mul	r6,r11,92
8001541c:	ec cb ff f4 	sub	r11,r6,-12
80015420:	fe b0 d5 76 	rcall	8000ff0c <_malloc_r>
80015424:	18 97       	mov	r7,r12
80015426:	c0 90       	breq	80015438 <__sfmoreglue+0x24>
80015428:	99 15       	st.w	r12[0x4],r5
8001542a:	30 0b       	mov	r11,0
8001542c:	2f 4c       	sub	r12,-12
8001542e:	0c 9a       	mov	r10,r6
80015430:	8f 2c       	st.w	r7[0x8],r12
80015432:	8f 0b       	st.w	r7[0x0],r11
80015434:	fe b0 d8 28 	rcall	80010484 <memset>
80015438:	0e 9c       	mov	r12,r7
8001543a:	d8 22       	popm	r4-r7,pc

8001543c <__sfp>:
8001543c:	d4 21       	pushm	r4-r7,lr
8001543e:	fe c8 cc 3a 	sub	r8,pc,-13254
80015442:	18 96       	mov	r6,r12
80015444:	70 07       	ld.w	r7,r8[0x0]
80015446:	6e 68       	ld.w	r8,r7[0x18]
80015448:	58 08       	cp.w	r8,0
8001544a:	c0 31       	brne	80015450 <__sfp+0x14>
8001544c:	0e 9c       	mov	r12,r7
8001544e:	c2 dc       	rcall	800154a8 <__sinit>
80015450:	ee c7 ff 28 	sub	r7,r7,-216
80015454:	30 05       	mov	r5,0
80015456:	6e 2c       	ld.w	r12,r7[0x8]
80015458:	6e 18       	ld.w	r8,r7[0x4]
8001545a:	c0 68       	rjmp	80015466 <__sfp+0x2a>
8001545c:	98 69       	ld.sh	r9,r12[0xc]
8001545e:	ea 09 19 00 	cp.h	r9,r5
80015462:	c1 10       	breq	80015484 <__sfp+0x48>
80015464:	2a 4c       	sub	r12,-92
80015466:	20 18       	sub	r8,1
80015468:	cf a7       	brpl	8001545c <__sfp+0x20>
8001546a:	6e 08       	ld.w	r8,r7[0x0]
8001546c:	58 08       	cp.w	r8,0
8001546e:	c0 61       	brne	8001547a <__sfp+0x3e>
80015470:	30 4b       	mov	r11,4
80015472:	0c 9c       	mov	r12,r6
80015474:	cd 0f       	rcall	80015414 <__sfmoreglue>
80015476:	8f 0c       	st.w	r7[0x0],r12
80015478:	c0 30       	breq	8001547e <__sfp+0x42>
8001547a:	6e 07       	ld.w	r7,r7[0x0]
8001547c:	ce db       	rjmp	80015456 <__sfp+0x1a>
8001547e:	30 c8       	mov	r8,12
80015480:	8d 38       	st.w	r6[0xc],r8
80015482:	d8 22       	popm	r4-r7,pc
80015484:	30 08       	mov	r8,0
80015486:	f9 48 00 4c 	st.w	r12[76],r8
8001548a:	99 08       	st.w	r12[0x0],r8
8001548c:	99 28       	st.w	r12[0x8],r8
8001548e:	99 18       	st.w	r12[0x4],r8
80015490:	99 48       	st.w	r12[0x10],r8
80015492:	99 58       	st.w	r12[0x14],r8
80015494:	99 68       	st.w	r12[0x18],r8
80015496:	99 d8       	st.w	r12[0x34],r8
80015498:	99 e8       	st.w	r12[0x38],r8
8001549a:	f9 48 00 48 	st.w	r12[72],r8
8001549e:	3f f8       	mov	r8,-1
800154a0:	b8 78       	st.h	r12[0xe],r8
800154a2:	30 18       	mov	r8,1
800154a4:	b8 68       	st.h	r12[0xc],r8
800154a6:	d8 22       	popm	r4-r7,pc

800154a8 <__sinit>:
800154a8:	d4 21       	pushm	r4-r7,lr
800154aa:	18 96       	mov	r6,r12
800154ac:	78 67       	ld.w	r7,r12[0x18]
800154ae:	58 07       	cp.w	r7,0
800154b0:	c4 91       	brne	80015542 <__sinit+0x9a>
800154b2:	fe c8 00 aa 	sub	r8,pc,170
800154b6:	30 15       	mov	r5,1
800154b8:	99 a8       	st.w	r12[0x28],r8
800154ba:	f9 47 00 d8 	st.w	r12[216],r7
800154be:	f9 47 00 dc 	st.w	r12[220],r7
800154c2:	f9 47 00 e0 	st.w	r12[224],r7
800154c6:	99 65       	st.w	r12[0x18],r5
800154c8:	cb af       	rcall	8001543c <__sfp>
800154ca:	8d 0c       	st.w	r6[0x0],r12
800154cc:	0c 9c       	mov	r12,r6
800154ce:	cb 7f       	rcall	8001543c <__sfp>
800154d0:	8d 1c       	st.w	r6[0x4],r12
800154d2:	0c 9c       	mov	r12,r6
800154d4:	cb 4f       	rcall	8001543c <__sfp>
800154d6:	6c 09       	ld.w	r9,r6[0x0]
800154d8:	30 48       	mov	r8,4
800154da:	93 07       	st.w	r9[0x0],r7
800154dc:	b2 68       	st.h	r9[0xc],r8
800154de:	93 17       	st.w	r9[0x4],r7
800154e0:	93 27       	st.w	r9[0x8],r7
800154e2:	6c 18       	ld.w	r8,r6[0x4]
800154e4:	b2 77       	st.h	r9[0xe],r7
800154e6:	93 47       	st.w	r9[0x10],r7
800154e8:	93 57       	st.w	r9[0x14],r7
800154ea:	93 67       	st.w	r9[0x18],r7
800154ec:	93 89       	st.w	r9[0x20],r9
800154ee:	91 07       	st.w	r8[0x0],r7
800154f0:	91 17       	st.w	r8[0x4],r7
800154f2:	91 27       	st.w	r8[0x8],r7
800154f4:	fe ce f2 9c 	sub	lr,pc,-3428
800154f8:	fe cb f2 cc 	sub	r11,pc,-3380
800154fc:	93 9e       	st.w	r9[0x24],lr
800154fe:	93 ab       	st.w	r9[0x28],r11
80015500:	fe ca f2 f4 	sub	r10,pc,-3340
80015504:	fe c4 f3 00 	sub	r4,pc,-3328
80015508:	93 ba       	st.w	r9[0x2c],r10
8001550a:	93 c4       	st.w	r9[0x30],r4
8001550c:	30 99       	mov	r9,9
8001550e:	b0 69       	st.h	r8[0xc],r9
80015510:	b0 75       	st.h	r8[0xe],r5
80015512:	91 c4       	st.w	r8[0x30],r4
80015514:	91 47       	st.w	r8[0x10],r7
80015516:	91 57       	st.w	r8[0x14],r7
80015518:	91 67       	st.w	r8[0x18],r7
8001551a:	91 88       	st.w	r8[0x20],r8
8001551c:	91 9e       	st.w	r8[0x24],lr
8001551e:	91 ab       	st.w	r8[0x28],r11
80015520:	91 ba       	st.w	r8[0x2c],r10
80015522:	8d 2c       	st.w	r6[0x8],r12
80015524:	31 28       	mov	r8,18
80015526:	99 07       	st.w	r12[0x0],r7
80015528:	b8 68       	st.h	r12[0xc],r8
8001552a:	99 17       	st.w	r12[0x4],r7
8001552c:	99 27       	st.w	r12[0x8],r7
8001552e:	30 28       	mov	r8,2
80015530:	b8 78       	st.h	r12[0xe],r8
80015532:	99 c4       	st.w	r12[0x30],r4
80015534:	99 67       	st.w	r12[0x18],r7
80015536:	99 9e       	st.w	r12[0x24],lr
80015538:	99 ab       	st.w	r12[0x28],r11
8001553a:	99 ba       	st.w	r12[0x2c],r10
8001553c:	99 47       	st.w	r12[0x10],r7
8001553e:	99 57       	st.w	r12[0x14],r7
80015540:	99 8c       	st.w	r12[0x20],r12
80015542:	d8 22       	popm	r4-r7,pc

80015544 <_malloc_trim_r>:
80015544:	d4 21       	pushm	r4-r7,lr
80015546:	16 95       	mov	r5,r11
80015548:	18 97       	mov	r7,r12
8001554a:	fe b0 d7 a4 	rcall	80010492 <__malloc_lock>
8001554e:	e0 64 01 50 	mov	r4,336
80015552:	68 28       	ld.w	r8,r4[0x8]
80015554:	70 16       	ld.w	r6,r8[0x4]
80015556:	e0 16 ff fc 	andl	r6,0xfffc
8001555a:	ec c8 ff 91 	sub	r8,r6,-111
8001555e:	f0 05 01 05 	sub	r5,r8,r5
80015562:	e0 15 ff 80 	andl	r5,0xff80
80015566:	ea c5 00 80 	sub	r5,r5,128
8001556a:	e0 45 00 7f 	cp.w	r5,127
8001556e:	e0 8a 00 25 	brle	800155b8 <_malloc_trim_r+0x74>
80015572:	30 0b       	mov	r11,0
80015574:	0e 9c       	mov	r12,r7
80015576:	fe b0 d8 f9 	rcall	80010768 <_sbrk_r>
8001557a:	68 28       	ld.w	r8,r4[0x8]
8001557c:	0c 08       	add	r8,r6
8001557e:	10 3c       	cp.w	r12,r8
80015580:	c1 c1       	brne	800155b8 <_malloc_trim_r+0x74>
80015582:	ea 0b 11 00 	rsub	r11,r5,0
80015586:	0e 9c       	mov	r12,r7
80015588:	fe b0 d8 f0 	rcall	80010768 <_sbrk_r>
8001558c:	5b fc       	cp.w	r12,-1
8001558e:	c1 91       	brne	800155c0 <_malloc_trim_r+0x7c>
80015590:	30 0b       	mov	r11,0
80015592:	0e 9c       	mov	r12,r7
80015594:	fe b0 d8 ea 	rcall	80010768 <_sbrk_r>
80015598:	68 28       	ld.w	r8,r4[0x8]
8001559a:	f8 08 01 09 	sub	r9,r12,r8
8001559e:	58 f9       	cp.w	r9,15
800155a0:	e0 8a 00 0c 	brle	800155b8 <_malloc_trim_r+0x74>
800155a4:	a1 a9       	sbr	r9,0x0
800155a6:	91 19       	st.w	r8[0x4],r9
800155a8:	e0 68 05 5c 	mov	r8,1372
800155ac:	70 09       	ld.w	r9,r8[0x0]
800155ae:	e0 68 0a 90 	mov	r8,2704
800155b2:	f8 09 01 09 	sub	r9,r12,r9
800155b6:	91 09       	st.w	r8[0x0],r9
800155b8:	0e 9c       	mov	r12,r7
800155ba:	fe b0 d7 6d 	rcall	80010494 <__malloc_unlock>
800155be:	d8 2a       	popm	r4-r7,pc,r12=0
800155c0:	68 28       	ld.w	r8,r4[0x8]
800155c2:	0a 16       	sub	r6,r5
800155c4:	a1 a6       	sbr	r6,0x0
800155c6:	91 16       	st.w	r8[0x4],r6
800155c8:	e0 68 0a 90 	mov	r8,2704
800155cc:	70 09       	ld.w	r9,r8[0x0]
800155ce:	0a 19       	sub	r9,r5
800155d0:	0e 9c       	mov	r12,r7
800155d2:	91 09       	st.w	r8[0x0],r9
800155d4:	fe b0 d7 60 	rcall	80010494 <__malloc_unlock>
800155d8:	da 2a       	popm	r4-r7,pc,r12=1
800155da:	d7 03       	nop

800155dc <_free_r>:
800155dc:	d4 21       	pushm	r4-r7,lr
800155de:	16 96       	mov	r6,r11
800155e0:	18 97       	mov	r7,r12
800155e2:	58 0b       	cp.w	r11,0
800155e4:	e0 80 00 c0 	breq	80015764 <_free_r+0x188>
800155e8:	fe b0 d7 55 	rcall	80010492 <__malloc_lock>
800155ec:	20 86       	sub	r6,8
800155ee:	e0 6a 01 50 	mov	r10,336
800155f2:	6c 18       	ld.w	r8,r6[0x4]
800155f4:	74 2e       	ld.w	lr,r10[0x8]
800155f6:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
800155fa:	a1 c8       	cbr	r8,0x0
800155fc:	ec 08 00 09 	add	r9,r6,r8
80015600:	72 1b       	ld.w	r11,r9[0x4]
80015602:	e0 1b ff fc 	andl	r11,0xfffc
80015606:	1c 39       	cp.w	r9,lr
80015608:	c1 e1       	brne	80015644 <_free_r+0x68>
8001560a:	f6 08 00 08 	add	r8,r11,r8
8001560e:	58 0c       	cp.w	r12,0
80015610:	c0 81       	brne	80015620 <_free_r+0x44>
80015612:	6c 09       	ld.w	r9,r6[0x0]
80015614:	12 16       	sub	r6,r9
80015616:	12 08       	add	r8,r9
80015618:	6c 3b       	ld.w	r11,r6[0xc]
8001561a:	6c 29       	ld.w	r9,r6[0x8]
8001561c:	97 29       	st.w	r11[0x8],r9
8001561e:	93 3b       	st.w	r9[0xc],r11
80015620:	10 99       	mov	r9,r8
80015622:	95 26       	st.w	r10[0x8],r6
80015624:	a1 a9       	sbr	r9,0x0
80015626:	8d 19       	st.w	r6[0x4],r9
80015628:	e0 69 05 58 	mov	r9,1368
8001562c:	72 09       	ld.w	r9,r9[0x0]
8001562e:	12 38       	cp.w	r8,r9
80015630:	c0 63       	brcs	8001563c <_free_r+0x60>
80015632:	e0 68 0a 8c 	mov	r8,2700
80015636:	0e 9c       	mov	r12,r7
80015638:	70 0b       	ld.w	r11,r8[0x0]
8001563a:	c8 5f       	rcall	80015544 <_malloc_trim_r>
8001563c:	0e 9c       	mov	r12,r7
8001563e:	fe b0 d7 2b 	rcall	80010494 <__malloc_unlock>
80015642:	d8 22       	popm	r4-r7,pc
80015644:	93 1b       	st.w	r9[0x4],r11
80015646:	58 0c       	cp.w	r12,0
80015648:	c0 30       	breq	8001564e <_free_r+0x72>
8001564a:	30 0c       	mov	r12,0
8001564c:	c1 08       	rjmp	8001566c <_free_r+0x90>
8001564e:	6c 0e       	ld.w	lr,r6[0x0]
80015650:	f4 c5 ff f8 	sub	r5,r10,-8
80015654:	1c 16       	sub	r6,lr
80015656:	1c 08       	add	r8,lr
80015658:	6c 2e       	ld.w	lr,r6[0x8]
8001565a:	0a 3e       	cp.w	lr,r5
8001565c:	f9 bc 00 01 	moveq	r12,1
80015660:	ed f5 10 03 	ld.wne	r5,r6[0xc]
80015664:	eb fe 1a 02 	st.wne	r5[0x8],lr
80015668:	fd f5 1a 03 	st.wne	lr[0xc],r5
8001566c:	f2 0b 00 0e 	add	lr,r9,r11
80015670:	7c 1e       	ld.w	lr,lr[0x4]
80015672:	ed be 00 00 	bld	lr,0x0
80015676:	c1 40       	breq	8001569e <_free_r+0xc2>
80015678:	16 08       	add	r8,r11
8001567a:	58 0c       	cp.w	r12,0
8001567c:	c0 d1       	brne	80015696 <_free_r+0xba>
8001567e:	e0 6e 01 50 	mov	lr,336
80015682:	72 2b       	ld.w	r11,r9[0x8]
80015684:	2f 8e       	sub	lr,-8
80015686:	1c 3b       	cp.w	r11,lr
80015688:	c0 71       	brne	80015696 <_free_r+0xba>
8001568a:	97 36       	st.w	r11[0xc],r6
8001568c:	97 26       	st.w	r11[0x8],r6
8001568e:	8d 2b       	st.w	r6[0x8],r11
80015690:	8d 3b       	st.w	r6[0xc],r11
80015692:	30 1c       	mov	r12,1
80015694:	c0 58       	rjmp	8001569e <_free_r+0xc2>
80015696:	72 2b       	ld.w	r11,r9[0x8]
80015698:	72 39       	ld.w	r9,r9[0xc]
8001569a:	93 2b       	st.w	r9[0x8],r11
8001569c:	97 39       	st.w	r11[0xc],r9
8001569e:	10 99       	mov	r9,r8
800156a0:	ec 08 09 08 	st.w	r6[r8],r8
800156a4:	a1 a9       	sbr	r9,0x0
800156a6:	8d 19       	st.w	r6[0x4],r9
800156a8:	58 0c       	cp.w	r12,0
800156aa:	c5 a1       	brne	8001575e <_free_r+0x182>
800156ac:	e0 48 01 ff 	cp.w	r8,511
800156b0:	e0 8b 00 13 	brhi	800156d6 <_free_r+0xfa>
800156b4:	a3 98       	lsr	r8,0x3
800156b6:	f4 08 00 39 	add	r9,r10,r8<<0x3
800156ba:	72 2b       	ld.w	r11,r9[0x8]
800156bc:	8d 39       	st.w	r6[0xc],r9
800156be:	8d 2b       	st.w	r6[0x8],r11
800156c0:	97 36       	st.w	r11[0xc],r6
800156c2:	93 26       	st.w	r9[0x8],r6
800156c4:	a3 48       	asr	r8,0x2
800156c6:	74 19       	ld.w	r9,r10[0x4]
800156c8:	30 1b       	mov	r11,1
800156ca:	f6 08 09 48 	lsl	r8,r11,r8
800156ce:	f3 e8 10 08 	or	r8,r9,r8
800156d2:	95 18       	st.w	r10[0x4],r8
800156d4:	c4 58       	rjmp	8001575e <_free_r+0x182>
800156d6:	f0 0b 16 09 	lsr	r11,r8,0x9
800156da:	58 4b       	cp.w	r11,4
800156dc:	e0 8b 00 06 	brhi	800156e8 <_free_r+0x10c>
800156e0:	f0 0b 16 06 	lsr	r11,r8,0x6
800156e4:	2c 8b       	sub	r11,-56
800156e6:	c2 08       	rjmp	80015726 <_free_r+0x14a>
800156e8:	59 4b       	cp.w	r11,20
800156ea:	e0 8b 00 04 	brhi	800156f2 <_free_r+0x116>
800156ee:	2a 5b       	sub	r11,-91
800156f0:	c1 b8       	rjmp	80015726 <_free_r+0x14a>
800156f2:	e0 4b 00 54 	cp.w	r11,84
800156f6:	e0 8b 00 06 	brhi	80015702 <_free_r+0x126>
800156fa:	f0 0b 16 0c 	lsr	r11,r8,0xc
800156fe:	29 2b       	sub	r11,-110
80015700:	c1 38       	rjmp	80015726 <_free_r+0x14a>
80015702:	e0 4b 01 54 	cp.w	r11,340
80015706:	e0 8b 00 06 	brhi	80015712 <_free_r+0x136>
8001570a:	f0 0b 16 0f 	lsr	r11,r8,0xf
8001570e:	28 9b       	sub	r11,-119
80015710:	c0 b8       	rjmp	80015726 <_free_r+0x14a>
80015712:	e0 4b 05 54 	cp.w	r11,1364
80015716:	e0 88 00 05 	brls	80015720 <_free_r+0x144>
8001571a:	37 eb       	mov	r11,126
8001571c:	c0 58       	rjmp	80015726 <_free_r+0x14a>
8001571e:	d7 03       	nop
80015720:	f0 0b 16 12 	lsr	r11,r8,0x12
80015724:	28 4b       	sub	r11,-124
80015726:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8001572a:	78 29       	ld.w	r9,r12[0x8]
8001572c:	18 39       	cp.w	r9,r12
8001572e:	c0 e1       	brne	8001574a <_free_r+0x16e>
80015730:	74 18       	ld.w	r8,r10[0x4]
80015732:	a3 4b       	asr	r11,0x2
80015734:	30 1c       	mov	r12,1
80015736:	f8 0b 09 4b 	lsl	r11,r12,r11
8001573a:	f1 eb 10 0b 	or	r11,r8,r11
8001573e:	12 98       	mov	r8,r9
80015740:	95 1b       	st.w	r10[0x4],r11
80015742:	c0 a8       	rjmp	80015756 <_free_r+0x17a>
80015744:	72 29       	ld.w	r9,r9[0x8]
80015746:	18 39       	cp.w	r9,r12
80015748:	c0 60       	breq	80015754 <_free_r+0x178>
8001574a:	72 1a       	ld.w	r10,r9[0x4]
8001574c:	e0 1a ff fc 	andl	r10,0xfffc
80015750:	14 38       	cp.w	r8,r10
80015752:	cf 93       	brcs	80015744 <_free_r+0x168>
80015754:	72 38       	ld.w	r8,r9[0xc]
80015756:	8d 38       	st.w	r6[0xc],r8
80015758:	8d 29       	st.w	r6[0x8],r9
8001575a:	93 36       	st.w	r9[0xc],r6
8001575c:	91 26       	st.w	r8[0x8],r6
8001575e:	0e 9c       	mov	r12,r7
80015760:	fe b0 d6 9a 	rcall	80010494 <__malloc_unlock>
80015764:	d8 22       	popm	r4-r7,pc
80015766:	d7 03       	nop

80015768 <__sfvwrite_r>:
80015768:	d4 31       	pushm	r0-r7,lr
8001576a:	20 3d       	sub	sp,12
8001576c:	14 94       	mov	r4,r10
8001576e:	18 95       	mov	r5,r12
80015770:	16 97       	mov	r7,r11
80015772:	74 28       	ld.w	r8,r10[0x8]
80015774:	58 08       	cp.w	r8,0
80015776:	e0 80 01 40 	breq	800159f6 <__sfvwrite_r+0x28e>
8001577a:	96 68       	ld.sh	r8,r11[0xc]
8001577c:	ed b8 00 03 	bld	r8,0x3
80015780:	c0 41       	brne	80015788 <__sfvwrite_r+0x20>
80015782:	76 48       	ld.w	r8,r11[0x10]
80015784:	58 08       	cp.w	r8,0
80015786:	c0 c1       	brne	8001579e <__sfvwrite_r+0x36>
80015788:	0e 9b       	mov	r11,r7
8001578a:	0a 9c       	mov	r12,r5
8001578c:	fe b0 f6 bc 	rcall	80014504 <__swsetup_r>
80015790:	c0 70       	breq	8001579e <__sfvwrite_r+0x36>
80015792:	8e 68       	ld.sh	r8,r7[0xc]
80015794:	a7 a8       	sbr	r8,0x6
80015796:	ae 68       	st.h	r7[0xc],r8
80015798:	30 98       	mov	r8,9
8001579a:	8b 38       	st.w	r5[0xc],r8
8001579c:	c2 b9       	rjmp	800159f2 <__sfvwrite_r+0x28a>
8001579e:	8e 63       	ld.sh	r3,r7[0xc]
800157a0:	68 00       	ld.w	r0,r4[0x0]
800157a2:	06 96       	mov	r6,r3
800157a4:	e2 16 00 02 	andl	r6,0x2,COH
800157a8:	c2 10       	breq	800157ea <__sfvwrite_r+0x82>
800157aa:	30 03       	mov	r3,0
800157ac:	e0 62 04 00 	mov	r2,1024
800157b0:	06 96       	mov	r6,r3
800157b2:	c0 48       	rjmp	800157ba <__sfvwrite_r+0x52>
800157b4:	60 03       	ld.w	r3,r0[0x0]
800157b6:	60 16       	ld.w	r6,r0[0x4]
800157b8:	2f 80       	sub	r0,-8
800157ba:	58 06       	cp.w	r6,0
800157bc:	cf c0       	breq	800157b4 <__sfvwrite_r+0x4c>
800157be:	e0 46 04 00 	cp.w	r6,1024
800157c2:	ec 09 17 80 	movls	r9,r6
800157c6:	e4 09 17 b0 	movhi	r9,r2
800157ca:	06 9a       	mov	r10,r3
800157cc:	6e a8       	ld.w	r8,r7[0x28]
800157ce:	6e 8b       	ld.w	r11,r7[0x20]
800157d0:	0a 9c       	mov	r12,r5
800157d2:	5d 18       	icall	r8
800157d4:	18 16       	sub	r6,r12
800157d6:	58 0c       	cp.w	r12,0
800157d8:	e0 8a 01 0a 	brle	800159ec <__sfvwrite_r+0x284>
800157dc:	68 28       	ld.w	r8,r4[0x8]
800157de:	18 18       	sub	r8,r12
800157e0:	89 28       	st.w	r4[0x8],r8
800157e2:	e0 80 01 0a 	breq	800159f6 <__sfvwrite_r+0x28e>
800157e6:	18 03       	add	r3,r12
800157e8:	ce 9b       	rjmp	800157ba <__sfvwrite_r+0x52>
800157ea:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
800157ee:	c0 70       	breq	800157fc <__sfvwrite_r+0x94>
800157f0:	50 06       	stdsp	sp[0x0],r6
800157f2:	0c 93       	mov	r3,r6
800157f4:	0c 91       	mov	r1,r6
800157f6:	50 15       	stdsp	sp[0x4],r5
800157f8:	08 92       	mov	r2,r4
800157fa:	c9 c8       	rjmp	80015932 <__sfvwrite_r+0x1ca>
800157fc:	06 96       	mov	r6,r3
800157fe:	08 91       	mov	r1,r4
80015800:	c0 48       	rjmp	80015808 <__sfvwrite_r+0xa0>
80015802:	60 03       	ld.w	r3,r0[0x0]
80015804:	60 16       	ld.w	r6,r0[0x4]
80015806:	2f 80       	sub	r0,-8
80015808:	58 06       	cp.w	r6,0
8001580a:	cf c0       	breq	80015802 <__sfvwrite_r+0x9a>
8001580c:	8e 68       	ld.sh	r8,r7[0xc]
8001580e:	6e 24       	ld.w	r4,r7[0x8]
80015810:	10 99       	mov	r9,r8
80015812:	e2 19 02 00 	andl	r9,0x200,COH
80015816:	c5 50       	breq	800158c0 <__sfvwrite_r+0x158>
80015818:	08 36       	cp.w	r6,r4
8001581a:	c4 43       	brcs	800158a2 <__sfvwrite_r+0x13a>
8001581c:	10 99       	mov	r9,r8
8001581e:	e2 19 04 80 	andl	r9,0x480,COH
80015822:	c4 00       	breq	800158a2 <__sfvwrite_r+0x13a>
80015824:	6e 4b       	ld.w	r11,r7[0x10]
80015826:	6e 09       	ld.w	r9,r7[0x0]
80015828:	16 19       	sub	r9,r11
8001582a:	50 09       	stdsp	sp[0x0],r9
8001582c:	6e 59       	ld.w	r9,r7[0x14]
8001582e:	10 9c       	mov	r12,r8
80015830:	f2 09 00 1a 	add	r10,r9,r9<<0x1
80015834:	30 28       	mov	r8,2
80015836:	f4 08 0c 08 	divs	r8,r10,r8
8001583a:	fa e9 00 04 	st.d	sp[4],r8
8001583e:	10 94       	mov	r4,r8
80015840:	40 09       	lddsp	r9,sp[0x0]
80015842:	e2 1c 04 00 	andl	r12,0x400,COH
80015846:	2f f9       	sub	r9,-1
80015848:	0c 09       	add	r9,r6
8001584a:	12 38       	cp.w	r8,r9
8001584c:	f2 04 17 30 	movlo	r4,r9
80015850:	58 0c       	cp.w	r12,0
80015852:	c1 10       	breq	80015874 <__sfvwrite_r+0x10c>
80015854:	08 9b       	mov	r11,r4
80015856:	0a 9c       	mov	r12,r5
80015858:	fe b0 d3 5a 	rcall	8000ff0c <_malloc_r>
8001585c:	18 92       	mov	r2,r12
8001585e:	c1 40       	breq	80015886 <__sfvwrite_r+0x11e>
80015860:	40 0a       	lddsp	r10,sp[0x0]
80015862:	6e 4b       	ld.w	r11,r7[0x10]
80015864:	fe b0 d5 6c 	rcall	8001033c <memcpy>
80015868:	8e 68       	ld.sh	r8,r7[0xc]
8001586a:	e0 18 fb 7f 	andl	r8,0xfb7f
8001586e:	a7 b8       	sbr	r8,0x7
80015870:	ae 68       	st.h	r7[0xc],r8
80015872:	c0 d8       	rjmp	8001588c <__sfvwrite_r+0x124>
80015874:	08 9a       	mov	r10,r4
80015876:	0a 9c       	mov	r12,r5
80015878:	fe b0 d6 18 	rcall	800104a8 <_realloc_r>
8001587c:	18 92       	mov	r2,r12
8001587e:	c0 71       	brne	8001588c <__sfvwrite_r+0x124>
80015880:	6e 4b       	ld.w	r11,r7[0x10]
80015882:	0a 9c       	mov	r12,r5
80015884:	ca ce       	rcall	800155dc <_free_r>
80015886:	30 c8       	mov	r8,12
80015888:	8b 38       	st.w	r5[0xc],r8
8001588a:	cb 18       	rjmp	800159ec <__sfvwrite_r+0x284>
8001588c:	40 0a       	lddsp	r10,sp[0x0]
8001588e:	40 09       	lddsp	r9,sp[0x0]
80015890:	e8 0a 01 0a 	sub	r10,r4,r10
80015894:	e4 09 00 08 	add	r8,r2,r9
80015898:	8f 54       	st.w	r7[0x14],r4
8001589a:	8f 2a       	st.w	r7[0x8],r10
8001589c:	8f 08       	st.w	r7[0x0],r8
8001589e:	8f 42       	st.w	r7[0x10],r2
800158a0:	0c 94       	mov	r4,r6
800158a2:	08 36       	cp.w	r6,r4
800158a4:	ec 04 17 30 	movlo	r4,r6
800158a8:	06 9b       	mov	r11,r3
800158aa:	08 9a       	mov	r10,r4
800158ac:	6e 0c       	ld.w	r12,r7[0x0]
800158ae:	c3 ad       	rcall	80015b22 <memmove>
800158b0:	6e 08       	ld.w	r8,r7[0x0]
800158b2:	08 08       	add	r8,r4
800158b4:	8f 08       	st.w	r7[0x0],r8
800158b6:	6e 28       	ld.w	r8,r7[0x8]
800158b8:	08 18       	sub	r8,r4
800158ba:	0c 94       	mov	r4,r6
800158bc:	8f 28       	st.w	r7[0x8],r8
800158be:	c2 e8       	rjmp	8001591a <__sfvwrite_r+0x1b2>
800158c0:	08 36       	cp.w	r6,r4
800158c2:	5f ba       	srhi	r10
800158c4:	6e 0c       	ld.w	r12,r7[0x0]
800158c6:	6e 48       	ld.w	r8,r7[0x10]
800158c8:	10 3c       	cp.w	r12,r8
800158ca:	5f b8       	srhi	r8
800158cc:	f5 e8 00 08 	and	r8,r10,r8
800158d0:	f2 08 18 00 	cp.b	r8,r9
800158d4:	c0 d0       	breq	800158ee <__sfvwrite_r+0x186>
800158d6:	06 9b       	mov	r11,r3
800158d8:	08 9a       	mov	r10,r4
800158da:	c2 4d       	rcall	80015b22 <memmove>
800158dc:	6e 08       	ld.w	r8,r7[0x0]
800158de:	08 08       	add	r8,r4
800158e0:	0e 9b       	mov	r11,r7
800158e2:	8f 08       	st.w	r7[0x0],r8
800158e4:	0a 9c       	mov	r12,r5
800158e6:	fe b0 fd 09 	rcall	800152f8 <_fflush_r>
800158ea:	c1 80       	breq	8001591a <__sfvwrite_r+0x1b2>
800158ec:	c8 08       	rjmp	800159ec <__sfvwrite_r+0x284>
800158ee:	6e 59       	ld.w	r9,r7[0x14]
800158f0:	12 36       	cp.w	r6,r9
800158f2:	c0 a3       	brcs	80015906 <__sfvwrite_r+0x19e>
800158f4:	6e a8       	ld.w	r8,r7[0x28]
800158f6:	06 9a       	mov	r10,r3
800158f8:	6e 8b       	ld.w	r11,r7[0x20]
800158fa:	0a 9c       	mov	r12,r5
800158fc:	5d 18       	icall	r8
800158fe:	18 94       	mov	r4,r12
80015900:	e0 89 00 0d 	brgt	8001591a <__sfvwrite_r+0x1b2>
80015904:	c7 48       	rjmp	800159ec <__sfvwrite_r+0x284>
80015906:	0c 9a       	mov	r10,r6
80015908:	06 9b       	mov	r11,r3
8001590a:	c0 cd       	rcall	80015b22 <memmove>
8001590c:	6e 08       	ld.w	r8,r7[0x0]
8001590e:	0c 08       	add	r8,r6
80015910:	0c 94       	mov	r4,r6
80015912:	8f 08       	st.w	r7[0x0],r8
80015914:	6e 28       	ld.w	r8,r7[0x8]
80015916:	0c 18       	sub	r8,r6
80015918:	8f 28       	st.w	r7[0x8],r8
8001591a:	62 28       	ld.w	r8,r1[0x8]
8001591c:	08 18       	sub	r8,r4
8001591e:	83 28       	st.w	r1[0x8],r8
80015920:	c6 b0       	breq	800159f6 <__sfvwrite_r+0x28e>
80015922:	08 16       	sub	r6,r4
80015924:	08 03       	add	r3,r4
80015926:	c7 1b       	rjmp	80015808 <__sfvwrite_r+0xa0>
80015928:	60 03       	ld.w	r3,r0[0x0]
8001592a:	60 11       	ld.w	r1,r0[0x4]
8001592c:	30 08       	mov	r8,0
8001592e:	2f 80       	sub	r0,-8
80015930:	50 08       	stdsp	sp[0x0],r8
80015932:	58 01       	cp.w	r1,0
80015934:	cf a0       	breq	80015928 <__sfvwrite_r+0x1c0>
80015936:	40 0a       	lddsp	r10,sp[0x0]
80015938:	58 0a       	cp.w	r10,0
8001593a:	c1 41       	brne	80015962 <__sfvwrite_r+0x1fa>
8001593c:	e2 c6 ff ff 	sub	r6,r1,-1
80015940:	02 9a       	mov	r10,r1
80015942:	30 ab       	mov	r11,10
80015944:	06 9c       	mov	r12,r3
80015946:	ce 3c       	rcall	80015b0c <memchr>
80015948:	f8 c8 ff ff 	sub	r8,r12,-1
8001594c:	58 0c       	cp.w	r12,0
8001594e:	f1 d3 e1 16 	subne	r6,r8,r3
80015952:	f9 b9 01 01 	movne	r9,1
80015956:	fb f9 1a 00 	st.wne	sp[0x0],r9
8001595a:	f9 b8 00 01 	moveq	r8,1
8001595e:	fb f8 0a 00 	st.weq	sp[0x0],r8
80015962:	02 36       	cp.w	r6,r1
80015964:	ec 04 17 80 	movls	r4,r6
80015968:	e2 04 17 b0 	movhi	r4,r1
8001596c:	6e 59       	ld.w	r9,r7[0x14]
8001596e:	6e 25       	ld.w	r5,r7[0x8]
80015970:	f2 05 00 05 	add	r5,r9,r5
80015974:	0a 34       	cp.w	r4,r5
80015976:	5f 9a       	srgt	r10
80015978:	6e 0c       	ld.w	r12,r7[0x0]
8001597a:	6e 48       	ld.w	r8,r7[0x10]
8001597c:	10 3c       	cp.w	r12,r8
8001597e:	5f b8       	srhi	r8
80015980:	f5 e8 00 08 	and	r8,r10,r8
80015984:	30 0a       	mov	r10,0
80015986:	f4 08 18 00 	cp.b	r8,r10
8001598a:	c0 d0       	breq	800159a4 <__sfvwrite_r+0x23c>
8001598c:	06 9b       	mov	r11,r3
8001598e:	0a 9a       	mov	r10,r5
80015990:	cc 9c       	rcall	80015b22 <memmove>
80015992:	6e 08       	ld.w	r8,r7[0x0]
80015994:	0a 08       	add	r8,r5
80015996:	0e 9b       	mov	r11,r7
80015998:	8f 08       	st.w	r7[0x0],r8
8001599a:	40 1c       	lddsp	r12,sp[0x4]
8001599c:	fe b0 fc ae 	rcall	800152f8 <_fflush_r>
800159a0:	c1 70       	breq	800159ce <__sfvwrite_r+0x266>
800159a2:	c2 58       	rjmp	800159ec <__sfvwrite_r+0x284>
800159a4:	12 34       	cp.w	r4,r9
800159a6:	c0 a5       	brlt	800159ba <__sfvwrite_r+0x252>
800159a8:	6e a8       	ld.w	r8,r7[0x28]
800159aa:	06 9a       	mov	r10,r3
800159ac:	6e 8b       	ld.w	r11,r7[0x20]
800159ae:	40 1c       	lddsp	r12,sp[0x4]
800159b0:	5d 18       	icall	r8
800159b2:	18 95       	mov	r5,r12
800159b4:	e0 89 00 0d 	brgt	800159ce <__sfvwrite_r+0x266>
800159b8:	c1 a8       	rjmp	800159ec <__sfvwrite_r+0x284>
800159ba:	08 9a       	mov	r10,r4
800159bc:	06 9b       	mov	r11,r3
800159be:	cb 2c       	rcall	80015b22 <memmove>
800159c0:	6e 08       	ld.w	r8,r7[0x0]
800159c2:	08 08       	add	r8,r4
800159c4:	08 95       	mov	r5,r4
800159c6:	8f 08       	st.w	r7[0x0],r8
800159c8:	6e 28       	ld.w	r8,r7[0x8]
800159ca:	08 18       	sub	r8,r4
800159cc:	8f 28       	st.w	r7[0x8],r8
800159ce:	0a 16       	sub	r6,r5
800159d0:	c0 71       	brne	800159de <__sfvwrite_r+0x276>
800159d2:	0e 9b       	mov	r11,r7
800159d4:	40 1c       	lddsp	r12,sp[0x4]
800159d6:	fe b0 fc 91 	rcall	800152f8 <_fflush_r>
800159da:	c0 91       	brne	800159ec <__sfvwrite_r+0x284>
800159dc:	50 06       	stdsp	sp[0x0],r6
800159de:	64 28       	ld.w	r8,r2[0x8]
800159e0:	0a 18       	sub	r8,r5
800159e2:	85 28       	st.w	r2[0x8],r8
800159e4:	c0 90       	breq	800159f6 <__sfvwrite_r+0x28e>
800159e6:	0a 11       	sub	r1,r5
800159e8:	0a 03       	add	r3,r5
800159ea:	ca 4b       	rjmp	80015932 <__sfvwrite_r+0x1ca>
800159ec:	8e 68       	ld.sh	r8,r7[0xc]
800159ee:	a7 a8       	sbr	r8,0x6
800159f0:	ae 68       	st.h	r7[0xc],r8
800159f2:	3f fc       	mov	r12,-1
800159f4:	c0 28       	rjmp	800159f8 <__sfvwrite_r+0x290>
800159f6:	30 0c       	mov	r12,0
800159f8:	2f dd       	sub	sp,-12
800159fa:	d8 32       	popm	r0-r7,pc

800159fc <_fwalk>:
800159fc:	d4 31       	pushm	r0-r7,lr
800159fe:	30 05       	mov	r5,0
80015a00:	16 91       	mov	r1,r11
80015a02:	f8 c7 ff 28 	sub	r7,r12,-216
80015a06:	0a 92       	mov	r2,r5
80015a08:	fe b0 fc fe 	rcall	80015404 <__sfp_lock_acquire>
80015a0c:	3f f3       	mov	r3,-1
80015a0e:	c1 68       	rjmp	80015a3a <_fwalk+0x3e>
80015a10:	6e 26       	ld.w	r6,r7[0x8]
80015a12:	6e 14       	ld.w	r4,r7[0x4]
80015a14:	2f 46       	sub	r6,-12
80015a16:	c0 c8       	rjmp	80015a2e <_fwalk+0x32>
80015a18:	8c 08       	ld.sh	r8,r6[0x0]
80015a1a:	e4 08 19 00 	cp.h	r8,r2
80015a1e:	c0 70       	breq	80015a2c <_fwalk+0x30>
80015a20:	8c 18       	ld.sh	r8,r6[0x2]
80015a22:	e6 08 19 00 	cp.h	r8,r3
80015a26:	c0 30       	breq	80015a2c <_fwalk+0x30>
80015a28:	5d 11       	icall	r1
80015a2a:	18 45       	or	r5,r12
80015a2c:	2a 46       	sub	r6,-92
80015a2e:	20 14       	sub	r4,1
80015a30:	ec cc 00 0c 	sub	r12,r6,12
80015a34:	58 04       	cp.w	r4,0
80015a36:	cf 14       	brge	80015a18 <_fwalk+0x1c>
80015a38:	6e 07       	ld.w	r7,r7[0x0]
80015a3a:	58 07       	cp.w	r7,0
80015a3c:	ce a1       	brne	80015a10 <_fwalk+0x14>
80015a3e:	fe b0 fc e4 	rcall	80015406 <__sfp_lock_release>
80015a42:	0a 9c       	mov	r12,r5
80015a44:	d8 32       	popm	r0-r7,pc
80015a46:	d7 03       	nop

80015a48 <_localeconv_r>:
80015a48:	fe cc cb c8 	sub	r12,pc,-13368
80015a4c:	5e fc       	retal	r12
80015a4e:	d7 03       	nop

80015a50 <__smakebuf_r>:
80015a50:	d4 21       	pushm	r4-r7,lr
80015a52:	20 fd       	sub	sp,60
80015a54:	96 68       	ld.sh	r8,r11[0xc]
80015a56:	16 97       	mov	r7,r11
80015a58:	18 96       	mov	r6,r12
80015a5a:	e2 18 00 02 	andl	r8,0x2,COH
80015a5e:	c3 d1       	brne	80015ad8 <__smakebuf_r+0x88>
80015a60:	96 7b       	ld.sh	r11,r11[0xe]
80015a62:	f0 0b 19 00 	cp.h	r11,r8
80015a66:	c0 55       	brlt	80015a70 <__smakebuf_r+0x20>
80015a68:	1a 9a       	mov	r10,sp
80015a6a:	e0 a0 04 b9 	rcall	800163dc <_fstat_r>
80015a6e:	c0 f4       	brge	80015a8c <__smakebuf_r+0x3c>
80015a70:	8e 65       	ld.sh	r5,r7[0xc]
80015a72:	0a 98       	mov	r8,r5
80015a74:	ab b8       	sbr	r8,0xb
80015a76:	e2 15 00 80 	andl	r5,0x80,COH
80015a7a:	ae 68       	st.h	r7[0xc],r8
80015a7c:	30 04       	mov	r4,0
80015a7e:	e0 68 04 00 	mov	r8,1024
80015a82:	f9 b5 01 40 	movne	r5,64
80015a86:	f0 05 17 00 	moveq	r5,r8
80015a8a:	c1 c8       	rjmp	80015ac2 <__smakebuf_r+0x72>
80015a8c:	40 18       	lddsp	r8,sp[0x4]
80015a8e:	e2 18 f0 00 	andl	r8,0xf000,COH
80015a92:	e0 48 20 00 	cp.w	r8,8192
80015a96:	5f 04       	sreq	r4
80015a98:	e0 48 80 00 	cp.w	r8,32768
80015a9c:	c0 e1       	brne	80015ab8 <__smakebuf_r+0x68>
80015a9e:	6e b9       	ld.w	r9,r7[0x2c]
80015aa0:	fe c8 f8 94 	sub	r8,pc,-1900
80015aa4:	10 39       	cp.w	r9,r8
80015aa6:	c0 91       	brne	80015ab8 <__smakebuf_r+0x68>
80015aa8:	8e 68       	ld.sh	r8,r7[0xc]
80015aaa:	e0 65 04 00 	mov	r5,1024
80015aae:	ab a8       	sbr	r8,0xa
80015ab0:	ef 45 00 50 	st.w	r7[80],r5
80015ab4:	ae 68       	st.h	r7[0xc],r8
80015ab6:	c0 68       	rjmp	80015ac2 <__smakebuf_r+0x72>
80015ab8:	8e 68       	ld.sh	r8,r7[0xc]
80015aba:	e0 65 04 00 	mov	r5,1024
80015abe:	ab b8       	sbr	r8,0xb
80015ac0:	ae 68       	st.h	r7[0xc],r8
80015ac2:	0a 9b       	mov	r11,r5
80015ac4:	0c 9c       	mov	r12,r6
80015ac6:	fe b0 d2 23 	rcall	8000ff0c <_malloc_r>
80015aca:	8e 68       	ld.sh	r8,r7[0xc]
80015acc:	c0 d1       	brne	80015ae6 <__smakebuf_r+0x96>
80015ace:	ed b8 00 09 	bld	r8,0x9
80015ad2:	c1 b0       	breq	80015b08 <__smakebuf_r+0xb8>
80015ad4:	a1 b8       	sbr	r8,0x1
80015ad6:	ae 68       	st.h	r7[0xc],r8
80015ad8:	ee c8 ff b9 	sub	r8,r7,-71
80015adc:	8f 48       	st.w	r7[0x10],r8
80015ade:	8f 08       	st.w	r7[0x0],r8
80015ae0:	30 18       	mov	r8,1
80015ae2:	8f 58       	st.w	r7[0x14],r8
80015ae4:	c1 28       	rjmp	80015b08 <__smakebuf_r+0xb8>
80015ae6:	a7 b8       	sbr	r8,0x7
80015ae8:	8f 4c       	st.w	r7[0x10],r12
80015aea:	ae 68       	st.h	r7[0xc],r8
80015aec:	8f 55       	st.w	r7[0x14],r5
80015aee:	fe c8 06 e6 	sub	r8,pc,1766
80015af2:	8f 0c       	st.w	r7[0x0],r12
80015af4:	8d a8       	st.w	r6[0x28],r8
80015af6:	58 04       	cp.w	r4,0
80015af8:	c0 80       	breq	80015b08 <__smakebuf_r+0xb8>
80015afa:	8e 7c       	ld.sh	r12,r7[0xe]
80015afc:	fe b0 d6 9c 	rcall	80010834 <isatty>
80015b00:	c0 40       	breq	80015b08 <__smakebuf_r+0xb8>
80015b02:	8e 68       	ld.sh	r8,r7[0xc]
80015b04:	a1 a8       	sbr	r8,0x0
80015b06:	ae 68       	st.h	r7[0xc],r8
80015b08:	2f 1d       	sub	sp,-60
80015b0a:	d8 22       	popm	r4-r7,pc

80015b0c <memchr>:
80015b0c:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
80015b10:	c0 68       	rjmp	80015b1c <memchr+0x10>
80015b12:	20 1a       	sub	r10,1
80015b14:	19 88       	ld.ub	r8,r12[0x0]
80015b16:	16 38       	cp.w	r8,r11
80015b18:	5e 0c       	reteq	r12
80015b1a:	2f fc       	sub	r12,-1
80015b1c:	58 0a       	cp.w	r10,0
80015b1e:	cf a1       	brne	80015b12 <memchr+0x6>
80015b20:	5e fa       	retal	r10

80015b22 <memmove>:
80015b22:	d4 01       	pushm	lr
80015b24:	18 3b       	cp.w	r11,r12
80015b26:	c1 92       	brcc	80015b58 <memmove+0x36>
80015b28:	f6 0a 00 09 	add	r9,r11,r10
80015b2c:	12 3c       	cp.w	r12,r9
80015b2e:	c1 52       	brcc	80015b58 <memmove+0x36>
80015b30:	f8 0a 00 0b 	add	r11,r12,r10
80015b34:	30 08       	mov	r8,0
80015b36:	c0 68       	rjmp	80015b42 <memmove+0x20>
80015b38:	f2 08 07 0e 	ld.ub	lr,r9[r8]
80015b3c:	20 1a       	sub	r10,1
80015b3e:	f6 08 0b 0e 	st.b	r11[r8],lr
80015b42:	20 18       	sub	r8,1
80015b44:	58 0a       	cp.w	r10,0
80015b46:	cf 91       	brne	80015b38 <memmove+0x16>
80015b48:	d8 02       	popm	pc
80015b4a:	f6 08 07 09 	ld.ub	r9,r11[r8]
80015b4e:	20 1a       	sub	r10,1
80015b50:	f8 08 0b 09 	st.b	r12[r8],r9
80015b54:	2f f8       	sub	r8,-1
80015b56:	c0 28       	rjmp	80015b5a <memmove+0x38>
80015b58:	30 08       	mov	r8,0
80015b5a:	58 0a       	cp.w	r10,0
80015b5c:	cf 71       	brne	80015b4a <memmove+0x28>
80015b5e:	d8 02       	popm	pc

80015b60 <__hi0bits>:
80015b60:	18 98       	mov	r8,r12
80015b62:	e0 1c 00 00 	andl	r12,0x0
80015b66:	f0 09 15 10 	lsl	r9,r8,0x10
80015b6a:	58 0c       	cp.w	r12,0
80015b6c:	f2 08 17 00 	moveq	r8,r9
80015b70:	f9 bc 00 10 	moveq	r12,16
80015b74:	f9 bc 01 00 	movne	r12,0
80015b78:	10 9a       	mov	r10,r8
80015b7a:	f0 09 15 08 	lsl	r9,r8,0x8
80015b7e:	e6 1a ff 00 	andh	r10,0xff00,COH
80015b82:	f7 bc 00 f8 	subeq	r12,-8
80015b86:	f2 08 17 00 	moveq	r8,r9
80015b8a:	10 9a       	mov	r10,r8
80015b8c:	f0 09 15 04 	lsl	r9,r8,0x4
80015b90:	e6 1a f0 00 	andh	r10,0xf000,COH
80015b94:	f7 bc 00 fc 	subeq	r12,-4
80015b98:	f2 08 17 00 	moveq	r8,r9
80015b9c:	10 9a       	mov	r10,r8
80015b9e:	f0 09 15 02 	lsl	r9,r8,0x2
80015ba2:	e6 1a c0 00 	andh	r10,0xc000,COH
80015ba6:	f7 bc 00 fe 	subeq	r12,-2
80015baa:	f2 08 17 00 	moveq	r8,r9
80015bae:	58 08       	cp.w	r8,0
80015bb0:	5e 5c       	retlt	r12
80015bb2:	ed b8 00 1e 	bld	r8,0x1e
80015bb6:	f9 bc 01 20 	movne	r12,32
80015bba:	f7 bc 00 ff 	subeq	r12,-1
80015bbe:	5e fc       	retal	r12

80015bc0 <__lo0bits>:
80015bc0:	18 99       	mov	r9,r12
80015bc2:	78 08       	ld.w	r8,r12[0x0]
80015bc4:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
80015bc8:	c1 50       	breq	80015bf2 <__lo0bits+0x32>
80015bca:	ed b8 00 00 	bld	r8,0x0
80015bce:	c0 21       	brne	80015bd2 <__lo0bits+0x12>
80015bd0:	5e fd       	retal	0
80015bd2:	10 9b       	mov	r11,r8
80015bd4:	f0 0a 16 01 	lsr	r10,r8,0x1
80015bd8:	e2 1b 00 02 	andl	r11,0x2,COH
80015bdc:	a3 88       	lsr	r8,0x2
80015bde:	58 0b       	cp.w	r11,0
80015be0:	f3 fa 1a 00 	st.wne	r9[0x0],r10
80015be4:	f9 bc 01 01 	movne	r12,1
80015be8:	f3 f8 0a 00 	st.weq	r9[0x0],r8
80015bec:	f9 bc 00 02 	moveq	r12,2
80015bf0:	5e fc       	retal	r12
80015bf2:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80015bf6:	f0 0b 16 10 	lsr	r11,r8,0x10
80015bfa:	58 0a       	cp.w	r10,0
80015bfc:	f6 08 17 00 	moveq	r8,r11
80015c00:	f9 bc 00 10 	moveq	r12,16
80015c04:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
80015c08:	f0 0a 16 08 	lsr	r10,r8,0x8
80015c0c:	58 0b       	cp.w	r11,0
80015c0e:	f7 bc 00 f8 	subeq	r12,-8
80015c12:	f4 08 17 00 	moveq	r8,r10
80015c16:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
80015c1a:	f0 0a 16 04 	lsr	r10,r8,0x4
80015c1e:	58 0b       	cp.w	r11,0
80015c20:	f7 bc 00 fc 	subeq	r12,-4
80015c24:	f4 08 17 00 	moveq	r8,r10
80015c28:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
80015c2c:	f0 0a 16 02 	lsr	r10,r8,0x2
80015c30:	58 0b       	cp.w	r11,0
80015c32:	f7 bc 00 fe 	subeq	r12,-2
80015c36:	f4 08 17 00 	moveq	r8,r10
80015c3a:	ed b8 00 00 	bld	r8,0x0
80015c3e:	c0 60       	breq	80015c4a <__lo0bits+0x8a>
80015c40:	a1 98       	lsr	r8,0x1
80015c42:	c0 31       	brne	80015c48 <__lo0bits+0x88>
80015c44:	32 0c       	mov	r12,32
80015c46:	5e fc       	retal	r12
80015c48:	2f fc       	sub	r12,-1
80015c4a:	93 08       	st.w	r9[0x0],r8
80015c4c:	5e fc       	retal	r12

80015c4e <__mcmp>:
80015c4e:	d4 01       	pushm	lr
80015c50:	18 98       	mov	r8,r12
80015c52:	76 49       	ld.w	r9,r11[0x10]
80015c54:	78 4c       	ld.w	r12,r12[0x10]
80015c56:	12 1c       	sub	r12,r9
80015c58:	c1 31       	brne	80015c7e <__mcmp+0x30>
80015c5a:	2f b9       	sub	r9,-5
80015c5c:	a3 69       	lsl	r9,0x2
80015c5e:	12 0b       	add	r11,r9
80015c60:	f0 09 00 09 	add	r9,r8,r9
80015c64:	2e c8       	sub	r8,-20
80015c66:	13 4e       	ld.w	lr,--r9
80015c68:	17 4a       	ld.w	r10,--r11
80015c6a:	14 3e       	cp.w	lr,r10
80015c6c:	c0 60       	breq	80015c78 <__mcmp+0x2a>
80015c6e:	f9 bc 03 ff 	movlo	r12,-1
80015c72:	f9 bc 02 01 	movhs	r12,1
80015c76:	d8 02       	popm	pc
80015c78:	10 39       	cp.w	r9,r8
80015c7a:	fe 9b ff f6 	brhi	80015c66 <__mcmp+0x18>
80015c7e:	d8 02       	popm	pc

80015c80 <_Bfree>:
80015c80:	d4 21       	pushm	r4-r7,lr
80015c82:	18 97       	mov	r7,r12
80015c84:	16 95       	mov	r5,r11
80015c86:	78 96       	ld.w	r6,r12[0x24]
80015c88:	58 06       	cp.w	r6,0
80015c8a:	c0 91       	brne	80015c9c <_Bfree+0x1c>
80015c8c:	31 0c       	mov	r12,16
80015c8e:	fe b0 d1 37 	rcall	8000fefc <malloc>
80015c92:	99 36       	st.w	r12[0xc],r6
80015c94:	8f 9c       	st.w	r7[0x24],r12
80015c96:	99 16       	st.w	r12[0x4],r6
80015c98:	99 26       	st.w	r12[0x8],r6
80015c9a:	99 06       	st.w	r12[0x0],r6
80015c9c:	58 05       	cp.w	r5,0
80015c9e:	c0 90       	breq	80015cb0 <_Bfree+0x30>
80015ca0:	6a 19       	ld.w	r9,r5[0x4]
80015ca2:	6e 98       	ld.w	r8,r7[0x24]
80015ca4:	70 38       	ld.w	r8,r8[0xc]
80015ca6:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
80015caa:	8b 0a       	st.w	r5[0x0],r10
80015cac:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
80015cb0:	d8 22       	popm	r4-r7,pc
80015cb2:	d7 03       	nop

80015cb4 <_Balloc>:
80015cb4:	d4 21       	pushm	r4-r7,lr
80015cb6:	18 97       	mov	r7,r12
80015cb8:	16 96       	mov	r6,r11
80015cba:	78 95       	ld.w	r5,r12[0x24]
80015cbc:	58 05       	cp.w	r5,0
80015cbe:	c0 91       	brne	80015cd0 <_Balloc+0x1c>
80015cc0:	31 0c       	mov	r12,16
80015cc2:	fe b0 d1 1d 	rcall	8000fefc <malloc>
80015cc6:	99 35       	st.w	r12[0xc],r5
80015cc8:	8f 9c       	st.w	r7[0x24],r12
80015cca:	99 15       	st.w	r12[0x4],r5
80015ccc:	99 25       	st.w	r12[0x8],r5
80015cce:	99 05       	st.w	r12[0x0],r5
80015cd0:	6e 95       	ld.w	r5,r7[0x24]
80015cd2:	6a 38       	ld.w	r8,r5[0xc]
80015cd4:	58 08       	cp.w	r8,0
80015cd6:	c0 b1       	brne	80015cec <_Balloc+0x38>
80015cd8:	31 0a       	mov	r10,16
80015cda:	30 4b       	mov	r11,4
80015cdc:	0e 9c       	mov	r12,r7
80015cde:	e0 a0 02 df 	rcall	8001629c <_calloc_r>
80015ce2:	8b 3c       	st.w	r5[0xc],r12
80015ce4:	6e 98       	ld.w	r8,r7[0x24]
80015ce6:	70 3c       	ld.w	r12,r8[0xc]
80015ce8:	58 0c       	cp.w	r12,0
80015cea:	c1 b0       	breq	80015d20 <_Balloc+0x6c>
80015cec:	6e 98       	ld.w	r8,r7[0x24]
80015cee:	70 38       	ld.w	r8,r8[0xc]
80015cf0:	f0 06 00 28 	add	r8,r8,r6<<0x2
80015cf4:	70 0c       	ld.w	r12,r8[0x0]
80015cf6:	58 0c       	cp.w	r12,0
80015cf8:	c0 40       	breq	80015d00 <_Balloc+0x4c>
80015cfa:	78 09       	ld.w	r9,r12[0x0]
80015cfc:	91 09       	st.w	r8[0x0],r9
80015cfe:	c0 e8       	rjmp	80015d1a <_Balloc+0x66>
80015d00:	0e 9c       	mov	r12,r7
80015d02:	30 17       	mov	r7,1
80015d04:	0e 9b       	mov	r11,r7
80015d06:	ee 06 09 47 	lsl	r7,r7,r6
80015d0a:	ee ca ff fb 	sub	r10,r7,-5
80015d0e:	a3 6a       	lsl	r10,0x2
80015d10:	e0 a0 02 c6 	rcall	8001629c <_calloc_r>
80015d14:	c0 60       	breq	80015d20 <_Balloc+0x6c>
80015d16:	99 16       	st.w	r12[0x4],r6
80015d18:	99 27       	st.w	r12[0x8],r7
80015d1a:	30 08       	mov	r8,0
80015d1c:	99 38       	st.w	r12[0xc],r8
80015d1e:	99 48       	st.w	r12[0x10],r8
80015d20:	d8 22       	popm	r4-r7,pc
80015d22:	d7 03       	nop

80015d24 <__d2b>:
80015d24:	d4 31       	pushm	r0-r7,lr
80015d26:	20 2d       	sub	sp,8
80015d28:	16 93       	mov	r3,r11
80015d2a:	12 96       	mov	r6,r9
80015d2c:	10 95       	mov	r5,r8
80015d2e:	14 92       	mov	r2,r10
80015d30:	30 1b       	mov	r11,1
80015d32:	cc 1f       	rcall	80015cb4 <_Balloc>
80015d34:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
80015d38:	50 09       	stdsp	sp[0x0],r9
80015d3a:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
80015d3e:	b5 a9       	sbr	r9,0x14
80015d40:	f0 01 16 14 	lsr	r1,r8,0x14
80015d44:	fb f9 1a 00 	st.wne	sp[0x0],r9
80015d48:	18 94       	mov	r4,r12
80015d4a:	58 02       	cp.w	r2,0
80015d4c:	c1 d0       	breq	80015d86 <__d2b+0x62>
80015d4e:	fa cc ff f8 	sub	r12,sp,-8
80015d52:	18 d2       	st.w	--r12,r2
80015d54:	c3 6f       	rcall	80015bc0 <__lo0bits>
80015d56:	40 18       	lddsp	r8,sp[0x4]
80015d58:	c0 d0       	breq	80015d72 <__d2b+0x4e>
80015d5a:	40 09       	lddsp	r9,sp[0x0]
80015d5c:	f8 0a 11 20 	rsub	r10,r12,32
80015d60:	f2 0a 09 4a 	lsl	r10,r9,r10
80015d64:	f5 e8 10 08 	or	r8,r10,r8
80015d68:	89 58       	st.w	r4[0x14],r8
80015d6a:	f2 0c 0a 49 	lsr	r9,r9,r12
80015d6e:	50 09       	stdsp	sp[0x0],r9
80015d70:	c0 28       	rjmp	80015d74 <__d2b+0x50>
80015d72:	89 58       	st.w	r4[0x14],r8
80015d74:	40 08       	lddsp	r8,sp[0x0]
80015d76:	58 08       	cp.w	r8,0
80015d78:	f9 b3 01 02 	movne	r3,2
80015d7c:	f9 b3 00 01 	moveq	r3,1
80015d80:	89 68       	st.w	r4[0x18],r8
80015d82:	89 43       	st.w	r4[0x10],r3
80015d84:	c0 88       	rjmp	80015d94 <__d2b+0x70>
80015d86:	1a 9c       	mov	r12,sp
80015d88:	c1 cf       	rcall	80015bc0 <__lo0bits>
80015d8a:	30 13       	mov	r3,1
80015d8c:	40 08       	lddsp	r8,sp[0x0]
80015d8e:	2e 0c       	sub	r12,-32
80015d90:	89 43       	st.w	r4[0x10],r3
80015d92:	89 58       	st.w	r4[0x14],r8
80015d94:	58 01       	cp.w	r1,0
80015d96:	c0 90       	breq	80015da8 <__d2b+0x84>
80015d98:	e2 c1 04 33 	sub	r1,r1,1075
80015d9c:	18 01       	add	r1,r12
80015d9e:	8d 01       	st.w	r6[0x0],r1
80015da0:	f8 0c 11 35 	rsub	r12,r12,53
80015da4:	8b 0c       	st.w	r5[0x0],r12
80015da6:	c0 c8       	rjmp	80015dbe <__d2b+0x9a>
80015da8:	e6 c8 ff fc 	sub	r8,r3,-4
80015dac:	f8 cc 04 32 	sub	r12,r12,1074
80015db0:	a5 73       	lsl	r3,0x5
80015db2:	8d 0c       	st.w	r6[0x0],r12
80015db4:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
80015db8:	cd 4e       	rcall	80015b60 <__hi0bits>
80015dba:	18 13       	sub	r3,r12
80015dbc:	8b 03       	st.w	r5[0x0],r3
80015dbe:	08 9c       	mov	r12,r4
80015dc0:	2f ed       	sub	sp,-8
80015dc2:	d8 32       	popm	r0-r7,pc

80015dc4 <__mdiff>:
80015dc4:	d4 31       	pushm	r0-r7,lr
80015dc6:	74 48       	ld.w	r8,r10[0x10]
80015dc8:	76 45       	ld.w	r5,r11[0x10]
80015dca:	16 97       	mov	r7,r11
80015dcc:	14 96       	mov	r6,r10
80015dce:	10 15       	sub	r5,r8
80015dd0:	c1 31       	brne	80015df6 <__mdiff+0x32>
80015dd2:	2f b8       	sub	r8,-5
80015dd4:	ee ce ff ec 	sub	lr,r7,-20
80015dd8:	a3 68       	lsl	r8,0x2
80015dda:	f4 08 00 0b 	add	r11,r10,r8
80015dde:	ee 08 00 08 	add	r8,r7,r8
80015de2:	11 4a       	ld.w	r10,--r8
80015de4:	17 49       	ld.w	r9,--r11
80015de6:	12 3a       	cp.w	r10,r9
80015de8:	c0 30       	breq	80015dee <__mdiff+0x2a>
80015dea:	c0 e2       	brcc	80015e06 <__mdiff+0x42>
80015dec:	c0 78       	rjmp	80015dfa <__mdiff+0x36>
80015dee:	1c 38       	cp.w	r8,lr
80015df0:	fe 9b ff f9 	brhi	80015de2 <__mdiff+0x1e>
80015df4:	c4 98       	rjmp	80015e86 <__mdiff+0xc2>
80015df6:	58 05       	cp.w	r5,0
80015df8:	c0 64       	brge	80015e04 <__mdiff+0x40>
80015dfa:	0e 98       	mov	r8,r7
80015dfc:	30 15       	mov	r5,1
80015dfe:	0c 97       	mov	r7,r6
80015e00:	10 96       	mov	r6,r8
80015e02:	c0 28       	rjmp	80015e06 <__mdiff+0x42>
80015e04:	30 05       	mov	r5,0
80015e06:	6e 1b       	ld.w	r11,r7[0x4]
80015e08:	c5 6f       	rcall	80015cb4 <_Balloc>
80015e0a:	6e 49       	ld.w	r9,r7[0x10]
80015e0c:	6c 44       	ld.w	r4,r6[0x10]
80015e0e:	99 35       	st.w	r12[0xc],r5
80015e10:	2f b4       	sub	r4,-5
80015e12:	f2 c5 ff fb 	sub	r5,r9,-5
80015e16:	ec 04 00 24 	add	r4,r6,r4<<0x2
80015e1a:	ee 05 00 25 	add	r5,r7,r5<<0x2
80015e1e:	2e c6       	sub	r6,-20
80015e20:	2e c7       	sub	r7,-20
80015e22:	f8 c8 ff ec 	sub	r8,r12,-20
80015e26:	30 0a       	mov	r10,0
80015e28:	0f 0e       	ld.w	lr,r7++
80015e2a:	0d 0b       	ld.w	r11,r6++
80015e2c:	fc 02 16 10 	lsr	r2,lr,0x10
80015e30:	f6 03 16 10 	lsr	r3,r11,0x10
80015e34:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80015e38:	e4 03 01 03 	sub	r3,r2,r3
80015e3c:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80015e40:	fc 0b 01 0b 	sub	r11,lr,r11
80015e44:	f6 0a 00 0a 	add	r10,r11,r10
80015e48:	b0 1a       	st.h	r8[0x2],r10
80015e4a:	b1 4a       	asr	r10,0x10
80015e4c:	e6 0a 00 0a 	add	r10,r3,r10
80015e50:	b0 0a       	st.h	r8[0x0],r10
80015e52:	2f c8       	sub	r8,-4
80015e54:	b1 4a       	asr	r10,0x10
80015e56:	08 36       	cp.w	r6,r4
80015e58:	ce 83       	brcs	80015e28 <__mdiff+0x64>
80015e5a:	c0 d8       	rjmp	80015e74 <__mdiff+0xb0>
80015e5c:	0f 0b       	ld.w	r11,r7++
80015e5e:	f6 0e 16 10 	lsr	lr,r11,0x10
80015e62:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80015e66:	16 0a       	add	r10,r11
80015e68:	b0 1a       	st.h	r8[0x2],r10
80015e6a:	b1 4a       	asr	r10,0x10
80015e6c:	1c 0a       	add	r10,lr
80015e6e:	b0 0a       	st.h	r8[0x0],r10
80015e70:	2f c8       	sub	r8,-4
80015e72:	b1 4a       	asr	r10,0x10
80015e74:	0a 37       	cp.w	r7,r5
80015e76:	cf 33       	brcs	80015e5c <__mdiff+0x98>
80015e78:	c0 28       	rjmp	80015e7c <__mdiff+0xb8>
80015e7a:	20 19       	sub	r9,1
80015e7c:	11 4a       	ld.w	r10,--r8
80015e7e:	58 0a       	cp.w	r10,0
80015e80:	cf d0       	breq	80015e7a <__mdiff+0xb6>
80015e82:	99 49       	st.w	r12[0x10],r9
80015e84:	d8 32       	popm	r0-r7,pc
80015e86:	30 0b       	mov	r11,0
80015e88:	c1 6f       	rcall	80015cb4 <_Balloc>
80015e8a:	30 18       	mov	r8,1
80015e8c:	99 48       	st.w	r12[0x10],r8
80015e8e:	30 08       	mov	r8,0
80015e90:	99 58       	st.w	r12[0x14],r8
80015e92:	d8 32       	popm	r0-r7,pc

80015e94 <__lshift>:
80015e94:	d4 31       	pushm	r0-r7,lr
80015e96:	16 97       	mov	r7,r11
80015e98:	76 46       	ld.w	r6,r11[0x10]
80015e9a:	f4 02 14 05 	asr	r2,r10,0x5
80015e9e:	2f f6       	sub	r6,-1
80015ea0:	14 93       	mov	r3,r10
80015ea2:	18 94       	mov	r4,r12
80015ea4:	04 06       	add	r6,r2
80015ea6:	76 1b       	ld.w	r11,r11[0x4]
80015ea8:	6e 28       	ld.w	r8,r7[0x8]
80015eaa:	c0 38       	rjmp	80015eb0 <__lshift+0x1c>
80015eac:	2f fb       	sub	r11,-1
80015eae:	a1 78       	lsl	r8,0x1
80015eb0:	10 36       	cp.w	r6,r8
80015eb2:	fe 99 ff fd 	brgt	80015eac <__lshift+0x18>
80015eb6:	08 9c       	mov	r12,r4
80015eb8:	cf ee       	rcall	80015cb4 <_Balloc>
80015eba:	30 09       	mov	r9,0
80015ebc:	18 95       	mov	r5,r12
80015ebe:	f8 c8 ff ec 	sub	r8,r12,-20
80015ec2:	12 9a       	mov	r10,r9
80015ec4:	c0 38       	rjmp	80015eca <__lshift+0x36>
80015ec6:	10 aa       	st.w	r8++,r10
80015ec8:	2f f9       	sub	r9,-1
80015eca:	04 39       	cp.w	r9,r2
80015ecc:	cf d5       	brlt	80015ec6 <__lshift+0x32>
80015ece:	6e 4b       	ld.w	r11,r7[0x10]
80015ed0:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
80015ed4:	2f bb       	sub	r11,-5
80015ed6:	ee c9 ff ec 	sub	r9,r7,-20
80015eda:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
80015ede:	58 03       	cp.w	r3,0
80015ee0:	c1 30       	breq	80015f06 <__lshift+0x72>
80015ee2:	e6 0c 11 20 	rsub	r12,r3,32
80015ee6:	30 0a       	mov	r10,0
80015ee8:	72 02       	ld.w	r2,r9[0x0]
80015eea:	e4 03 09 42 	lsl	r2,r2,r3
80015eee:	04 4a       	or	r10,r2
80015ef0:	10 aa       	st.w	r8++,r10
80015ef2:	13 0a       	ld.w	r10,r9++
80015ef4:	f4 0c 0a 4a 	lsr	r10,r10,r12
80015ef8:	16 39       	cp.w	r9,r11
80015efa:	cf 73       	brcs	80015ee8 <__lshift+0x54>
80015efc:	91 0a       	st.w	r8[0x0],r10
80015efe:	58 0a       	cp.w	r10,0
80015f00:	c0 70       	breq	80015f0e <__lshift+0x7a>
80015f02:	2f f6       	sub	r6,-1
80015f04:	c0 58       	rjmp	80015f0e <__lshift+0x7a>
80015f06:	13 0a       	ld.w	r10,r9++
80015f08:	10 aa       	st.w	r8++,r10
80015f0a:	16 39       	cp.w	r9,r11
80015f0c:	cf d3       	brcs	80015f06 <__lshift+0x72>
80015f0e:	08 9c       	mov	r12,r4
80015f10:	20 16       	sub	r6,1
80015f12:	0e 9b       	mov	r11,r7
80015f14:	8b 46       	st.w	r5[0x10],r6
80015f16:	cb 5e       	rcall	80015c80 <_Bfree>
80015f18:	0a 9c       	mov	r12,r5
80015f1a:	d8 32       	popm	r0-r7,pc

80015f1c <__multiply>:
80015f1c:	d4 31       	pushm	r0-r7,lr
80015f1e:	20 2d       	sub	sp,8
80015f20:	76 49       	ld.w	r9,r11[0x10]
80015f22:	74 48       	ld.w	r8,r10[0x10]
80015f24:	16 96       	mov	r6,r11
80015f26:	14 95       	mov	r5,r10
80015f28:	10 39       	cp.w	r9,r8
80015f2a:	ec 08 17 50 	movlt	r8,r6
80015f2e:	ea 06 17 50 	movlt	r6,r5
80015f32:	f0 05 17 50 	movlt	r5,r8
80015f36:	6c 28       	ld.w	r8,r6[0x8]
80015f38:	76 43       	ld.w	r3,r11[0x10]
80015f3a:	74 42       	ld.w	r2,r10[0x10]
80015f3c:	76 1b       	ld.w	r11,r11[0x4]
80015f3e:	e4 03 00 07 	add	r7,r2,r3
80015f42:	10 37       	cp.w	r7,r8
80015f44:	f7 bb 09 ff 	subgt	r11,-1
80015f48:	cb 6e       	rcall	80015cb4 <_Balloc>
80015f4a:	ee c4 ff fb 	sub	r4,r7,-5
80015f4e:	f8 c9 ff ec 	sub	r9,r12,-20
80015f52:	f8 04 00 24 	add	r4,r12,r4<<0x2
80015f56:	30 0a       	mov	r10,0
80015f58:	12 98       	mov	r8,r9
80015f5a:	c0 28       	rjmp	80015f5e <__multiply+0x42>
80015f5c:	10 aa       	st.w	r8++,r10
80015f5e:	08 38       	cp.w	r8,r4
80015f60:	cf e3       	brcs	80015f5c <__multiply+0x40>
80015f62:	2f b3       	sub	r3,-5
80015f64:	2f b2       	sub	r2,-5
80015f66:	ec 03 00 23 	add	r3,r6,r3<<0x2
80015f6a:	ea 02 00 22 	add	r2,r5,r2<<0x2
80015f6e:	ec cb ff ec 	sub	r11,r6,-20
80015f72:	50 12       	stdsp	sp[0x4],r2
80015f74:	ea ca ff ec 	sub	r10,r5,-20
80015f78:	c4 48       	rjmp	80016000 <__multiply+0xe4>
80015f7a:	94 95       	ld.uh	r5,r10[0x2]
80015f7c:	58 05       	cp.w	r5,0
80015f7e:	c2 00       	breq	80015fbe <__multiply+0xa2>
80015f80:	12 98       	mov	r8,r9
80015f82:	16 96       	mov	r6,r11
80015f84:	30 0e       	mov	lr,0
80015f86:	50 09       	stdsp	sp[0x0],r9
80015f88:	0d 02       	ld.w	r2,r6++
80015f8a:	e4 00 16 10 	lsr	r0,r2,0x10
80015f8e:	70 01       	ld.w	r1,r8[0x0]
80015f90:	70 09       	ld.w	r9,r8[0x0]
80015f92:	b1 81       	lsr	r1,0x10
80015f94:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
80015f98:	e0 05 03 41 	mac	r1,r0,r5
80015f9c:	ab 32       	mul	r2,r5
80015f9e:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
80015fa2:	00 02       	add	r2,r0
80015fa4:	e4 0e 00 0e 	add	lr,r2,lr
80015fa8:	b0 1e       	st.h	r8[0x2],lr
80015faa:	b1 8e       	lsr	lr,0x10
80015fac:	1c 01       	add	r1,lr
80015fae:	b0 01       	st.h	r8[0x0],r1
80015fb0:	e2 0e 16 10 	lsr	lr,r1,0x10
80015fb4:	2f c8       	sub	r8,-4
80015fb6:	06 36       	cp.w	r6,r3
80015fb8:	ce 83       	brcs	80015f88 <__multiply+0x6c>
80015fba:	40 09       	lddsp	r9,sp[0x0]
80015fbc:	91 0e       	st.w	r8[0x0],lr
80015fbe:	94 86       	ld.uh	r6,r10[0x0]
80015fc0:	58 06       	cp.w	r6,0
80015fc2:	c1 d0       	breq	80015ffc <__multiply+0xe0>
80015fc4:	72 02       	ld.w	r2,r9[0x0]
80015fc6:	12 98       	mov	r8,r9
80015fc8:	16 9e       	mov	lr,r11
80015fca:	30 05       	mov	r5,0
80015fcc:	b0 12       	st.h	r8[0x2],r2
80015fce:	1d 01       	ld.w	r1,lr++
80015fd0:	90 82       	ld.uh	r2,r8[0x0]
80015fd2:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
80015fd6:	ad 30       	mul	r0,r6
80015fd8:	e0 02 00 02 	add	r2,r0,r2
80015fdc:	e4 05 00 05 	add	r5,r2,r5
80015fe0:	b0 05       	st.h	r8[0x0],r5
80015fe2:	b1 85       	lsr	r5,0x10
80015fe4:	b1 81       	lsr	r1,0x10
80015fe6:	2f c8       	sub	r8,-4
80015fe8:	ad 31       	mul	r1,r6
80015fea:	90 92       	ld.uh	r2,r8[0x2]
80015fec:	e2 02 00 02 	add	r2,r1,r2
80015ff0:	0a 02       	add	r2,r5
80015ff2:	e4 05 16 10 	lsr	r5,r2,0x10
80015ff6:	06 3e       	cp.w	lr,r3
80015ff8:	ce a3       	brcs	80015fcc <__multiply+0xb0>
80015ffa:	91 02       	st.w	r8[0x0],r2
80015ffc:	2f ca       	sub	r10,-4
80015ffe:	2f c9       	sub	r9,-4
80016000:	40 18       	lddsp	r8,sp[0x4]
80016002:	10 3a       	cp.w	r10,r8
80016004:	cb b3       	brcs	80015f7a <__multiply+0x5e>
80016006:	c0 28       	rjmp	8001600a <__multiply+0xee>
80016008:	20 17       	sub	r7,1
8001600a:	58 07       	cp.w	r7,0
8001600c:	e0 8a 00 05 	brle	80016016 <__multiply+0xfa>
80016010:	09 48       	ld.w	r8,--r4
80016012:	58 08       	cp.w	r8,0
80016014:	cf a0       	breq	80016008 <__multiply+0xec>
80016016:	99 47       	st.w	r12[0x10],r7
80016018:	2f ed       	sub	sp,-8
8001601a:	d8 32       	popm	r0-r7,pc

8001601c <__i2b>:
8001601c:	d4 21       	pushm	r4-r7,lr
8001601e:	16 97       	mov	r7,r11
80016020:	30 1b       	mov	r11,1
80016022:	c4 9e       	rcall	80015cb4 <_Balloc>
80016024:	30 19       	mov	r9,1
80016026:	99 57       	st.w	r12[0x14],r7
80016028:	99 49       	st.w	r12[0x10],r9
8001602a:	d8 22       	popm	r4-r7,pc

8001602c <__multadd>:
8001602c:	d4 31       	pushm	r0-r7,lr
8001602e:	30 08       	mov	r8,0
80016030:	12 95       	mov	r5,r9
80016032:	16 97       	mov	r7,r11
80016034:	18 96       	mov	r6,r12
80016036:	76 44       	ld.w	r4,r11[0x10]
80016038:	f6 c9 ff ec 	sub	r9,r11,-20
8001603c:	72 0b       	ld.w	r11,r9[0x0]
8001603e:	f6 0c 16 10 	lsr	r12,r11,0x10
80016042:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80016046:	f4 0c 02 4c 	mul	r12,r10,r12
8001604a:	f4 0b 03 45 	mac	r5,r10,r11
8001604e:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
80016052:	b1 85       	lsr	r5,0x10
80016054:	18 05       	add	r5,r12
80016056:	ea 0c 15 10 	lsl	r12,r5,0x10
8001605a:	f8 0b 00 0b 	add	r11,r12,r11
8001605e:	12 ab       	st.w	r9++,r11
80016060:	2f f8       	sub	r8,-1
80016062:	b1 85       	lsr	r5,0x10
80016064:	08 38       	cp.w	r8,r4
80016066:	ce b5       	brlt	8001603c <__multadd+0x10>
80016068:	58 05       	cp.w	r5,0
8001606a:	c1 c0       	breq	800160a2 <__multadd+0x76>
8001606c:	6e 28       	ld.w	r8,r7[0x8]
8001606e:	10 34       	cp.w	r4,r8
80016070:	c1 35       	brlt	80016096 <__multadd+0x6a>
80016072:	6e 1b       	ld.w	r11,r7[0x4]
80016074:	0c 9c       	mov	r12,r6
80016076:	2f fb       	sub	r11,-1
80016078:	c1 ee       	rcall	80015cb4 <_Balloc>
8001607a:	6e 4a       	ld.w	r10,r7[0x10]
8001607c:	ee cb ff f4 	sub	r11,r7,-12
80016080:	18 93       	mov	r3,r12
80016082:	2f ea       	sub	r10,-2
80016084:	2f 4c       	sub	r12,-12
80016086:	a3 6a       	lsl	r10,0x2
80016088:	fe b0 d1 5a 	rcall	8001033c <memcpy>
8001608c:	0e 9b       	mov	r11,r7
8001608e:	0c 9c       	mov	r12,r6
80016090:	fe b0 fd f8 	rcall	80015c80 <_Bfree>
80016094:	06 97       	mov	r7,r3
80016096:	e8 c8 ff ff 	sub	r8,r4,-1
8001609a:	2f b4       	sub	r4,-5
8001609c:	8f 48       	st.w	r7[0x10],r8
8001609e:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
800160a2:	0e 9c       	mov	r12,r7
800160a4:	d8 32       	popm	r0-r7,pc
800160a6:	d7 03       	nop

800160a8 <__pow5mult>:
800160a8:	d4 31       	pushm	r0-r7,lr
800160aa:	14 96       	mov	r6,r10
800160ac:	18 97       	mov	r7,r12
800160ae:	16 94       	mov	r4,r11
800160b0:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
800160b4:	c0 90       	breq	800160c6 <__pow5mult+0x1e>
800160b6:	20 18       	sub	r8,1
800160b8:	fe c9 d1 f8 	sub	r9,pc,-11784
800160bc:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
800160c0:	30 09       	mov	r9,0
800160c2:	cb 5f       	rcall	8001602c <__multadd>
800160c4:	18 94       	mov	r4,r12
800160c6:	a3 46       	asr	r6,0x2
800160c8:	c3 40       	breq	80016130 <__pow5mult+0x88>
800160ca:	6e 95       	ld.w	r5,r7[0x24]
800160cc:	58 05       	cp.w	r5,0
800160ce:	c0 91       	brne	800160e0 <__pow5mult+0x38>
800160d0:	31 0c       	mov	r12,16
800160d2:	fe b0 cf 15 	rcall	8000fefc <malloc>
800160d6:	99 35       	st.w	r12[0xc],r5
800160d8:	8f 9c       	st.w	r7[0x24],r12
800160da:	99 15       	st.w	r12[0x4],r5
800160dc:	99 25       	st.w	r12[0x8],r5
800160de:	99 05       	st.w	r12[0x0],r5
800160e0:	6e 93       	ld.w	r3,r7[0x24]
800160e2:	66 25       	ld.w	r5,r3[0x8]
800160e4:	58 05       	cp.w	r5,0
800160e6:	c0 c1       	brne	800160fe <__pow5mult+0x56>
800160e8:	e0 6b 02 71 	mov	r11,625
800160ec:	0e 9c       	mov	r12,r7
800160ee:	c9 7f       	rcall	8001601c <__i2b>
800160f0:	87 2c       	st.w	r3[0x8],r12
800160f2:	30 08       	mov	r8,0
800160f4:	18 95       	mov	r5,r12
800160f6:	99 08       	st.w	r12[0x0],r8
800160f8:	c0 38       	rjmp	800160fe <__pow5mult+0x56>
800160fa:	06 9c       	mov	r12,r3
800160fc:	18 95       	mov	r5,r12
800160fe:	ed b6 00 00 	bld	r6,0x0
80016102:	c0 b1       	brne	80016118 <__pow5mult+0x70>
80016104:	08 9b       	mov	r11,r4
80016106:	0a 9a       	mov	r10,r5
80016108:	0e 9c       	mov	r12,r7
8001610a:	c0 9f       	rcall	80015f1c <__multiply>
8001610c:	08 9b       	mov	r11,r4
8001610e:	18 93       	mov	r3,r12
80016110:	0e 9c       	mov	r12,r7
80016112:	06 94       	mov	r4,r3
80016114:	fe b0 fd b6 	rcall	80015c80 <_Bfree>
80016118:	a1 56       	asr	r6,0x1
8001611a:	c0 b0       	breq	80016130 <__pow5mult+0x88>
8001611c:	6a 03       	ld.w	r3,r5[0x0]
8001611e:	58 03       	cp.w	r3,0
80016120:	ce d1       	brne	800160fa <__pow5mult+0x52>
80016122:	0a 9a       	mov	r10,r5
80016124:	0a 9b       	mov	r11,r5
80016126:	0e 9c       	mov	r12,r7
80016128:	cf ae       	rcall	80015f1c <__multiply>
8001612a:	8b 0c       	st.w	r5[0x0],r12
8001612c:	99 03       	st.w	r12[0x0],r3
8001612e:	ce 7b       	rjmp	800160fc <__pow5mult+0x54>
80016130:	08 9c       	mov	r12,r4
80016132:	d8 32       	popm	r0-r7,pc

80016134 <__isinfd>:
80016134:	14 98       	mov	r8,r10
80016136:	fc 19 7f f0 	movh	r9,0x7ff0
8001613a:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8001613e:	f0 0b 11 00 	rsub	r11,r8,0
80016142:	f7 e8 10 08 	or	r8,r11,r8
80016146:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8001614a:	f2 08 01 08 	sub	r8,r9,r8
8001614e:	f0 0c 11 00 	rsub	r12,r8,0
80016152:	f9 e8 10 08 	or	r8,r12,r8
80016156:	f0 0c 14 1f 	asr	r12,r8,0x1f
8001615a:	2f fc       	sub	r12,-1
8001615c:	5e fc       	retal	r12

8001615e <__isnand>:
8001615e:	14 98       	mov	r8,r10
80016160:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
80016164:	f0 0c 11 00 	rsub	r12,r8,0
80016168:	10 4c       	or	r12,r8
8001616a:	fc 18 7f f0 	movh	r8,0x7ff0
8001616e:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
80016172:	f0 0c 01 0c 	sub	r12,r8,r12
80016176:	bf 9c       	lsr	r12,0x1f
80016178:	5e fc       	retal	r12
8001617a:	d7 03       	nop

8001617c <_raise_r>:
8001617c:	d4 21       	pushm	r4-r7,lr
8001617e:	18 97       	mov	r7,r12
80016180:	16 96       	mov	r6,r11
80016182:	59 fb       	cp.w	r11,31
80016184:	e0 88 00 05 	brls	8001618e <_raise_r+0x12>
80016188:	31 68       	mov	r8,22
8001618a:	99 38       	st.w	r12[0xc],r8
8001618c:	dc 2a       	popm	r4-r7,pc,r12=-1
8001618e:	79 19       	ld.w	r9,r12[0x44]
80016190:	58 09       	cp.w	r9,0
80016192:	c0 60       	breq	8001619e <_raise_r+0x22>
80016194:	f2 0b 00 29 	add	r9,r9,r11<<0x2
80016198:	72 08       	ld.w	r8,r9[0x0]
8001619a:	58 08       	cp.w	r8,0
8001619c:	c0 81       	brne	800161ac <_raise_r+0x30>
8001619e:	0e 9c       	mov	r12,r7
800161a0:	c1 cc       	rcall	800161d8 <_getpid_r>
800161a2:	0c 9a       	mov	r10,r6
800161a4:	18 9b       	mov	r11,r12
800161a6:	0e 9c       	mov	r12,r7
800161a8:	c1 cc       	rcall	800161e0 <_kill_r>
800161aa:	d8 22       	popm	r4-r7,pc
800161ac:	58 18       	cp.w	r8,1
800161ae:	c0 21       	brne	800161b2 <_raise_r+0x36>
800161b0:	d8 2a       	popm	r4-r7,pc,r12=0
800161b2:	5b f8       	cp.w	r8,-1
800161b4:	c0 41       	brne	800161bc <_raise_r+0x40>
800161b6:	31 68       	mov	r8,22
800161b8:	99 38       	st.w	r12[0xc],r8
800161ba:	da 2a       	popm	r4-r7,pc,r12=1
800161bc:	30 07       	mov	r7,0
800161be:	16 9c       	mov	r12,r11
800161c0:	93 07       	st.w	r9[0x0],r7
800161c2:	5d 18       	icall	r8
800161c4:	0e 9c       	mov	r12,r7
800161c6:	d8 22       	popm	r4-r7,pc

800161c8 <raise>:
800161c8:	d4 01       	pushm	lr
800161ca:	e0 68 01 4c 	mov	r8,332
800161ce:	18 9b       	mov	r11,r12
800161d0:	70 0c       	ld.w	r12,r8[0x0]
800161d2:	cd 5f       	rcall	8001617c <_raise_r>
800161d4:	d8 02       	popm	pc
800161d6:	d7 03       	nop

800161d8 <_getpid_r>:
800161d8:	d4 01       	pushm	lr
800161da:	fe b0 d3 68 	rcall	800108aa <_getpid>
800161de:	d8 02       	popm	pc

800161e0 <_kill_r>:
800161e0:	d4 21       	pushm	r4-r7,lr
800161e2:	16 98       	mov	r8,r11
800161e4:	18 97       	mov	r7,r12
800161e6:	10 9c       	mov	r12,r8
800161e8:	30 08       	mov	r8,0
800161ea:	e0 66 12 10 	mov	r6,4624
800161ee:	14 9b       	mov	r11,r10
800161f0:	8d 08       	st.w	r6[0x0],r8
800161f2:	fe b0 d3 5b 	rcall	800108a8 <_kill>
800161f6:	5b fc       	cp.w	r12,-1
800161f8:	c0 51       	brne	80016202 <_kill_r+0x22>
800161fa:	6c 08       	ld.w	r8,r6[0x0]
800161fc:	58 08       	cp.w	r8,0
800161fe:	ef f8 1a 03 	st.wne	r7[0xc],r8
80016202:	d8 22       	popm	r4-r7,pc

80016204 <__sclose>:
80016204:	d4 01       	pushm	lr
80016206:	96 7b       	ld.sh	r11,r11[0xe]
80016208:	c7 6c       	rcall	800162f4 <_close_r>
8001620a:	d8 02       	popm	pc

8001620c <__sseek>:
8001620c:	d4 21       	pushm	r4-r7,lr
8001620e:	16 97       	mov	r7,r11
80016210:	96 7b       	ld.sh	r11,r11[0xe]
80016212:	cf 7c       	rcall	80016400 <_lseek_r>
80016214:	8e 68       	ld.sh	r8,r7[0xc]
80016216:	10 99       	mov	r9,r8
80016218:	ad c8       	cbr	r8,0xc
8001621a:	ad a9       	sbr	r9,0xc
8001621c:	5b fc       	cp.w	r12,-1
8001621e:	ef f8 0c 06 	st.heq	r7[0xc],r8
80016222:	ef f9 1c 06 	st.hne	r7[0xc],r9
80016226:	ef fc 1a 15 	st.wne	r7[0x54],r12
8001622a:	d8 22       	popm	r4-r7,pc

8001622c <__swrite>:
8001622c:	d4 21       	pushm	r4-r7,lr
8001622e:	96 68       	ld.sh	r8,r11[0xc]
80016230:	16 97       	mov	r7,r11
80016232:	14 95       	mov	r5,r10
80016234:	12 94       	mov	r4,r9
80016236:	e2 18 01 00 	andl	r8,0x100,COH
8001623a:	18 96       	mov	r6,r12
8001623c:	c0 50       	breq	80016246 <__swrite+0x1a>
8001623e:	30 29       	mov	r9,2
80016240:	30 0a       	mov	r10,0
80016242:	96 7b       	ld.sh	r11,r11[0xe]
80016244:	cd ec       	rcall	80016400 <_lseek_r>
80016246:	8e 68       	ld.sh	r8,r7[0xc]
80016248:	ad c8       	cbr	r8,0xc
8001624a:	08 99       	mov	r9,r4
8001624c:	0a 9a       	mov	r10,r5
8001624e:	8e 7b       	ld.sh	r11,r7[0xe]
80016250:	0c 9c       	mov	r12,r6
80016252:	ae 68       	st.h	r7[0xc],r8
80016254:	c1 0c       	rcall	80016274 <_write_r>
80016256:	d8 22       	popm	r4-r7,pc

80016258 <__sread>:
80016258:	d4 21       	pushm	r4-r7,lr
8001625a:	16 97       	mov	r7,r11
8001625c:	96 7b       	ld.sh	r11,r11[0xe]
8001625e:	ce 5c       	rcall	80016428 <_read_r>
80016260:	c0 65       	brlt	8001626c <__sread+0x14>
80016262:	6f 58       	ld.w	r8,r7[0x54]
80016264:	18 08       	add	r8,r12
80016266:	ef 48 00 54 	st.w	r7[84],r8
8001626a:	d8 22       	popm	r4-r7,pc
8001626c:	8e 68       	ld.sh	r8,r7[0xc]
8001626e:	ad c8       	cbr	r8,0xc
80016270:	ae 68       	st.h	r7[0xc],r8
80016272:	d8 22       	popm	r4-r7,pc

80016274 <_write_r>:
80016274:	d4 21       	pushm	r4-r7,lr
80016276:	16 98       	mov	r8,r11
80016278:	18 97       	mov	r7,r12
8001627a:	10 9c       	mov	r12,r8
8001627c:	30 08       	mov	r8,0
8001627e:	14 9b       	mov	r11,r10
80016280:	e0 66 12 10 	mov	r6,4624
80016284:	12 9a       	mov	r10,r9
80016286:	8d 08       	st.w	r6[0x0],r8
80016288:	fe b0 d2 cc 	rcall	80010820 <_write>
8001628c:	5b fc       	cp.w	r12,-1
8001628e:	c0 51       	brne	80016298 <_write_r+0x24>
80016290:	6c 08       	ld.w	r8,r6[0x0]
80016292:	58 08       	cp.w	r8,0
80016294:	ef f8 1a 03 	st.wne	r7[0xc],r8
80016298:	d8 22       	popm	r4-r7,pc
8001629a:	d7 03       	nop

8001629c <_calloc_r>:
8001629c:	d4 21       	pushm	r4-r7,lr
8001629e:	f4 0b 02 4b 	mul	r11,r10,r11
800162a2:	fe b0 ce 35 	rcall	8000ff0c <_malloc_r>
800162a6:	18 97       	mov	r7,r12
800162a8:	c2 30       	breq	800162ee <_calloc_r+0x52>
800162aa:	f8 fa ff fc 	ld.w	r10,r12[-4]
800162ae:	e0 1a ff fc 	andl	r10,0xfffc
800162b2:	20 4a       	sub	r10,4
800162b4:	e0 4a 00 24 	cp.w	r10,36
800162b8:	e0 8b 00 18 	brhi	800162e8 <_calloc_r+0x4c>
800162bc:	18 98       	mov	r8,r12
800162be:	59 3a       	cp.w	r10,19
800162c0:	e0 88 00 0f 	brls	800162de <_calloc_r+0x42>
800162c4:	30 09       	mov	r9,0
800162c6:	10 a9       	st.w	r8++,r9
800162c8:	10 a9       	st.w	r8++,r9
800162ca:	59 ba       	cp.w	r10,27
800162cc:	e0 88 00 09 	brls	800162de <_calloc_r+0x42>
800162d0:	10 a9       	st.w	r8++,r9
800162d2:	10 a9       	st.w	r8++,r9
800162d4:	e0 4a 00 24 	cp.w	r10,36
800162d8:	c0 31       	brne	800162de <_calloc_r+0x42>
800162da:	10 a9       	st.w	r8++,r9
800162dc:	10 a9       	st.w	r8++,r9
800162de:	30 09       	mov	r9,0
800162e0:	10 a9       	st.w	r8++,r9
800162e2:	91 19       	st.w	r8[0x4],r9
800162e4:	91 09       	st.w	r8[0x0],r9
800162e6:	c0 48       	rjmp	800162ee <_calloc_r+0x52>
800162e8:	30 0b       	mov	r11,0
800162ea:	fe b0 d0 cd 	rcall	80010484 <memset>
800162ee:	0e 9c       	mov	r12,r7
800162f0:	d8 22       	popm	r4-r7,pc
800162f2:	d7 03       	nop

800162f4 <_close_r>:
800162f4:	d4 21       	pushm	r4-r7,lr
800162f6:	30 08       	mov	r8,0
800162f8:	18 97       	mov	r7,r12
800162fa:	e0 66 12 10 	mov	r6,4624
800162fe:	16 9c       	mov	r12,r11
80016300:	8d 08       	st.w	r6[0x0],r8
80016302:	fe b0 d2 71 	rcall	800107e4 <_close>
80016306:	5b fc       	cp.w	r12,-1
80016308:	c0 51       	brne	80016312 <_close_r+0x1e>
8001630a:	6c 08       	ld.w	r8,r6[0x0]
8001630c:	58 08       	cp.w	r8,0
8001630e:	ef f8 1a 03 	st.wne	r7[0xc],r8
80016312:	d8 22       	popm	r4-r7,pc

80016314 <_fclose_r>:
80016314:	d4 21       	pushm	r4-r7,lr
80016316:	18 96       	mov	r6,r12
80016318:	16 97       	mov	r7,r11
8001631a:	58 0b       	cp.w	r11,0
8001631c:	c0 31       	brne	80016322 <_fclose_r+0xe>
8001631e:	16 95       	mov	r5,r11
80016320:	c5 38       	rjmp	800163c6 <_fclose_r+0xb2>
80016322:	fe b0 f8 71 	rcall	80015404 <__sfp_lock_acquire>
80016326:	58 06       	cp.w	r6,0
80016328:	c0 70       	breq	80016336 <_fclose_r+0x22>
8001632a:	6c 68       	ld.w	r8,r6[0x18]
8001632c:	58 08       	cp.w	r8,0
8001632e:	c0 41       	brne	80016336 <_fclose_r+0x22>
80016330:	0c 9c       	mov	r12,r6
80016332:	fe b0 f8 bb 	rcall	800154a8 <__sinit>
80016336:	fe c8 d5 16 	sub	r8,pc,-10986
8001633a:	10 37       	cp.w	r7,r8
8001633c:	c0 31       	brne	80016342 <_fclose_r+0x2e>
8001633e:	6c 07       	ld.w	r7,r6[0x0]
80016340:	c0 c8       	rjmp	80016358 <_fclose_r+0x44>
80016342:	fe c8 d5 02 	sub	r8,pc,-11006
80016346:	10 37       	cp.w	r7,r8
80016348:	c0 31       	brne	8001634e <_fclose_r+0x3a>
8001634a:	6c 17       	ld.w	r7,r6[0x4]
8001634c:	c0 68       	rjmp	80016358 <_fclose_r+0x44>
8001634e:	fe c8 d4 ee 	sub	r8,pc,-11026
80016352:	10 37       	cp.w	r7,r8
80016354:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80016358:	8e 69       	ld.sh	r9,r7[0xc]
8001635a:	30 08       	mov	r8,0
8001635c:	f0 09 19 00 	cp.h	r9,r8
80016360:	c0 51       	brne	8001636a <_fclose_r+0x56>
80016362:	fe b0 f8 52 	rcall	80015406 <__sfp_lock_release>
80016366:	30 05       	mov	r5,0
80016368:	c2 f8       	rjmp	800163c6 <_fclose_r+0xb2>
8001636a:	0e 9b       	mov	r11,r7
8001636c:	0c 9c       	mov	r12,r6
8001636e:	fe b0 f7 c5 	rcall	800152f8 <_fflush_r>
80016372:	6e c8       	ld.w	r8,r7[0x30]
80016374:	18 95       	mov	r5,r12
80016376:	58 08       	cp.w	r8,0
80016378:	c0 60       	breq	80016384 <_fclose_r+0x70>
8001637a:	6e 8b       	ld.w	r11,r7[0x20]
8001637c:	0c 9c       	mov	r12,r6
8001637e:	5d 18       	icall	r8
80016380:	f9 b5 05 ff 	movlt	r5,-1
80016384:	8e 68       	ld.sh	r8,r7[0xc]
80016386:	ed b8 00 07 	bld	r8,0x7
8001638a:	c0 51       	brne	80016394 <_fclose_r+0x80>
8001638c:	6e 4b       	ld.w	r11,r7[0x10]
8001638e:	0c 9c       	mov	r12,r6
80016390:	fe b0 f9 26 	rcall	800155dc <_free_r>
80016394:	6e db       	ld.w	r11,r7[0x34]
80016396:	58 0b       	cp.w	r11,0
80016398:	c0 a0       	breq	800163ac <_fclose_r+0x98>
8001639a:	ee c8 ff bc 	sub	r8,r7,-68
8001639e:	10 3b       	cp.w	r11,r8
800163a0:	c0 40       	breq	800163a8 <_fclose_r+0x94>
800163a2:	0c 9c       	mov	r12,r6
800163a4:	fe b0 f9 1c 	rcall	800155dc <_free_r>
800163a8:	30 08       	mov	r8,0
800163aa:	8f d8       	st.w	r7[0x34],r8
800163ac:	6f 2b       	ld.w	r11,r7[0x48]
800163ae:	58 0b       	cp.w	r11,0
800163b0:	c0 70       	breq	800163be <_fclose_r+0xaa>
800163b2:	0c 9c       	mov	r12,r6
800163b4:	fe b0 f9 14 	rcall	800155dc <_free_r>
800163b8:	30 08       	mov	r8,0
800163ba:	ef 48 00 48 	st.w	r7[72],r8
800163be:	30 08       	mov	r8,0
800163c0:	ae 68       	st.h	r7[0xc],r8
800163c2:	fe b0 f8 22 	rcall	80015406 <__sfp_lock_release>
800163c6:	0a 9c       	mov	r12,r5
800163c8:	d8 22       	popm	r4-r7,pc
800163ca:	d7 03       	nop

800163cc <fclose>:
800163cc:	d4 01       	pushm	lr
800163ce:	e0 68 01 4c 	mov	r8,332
800163d2:	18 9b       	mov	r11,r12
800163d4:	70 0c       	ld.w	r12,r8[0x0]
800163d6:	c9 ff       	rcall	80016314 <_fclose_r>
800163d8:	d8 02       	popm	pc
800163da:	d7 03       	nop

800163dc <_fstat_r>:
800163dc:	d4 21       	pushm	r4-r7,lr
800163de:	16 98       	mov	r8,r11
800163e0:	18 97       	mov	r7,r12
800163e2:	10 9c       	mov	r12,r8
800163e4:	30 08       	mov	r8,0
800163e6:	e0 66 12 10 	mov	r6,4624
800163ea:	14 9b       	mov	r11,r10
800163ec:	8d 08       	st.w	r6[0x0],r8
800163ee:	fe b0 d2 37 	rcall	8001085c <_fstat>
800163f2:	5b fc       	cp.w	r12,-1
800163f4:	c0 51       	brne	800163fe <_fstat_r+0x22>
800163f6:	6c 08       	ld.w	r8,r6[0x0]
800163f8:	58 08       	cp.w	r8,0
800163fa:	ef f8 1a 03 	st.wne	r7[0xc],r8
800163fe:	d8 22       	popm	r4-r7,pc

80016400 <_lseek_r>:
80016400:	d4 21       	pushm	r4-r7,lr
80016402:	16 98       	mov	r8,r11
80016404:	18 97       	mov	r7,r12
80016406:	10 9c       	mov	r12,r8
80016408:	30 08       	mov	r8,0
8001640a:	14 9b       	mov	r11,r10
8001640c:	e0 66 12 10 	mov	r6,4624
80016410:	12 9a       	mov	r10,r9
80016412:	8d 08       	st.w	r6[0x0],r8
80016414:	fe b0 d1 f2 	rcall	800107f8 <_lseek>
80016418:	5b fc       	cp.w	r12,-1
8001641a:	c0 51       	brne	80016424 <_lseek_r+0x24>
8001641c:	6c 08       	ld.w	r8,r6[0x0]
8001641e:	58 08       	cp.w	r8,0
80016420:	ef f8 1a 03 	st.wne	r7[0xc],r8
80016424:	d8 22       	popm	r4-r7,pc
80016426:	d7 03       	nop

80016428 <_read_r>:
80016428:	d4 21       	pushm	r4-r7,lr
8001642a:	16 98       	mov	r8,r11
8001642c:	18 97       	mov	r7,r12
8001642e:	10 9c       	mov	r12,r8
80016430:	30 08       	mov	r8,0
80016432:	14 9b       	mov	r11,r10
80016434:	e0 66 12 10 	mov	r6,4624
80016438:	12 9a       	mov	r10,r9
8001643a:	8d 08       	st.w	r6[0x0],r8
8001643c:	fe b0 d1 e8 	rcall	8001080c <_read>
80016440:	5b fc       	cp.w	r12,-1
80016442:	c0 51       	brne	8001644c <_read_r+0x24>
80016444:	6c 08       	ld.w	r8,r6[0x0]
80016446:	58 08       	cp.w	r8,0
80016448:	ef f8 1a 03 	st.wne	r7[0xc],r8
8001644c:	d8 22       	popm	r4-r7,pc
8001644e:	d7 03       	nop

80016450 <__avr32_f64_cmp_eq>:
80016450:	10 3a       	cp.w	r10,r8
80016452:	f2 0b 13 00 	cpc	r11,r9
80016456:	c0 80       	breq	80016466 <__avr32_f64_cmp_eq+0x16>
80016458:	a1 7b       	lsl	r11,0x1
8001645a:	a1 79       	lsl	r9,0x1
8001645c:	14 4b       	or	r11,r10
8001645e:	12 4b       	or	r11,r9
80016460:	10 4b       	or	r11,r8
80016462:	5e 0f       	reteq	1
80016464:	5e fd       	retal	0
80016466:	a1 7b       	lsl	r11,0x1
80016468:	fc 1c ff e0 	movh	r12,0xffe0
8001646c:	58 0a       	cp.w	r10,0
8001646e:	f8 0b 13 00 	cpc	r11,r12
80016472:	5e 8f       	retls	1
80016474:	5e fd       	retal	0

80016476 <__avr32_f64_cmp_ge>:
80016476:	1a de       	st.w	--sp,lr
80016478:	1a d7       	st.w	--sp,r7
8001647a:	a1 7b       	lsl	r11,0x1
8001647c:	5f 3c       	srlo	r12
8001647e:	a1 79       	lsl	r9,0x1
80016480:	5f 37       	srlo	r7
80016482:	5c fc       	rol	r12
80016484:	fc 1e ff e0 	movh	lr,0xffe0
80016488:	58 0a       	cp.w	r10,0
8001648a:	fc 0b 13 00 	cpc	r11,lr
8001648e:	e0 8b 00 1d 	brhi	800164c8 <__avr32_f64_cmp_ge+0x52>
80016492:	58 08       	cp.w	r8,0
80016494:	fc 09 13 00 	cpc	r9,lr
80016498:	e0 8b 00 18 	brhi	800164c8 <__avr32_f64_cmp_ge+0x52>
8001649c:	58 0b       	cp.w	r11,0
8001649e:	f5 ba 00 00 	subfeq	r10,0
800164a2:	c1 50       	breq	800164cc <__avr32_f64_cmp_ge+0x56>
800164a4:	1b 07       	ld.w	r7,sp++
800164a6:	1b 0e       	ld.w	lr,sp++
800164a8:	58 3c       	cp.w	r12,3
800164aa:	c0 a0       	breq	800164be <__avr32_f64_cmp_ge+0x48>
800164ac:	58 1c       	cp.w	r12,1
800164ae:	c0 33       	brcs	800164b4 <__avr32_f64_cmp_ge+0x3e>
800164b0:	5e 0f       	reteq	1
800164b2:	5e 1d       	retne	0
800164b4:	10 3a       	cp.w	r10,r8
800164b6:	f2 0b 13 00 	cpc	r11,r9
800164ba:	5e 2f       	reths	1
800164bc:	5e 3d       	retlo	0
800164be:	14 38       	cp.w	r8,r10
800164c0:	f6 09 13 00 	cpc	r9,r11
800164c4:	5e 2f       	reths	1
800164c6:	5e 3d       	retlo	0
800164c8:	1b 07       	ld.w	r7,sp++
800164ca:	d8 0a       	popm	pc,r12=0
800164cc:	58 17       	cp.w	r7,1
800164ce:	5f 0c       	sreq	r12
800164d0:	58 09       	cp.w	r9,0
800164d2:	f5 b8 00 00 	subfeq	r8,0
800164d6:	1b 07       	ld.w	r7,sp++
800164d8:	1b 0e       	ld.w	lr,sp++
800164da:	5e 0f       	reteq	1
800164dc:	5e fc       	retal	r12

800164de <__avr32_f64_cmp_lt>:
800164de:	1a de       	st.w	--sp,lr
800164e0:	1a d7       	st.w	--sp,r7
800164e2:	a1 7b       	lsl	r11,0x1
800164e4:	5f 3c       	srlo	r12
800164e6:	a1 79       	lsl	r9,0x1
800164e8:	5f 37       	srlo	r7
800164ea:	5c fc       	rol	r12
800164ec:	fc 1e ff e0 	movh	lr,0xffe0
800164f0:	58 0a       	cp.w	r10,0
800164f2:	fc 0b 13 00 	cpc	r11,lr
800164f6:	e0 8b 00 1d 	brhi	80016530 <__avr32_f64_cmp_lt+0x52>
800164fa:	58 08       	cp.w	r8,0
800164fc:	fc 09 13 00 	cpc	r9,lr
80016500:	e0 8b 00 18 	brhi	80016530 <__avr32_f64_cmp_lt+0x52>
80016504:	58 0b       	cp.w	r11,0
80016506:	f5 ba 00 00 	subfeq	r10,0
8001650a:	c1 50       	breq	80016534 <__avr32_f64_cmp_lt+0x56>
8001650c:	1b 07       	ld.w	r7,sp++
8001650e:	1b 0e       	ld.w	lr,sp++
80016510:	58 3c       	cp.w	r12,3
80016512:	c0 a0       	breq	80016526 <__avr32_f64_cmp_lt+0x48>
80016514:	58 1c       	cp.w	r12,1
80016516:	c0 33       	brcs	8001651c <__avr32_f64_cmp_lt+0x3e>
80016518:	5e 0d       	reteq	0
8001651a:	5e 1f       	retne	1
8001651c:	10 3a       	cp.w	r10,r8
8001651e:	f2 0b 13 00 	cpc	r11,r9
80016522:	5e 2d       	reths	0
80016524:	5e 3f       	retlo	1
80016526:	14 38       	cp.w	r8,r10
80016528:	f6 09 13 00 	cpc	r9,r11
8001652c:	5e 2d       	reths	0
8001652e:	5e 3f       	retlo	1
80016530:	1b 07       	ld.w	r7,sp++
80016532:	d8 0a       	popm	pc,r12=0
80016534:	58 17       	cp.w	r7,1
80016536:	5f 1c       	srne	r12
80016538:	58 09       	cp.w	r9,0
8001653a:	f5 b8 00 00 	subfeq	r8,0
8001653e:	1b 07       	ld.w	r7,sp++
80016540:	1b 0e       	ld.w	lr,sp++
80016542:	5e 0d       	reteq	0
80016544:	5e fc       	retal	r12
80016546:	d7 03       	nop

80016548 <__avr32_f64_div>:
80016548:	eb cd 40 ff 	pushm	r0-r7,lr
8001654c:	f7 e9 20 0e 	eor	lr,r11,r9
80016550:	f6 07 16 14 	lsr	r7,r11,0x14
80016554:	a9 7b       	lsl	r11,0x9
80016556:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8001655a:	a9 7a       	lsl	r10,0x9
8001655c:	bd bb       	sbr	r11,0x1d
8001655e:	e4 1b 3f ff 	andh	r11,0x3fff
80016562:	ab d7       	cbr	r7,0xb
80016564:	e0 80 00 cc 	breq	800166fc <__avr32_f64_div_round_subnormal+0x54>
80016568:	e0 47 07 ff 	cp.w	r7,2047
8001656c:	e0 84 00 b5 	brge	800166d6 <__avr32_f64_div_round_subnormal+0x2e>
80016570:	f2 06 16 14 	lsr	r6,r9,0x14
80016574:	a9 79       	lsl	r9,0x9
80016576:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8001657a:	a9 78       	lsl	r8,0x9
8001657c:	bd b9       	sbr	r9,0x1d
8001657e:	e4 19 3f ff 	andh	r9,0x3fff
80016582:	ab d6       	cbr	r6,0xb
80016584:	e0 80 00 e2 	breq	80016748 <__avr32_f64_div_round_subnormal+0xa0>
80016588:	e0 46 07 ff 	cp.w	r6,2047
8001658c:	e0 84 00 b2 	brge	800166f0 <__avr32_f64_div_round_subnormal+0x48>
80016590:	0c 17       	sub	r7,r6
80016592:	fe 37 fc 01 	sub	r7,-1023
80016596:	fc 1c 80 00 	movh	r12,0x8000
8001659a:	f8 03 16 01 	lsr	r3,r12,0x1
8001659e:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
800165a2:	5c d4       	com	r4
800165a4:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
800165a8:	e6 09 06 44 	mulu.d	r4,r3,r9
800165ac:	f8 05 01 25 	sub	r5,r12,r5<<0x2
800165b0:	e6 05 06 44 	mulu.d	r4,r3,r5
800165b4:	ea 03 15 02 	lsl	r3,r5,0x2
800165b8:	e6 09 06 44 	mulu.d	r4,r3,r9
800165bc:	f8 05 01 25 	sub	r5,r12,r5<<0x2
800165c0:	e6 05 06 44 	mulu.d	r4,r3,r5
800165c4:	ea 03 15 02 	lsl	r3,r5,0x2
800165c8:	e6 09 06 44 	mulu.d	r4,r3,r9
800165cc:	f8 05 01 25 	sub	r5,r12,r5<<0x2
800165d0:	e6 05 06 44 	mulu.d	r4,r3,r5
800165d4:	ea 03 15 02 	lsl	r3,r5,0x2
800165d8:	e6 08 06 40 	mulu.d	r0,r3,r8
800165dc:	e4 09 07 40 	macu.d	r0,r2,r9
800165e0:	e6 09 06 44 	mulu.d	r4,r3,r9
800165e4:	02 04       	add	r4,r1
800165e6:	5c 05       	acr	r5
800165e8:	a3 65       	lsl	r5,0x2
800165ea:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
800165ee:	a3 64       	lsl	r4,0x2
800165f0:	5c 34       	neg	r4
800165f2:	f8 05 01 45 	sbc	r5,r12,r5
800165f6:	e6 04 06 40 	mulu.d	r0,r3,r4
800165fa:	e4 05 07 40 	macu.d	r0,r2,r5
800165fe:	e6 05 06 44 	mulu.d	r4,r3,r5
80016602:	02 04       	add	r4,r1
80016604:	5c 05       	acr	r5
80016606:	ea 03 15 02 	lsl	r3,r5,0x2
8001660a:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8001660e:	e8 02 15 02 	lsl	r2,r4,0x2
80016612:	e6 08 06 40 	mulu.d	r0,r3,r8
80016616:	e4 09 07 40 	macu.d	r0,r2,r9
8001661a:	e6 09 06 44 	mulu.d	r4,r3,r9
8001661e:	02 04       	add	r4,r1
80016620:	5c 05       	acr	r5
80016622:	a3 65       	lsl	r5,0x2
80016624:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
80016628:	a3 64       	lsl	r4,0x2
8001662a:	5c 34       	neg	r4
8001662c:	f8 05 01 45 	sbc	r5,r12,r5
80016630:	e6 04 06 40 	mulu.d	r0,r3,r4
80016634:	e4 05 07 40 	macu.d	r0,r2,r5
80016638:	e6 05 06 44 	mulu.d	r4,r3,r5
8001663c:	02 04       	add	r4,r1
8001663e:	5c 05       	acr	r5
80016640:	ea 03 15 02 	lsl	r3,r5,0x2
80016644:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
80016648:	e8 02 15 02 	lsl	r2,r4,0x2
8001664c:	e6 0a 06 40 	mulu.d	r0,r3,r10
80016650:	e4 0b 07 40 	macu.d	r0,r2,r11
80016654:	e6 0b 06 42 	mulu.d	r2,r3,r11
80016658:	02 02       	add	r2,r1
8001665a:	5c 03       	acr	r3
8001665c:	ed b3 00 1c 	bld	r3,0x1c
80016660:	c0 90       	breq	80016672 <__avr32_f64_div+0x12a>
80016662:	a1 72       	lsl	r2,0x1
80016664:	5c f3       	rol	r3
80016666:	20 17       	sub	r7,1
80016668:	a3 9a       	lsr	r10,0x3
8001666a:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8001666e:	a3 9b       	lsr	r11,0x3
80016670:	c0 58       	rjmp	8001667a <__avr32_f64_div+0x132>
80016672:	a5 8a       	lsr	r10,0x4
80016674:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
80016678:	a5 8b       	lsr	r11,0x4
8001667a:	58 07       	cp.w	r7,0
8001667c:	e0 8a 00 8b 	brle	80016792 <__avr32_f64_div_res_subnormal>
80016680:	e0 12 ff 00 	andl	r2,0xff00
80016684:	e8 12 00 80 	orl	r2,0x80
80016688:	e6 08 06 40 	mulu.d	r0,r3,r8
8001668c:	e4 09 07 40 	macu.d	r0,r2,r9
80016690:	e4 08 06 44 	mulu.d	r4,r2,r8
80016694:	e6 09 06 48 	mulu.d	r8,r3,r9
80016698:	00 05       	add	r5,r0
8001669a:	f0 01 00 48 	adc	r8,r8,r1
8001669e:	5c 09       	acr	r9
800166a0:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
800166a4:	58 04       	cp.w	r4,0
800166a6:	5c 25       	cpc	r5

800166a8 <__avr32_f64_div_round_subnormal>:
800166a8:	f4 08 13 00 	cpc	r8,r10
800166ac:	f6 09 13 00 	cpc	r9,r11
800166b0:	5f 36       	srlo	r6
800166b2:	f8 06 17 00 	moveq	r6,r12
800166b6:	e4 0a 16 08 	lsr	r10,r2,0x8
800166ba:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
800166be:	e6 0b 16 08 	lsr	r11,r3,0x8
800166c2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
800166c6:	ed be 00 1f 	bld	lr,0x1f
800166ca:	ef bb 00 1f 	bst	r11,0x1f
800166ce:	0c 0a       	add	r10,r6
800166d0:	5c 0b       	acr	r11
800166d2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
800166d6:	e4 1b 00 0f 	andh	r11,0xf
800166da:	14 4b       	or	r11,r10
800166dc:	e0 81 00 a7 	brne	8001682a <__avr32_f64_div_res_subnormal+0x98>
800166e0:	f2 06 16 14 	lsr	r6,r9,0x14
800166e4:	ab d6       	cbr	r6,0xb
800166e6:	e0 46 07 ff 	cp.w	r6,2047
800166ea:	e0 81 00 a4 	brne	80016832 <__avr32_f64_div_res_subnormal+0xa0>
800166ee:	c9 e8       	rjmp	8001682a <__avr32_f64_div_res_subnormal+0x98>
800166f0:	e4 19 00 0f 	andh	r9,0xf
800166f4:	10 49       	or	r9,r8
800166f6:	e0 81 00 9a 	brne	8001682a <__avr32_f64_div_res_subnormal+0x98>
800166fa:	c9 28       	rjmp	8001681e <__avr32_f64_div_res_subnormal+0x8c>
800166fc:	a3 7b       	lsl	r11,0x3
800166fe:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
80016702:	a3 7a       	lsl	r10,0x3
80016704:	f5 eb 10 04 	or	r4,r10,r11
80016708:	e0 80 00 a0 	breq	80016848 <__avr32_f64_div_op1_zero>
8001670c:	f6 04 12 00 	clz	r4,r11
80016710:	c1 70       	breq	8001673e <__avr32_f64_div_round_subnormal+0x96>
80016712:	c0 c3       	brcs	8001672a <__avr32_f64_div_round_subnormal+0x82>
80016714:	e8 05 11 20 	rsub	r5,r4,32
80016718:	f6 04 09 4b 	lsl	r11,r11,r4
8001671c:	f4 05 0a 45 	lsr	r5,r10,r5
80016720:	0a 4b       	or	r11,r5
80016722:	f4 04 09 4a 	lsl	r10,r10,r4
80016726:	08 17       	sub	r7,r4
80016728:	c0 b8       	rjmp	8001673e <__avr32_f64_div_round_subnormal+0x96>
8001672a:	f4 04 12 00 	clz	r4,r10
8001672e:	f9 b4 03 00 	movlo	r4,0
80016732:	f7 b4 02 e0 	subhs	r4,-32
80016736:	f4 04 09 4b 	lsl	r11,r10,r4
8001673a:	30 0a       	mov	r10,0
8001673c:	08 17       	sub	r7,r4
8001673e:	a3 8a       	lsr	r10,0x2
80016740:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
80016744:	a3 8b       	lsr	r11,0x2
80016746:	c1 1b       	rjmp	80016568 <__avr32_f64_div+0x20>
80016748:	a3 79       	lsl	r9,0x3
8001674a:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8001674e:	a3 78       	lsl	r8,0x3
80016750:	f3 e8 10 04 	or	r4,r9,r8
80016754:	c6 f0       	breq	80016832 <__avr32_f64_div_res_subnormal+0xa0>
80016756:	f2 04 12 00 	clz	r4,r9
8001675a:	c1 70       	breq	80016788 <__avr32_f64_div_round_subnormal+0xe0>
8001675c:	c0 c3       	brcs	80016774 <__avr32_f64_div_round_subnormal+0xcc>
8001675e:	e8 05 11 20 	rsub	r5,r4,32
80016762:	f2 04 09 49 	lsl	r9,r9,r4
80016766:	f0 05 0a 45 	lsr	r5,r8,r5
8001676a:	0a 49       	or	r9,r5
8001676c:	f0 04 09 48 	lsl	r8,r8,r4
80016770:	08 16       	sub	r6,r4
80016772:	c0 b8       	rjmp	80016788 <__avr32_f64_div_round_subnormal+0xe0>
80016774:	f0 04 12 00 	clz	r4,r8
80016778:	f9 b4 03 00 	movlo	r4,0
8001677c:	f7 b4 02 e0 	subhs	r4,-32
80016780:	f0 04 09 49 	lsl	r9,r8,r4
80016784:	30 08       	mov	r8,0
80016786:	08 16       	sub	r6,r4
80016788:	a3 88       	lsr	r8,0x2
8001678a:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8001678e:	a3 89       	lsr	r9,0x2
80016790:	cf ca       	rjmp	80016588 <__avr32_f64_div+0x40>

80016792 <__avr32_f64_div_res_subnormal>:
80016792:	5c 37       	neg	r7
80016794:	2f f7       	sub	r7,-1
80016796:	f1 b7 04 c0 	satu	r7,0x6
8001679a:	e0 47 00 20 	cp.w	r7,32
8001679e:	c1 54       	brge	800167c8 <__avr32_f64_div_res_subnormal+0x36>
800167a0:	ee 06 11 20 	rsub	r6,r7,32
800167a4:	e4 07 0a 42 	lsr	r2,r2,r7
800167a8:	e6 06 09 4c 	lsl	r12,r3,r6
800167ac:	18 42       	or	r2,r12
800167ae:	e6 07 0a 43 	lsr	r3,r3,r7
800167b2:	f4 06 09 41 	lsl	r1,r10,r6
800167b6:	f4 07 0a 4a 	lsr	r10,r10,r7
800167ba:	f6 06 09 4c 	lsl	r12,r11,r6
800167be:	18 4a       	or	r10,r12
800167c0:	f6 07 0a 4b 	lsr	r11,r11,r7
800167c4:	30 00       	mov	r0,0
800167c6:	c1 58       	rjmp	800167f0 <__avr32_f64_div_res_subnormal+0x5e>
800167c8:	ee 06 11 20 	rsub	r6,r7,32
800167cc:	f9 b0 00 00 	moveq	r0,0
800167d0:	f9 bc 00 00 	moveq	r12,0
800167d4:	c0 50       	breq	800167de <__avr32_f64_div_res_subnormal+0x4c>
800167d6:	f4 06 09 40 	lsl	r0,r10,r6
800167da:	f6 06 09 4c 	lsl	r12,r11,r6
800167de:	e6 07 0a 42 	lsr	r2,r3,r7
800167e2:	30 03       	mov	r3,0
800167e4:	f4 07 0a 41 	lsr	r1,r10,r7
800167e8:	18 41       	or	r1,r12
800167ea:	f6 07 0a 4a 	lsr	r10,r11,r7
800167ee:	30 0b       	mov	r11,0
800167f0:	e0 12 ff 00 	andl	r2,0xff00
800167f4:	e8 12 00 80 	orl	r2,0x80
800167f8:	e6 08 06 46 	mulu.d	r6,r3,r8
800167fc:	e4 09 07 46 	macu.d	r6,r2,r9
80016800:	e4 08 06 44 	mulu.d	r4,r2,r8
80016804:	e6 09 06 48 	mulu.d	r8,r3,r9
80016808:	0c 05       	add	r5,r6
8001680a:	f0 07 00 48 	adc	r8,r8,r7
8001680e:	5c 09       	acr	r9
80016810:	30 07       	mov	r7,0
80016812:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
80016816:	00 34       	cp.w	r4,r0
80016818:	e2 05 13 00 	cpc	r5,r1
8001681c:	c4 6b       	rjmp	800166a8 <__avr32_f64_div_round_subnormal>
8001681e:	1c 9b       	mov	r11,lr
80016820:	e6 1b 80 00 	andh	r11,0x8000,COH
80016824:	30 0a       	mov	r10,0
80016826:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8001682a:	3f fb       	mov	r11,-1
8001682c:	30 0a       	mov	r10,0
8001682e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
80016832:	f5 eb 10 04 	or	r4,r10,r11
80016836:	c0 90       	breq	80016848 <__avr32_f64_div_op1_zero>
80016838:	1c 9b       	mov	r11,lr
8001683a:	e6 1b 80 00 	andh	r11,0x8000,COH
8001683e:	ea 1b 7f f0 	orh	r11,0x7ff0
80016842:	30 0a       	mov	r10,0
80016844:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

80016848 <__avr32_f64_div_op1_zero>:
80016848:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8001684c:	ce f0       	breq	8001682a <__avr32_f64_div_res_subnormal+0x98>
8001684e:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
80016852:	e0 44 07 ff 	cp.w	r4,2047
80016856:	ce 41       	brne	8001681e <__avr32_f64_div_res_subnormal+0x8c>
80016858:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8001685c:	ce 10       	breq	8001681e <__avr32_f64_div_res_subnormal+0x8c>
8001685e:	ce 6b       	rjmp	8001682a <__avr32_f64_div_res_subnormal+0x98>

80016860 <__avr32_umod64>:
80016860:	d4 31       	pushm	r0-r7,lr
80016862:	1a 97       	mov	r7,sp
80016864:	20 3d       	sub	sp,12
80016866:	10 9c       	mov	r12,r8
80016868:	12 95       	mov	r5,r9
8001686a:	14 9e       	mov	lr,r10
8001686c:	16 91       	mov	r1,r11
8001686e:	16 96       	mov	r6,r11
80016870:	58 09       	cp.w	r9,0
80016872:	e0 81 00 81 	brne	80016974 <__avr32_umod64+0x114>
80016876:	16 38       	cp.w	r8,r11
80016878:	e0 88 00 12 	brls	8001689c <__avr32_umod64+0x3c>
8001687c:	f0 08 12 00 	clz	r8,r8
80016880:	c4 e0       	breq	8001691c <__avr32_umod64+0xbc>
80016882:	f6 08 09 46 	lsl	r6,r11,r8
80016886:	f8 08 09 4c 	lsl	r12,r12,r8
8001688a:	f0 0b 11 20 	rsub	r11,r8,32
8001688e:	f4 08 09 4e 	lsl	lr,r10,r8
80016892:	f4 0b 0a 4b 	lsr	r11,r10,r11
80016896:	f7 e6 10 06 	or	r6,r11,r6
8001689a:	c4 18       	rjmp	8001691c <__avr32_umod64+0xbc>
8001689c:	58 08       	cp.w	r8,0
8001689e:	c0 51       	brne	800168a8 <__avr32_umod64+0x48>
800168a0:	30 19       	mov	r9,1
800168a2:	f2 08 0d 08 	divu	r8,r9,r8
800168a6:	10 9c       	mov	r12,r8
800168a8:	f8 08 12 00 	clz	r8,r12
800168ac:	c0 31       	brne	800168b2 <__avr32_umod64+0x52>
800168ae:	18 16       	sub	r6,r12
800168b0:	c3 68       	rjmp	8001691c <__avr32_umod64+0xbc>
800168b2:	f0 03 11 20 	rsub	r3,r8,32
800168b6:	f4 03 0a 4b 	lsr	r11,r10,r3
800168ba:	f8 08 09 4c 	lsl	r12,r12,r8
800168be:	ec 08 09 49 	lsl	r9,r6,r8
800168c2:	ec 03 0a 43 	lsr	r3,r6,r3
800168c6:	f7 e9 10 09 	or	r9,r11,r9
800168ca:	f8 05 16 10 	lsr	r5,r12,0x10
800168ce:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
800168d2:	e6 05 0d 02 	divu	r2,r3,r5
800168d6:	f2 0e 16 10 	lsr	lr,r9,0x10
800168da:	ec 02 02 4b 	mul	r11,r6,r2
800168de:	fd e3 11 0e 	or	lr,lr,r3<<0x10
800168e2:	16 3e       	cp.w	lr,r11
800168e4:	c0 72       	brcc	800168f2 <__avr32_umod64+0x92>
800168e6:	18 0e       	add	lr,r12
800168e8:	18 3e       	cp.w	lr,r12
800168ea:	c0 43       	brcs	800168f2 <__avr32_umod64+0x92>
800168ec:	16 3e       	cp.w	lr,r11
800168ee:	fd dc e3 0e 	addcs	lr,lr,r12
800168f2:	fc 0b 01 03 	sub	r3,lr,r11
800168f6:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
800168fa:	e6 05 0d 02 	divu	r2,r3,r5
800168fe:	f3 e3 11 09 	or	r9,r9,r3<<0x10
80016902:	a5 36       	mul	r6,r2
80016904:	0c 39       	cp.w	r9,r6
80016906:	c0 72       	brcc	80016914 <__avr32_umod64+0xb4>
80016908:	18 09       	add	r9,r12
8001690a:	18 39       	cp.w	r9,r12
8001690c:	c0 43       	brcs	80016914 <__avr32_umod64+0xb4>
8001690e:	0c 39       	cp.w	r9,r6
80016910:	f3 dc e3 09 	addcs	r9,r9,r12
80016914:	f2 06 01 06 	sub	r6,r9,r6
80016918:	f4 08 09 4e 	lsl	lr,r10,r8
8001691c:	f8 0a 16 10 	lsr	r10,r12,0x10
80016920:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
80016924:	ec 0a 0d 02 	divu	r2,r6,r10
80016928:	fc 09 16 10 	lsr	r9,lr,0x10
8001692c:	ea 02 02 4b 	mul	r11,r5,r2
80016930:	f3 e3 11 09 	or	r9,r9,r3<<0x10
80016934:	16 39       	cp.w	r9,r11
80016936:	c0 72       	brcc	80016944 <__avr32_umod64+0xe4>
80016938:	18 09       	add	r9,r12
8001693a:	18 39       	cp.w	r9,r12
8001693c:	c0 43       	brcs	80016944 <__avr32_umod64+0xe4>
8001693e:	16 39       	cp.w	r9,r11
80016940:	f3 dc e3 09 	addcs	r9,r9,r12
80016944:	f2 0b 01 0b 	sub	r11,r9,r11
80016948:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8001694c:	f6 0a 0d 0a 	divu	r10,r11,r10
80016950:	fd eb 11 0e 	or	lr,lr,r11<<0x10
80016954:	ea 0a 02 4a 	mul	r10,r5,r10
80016958:	14 3e       	cp.w	lr,r10
8001695a:	c0 72       	brcc	80016968 <__avr32_umod64+0x108>
8001695c:	18 0e       	add	lr,r12
8001695e:	18 3e       	cp.w	lr,r12
80016960:	c0 43       	brcs	80016968 <__avr32_umod64+0x108>
80016962:	14 3e       	cp.w	lr,r10
80016964:	fd dc e3 0e 	addcs	lr,lr,r12
80016968:	fc 0a 01 0a 	sub	r10,lr,r10
8001696c:	30 0b       	mov	r11,0
8001696e:	f4 08 0a 4a 	lsr	r10,r10,r8
80016972:	c7 b8       	rjmp	80016a68 <__avr32_umod64+0x208>
80016974:	16 39       	cp.w	r9,r11
80016976:	e0 8b 00 79 	brhi	80016a68 <__avr32_umod64+0x208>
8001697a:	f2 09 12 00 	clz	r9,r9
8001697e:	c1 21       	brne	800169a2 <__avr32_umod64+0x142>
80016980:	10 3a       	cp.w	r10,r8
80016982:	5f 2b       	srhs	r11
80016984:	0a 31       	cp.w	r1,r5
80016986:	5f ba       	srhi	r10
80016988:	f7 ea 10 0a 	or	r10,r11,r10
8001698c:	f2 0a 18 00 	cp.b	r10,r9
80016990:	c0 60       	breq	8001699c <__avr32_umod64+0x13c>
80016992:	fc 08 01 0c 	sub	r12,lr,r8
80016996:	e2 05 01 46 	sbc	r6,r1,r5
8001699a:	18 9e       	mov	lr,r12
8001699c:	0c 9b       	mov	r11,r6
8001699e:	1c 9a       	mov	r10,lr
800169a0:	c6 48       	rjmp	80016a68 <__avr32_umod64+0x208>
800169a2:	ea 09 09 4c 	lsl	r12,r5,r9
800169a6:	f2 06 11 20 	rsub	r6,r9,32
800169aa:	f6 09 09 4b 	lsl	r11,r11,r9
800169ae:	f0 09 09 42 	lsl	r2,r8,r9
800169b2:	ef 46 ff f4 	st.w	r7[-12],r6
800169b6:	f0 06 0a 48 	lsr	r8,r8,r6
800169ba:	18 48       	or	r8,r12
800169bc:	e2 06 0a 4c 	lsr	r12,r1,r6
800169c0:	f4 09 09 43 	lsl	r3,r10,r9
800169c4:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
800169c8:	f4 06 0a 4a 	lsr	r10,r10,r6
800169cc:	16 4a       	or	r10,r11
800169ce:	f0 0b 16 10 	lsr	r11,r8,0x10
800169d2:	f8 0b 0d 04 	divu	r4,r12,r11
800169d6:	f4 0c 16 10 	lsr	r12,r10,0x10
800169da:	08 91       	mov	r1,r4
800169dc:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
800169e0:	e8 0e 02 46 	mul	r6,r4,lr
800169e4:	0c 3c       	cp.w	r12,r6
800169e6:	c0 a2       	brcc	800169fa <__avr32_umod64+0x19a>
800169e8:	20 11       	sub	r1,1
800169ea:	10 0c       	add	r12,r8
800169ec:	10 3c       	cp.w	r12,r8
800169ee:	c0 63       	brcs	800169fa <__avr32_umod64+0x19a>
800169f0:	0c 3c       	cp.w	r12,r6
800169f2:	f7 b1 03 01 	sublo	r1,1
800169f6:	f9 d8 e3 0c 	addcs	r12,r12,r8
800169fa:	0c 1c       	sub	r12,r6
800169fc:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
80016a00:	f8 0b 0d 04 	divu	r4,r12,r11
80016a04:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
80016a08:	08 96       	mov	r6,r4
80016a0a:	e8 0e 02 4e 	mul	lr,r4,lr
80016a0e:	1c 3b       	cp.w	r11,lr
80016a10:	c0 a2       	brcc	80016a24 <__avr32_umod64+0x1c4>
80016a12:	20 16       	sub	r6,1
80016a14:	10 0b       	add	r11,r8
80016a16:	10 3b       	cp.w	r11,r8
80016a18:	c0 63       	brcs	80016a24 <__avr32_umod64+0x1c4>
80016a1a:	1c 3b       	cp.w	r11,lr
80016a1c:	f7 b6 03 01 	sublo	r6,1
80016a20:	f7 d8 e3 0b 	addcs	r11,r11,r8
80016a24:	ed e1 11 01 	or	r1,r6,r1<<0x10
80016a28:	1c 1b       	sub	r11,lr
80016a2a:	e2 02 06 40 	mulu.d	r0,r1,r2
80016a2e:	00 9e       	mov	lr,r0
80016a30:	02 9c       	mov	r12,r1
80016a32:	16 3c       	cp.w	r12,r11
80016a34:	e0 8b 00 08 	brhi	80016a44 <__avr32_umod64+0x1e4>
80016a38:	5f 06       	sreq	r6
80016a3a:	06 30       	cp.w	r0,r3
80016a3c:	5f ba       	srhi	r10
80016a3e:	ed ea 00 0a 	and	r10,r6,r10
80016a42:	c0 60       	breq	80016a4e <__avr32_umod64+0x1ee>
80016a44:	fc 02 01 04 	sub	r4,lr,r2
80016a48:	f8 08 01 4c 	sbc	r12,r12,r8
80016a4c:	08 9e       	mov	lr,r4
80016a4e:	e6 0e 01 0a 	sub	r10,r3,lr
80016a52:	f6 0c 01 4c 	sbc	r12,r11,r12
80016a56:	ee f1 ff f4 	ld.w	r1,r7[-12]
80016a5a:	f8 09 0a 4b 	lsr	r11,r12,r9
80016a5e:	f4 09 0a 4a 	lsr	r10,r10,r9
80016a62:	f8 01 09 4c 	lsl	r12,r12,r1
80016a66:	18 4a       	or	r10,r12
80016a68:	2f dd       	sub	sp,-12
80016a6a:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

80016c00 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
80016c00:	c0 08       	rjmp	80016c00 <_evba>
	...

80016c04 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
80016c04:	c0 08       	rjmp	80016c04 <_handle_TLB_Multiple_Hit>
	...

80016c08 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
80016c08:	c0 08       	rjmp	80016c08 <_handle_Bus_Error_Data_Fetch>
	...

80016c0c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
80016c0c:	c0 08       	rjmp	80016c0c <_handle_Bus_Error_Instruction_Fetch>
	...

80016c10 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
80016c10:	c0 08       	rjmp	80016c10 <_handle_NMI>
	...

80016c14 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
80016c14:	c0 08       	rjmp	80016c14 <_handle_Instruction_Address>
	...

80016c18 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
80016c18:	c0 08       	rjmp	80016c18 <_handle_ITLB_Protection>
	...

80016c1c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
80016c1c:	c0 08       	rjmp	80016c1c <_handle_Breakpoint>
	...

80016c20 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
80016c20:	c0 08       	rjmp	80016c20 <_handle_Illegal_Opcode>
	...

80016c24 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
80016c24:	c0 08       	rjmp	80016c24 <_handle_Unimplemented_Instruction>
	...

80016c28 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
80016c28:	c0 08       	rjmp	80016c28 <_handle_Privilege_Violation>
	...

80016c2c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR32UC and AVR32AP.
_handle_Floating_Point:
	rjmp $
80016c2c:	c0 08       	rjmp	80016c2c <_handle_Floating_Point>
	...

80016c30 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
	rjmp $
80016c30:	c0 08       	rjmp	80016c30 <_handle_Coprocessor_Absent>
	...

80016c34 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
80016c34:	c0 08       	rjmp	80016c34 <_handle_Data_Address_Read>
	...

80016c38 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
80016c38:	c0 08       	rjmp	80016c38 <_handle_Data_Address_Write>
	...

80016c3c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
80016c3c:	c0 08       	rjmp	80016c3c <_handle_DTLB_Protection_Read>
	...

80016c40 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
80016c40:	c0 08       	rjmp	80016c40 <_handle_DTLB_Protection_Write>
	...

80016c44 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
80016c44:	c0 08       	rjmp	80016c44 <_handle_DTLB_Modified>
	...

80016c50 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
80016c50:	c0 08       	rjmp	80016c50 <_handle_ITLB_Miss>
	...

80016c60 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
80016c60:	c0 08       	rjmp	80016c60 <_handle_DTLB_Miss_Read>
	...

80016c70 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
80016c70:	c0 08       	rjmp	80016c70 <_handle_DTLB_Miss_Write>
	...

80016d00 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	rjmp $
80016d00:	c0 08       	rjmp	80016d00 <_handle_Supervisor_Call>
80016d02:	d7 03       	nop

80016d04 <_int0>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80016d04:	30 0c       	mov	r12,0
80016d06:	fe b0 a5 c1 	rcall	8000b888 <_get_interrupt_handler>
80016d0a:	58 0c       	cp.w	r12,0
80016d0c:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80016d10:	d6 03       	rete

80016d12 <_int1>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80016d12:	30 1c       	mov	r12,1
80016d14:	fe b0 a5 ba 	rcall	8000b888 <_get_interrupt_handler>
80016d18:	58 0c       	cp.w	r12,0
80016d1a:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80016d1e:	d6 03       	rete

80016d20 <_int2>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80016d20:	30 2c       	mov	r12,2
80016d22:	fe b0 a5 b3 	rcall	8000b888 <_get_interrupt_handler>
80016d26:	58 0c       	cp.w	r12,0
80016d28:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80016d2c:	d6 03       	rete

80016d2e <_int3>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80016d2e:	30 3c       	mov	r12,3
80016d30:	fe b0 a5 ac 	rcall	8000b888 <_get_interrupt_handler>
80016d34:	58 0c       	cp.w	r12,0
80016d36:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80016d3a:	d6 03       	rete
80016d3c:	d7 03       	nop
80016d3e:	d7 03       	nop
80016d40:	d7 03       	nop
80016d42:	d7 03       	nop
80016d44:	d7 03       	nop
80016d46:	d7 03       	nop
80016d48:	d7 03       	nop
80016d4a:	d7 03       	nop
80016d4c:	d7 03       	nop
80016d4e:	d7 03       	nop
80016d50:	d7 03       	nop
80016d52:	d7 03       	nop
80016d54:	d7 03       	nop
80016d56:	d7 03       	nop
80016d58:	d7 03       	nop
80016d5a:	d7 03       	nop
80016d5c:	d7 03       	nop
80016d5e:	d7 03       	nop
80016d60:	d7 03       	nop
80016d62:	d7 03       	nop
80016d64:	d7 03       	nop
80016d66:	d7 03       	nop
80016d68:	d7 03       	nop
80016d6a:	d7 03       	nop
80016d6c:	d7 03       	nop
80016d6e:	d7 03       	nop
80016d70:	d7 03       	nop
80016d72:	d7 03       	nop
80016d74:	d7 03       	nop
80016d76:	d7 03       	nop
80016d78:	d7 03       	nop
80016d7a:	d7 03       	nop
80016d7c:	d7 03       	nop
80016d7e:	d7 03       	nop
80016d80:	d7 03       	nop
80016d82:	d7 03       	nop
80016d84:	d7 03       	nop
80016d86:	d7 03       	nop
80016d88:	d7 03       	nop
80016d8a:	d7 03       	nop
80016d8c:	d7 03       	nop
80016d8e:	d7 03       	nop
80016d90:	d7 03       	nop
80016d92:	d7 03       	nop
80016d94:	d7 03       	nop
80016d96:	d7 03       	nop
80016d98:	d7 03       	nop
80016d9a:	d7 03       	nop
80016d9c:	d7 03       	nop
80016d9e:	d7 03       	nop
80016da0:	d7 03       	nop
80016da2:	d7 03       	nop
80016da4:	d7 03       	nop
80016da6:	d7 03       	nop
80016da8:	d7 03       	nop
80016daa:	d7 03       	nop
80016dac:	d7 03       	nop
80016dae:	d7 03       	nop
80016db0:	d7 03       	nop
80016db2:	d7 03       	nop
80016db4:	d7 03       	nop
80016db6:	d7 03       	nop
80016db8:	d7 03       	nop
80016dba:	d7 03       	nop
80016dbc:	d7 03       	nop
80016dbe:	d7 03       	nop
80016dc0:	d7 03       	nop
80016dc2:	d7 03       	nop
80016dc4:	d7 03       	nop
80016dc6:	d7 03       	nop
80016dc8:	d7 03       	nop
80016dca:	d7 03       	nop
80016dcc:	d7 03       	nop
80016dce:	d7 03       	nop
80016dd0:	d7 03       	nop
80016dd2:	d7 03       	nop
80016dd4:	d7 03       	nop
80016dd6:	d7 03       	nop
80016dd8:	d7 03       	nop
80016dda:	d7 03       	nop
80016ddc:	d7 03       	nop
80016dde:	d7 03       	nop
80016de0:	d7 03       	nop
80016de2:	d7 03       	nop
80016de4:	d7 03       	nop
80016de6:	d7 03       	nop
80016de8:	d7 03       	nop
80016dea:	d7 03       	nop
80016dec:	d7 03       	nop
80016dee:	d7 03       	nop
80016df0:	d7 03       	nop
80016df2:	d7 03       	nop
80016df4:	d7 03       	nop
80016df6:	d7 03       	nop
80016df8:	d7 03       	nop
80016dfa:	d7 03       	nop
80016dfc:	d7 03       	nop
80016dfe:	d7 03       	nop
